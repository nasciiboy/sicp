@ -*- mode: org; -*-
..title    > Estructura e Interpretacion de programas informaticos
..subtitle > @e(Segunda Edicion) Formato morg No oficial
..copy     > 1996 Massachusetts Institute of Technology
..licence  > CC BY-SA 4.0
..author   > Harold Abelson and Gerald Jay Sussman with Julie Sussman
..style    > worg-data/worg.css
..options  > mathJax fancyCode toc

@ dircategory The Algorithmic Language Scheme
@ utfversion      2.andresraba6.6
@ utfversiondate  September 16, 2015
@ ↵ ƒ ⟨⟩

# ..pret >
..pret >
#   by Harold Abelson and Gerald Jay Sussman, with Julie Sussman
#   foreword by Alan J. Perlis
  por Harold Abelson y Gerald Jay Sussman, con Julie Sussman
  prologo por Alan J. Perlis

# This work is licensed under a Creative Commons Attribution-ShareAlike 4.0
# International License (@l(http://creativecommons.org/licenses/by-sa/4.0/<>@A(CC
# BY-SA 4.0))). Based on a work at @l(http://mitpress.mit.edu/sicp/<>mitpress.mit.edu).
Este trabajo esta licenciado bajo una licencia Creative Commons
Attribution-ShareAlike 4.0 International (@l(http://creativecommons.org/licenses/by-sa/4.0/<>@A(CC BY-SA 4.0))).
Basado en una obra de @l(http://mitpress.mit.edu/sicp/<>mitpress.mit.edu).

# ..pret >
..pret >
#   The @A(MIT) Press
#   Cambridge, Massachusetts
#   London, England
  The @A(MIT) Press
  Cambridge, Massachusetts
  London, England

# ..pret >
..pret >
#   McGraw-Hill Book Company
#   New York, St. Louis, San Francisco,
#   Montreal, Toronto
  McGraw-Hill Book Company
  New York, St. Louis, San Francisco,
  Montreal, Toronto

# This book is one of a series of texts written by faculty of the Electrical
# Engineering and Computer Science Department at the Massachusetts Institute of
# Technology. It was edited and produced by The @A(MIT) Press under a joint
# production-distribution arrangement with the McGraw-Hill Book Company.
Este libro es uno de una serie de textos escritos por la facultad del
Departamento de Ingeniería Eléctrica y Ciencias de la Computación del Instituto
de Tecnología de Massachusetts. Fue editado y producido por The @A(MIT) Press
bajo un acuerdo conjunto de producción y distribución con McGraw-Hill Book
Company.

# * Unofficial @e(morg) Format
* Formato @e(morg) No Oficial

#   This is the second edition @A(SICP) book, from Unofficial morg Format.
  Esta es la segunda edicion del libro @A(SICP), @e(no oficial) en formato morg.

#   This @l(https://github.com/nasciiboy/morg/<>morg) version is based on
#   Unofficial Texinfo Format @l(http://sicpebook.wordpress.com) (July 07, 2017),
#   based on @l(http://www.neilvandyke.org/sicp-texi/<>2.neilvandyke4).
  Esta versión en formato @l(https://github.com/nasciiboy/morg/<>morg) se basa
  en la version no oficial @l(http://sicpebook.wordpress.com/<>sicpebook) en
  formato Texinfo (Julio 07, 2017), basada en la version no oficial
  @l(http://www.neilvandyke.org/sicp-texi/<>2.neilvandyke4) convertida desde la
  @l(http://mitpress.mit.edu/sicp/<>version HTML) original de MIT Press.

#   The freely-distributed official @A(HTML)-and-@A(GIF) format was first
#   converted personally to Unofficial Texinfo Format (@A(UTF)) version 1 by Lytha
#   Ayth during a long Emacs lovefest weekend in April, 2001.
  El formato oficial @A(HTML)-and-@A(GIF) distribuido libremente primero fue
  convertido personalmente al formato no oficial Texinfo (@A(UTF)) versión 1 por
  Lytha Ayth durante un lango fin de semana del festival del amor Emacs en abril
  de 2001.

#   The Texinfo conversion has been a straight transliteration, to the extent
#   possible. Like the @e(morg)-to-@A(HTML) conversion, this was not without some
#   introduction of breakage. In the case of Unofficial morg Format, figures
#   have suffered an amateurish resurrection of the lost art of @A(ASCII) (and
#   Unicode). Also, it's quite possible that some errors of ambiguity were
#   introduced during the conversion of some of the copious superscripts (@'(^))
#   and subscripts (@'(_)).  Divining @e(which) has been left as an exercise to
#   the reader.
  La conversión de Texinfo ha sido una transliteración directa, en la medida de
  lo posible. Al igual que la conversión @e(morg)-a-@A(HTML), esto no fue sin
  introducir alguna inconsistencia. En el caso de formato morg No oficial, las
  figuras han sufrido una resurrección aficionada del perdido arte @A(ASCII) (y
  Unicode). Además, es muy posible que se introdujeran algunos errores de
  ambigüedad durante la conversión de algunos de los copiosos superíndices
  (@'(^)) Y subíndices (@'(_)). Siempre que fue posible, se utilizaron
  caracteres unicode, para substituir super y sub indices (y otros simbolos), no
  obstante, en algunos casos esto no fue posible, por lo que se prefirio colocar
  una equivalencia en formato @e(TeX). Adivinar @e(cuales) se deja como
  ejercicio al lector.

#   It is believed that the Unofficial Texinfo Format is in keeping with the
#   spirit of the graciously freely-distributed @A(HTML) version. But you never
#   know when someone's armada of lawyers might need something to do, and get
#   their shorts all in a knot over some benign little thing, so think twice
#   before you use your full name or distribute Info, @A(DVI), PostScript, or
#   @A(PDF) formats that might embed your account or machine name. @i(Peath,
#   Lytha Ayth)
  Se cree que el formato morg No oficial está en consonancia con el espíritu de
  la versión @A(HTML) graciosamente distribuida-libremente. Pero nunca se sabe
  cuando la armada de los abogados de alguien necesitaría algo por hacer, y
  obtener sus pantalones cortos en un nudo sobre algo poco benigno, así que
  piense dos veces antes de usar su nombre completo o distribuir una version en
  otros formatos que puedan incrustar el nombre de su cuenta o máquina.
  @i(Peath, Lytha Ayth)

# * Dedication
* Dedicación

#   This book is dedicated, in respect and admiration, to the spirit that lives in
#   the computer.
  Este libro está dedicado, con respeto y admiración, al espíritu que vive en la
  computadora.

#   ..quote >
  ..quote >
#     @"(I think that it's extraordinarily important that we in computer science
#     keep fun in computing. When it started out, it was an awful lot of fun. Of
#     course, the paying customers got shafted every now and then, and after a
#     while we began to take their complaints seriously. We began to feel as if
#     we really were responsible for the successful, error-free perfect use of
#     these machines. I don't think we are. I think we're responsible for
#     stretching them, setting them off in new directions, and keeping fun in the
#     house. I hope the field of computer science never loses its sense of fun.
#     Above all, I hope we don't become missionaries. Don't feel as if you're
#     Bible salesmen. The world has too many of those already. What you know
#     about computing other people will learn. Don't feel as if the key to
#     successful computing is only in your hands. What's in your hands, I think
#     and hope, is intelligence: the ability to see the machine as more than when
#     you were first led up to it, that you can make it more.)
    @"(Creo que es extraordinariamente importante que sigamos manteniendo la
    diversion en las ciencias de la computacion. Cuando empezó, fue muy
    divertido. Por supuesto, los clientes que pagaban se quejaban de vez en
    cuando, y después de un rato comenzamos a tomar sus quejas
    seriamente. Empezamos a sentirnos como si realmente fuésemos responsables
    del uso exitoso y libre de errores de estas máquinas. No creo que lo
    seamos. Creo que somos responsables de extenderlas, de ponerlas en nuevas
    direcciones y de divertirnos en casa. Espero que el campo de la informática
    nunca pierda su sentido de la diversión. Sobre todo, espero que no seamos
    misioneros. No te sientas fueras un vendedor de Biblias. El mundo ya tiene
    demasiadas. Lo que conoses sobre la computación otras personas lo
    aprenderán. No sientas como si la clave para el exito de la computación
    estubiera solamente en tus manos. Lo que está en tus manos, creo y espero,
    es la inteligencia: la capacidad de ver la máquina como algo más que cuando
    te condujeron a ella, para que la puedas hacer más.)

#     --Alan J. Perlis (April 1, 1922−February 7, 1990)
    --Alan J. Perlis (Abril 1 de 1922−Febrero 7 de 1990)
#   < quote..
  < quote..

# * Foreword
* Prefacio

#   Educators, generals, dieticians, psychologists, and parents program. Armies,
#   students, and some societies are programmed. An assault on large problems
#   employs a succession of programs, most of which spring into existence en
#   route. These programs are rife with issues that appear to be particular to
#   the problem at hand. To appreciate programming as an intellectual activity in
#   its own right you must turn to computer programming; you must read and write
#   computer programs––many of them. It doesn't matter much what the programs
#   are about or what applications they serve. What does matter is how well they
#   perform and how smoothly they fit with other programs in the creation of still
#   greater programs. The programmer must seek both perfection of part and
#   adequacy of collection. In this book the use of @"(program) is focused on the
#   creation, execution, and study of programs written in a dialect of Lisp for
#   execution on a digital computer. Using Lisp we restrict or limit not what we
#   may program, but only the notation for our program descriptions.
  Educadores, generales, dietistas, psicólogos y padres. Ejércitos, estudiantes
  y algunas sociedades están programando. Un asalto a grandes problemas emplea
  una sucesión de programas, la mayoría de los cuales surgen en el camino. Estos
  programas están llenos de problemas que parecen ser particulares al problema
  actual. Para apreciar la programación como una actividad intelectual por
  derecho propio, debe recurrir a la programación de computadoras; Usted debe
  leer y escribir programas de computadora––muchos de ellos. No importa mucho lo
  que sean los programas o a qué aplicaciones sirven. Lo que sí importa es lo
  bien que funcionan y cómo se adaptan sin problemas a otros programas en la
  creación de programas aún mayores. El programador debe buscar tanto la
  perfección de la parte como la suficiencia de la colección. En este libro el
  uso de @"(programa) se centra en la creación, ejecución y estudio de programas
  escritos en un dialecto de Lisp para su ejecución en un computador
  digital. Usando Lisp restringimos o limitamos no lo que podemos programar,
  sino solo la notación para nuestras descripciones del programa.

#   Our traffic with the subject matter of this book involves us with three foci of
#   phenomena: the human mind, collections of computer programs, and the computer.
#   Every computer program is a model, hatched in the mind, of a real or mental
#   process. These processes, arising from human experience and thought, are huge
#   in number, intricate in detail, and at any time only partially understood.
#   They are modeled to our permanent satisfaction rarely by our computer programs.
#   Thus even though our programs are carefully handcrafted discrete collections of
#   symbols, mosaics of interlocking functions, they continually evolve: we change
#   them as our perception of the model deepens, enlarges, generalizes until the
#   model ultimately attains a metastable place within still another model with
#   which we struggle. The source of the exhilaration associated with computer
#   programming is the continual unfolding within the mind and on the computer of
#   mechanisms expressed as programs and the explosion of perception they generate.
#   If art interprets our dreams, the computer executes them in the guise of
#   programs!
  Nuestro tráfico con el tema de este libro nos involucra con tres focos de
  fenómenos: la mente humana, las colecciones de programas de computadora y la
  computadora. Cada programa de computadora es un modelo, nacido en la mente, de
  un proceso real o mental. Estos procesos, que surgen de la experiencia y el
  pensamiento humanos, son enormes en número, intrincados en detalle y en
  cualquier momento sólo parcialmente comprendidos. Son modelados a nuestra
  satisfacción raramente permanente por nuestros programas de computadora. Así,
  aunque nuestros programas son cuidadosamente hechos a mano apartir de
  colecciones discretas de símbolos, mosaicos de funciones entrelazadas,
  evolucionan continuamente: los cambiamos a medida que nuestra percepción del
  modelo se profundiza, se agranda, generaliza hasta que el modelo finalmente
  alcanza un lugar metaestable dentro de otro modelo con el cual Nosotros
  luchamos. La fuente de la alegría asociada con la programación de computadoras
  es el despliegue continuo dentro de la mente y la computadora de los
  mecanismos expresados como programas y la explosión de la percepción que
  generan. Si el arte interpreta nuestros sueños, la computadora los ejecuta en
  forma de programas!

#   For all its power, the computer is a harsh taskmaster. Its programs must be
#   correct, and what we wish to say must be said accurately in every detail. As
#   in every other symbolic activity, we become convinced of program truth through
#   argument. Lisp itself can be assigned a semantics (another model, by the way),
#   and if a program's function can be specified, say, in the predicate calculus,
#   the proof methods of logic can be used to make an acceptable correctness
#   argument. Unfortunately, as programs get large and complicated, as they almost
#   always do, the adequacy, consistency, and correctness of the specifications
#   themselves become open to doubt, so that complete formal arguments of
#   correctness seldom accompany large programs. Since large programs grow from
#   small ones, it is crucial that we develop an arsenal of standard program
#   structures of whose correctness we have become sure––we call them idioms––and
#   learn to combine them into larger structures using organizational techniques of
#   proven value. These techniques are treated at length in this book, and
#   understanding them is essential to participation in the Promethean enterprise
#   called programming. More than anything else, the uncovering and mastery of
#   powerful organizational techniques accelerates our ability to create large,
#   significant programs. Conversely, since writing large programs is very taxing,
#   we are stimulated to invent new methods of reducing the mass of function and
#   detail to be fitted into large programs.
  A pesar de todo su poder, la computadora es un duro maestro. Sus programas
  deben ser correctos, y lo que deseamos decir debe decirse con precisión en
  cada detalle. Como en cualquier otra actividad simbólica, nos convencemos de
  la verdad del programa mediante el argumento. A Lisp se puede asignar una
  semántica (otro modelo, por cierto), y si la función de un programa se puede
  especificar, digamos, en el cálculo de predicados, los métodos de prueba de la
  lógica se puede utilizar para hacer un argumento de corrección aceptable.
  Desafortunadamente, a medida que los programas se hacen grandes y complicados,
  como casi siempre lo hacen, la adecuación, consistencia y corrección de las
  propias especificaciones se vuelven abiertas a la duda, de modo que los
  argumentos formales de corrección raramente acompañan a los grandes
  programas. Puesto que los programas grandes crecen a partir de los pequeños,
  Es crucial que desarrollemos un arsenal de estructuras de programa estándar de
  cuya exactituc nos hemos asegurado––los llamamos lenguajes––y aprendemos a
  combinarlos en estructuras más grandes utilizando técnicas organizativas de
  probado valor. Estas técnicas se tratan extensamente en este libro, y
  entenderlas es esencial para la participación en la empresa prometheana
  llamada programación. Más que nada, el descubrimiento y el dominio de
  poderosas técnicas organizativas acelera nuestra capacidad de crear programas
  grandes e importantes. Inversamente, puesto que escribir grandes programas es
  muy agotador, estamos estimulados a inventar nuevos métodos para reducir la
  masa de funciones y detalles que se incorporarán en grandes programas.

#   Unlike programs, computers must obey the laws of physics. If they wish to
#   perform rapidly––a few nanoseconds per state change––they must transmit
#   electrons only small distances (at most @m(1 ½) feet). The heat generated by
#   the huge number of devices so concentrated in space has to be removed. An
#   exquisite engineering art has been developed balancing between multiplicity of
#   function and density of devices. In any event, hardware always operates at a
#   level more primitive than that at which we care to program. The processes
#   that transform our Lisp programs to @"(machine) programs are themselves
#   abstract models which we program. Their study and creation give a great deal
#   of insight into the organizational programs associated with programming
#   arbitrary models. Of course the computer itself can be so modeled. Think of
#   it: the behavior of the smallest physical switching element is modeled by
#   quantum mechanics described by differential equations whose detailed behavior
#   is captured by numerical approximations represented in computer programs
#   executing on computers composed of …!
  A diferencia de los programas, las computadoras deben obedecer las leyes de la
  física. Si se desea que funcionen rápidamente––unos pocos nanosegundos por
  cambio de estado––deben transmitir electrones sólo a pequeñas distancias (como
  máximo @m(1 ½) pies). El calor generado por el gran número de dispositivos tan
  concentrados en ese espacio tiene que ser eliminado. Se ha desarrollado un
  exquisito arte de ingeniería que equilibra entre multiplicidad de funciones y
  densidad de dispositivos. En cualquier caso, el hardware siempre opera a un
  nivel más primitivo que el que queremos programar. Los procesos que
  transforman nuestros programas Lisp en programas @"(máquina) son modelos
  abstractos que nosotros programamos. Su estudio y creación dan una gran
  cantidad de información sobre los programas organizativos asociados con la
  programación de modelos arbitrarios. Por supuesto, la propia computadora puede
  ser modelada. Piense en ello: el comportamiento del elemento de conmutación
  física más pequeño es modelado por la mecánica cuántica descrita por
  ecuaciones diferenciales cuyo comportamiento detallado es capturado por
  aproximaciones numéricas representadas en programas de computadora
  ejecutándose en computadoras compuestas de …!

#   It is not merely a matter of tactical convenience to separately identify the
#   three foci. Even though, as they say, it's all in the head, this logical
#   separation induces an acceleration of symbolic traffic between these foci
#   whose richness, vitality, and potential is exceeded in human experience only
#   by the evolution of life itself. At best, relationships between the foci are
#   metastable. The computers are never large enough or fast enough. Each
#   breakthrough in hardware technology leads to more massive programming
#   enterprises, new organizational principles, and an enrichment of abstract
#   models. Every reader should ask himself periodically @"(Toward what end,
#   toward what end?)––but do not ask it too often lest you pass up the fun of
#   programming for the constipation of bittersweet philosophy.
  No es meramente una cuestión de conveniencia táctica identificar por separado
  los tres focos. Aun cuando, como dicen, todo está en la cabeza, esta
  separación lógica induce una aceleración del tráfico simbólico entre estos
  focos cuya riqueza, vitalidad y potencial se superan en la experiencia humana
  sólo por la evolución de la vida misma. En el mejor de los casos, las
  relaciones entre los focos son metastables. Las computadoras nunca son lo
  suficientemente grandes o lo suficientemente rápidas. Cada avance en la
  tecnología de hardware conduce a empresas de programación más masivas, nuevos
  principios organizativos y un enriquecimiento de modelos abstractos. Cada
  lector debe preguntarse periódicamente @"(¿hacia qué fin, hacia qué
  fin?)––pero no lo pregunte con demasiada frecuencia como para perder la
  diversión de programar por el estreñimiento de la filosofía agridulce.

#   Among the programs we write, some (but never enough) perform a precise
#   mathematical function such as sorting or finding the maximum of a sequence of
#   numbers, determining primality, or finding the square root. We call such
#   programs algorithms, and a great deal is known of their optimal behavior,
#   particularly with respect to the two important parameters of execution time
#   and data storage requirements. A programmer should acquire good algorithms
#   and idioms. Even though some programs resist precise specifications, it is
#   the responsibility of the programmer to estimate, and always to attempt to
#   improve, their performance.
  Entre los programas que escribimos, algunos (pero nunca lo suficientes)
  realizan una función matemática precisa como ordenar o encontrar el máximo de
  una secuencia de números, determinar la primalidad o encontrar la raíz
  cuadrada. A estos programas se les llama algoritmos, y se sabe mucho de su
  comportamiento óptimo, particularmente con respecto a los dos parámetros
  importantes del tiempo de ejecución y los requisitos de almacenamiento de
  datos. Un programador debe adquirir buenos algoritmos y lenguajes. Aunque
  algunos programas resisten especificaciones precisas, es responsabilidad del
  programador estimar y siempre intentar mejorar su rendimiento.

#   Lisp is a survivor, having been in use for about a quarter of a century.
#   Among the active programming languages only Fortran has had a longer life.
#   Both languages have supported the programming needs of important areas of
#   application, Fortran for scientific and engineering computation and Lisp for
#   artificial intelligence. These two areas continue to be important, and their
#   programmers are so devoted to these two languages that Lisp and Fortran may
#   well continue in active use for at least another quarter-century.
  Lisp es un sobreviviente, habiendo estado en uso durante aproximadamente un
  cuarto de siglo. Entre los lenguajes de programación activos sólo Fortran ha
  tenido una vida más larga. Ambos lenguajes han apoyado las necesidades de
  programación de importantes áreas de aplicación, Fortran para computación
  científica y de ingeniería y Lisp para inteligencia artificial. Estas dos
  áreas siguen siendo importantes, y sus programadores están tan dedicados a
  estos dos lenguajes que Lisp y Fortran bien pueden continuar en uso activo por
  lo menos otro cuarto de siglo.

#   Lisp changes. The Scheme dialect used in this text has evolved from the
#   original Lisp and differs from the latter in several important ways, including
#   static scoping for variable binding and permitting functions to yield
#   functions as values. In its semantic structure Scheme is as closely akin to
#   Algol 60 as to early Lisps. Algol 60, never to be an active language again,
#   lives on in the genes of Scheme and Pascal. It would be difficult to find two
#   languages that are the communicating coin of two more different cultures than
#   those gathered around these two languages. Pascal is for building
#   pyramids––imposing, breathtaking, static structures built by armies pushing
#   heavy blocks into place. Lisp is for building organisms––imposing,
#   breathtaking, dynamic structures built by squads fitting fluctuating myriads
#   of simpler organisms into place. The organizing principles used are the same
#   in both cases, except for one extraordinarily important difference: The
#   discretionary exportable functionality entrusted to the individual Lisp
#   programmer is more than an order of magnitude greater than that to be found
#   within Pascal enterprises. Lisp programs inflate libraries with functions
#   whose utility transcends the application that produced them. The list, Lisp's
#   native data structure, is largely responsible for such growth of utility. The
#   simple structure and natural applicability of lists are reflected in functions
#   that are amazingly nonidiosyncratic. In Pascal the plethora of declarable
#   data structures induces a specialization within functions that inhibits and
#   penalizes casual cooperation. It is better to have 100 functions operate on
#   one data structure than to have 10 functions operate on 10 data structures.
#   As a result the pyramid must stand unchanged for a millennium; the organism
#   must evolve or perish.
  Lisp cambia. El dialecto Scheme utilizado en este texto ha evolucionado a
  partir del Lisp original y difiere de éste último de varias maneras
  importantes, incluyendo el alcance estático para la vinculación variable y las
  funciones de permiso para producir funciones como valores. En su estructura
  semántica Scheme es tan similar a Algol 60 como a los primeros Lisps. Algol
  60, nunca más volverá a ser un lenguaje activo, vive en los genes de Scheme y
  Pascal. Sería difícil encontrar dos lenguajes que sean la moneda de
  comunicación de dos culturas más diferentes que las reunidas en torno a estos
  dos lenguajes. Pascal es para la construcción de pirámides––imponentes,
  impresionantes, estructuras estáticas construidas por los ejércitos empujando
  bloques pesados en su lugar. Lisp es para construir organismos––imponentes,
  impresionantes, estructuras dinámicas construidas por los escuadrones que
  encajan miriadas de organismos más simples en su lugar. Los principios
  organizativos utilizados en ambos casos son los mismos, excepto por una
  diferencia extraordinariamente importante: La funcionalidad factible
  exportable confiada al programador individual Lisp es mayor de un orden de
  magnitud que el que se encuentra en las empresas Pascal. Los programas Lisp
  inflan librerias con funciones cuya utilidad trasciende la aplicación que
  los produjo. Las lista, la estructura de datos nativa de Lisp, es en gran parte
  responsable de este crecimiento de utilidad. La estructura simple y la
  aplicabilidad natural de las listas se reflejan en funciones que son
  sorprendentemente no idiomáticas. En Pascal la plétora de estructuras de
  datos declarables induce una especialización dentro de funciones que inhibe y
  penaliza la cooperación casual. Es mejor tener 100 funciones actuando en una
  estructura de datos que tener 10 funciones actuando en 10 estructuras de
  datos. Como resultado, la pirámide debe permanecer inalterada durante un
  milenio; El organismo debe evolucionar o perecer.

#   To illustrate this difference, compare the treatment of material and exercises
#   within this book with that in any first-course text using Pascal. Do not
#   labor under the illusion that this is a text digestible at @A(MIT) only,
#   peculiar to the breed found there. It is precisely what a serious book on
#   programming Lisp must be, no matter who the student is or where it is used.
  Para ilustrar esta diferencia, compare el tratamiento de material y ejercicios
  dentro de este libro con el de cualquier texto de primer curso usando
  Pascal. No trabaje bajo la ilusión de que este es un texto digerible sólo en
  el @A(MIT), peculiar de la raza que se encuentra allí. Es precisamente lo que
  un libro serio sobre la programación Lisp debe ser, no importa quién es el
  estudiante o dónde se utiliza.

#   Note that this is a text about programming, unlike most Lisp books, which are
#   used as a preparation for work in artificial intelligence. After all, the
#   critical programming concerns of software engineering and artificial
#   intelligence tend to coalesce as the systems under investigation become
#   larger. This explains why there is such growing interest in Lisp outside of
#   artificial intelligence.
  Tenga en cuenta que se trata de un texto sobre programación, a diferencia
  de la mayoría de los libros Lisp, que se utilizan como una preparación para el
  trabajo en la inteligencia artificial. Después de todo, los problemas críticos
  de programación de la ingeniería de software y la inteligencia artificial
  tienden a unirse a medida que los sistemas bajo investigación se hacen más
  grandes. Esto explica por qué existe un interés creciente en Lisp fuera de la
  inteligencia artificial.

#   As one would expect from its goals, artificial intelligence research generates
#   many significant programming problems. In other programming cultures this
#   spate of problems spawns new languages. Indeed, in any very large programming
#   task a useful organizing principle is to control and isolate traffic within
#   the task modules via the invention of language. These languages tend to
#   become less primitive as one approaches the boundaries of the system where we
#   humans interact most often. As a result, such systems contain complex
#   language-processing functions replicated many times. Lisp has such a simple
#   syntax and semantics that parsing can be treated as an elementary task. Thus
#   parsing technology plays almost no role in Lisp programs, and the construction
#   of language processors is rarely an impediment to the rate of growth and
#   change of large Lisp systems. Finally, it is this very simplicity of syntax
#   and semantics that is responsible for the burden and freedom borne by all Lisp
#   programmers. No Lisp program of any size beyond a few lines can be written
#   without being saturated with discretionary functions. Invent and fit; have
#   fits and reinvent!  We toast the Lisp programmer who pens his thoughts within
#   nests of parentheses.
  Como uno esperaría de sus objetivos, la investigación en inteligencia
  artificial genera muchos problemas de programación importantes. En otras
  culturas de programación esta oleada de problemas genera nuevos lenguajes. De
  hecho, en cualquier tarea de programación muy grande, un principio de
  organización útil es controlar y aislar el tráfico dentro de los módulos de
  tarea a través de la invención del lenguaje. Estos lenguajes tienden a ser
  menos primitivos a medida que uno se acerca a los límites del sistema donde
  los seres humanos interactúan más a menudo. Como resultado, estos sistemas
  contienen complejas funciones de procesamiento del lenguaje replicadas muchas
  veces. Lisp tiene una sintaxis y semántica tan simple que el análisis puede
  ser tratado como una tarea elemental. Por lo tanto, la tecnología de análisis
  no juega casi ningún papel en los programas Lisp, Y la construcción de
  procesadores de lenguaje rara vez es un impedimento para la tasa de
  crecimiento y cambio de grandes sistemas Lisp. Por último, es esta misma
  sencillez de sintaxis y semántica que es responsable de la carga y la libertad
  que soportan todos los programadores de Lisp. Ningun programa Lisp de
  cualquier tamaño más allá de unas pocas líneas puede escribirse sin ser
  saturado con funciones discrecionales. Inventar y ajustar; Tienen ajustes y
  reinventan!  Brindamos al programador Lisp que escribe sus pensamientos dentro
  de los nidos de paréntesis.

#   ..pret >
  ..pret >
#     Alan J. Perlis
#     New Haven, Connecticut
    Alan J. Perlis
    New Haven, Connecticut

# * Preface to the Second Edition
* Prefacio a la Segunda Edición

#   ..quote >
  ..quote >
#     Is it possible that software is not like anything else, that it is meant to
#     be discarded: that the whole point is to always see it as a soap bubble?
    Es posible que el software no sea como cualquier otra cosa, que está
    destinado a ser descartado: que el punto es siempre verlo como una burbuja
    de jabón?

#     --Alan J. Perlis
    --Alan J. Perlis
#   < quote..
  < quote..


#   The material in this book has been the basis of @A(MIT)'s entry-level computer
#   science subject since 1980. We had been teaching this material for four years
#   when the first edition was published, and twelve more years have elapsed until
#   the appearance of this second edition. We are pleased that our work has been
#   widely adopted and incorporated into other texts. We have seen our students
#   take the ideas and programs in this book and build them in as the core of new
#   computer systems and languages. In literal realization of an ancient Talmudic
#   pun, our students have become our builders. We are lucky to have such capable
#   students and such accomplished builders.
  El material de este libro ha sido la base de la ciencia de la informática de
  primer nivel del @A(MIT) desde 1980. Habíamos estado enseñando este material
  durante cuatro años cuando se publicó la primera edición, y han pasado doce
  años hasta la aparición de esta segunda edición. Nos complace que nuestro
  trabajo haya sido ampliamente adoptado e incorporado a otros textos. Hemos
  visto a nuestros estudiantes tomar las ideas y los programas en este libro y
  construirlos como el núcleo de los nuevos sistemas informáticos y
  lenguajes. En la realización literal de un antiguo juego de palabras
  talmúdico, nuestros estudiantes se han convertido en nuestros
  constructores. Somos afortunados de tener estudiantes tan competentes y
  constructores tan consumados.

#   In preparing this edition, we have incorporated hundreds of clarifications
#   suggested by our own teaching experience and the comments of colleagues at
#   @A(MIT) and elsewhere. We have redesigned most of the major programming
#   systems in the book, including the generic-arithmetic system, the
#   interpreters, the register-machine simulator, and the compiler; and we have
#   rewritten all the program examples to ensure that any Scheme implementation
#   conforming to the @A(IEEE) Scheme standard (@l(#IEEE 1990)) will be able to
#   run the code.
  Al preparar esta edición, hemos incorporado cientos de aclaraciones sugeridas
  por nuestra propia experiencia de enseñanza y los comentarios de colegas en el
  @A(MIT) y en otros lugares. Hemos rediseñado la mayoría de los principales
  sistemas de programación del libro, incluyendo el sistema genérico-aritmético,
  los intérpretes, el simulador de registro-máquina y el compilador; Y hemos
  reescrito todos los ejemplos de programas para asegurar que cualquier
  implementación de Scheme conforme al estardar @A(#IEEE) Scheme (@l(#IEEE
  1990)) pueda ejecutar el código.

#   This edition emphasizes several new themes. The most important of these is
#   the central role played by different approaches to dealing with time in
#   computational models: objects with state, concurrent programming, functional
#   programming, lazy evaluation, and nondeterministic programming. We have
#   included new sections on concurrency and nondeterminism, and we have tried to
#   integrate this theme throughout the book.
  Esta edición enfatiza varios temas nuevos. El más importante de ellos es el
  papel central que desempeñan los diferentes enfoques para manejar el tiempo en
  modelos computacionales: objetos con estado, programación concurrente,
  programación funcional, evaluación perezosa y programación no determinística.
  Hemos incluido nuevas secciones sobre concurrencia y no determinismo, y hemos
  tratado de integrar este tema a lo largo del libro.

#   The first edition of the book closely followed the syllabus of our @A(MIT)
#   one-semester subject. With all the new material in the second edition, it
#   will not be possible to cover everything in a single semester, so the
#   instructor will have to pick and choose. In our own teaching, we sometimes
#   skip the section on logic programming (section @l(#4.4)), we have students use the
#   register-machine simulator but we do not cover its implementation (section @l(#5.2)),
#   and we give only a cursory overview of the compiler (section @l(#5.5)). Even so, this
#   is still an intense course. Some instructors may wish to cover only the first
#   three or four chapters, leaving the other material for subsequent courses.
  La primera edición del libro siguió de cerca el plan de estudios de nuestra
  asignatura de un semestre del @A(MIT). Con todo el material nuevo en la
  segunda edición, no será posible cubrir todo en un solo semestre, por lo que
  el instructor tendrá que elegir. En nuestra propia enseñanza, a veces saltamos
  la sección sobre la programación lógica (seccion @l(#4.4)), los estudiantes usan el
  simulador registrador-máquina, pero no cubrimos su implementación (seccion @l(#5.2)),
  y sólo ofrecemos una descripción somera del compilador (seccion @l(#5.5)). Aún así,
  este sigue siendo un curso intenso. Algunos instructores tal vez deseen cubrir
  sólo los primeros tres o cuatro capítulos, dejando el otro material para
  cursos posteriores.

#   The World-Wide-Web site @l(http://mitpress.mit.edu/sicp) provides support for
#   users of this book. This includes programs from the book, sample programming
#   assignments, supplementary materials, and downloadable implementations of the
#   Scheme dialect of Lisp.
  El sitio World-Wide-Web @l(http://mitpress.mit.edu/sicp) proporciona soporte
  para los usuarios de este libro. Esto incluye programas del libro, asignacion
  de programación de ejemplo, materiales complementarios e implementaciones
  descargables del dialecto Scheme de Lisp.

# * Preface to the First Edition
* Prefacio a la Primera Edición

#   ..quote >
 ..quote >
#     A computer is like a violin. You can imagine a novice trying first a
#     phonograph and then a violin. The latter, he says, sounds terrible. That
#     is the argument we have heard from our humanists and most of our computer
#     scientists. Computer programs are good, they say, for particular purposes,
#     but they aren't flexible. Neither is a violin, or a typewriter, until you
#     learn how to use it.
   Una computadora es como un violín. Puedes imaginar a un principiante que
   probar primero con un fonógrafo y luego con un violín. Este último, dice,
   suena terrible. Ese es el argumento que hemos escuchado de nuestros
   humanistas y la mayoría de nuestros informáticos. Los programas informáticos
   son buenos, dicen, para propósitos particulares, pero no son
   flexibles. Tampoco lo es un violín, ni una máquina de escribir, hasta que
   aprendas a usarlo.

#     --Marvin Minsky, @q(Why Programming Is a Good Medium for Expressing
#       Poorly-Understood and Sloppily-Formulated Ideas)
   --Marvin Minsky, @"(¿Por qué la programación es un buen medio para expresar
     ideas mal entendidas y formuladas)
#   < quote..
 < quote..


#   @"(The Structure and Interpretation of Computer Programs) is the entry-level
#   subject in computer science at the Massachusetts Institute of Technology. It
#   is required of all students at @A(MIT) who major in electrical engineering or
#   in computer science, as one-fourth of the @"(common core curriculum,) which
#   also includes two subjects on circuits and linear systems and a subject on the
#   design of digital systems. We have been involved in the development of this
#   subject since 1978, and we have taught this material in its present form since
#   the fall of 1980 to between 600 and 700 students each year. Most of these
#   students have had little or no prior formal training in computation, although
#   many have played with computers a bit and a few have had extensive programming
#   or hardware-design experience.
  @"(La Estructura e Interpretación de los Programas Informaticos) es la
  asignatura de nivel básico en informática en el Massachusetts Institute of
  Technology. Se requiere a todos los estudiantes en el @A(MIT) que se
  especializan en ingeniería eléctrica o en informática, como una cuarta parte
  del @"(plan de estudios básico común), que también incluye dos asignaturas
  sobre circuitos y sistemas lineales y un tema sobre el diseño de sistemas
  digitales. Hemos estado involucrados en el desarrollo de este tema desde 1978,
  y hemos enseñado este material en su forma actual desde otoño de 1980 a entre
  600 y 700 estudiantes cada año. La mayoría de estos estudiantes han tenido
  poco o ningún entrenamiento formal previo en computación, aunque muchos han
  jugado con las computadoras un poco y unos cuantos han tenido programación
  extensa o experiencia de diseño de hardware.

#   Our design of this introductory computer-science subject reflects two major
#   concerns. First, we want to establish the idea that a computer language is
#   not just a way of getting a computer to perform operations but rather that it
#   is a novel formal medium for expressing ideas about methodology. Thus,
#   programs must be written for people to read, and only incidentally for
#   machines to execute. Second, we believe that the essential material to be
#   addressed by a subject at this level is not the syntax of particular
#   programming-language constructs, nor clever algorithms for computing
#   particular functions efficiently, nor even the mathematical analysis of
#   algorithms and the foundations of computing, but rather the techniques used to
#   control the intellectual complexity of large software systems.
  Nuestro diseño de este tema introductorio de ciencias de la computación
  refleja dos preocupaciones principales. En primer lugar, queremos establecer
  la idea de que un lenguaje informático no es sólo una forma lograr que una
  computadora realice operaciones, sino que es un nuevo medio formal para
  expresar ideas sobre metodología. Así, los programas deben ser escritos para
  que la gente lea, y sólo de manera incidental para que las máquinas
  ejecuten. En segundo lugar, creemos que el material esencial a ser abordado
  por un sujeto en este nivel no es la sintaxis de construcciones particulares
  de lenguaje de programación, ni algoritmos inteligentes para calcular
  funciones particulares de manera eficiente, ni siquiera el análisis matemático
  de algoritmos y las bases de la computación, Sino más bien las técnicas
  utilizadas para controlar la complejidad intelectual de los grandes sistemas
  de software.

#   Our goal is that students who complete this subject should have a good feel
#   for the elements of style and the aesthetics of programming. They should have
#   command of the major techniques for controlling complexity in a large
#   system. They should be capable of reading a 50-page-long program, if it is
#   written in an exemplary style. They should know what not to read, and what
#   they need not understand at any moment. They should feel secure about
#   modifying a program, retaining the spirit and style of the original author.
  Nuestro objetivo es que los estudiantes que completen este tema deben tener
  una buena idea de los elementos de estilo y la estética de la programación.
  Deben tener el dominio de las principales técnicas para controlar la
  complejidad en un sistema grande. Ellos deben ser capaces de leer un programa
  de 50 páginas, si está escrito en un estilo ejemplar. Deben saber qué no
  necesitan leer y que no necesitan comprender en ningún momento. Ellos deben
  sentirse seguros sobre la modificación de un programa, manteniendo el espíritu
  y el estilo del autor original.

#   These skills are by no means unique to computer programming. The techniques we
#   teach and draw upon are common to all of engineering design. We control
#   complexity by building abstractions that hide details when appropriate. We
#   control complexity by establishing conventional interfaces that enable us to
#   construct systems by combining standard, well-understood pieces in a @"(mix
#   and match) way. We control complexity by establishing new languages for
#   describing a design, each of which emphasizes particular aspects of the design
#   and deemphasizes others.
  Estas habilidades no son únicas en la programación de computadoras. Las
  técnicas que enseñamos y utilizamos son comunes a todo el diseño de
  ingeniería. Controlamos la complejidad creando abstracciones que ocultan
  detalles cuando es apropiado. Controlamos la complejidad estableciendo
  interfaces convencionales que nos permiten construir sistemas combinando
  piezas estándar y bien entendidas en forma de @"(mezcla y coincidencia).
  Controlamos la complejidad estableciendo nuevos lenguajes para describir un
  diseño, cada uno de los cuales enfatiza aspectos particulares del diseño y
  atenua otros.

#   Underlying our approach to this subject is our conviction that @"(computer
#   science) is not a science and that its significance has little to do with
#   computers. The computer revolution is a revolution in the way we think and in
#   the way we express what we think. The essence of this change is the emergence
#   of what might best be called @e(procedural epistemology)––the study of the
#   structure of knowledge from an imperative point of view, as opposed to the
#   more declarative point of view taken by classical mathematical subjects.
#   Mathematics provides a framework for dealing precisely with notions of @"(what
#   is.)  Computation provides a framework for dealing precisely with notions of
#   @"(how to.)
  Subyacente a nuestro enfoque de este tema es nuestra convicción de que la
  @"(informática) no es una ciencia y que su importancia tiene poco que ver con
  las computadoras. La revolución de la computadora es una revolución en la
  forma en que pensamos y en la forma en que expresamos lo que pensamos. La
  esencia de este cambio es la aparición de lo que mejor podría llamarse
  @e(epistemología procedimental)––el estudio de la estructura del conocimiento
  desde un punto de vista imperativo, en oposición al punto de vista más
  declarativo tomado por los sujetos matemáticos clásicos. Las matemáticas
  proporcionan un marco para tratar con precisión las nociones de @"(lo que es).
  La computación proporciona un marco para tratar con precisión las nociones de
  @"(cómo).

#   In teaching our material we use a dialect of the programming language Lisp. We
#   never formally teach the language, because we don't have to. We just use it,
#   and students pick it up in a few days. This is one great advantage of
#   Lisp-like languages: They have very few ways of forming compound expressions,
#   and almost no syntactic structure. All of the formal properties can be covered
#   in an hour, like the rules of chess. After a short time we forget about
#   syntactic details of the language (because there are none) and get on with the
#   real issues––figuring out what we want to compute, how we will decompose
#   problems into manageable parts, and how we will work on the parts. Another
#   advantage of Lisp is that it supports (but does not enforce) more of the
#   large-scale strategies for modular decomposition of programs than any other
#   language we know. We can make procedural and data abstractions, we can use
#   higher-order functions to capture common patterns of usage, we can model local
#   state using assignment and data mutation, we can link parts of a program with
#   streams and delayed evaluation, and we can easily implement embedded
#   languages.  All of this is embedded in an interactive environment with
#   excellent support for incremental program design, construction, testing, and
#   debugging. We thank all the generations of Lisp wizards, starting with John
#   McCarthy, who have fashioned a fine tool of unprecedented power and elegance.
  En la enseñanza de nuestro material utilizamos un dialecto del lenguaje de
  programación Lisp. Nunca enseñamos formalmente el lenguaje, porque no tenemos
  que hacerlo. Sólo lo usamos, y los estudiantes lo recogen en unos días. Esta
  es una gran ventaja de los lenguajes de tipo Lisp: tienen muy pocas formas de
  formar expresiones compuestas y casi ninguna estructura sintáctica. Todas las
  propiedades formales se pueden cubrir en una hora, como las reglas del
  ajedrez. Después de un corto tiempo nos olvidamos de los detalles sintácticos
  del lenguaje (porque no hay ninguno) y seguimos adelante con los problemas
  reales––averiguar lo que queremos calcular, cómo vamos a descomponer los
  problemas en partes manejables, y cómo vamos a trabajar en las partes. Otra
  ventaja de Lisp es que soporta (pero no impone) la mayoria de estrategias de
  cualquier otro lenguaje que conozcamos para la descomposición modular de los
  programas a gran escala. Podemos hacer abstracciones de procedimientos y
  datos, podemos usar funciones de orden superior para capturar patrones comunes
  de uso, podemos modelar el estado local usando asignación y mutación de datos,
  podemos enlazar partes de un programa con flujos y evaluación retrasada, y
  podemos implementar lenguajes enbebidos fácilmente. Todo esto está incrustado
  en un entorno interactivo con un excelente soporte para el diseño incremental
  de programas, construcción, pruebas y depuración. Agradecemos a todas las
  generaciones de magos Lisp, empezando por John McCarthy, que han creado una
  excelente herramienta de poder y elegancia sin precedentes.

#   Scheme, the dialect of Lisp that we use, is an attempt to bring together the
#   power and elegance of Lisp and Algol. From Lisp we take the metalinguistic
#   power that derives from the simple syntax, the uniform representation of
#   programs as data objects, and the garbage-collected heap-allocated data. From
#   Algol we take lexical scoping and block structure, which are gifts from the
#   pioneers of programming-language design who were on the Algol committee. We
#   wish to cite John Reynolds and Peter Landin for their insights into the
#   relationship of Church's λ-calculus to the structure of programming
#   languages. We also recognize our debt to the mathematicians who scouted out
#   this territory decades before computers appeared on the scene. These pioneers
#   include Alonzo Church, Barkley Rosser, Stephen Kleene, and Haskell Curry.
  Scheme, el dialecto de Lisp que usamos, es un intento de reunir el poder y la
  elegancia de Lisp y Algol. De Lisp tomamos el poder metalingüístico que deriva
  de la sintaxis simple, la representación uniforme de los programas como
  objetos de datos, y la recolección de basura de datos almacenados en el
  monticulo. De Algol tomamos el ámbito léxico y la estructura de bloques, que
  son regalos de los pioneros del diseño de lenguaje de programación que estaban
  en el comité de Algol. Queremos citar a John Reynolds y Peter Landin por sus
  ideas sobre la relacion de la Iglesia del cálculo-λ con la estructura de los
  lenguajes de programación. También reconocemos nuestra deuda con los
  matemáticos que exploraron este territorio décadas antes de que las
  computadoras aparecieran en escena. Estos pioneros incluyen a Alonzo Church,
  Barkley Rosser, Stephen Kleene y Haskell Curry.

# * Acknowledgments
* Agradecimientos

#   We would like to thank the many people who have helped us develop this book
#   and this curriculum.
  Nos gustaría agradecer a las muchas personas que nos han ayudado a desarrollar
  este libro y este plan de estudios.

#   Our subject is a clear intellectual descendant of @"(6.231,) a wonderful
#   subject on programming linguistics and the λ-calculus taught at @A(MIT) in the
#   late 1960s by Jack Wozencraft and Arthur Evans, Jr.
  Nuestro tema es un claro descendiente intelectual de @"(6.231), un maravilloso
  tema de programación lingüística y del cálculo-λ enseñado en el @A(MIT) a
  finales de 1960 por Jack Wozencraft y Arthur Evans, Jr.

#   We owe a great debt to Robert Fano, who reorganized @A(MIT)'s introductory
#   curriculum in electrical engineering and computer science to emphasize the
#   principles of engineering design. He led us in starting out on this enterprise
#   and wrote the first set of subject notes from which this book evolved.
  Tenemos una gran deuda con Robert Fano, quien reorganizó el programa de
  introducción al @A(MIT) en ingeniería eléctrica e informática para enfatizar
  los principios del diseño de ingeniería. Él nos guió para empezar esta empresa
  y escribió el primer conjunto de notas de temas de las cuales este libro
  evolucionó.

#   Much of the style and aesthetics of programming that we try to teach were
#   developed in conjunction with Guy Lewis Steele Jr., who collaborated with
#   Gerald Jay Sussman in the initial development of the Scheme language. In
#   addition, David Turner, Peter Henderson, Dan Friedman, David Wise, and Will
#   Clinger have taught us many of the techniques of the functional programming
#   community that appear in this book.
  Gran parte del estilo y la estética de la programación que tratamos de enseñar
  se desarrollaron conjuntamente con Guy Lewis Steele Jr., quien colaboró con
  Gerald Jay Sussman en el desarrollo inicial del lenguaje Scheme. Además, David
  Turner, Peter Henderson, Dan Friedman, David Wise y Will Clinger nos han
  enseñado muchas de las técnicas de la comunidad de programación funcional que
  aparecen en este libro.

#   Joel Moses taught us about structuring large systems. His experience with the
#   Macsyma system for symbolic computation provided the insight that one should
#   avoid complexities of control and concentrate on organizing the data to
#   reflect the real structure of the world being modeled.
  Joel Moses nos enseñó sobre la estructuración de sistemas grandes. Su
  experiencia con el sistema Macsyma para la computación simbólica proporcionó
  la idea de que uno debe evitar las complejidades de control y concentrarse en
  organizar los datos para reflejar la estructura real del mundo que está siendo
  modelado.

#   Marvin Minsky and Seymour Papert formed many of our attitudes about
#   programming and its place in our intellectual lives. To them we owe the
#   understanding that computation provides a means of expression for exploring
#   ideas that would otherwise be too complex to deal with precisely. They
#   emphasize that a student's ability to write and modify programs provides a
#   powerful medium in which exploring becomes a natural activity.
  Marvin Minsky y Seymour Papert formaron muchas de nuestras actitudes acerca de
  la programación y su lugar en nuestra vida intelectual. A ellos le debemos
  entender que la computación proporciona un medio de expresión para explorar
  ideas que de otra manera serían demasiado complejas para tratarlas con
  precisión. Enfatizan que la capacidad del estudiante para escribir y modificar
  programas provee un poderoso medio en el cual la exploración se convierte en
  una actividad natural.

#   We also strongly agree with Alan Perlis that programming is lots of fun and we
#   had better be careful to support the joy of programming. Part of this joy
#   derives from observing great masters at work. We are fortunate to have been
#   apprentice programmers at the feet of Bill Gosper and Richard Greenblatt.
  También estamos bastante de acuerdo con Alan Perlis de que la programación es
  muy divertida y que es mejor tener cuidado de apoyar la alegría de la
  programación. Parte de esta alegría deriva de la observación de grandes
  maestros en el trabajo. Tenemos la fortuna de haber sido programadores de
  aprendiz a los pies de Bill Gosper y Richard Greenblatt.

#   It is difficult to identify all the people who have contributed to the
#   development of our curriculum. We thank all the lecturers, recitation
#   instructors, and tutors who have worked with us over the past fifteen years
#   and put in many extra hours on our subject, especially Bill Siebert, Albert
#   Meyer, Joe Stoy, Randy Davis, Louis Braida, Eric Grimson, Rod Brooks, Lynn
#   Stein, and Peter Szolovits. We would like to specially acknowledge the
#   outstanding teaching contributions of Franklyn Turbak, now at Wellesley; his
#   work in undergraduate instruction set a standard that we can all aspire to. We
#   are grateful to Jerry Saltzer and Jim Miller for helping us grapple with the
#   mysteries of concurrency, and to Peter Szolovits and David McAllester for
#   their contributions to the exposition of nondeterministic evaluation in
#   @l(#Chapter 4).
  Es difícil identificar a todas las personas que han contribuido al desarrollo
  de nuestro currículo. Agradecemos a todos los profesores, instructores de
  recitación y tutores que han trabajado con nosotros en los últimos quince años
  y han dedicado muchas horas adicionales a nuestro tema, especialmente Bill
  Siebert, Albert Meyer, Joe Stoy, Randy Davis, Louis Braida, Eric Grimson, Rod
  Brooks, Lynn Stein y Peter Szolovits. Queremos reconocer especialmente las
  destacadas contribuciones de Franklyn Turbak, ahora en Wellesley; Su trabajo
  en la enseñanza de pregrado establece un estándar al que todos podemos
  aspirar. Estamos agradecidos con Jerry Saltzer y Jim Miller por ayudarnos a
  lidiar con los misterios de la concurrencia, a Peter Szolovits y David
  McAllester por sus contribuciones a la exposición de la evaluación no
  determinista en el @l(#Capitulo 4).

#   Many people have put in significant effort presenting this material at other
#   universities. Some of the people we have worked closely with are Jacob
#   Katzenelson at the Technion, Hardy Mayer at the University of California at
#   Irvine, Joe Stoy at Oxford, Elisha Sacks at Purdue, and Jan Komorowski at the
#   Norwegian University of Science and Technology. We are exceptionally proud of
#   our colleagues who have received major teaching awards for their adaptations
#   of this subject at other universities, including Kenneth Yip at Yale, Brian
#   Harvey at the University of California at Berkeley, and Dan Huttenlocher at
#   Cornell.
  Muchas personas han hecho un esfuerzo significativo para presentar este
  material en otras universidades. Algunas de las personas con las que hemos
  trabajado estrechamente son Jacob Katzenelson en el Technion, Hardy Mayer en
  la Universidad de California en Irvine, Joe Stoy en Oxford, Elisha Sacks en
  Purdue y Jan Komorowski en la Universidad Noruega de Ciencia y Tecnología.
  Estamos excepcionalmente orgullosos de nuestros colegas que han recibido
  importantes premios de enseñanza por sus adaptaciones de este tema en otras
  universidades, incluyendo a Kenneth Yip en Yale, Brian Harvey en la Universidad
  de California en Berkeley y Dan Huttenlocher en Cornell.

#   Al Moyé arranged for us to teach this material to engineers at
#   Hewlett-Packard and for the production of videotapes of these lectures. We
#   would like to thank the talented instructors––in particular Jim Miller, Bill
#   Siebert, and Mike Eisenberg––who have designed continuing education courses
#   incorporating these tapes and taught them at universities and industry all
#   over the world.
  Al Moyé nos dispuso para enseñar este material a los ingenieros de
  Hewlett-Packard y para la producción de videos de estas conferencias.
  Quisiéramos agradecer a los talentosos instructores, en particular a Jim
  Miller, Bill Siebert y Mike Eisenberg, quienes han diseñado cursos de
  educación continua que incorporan estas cintas y las enseñaron en
  universidades e industrias de todo el mundo.

#   Many educators in other countries have put in significant work translating the
#   first edition. Michel Briand, Pierre Chamard, and André Pic produced a
#   French edition; Susanne Daniels-Herold produced a German edition; and Fumio
#   Motoyoshi produced a Japanese edition. We do not know who produced the Chinese
#   edition, but we consider it an honor to have been selected as the subject of
#   an @"(unauthorized) translation.
  Muchos educadores de otros países han hecho un trabajo significativo
  traduciendo la primera edición. Michel Briand, Pierre Chamard y André Pic
  produjeron una edición francesa; Susanne Daniels-Herold produjo una edición
  alemana; Y Fumio Motoyoshi produjo una edición japonesa. No sabemos quién
  produjo la edición china, pero consideramos un honor haber sido seleccionados
  como sujeto de una traducción @"(no autorizada).

#   It is hard to enumerate all the people who have made technical contributions
#   to the development of the Scheme systems we use for instructional purposes. In
#   addition to Guy Steele, principal wizards have included Chris Hanson, Joe
#   Bowbeer, Jim Miller, Guillermo Rozas, and Stephen Adams. Others who have put
#   in significant time are Richard Stallman, Alan Bawden, Kent Pitman, Jon Taft,
#   Neil Mayle, John Lamping, Gwyn Osnos, Tracy Larrabee, George Carrette, Soma
#   Chaudhuri, Bill Chiarchiaro, Steven Kirsch, Leigh Klotz, Wayne Noss, Todd
#   Cass, Patrick O'Donnell, Kevin Theobald, Daniel Weise, Kenneth Sinclair,
#   Anthony Courtemanche, Henry M. Wu, Andrew Berlin, and Ruth Shyu.
  Es difícil enumerar a todas las personas que han hecho contribuciones técnicas
  al desarrollo de los sistemas Scheme que usamos con fines educativos. Además
  de Guy Steele, los magos principales han incluido a Chris Hanson, Joe Bowbeer,
  Jim Miller, Guillermo Rozas y Stephen Adams. Otros que han puesto un tiempo
  significativo son Richard Stallman, Alan Bawden, Pitman Kent, Jon Taft, Neil
  Mayle, John Lamping, Gwyn Osnos, Tracy Larrabee, George Carrette, Soma
  Chaudhuri, Bill Chiarchiaro, Steven Kirsch, Todd Cass, Patrick O'Donnell,
  Kevin Theobald, Daniel Weise, Kenneth Sinclair, Anthony Courtemanche, Henry
  M. Wu, Andrew Berlín, y Ruth Shyu.

#   Beyond the @A(MIT) implementation, we would like to thank the many people who
#   worked on the @A(IEEE) Scheme standard, including William Clinger and Jonathan
#   Rees, who edited the R⁴RS, and Chris Haynes, David Bartley, Chris Hanson, and
#   Jim Miller, who prepared the @A(IEEE) standard.
  Más allá de la implementación del @A(MIT), queremos agradecer a muchas
  personas que trabajaron en el estándar @A(IEEE) Scheme, incluyendo a William
  Clinger y Jonathan Rees, quien editó el R⁴RS, y Chris Haynes, David Bartley,
  Chris Hanson y Jim Miller, quienes prepararon el estándar @A(IEEE).

#   Dan Friedman has been a long-time leader of the Scheme community. The
#   community's broader work goes beyond issues of language design to encompass
#   significant educational innovations, such as the high-school curriculum based
#   on EdScheme by Schemer's Inc., and the wonderful books by Mike Eisenberg and
#   by Brian Harvey and Matthew Wright.
  Dan Friedman ha sido mucho tiempo un líder de la comunidad Scheme. El trabajo
  más amplio de la comunidad va más allá de las cuestiones de diseño del
  lenguaje para abarcar innovaciones educativas significativas, como el plan de
  estudios de la escuela secundaria basado en EdScheme de Schemer Inc. y los
  maravillosos libros de Mike Eisenberg y Brian Harvey y Matthew Wright.

#   We appreciate the work of those who contributed to making this a real book,
#   especially Terry Ehling, Larry Cohen, and Paul Bethge at the @A(MIT)
#   Press. Ella Mazel found the wonderful cover image. For the second edition we
#   are particularly grateful to Bernard and Ella Mazel for help with the book
#   design, and to David Jones, @e(TeX) wizard extraordinaire. We also are
#   indebted to those readers who made penetrating comments on the new draft:
#   Jacob Katzenelson, Hardy Mayer, Jim Miller, and especially Brian Harvey, who
#   did unto this book as Julie did unto his book @q{Simply Scheme}.
  Apreciamos el trabajo de aquellos que contribuyeron a hacer de esto un libro
  real, especialmente Terry Ehling, Larry Cohen, y Paul Bethge en la prensa del
  @A(MIT). Ella Mazel encontró la maravillosa imagen de la portada. Para la
  segunda edición estamos particularmente agradecidos a Bernard y Ella Mazel por
  su ayuda con el diseño del libro, y David Jones, extraordinario mago
  @e(TeX). También estamos en deuda con los lectores que hicieron comentarios
  penetrantes sobre el nuevo proyecto: Jacob Katzenelson, Hardy Mayer, Jim
  Miller, y especialmente Brian Harvey, que hizo en este libro como Julie hizo
  en su propio libro @q(Simply Scheme).

#   Finally, we would like to acknowledge the support of the organizations that
#   have encouraged this work over the years, including support from
#   Hewlett-Packard, made possible by Ira Goldstein and Joel Birnbaum, and support
#   from @A(DARPA), made possible by Bob Kahn.
  Finalmente, queremos agradecer el apoyo de las organizaciones que han alentado
  este trabajo a través de los años, incluyendo el apoyo de Hewlett-Packard,
  hecho posible por Ira Goldstein y Joel Birnbaum, y el apoyo de @A(DARPA),
  hecho posible por Bob Kahn.

# * Chapter 1 <> Building Abstractions with Procedures
* Capitulo 1 <> Construyendo Abstracciones con Procedimientos

#   ..quote >
  ..quote >
#     The acts of the mind, wherein it exerts its power over simple ideas, are
#     chiefly these three: 1. Combining several simple ideas into one compound
#     one, and thus all complex ideas are made. 2. The second is bringing two
#     ideas, whether simple or complex, together, and setting them by one another
#     so as to take a view of them at once, without uniting them into one, by
#     which it gets all its ideas of relations. 3. The third is separating them
#     from all other ideas that accompany them in their real existence: this is
#     called abstraction, and thus all its general ideas are made.
    Los actos de la mente, en los que ejerce su poder sobre las ideas simples,
    son principalmente estos tres: 1. La combinación de varias ideas simples en
    una compuesta una, y por lo tanto todas las ideas complejas se hacen. 2. La
    segunda consiste en reunir dos ideas, ya sean simples o complejas, y fijarlas
    unas a otras para poder verlas a la vez, sin unirlas en una sola, por las
    cuales se obtienen todas sus ideas de relaciones. 3. La tercera es separarlas
    de todas las otras ideas que las acompañan en su existencia real: esto se
    llama abstracción, y así se hacen todas sus ideas generales.

#     --John Locke, @q(An Essay Concerning Human Understanding) (1690)
    --John Locke, @q(un ensayo sobre la comprensión humana) (1690)
#   < quote..
  < quote..


#   We are about to study the idea of a @e(computational process).  Computational
#   processes are abstract beings that inhabit computers. As they evolve,
#   processes manipulate other abstract things called @e(data). The evolution of a
#   process is directed by a pattern of rules called a @e(program). People create
#   programs to direct processes. In effect, we conjure the spirits of the
#   computer with our spells.
  Estamos a punto de estudiar la idea de un @e(proceso computacional). Los
  procesos computacionales son seres abstractos que habitan las computadoras. A
  medida que evolucionan, los procesos manipulan otras cosas abstractas llamadas
  @e(datos). La evolución de un proceso está dirigida por un patrón de reglas
  llamado @e(programa). La gente crea programas para dirigir procesos. En
  efecto, conjuramos los espíritus de la computadora con nuestros hechizos.

#   A computational process is indeed much like a sorcerer's idea of a spirit. It
#   cannot be seen or touched. It is not composed of matter at all. However, it is
#   very real. It can perform intellectual work. It can answer questions. It can
#   affect the world by disbursing money at a bank or by controlling a robot arm
#   in a factory. The programs we use to conjure processes are like a sorcerer's
#   spells. They are carefully composed from symbolic expressions in arcane and
#   esoteric @e(programming languages) that prescribe the tasks we want our
#   processes to perform.
  Un proceso computacional es, de hecho, muy parecido a la idea de un espíritu
  de un hechicero. No se puede ver ni tocar. No está compuesto de materia en
  absoluto. Sin embargo, es muy real. Puede realizar trabajo intelectual. Puede
  responder preguntas. Puede afectar al mundo desembolsando dinero en un banco o
  controlando un brazo robot en una fábrica. Los programas que usamos para
  conjurar procesos son como los hechizos de un hechicero. Se componen
  cuidadosamente de expresiones simbólicas en @e(lenguajes de programación)
  arcanos y esotéricos que prescriben las tareas que queremos que nuestros
  procesos realicen.

#   A computational process, in a correctly working computer, executes programs
#   precisely and accurately. Thus, like the sorcerer's apprentice, novice
#   programmers must learn to understand and to anticipate the consequences of
#   their conjuring. Even small errors (usually called @e(bugs) or @e(glitches))
#   in programs can have complex and unanticipated consequences.
  Un proceso computacional, en un equipo que funciona correctamente, ejecuta los
  programas con precisión y exactitud. Así, al igual que el aprendiz de brujo,
  los programadores principiantes deben aprender a entender y anticipar las
  consecuencias de su conjuración. Incluso los pequeños errores en los programas
  (generalmente llamados @e(bugs) o @e(glitches)) pueden tener consecuencias
  complejas e imprevistas.

#   Fortunately, learning to program is considerably less dangerous than learning
#   sorcery, because the spirits we deal with are conveniently contained in a
#   secure way. Real-world programming, however, requires care, expertise, and
#   wisdom. A small bug in a computer-aided design program, for example, can lead
#   to the catastrophic collapse of an airplane or a dam or the self-destruction
#   of an industrial robot.
  Afortunadamente, aprender a programar es considerablemente menos peligroso que
  aprender brujería, porque los espíritus que tratamos están convenientemente
  contenidos de una manera segura. La programación del mundo real, sin embargo,
  requiere cuidado, experiencia y sabiduría. Un pequeño error en un programa de
  diseño asistido por computadora, por ejemplo, puede conducir al colapso
  catastrófico de un avión o una presa o la autodestrucción de un robot
  industrial.

#   Master software engineers have the ability to organize programs so that they
#   can be reasonably sure that the resulting processes will perform the tasks
#   intended. They can visualize the behavior of their systems in advance. They
#   know how to structure programs so that unanticipated problems do not lead to
#   catastrophic consequences, and when problems do arise, they can @e(debug)
#   their programs. Well-designed computational systems, like well-designed
#   automobiles or nuclear reactors, are designed in a modular manner, so that the
#   parts can be constructed, replaced, and debugged separately.
  Los ingenieros maestros de software tienen la capacidad de organizar los
  programas para que puedan estar razonablemente seguros de que los procesos
  resultantes realizarán las tareas previstas. Pueden visualizar el
  comportamiento de sus sistemas de antemano. Saben cómo estructurar los
  programas para que los problemas imprevistos no conduzcan a consecuencias
  catastróficas, y cuando surgen problemas, pueden @e(depurar) sus programas.
  Los sistemas computacionales bien diseñados, como los automóviles o los
  reactores nucleares bien diseñados, están diseñados de manera modular, de modo
  que las piezas se pueden construir, reemplazar y depurar por separado.

# ** Programming in Lisp
** Programación en Lisp

#    We need an appropriate language for describing processes, and we will use for
#    this purpose the programming language Lisp. Just as our everyday thoughts are
#    usually expressed in our natural language (such as English, French, or
#    Japanese), and descriptions of quantitative phenomena are expressed with
#    mathematical notations, our procedural thoughts will be expressed in Lisp.
#    Lisp was invented in the late 1950s as a formalism for reasoning about the use
#    of certain kinds of logical expressions, called @e(recursion equations), as a
#    model for computation. The language was conceived by John McCarthy and is
#    based on his paper @"(Recursive Functions of Symbolic Expressions and Their
#    Computation by Machine) (@l(#McCarthy 1960)).
   Necesitamos un lenguaje apropiado para describir los procesos, y usaremos
   para este propósito el lenguaje de programación Lisp. Así como nuestros
   pensamientos cotidianos se expresan generalmente en nuestro lenguaje natural
   (como el inglés, el francés o el japonés), y las descripciones de los
   fenómenos cuantitativos se expresan con anotaciones matemáticas, nuestros
   pensamientos procesales se expresarán en Lisp. Lisp fue inventado a finales
   de la década de 1950 como un formalismo para razonar sobre el uso de ciertos
   tipos de expresiones lógicas, llamadas @e(ecuaciones de recursión), como un
   modelo para la computación. El lenguaje fue concebido por John McCarthy y se
   basa en su documento @"(Funciones Recursivas de Expresiones Simbólicas y su
   Computación por Máquina) (@l(#McCarthy 1960)).

#    Despite its inception as a mathematical formalism, Lisp is a practical
#    programming language. A Lisp @e(interpreter) is a machine that carries out
#    processes described in the Lisp language. The first Lisp interpreter was
#    implemented by McCarthy with the help of colleagues and students in the
#    Artificial Intelligence Group of the @A(MIT) Research Laboratory of
#    Electronics and in the @A(MIT) Computation Center.@n(1) Lisp, whose name is an
#    acronym for LISt Processing, was designed to provide symbol-manipulating
#    capabilities for attacking programming problems such as the symbolic
#    differentiation and integration of algebraic expressions. It included for this
#    purpose new data objects known as atoms and lists, which most strikingly set
#    it apart from all other languages of the period.
   A pesar de su inicio como formalismo matemático, Lisp es un lenguaje de
   programación práctico. Un @e(intérprete) Lisp es una máquina que realiza
   procesos descritos en el lenguaje Lisp. El primer intérprete Lisp fue
   implementado por McCarthy con la ayuda de colegas y estudiantes en el Grupo
   de Inteligencia Artificial del @A(MIT) Research Laboratory of Electronics y
   en el @A(MIT) Computation Center. @n(1) Lisp, cuyo nombre es un acrónimo de
   LISt Processing, fue diseñado para proporcionar capacidades de manipulación
   de símbolos para atacar problemas de programación como la diferenciación
   simbólica y la integración de expresiones algebraicas. Incluía para este
   propósito nuevos objetos de datos conocidos como átomos y listas,

#    Lisp was not the product of a concerted design effort. Instead, it evolved
#    informally in an experimental manner in response to users' needs and to
#    pragmatic implementation considerations. Lisp's informal evolution has
#    continued through the years, and the community of Lisp users has traditionally
#    resisted attempts to promulgate any @"(official) definition of the language.
#    This evolution, together with the flexibility and elegance of the initial
#    conception, has enabled Lisp, which is the second oldest language in
#    widespread use today (only Fortran is older), to continually adapt to
#    encompass the most modern ideas about program design. Thus, Lisp is by now a
#    family of dialects, which, while sharing most of the original features, may
#    differ from one another in significant ways. The dialect of Lisp used in this
#    book is called Scheme.@n(2)
   Lisp no fue el producto de un esfuerzo de diseño planeado. En cambio,
   evolucionó informalmente de manera experimental en respuesta a las
   necesidades de los usuarios y a consideraciones pragmáticas de
   implementación. La evolución informal de Lisp ha continuado a través de los
   años, y la comunidad de usuarios de Lisp tradicionalmente ha resistido los
   intentos de promulgar cualquier definición @"(oficial) del lenguaje. Esta
   evolución, junto con la flexibilidad y la elegancia de la concepción inicial,
   ha permitido a Lisp, que es el segundo lenguaje más antiguo en uso hoy en día
   (sólo Fortran es más viejo), adaptarse continuamente para abarcar las ideas
   más modernas sobre el diseño de programas. Por lo tanto, Lisp es ahora una
   familia de dialectos, que, aunque comparten la mayoría de las características
   originales, pueden diferir entre sí de maneras significativas. El dialecto de
   Lisp usado en este libro se llama Scheme.@n(2)

#    Because of its experimental character and its emphasis on symbol manipulation,
#    Lisp was at first very inefficient for numerical computations, at least in
#    comparison with Fortran. Over the years, however, Lisp compilers have been
#    developed that translate programs into machine code that can perform numerical
#    computations reasonably efficiently. And for special applications, Lisp has
#    been used with great effectiveness.@n(3) Although Lisp has not yet overcome
#    its old reputation as hopelessly inefficient, Lisp is now used in many
#    applications where efficiency is not the central concern. For example, Lisp
#    has become a language of choice for operating-system shell languages and for
#    extension languages for editors and computer-aided design systems.
   Debido a su carácter experimental y su énfasis en la manipulación de
   símbolos, Lisp fue al principio muy ineficiente para cálculos numéricos, al
   menos en comparación con Fortran. Con el paso de los años, sin embargo, se
   han desarrollado compiladores de Lisp que traducen programas a código máquina
   que puede realizar cálculos numéricos razonablemente eficientes. Y para
   aplicaciones especiales, Lisp se ha utilizado con gran eficacia.@n(3) Aunque
   Lisp todavía no ha superado su vieja reputación como desesperadamente
   ineficiente, ahora se usa en muchas aplicaciones donde la eficiencia no es la
   preocupación central. Por ejemplo, Lisp se ha convertido en un lenguaje para
   shell del sistema operativo y como lenguajes de extensión para editores y
   sistemas de diseño asistido por computador.

#    If Lisp is not a mainstream language, why are we using it as the framework for
#    our discussion of programming?  Because the language possesses unique features
#    that make it an excellent medium for studying important programming constructs
#    and data structures and for relating them to the linguistic features that
#    support them. The most significant of these features is the fact that Lisp
#    descriptions of processes, called @e(procedures), can themselves be
#    represented and manipulated as Lisp data. The importance of this is that there
#    are powerful program-design techniques that rely on the ability to blur the
#    traditional distinction between @"(passive) data and @"(active) processes. As
#    we shall discover, Lisp's flexibility in handling procedures as data makes it
#    one of the most convenient languages in existence for exploring these
#    techniques. The ability to represent procedures as data also makes Lisp an
#    excellent language for writing programs that must manipulate other programs as
#    data, such as the interpreters and compilers that support computer languages.
#    Above and beyond these considerations, programming in Lisp is great fun.
   Si Lisp no es un lenguaje convencional, ¿por qué lo utilizamos como marco
   para nuestra discusión sobre programación? Porque el lenguaje posee
   características únicas que lo convierten en un medio excelente para estudiar
   importantes construcciones de programación y estructuras de datos y para
   relacionarlas con las características lingüísticas que las soportan. La más
   significativa de estas características es el hecho de que las descripciones
   Lisp de procesos, llamados @e(procedimientos), pueden ser representadas y
   manipuladas como datos Lisp. La importancia de esto es que hay poderosas
   técnicas de diseño de programas que se basan en la capacidad de difuminar la
   distinción tradicional entre datos @"(pasivos) y procesos @"(activos). Como
   veremos, la flexibilidad de Lisp en el manejo de procedimientos como datos
   hace que sea uno de los lenguajes más convenientes en existencia para
   explorar estas técnicas. La capacidad de representar los procedimientos como
   datos también convierte a Lisp en un excelente lenguaje para escribir
   programas que deben manipular otros programas como datos, como los
   intérpretes y compiladores que soportan los lenguajes de la computadora. Por
   encima y más allá de estas consideraciones, la programación en Lisp es muy
   divertida.

# ** 1.1 <> The Elements of Programming
** 1.1 <> Los Elementos de la Programación

#    A powerful programming language is more than just a means for instructing a
#    computer to perform tasks. The language also serves as a framework within
#    which we organize our ideas about processes. Thus, when we describe a
#    language, we should pay particular attention to the means that the language
#    provides for combining simple ideas to form more complex ideas. Every powerful
#    language has three mechanisms for accomplishing this:
   Un potente lenguaje de programación es más que un medio para enseñar a un
   computador a realizar tareas. El lenguaje también sirve como un marco dentro
   del cual organizamos nuestras ideas sobre los procesos. Por lo tanto, cuando
   describimos un lenguaje, debemos prestar especial atención a los medios que
   el lenguaje provee para combinar ideas simples para formar ideas más
   complejas. Cada lenguaje poderoso tiene tres mecanismos para lograr esto:

#    - @b{primitive expressions}, which represent the simplest entities the
#      language is concerned with,
   - @b(Expresiones primitivas), que representan las entidades más simples del
     lenguaje,

#    - @b{means of combination}, by which compound elements are built from simpler
#      ones, and
   - @b(Medios de combinación), mediante los cuales los elementos compuestos se
     construyen a partir de los más simples, y

#    - @b{means of abstraction}, by which compound elements can be named and
#      manipulated as units.
   - @b(Medios de abstracción), mediante los cuales los elementos compuestos
     pueden ser nombrados y manipulados como unidades.


#    In programming, we deal with two kinds of elements: procedures and
#    data. (Later we will discover that they are really not so distinct.)
#    Informally, data is @"(stuff) that we want to manipulate, and procedures are
#    descriptions of the rules for manipulating the data. Thus, any powerful
#    programming language should be able to describe primitive data and primitive
#    procedures and should have methods for combining and abstracting procedures
#    and data.
   En la programación, nos ocupamos de dos tipos de elementos: procedimientos y
   datos. Informalmente, los datos son @"(cosas) que queremos manipular, y los
   procedimientos son descripciones de las reglas para manipular los datos. Por
   lo tanto, cualquier lenguaje de programación potente debe ser capaz de
   describir datos primitivos y procedimientos primitivos y debe tener métodos
   para combinar y abstraer procedimientos y datos.

#    In this chapter we will deal only with simple numerical data so that we can
#    focus on the rules for building procedures.@n(4) In later chapters we will see
#    that these same rules allow us to build procedures to manipulate compound data
#    as well.
   En este capítulo trataremos sólo con datos numéricos simples para que podamos
   centrarnos en las reglas para la construcción de procedimientos.@n(4) En
   capítulos posteriores veremos que estas mismas reglas también nos permiten
   construir procedimientos para manipular datos compuestos.

# *** 1.1.1 <> Expressions
*** 1.1.1 <> Expresiones

#     One easy way to get started at programming is to examine some typical
#     interactions with an interpreter for the Scheme dialect of Lisp. Imagine that
#     you are sitting at a computer terminal. You type an @e(expression), and the
#     interpreter responds by displaying the result of its @e(evaluating) that
#     expression.
    Una manera fácil de empezar en la programación es examinar algunas
    interacciones típicas con un intérprete del dialecto Scheme de Lisp.
    Imagine que usted está sentado en una terminal de computadora. Escribe una
    @e(expresión) y el intérprete responde mostrando el resultado de su
    @e(evaluación).

#     One kind of primitive expression you might type is a number. (More precisely,
#     the expression that you type consists of the numerals that represent the
#     number in base 10.)  If you present Lisp with a number
    Un tipo de expresión primitiva que puede escribir es un número. (Más
    precisamente, la expresión que escribe consiste en los números que
    representan un número en la base 10.) Si ingresa un número

#     ..src > scheme
#       486
#     < src..
    ..src > scheme
      486
    < src..

#     the interpreter will respond by printing@n(5)
    El intérprete responderá imprimiendo@n(5)

#     ..srci > scheme
#       486
#     < srci..
    ..srci > scheme
      486
    < srci..

#     Expressions representing numbers may be combined with an expression
#     representing a primitive procedure (such as @c(+) or @c(*)) to form a compound
#     expression that represents the application of the procedure to those
#     numbers. For example:
    Las expresiones que representan números pueden combinarse con una expresión
    que representa un procedimiento primitivo (como @c(+) o @c(*)) para
    formar una expresión compuesta que representa la aplicación del
    procedimiento a esos números. Por ejemplo:

#     ..srci > scheme
#       > (+ 137 349)
#       486
#       > (- 1000 334)
#       666
#       > (* 5 99)
#       495
#       > (/ 10 5)
#       2
#       > (+ 2.7 10)
#       12.7
#     < srci..
    ..srci > scheme
      > (+ 137 349)
      486
      > (- 1000 334)
      666
      > (* 5 99)
      495
      > (/ 10 5)
      2
      > (+ 2.7 10)
      12.7
    < srci..

#     Expressions such as these, formed by delimiting a list of expressions within
#     parentheses in order to denote procedure application, are called
#     @e(combinations). The leftmost element in the list is called the @e(operator),
#     and the other elements are called @e(operands). The value of a combination is
#     obtained by applying the procedure specified by the operator to the
#     @e(arguments) that are the values of the operands.
    Expresiones como estas, formadas por una lista de expresiones delimitanda
    entre paréntesis para denotar la aplicación de procedimiento, se llaman
    @e(combinaciones). El elemento más a la izquierda en la lista se denomina el
    @e(operador), y los otros elementos se denominan los @e(operandos). El valor
    de una combinación se obtiene aplicando el procedimiento especificado por el
    operador a los @e(argumentos) que son los valores de los operandos.

#     The convention of placing the operator to the left of the operands is known as
#     @e(prefix notation), and it may be somewhat confusing at first because it
#     departs significantly from the customary mathematical convention. Prefix
#     notation has several advantages, however. One of them is that it can
#     accommodate procedures that may take an arbitrary number of arguments, as in
#     the following examples:
    La convención de colocar al operador a la izquierda de los operandos se
    conoce como @e(notación de prefijo), y puede ser algo confusa al principio
    porque se aleja significativamente de la convención matemática habitual. La
    notación de prefijo tiene varias ventajas. Una de ellas es que puede
    alojar procedimientos que pueden tomar un número arbitrario de argumentos,
    como en los siguientes ejemplos:

#     ..srci > scheme
#       > (+ 21 35 12 7)
#       75
#       > (* 25 4 12)
#       1200
#     < srci..
    ..srci > scheme
      > (+ 21 35 12 7)
      75
      > (* 25 4 12)
      1200
    < srci..

#     No ambiguity can arise, because the operator is always the leftmost element
#     and the entire combination is delimited by the parentheses.
    Ninguna ambigüedad puede surgir, porque el operador es siempre el elemento
    más a la izquierda y toda la combinación está delimitada por los paréntesis.

#     A second advantage of prefix notation is that it extends in a straightforward
#     way to allow combinations to be @e(nested), that is, to have combinations
#     whose elements are themselves combinations:
    Una segunda ventaja de la notación de prefijo es que se extiende de manera
    directa para permitir que las combinaciones sean @e(anidadas), es decir,
    tener combinaciones cuyos elementos son en si mismos combinaciones:

#     ..srci > scheme
#       > (+ (* 3 5) (- 10 6))
#       19
#     < srci..
    ..srci > scheme
      > (+ (* 3 5) (- 10 6))
      19
    < srci..

#     There is no limit (in principle) to the depth of such nesting and to the
#     overall complexity of the expressions that the Lisp interpreter can evaluate.
#     It is we humans who get confused by still relatively simple expressions such
#     as
    No hay límite (en principio) a la profundidad de este anidamiento ni a la
    complejidad general de las expresiones que el intérprete Lisp puede
    evaluar. Somos nosotros los seres humanos que nos confundimos con
    expresiones relativamente simples, como

#     ..src > scheme
#       (+ (* 3 (+ (* 2 4) (+ 3 5))) (+ (- 10 7) 6))
#     < src..
    ..src > scheme
      (+ (* 3 (+ (* 2 4) (+ 3 5))) (+ (- 10 7) 6))
    < src..

#     which the interpreter would readily evaluate to be 57. We can help ourselves
#     by writing such an expression in the form
    Que el intérprete evaluaría fácilmente como 57. Podemos ayudarnos
    escribiendo tal expresión en la forma

#     ..src > scheme
#       (+ (* 3
#             (+ (* 2 4)
#                (+ 3 5)))
#          (+ (- 10 7)
#             6))
#     < src..
    ..src > scheme
      (+ (* 3
            (+ (* 2 4)
               (+ 3 5)))
         (+ (- 10 7)
            6))
    < src..

#     following a formatting convention known as @e(pretty-printing), in which each
#     long combination is written so that the operands are aligned vertically.  The
#     resulting indentations display clearly the structure of the expression.@n(6)
    Siguiendo una convención de formato conocida como @e(pretty-printing), en la
    que cada combinación larga se escribe para que los operandos estén alineados
    verticalmente. Las indentaciones resultantes muestran claramente la
    estructura de la expresión.@n(6)

#     Even with complex expressions, the interpreter always operates in the same
#     basic cycle: It reads an expression from the terminal, evaluates the
#     expression, and prints the result. This mode of operation is often expressed
#     by saying that the interpreter runs in a @e(read-eval-print loop).  Observe in
#     particular that it is not necessary to explicitly instruct the interpreter to
#     print the value of the expression.@n(7)
    Incluso con expresiones complejas, el intérprete siempre opera en el mismo
    ciclo básico: lee una expresión desde el terminal, evalúa la expresión e
    imprime el resultado. Este modo de operación se expresa a menudo diciendo
    que el intérprete se ejecuta en un @e(bucle de lectura-evaluacion-impresion).
    Observe en particular que no es necesario instruir explícitamente al
    intérprete para que imprima el valor de la expresión.@n(7)

# *** 1.1.2 <> Naming and the Environment
*** 1.1.2 <> Nombres y Entorno

#     A critical aspect of a programming language is the means it provides for using
#     names to refer to computational objects. We say that the name identifies a
#     @e(variable) whose @e(value) is the object.
    Un aspecto crítico de un lenguaje de programación es el medio que
    proporciona para referirse a objetos computacionales mediante
    nombres. Decimos que el nombre identifica una @e(variable) cuyo @e(valor) es
    el objeto.

#     In the Scheme dialect of Lisp, we name things with @c(define). Typing
    En el dialecto Scheme de Lisp, nombramos cosas con @c(define). Escriba

#     ..src > scheme
#       (define size 2)
#     < src..
    ..src > scheme
      (define size 2)
    < src..

#     causes the interpreter to associate the value 2 with the name @c(size).@n(8)
#     Once the name @c(size) has been associated with the number 2, we can refer to
#     the value 2 by name:
    Hace que el intérprete asocie el valor 2 con el nombre @c(size).@n(8) Una
    vez que el nombre @c(size) se ha asociado con el número 2, podemos
    referirnos al valor 2 por nombre:

#     ..srci > scheme
#       > size
#       2
#       > (* 5 size)
#       10
#     < srci..
    ..srci > scheme
      > size
      2
      > (* 5 size)
      10
    < srci..

#     Here are further examples of the use of @c(define):
    Aquí hay otros ejemplos del uso de @c(define):

#     ..srci > scheme
#       > (define pi 3.14159)
#       > (define radius 10)
#       > (* pi (* radius radius))
#       314.159
#       > (define circumference (* 2 pi radius))
#       > circumference
#       62.8318
#     < srci..
    ..srci > scheme
      > (define pi 3.14159)
      > (define radius 10)
      > (* pi (* radius radius))
      314.159
      > (define circumference (* 2 pi radius))
      > circumference
      62.8318
    < srci..

#     @c(define) is our language's simplest means of abstraction, for it allows us
#     to use simple names to refer to the results of compound operations, such as
#     the @c(circumference) computed above. In general, computational objects may
#     have very complex structures, and it would be extremely inconvenient to have
#     to remember and repeat their details each time we want to use them. Indeed,
#     complex programs are constructed by building, step by step, computational
#     objects of increasing complexity. The interpreter makes this step-by-step
#     program construction particularly convenient because name-object associations
#     can be created incrementally in successive interactions. This feature
#     encourages the incremental development and testing of programs and is largely
#     responsible for the fact that a Lisp program usually consists of a large
#     number of relatively simple procedures.
    @c(define) es el medio más simple de abstracción de nuestro lenguaje, ya que
    nos permite usar nombres simples para referirnos a los resultados de
    operaciones compuestas, como el anterior calculo de @c(circumference). En
    general, los objetos computacionales pueden tener estructuras muy complejas,
    y sería extremadamente incómodo tener que recordar y repetir sus detalles
    cada vez que queramos usarlos. De hecho, los programas complejos se
    construyen construyendo, paso a paso, objetos computacionales de creciente
    complejidad. El intérprete hace que esta construcción del programa paso a
    paso resulte particularmente conveniente ya que las asociaciones
    nombre-objeto pueden crearse de forma incremental en sucesivas
    interacciones. Esta característica estimula el desarrollo y la prueba
    incremental de los programas y es en gran parte responsable del hecho de que
    un programa Lisp por lo general consiste en un gran número de procedimientos
    relativamente simples.

#     It should be clear that the possibility of associating values with symbols and
#     later retrieving them means that the interpreter must maintain some sort of
#     memory that keeps track of the name-object pairs. This memory is called the
#     @e(environment) (more precisely the @e(global environment), since we will see
#     later that a computation may involve a number of different environments).@n(9)
    Debe quedar claro que la posibilidad de asociar valores con símbolos y
    recuperarlos posteriormente significa que el intérprete debe mantener algún
    tipo de memoria que rastree los pares nombre-objeto. Esta memoria se llama
    el @e(entorno) (más precisamente el @e(entorno global), ya que veremos más
    adelante que un cálculo puede implicar un número de entornos
    diferentes).@n(9)

# *** 1.1.3 <> Evaluating Combinations
*** 1.1.3 <> Evaluando Combinaciones

#     One of our goals in this chapter is to isolate issues about thinking
#     procedurally. As a case in point, let us consider that, in evaluating
#     combinations, the interpreter is itself following a procedure.
    Uno de nuestros objetivos en este capítulo es aislar las cuestiones
    relativas al pensamiento procedimental. Como ejemplo, consideremos que, al
    evaluar las combinaciones, el intérprete está siguiendo un procedimiento.

#     - To evaluate a combination, do the following:
    - Para evaluar una combinación, haga lo siguiente:

#       1. Evaluate the subexpressions of the combination.
      1. Evaluar las subexpresiones de la combinación.

#       2. Apply the procedure that is the value of the leftmost subexpression (the
#          operator) to the arguments that are the values of the other
#          subexpressions (the operands).
      2. Aplique el procedimiento que es el valor de la subexpresión más a la
         izquierda (el operador) a los argumentos que son los valores de las
         otras subexpresiones (los operandos).


#     Even this simple rule illustrates some important points about processes in
#     general. First, observe that the first step dictates that in order to
#     accomplish the evaluation process for a combination we must first perform the
#     evaluation process on each element of the combination. Thus, the evaluation
#     rule is @e(recursive) in nature; that is, it includes, as one of its steps,
#     the need to invoke the rule itself.@n(10)
    Incluso esta simple regla ilustra algunos puntos importantes sobre los
    procesos en general. Primero, observe que el primer paso determina que para
    realizar el proceso de evaluación de una combinación primero debemos
    realizar el proceso de evaluación sobre cada elemento de la combinación. Por
    lo tanto, la regla de evaluación es de naturaleza @e(recursiva); Es decir,
    incluye, como uno de sus pasos, la necesidad de invocar la regla
    misma.@n(10)

#     Notice how succinctly the idea of recursion can be used to express what, in
#     the case of a deeply nested combination, would otherwise be viewed as a rather
#     complicated process. For example, evaluating
    Obsérvese cómo brevemente se puede utilizar la idea de recursión para
    expresar lo que, en el caso de una combinación profundamente anidada, sería
    de otro modo considerada como un proceso bastante complicado. Por ejemplo,
    evaluar

#     ..src > scheme
#       (* (+ 2 (* 4 6)) (+ 3 5 7))
#     < src..
    ..src > scheme
      (* (+ 2 (* 4 6)) (+ 3 5 7))
    < src..

#     requires that the evaluation rule be applied to four different combinations.
#     We can obtain a picture of this process by representing the combination in the
#     form of a tree, as shown in @l(#Figure 1.1). Each combination is represented
#     by a node with branches corresponding to the operator and the operands of the
#     combination stemming from it. The terminal nodes (that is, nodes with no
#     branches stemming from them) represent either operators or numbers. Viewing
#     evaluation in terms of the tree, we can imagine that the values of the
#     operands percolate upward, starting from the terminal nodes and then combining
#     at higher and higher levels. In general, we shall see that recursion is a very
#     powerful technique for dealing with hierarchical, treelike objects. In fact,
#     the @"(percolate values upward) form of the evaluation rule is an example of a
#     general kind of process known as @e(tree accumulation).
    Requiere que la regla de evaluación se aplique a cuatro combinaciones
    diferentes. Podemos obtener una imagen de este proceso representando la
    combinación en forma de árbol, como se muestra en la @l(#Figura 1.1). Cada
    combinación está representada por un nodo con ramas correspondientes al
    operador y los operandos de la combinación que se derivan de él. Los nodos
    terminales (es decir, nodos sin ramas derivadas de ellos) representan tanto
    operadores como números. Viendo la evaluación en términos del árbol, podemos
    imaginar que los valores de los operandos se filtran hacia arriba, partiendo
    de los nodos terminales y luego combinándose en niveles más altos y más
    altos. En general, veremos que la recursión es una técnica muy poderosa para
    tratar con objetos jerárquicos y similares a los árboles. De hecho, la
    @"(forma ascendente de valores percolada) de la regla de evaluación es un
    ejemplo de un tipo general de proceso conocido como @"(acumulación de
    árboles).

#     ..figure > @t(Figure 1.1) Tree representation, showing the value of each
#       subcombination.
    ..figure > @t(Figura 1.1) Representación de árbol, mostrando el valor de
      cada subcombinación.

#       ..art >
#            390
#            /|\____________
#           / |             \
#          *  26            15
#             /|\           /|\
#            / | \         // \\
#           +  2  24      / | | \
#                 /|\    +  3 5  7
#                / | \
#               *  4  6
#       < art..
      ..art >
           390
           /|\____________
          / |             \
         *  26            15
            /|\           /|\
           / | \         // \\
          +  2  24      / | | \
                /|\    +  3 5  7
               / | \
              *  4  6
      < art..

# @   ..img > img/chap1/Fig1.1g.std.svg
@   ..img > img/chap1/Fig1.1g.std.svg

#     Next, observe that the repeated application of the first step brings us to the
#     point where we need to evaluate, not combinations, but primitive expressions
#     such as numerals, built-in operators, or other names. We take care of the
#     primitive cases by stipulating that
    A continuación, observe que la aplicación repetida del primer paso nos lleva
    al punto en el que debemos evaluar, no combinaciones, sino expresiones
    primitivas como números, operadores nativos u otros nombres. Nos ocupamos de
    los casos primitivos estipulando que

#     - the values of numerals are the numbers that they name,
    - Los valores de los números son los números que ellos nombran,

#     - the values of built-in operators are the machine instruction sequences that
#       carry out the corresponding operations, and
    - Los valores de los operadores nativos son las secuencias de instrucciones
      máquina que llevan a cabo las operaciones correspondientes, y

#     - the values of other names are the objects associated with those names in the
#       environment.
    - Los valores de otros nombres son los objetos asociados con esos nombres en
      el entorno.

#     We may regard the second rule as a special case of the third one by
#     stipulating that symbols such as @c(+) and @c(*) are also included in the
#     global environment, and are associated with the sequences of machine
#     instructions that are their @"(values.)  The key point to notice is the role
#     of the environment in determining the meaning of the symbols in
#     expressions. In an interactive language such as Lisp, it is meaningless to
#     speak of the value of an expression such as @c[(+ x 1)] without specifying any
#     information about the environment that would provide a meaning for the symbol
#     @c(x) (or even for the symbol @c(+)). As we shall see in @l(#Chapter 3), the
#     general notion of the environment as providing a context in which evaluation
#     takes place will play an important role in our understanding of program
#     execution.
    Podemos considerar la segunda regla como un caso especial de la tercera,
    estipulando que los símbolos como @c(+) y @c(*) también están incluidos en
    el entorno global, y están asociados con las secuencias de instrucciones de
    la máquina que son sus @"(valores). El punto clave a observar es el papel
    del entorno en la determinación del significado de los símbolos en las
    expresiones. En un lenguaje interactivo como Lisp, no tiene sentido hablar
    del valor de una expresión como @c[(+ x 1)] sin especificar ninguna
    información sobre el entorno que proporcionaría un significado para el
    símbolo @c(x) (o incluso para el símbolo @c(+)). Como veremos en el
    @l(#Capitulo 3), la noción general del entorno como un contexto en el cual
    la evaluación tiene lugar desempeñará un papel importante en nuestra
    comprensión de la ejecución del programa.

#     Notice that the evaluation rule given above does not handle definitions. For
#     instance, evaluating @c[(define x 3)] does not apply @c(define) to two
#     arguments, one of which is the value of the symbol @c(x) and the other of
#     which is 3, since the purpose of the @c(define) is precisely to associate
#     @c(x) with a value. (That is, @c[(define x 3)] is not a combination.)
    Observe que la regla de evaluación dada anteriormente no maneja
    definiciones. Por ejemplo, la evaluación @c[(define x 3)] no aplica
    @c(define) a dos argumentos, uno de estos es el valor del símbolo @c(x) y el
    otro es 3, ya que el propósito de @c(define) es precisamente asociar @c(x)
    con un valor. (Es decir, @c[(define x 3)] no es una combinación.)

#     Such exceptions to the general evaluation rule are called @e(special forms).
#     @c(define) is the only example of a special form that we have seen so far, but
#     we will meet others shortly. Each special form has its own evaluation
#     rule. The various kinds of expressions (each with its associated evaluation
#     rule) constitute the syntax of the programming language. In comparison with
#     most other programming languages, Lisp has a very simple syntax; that is, the
#     evaluation rule for expressions can be described by a simple general rule
#     together with specialized rules for a small number of special forms.@n(11)
    Tales excepciones a la regla general de evaluación se llaman @e(formas
    especiales). @c(define) es el único ejemplo de una forma especial que hemos
    visto hasta ahora, pero pronto nos reuniremos con otros. Cada forma especial
    tiene su propia regla de evaluación. Los distintos tipos de expresiones
    (cada uno con su regla de evaluación asociada) constituyen la sintaxis del
    lenguaje de programación. En comparación con la mayoría de otros lenguajes
    de programación, Lisp tiene una sintaxis muy simple; Es decir, la regla de
    evaluación para las expresiones puede ser descrita por una regla general
    simple junto con reglas especializadas para un pequeño número de formas
    especiales.@n(11)

# *** 1.1.4 <> Compound Procedures
*** 1.1.4 <> Procedimientos compuestos

#     We have identified in Lisp some of the elements that must appear in any
#     powerful programming language:
    Hemos identificado en Lisp algunos de los elementos que deben aparecer en
    cualquier lenguaje de programación poderoso:

#     - Numbers and arithmetic operations are primitive data and procedures.
    - Los números y operaciones aritméticas son datos primitivos y
      procedimientos.

#     - Nesting of combinations provides a means of combining operations.
    - El anidamiento de combinaciones proporciona un medio de combinar
      operaciones.

#     - Definitions that associate names with values provide a limited means of
#       abstraction.
    - Las definiciones que asocian nombres con valores proporcionan un medio
      limitado de abstracción.

#     Now we will learn about @e(procedure definitions), a much more powerful
#     abstraction technique by which a compound operation can be given a name and
#     then referred to as a unit.
    Ahora aprenderemos sobre las @e(definiciones de los procedimientos), una
    técnica de abstracción mucho más poderosa mediante la cual puede darse un
    nombre a una operación compuesta y luego referirla como una unidad.

#     We begin by examining how to express the idea of @"(squaring.)  We might say,
#     @"(To square something, multiply it by itself.)  This is expressed in our
#     language as
    Comenzamos examinando cómo expresar la idea de @"(cuadratura). Podríamos
    decir: @"(Para cuadrar algo, multiplíquelo por sí mismo).  Esto se expresa
    en nuestro lenguaje como

#     ..src > scheme
#       (define (square x) (* x x))
#     < src..
    ..src > scheme
      (define (square x) (* x x))
    < src..

#     We can understand this in the following way:
    Podemos entender esto de la siguiente manera:

#     ..example >
#       (define (square x)    (*       x       x))
#         |      |      |      |       |       |
#        To square something, multiply it by itself.
#     < example..
    ..example >
      (define (square x)     (*          x       x))
        |      |      |       |          |       |
       Para cuadrar algo, multipliquelo por si mismo
    < example..

#     We have here a @e(compound procedure), which has been given the name
#     @c(square). The procedure represents the operation of multiplying something by
#     itself. The thing to be multiplied is given a local name, @c(x), which plays
#     the same role that a pronoun plays in natural language. Evaluating the
#     definition creates this compound procedure and associates it with the name
#     @c(square).@n(12)
    Tenemos aquí un @e(procedimiento compuesto), al que se ha dado el nombre
    @c(square). El procedimiento representa la operación de multiplicar algo por
    sí mismo. La cosa a ser multiplicada recive un nombre local @c(x), que juega
    el mismo papel que un pronombre juega en lenguaje natural. La evaluación de
    la definición crea este procedimiento compuesto y lo asocia con el nombre
    @c(square).@n(12)

#     The general form of a procedure definition is
    La forma general de una definición de procedimiento es

#     ..src > scheme
#       (define (⟨name⟩ ⟨formal parameters⟩) ⟨body⟩)
#     < src..
    ..src > scheme
      (define (⟨nombre⟩ ⟨parametros formales⟩) ⟨cuerpo⟩)
    < src..

#     The @c[⟨name⟩] is a symbol to be associated with the procedure definition in
#     the environment.@n(13) The @c[⟨formal parameters⟩] are the names used within
#     the body of the procedure to refer to the corresponding arguments of the
#     procedure. The @c[⟨body⟩] is an expression that will yield the value of the
#     procedure application when the formal parameters are replaced by the actual
#     arguments to which the procedure is applied.@n(14) The @c[⟨name⟩] and the
#     @c[⟨formal parameters⟩] are grouped within parentheses, just as they would be
#     in an actual call to the procedure being defined.
    El @c[⟨nombre⟩] símbolo es un símbolo asociado con la definición del
    procedimiento en el entorno.@n(13) Los @c[⟨parametros formales⟩] son los
    nombres utilizados dentro del cuerpo del procedimiento para referirse a los
    argumentos correspondientes del procedimiento. El @c[⟨cuerpo⟩] es una expresión
    que dará el valor de la aplicación de procedimiento cuando los parámetros
    formales son reemplazados por los argumentos reales a los que se aplica el
    procedimiento.@n(14) El @c[⟨nombre⟩] y los @c[⟨parametros formales⟩] se
    agrupan entre paréntesis, como serían en una llamada real al
    procedimiento que se está definiendo.

#     Having defined @c(square), we can now use it:
    Una vez definido @c(square), podemos utilizarlo:

#     ..srci > scheme
#       > (square 21)
#       441
#       > (square (+ 2 5))
#       49
#       > (square (square 3))
#       81
#     < srci..
    ..srci > scheme
      > (square 21)
      441
      > (square (+ 2 5))
      49
      > (square (square 3))
      81
    < srci..

#     We can also use @c(square) as a building block in defining other procedures.
#     For example, @m(x² + y²) can be expressed as
    También podemos utilizar @c(square) como un elemento fundamental en la
    definición de otros procedimientos. Por ejemplo, @m(x² + y²) puede
    expresarse como

#     ..src > scheme
#       (+ (square x) (square y))
#     < src..
    ..src > scheme
      (+ (square x) (square y))
    < src..

#     We can easily define a procedure @c(sum-of-squares) that, given any two
#     numbers as arguments, produces the sum of their squares:
    Podemos definir fácilmente un procedimiento @c(sum-of-squares) que, dados dos
    números como argumentos, produce la suma de sus cuadrados:

#     ..srci > scheme
#       > (define (sum-of-squares x y)
#       ^   (+ (square x) (square y)))
#       > (sum-of-squares 3 4)
#       25
#     < srci..
    ..srci > scheme
      > (define (sum-of-squares x y)
      ^   (+ (square x) (square y)))
      > (sum-of-squares 3 4)
      25
    < srci..

#     Now we can use @c(sum-of-squares) as a building block in constructing further
#     procedures:
    Ahora podemos usar @c(sum-of-squares) como un elemento fundamental en la
    construcción de procedimientos adicionales:

#     ..srci > scheme
#       > (define (f a)
#       ^   (sum-of-squares (+ a 1) (* a 2)))
#       > (f 5)
#       136
#     < srci..
    ..srci > scheme
      > (define (f a)
      ^   (sum-of-squares (+ a 1) (* a 2)))
      > (f 5)
      136
    < srci..

#     Compound procedures are used in exactly the same way as primitive procedures.
#     Indeed, one could not tell by looking at the definition of @c(sum-of-squares)
#     given above whether @c(square) was built into the interpreter, like @c(+) and
#     @c(*), or defined as a compound procedure.
    Los procedimientos compuestos se usan exactamente de la misma manera que los
    procedimientos primitivos. De hecho, uno no podría decir al mirar la
    definición de @c(sum-of-squares) anterior si @c(square) fue construido en el
    intérprete igual a @c(+) y @c(*), o definido como un procedimiento
    compuesto.

# *** 1.1.5 <> The Substitution Model for Procedure Application
*** 1.1.5 <> El Modelo de Sustitución para la Aplicación de Procedimientos

#     To evaluate a combination whose operator names a compound procedure, the
#     interpreter follows much the same process as for combinations whose operators
#     name primitive procedures, which we described in section @l(#1.1.3). That is, the
#     interpreter evaluates the elements of the combination and applies the
#     procedure (which is the value of the operator of the combination) to the
#     arguments (which are the values of the operands of the combination).
    Para evaluar una combinación cuyo operador nombra un procedimiento
    compuesto, el intérprete sigue mucho el mismo proceso que para las
    combinaciones cuyos operadores denominan procedimientos primitivos, que
    describimos en la seccion @l(#1.1.3). Es decir, el intérprete evalúa los
    elementos de la combinación y aplica el procedimiento (que es el valor del
    operador de la combinación) a los argumentos (que son los valores de los
    operandos de la combinación).

#     We can assume that the mechanism for applying primitive procedures to
#     arguments is built into the interpreter. For compound procedures, the
#     application process is as follows:
    Podemos asumir que el mecanismo para aplicar procedimientos primitivos a los
    argumentos está incorporado en el intérprete. Para procedimientos
    compuestos, el proceso de aplicación es el siguiente:

#     - To apply a compound procedure to arguments, evaluate the body of the
#       procedure with each formal parameter replaced by the corresponding argument.
    - Para aplicar un procedimiento compuesto a los argumentos, evalúe el cuerpo
      del procedimiento con cada parámetro formal reemplazado por el argumento
      correspondiente.


#     To illustrate this process, let's evaluate the combination
   Para ilustrar este proceso, vamos a evaluar la combinación

#     ..src > scheme
#       (f 5)
#     < src..
    ..src > scheme
      (f 5)
    < src..

#     where @c(f) is the procedure defined in section @l(#1.1.4). We begin by retrieving the
#     body of @c(f):
    Donde @c(f) está el procedimiento definido en la seccion @l(#1.1.4).
    Comenzamos recuperando el cuerpo de @c(f):

#     ..src > scheme
#       (sum-of-squares (+ a 1) (* a 2))
#     < src..
    ..src > scheme
      (sum-of-squares (+ a 1) (* a 2))
    < src..

#     Then we replace the formal parameter @c(a) by the argument 5:
    Entonces reemplazamos el parámetro formal @c(a) por el argumento 5:

#     ..src > scheme
#       (sum-of-squares (+ 5 1) (* 5 2))
#     < src..
    ..src > scheme
      (sum-of-squares (+ 5 1) (* 5 2))
    < src..

#     Thus the problem reduces to the evaluation of a combination with two operands
#     and an operator @c(sum-of-squares). Evaluating this combination involves three
#     subproblems. We must evaluate the operator to get the procedure to be applied,
#     and we must evaluate the operands to get the arguments. Now @c[(+ 5 1)]
#     produces 6 and @c[(* 5 2)] produces 10, so we must apply the
#     @c(sum-of-squares) procedure to 6 and 10. These values are substituted for the
#     formal parameters @c(x) and @c(y) in the body of @c(sum-of-squares), reducing
#     the expression to
    Así, el problema se reduce a la evaluación de una combinación con dos
    operandos y el operador @c(sum-of-squares). La evaluación de esta
    combinación implica tres subproblemas. Debemos evaluar al operador para
    obtener el procedimiento a aplicar, y debemos evaluar los operandos para
    obtener los argumentos. Ahora @c[(+ 5 1)] produce 6 y @c[(* 5 2)] produce
    10, por lo que debemos aplicar el procedimiento @c(sum-of-squares) a 6
    y 10. Estos valores son sustituidos por los parámetros formales @c(x) y
    @c(y) en el cuerpo de @c(sum-of-squares), reduciendo la expresión a

#     ..src > scheme
#       (+ (square 6) (square 10))
#     < src..
    ..src > scheme
      (+ (square 6) (square 10))
    < src..

#     If we use the definition of @c(square), this reduces to
    Si usamos la definición de @c(square), esto se reduce a

#     ..src > scheme
#       (+ (* 6 6) (* 10 10))
#     < src..
    ..src > scheme
      (+ (* 6 6) (* 10 10))
    < src..

#     which reduces by multiplication to
    Que reduce por multiplicación a

#     ..src > scheme
#       (+ 36 100)
#     < src..
    ..src > scheme
      (+ 36 100)
    < src..

#     and finally to
    Y finalmente a

#     ..srci > scheme
#       136
#     < srci..
    ..srci > scheme
      136
    < srci..

#     The process we have just described is called the @e(substitution model) for
#     procedure application. It can be taken as a model that determines the
#     @"(meaning) of procedure application, insofar as the procedures in this
#     chapter are concerned. However, there are two points that should be stressed:
    El proceso que acabamos de describir se llama @e(modelo de sustitución) para
    la aplicación del procedimiento. Puede tomarse como un modelo que determina
    el @"(significado) de la aplicación del procedimiento, en lo que se refiere
    a los procedimientos de este capítulo. Sin embargo, hay dos puntos que deben
    subrayarse:

#     - The purpose of the substitution is to help us think about procedure
#       application, not to provide a description of how the interpreter really
#       works.  Typical interpreters do not evaluate procedure applications by
#       manipulating the text of a procedure to substitute values for the formal
#       parameters. In practice, the @"(substitution) is accomplished by using a
#       local environment for the formal parameters. We will discuss this more fully
#       in @l(#Chapter 3) and @l(#Chapter 4) when we examine the implementation of
#       an interpreter in detail.
    - El propósito de la sustitución es ayudarnos a pensar en la aplicación del
      procedimiento, no a proporcionar una descripción de cómo el intérprete
      funciona realmente. Los intérpretes típicos no evalúan las aplicaciones de
      procedimiento manipulando el texto de un procedimiento para sustituir
      valores por los parámetros formales. En la práctica, la @"(sustitución) se
      logra utilizando un entorno local para los parámetros formales.
      Discutiremos esto más detalladamente en el @l(#Capitulo 3) y el
      @l(#Capitulo 4) cuando examinemos la implementación de un intérprete en
      detalle.

#     - Over the course of this book, we will present a sequence of increasingly
#       elaborate models of how interpreters work, culminating with a complete
#       implementation of an interpreter and compiler in @l(#Chapter 5). The
#       substitution model is only the first of these models––a way to get started
#       thinking formally about the evaluation process. In general, when modeling
#       phenomena in science and engineering, we begin with simplified, incomplete
#       models. As we examine things in greater detail, these simple models become
#       inadequate and must be replaced by more refined models. The substitution
#       model is no exception. In particular, when we address in @l(#Chapter 3) the
#       use of procedures with @"(mutable data,) we will see that the substitution
#       model breaks down and must be replaced by a more complicated model of
#       procedure application.@n(15)
    - A lo largo de este libro, presentaremos una secuencia de modelos cada vez
      más elaborados de cómo funcionan los intérpretes, culminando con la
      implementación completa de un intérprete y compilador en el @l(#Capitulo 5).
      El modelo de sustitución es sólo el primero de estos modelos––una forma de
      empezar a pensar formalmente sobre el proceso de evaluación. En general,
      al modelar fenómenos en la ciencia y la ingeniería, comenzamos con modelos
      simplificados e incompletos. A medida que examinamos las cosas con mayor
      detalle, estos modelos simples se vuelven inadecuados y deben ser
      reemplazados por modelos más refinados. El modelo de sustitución no es una
      excepción. En particular, cuando abordemos el uso de procedimientos con
      @"(datos mutables) en el @l(#Capitulo 3), veremos que el modelo de
      sustitución se quiebra y debe ser reemplazado por un modelo de aplicación
      de procedimiento más complicado.@n(15)

# **** Applicative order versus normal order
**** Orden aplicable vs orden normal

#      According to the description of evaluation given in section @l(#1.1.3), the
#      interpreter first evaluates the operator and operands and then applies the
#      resulting procedure to the resulting arguments. This is not the only way to
#      perform evaluation. An alternative evaluation model would not evaluate the
#      operands until their values were needed. Instead it would first substitute
#      operand expressions for parameters until it obtained an expression involving
#      only primitive operators, and would then perform the evaluation. If we used
#      this method, the evaluation of @c[(f 5)] would proceed according to the
#      sequence of expansions
     De acuerdo con la descripción de la evaluación dada en la seccion
     @l(#1.1.3), el intérprete evalúa primero el operador y los operandos y
     luego aplica el procedimiento resultante a los argumentos resultantes. Esta
     no es la única manera de realizar la evaluación. Un modelo de evaluación
     alternativo no evaluaría los operandos hasta que sus valores fueran
     necesarios. En su lugar, primero sustituiría las expresiones de operando
     por los parámetros hasta que obtuviera una expresión que sólo involucraría
     a operadores primitivos, y luego realizaría la evaluación. Si usamos este
     método, la evaluación de @c[(f 5)] procedería de acuerdo con la secuencia
     de expansiones

#      ..src > scheme
#        (sum-of-squares (+ 5 1) (* 5 2))
#
#        (+ (square (+ 5 1))
#           (square (* 5 2)))
#
#        (+ (* (+ 5 1) (+ 5 1))
#           (* (* 5 2) (* 5 2)))
#      < src..
     ..src > scheme
       (sum-of-squares (+ 5 1) (* 5 2))

       (+ (square (+ 5 1))
          (square (* 5 2)))

       (+ (* (+ 5 1) (+ 5 1))
          (* (* 5 2) (* 5 2)))
     < src..

#      followed by the reductions
     Seguido por las reducciones

#      ..srci > scheme
#        > (+ (* 6 6)
#        ^    (* 10 10))
#        > (+ 36 100)
#        136
#      < srci..
     ..srci > scheme
       > (+ (* 6 6)
       ^    (* 10 10))
       > (+ 36 100)
       136
     < srci..

#      This gives the same answer as our previous evaluation model, but the process
#      is different. In particular, the evaluations of @c[(+ 5 1)] and @c[(* 5 2)]
#      are each performed twice here, corresponding to the reduction of the
#      expression @c[(* x x)] with @c(x) replaced respectively by @c[(+ 5 1)] and
#      @c[(* 5 2)].
     Esto da la misma respuesta que nuestro modelo de evaluación anterior, pero
     el proceso es diferente. En particular, las evaluaciones de @c[(+ 5 1)] y
     @c[(* 5 2)] se realizan cada una dos veces, que corresponden a la reducción
     de la expresión @c[(* x x)] con @c(x) sustituido respectivamente por @c[(+
     5 1)] y @c[(* 5 2)].

#      This alternative @"(fully expand and then reduce) evaluation method is known
#      as @e(normal-order evaluation), in contrast to the @"(evaluate the arguments
#      and then apply) method that the interpreter actually uses, which is called
#      @e(applicative-order evaluation). It can be shown that, for procedure
#      applications that can be modeled using substitution (including all the
#      procedures in the first two chapters of this book) and that yield legitimate
#      values, normal-order and applicative-order evaluation produce the same value.
#      (See @l(#Exercise 1.5) for an instance of an @"(illegitimate) value where
#      normal-order and applicative-order evaluation do not give the same result.)
     Esta alternativa de @"(expandir completamente y luego reducir) el método de
     evaluación se conoce como @e(evaluación de orden normal), en contraste con
     la @"(evaluación de los argumentos y luego aplicar) el método que el
     intérprete realmente utiliza, que se llama @e(aplicación de orden de
     evaluación). Se puede demostrar que para aplicaciones de procedimiento que
     pueden ser modeladas usando sustitución (incluyendo todos los
     procedimientos en los dos primeros capítulos de este libro) y que producen
     valores legítimos, la evaluacion de orden normal y de orden aplicativo
     producen el mismo valor. (Vea el @l(#Ejercicio 1.5) para una instancia de
     un valor @"(ilegítimo) donde el orden normal y el orden aplicativo no dan
     el mismo resultado).

#      Lisp uses applicative-order evaluation, partly because of the additional
#      efficiency obtained from avoiding multiple evaluations of expressions such as
#      those illustrated with @c[(+ 5 1)] and @c[(* 5 2)] above and, more
#      significantly, because normal-order evaluation becomes much more complicated
#      to deal with when we leave the realm of procedures that can be modeled by
#      substitution. On the other hand, normal-order evaluation can be an extremely
#      valuable tool, and we will investigate some of its implications in @l(#Chapter
#      3) and @l(#Chapter 4).@n(16)
     Lisp utiliza la evaluación de orden aplicativo, en parte debido a la
     eficiencia adicional obtenida evitando evaluaciones múltiples de
     expresiones como las ilustradas arriba con @c[(+ 5 1)] y @c[(* 5 2)], más
     significativamente, porque la evaluación de orden normal se vuelve mucho
     más complicada cuando salimos del reino de procedimientos que pueden ser
     modelados por sustitución. Por otro lado, la evaluación de orden normal
     puede ser una herramienta extremadamente valiosa, e investigaremos algunas
     de sus implicaciones en el @l(#Capitulo 3) y el @l(#Capitulo 4).@n(16)

# *** 1.1.6 <> Conditional Expressions and Predicates
*** 1.1.6 <> Expresiones Condicionales y Predicados

#     The expressive power of the class of procedures that we can define at this
#     point is very limited, because we have no way to make tests and to perform
#     different operations depending on the result of a test. For instance, we
#     cannot define a procedure that computes the absolute value of a number by
#     testing whether the number is positive, negative, or zero and taking different
#     actions in the different cases according to the rule
    El poder expresivo de la clase de procedimientos que podemos definir en este
    punto es muy limitado, porque no tenemos forma de hacer pruebas y realizar
    operaciones diferentes dependiendo del resultado de una prueba. Por ejemplo,
    no podemos definir un procedimiento que calcule el valor absoluto de un
    número probando si el número es positivo, negativo o cero y tomando acciones
    diferentes en los diferentes casos según la regla

#     ..example >
#              ╭
#              │   x  if x > 0
#       │x│ = <    0  if x = 0
#              │  −x  if x < 0
#              ╰
#     < example..
    ..example >
             ╭
             │   x  if x > 0
      │x│ = <    0  if x = 0
             │  −x  if x < 0
             ╰
    < example..

#     This construct is called a @e(case analysis), and there is a special form in
#     Lisp for notating such a case analysis. It is called @c(cond) (which stands
#     for @"(conditional)), and it is used as follows:
    Esta construcción se llama un @e(análisis de casos), y hay una forma
    especial en Lisp para anotar tal análisis de casos. Se llama @c(cond) (que
    significa @"(condicional)), y se utiliza de la siguiente manera:

#     ..src > scheme
#       (define (abs x)
#         (cond ((> x 0) x)
#               ((= x 0) 0)
#               ((< x 0) (- x))))
#     < src..
    ..src > scheme
      (define (abs x)
        (cond ((> x 0) x)
              ((= x 0) 0)
              ((< x 0) (- x))))
    < src..

#     The general form of a conditional expression is
    La forma general de una expresión condicional es

#     ..src > scheme
#       (cond (⟨p₁⟩ ⟨e₁⟩)
#             (⟨p₂⟩ ⟨e₂⟩)
#             ;; …
#             (⟨pₙ⟩ ⟨eₙ⟩))
#     < src..
    ..src > scheme
      (cond (⟨p₁⟩ ⟨e₁⟩)
            (⟨p₂⟩ ⟨e₂⟩)
            ;; …
            (⟨pₙ⟩ ⟨eₙ⟩))
    < src..

#     consisting of the symbol @c(cond) followed by parenthesized pairs of
#     expressions
    Consistente en el símbolo @c(cond) seguido de pares de paréntesis de
    expresiones

#     ..src > scheme
#       (⟨p⟩ ⟨e⟩)
#     < src..
    ..src > scheme
      (⟨p⟩ ⟨e⟩)
    < src..

#     called @e(clauses). The first expression in each pair is a @e(predicate)––that
#     is, an expression whose value is interpreted as either true or false.@n(17)
    llamadas @e(cláusulas). La primera expresión de cada par es un
    @e(predicado)––es decir, una expresión cuyo valor se interpreta como
    verdadero o falso.@n(17)

#     Conditional expressions are evaluated as follows.  The predicate @m[⟨p₁⟩] is
#     evaluated first. If its value is false, then @m[⟨p₂⟩] is evaluated. If
#     @m[⟨p₂⟩]'s value is also false, then @m[⟨p₃⟩] is evaluated. This process
#     continues until a predicate is found whose value is true, in which case the
#     interpreter returns the value of the corresponding @e(consequent expression)
#     @m[⟨e⟩] of the clause as the value of the conditional expression.  If none
#     of the @m[⟨p⟩]'s is found to be true, the value of the @c(cond) is
#     undefined.
    Las expresiones condicionales se evalúan de la siguiente manera. El
    predicado @m(⟨p₁⟩) se evalúa primero. Si su valor es falso, se evalúa
    @m(⟨p₂⟩). Si el valor de @m(⟨p₂⟩) es también falso, se evalúa @m(⟨p₃⟩). Este
    proceso continúa hasta que se encuentra un predicado cuyo valor es
    verdadero, en cuyo caso el intérprete devuelve el valor de la @e(expresión)
    correspondiente @m(⟨e⟩) de la cláusula como el valor de la expresión
    condicional. Si ningun valor de los predicados @m(⟨p⟩) es verdadero, el
    valor de @c(cond) es indefinido

#     The word @e(predicate) is used for procedures that return true or false, as
#     well as for expressions that evaluate to true or false. The absolute-value
#     procedure @c(abs) makes use of the primitive predicates @c(>), @c(<), and
#     @c(=).@n(18) These take two numbers as arguments and test whether the first
#     number is, respectively, greater than, less than, or equal to the second
#     number, returning true or false accordingly.
    La palabra @e(predicado) se utiliza para los procedimientos que devuelven
    verdadero o falso, así como para las expresiones que evalúan a verdadero o
    falso. El procedimiento de valor absoluto @c(abs) hace uso de los predicados
    primitivos @c(>), @c(<) y @c(=).@n(18) Estos toman dos números como
    argumentos y prueban si el primer número es, respectivamente, mayor que,
    menor que o igual a al segundo número, devolviendo verdadero o falso en
    consecuencia.

#     Another way to write the absolute-value procedure is
    Otra forma de escribir el procedimiento de valor absoluto es

#     ..src > scheme
#       (define (abs x)
#         (cond ((< x 0) (- x))
#               (else x)))
#     < src..
    ..src > scheme
      (define (abs x)
        (cond ((< x 0) (- x))
              (else x)))
    < src..

#     which could be expressed in English as @"(If @m(x) is less than zero return
#     @m(-x); otherwise return @m(x).) @c(else) is a special symbol that can be
#     used in place of the @m[⟨p⟩] in the final clause of a @c(cond). This causes
#     the @c(cond) to return as its value the value of the corresponding @m[⟨e⟩]
#     whenever all previous clauses have been bypassed. In fact, any expression that
#     always evaluates to a true value could be used as the @m[⟨p⟩] here.
    Que podría expresarse en inglés como @"(si @m(x) es menor que cero regresa
    @m(-x); de lo contrario devuelve @m(x)). @c(else) es un símbolo especial que
    se puede utilizar en lugar de @m(⟨p⟩) en la cláusula final de @c(cond).
    Esto hace que @c(cond) devuelva como su valor el valor de la @m(⟨e⟩)
    correspondiente siempre que se hayan omitido todas las cláusulas anteriores.
    De hecho, cualquier expresión que siempre se evalúa a un valor verdadero
    podría ser utilizada aqui como @m(⟨p⟩).

#     Here is yet another way to write the absolute-value procedure:
    Aquí hay otra manera de escribir el procedimiento de valor absoluto:

#     ..src > scheme
#       (define (abs x)
#         (if (< x 0)
#             (- x)
#             x))
#     < src..
    ..src > scheme
      (define (abs x)
        (if (< x 0)
            (- x)
            x))
    < src..

#     This uses the special form @c(if), a restricted type of conditional that can
#     be used when there are precisely two cases in the case analysis. The general
#     form of an @c(if) expression is
    Esto utiliza la forma @c(if), un tipo restringido de condicional que puede
    usarse cuando hay precisamente dos casos en el análisis del caso. La forma
    general de una expresión @c(if) es

#     ..src > scheme
#       (if ⟨predicate⟩ ⟨consequent⟩ ⟨alternative⟩)
#     < src..
    ..src > scheme
      (if ⟨predicado⟩ ⟨consecuente⟩ ⟨alternativo⟩)
    < src..

#     To evaluate an @c(if) expression, the interpreter starts by evaluating the
#     @c[⟨predicate⟩] part of the expression. If the @c[⟨predicate⟩] evaluates to a
#     true value, the interpreter then evaluates the @c[⟨consequent⟩] and returns
#     its value. Otherwise it evaluates the @c[⟨alternative⟩] and returns its
#     value.@n(19)
    Para evaluar una expresión @c(if), el intérprete comienza evaluando la parte
    @c[⟨predicado⟩] de la expresión. Si el @c[⟨predicado⟩] se evalúa a un valor
    verdadero, el intérprete evalúa @c[⟨consecuente⟩] y devuelve su valor. De lo
    contrario, evalúa @c[⟨alternativo⟩] y devuelve su valor.@n(19)

#     In addition to primitive predicates such as @c(<), @c(=), and @c(>), there are
#     logical composition operations, which enable us to construct compound
#     predicates. The three most frequently used are these:
    Además de predicados primitivos como @c(<), @c(=), y @c(>), hay operaciones
    de composición lógicos, que nos permiten construir predicados
    compuestos. Los tres más utilizados son los siguientes:

#     - @c[(and ⟨e₁⟩ … ⟨eₙ⟩)]
    - @c[(and ⟨e₁⟩ … ⟨eₙ⟩)]

#       The interpreter evaluates the expressions @c(⟨e⟩) one at a time, in
#       left-to-right order. If any @c(⟨e⟩) evaluates to false, the value of the
#       @c(and) expression is false, and the rest of the @c(⟨e⟩)'s are not
#       evaluated. If all @c(⟨e⟩)'s evaluate to true values, the value of the
#       @c(and) expression is the value of the last one.
    El intérprete evalúa las expresiones @c(⟨e⟩) una a la vez, de izquierda a
    derecha. Si alguna @c(⟨e⟩) se evalúa como falsa, el valor de la expresión
    @c(and) es falso, y el resto de expresiones @c(⟨e⟩) no se evalúan. Si todas
    las @c(⟨e⟩) se evaluan a valores verdaderos, el valor de la expresión
    @c(and) es el valor de la última.

#     - @c[(or ⟨e₁⟩ … ⟨eₙ⟩)]
    - @c[(or ⟨e₁⟩ … ⟨eₙ⟩)]

#       The interpreter evaluates the expressions @c(⟨e⟩) one at a time, in
#       left-to-right order. If any @c(⟨e⟩) evaluates to a true value, that value is
#       returned as the value of the @c(or) expression, and the rest of the
#       @c(⟨e⟩)'s are not evaluated. If all @c(⟨e⟩)'s evaluate to false, the value
#       of the @c(or) expression is false.
      El intérprete evalúa las expresiones @c(⟨e⟩) una a la vez, de izquierda a
      derecha. Si alguna @c(⟨e⟩) evalúa un valor verdadero, ese valor se
      devuelve como el valor de la expresión @c(or), y el resto de expresiones
      @c(⟨e⟩) no se evalúan. Si todas las @c(⟨e⟩) se evaluan a un valor falso,
      el valor de la expresión @c(or) es falso.

#     - @c[(not ⟨e⟩)]
    - @c[(not ⟨e⟩)]

#       The value of a @c(not) expression is true when the expression @c(⟨e⟩)
#       evaluates to false, and false otherwise.
      El valor de una expresión @c(not) es verdadero cuando la expresión @c(⟨e⟩)
      se evalúa como falsa, y falso en caso contrario.


#     Notice that @c(and) and @c(or) are special forms, not procedures, because the
#     subexpressions are not necessarily all evaluated. @c(not) is an ordinary
#     procedure.
    Observe que @c(and) y @c(or) son formas especiales, no procedimientos,
    porque no tadas las subexpresiones se evaluan necesariamente. @c(not) Es un
    procedimiento ordinario.

#     As an example of how these are used, the condition that a number @m(x) be in
#     the range @m(5 < x < 10) may be expressed as
    Como ejemplo de cómo se usan, la condición de que un número @m(x) esté en el
    intervalo @m(5 < x < 10) puede expresarse como

#     ..src > scheme
#       (and (> x 5) (< x 10))
#     < src..
    ..src > scheme
      (and (> x 5) (< x 10))
    < src..

#     As another example, we can define a predicate to test whether one number is
#     greater than or equal to another as
    Como otro ejemplo, podemos definir un predicado para probar si un número es
    mayor o igual que otro como

#     ..src > scheme
#       (define (>= x y)
#         (or (> x y) (= x y)))
#     < src..
    ..src > scheme
      (define (>= x y)
        (or (> x y) (= x y)))
    < src..

#     or alternatively as
    O alternativamente como

#     ..src > scheme
#       (define (>= x y)
#         (not (< x y)))
#     < src..
    ..src > scheme
      (define (>= x y)
        (not (< x y)))
    < src..

#     :: @t(Exercise 1.1) :: Below is a sequence of expressions.  What is the result
#        printed by the interpreter in response to each expression?  Assume that the
#        sequence is to be evaluated in the order in which it is presented.
    :: @t(Ejercicio 1.1) :: A continuación se muestra una secuencia de
       expresiones. ¿Cuál es el resultado impreso por el intérprete en respuesta
       a cada expresión? Suponga que la secuencia debe evaluarse en el orden en
       que se presenta.

#        ..src > scheme
#          10
#          (+ 5 3 4)
#          (- 9 1)
#          (/ 6 2)
#          (+ (* 2 4) (- 4 6))
#          (define a 3)
#          (define b (+ a 1))
#          (+ a b (* a b))
#          (= a b)
#          (if (and (> b a) (< b (* a b)))
#              b
#              a)
#          (cond ((= a 4) 6)
#                ((= b 4) (+ 6 7 a))
#                (else 25))
#          (+ 2 (if (> b a) b a))
#          (* (cond ((> a b) a)
#                   ((< a b) b)
#                   (else -1))
#             (+ a 1))
#        < src..
       ..src > scheme
         10
         (+ 5 3 4)
         (- 9 1)
         (/ 6 2)
         (+ (* 2 4) (- 4 6))
         (define a 3)
         (define b (+ a 1))
         (+ a b (* a b))
         (= a b)
         (if (and (> b a) (< b (* a b)))
             b
             a)
         (cond ((= a 4) 6)
               ((= b 4) (+ 6 7 a))
               (else 25))
         (+ 2 (if (> b a) b a))
         (* (cond ((> a b) a)
                  ((< a b) b)
                  (else -1))
            (+ a 1))
       < src..


#     :: @t(Exercise 1.2) :: Translate the following expression into prefix form:
    :: @t(Ejercicio 1.2) :: Traduce la siguiente expresión en forma de prefijo:

#        ..example >
#          5 + 4 + (2 − (3 − (6 + ⅘)))
#          –––––––––––––––––––––––––––
#               3(6 − 2)(2 − 7)
#        < example..
       ..example >
         5 + 4 + (2 − (3 − (6 + ⅘)))
         –––––––––––––––––––––––––––
              3(6 − 2)(2 − 7)
       < example..

#     :: @t(Exercise 1.3) :: Define a procedure that takes three numbers as
#        arguments and returns the sum of the squares of the two larger numbers.
    :: @t(Ejercicio 1.3) :: Definir un procedimiento que toma tres números como
       argumentos y devuelve la suma de los cuadrados de los dos números mayores.

#     :: @t(Exercise 1.4) :: Observe that our model of evaluation allows for
#        combinations whose operators are compound expressions. Use this observation
#        to describe the behavior of the following procedure:
    :: @t(Ejercicio 1.4) :: Observe que nuestro modelo de evaluación permite
       combinaciones cuyos operadores son expresiones compuestas. Utilice esta
       observación para describir el comportamiento del siguiente procedimiento:

#        ..src > scheme
#          (define (a-plus-abs-b a b)
#            ((if (> b 0) + -) a b))
#        < src..
       ..src > scheme
         (define (a-plus-abs-b a b)
           ((if (> b 0) + -) a b))
       < src..

#     :: @t(Exercise 1.5) :: Ben Bitdiddle has invented a test to determine whether
#        the interpreter he is faced with is using applicative-order evaluation or
#        normal-order evaluation. He defines the following two procedures:
    :: @t(Ejercicio 1.5) :: Ben Bitdiddle ha inventado una prueba para
       determinar si el intérprete con el que se enfrenta utiliza evaluacion de
       orden aplicativo o evaluacion de orden normal. Él define los dos
       procedimientos siguientes:

#        ..src > scheme
#          (define (p) (p))
#
#          (define (test x y)
#            (if (= x 0)
#                0
#                y))
#        < src..
       ..src > scheme
         (define (p) (p))

         (define (test x y)
           (if (= x 0)
               0
               y))
       < src..

#        Then he evaluates the expression
       Luego evalúa la expresión

#        ..src > scheme
#          (test 0 (p))
#        < src..
       ..src > scheme
         (test 0 (p))
       < src..

#        What behavior will Ben observe with an interpreter that uses
#        applicative-order evaluation?  What behavior will he observe with an
#        interpreter that uses normal-order evaluation?  Explain your
#        answer. (Assume that the evaluation rule for the special form @c(if) is the
#        same whether the interpreter is using normal or applicative order: The
#        predicate expression is evaluated first, and the result determines whether
#        to evaluate the consequent or the alternative expression.)
       ¿Qué comportamiento observará Ben con un intérprete que utilice una
       evaluación de orden aplicativo? ¿Qué comportamiento observará con un
       intérprete que use la evaluación de orden normal? Explica tu
       respuesta. (Supongamos que la regla de evaluación para la forma especial
       @c(if) es la misma si el intérprete está usando el orden normal o
       aplicativo: primero se evalúa la expresión de predicado y el resultado
       determina si se debe evaluar la expresión resultante o la alternativa.)

# *** 1.1.7 <> Example: Square Roots by Newton's Method
*** 1.1.7 <> Ejemplo: Raíces Cuadradas por el Método Newton

#     Procedures, as introduced above, are much like ordinary mathematical
#     functions.  They specify a value that is determined by one or more
#     parameters. But there is an important difference between mathematical
#     functions and computer procedures. Procedures must be effective.
    Los procedimientos, tal como se han introducido anteriormente, se parecen
    mucho a las funciones matemáticas ordinarias. Especifican un valor
    determinado por uno o más parámetros. Pero hay una diferencia importante
    entre las funciones matemáticas y los procedimientos informáticos. Los
    procedimientos deben ser efectivos.

#     As a case in point, consider the problem of computing square roots. We can
#     define the square-root function as
    Como un caso demostrativo, considere el problema de computar raíces
    cuadradas. Podemos definir la función raíz cuadrada como

#     ..example >
#       √x = the y such that y ≥ 0 and y² = x
#     < example..
    ..example >
      √x = la y tal que y ≥ 0 e y² = x
    < example..

#     This describes a perfectly legitimate mathematical function. We could use it
#     to recognize whether one number is the square root of another, or to derive
#     facts about square roots in general. On the other hand, the definition does
#     not describe a procedure. Indeed, it tells us almost nothing about how to
#     actually find the square root of a given number. It will not help matters to
#     rephrase this definition in pseudo-Lisp:
    Esto describe una función matemática perfectamente legítima. Podríamos
    utilizarlo para reconocer si un número es la raíz cuadrada de otro, o para
    derivar hechos sobre raíces cuadradas en general. Por otro lado, la
    definición no describe un procedimiento. De hecho, no nos dice casi nada
    acerca de cómo encontrar la raíz cuadrada de un número dado. No ayudará a
    los asuntos a reformular esta definición en pseudo-Lisp:

#     ..src > scheme
#       (define (sqrt x)
#         (the y (and (>= y 0)
#                     (= (square y) x))))
#     < src..
    ..src > scheme
      (define (sqrt x)
        (the y (and (>= y 0)
                    (= (square y) x))))
    < src..

#     This only begs the question.
    Esto sólo plantea la pregunta.

#     The contrast between function and procedure is a reflection of the general
#     distinction between describing properties of things and describing how to do
#     things, or, as it is sometimes referred to, the distinction between
#     declarative knowledge and imperative knowledge. In mathematics we are usually
#     concerned with declarative (what is) descriptions, whereas in computer science
#     we are usually concerned with imperative (how to) descriptions.@n(20)
    El contraste entre la función y el procedimiento es un reflejo de la
    distinción general entre la descripción de las propiedades de las cosas y la
    descripción de cómo hacer las cosas o, como a veces se hace referencia, la
    distinción entre conocimiento declarativo y conocimiento imperativo. En
    matemáticas nos referimos generalmente a descripciones declarativas (lo que
    es), mientras que en informática normalmente nos referimos a las
    descripciones imperativas (cómo es).@n(20)

#     How does one compute square roots?  The most common way is to use Newton's
#     method of successive approximations, which says that whenever we have a guess
#     @m(y) for the value of the square root of a number @m(x), we can perform a
#     simple manipulation to get a better guess (one closer to the actual square
#     root) by averaging @m(y) with @m(x / y).@n(21) For example, we can compute the
#     square root of 2 as follows.  Suppose our initial guess is 1:
    ¿Cómo se calculan las raíces cuadradas? La forma más común es utilizar el
    método de aproximaciones sucesivas de Newton, que dice que siempre que
    tengamos una suposición @m(y) para el valor de la raíz cuadrada de un número
    @m(x), podemos realizar una manipulación simple para obtener una mejor
    conjetura (una más cercana a la raíz cuadrada real) haciendo un promedio de
    @m(y) con @m(x / y).@n(21) Por ejemplo, podemos calcular la raíz
    cuadrada de 2 como sigue. Supongamos que nuestra conjetura inicial es 1:

#     ..example >
#       Guess     Quotient      Average
#
#       1         (2/1)  = 2    ((2 + 1)/2)  = 1.5
#
#       1.5       (2/1.5)       ((1.3333 + 1.5)/2)
#                   = 1.3333      = 1.4167
#
#       1.4167    (2/1.4167)    ((1.4167 + 1.4118)/2)
#                   = 1.4118      = 1.4142
#
#       1.4142    ...           ...
#     < example..
    ..example >
      Conjetura   Cociente      Promedio

      1           (2/1)  = 2    ((2 + 1)/2)  = 1.5

      1.5         (2/1.5)       ((1.3333 + 1.5)/2)
                    = 1.3333      = 1.4167

      1.4167      (2/1.4167)    ((1.4167 + 1.4118)/2)
                    = 1.4118      = 1.4142

      1.4142      ...           ...
    < example..

#     Continuing this process, we obtain better and better approximations to the
#     square root.
    Continuando este proceso, obtenemos mejores y mejores aproximaciones a la
    raíz cuadrada.

#     Now let's formalize the process in terms of procedures. We start with a value
#     for the radicand (the number whose square root we are trying to compute) and a
#     value for the guess. If the guess is good enough for our purposes, we are
#     done; if not, we must repeat the process with an improved guess. We write this
#     basic strategy as a procedure:
    Ahora vamos a formalizar el proceso en términos de procedimientos.
    Comenzamos con un valor para la radicand (el número cuya raíz cuadrada
    estamos tratando de calcular) y un valor para la conjetura. Si la suposición
    es lo suficientemente buena para nuestros propósitos, hemos terminado; Si
    no, debemos repetir el proceso con una conjetura mejorada. Escribimos esta
    estrategia básica como un procedimiento:

#     ..src > scheme
#       (define (sqrt-iter guess x)
#         (if (good-enough? guess x)
#             guess
#             (sqrt-iter (improve guess x) x)))
#     < src..
    ..src > scheme
      (define (sqrt-iter guess x)
        (if (good-enough? guess x)
            guess
            (sqrt-iter (improve guess x) x)))
    < src..

#     A guess is improved by averaging it with the quotient of the radicand and the
#     old guess:
    Una suposición es mejorada haciendo un promedio con el cociente de radicand
    y la vieja conjetura:

#     ..src > scheme
#       (define (improve guess x)
#         (average guess (/ x guess)))
#     < src..
    ..src > scheme
      (define (improve guess x)
        (average guess (/ x guess)))
    < src..

#     where
    dónde

#     ..src > scheme
#       (define (average x y)
#         (/ (+ x y) 2))
#     < src..
    ..src > scheme
      (define (average x y)
        (/ (+ x y) 2))
    < src..

#     We also have to say what we mean by @"(good enough.)  The following will do
#     for illustration, but it is not really a very good test. (See @l(#Exercise
#     1.7).)  The idea is to improve the answer until it is close enough so that its
#     square differs from the radicand by less than a predetermined tolerance (here
#     0.001):@n(22)
    También tenemos que decir lo que significa @"(suficientemente bueno.) Por
    ejemplo, lo siguiente lo hara, pero no es realmente una prueba muy
    buena. (Ver @l(#Ejercicio 1.7).) La idea es mejorar la respuesta hasta que
    esté lo suficientemente cerca como para que su posicion se diferencie del
    radicando en menos de una tolerancia predeterminada (en este caso
    0.001):@n(22)

#     ..src > scheme
#       (define (good-enough? guess x)
#         (< (abs (- (square guess) x)) 0.001))
#     < src..
    ..src > scheme
      (define (good-enough? guess x)
        (< (abs (- (square guess) x)) 0.001))
    < src..

#     Finally, we need a way to get started. For instance, we can always guess that
#     the square root of any number is 1:@n(23)
    Por último, necesitamos una manera de empezar. Por ejemplo, siempre podemos
    adivinar que la raíz cuadrada de cualquier número es 1:@n(23)

#     ..src > scheme
#       (define (sqrt x)
#         (sqrt-iter 1.0 x))
#     < src..
    ..src > scheme
      (define (sqrt x)
        (sqrt-iter 1.0 x))
    < src..

#     If we type these definitions to the interpreter, we can use @c(sqrt) just as
#     we can use any procedure:
    Si escribimos estas definiciones para el intérprete, podemos usar @c(sqrt)
    de misma manera que podemos usar cualquier procedimiento:

#     ..srci > scheme
#       > (sqrt 9)
#       3.00009155413138
#       > (sqrt (+ 100 37))
#       11.704699917758145
#       > (sqrt (+ (sqrt 2) (sqrt 3)))
#       1.7739279023207892
#       > (square (sqrt 1000))
#       1000.000369924366
#     < srci..
    ..srci > scheme
      > (sqrt 9)
      3.00009155413138
      > (sqrt (+ 100 37))
      11.704699917758145
      > (sqrt (+ (sqrt 2) (sqrt 3)))
      1.7739279023207892
      > (square (sqrt 1000))
      1000.000369924366
    < srci..

#     The @c(sqrt) program also illustrates that the simple procedural language we
#     have introduced so far is sufficient for writing any purely numerical program
#     that one could write in, say, C or Pascal. This might seem surprising, since
#     we have not included in our language any iterative (looping) constructs that
#     direct the computer to do something over and over again. @c(Sqrt-iter), on the
#     other hand, demonstrates how iteration can be accomplished using no special
#     construct other than the ordinary ability to call a procedure.@n(24)
    El programa @c(sqrt) también ilustra que el lenguaje de procedimiento simple
    que hemos introducido hasta ahora es suficiente para escribir cualquier
    programa puramente numérico que se pueda escribir en, por ejemplo, C o
    Pascal. Esto puede parecer sorprendente, ya que no hemos incluido en nuestro
    lenguaje ninguna construccion iterativa (bucles) construcciones que dirigen
    la computadora a hacer algo una y otra vez. @c(sqrt-iter), por otro lado,
    demuestra cómo la iteración se puede lograr sin utilizar un constructo
    especial distinto de la capacidad ordinaria de llamar a un
    procedimiento.@n(24)

#     :: @t(Exercise 1.6) :: Alyssa P. Hacker doesn't see why @c(if) needs to be
#        provided as a special form. @"(Why can't I just define it as an ordinary
#        procedure in terms of @c(cond)?) she asks. Alyssa's friend Eva Lu Ator
#        claims this can indeed be done, and she defines a new version of @c(if):
    :: @t(Ejercicio 1.6) :: Alyssa P. Hacker no ve por qué @c(if) necesita ser
       proporcionado como una forma especial. @"(¿Por qué no puedo definirlo
       como un procedimiento ordinario en términos de @c(cond)?) pregunta
       ella. La amiga de Alyssa, Eva Lu Ator, afirma que esto puede
       efectivamente hacerse, y define una nueva versión de @c(if):

#        ..src > scheme
#          (define (new-if predicate
#                          then-clause
#                          else-clause)
#            (cond (predicate then-clause)
#                  (else else-clause)))
#        < src..
       ..src > scheme
         (define (new-if predicate
                         then-clause
                         else-clause)
           (cond (predicate then-clause)
                 (else else-clause)))
       < src..

#        Eva demonstrates the program for Alyssa:
       Eva demuestra el programa para Alyssa:

#        ..srci > scheme
#          > (new-if (= 2 3) 0 5)
#          5
#          > (new-if (= 1 1) 0 5)
#          0
#        < srci..
       ..srci > scheme
         > (new-if (= 2 3) 0 5)
         5
         > (new-if (= 1 1) 0 5)
         0
       < srci..

#        Delighted, Alyssa uses @c(new-if) to rewrite the square-root program:
       Encantada, Alyssa utiliza @c(new-if) para reescribir el programa
       raíz-cuadrada:

#        ..src > scheme
#          (define (sqrt-iter guess x)
#            (new-if (good-enough? guess x)
#                    guess
#                    (sqrt-iter (improve guess x) x)))
#        < src..
       ..src > scheme
         (define (sqrt-iter guess x)
           (new-if (good-enough? guess x)
                   guess
                   (sqrt-iter (improve guess x) x)))
       < src..

#        What happens when Alyssa attempts to use this to compute square roots?
#        Explain.
       ¿Qué sucede cuando Alyssa intenta usar esto para calcular raíces
       cuadradas? Explique.

#     :: @t(Exercise 1.7) :: The @c(good-enough?) test used in computing square
#        roots will not be very effective for finding the square roots of very small
#        numbers. Also, in real computers, arithmetic operations are almost always
#        performed with limited precision. This makes our test inadequate for very
#        large numbers. Explain these statements, with examples showing how the test
#        fails for small and large numbers. An alternative strategy for implementing
#        @c(good-enough?) is to watch how @c(guess) changes from one iteration to
#        the next and to stop when the change is a very small fraction of the
#        guess. Design a square-root procedure that uses this kind of end test. Does
#        this work better for small and large numbers?
    :: @t(Ejercicio 1.7) :: La prueba @c(good-enough?) usada en el cálculo de
       raíces cuadradas no será muy eficaz para encontrar las raíces cuadradas
       de números muy pequeños. Además, en las computadoras reales, las
       operaciones aritméticas se realizan casi siempre con una precisión
       limitada. Esto hace que nuestra prueba sea inadecuada para números muy
       grandes. Explique estas declaraciones, con ejemplos que muestren cómo
       falla la prueba para números pequeños y grandes. Una estrategia
       alternativa para implementar @c(good-enough?) es observar cómo @c(guess)
       cambia de una iteración a la siguiente y se detene cuando el cambio es
       una fracción muy pequeña de la suposición. Diseñe un procedimiento de
       raíz cuadrada que utilice este tipo de prueba final. ¿Funciona mejor para
       números pequeños y grandes?

#     :: @t(Exercise 1.8) :: Newton's method for cube roots is based on the fact
#        that if @m(y) is an approximation to the cube root of @m(x), then a better
#        approximation is given by the value
    :: @t(Ejercicio 1.8) :: El método de Newton para raíces cuadradas se basa en
       el hecho de que si @m(y) es una aproximación a la raíz cuadrada de @m(x),
       entonces una mejor aproximación es dada por el valor

#        ..example >
#          x/y² + 2y
#          –––––––––
#              3
#        < example..
       ..example >
         x/y² + 2y
         –––––––––
             3
       < example..

#        Use this formula to implement a cube-root procedure analogous to the
#        square-root procedure. (in section @l(#1.3.4) we will see how to implement Newton's
#        method in general as an abstraction of these square-root and cube-root
#        procedures.)
       Utilice esta fórmula para implementar un procedimiento de raíz cúbica
       análogo al procedimiento de raíz cuadrada. (En la seccion @l(#1.3.4)
       veremos cómo implementar el método Newton en general como abstracción de
       estos procedimientos de raíz cuadrada y raíz cúbica).

# *** 1.1.8 <> Procedures as Black-Box Abstractions
*** 1.1.8 <> Procedimientos como Abstracciones de Caja Negra

#     @c(sqrt) is our first example of a process defined by a set of mutually
#     defined procedures. Notice that the definition of @c(sqrt-iter) is
#     @e(recursive); that is, the procedure is defined in terms of itself. The idea
#     of being able to define a procedure in terms of itself may be disturbing; it
#     may seem unclear how such a @"(circular) definition could make sense at all,
#     much less specify a well-defined process to be carried out by a computer. This
#     will be addressed more carefully in section @l(#1.2). But first let's consider some
#     other important points illustrated by the @c(sqrt) example.
    @c(sqrt) Es nuestro primer ejemplo de un proceso definido por un conjunto de
    procedimientos definidos mutuamente. Observe que la definición de
    @c(sqrt-iter) es @e(recursiva); Es decir, el procedimiento se define en
    términos de sí mismo. La idea de ser capaz de definir un procedimiento en
    términos de sí mismo puede ser inquietante; Puede parecer poco claro cómo
    una definición @"(circular) de este tipo podría tener sentido en absoluto, y
    mucho menos especificar un proceso bien definido que debe ser llevado a cabo
    por un ordenador. Esto se tratará con mayor atención en la seccion
    @l(#1.2). Pero primero vamos a considerar algunos otros puntos importantes
    ilustrados por el ejemplo @c(sqrt).

#     Observe that the problem of computing square roots breaks up naturally into a
#     number of subproblems: how to tell whether a guess is good enough, how to
#     improve a guess, and so on. Each of these tasks is accomplished by a separate
#     procedure. The entire @c(sqrt) program can be viewed as a cluster of
#     procedures (shown in @l(#Figure 1.2)) that mirrors the decomposition of the
#     problem into subproblems.
    Observe que el problema de calcular raíces cuadradas se descompone de forma
    natural en una serie de subproblemas: cómo saber si una suposición es lo
    suficientemente buena, cómo mejorar una conjetura, etc. Cada una de estas
    tareas se realiza mediante un procedimiento separado. Todo el programa
    @c(sqrt) puede ser visto como un conjunto de procedimientos (que se muestra
    en la @l(#Figura 1.2) ) que refleja la descomposición del problema en
    subproblemas.

#     ..figure > @t(Figure 1.2) Procedural decomposition of the @c(sqrt) program.
    ..figure > @t(Figura 1.2) Descomposición procedural del programa @c(sqrt).

#       ..art >
#                       sqrt
#                        |
#                    sqrt-iter
#                    /       \
#              good-enough   improve
#              /         \         \
#         square         abs       average
#       < art..
      ..art >
                      sqrt
                       |
                   sqrt-iter
                   /       \
             good-enough   improve
             /         \         \
        square         abs       average
      < art..

# @   ..img > img/chap1/Fig1.2.std.svg
@   ..img > img/chap1/Fig1.2.std.svg

#     The importance of this decomposition strategy is not simply that one is
#     dividing the program into parts. After all, we could take any large program
#     and divide it into parts––the first ten lines, the next ten lines, the next
#     ten lines, and so on. Rather, it is crucial that each procedure accomplishes
#     an identifiable task that can be used as a module in defining other
#     procedures.  For example, when we define the @c(good-enough?) procedure in
#     terms of @c(square), we are able to regard the @c(square) procedure as a
#     @"(black box.)  We are not at that moment concerned with @e(how) the procedure
#     computes its result, only with the fact that it computes the square. The
#     details of how the square is computed can be suppressed, to be considered at a
#     later time. Indeed, as far as the @c(good-enough?) procedure is concerned,
#     @c(square) is not quite a procedure but rather an abstraction of a procedure,
#     a so-called @e(procedural abstraction). At this level of abstraction, any
#     procedure that computes the square is equally good.
    La importancia de esta estrategia de descomposición no es simplemente que se
    está dividiendo el programa en partes. Después de todo, podríamos tomar
    cualquier programa grande y dividirlo en partes: las primeras diez líneas,
    las siguientes diez líneas, las siguientes diez líneas, y así sucesivamente.
    Más bien, es crucial que cada procedimiento lleve a cabo una tarea
    identificable que pueda ser utilizada como módulo para definir otros
    procedimientos. Por ejemplo, cuando definimos el procedimiento
    @c(good-enough?) en términos de @c(square), podemos considerar el
    procedimiento @c(square) como una @"(caja negra).  No estamos en ese momento
    interesados en @e(cómo) el procedimiento calcula su resultado, sólo con el
    hecho de que calcula el cuadrado. Los detalles de cómo se calcula el
    cuadrado pueden ser suprimidos, para ser considerados en un momento
    posterior. De hecho, en lo que al procedimiento @c(good-enough?) se refiere,
    @c(square) No es un procedimiento sino una abstracción de un procedimiento,
    una denominada @e(abstracción procedural). En este nivel de abstracción,
    cualquier procedimiento que calcule el cuadrado es igualmente bueno.

#     Thus, considering only the values they return, the following two procedures
#     for squaring a number should be indistinguishable. Each takes a numerical
#     argument and produces the square of that number as the value.@n(25)
    Por lo tanto, considerando sólo los valores que devuelven, los dos
    siguientes procedimientos para cuadrar un número deben ser indistinguibles.
    Cada uno toma un argumento numérico y produce el cuadrado de ese número como
    el valor.@n(25)

#     ..src > scheme
#       (define (square x) (* x x))
#
#       (define (square x)
#         (exp (double (log x))))
#
#       (define (double x) (+ x x))
#     < src..
    ..src > scheme
      (define (square x) (* x x))

      (define (square x)
        (exp (double (log x))))

      (define (double x) (+ x x))
    < src..

#     So a procedure definition should be able to suppress detail. The users of the
#     procedure may not have written the procedure themselves, but may have obtained
#     it from another programmer as a black box. A user should not need to know how
#     the procedure is implemented in order to use it.
    Así que una definición de procedimiento debe ser capaz de suprimir el
    detalle. Los usuarios del procedimiento pueden no haber escrito el
    procedimiento ellos mismos, pueden haberlo obtenido de otro programador como
    una caja negra. Un usuario no debería necesitar saber cómo se implementa el
    procedimiento para usarlo.

# **** Local names
**** Nombres locales

#      One detail of a procedure's implementation that should not matter to the user
#      of the procedure is the implementer's choice of names for the procedure's
#      formal parameters. Thus, the following procedures should not be
#      distinguishable:
     Un detalle de la implementación de un procedimiento que no debería importar
     al usuario del procedimiento es la elección de nombres de los parámetros
     formales del procedimiento por parte del implementador. Por lo tanto, los
     siguientes procedimientos no deben distinguirse:

#      ..src > scheme
#        (define (square x) (* x x))
#        (define (square y) (* y y))
#      < src..
     ..src > scheme
       (define (square x) (* x x))
       (define (square y) (* y y))
     < src..

#      This principle––that the meaning of a procedure should be independent of the
#      parameter names used by its author––seems on the surface to be self-evident,
#      but its consequences are profound. The simplest consequence is that the
#      parameter names of a procedure must be local to the body of the procedure. For
#      example, we used @c(square) in the definition of @c(good-enough?) in our
#      square-root procedure:
     Este principio––que el significado de un procedimiento debe ser
     independiente del nombres de los parámetros utilizados por su autor––parece
     evidente en la superficie, pero sus consecuencias son profundas. La
     consecuencia más simple es que los nombres de los parámetros de un
     procedimiento deben ser locales al cuerpo del procedimiento. Por ejemplo,
     hemos utilizado @c(square) en la definición de @c(good-enough?) en nuestro
     procedimiento de raíz-cuadrada:

#      ..src > scheme
#        (define (good-enough? guess x)
#          (< (abs (- (square guess) x)) 0.001))
#      < src..
     ..src > scheme
       (define (good-enough? guess x)
         (< (abs (- (square guess) x)) 0.001))
     < src..

#      The intention of the author of @c(good-enough?) is to determine if the square
#      of the first argument is within a given tolerance of the second argument. We
#      see that the author of @c(good-enough?) used the name @c(guess) to refer to
#      the first argument and @c(x) to refer to the second argument. The argument of
#      @c(square) is @c(guess). If the author of @c(square) used @c(x) (as above) to
#      refer to that argument, we see that the @c(x) in @c(good-enough?) must be a
#      different @c(x) than the one in @c(square). Running the procedure @c(square)
#      must not affect the value of @c(x) that is used by @c(good-enough?), because
#      that value of @c(x) may be needed by @c(good-enough?) after @c(square) is done
#      computing.
     La intención del autor de @c(good-enough?) es determinar si el cuadrado del
     primer argumento está dentro de una tolerancia dada del segundo
     argumento. Vemos que el autor de @c(good-enough?) usó el nombre @c(guess)
     para referirse al primer argumento y @c(x) para referirse al segundo
     argumento. El argumento de @c(square) es @c(guess). Si el autor de
     @c(square) usa @c(x) (como arriba) para referirse a ese argumento, vemos
     que el @c(x) en @c(good-enough?) debe ser diferente al @c(x) en
     @c(square). Ejecutar el procedimiento @c(square) no debe afectar el valor
     de @c(x) que utiliza @c(good-enough?), ya que el valor de @c(x) puede ser
     necesario en @c(good-enough?) después de que @c(square) termine el calculo.

#      If the parameters were not local to the bodies of their respective procedures,
#      then the parameter @c(x) in @c(square) could be confused with the parameter
#      @c(x) in @c(good-enough?), and the behavior of @c(good-enough?) would depend
#      upon which version of @c(square) we used.  Thus, @c(square) would not be the
#      black box we desired.
     Si los parámetros no fueran locales a los cuerpos de sus respectivos
     procedimientos, entonces el parámetro @c(x) en @c(square) podría
     confundirse con el parámetro @c(x) en @c(good-enough?), y el comportamiento
     de @c(good-enough?) dependería de la versión de @c(square) que
     utilizamos. Por lo tanto @c(square), no sería la caja negra que deseábamos.

#      A formal parameter of a procedure has a very special role in the procedure
#      definition, in that it doesn't matter what name the formal parameter has. Such
#      a name is called a @e(bound variable), and we say that the procedure
#      definition @e(binds) its formal parameters. The meaning of a procedure
#      definition is unchanged if a bound variable is consistently renamed throughout
#      the definition.@n(26) If a variable is not bound, we say that it is @e(free).
#      The set of expressions for which a binding defines a name is called the
#      @e(scope) of that name. In a procedure definition, the bound variables
#      declared as the formal parameters of the procedure have the body of the
#      procedure as their scope.
     Un parámetro formal de un procedimiento tiene un papel muy especial en la
     definición del procedimiento, ya que no importa qué nombre tenga el
     parámetro formal. Este nombre se denomina @e(variable enlazada), y decimos
     que la definición del procedimiento @e(enlaza) sus parámetros formales. El
     significado de una definición de procedimiento no cambia si una variable
     enlazada se renombra constantemente a lo largo de la definición.@n(26) Si
     una variable no está unida, decimos que es @e(libre). El conjunto de
     expresiones para las que un enlace define un nombre se denomina @e(alcance)
     de ese nombre. En una definición de procedimiento, las variables enlazadas
     declaradas como los parámetros formales del procedimiento tienen como
     alcance el cuerpo del procedimiento.

#      In the definition of @c(good-enough?) above, @c(guess) and @c(x) are bound
#      variables but @c(<), @c(-), @c(abs), and @c(square) are free.  The meaning of
#      @c(good-enough?) should be independent of the names we choose for @c(guess)
#      and @c(x) so long as they are distinct and different from @c(<), @c(-),
#      @c(abs), and @c(square). (If we renamed @c(guess) to @c(abs) we would have
#      introduced a bug by @e(capturing) the variable @c(abs). It would have changed
#      from free to bound.)  The meaning of @c(good-enough?) is not independent of
#      the names of its free variables, however. It surely depends upon the fact
#      (external to this definition) that the symbol @c(abs) names a procedure for
#      computing the absolute value of a number. @c(good-enough?) will compute a
#      different function if we substitute @c(cos) for @c(abs) in its definition.
     En la definición de @c(good-enough?) anterior, @c(guess) y @c(x) son
     variables enlazadas, pero @c(<), @c(-), @c(abs), y @c(square) estan
     libres. El significado de @c(good-enough?) debe ser independiente de los
     nombres que elegimos para @c(guess) y @c(x) cuando sean distintos y
     diferentes de @c(<), @c(-), @c(abs), y @c(square). (Si renombramos
     @c(guess) a @c(abs), habríamos introducido un error @e(capturando) la
     variable @c(abs). Habria cambiado de libre a enlazada.) El significado de
     @c(good-enough?) no es independiente de los nombres de sus variables
     libres. Seguramente depende del hecho (externo a esta definición) que el
     símbolo @c(abs) nombra un procedimiento para calcular el valor absoluto de
     un número. @c(good-enough?) calculara una funcion diferente si sustituimos
     @c(cos) por @c(abs) en esta definicion.

# **** Internal definitions and block structure
**** Definiciones internas y estructura de bloques

#      We have one kind of name isolation available to us so far: The formal
#      parameters of a procedure are local to the body of the procedure. The
#      square-root program illustrates another way in which we would like to control
#      the use of names. The existing program consists of separate procedures:
     Hasta ahora tenemos un tipo de aislamiento del nombre disponible: Los
     parámetros formales de un procedimiento son locales al cuerpo del
     procedimiento. El programa raíz-cuadrada ilustra otra forma en la que nos
     gustaría controlar el uso de nombres. El programa existente consta de
     procedimientos separados:

#      ..src > scheme
#        (define (sqrt x)
#          (sqrt-iter 1.0 x))
#
#        (define (sqrt-iter guess x)
#          (if (good-enough? guess x)
#              guess
#              (sqrt-iter (improve guess x) x)))
#
#        (define (good-enough? guess x)
#          (< (abs (- (square guess) x)) 0.001))
#
#        (define (improve guess x)
#          (average guess (/ x guess)))
#      < src..
     ..src > scheme
       (define (sqrt x)
         (sqrt-iter 1.0 x))

       (define (sqrt-iter guess x)
         (if (good-enough? guess x)
             guess
             (sqrt-iter (improve guess x) x)))

       (define (good-enough? guess x)
         (< (abs (- (square guess) x)) 0.001))

       (define (improve guess x)
         (average guess (/ x guess)))
     < src..

#      The problem with this program is that the only procedure that is important to
#      users of @c(sqrt) is @c(sqrt). The other procedures (@c(sqrt-iter),
#      @c(good-enough?), and @c(improve)) only clutter up their minds. They may not
#      define any other procedure called @c(good-enough?) as part of another program
#      to work together with the square-root program, because @c(sqrt) needs it. The
#      problem is especially severe in the construction of large systems by many
#      separate programmers. For example, in the construction of a large library of
#      numerical procedures, many numerical functions are computed as successive
#      approximations and thus might have procedures named @c(good-enough?) and
#      @c(improve) as auxiliary procedures. We would like to localize the
#      subprocedures, hiding them inside @c(sqrt) so that @c(sqrt) could coexist with
#      other successive approximations, each having its own private @c(good-enough?)
#      procedure. To make this possible, we allow a procedure to have internal
#      definitions that are local to that procedure. For example, in the square-root
#      problem we can write
     El problema con este programa es que el único procedimiento que es
     importante para los usuarios de @c(sqrt) es @c(sqrt). Los otros
     procedimientos (@c(sqrt-iter), @c(good-enough?) e @c(improve)), sólo
     confundira sus mentes. No pueden definir ningún otro procedimiento llamado
     @c(good-enough?) como parte de otro programa para trabajar junto con el
     programa raiz-cuadrada, porque @c(sqrt) lo necesita. El problema es
     especialmente grave en la construcción sistemas grandes por muchos
     programadores independientes. Por ejemplo, en la construcción de una gran
     libreria de procedimientos numéricos, muchas funciones numéricas se
     calculan como aproximaciones sucesivas y por lo tanto pueden tener
     procedimientos llamados @c(good-enough?) e @c(improve) como procedimientos
     auxiliares. Nos gustaría localizar los subprocedimientos, ocultándolos
     dentro para que @c(sqrt) para que @c(sqrt) pudieran coexistir con otras
     aproximaciones sucesivas, cada una teniendo su propio procedimiento privado
     @c(good-enough?). Para hacer esto posible, permitimos que un procedimiento
     tenga definiciones internas que son locales a ese procedimiento. Por
     ejemplo, en el problema de raíz cuadrada podemos escribir

#      ..src > scheme
#        (define (sqrt x)
#          (define (good-enough? guess x)
#            (< (abs (- (square guess) x)) 0.001))
#          (define (improve guess x)
#            (average guess (/ x guess)))
#          (define (sqrt-iter guess x)
#            (if (good-enough? guess x)
#                guess
#                (sqrt-iter (improve guess x) x)))
#          (sqrt-iter 1.0 x))
#      < src..
     ..src > scheme
       (define (sqrt x)
         (define (good-enough? guess x)
           (< (abs (- (square guess) x)) 0.001))
         (define (improve guess x)
           (average guess (/ x guess)))
         (define (sqrt-iter guess x)
           (if (good-enough? guess x)
               guess
               (sqrt-iter (improve guess x) x)))
         (sqrt-iter 1.0 x))
     < src..

#      Such nesting of definitions, called @e(block structure), is basically the
#      right solution to the simplest name-packaging problem. But there is a better
#      idea lurking here. In addition to internalizing the definitions of the
#      auxiliary procedures, we can simplify them. Since @c(x) is bound in the
#      definition of @c(sqrt), the procedures @c(good-enough?), @c(improve), and
#      @c(sqrt-iter), which are defined internally to @c(sqrt), are in the scope of
#      @c(x). Thus, it is not necessary to pass @c(x) explicitly to each of these
#      procedures. Instead, we allow @c(x) to be a free variable in the internal
#      definitions, as shown below. Then @c(x) gets its value from the argument with
#      which the enclosing procedure @c(sqrt) is called. This discipline is called
#      @e(lexical scoping).@n(27)
     Este anidamiento de definiciones, denominado @e(estructura de bloques), es
     básicamente la solución correcta al problema más simple del empaquetado de
     nombres. Pero hay una mejor idea acechando aquí. Además de internalizar las
     definiciones de los procedimientos auxiliares, podemos simplificarlos.
     Puesto que @c(x) está enlazado en la definición de @c(sqrt), los
     procedimientos @c(good-enough?), @c(improve) y @c(sqrt-iter), que se
     definen internamente en @c(sqrt), están en el ámbito de @c(x). Por lo
     tanto, no es necesario pasar @c(x) explícitamente a cada uno de estos
     procedimientos. En cambio, permitimos a @c(x) ser una variable libre en las
     definiciones internas, como se muestra a continuación. A continuación,
     @c(x) obtiene su valor del argumento con el que @c(sqrt) se llama al
     procedimiento interno @c(sqrt). Esta disciplina se denomina @e(escaneo
     léxico).@n(27)

#      ..src > scheme
#        (define (sqrt x)
#          (define (good-enough? guess)
#            (< (abs (- (square guess) x)) 0.001))
#          (define (improve guess)
#            (average guess (/ x guess)))
#          (define (sqrt-iter guess)
#            (if (good-enough? guess)
#                guess
#                (sqrt-iter (improve guess))))
#          (sqrt-iter 1.0))
#      < src..
     ..src > scheme
       (define (sqrt x)
         (define (good-enough? guess)
           (< (abs (- (square guess) x)) 0.001))
         (define (improve guess)
           (average guess (/ x guess)))
         (define (sqrt-iter guess)
           (if (good-enough? guess)
               guess
               (sqrt-iter (improve guess))))
         (sqrt-iter 1.0))
     < src..

#      We will use block structure extensively to help us break up large programs
#      into tractable pieces.@n(28) The idea of block structure originated with the
#      programming language Algol 60. It appears in most advanced programming
#      languages and is an important tool for helping to organize the construction of
#      large programs.
     Usaremos extensivamente la estructura de bloques para ayudarnos a descomponer
     grandes programas en piezas manejables.@n(28) La idea de estructura de
     bloques se originó con el lenguaje de programación Algol 60. Aparece en la
     mayoría de los lenguajes de programación avanzados y es una herramienta
     importante para ayudar a organizar la construcción de grandes programas.

# ** 1.2 <> Procedures and the Processes They Generate
** 1.2 <> Procedimientos y Procesos que los Generan

#    We have now considered the elements of programming: We have used primitive
#    arithmetic operations, we have combined these operations, and we have
#    abstracted these composite operations by defining them as compound procedures.
#    But that is not enough to enable us to say that we know how to program. Our
#    situation is analogous to that of someone who has learned the rules for how
#    the pieces move in chess but knows nothing of typical openings, tactics, or
#    strategy. Like the novice chess player, we don't yet know the common patterns
#    of usage in the domain. We lack the knowledge of which moves are worth making
#    (which procedures are worth defining). We lack the experience to predict the
#    consequences of making a move (executing a procedure).
   Ahora hemos considerado los elementos de la programación: Hemos utilizado
   operaciones aritméticas primitivas, hemos combinado estas operaciones y hemos
   abstraído estas operaciones compuestas definiéndolas como procedimientos
   compuestos. Pero eso no es suficiente para permitirnos decir que sabemos
   programar. Nuestra situación es análoga a la de alguien que ha aprendido las
   reglas de cómo las piezas se mueven en el ajedrez pero no sabe nada de
   aberturas típicas, tácticas o estrategia. Al igual que el jugador de ajedrez
   novato, todavía no conocemos los patrones comunes de uso en el dominio. Nos
   falta el conocimiento de los movimientos que valen la pena hacer (qué
   procedimientos vale la pena definir). Nos falta la experiencia para predecir
   las consecuencias de hacer un movimiento (ejecutar un procedimiento).

#    The ability to visualize the consequences of the actions under consideration
#    is crucial to becoming an expert programmer, just as it is in any synthetic,
#    creative activity. In becoming an expert photographer, for example, one must
#    learn how to look at a scene and know how dark each region will appear on a
#    print for each possible choice of exposure and development conditions. Only
#    then can one reason backward, planning framing, lighting, exposure, and
#    development to obtain the desired effects. So it is with programming, where we
#    are planning the course of action to be taken by a process and where we
#    control the process by means of a program. To become experts, we must learn to
#    visualize the processes generated by various types of procedures. Only after
#    we have developed such a skill can we learn to reliably construct programs
#    that exhibit the desired behavior.
   La capacidad de visualizar las consecuencias de las acciones consideradas es
   crucial para convertirse en un programador experto, al igual que en cualquier
   actividad sintética y creativa. Al convertirse en un fotógrafo experto, por
   ejemplo, uno debe aprender cómo mirar una escena y saber cómo aparecerá la
   oscuridad de cada región en una impresión para cada posible opción de las
   condiciones de exposición y desarrollo. Sólo entonces se puede razonar hacia
   atrás, planificando el encuadre, la iluminación, la exposición y el
   desarrollo, para obtener los efectos deseados. Lo mismo ocurre con la
   programación, en la que estamos planificando el curso de acción que debe
   tomar un proceso y donde controlamos el proceso mediante un programa. Para
   ser expertos, debemos aprender a visualizar los procesos generados por los
   distintos tipos de procedimientos.

#    A procedure is a pattern for the @e(local evolution) of a computational
#    process. It specifies how each stage of the process is built upon the previous
#    stage. We would like to be able to make statements about the overall, or
#    @e(global), behavior of a process whose local evolution has been specified by
#    a procedure. This is very difficult to do in general, but we can at least try
#    to describe some typical patterns of process evolution.
   Un procedimiento es un patrón para la @e(evolución local) de un proceso
   computacional. Especifica cómo cada etapa del proceso se construye sobre la
   etapa anterior. Nos gustaría poder hacer declaraciones sobre el
   comportamiento general o @e(global) de un proceso cuya evolución local ha
   sido especificada por un procedimiento. Esto es muy difícil de hacer en
   general, pero al menos podemos intentar describir algunos patrones típicos de
   la evolución del proceso.

#    In this section we will examine some common @"(shapes) for processes generated
#    by simple procedures. We will also investigate the rates at which these
#    processes consume the important computational resources of time and space. The
#    procedures we will consider are very simple. Their role is like that played by
#    test patterns in photography: as oversimplified prototypical patterns, rather
#    than practical examples in their own right.
   En esta sección examinaremos algunas @"(formas) comunes para procesos
   generados por procedimientos simples. También investigaremos las tasas a las
   que estos procesos consumen los importantes recursos computacionales de
   tiempo y espacio. Los procedimientos que consideraremos son muy sencillos. Su
   papel es como el que juegan los patrones de prueba en la fotografía: como
   patrones prototípicos simplificados en lugar de ejemplos prácticos por
   derecho propio.

# *** 1.2.1 <> Linear Recursion and Iteration
*** 1.2.1 <> Recursión Lineal e Iteración

#     We begin by considering the factorial function, defined by
    Comenzamos por considerar la función factorial, definida por

#     ..example >
#       n! = n ⋅ (n − 1) ⋅ (n − 2) ⋯ 3 ⋅ 2 ⋅ 1
#     < example..
    ..example >
      n! = n ⋅ (n − 1) ⋅ (n − 2) ⋯ 3 ⋅ 2 ⋅ 1
    < example..

#     There are many ways to compute factorials. One way is to make use of the
#     observation that @m(n!) is equal to @m(n) times @m[(n - 1)!] for any positive
#     integer @m(n):
    Hay muchas maneras de calcular factoriales. Una forma es hacer uso de la
    observación de que @m(n!) Es igual a @m(n) veces @m[(n - 1)] ) para
    cualquier número entero positivo @m(n):

#     ..example >
#       n! = n ⋅ [(n − 1) ⋅ (n − 2) ⋯ 3 ⋅ 2 ⋅ 1] = n ⋅ (n − 1)!
#     < example..
    ..example >
      n! = n ⋅ [(n − 1) ⋅ (n − 2) ⋯ 3 ⋅ 2 ⋅ 1] = n ⋅ (n − 1)!
    < example..

#     Thus, we can compute @m(n!) by computing @m[(n - 1)!] and multiplying the
#     result by @m[n]. If we add the stipulation that @m(1!) is equal to 1, this
#     observation translates directly into a procedure:
    Así, podemos calcular @m(n!) calculando @m[(n - 1)!]) y multiplicando el
    resultado por @m(n). Si añadimos la condicion de que @m(1!) Es igual a 1,
    esta observación se traduce directamente en un procedimiento:

#     ..src > scheme
#       (define (factorial n)
#         (if (= n 1)
#             1
#             (* n (factorial (- n 1)))))
#     < src..
    ..src > scheme
      (define (factorial n)
        (if (= n 1)
            1
            (* n (factorial (- n 1)))))
    < src..

#     We can use the substitution model of section @l(#1.1.5) to watch this procedure in
#     action computing @m(6!), as shown in @l(#Figure 1.3).
    Podemos utilizar el modelo de sustitución de la seccion @l(#1.1.5) para
    observar este procedimiento en la acción de cálculo @m(6!), como se muestra
    en la @l(#Figura 1.3).

#     ..figure > @t(Figure 1.3) A linear recursive process for computing @m(6!).
    ..figure > @t(Figura 1.3) Un proceso recursivo lineal para calcular @m(6!).

#       ..art >
#         (factorial 6)        ----------------
#         (* 6 (factorial 5))                   \
#         (* 6 (* 5 (factorial 4)))               \
#         (* 6 (* 5 (* 4 (factorial 3))))           \
#         (* 6 (* 5 (* 4 (* 3 (factorial 2)))))       \
#         (* 6 (* 5 (* 4 (* 3 (* 2 (factorial 1))))))  |
#         (* 6 (* 5 (* 4 (* 3 (* 2 1)))))             /
#         (* 6 (* 5 (* 4 (* 3 2))))                 /
#         (* 6 (* 5 (* 4 6)))                     /
#         (* 6 (* 5 24))                        /
#         (* 6 120)                           /
#         720          <---------------------
#       < art..
      ..art >
        (factorial 6)        ----------------
        (* 6 (factorial 5))                   \
        (* 6 (* 5 (factorial 4)))               \
        (* 6 (* 5 (* 4 (factorial 3))))           \
        (* 6 (* 5 (* 4 (* 3 (factorial 2)))))       \
        (* 6 (* 5 (* 4 (* 3 (* 2 (factorial 1))))))  |
        (* 6 (* 5 (* 4 (* 3 (* 2 1)))))             /
        (* 6 (* 5 (* 4 (* 3 2))))                 /
        (* 6 (* 5 (* 4 6)))                     /
        (* 6 (* 5 24))                        /
        (* 6 120)                           /
        720          <---------------------
      < art..

# @   ..img > img/chap1/Fig1.3d.std.svg
@   ..img > img/chap1/Fig1.3d.std.svg

#     Now let's take a different perspective on computing factorials. We could
#     describe a rule for computing @m[n!] by specifying that we first multiply 1 by
#     2, then multiply the result by 3, then by 4, and so on until we reach @m[n].
#     More formally, we maintain a running product, together with a counter that
#     counts from 1 up to @m[n]. We can describe the computation by saying that the
#     counter and the product simultaneously change from one step to the next
#     according to the rule
    Ahora vamos a tomar una perspectiva diferente en el computo de
    factoriales. Podríamos describir una regla para calcular @m(n!)
    especificando que primero multiplicamos 1 por 2, luego multiplicamos el
    resultado por 3, luego por 4, y así sucesivamente hasta llegar a @m(n). Más
    formalmente, mantenemos un producto en ejecución, junto con un contador que
    cuenta desde 1 hasta @m(n). Podemos describir el cálculo diciendo que el
    contador y el producto cambian simultáneamente de un paso al siguiente según
    la regla

#     ..example >
#       product ← counter ⋅ product
#       counter ← counter + 1
#     < example..
    ..example >
      producto ← contador ⋅ producto
      contador ← contador + 1
    < example..

#     and stipulating that @m[n!] is the value of the product when the counter
#     exceeds @m[n].
    Y estipulando que @m(n!) Es el valor del producto cuando el contador supera
    @m(n).

#     Once again, we can recast our description as a procedure for computing
#     factorials:@n(29)
    Una vez más, podemos refundir nuestra descripción como un procedimiento para
    calcular factoriales:@n(29)

#     ..src > scheme
#       (define (factorial n)
#         (fact-iter 1 1 n))
#
#       (define (fact-iter product counter max-count)
#         (if (> counter max-count)
#             product
#             (fact-iter (* counter product)
#                        (+ counter 1)
#                        max-count)))
#     < src..
    ..src > scheme
      (define (factorial n)
        (fact-iter 1 1 n))

      (define (fact-iter product counter max-count)
        (if (> counter max-count)
            product
            (fact-iter (* counter product)
                       (+ counter 1)
                       max-count)))
    < src..

#     As before, we can use the substitution model to visualize the process of
#     computing @m(6!), as shown in @l(#Figure 1.4).
    Como antes, podemos utilizar el modelo de sustitución para visualizar el
    proceso de cálcular @m(6!), como se muestra en la @l(#Figura 1.4).

#     ..figure > @t(Figure 1.4) A linear iterative process for computing @m(6!).
    ..figure > @t(Figura 1.4) Un proceso iterativo lineal para calcular @m(6!).

#       ..art >
#         (factorial 6)   ------.
#         (fact-iter   1 1 6)   |
#         (fact-iter   1 2 6)   |
#         (fact-iter   2 3 6)   |
#         (fact-iter   6 4 6)   |
#         (fact-iter  24 5 6)   |
#         (fact-iter 120 6 6)   |
#         (fact-iter 720 7 6)  /
#         720      <----------'
#       < art..
      ..art >
        (factorial 6)   ------.
        (fact-iter   1 1 6)   |
        (fact-iter   1 2 6)   |
        (fact-iter   2 3 6)   |
        (fact-iter   6 4 6)   |
        (fact-iter  24 5 6)   |
        (fact-iter 120 6 6)   |
        (fact-iter 720 7 6)  /
        720      <----------'
      < art..

# @   ..img > img/chap1/Fig1.4d.std.svg
@   ..img > img/chap1/Fig1.4d.std.svg

#     Compare the two processes. From one point of view, they seem hardly different
#     at all. Both compute the same mathematical function on the same domain, and
#     each requires a number of steps proportional to @m(n) to compute @m(n!).
#     Indeed, both processes even carry out the same sequence of multiplications,
#     obtaining the same sequence of partial products. On the other hand, when we
#     consider the @"(shapes) of the two processes, we find that they evolve quite
#     differently.
    Compare los dos procesos. Desde un punto de vista, parecen muy diferentes.
    Ambos calculan la misma función matemática en el mismo dominio, y cada uno
    requiere un número de pasos proporcionales a @m(n) para calcular @m(n!). De
    hecho, ambos procesos incluso llevan a cabo la misma secuencia de
    multiplicaciones, obteniendo la misma secuencia de productos parciales. Por
    otro lado, cuando consideramos las @"(formas) de los dos procesos,
    encontramos que evolucionan de manera muy diferente.

#     Consider the first process. The substitution model reveals a shape of
#     expansion followed by contraction, indicated by the arrow in @l(#Figure 1.3).
#     The expansion occurs as the process builds up a chain of @e(deferred
#     operations) (in this case, a chain of multiplications). The contraction occurs
#     as the operations are actually performed. This type of process, characterized
#     by a chain of deferred operations, is called a @e(recursive process).
#     Carrying out this process requires that the interpreter keep track of the
#     operations to be performed later on. In the computation of @m[n!], the length
#     of the chain of deferred multiplications, and hence the amount of information
#     needed to keep track of it, grows linearly with @m[n] (is proportional to
#     @m[n]), just like the number of steps. Such a process is called a @e(linear
#     recursive process).
    Considere el primer proceso. El modelo de sustitución revela una forma de
    expansión seguida de contracción, indicada por la flecha en la @l(#Figura
    1.3). La expansión se produce cuando el proceso acumula una cadena de
    @e(operaciones diferidas) (en este caso, una cadena de multiplicaciones). La
    contracción ocurre cuando las operaciones se realizan realmente. Este tipo
    de proceso, caracterizado por una cadena de operaciones diferidas, se llama
    @e(proceso recursivo). Llevar a cabo este proceso requiere que el intérprete
    haga un seguimiento de las operaciones que se realizarán más adelante. En el
    cálculo de @m(n!), la longitud de la cadena de multiplicaciones diferidas y,
    por lo tanto, la cantidad de información necesaria para seguirla, @m(Crece
    linealmente con @m(n) (es proporcional a @m(n)), igual que el número de
    pasos. Este proceso se denomina @e(proceso recursivo lineal).

#     By contrast, the second process does not grow and shrink. At each step, all we
#     need to keep track of, for any @m[n], are the current values of the variables
#     @c(product), @c(counter), and @c(max-count). We call this an @e(iterative
#     process). In general, an iterative process is one whose state can be
#     summarized by a fixed number of @e(state variables), together with a fixed
#     rule that describes how the state variables should be updated as the process
#     moves from state to state and an (optional) end test that specifies conditions
#     under which the process should terminate. In computing @m[n!], the number of
#     steps required grows linearly with @m[n]. Such a process is called a @e(linear
#     iterative process).
    Por el contrario, el segundo proceso no crece y se contrae. En cada paso,
    todo lo que necesitamos para realizar un seguimiento para cualquier @m(n),
    son los valores actuales de las variables @c(product), @c(counter) y
    @c(max-count). Llamamos a esto un @e(proceso iterativo). En general, un
    proceso iterativo es aquel cuyo estado puede ser resumido por un número fijo
    de @e(variables de estado), junto con una regla fija que describe cómo se
    deben actualizar las variables de estado a medida que el proceso se mueve de
    estado a estado y una prueba final (opcional) Que especifica las condiciones
    bajo las cuales el proceso debe terminarse. En computación @m(n!), el número
    de pasos necesarios crece linealmente con @m(n). Este proceso se denomina
    @e(proceso iterativo lineal).

#     The contrast between the two processes can be seen in another way. In the
#     iterative case, the program variables provide a complete description of the
#     state of the process at any point. If we stopped the computation between
#     steps, all we would need to do to resume the computation is to supply the
#     interpreter with the values of the three program variables. Not so with the
#     recursive process. In this case there is some additional @"(hidden)
#     information, maintained by the interpreter and not contained in the program
#     variables, which indicates @"(where the process is) in negotiating the chain
#     of deferred operations. The longer the chain, the more information must be
#     maintained.@n(30)
    El contraste entre los dos procesos se puede ver de otra manera. En el caso
    iterativo, las variables del programa proporcionan una descripción completa
    del estado del proceso en cualquier punto. Si detenemos el cálculo entre los
    pasos, todo lo que tendríamos que hacer para reanudar el cálculo es
    suministrar al intérprete los valores de las tres variables del programa. No
    es así con el proceso recursivo. En este caso hay alguna información
    @"(oculta) adicional, mantenida por el intérprete y no contenida en las
    variables del programa, que indican @"(dónde está el proceso) en la
    negociación de la cadena de operaciones diferidas. Cuanto más larga sea la
    cadena, más información deberá mantenerse.@n(30)

#     In contrasting iteration and recursion, we must be careful not to confuse the
#     notion of a recursive @e(process) with the notion of a recursive
#     @e(procedure). When we describe a procedure as recursive, we are referring to
#     the syntactic fact that the procedure definition refers (either directly or
#     indirectly) to the procedure itself. But when we describe a process as
#     following a pattern that is, say, linearly recursive, we are speaking about
#     how the process evolves, not about the syntax of how a procedure is
#     written. It may seem disturbing that we refer to a recursive procedure such as
#     @c(fact-iter) as generating an iterative process. However, the process really
#     is iterative: Its state is captured completely by its three state variables,
#     and an interpreter need keep track of only three variables in order to execute
#     the process.
    Al contrastar la iteración y la recursión, debemos tener cuidado de no
    confundir la noción de @e(proceso) recursivo con la noción de
    @e(procedimiento) recursivo. Cuando describimos un procedimiento como
    recursivo, nos referimos al hecho sintáctico de que la definición del
    procedimiento se refiere (directa o indirectamente) al procedimiento
    mismo. Pero cuando describimos un proceso siguiendo un patrón que es,
    digamos, recursivo linealmente, estamos hablando de cómo evoluciona el
    proceso, no de la sintaxis de cómo se escribe un procedimiento. Puede
    parecer inquietante que nos referimos a un procedimiento recursivo
    @c(fact-iter) como generar un proceso iterativo. Sin embargo, el proceso es
    realmente iterativo: su estado es capturado completamente por sus tres
    variables de estado,

#     One reason that the distinction between process and procedure may be confusing
#     is that most implementations of common languages (including Ada, Pascal, and
#     C) are designed in such a way that the interpretation of any recursive
#     procedure consumes an amount of memory that grows with the number of procedure
#     calls, even when the process described is, in principle, iterative. As a
#     consequence, these languages can describe iterative processes only by
#     resorting to special-purpose @"(looping constructs) such as @c(do),
#     @c(repeat), @c(until), @c(for), and @c(while). The implementation of Scheme we
#     shall consider in @l(#Chapter 5) does not share this defect. It will execute
#     an iterative process in constant space, even if the iterative process is
#     described by a recursive procedure. An implementation with this property is
#     called @e(tail-recursive). With a tail-recursive implementation, iteration can
#     be expressed using the ordinary procedure call mechanism, so that special
#     iteration constructs are useful only as syntactic sugar.@n(31)
    Una de las razones por las que la distinción entre proceso y procedimiento
    puede ser confusa es que la mayoría de las implementaciones de lenguajes
    comunes (incluyendo Ada, Pascal y C) están diseñadas de tal manera que la
    interpretación de cualquier procedimiento recursivo consume una cantidad de
    memoria que crece con el número de llamadas de procedimiento, incluso cuando
    el proceso descrito es, en principio, iterativo. Como consecuencia, estos
    lenguajes pueden describir procesos iterativos recurriendo sólo a
    @"(construcciones de bucle) especiales como @c(do), @c(repeat), @c(until),
    @c(for), y @c(while). La implementación del esquema que consideraremos en el
    @l(Capitulo 5) no comparte este defecto. Ejecutará un proceso iterativo en
    un espacio constante, incluso si el proceso iterativo se describe mediante
    un procedimiento recursivo. Una implementación con esta propiedad se
    denomina @e(cola-recursiva). Con una implementación de cola-recursiva, la
    iteración se puede expresar usando el mecanismo ordinario de la llamada del
    procedimiento, de modo que las construcciones especiales de la iteración
    sean útiles solamente como azúcar sintáctico.@n(31)

#     :: @t(Exercise 1.9) :: Each of the following two procedures defines a method
#        for adding two positive integers in terms of the procedures @c(inc), which
#        increments its argument by 1, and @c(dec), which decrements its argument
#        by 1.
    :: @t(Ejercicio 1.9) :: Cada uno de los dos procedimientos siguientes define
       un método para agregar dos enteros positivos en términos de los
       procedimientos @c(inc), que incrementa su argumento por 1, y @c(dec) que
       decrementa su argumento por 1.

#        ..src > scheme
#          (define (+ a b)
#            (if (= a 0)
#                b
#                (inc (+ (dec a) b))))
#
#          (define (+ a b)
#            (if (= a 0)
#                b
#                (+ (dec a) (inc b))))
#        < src..
       ..src > scheme
         (define (+ a b)
           (if (= a 0)
               b
               (inc (+ (dec a) b))))

         (define (+ a b)
           (if (= a 0)
               b
               (+ (dec a) (inc b))))
       < src..

#        Using the substitution model, illustrate the process generated by each
#        procedure in evaluating @c[(+ 4 5)]. Are these processes iterative or
#        recursive?
       Utilizando el modelo de sustitución, ilustra el proceso generado por
       cada procedimiento en la evaluación @c[(+ 4 5)]. ¿Son estos procesos
       iterativos o recursivos?

#     :: @t(Exercise 1.10) :: The following procedure computes a mathematical
#        function called Ackermann's function.
    :: @t(Ejercicio 1.10) :: El siguiente procedimiento calcula una función
       matemática llamada función de Ackermann.

#        ..src > scheme
#          (define (A x y)
#            (cond ((= y 0) 0)
#                  ((= x 0) (* 2 y))
#                  ((= y 1) 2)
#                  (else (A (- x 1)
#                           (A x (- y 1))))))
#        < src..
       ..src > scheme
         (define (A x y)
           (cond ((= y 0) 0)
                 ((= x 0) (* 2 y))
                 ((= y 1) 2)
                 (else (A (- x 1)
                          (A x (- y 1))))))
       < src..

#        What are the values of the following expressions?
       ¿Cuáles son los valores de las siguientes expresiones?

#        ..src > scheme
#          (A 1 10)
#          (A 2 4)
#          (A 3 3)
#        < src..
       ..src > scheme
         (A 1 10)
         (A 2 4)
         (A 3 3)
       < src..

#        Consider the following procedures, where @c(A) is the procedure defined
#        above:
       Considere los siguientes procedimientos, donde @c(A) es el procedimiento
       definido anteriormente:

#        ..src > scheme
#          (define (f n) (A 0 n))
#          (define (g n) (A 1 n))
#          (define (h n) (A 2 n))
#          (define (k n) (* 5 n n))
#        < src..
       ..src > scheme
         (define (f n) (A 0 n))
         (define (g n) (A 1 n))
         (define (h n) (A 2 n))
         (define (k n) (* 5 n n))
       < src..

#        Give concise mathematical definitions for the functions computed by the
#        procedures @c(f), @c(g), and @c(h) for positive integer values of
#        @m[n]. For example, @c[(k n)] computes @m[5n²].
       Dar definiciones matemáticas concisas para las funciones calculadas por
       los procedimientos @c(f), @c(g) y @c(h) para valores enteros positivos de
       @m(n). Por ejemplo, @c[(k n)] calcula @m(5n²).

# *** 1.2.2 <> Tree Recursion
*** 1.2.2 <> Arbol de Recursion

#     Another common pattern of computation is called @e(tree recursion). As an
#     example, consider computing the sequence of Fibonacci numbers, in which each
#     number is the sum of the preceding two:
    Otro patrón de computación común se llama @e(arbol de recursion). Como
    ejemplo, considere el cálculo de la secuencia de números de Fibonacci, en la
    que cada número es la suma de los dos precedentes:

#     ..center >
    ..center >
#       0, 1, 1, 2, 3, 5, 8, 13, 21, ….
      0, 1, 1, 2, 3, 5, 8, 13, 21, ....

#     In general, the Fibonacci numbers can be defined by the rule
    En general, los números de Fibonacci pueden definirse por la regla

#     ..example >
#                 ╭
#                 │ 0                        if n = 0
#       Fib(n) = <  1                        if n = 1
#                 │ Fib(n − 1) + Fib(n − 2)  otherwise
#                 ╰
#     < example..
    ..example >
                ╭
                │ 0                        si n = 0
      Fib(n) = <  1                        si n = 1
                │ Fib(n − 1) + Fib(n − 2)  de otra forma
                ╰
    < example..

#     We can immediately translate this definition into a recursive procedure for
#     computing Fibonacci numbers:
    Podemos traducir inmediatamente esta definición en un procedimiento
    recursivo que calcula números de Fibonacci:

#     ..src > scheme
#       (define (fib n)
#         (cond ((= n 0) 0)
#               ((= n 1) 1)
#               (else (+ (fib (- n 1))
#                        (fib (- n 2))))))
#     < src..
    ..src > scheme
      (define (fib n)
        (cond ((= n 0) 0)
              ((= n 1) 1)
              (else (+ (fib (- n 1))
                       (fib (- n 2))))))
    < src..

#     Consider the pattern of this computation. To compute @c[(fib 5)], we compute
#     @c[(fib 4)] and @c[(fib 3)]. To compute @c[(fib 4)], we compute @c[(fib 3)]
#     and @c[(fib 2)]. In general, the evolved process looks like a tree, as shown
#     in @l(#Figure 1.5). Notice that the branches split into two at each level
#     (except at the bottom); this reflects the fact that the @c(fib) procedure
#     calls itself twice each time it is invoked.
    Considere el patrón de este cálculo. Para calcular @c[(fib 5)], calculamos
    @c[(fib 4)] y @c[(fib 3)]. Para computar @c[(fib 4)], calculamos @c[(fib 3)]
    y @c[(fib 2)]. En general, el proceso evolucionado se parece a un árbol,
    como se muestra en la @l(#Figura 1.5). Observe que las ramas se
    dividen en dos en cada nivel (excepto en la parte inferior); Esto refleja el
    hecho de que el procedimiento @c(fib) se llama dos veces cada vez que se
    invoca.

#     ..figure > @t(Figure 1.5) The tree-recursive process generated in computing @c[(fib 5)].
    ..figure > @t(Figura 1.5) El proceso de arbol de recursion generado en el
      calculo @c[(fib 5)].

#       ..art >
#
#                            ..<............ fib5   <..........
#                         ...     ___________/  \___________   .
#                      ...       /       . .....            \    .
#                    ..       fib4     .        . > . .     fib3  .
#                  ..     ____/. \____  ..             .  __/  \__  .
#                ..      /  . .  ..   \    .        ..   /  . .   \   .
#              ..     fib3 .       .  fib2 .        . fib2 .   .  fib1 .
#            ..      / . \  .     .   /  \  .      .  /  \ ...  .  |  .
#          ..       / . . \   .  .   /  . \   .  .   / .  \   .  . 1 .
#         .      fib2 . . fib1.  .fib1 .  fib0 . .fib1. . fib0 .  .  .
#         .      /  \  . . |  .  . |  .  . |   . . |   . . |   .   .>
#         V     /  . \   . 1  .  . 1  .  . 0  .  . 1  .  . 0  ..
#         .  fib1 .. fib0..  .   .   .   .   .   .   .   ..  .
#         .   |  .  . |  . .>     .>.     . .     .>.      .>
#         .   1 .   . 0  .
#          .   .     .  .
#           .>.       ..
#       < art..
      ..art >

                           ..<............ fib5   <..........
                        ...     ___________/  \___________   .
                     ...       /       . .....            \    .
                   ..       fib4     .        . > . .     fib3  .
                 ..     ____/. \____  ..             .  __/  \__  .
               ..      /  . .  ..   \    .        ..   /  . .   \   .
             ..     fib3 .       .  fib2 .        . fib2 .   .  fib1 .
           ..      / . \  .     .   /  \  .      .  /  \ ...  .  |  .
         ..       / . . \   .  .   /  . \   .  .   / .  \   .  . 1 .
        .      fib2 . . fib1.  .fib1 .  fib0 . .fib1. . fib0 .  .  .
        .      /  \  . . |  .  . |  .  . |   . . |   . . |   .   .>
        V     /  . \   . 1  .  . 1  .  . 0  .  . 1  .  . 0  ..
        .  fib1 .. fib0..  .   .   .   .   .   .   .   ..  .
        .   |  .  . |  . .>     .>.     . .     .>.      .>
        .   1 .   . 0  .
         .   .     .  .
          .>.       ..
      < art..

# @   ..img > img/chap1/Fig1.5d.std.svg
@   ..img > img/chap1/Fig1.5d.std.svg

#     This procedure is instructive as a prototypical tree recursion, but it is a
#     terrible way to compute Fibonacci numbers because it does so much redundant
#     computation. Notice in @l(#Figure 1.5) that the entire computation of
#     @c[(fib 3)]––almost half the work––is duplicated. In fact, it is not hard
#     to show that the number of times the procedure will compute @c[(fib 1)] or
#     @c[(fib 0)] (the number of leaves in the above tree, in general) is
#     precisely @m[Fib(n+1)]. To get an idea of how bad this is, one can
#     show that the value of @m[Fib(n)] grows exponentially with @m[n]. More
#     precisely (see @l(#Exercise 1.13)), @m[Fib(n)] is the closest integer
#     to @m[φⁿ / √5], where
    Este procedimiento es instructivo como arbol de recursion prototipico, pero
    es una manera terrible de calcular números de Fibonacci porque hace
    demaciado cálculo redundante. Observe en la @l(#Figura 1.5) que el calculo
    completo de @c[(fib 3)]––casi la mitad del trabajo––se duplica. De hecho, no
    es difícil demostrar que el número de veces que el procedimiento calculará
    @c[(fib 1)] o @c[(fib 0)] (el número de hojas en el árbol anterior, en
    general) es precisamente @m[Fib(n + 1)]. Para tener una idea de lo malo que
    es esto, uno puede demostrar que el valor de @m[Fib(n)] crece
    exponencialmente con @m(n). Más precisamente (véa el @l(#Ejercicio 1.13)),
    @m[Fib(n)] es el entero más cercano a @m(φⁿ / √5), donde

#     ..example >
#       φ = (1 + √5)/2 ≈ 1.6180
#     < example..
    ..example >
      φ = (1 + √5)/2 ≈ 1.6180
    < example..

#     is the @e(golden ratio), which satisfies the equation
    es la @e(proporcion aurea), que satisface la ecuación

#     ..example >
#       φ² = φ + 1
#     < example..
    ..example >
      φ² = φ + 1
    < example..

#     Thus, the process uses a number of steps that grows exponentially with the
#     input. On the other hand, the space required grows only linearly with the
#     input, because we need keep track only of which nodes are above us in the tree
#     at any point in the computation. In general, the number of steps required by a
#     tree-recursive process will be proportional to the number of nodes in the
#     tree, while the space required will be proportional to the maximum depth of
#     the tree.
    Por lo tanto, el proceso utiliza una serie de pasos que crecen
    exponencialmente con la entrada. Por otro lado, el espacio requerido crece
    sólo de forma lineal con la entrada, ya que necesitamos mantener un
    seguimiento de los nodos que están por encima de nosotros en el árbol en
    cualquier punto del calculo. En general, el número de pasos requeridos por
    un proceso de arbol de recursion será proporcional al número de nodos en el
    árbol, mientras que el espacio requerido será proporcional a la profundidad
    máxima del árbol.

#     We can also formulate an iterative process for computing the Fibonacci
#     numbers.  The idea is to use a pair of integers @m[a] and @m[b], initialized
#     to @m[Fib(1) = 1] and @m[Fib(0) = 0], and to repeatedly apply the simultaneous
#     transformations
    También podemos formular un proceso iterativo para calcular los números de
    Fibonacci. La idea es utilizar un par de enteros @m(a) y @m(b),
    inicializados en @m[Fib(1) = 1] y @m[Fib(0) = 0], y para aplicar
    repetidamente las transformaciones simultáneas

#     ..example >
#       a ← a + b
#       b ← a
#     < example..
    ..example >
      a ← a + b
      b ← a
    < example..

#     It is not hard to show that, after applying this transformation @m[n] times,
#     @m[a] and @m[b] will be equal, respectively, to @m[Fib(n+1)] and
#     @m[Fib(n)]. Thus, we can compute Fibonacci numbers iteratively using the
#     procedure
    No es difícil demostrar que, después de aplicar esta transformación @m(n)
    veces, @m(a) y @m(b) serán iguales, respectivamente, a @m[Fib(n + 1)] y
    @m[Fib(n)]. Así, podemos calcular los números de Fibonacci iterativamente
    usando el procedimiento

#     ..src > scheme
#       (define (fib n)
#         (fib-iter 1 0 n))
#
#       (define (fib-iter a b count)
#         (if (= count 0)
#             b
#             (fib-iter (+ a b) a (- count 1))))
#     < src..
    ..src > scheme
      (define (fib n)
        (fib-iter 1 0 n))

      (define (fib-iter a b count)
        (if (= count 0)
            b
            (fib-iter (+ a b) a (- count 1))))
    < src..

#     This second method for computing @m[Fib(n)] is a linear iteration. The
#     difference in number of steps required by the two methods––one linear in
#     @m[n], one growing as fast as @m[Fib(n)] itself––is enormous, even for small
#     inputs.
    Este segundo método para calcular @m[Fib(n)] es una iteración lineal. La
    diferencia en el número de pasos requeridos por los dos métodos––uno lineal
    en @m(n), el otro crece tan rápido como @m[Fib(n)] en sí––es enorme, incluso
    para entradas pequeñas.

#     One should not conclude from this that tree-recursive processes are useless.
#     When we consider processes that operate on hierarchically structured data
#     rather than numbers, we will find that tree recursion is a natural and
#     powerful tool.@n(32) But even in numerical operations, tree-recursive
#     processes can be useful in helping us to understand and design programs. For
#     instance, although the first @c(fib) procedure is much less efficient than the
#     second one, it is more straightforward, being little more than a translation
#     into Lisp of the definition of the Fibonacci sequence. To formulate the
#     iterative algorithm required noticing that the computation could be recast as
#     an iteration with three state variables.
    No se debe concluir de esto que los procesos recursivos arbóreos son
    inútiles. Cuando consideramos procesos que operan sobre datos estructurados
    jerárquicamente en lugar de números, encontraremos que el arbol de recursión
    es una herramienta natural y poderosa.@n(32) Pero incluso en operaciones
    numéricas, los procesos de arbol de recursion pueden ser útiles para
    ayudarnos a entender y diseñar programas. Por ejemplo, aunque el primer
    procedimiento @c(fib) es mucho menos eficiente que el segundo, es más
    sencillo, siendo poco más que una traducción a Lisp de la definición de la
    secuencia de Fibonacci. Para formular el algoritmo iterativo es necesario
    notar que el cálculo podría ser refundido como una iteración con tres
    variables de estado.

# **** Example: Counting change
**** Ejemplo: Contar el Cambio

#      It takes only a bit of cleverness to come up with the iterative Fibonacci
#      algorithm. In contrast, consider the following problem: How many different
#      ways can we make change of $1.00, given half-dollars, quarters, dimes,
#      nickels, and pennies?  More generally, can we write a procedure to compute the
#      number of ways to change any given amount of money?
     Se necesita sólo un poco de inteligencia para llegar al algoritmo iterativo
     Fibonacci. En contraste, considere el siguiente problema: ¿De Cuántas
     maneras diferentes podemos hacer el cambio de $1.00, dado medio-dólares,
     cuartos, monedas de diez, cinco, y un centavos? De manera más general,
     ¿podemos escribir un procedimiento para calcular el número de formas de
     cambiar cualquier cantidad de dinero?

#      This problem has a simple solution as a recursive procedure. Suppose we think
#      of the types of coins available as arranged in some order. Then the following
#      relation holds:
     Este problema tiene una solución simple como un procedimiento
     recursivo. Supongamos que pensamos en los tipos de monedas disponibles
     según lo dispuesto en algún orden. Entonces se cumple la siguiente
     relación:

#      The number of ways to change amount @m[a] using @m[n] kinds of coins equals
     El número de maneras de cambiar la cantidad @m(a) usando @m(n) tipos de
     monedas iguales

#      - the number of ways to change amount @m[a] using all but the first kind of
#        coin, plus
     - El número de maneras de cambiar la cantidad @m(a) utilizando todos menos
       el primer tipo de moneda, mas

#      - the number of ways to change amount @m[a - d] using all @m[n] kinds of
#        coins, where @m[d] is the denomination of the first kind of coin.
     - el número de maneras de cambiar la cantidad @m(a - d) usando todos los
       @m(n) tipos de monedas, donde @m(d) es la denominación de la primera
       clase de moneda.

#      To see why this is true, observe that the ways to make change can be divided
#      into two groups: those that do not use any of the first kind of coin, and
#      those that do. Therefore, the total number of ways to make change for some
#      amount is equal to the number of ways to make change for the amount without
#      using any of the first kind of coin, plus the number of ways to make change
#      assuming that we do use the first kind of coin. But the latter number is equal
#      to the number of ways to make change for the amount that remains after using a
#      coin of the first kind.
     Para ver por qué esto es cierto, observe que las maneras de hacer el cambio
     se pueden dividir en dos grupos: los que no usan ninguna de la primera
     clase de moneda, y los que lo hacen. Por lo tanto, el número total de
     maneras de hacer el cambio para una cantidad es igual al número de maneras
     de hacer el cambio por la cantidad sin usar cualquiera de la primera clase
     de moneda, más el número de maneras de hacer el cambio asumiendo que usamos
     la primer clase de moneda. Pero este último número es igual al número de
     maneras de hacer cambios por la cantidad que queda después de usar una
     moneda del primer tipo.

#      Thus, we can recursively reduce the problem of changing a given amount to the
#      problem of changing smaller amounts using fewer kinds of coins. Consider this
#      reduction rule carefully, and convince yourself that we can use it to describe
#      an algorithm if we specify the following degenerate cases:@n(33)
     Así, podemos reducir recursivamente el problema de cambiar una cantidad
     dada al problema de cambiar cantidades más pequeñas usando menos tipos de
     monedas. Considere cuidadosamente esta regla de reducción y convenzase de
     que podemos usarla para describir un algoritmo si especificamos los
     siguientes casos degenerados:@n(33)

#      - If @m[a] is exactly 0, we should count that as 1 way to make change.
     - Si @m(a) es exactamente 0, debemos contarlo como una forma de hacer el
       cambio.

#      - If @m[a] is less than 0, we should count that as 0 ways to make change.
     - Si @m(a) es menor que 0, debemos contar esto como 0 maneras de hacer
       cambios.

#      - If @m[n] is 0, we should count that as 0 ways to make change.
     - Si @m(n) es 0, debemos contarlo como 0 maneras de hacer cambios.


#      We can easily translate this description into a recursive procedure:
     Podemos traducir fácilmente esta descripción en un procedimiento recursivo:

#      ..src > scheme
#        (define (count-change amount)
#          (cc amount 5))
#
#        (define (cc amount kinds-of-coins)
#          (cond ((= amount 0) 1)
#                ((or (< amount 0)
#                     (= kinds-of-coins 0))
#                 0)
#                (else
#                 (+ (cc amount (- kinds-of-coins 1))
#                    (cc (- amount (first-denomination
#                                   kinds-of-coins))
#                        kinds-of-coins)))))
#
#        (define (first-denomination kinds-of-coins)
#          (cond ((= kinds-of-coins 1) 1)
#                ((= kinds-of-coins 2) 5)
#                ((= kinds-of-coins 3) 10)
#                ((= kinds-of-coins 4) 25)
#                ((= kinds-of-coins 5) 50)))
#      < src..
     ..src > scheme
       (define (count-change amount)
         (cc amount 5))

       (define (cc amount kinds-of-coins)
         (cond ((= amount 0) 1)
               ((or (< amount 0)
                    (= kinds-of-coins 0))
                0)
               (else
                (+ (cc amount (- kinds-of-coins 1))
                   (cc (- amount (first-denomination
                                  kinds-of-coins))
                       kinds-of-coins)))))

       (define (first-denomination kinds-of-coins)
         (cond ((= kinds-of-coins 1) 1)
               ((= kinds-of-coins 2) 5)
               ((= kinds-of-coins 3) 10)
               ((= kinds-of-coins 4) 25)
               ((= kinds-of-coins 5) 50)))
     < src..

#      (The @c(first-denomination) procedure takes as input the number of kinds of
#      coins available and returns the denomination of the first kind. Here we are
#      thinking of the coins as arranged in order from largest to smallest, but any
#      order would do as well.)  We can now answer our original question about
#      changing a dollar:
     (El procedimiento @c(first-denomination) toma como entrada el número de
     tipos de monedas disponibles y devuelve la denominación de la primera
     clase. Aquí estamos pensando en las monedas según lo ordenado en orden de
     mayor a menor, pero cualquier orden también lo haría). Responder a nuestra
     pregunta original sobre el cambio de un dólar:

#      ..srci > scheme
#        > (count-change 100)
#        292
#      < srci..
     ..srci > scheme
       > (count-change 100)
       292
     < srci..

#      @c(Count-change) generates a tree-recursive process with redundancies similar
#      to those in our first implementation of @c(fib). (It will take quite a while
#      for that 292 to be computed.)  On the other hand, it is not obvious how to
#      design a better algorithm for computing the result, and we leave this problem
#      as a challenge. The observation that a tree-recursive process may be highly
#      inefficient but often easy to specify and understand has led people to propose
#      that one could get the best of both worlds by designing a @"(smart compiler)
#      that could transform tree-recursive procedures into more efficient procedures
#      that compute the same result.@n(34)
     @c(Count-change) Genera un proceso de árbol-recursivo con redundancias
     similares a las de nuestra primer implementación de @c(fib). Por otro
     lado, no es obvio cómo diseñar un mejor algoritmo para calcular el
     resultado, y dejamos este problema como un desafío. La observación de que
     un proceso de árbol recursivo puede ser altamente ineficiente, pero a menudo
     fácil de especificar y entender ha llevado a la gente a proponer que uno
     podría obtener lo mejor de ambos mundos mediante el diseño de un
     @"(compilador inteligente) que podría transformar los procedimientos
     recursivos arbóreos en procedimientos más eficientes que Calcular el mismo
     resultado.@n(34)

#      :: @t(Exercise 1.11) :: A function @m(ƒ) is defined by the rule that @m[ƒ(n) =
#         n] if @m[n < 3] and @m[ƒ(n) = ƒ(n-1) + 2ƒ(n-2) + 3ƒ(n-3)] if @m[n ≥
#         3]. Write a procedure that computes @m(ƒ) by means of a recursive
#         process. Write a procedure that computes @m(ƒ) by means of an iterative
#         process.
     :: @t(Ejercicio 1.11) :: Una función @m(ƒ) se define por la regla de que
        @m(ƒ(n) = n) si @m(n < 3) y @m(ƒ(n) = ƒ(n-1) + 2ƒ(n-2) + 3ƒ(n-3))
        si @m(n ≥ 3). Escriba un procedimiento que calcule @m(ƒ) por medio de un
        proceso recursivo. Escriba un procedimiento que calcule @m(ƒ) por medio
        de un proceso iterativo.

#      :: @t(Exercise 1.12) :: The following pattern of numbers is called @e(Pascal's
#         triangle).
     :: @t(Ejercicio 1.12) :: El siguiente patrón de números se llama
        @e(triángulo de Pascal).

#         ..example >
#                    1
#                  1   1
#                1   2   1
#              1   3   3   1
#            1   4   6   4   1
#                  . . .
#         < example..
        ..example >
                   1
                 1   1
               1   2   1
             1   3   3   1
           1   4   6   4   1
                 . . .
        < example..

#         The numbers at the edge of the triangle are all 1, and each number inside
#         the triangle is the sum of the two numbers above it.@n(35) Write a
#         procedure that computes elements of Pascal's triangle by means of a
#         recursive process.
        Los números en el borde del triángulo son todos 1, y cada número dentro
        del triángulo es la suma de los dos números sobre él.@n(35) Escriba un
        procedimiento que calcule los elementos del triángulo de Pascal por
        medio de un proceso recursivo.

#      :: @t(Exercise 1.13) :: Prove that @m[Fib(n)] is the closest integer to @m(φⁿ
#         / √5), where @m[φ = (1 + √5) / 2]. Hint: Let @m[ψ = (1 - √5) / 2]. Use
#         induction and the definition of the Fibonacci numbers (see @l(#1.2.2)) to
#         prove that @m[Fib(n) = (φⁿ - ψⁿ) / √5].
     :: @t(Ejercicio 1.13) :: Probar que @m[Fib(n)] es el entero más cercano a
        @m(φⁿ / √5), donde @m[φ = (1 + √5) / 2]. Sugerencia: Sea @m[ψ = (1 - √5)
        / 2]. Utilice la inducción y la definición de los números de Fibonacci
        (vea la seccion @l(#1.2.2)) para demostrar que @m[Fib(n) = (φⁿ - ψⁿ) / √5].

# *** 1.2.3 <> Orders of Growth
*** 1.2.3 <> Órdenes de Crecimiento

#     The previous examples illustrate that processes can differ considerably in the
#     rates at which they consume computational resources. One convenient way to
#     describe this difference is to use the notion of @e(order of growth) to obtain
#     a gross measure of the resources required by a process as the inputs become
#     larger.
    Los ejemplos anteriores ilustran que los procesos pueden diferir
    considerablemente en las tasas a las que consumen los recursos
    computacionales. Una manera conveniente de describir esta diferencia es usar
    la noción de @e(orden de crecimiento) para obtener una medida bruta de los
    recursos requeridos por un proceso a medida que los datos de entrada se
    hacen más grandes.

#     Let @m[n] be a parameter that measures the size of the problem, and let
#     @m[R(n)] be the amount of resources the process requires for a problem of size
#     @m[n]. In our previous examples we took @m[n] to be the number for which a
#     given function is to be computed, but there are other possibilities. For
#     instance, if our goal is to compute an approximation to the square root of a
#     number, we might take @m[n] to be the number of digits accuracy required. For
#     matrix multiplication we might take @m[n] to be the number of rows in the
#     matrices. In general there are a number of properties of the problem with
#     respect to which it will be desirable to analyze a given process. Similarly,
#     @m[R(n)] might measure the number of internal storage registers used, the
#     number of elementary machine operations performed, and so on. In computers
#     that do only a fixed number of operations at a time, the time required will be
#     proportional to the number of elementary machine operations performed.
    Sea @m(n) un parámetro que mide el tamaño del problema, y sea @m[R(n)] la
    cantidad de recursos que el proceso requiere para un problema de tamaño
    @m(n). En nuestros ejemplos anteriores tomamos @m(n) como el número para el
    cual se va a calcular una función dada, pero hay otras posibilidades. Por
    ejemplo, si nuestro objetivo es calcular una aproximación a la raíz cuadrada
    de un número, podríamos tomar @m(n) como el número de dígitos requerido.
    Para la multiplicación matricial podríamos tomar @m(n) como el número de
    filas en las matrices. En general hay una serie de propiedades del problema
    con respecto a las cuales será deseable analizar un proceso dado. De forma
    similar, @m[R(n)] puede medir el número de registros de almacenamiento
    internos utilizados, el número de operaciones elementales de la máquina
    realizadas, etc. En los ordenadores que sólo realizan un número fijo de
    operaciones a la vez, el tiempo requerido será proporcional al número de
    operaciones elementales realizadas por la máquina.

#     We say that @m[R(n)] has order of growth @m[Θ(ƒ(n))], written @m[R(n) =
#     Θ(ƒ(n))] (pronounced @"(theta of @m[ƒ(n)]), if there are positive constants
#     @m[k₁] and @m[k₂] independent of @m[n] such that @m[k₁ ƒ(n) ≤ R(n) ≤ k₂ ƒ(n)]
#     for any sufficiently large value of @m[n]. (In other words, for large @m[n],
#     the value @m[R(n)] is sandwiched between @m[k₁ ƒ(n)] and @m[k₂ ƒ(n)].)
    Decimos que @m[R(n)] tiene orden de crecimiento @m[Θ(ƒ(n))], escrito @m[R(n)
    = Θ(ƒ(n))] (pronunciado @"(theta de @m[ƒ(n)]), si hay constantes positivas
    @m(k₁) y @m(k₂) independientes de @m(n) tal que @m[k₁ ƒ(n) ≤ R(n) ≤ k₂ ƒ(n)]
    para cualquier valor suficientemente grande de @m(n) (es decir, para un @m(n)
    grande, el valor @m[R(n)] está intercalado entre @m[k₁ ƒ(n)] Y @m[k₂ ƒ(n)].)


#     For instance, with the linear recursive process for computing factorial
#     described in section @l(#1.2.1) the number of steps grows proportionally to the input
#     @m[n]. Thus, the steps required for this process grows as @m[Θ(n)]. We also
#     saw that the space required grows as @m[Θ(n)]. For the iterative factorial,
#     the number of steps is still @m[Θ(n)] but the space is @m[Θ(1)]––that is,
#     constant.@n(36) The tree-recursive Fibonacci computation requires @m[Θ(φⁿ)]
#     steps and space @m[Θ(n)], where @m(φ) is the golden ratio described in
#     @l(#1.2.2).
    Por ejemplo, con el proceso recursivo lineal para calcular el factorial
    descrito en la seccion @l(#1.2.1) el número de pasos crece proporcionalmente
    a la entrada @m(n). Así, los pasos requeridos para este proceso crecen como
    @m[Θ(n)]. También vimos que el espacio requerido crece como @m[Θ(n)]. Para
    el factorial iterativo, el número de pasos sigue siendo @m[Θ(n)] pero el
    espacio es @m[Θ(1)] - es decir, constante.@n(36) La computación recursiva de
    Fibonacci requiere @m[Θ(φⁿ)] pasos y espacio @m(Θ (n)), donde @m(φ) es la
    proporcion aurea descrita en la seccion @l(#1.2.2).

#     Orders of growth provide only a crude description of the behavior of a
#     process.  For example, a process requiring @m[n²] steps and a process
#     requiring @m[1000n²] steps and a process requiring @m[3n² + 10n + 17] steps
#     all have @m[Θ(n²)] order of growth. On the other hand, order of growth
#     provides a useful indication of how we may expect the behavior of the process
#     to change as we change the size of the problem. For a @m[Θ(n)] (linear)
#     process, doubling the size will roughly double the amount of resources
#     used. For an exponential process, each increment in problem size will multiply
#     the resource utilization by a constant factor. In the remainder of section @l(#1.2) we
#     will examine two algorithms whose order of growth is logarithmic, so that
#     doubling the problem size increases the resource requirement by a constant
#     amount.
    Las órdenes de crecimiento proporcionan sólo una descripción cruda del
    comportamiento de un proceso. Por ejemplo, un proceso que requiere @m(n²)
    pasos y un proceso que requiere @m(1000n²) pasos y un proceso que requiere
    @m(3n + 10n + 17) pasos todos tienen un orden de crecimiento @m[Θ(n²)]. Por
    otro lado, el orden de crecimiento proporciona una indicación útil de cómo
    podemos esperar que el comportamiento del proceso cambie a medida que
    cambiamos el tamaño del problema. Para un proceso @m[Θ(n)] (lineal),
    duplicar el tamaño duplicará aproximadamente la cantidad de recursos
    utilizados. Para un proceso exponencial, cada incremento en tamaño de
    problema multiplicará la utilización de recursos por un factor constante. En
    el resto de la seccion @l(#1.2) examinaremos dos algoritmos cuyo orden de
    crecimiento es logarítmico,

#     :: @t(Exercise 1.14) :: Draw the tree illustrating the process generated by
#        the @c(count-change) procedure of section @l(#1.2.2) in making change for 11
#        cents. What are the orders of growth of the space and number of steps used
#        by this process as the amount to be changed increases?
    :: @t(Ejercicio 1.14) :: Dibuje el árbol que ilustre el proceso generado por
       el procedimiento @c(count-change) de la seccion @l(#1.2.2) en hacer
       cambios por 11 centavos. ¿Cuáles son los órdenes de crecimiento del
       espacio y el número de pasos utilizados por este proceso a medida que
       aumenta el monto a cambiar?

#     :: @t(Exercise 1.15) :: The sine of an angle (specified in radians) can be
#        computed by making use of the approximation @m(sin x ≈ x) if @m(x) is
#        sufficiently small, and the trigonometric identity
    :: @t(Ejercicio 1.15) :: El seno de un ángulo (especificado en radianes) se
       puede calcular haciendo uso de la aproximación @m(sen x ≈ x) si @m(x) es
       suficientemente pequeño, y la identidad trigonométrica

#        ..example >
#                        x           x
#          sin x = 3sin ––– − 4sin³ –––
#                        3           3
#        < example..
       ..example >
                       x           x
         sin x = 3sin ––– − 4sin³ –––
                       3           3
       < example..

#        to reduce the size of the argument of sin. (For purposes of this exercise
#        an angle is considered @"(sufficiently small) if its magnitude is not
#        greater than 0.1 radians.) These ideas are incorporated in the following
#        procedures:
       para reducir el tamaño del argumento de sin. (Para los propósitos de
       este ejercicio un ángulo se considera @"(suficientemente pequeño) si su
       magnitud no es mayor que 0.1 radianes). Estas ideas se incorporan en los
       siguientes procedimientos:

#        ..src > scheme
#          (define (cube x) (* x x x))
#          (define (p x) (- (* 3 x) (* 4 (cube x))))
#          (define (sine angle)
#             (if (not (> (abs angle) 0.1))
#                 angle
#                 (p (sine (/ angle 3.0)))))
#        < src..
       ..src > scheme
         (define (cube x) (* x x x))
         (define (p x) (- (* 3 x) (* 4 (cube x))))
         (define (sine angle)
            (if (not (> (abs angle) 0.1))
                angle
                (p (sine (/ angle 3.0)))))
       < src..

#        1. How many times is the procedure @c(p) applied when @c[(sine 12.15)] is
#           evaluated?
       1. ¿Cuántas veces se aplica el procedimiento @c(p) cuando se evalúa
          @c[(sine 12.15)]?

#        2. What is the order of growth in space and number of steps (as a function
#           of @m(a)) used by the process generated by the @c(sine) procedure when
#           @c[(sine a)] is evaluated?
       2. ¿Cuál es el orden de crecimiento en el espacio y el número de pasos
          (en función de @m(a) ) utilizados por el proceso generado por el
          procedimiento @c(sine) cuando se evalúa @c[(sine a)]?

# *** 1.2.4 <> Exponentiation
*** 1.2.4 <> Exponenciación

#     Consider the problem of computing the exponential of a given number. We would
#     like a procedure that takes as arguments a base @m[b] and a positive integer
#     exponent @m[n] and computes @m[bⁿ]. One way to do this is via the recursive
#     definition
    Considere el problema de calcular el exponencial de un número dado. Nos
    gustaría un procedimiento que toma como argumentos una base @m(b) y un
    exponente entero positivo @m(n) y calcula @m(bⁿ). Una forma de hacerlo es a
    través de la definición recursiva

#     ..example >
#       bⁿ = b ⋅ bⁿ⁻¹
#       b⁰ = 1
#     < example..
    ..example >
      bⁿ = b ⋅ bⁿ⁻¹
      b⁰ = 1
    < example..

#     which translates readily into the procedure
    Que se traduce fácilmente en el procedimiento

#     ..src > scheme
#       (define (expt b n)
#         (if (= n 0)
#             1
#             (* b (expt b (- n 1)))))
#     < src..
    ..src > scheme
      (define (expt b n)
        (if (= n 0)
            1
            (* b (expt b (- n 1)))))
    < src..

#     This is a linear recursive process, which requires @m[Θ(n)] steps and @m[Θ(n)]
#     space. Just as with factorial, we can readily formulate an equivalent linear
#     iteration:
    Este es un proceso recursivo lineal, que requiere @m[Θ(n)] pasos y @m[Θ(n)]
    espacio. Al igual que con el factorial, podemos formular fácilmente una
    iteración lineal equivalente:

#     ..src > scheme
#       (define (expt b n)
#         (expt-iter b n 1))
#
#       (define (expt-iter b counter product)
#         (if (= counter 0)
#             product
#             (expt-iter b
#                        (- counter 1)
#                        (* b product))))
#     < src..
    ..src > scheme
      (define (expt b n)
        (expt-iter b n 1))

      (define (expt-iter b counter product)
        (if (= counter 0)
            product
            (expt-iter b
                       (- counter 1)
                       (* b product))))
    < src..

#     This version requires @m[Θ(n)] steps and @m[Θ(1)] space.
    Esta versión requiere @m[Θ(n)] pasos y @m[Θ(1)] espacio.

#     We can compute exponentials in fewer steps by using successive squaring. For
#     instance, rather than computing @m(b⁸) as
    Podemos calcular exponenciales en menos pasos usando cuadrados
    sucesivos. Por ejemplo, en lugar de calcular @m(b⁸) como

#     ..example >
#       b ⋅ (b ⋅ (b ⋅ (b ⋅ (b ⋅ (b ⋅ (b ⋅ b))))))
#     < example..
    ..example >
      b ⋅ (b ⋅ (b ⋅ (b ⋅ (b ⋅ (b ⋅ (b ⋅ b))))))
    < example..

#     we can compute it using three multiplications:
    Podemos calcularlo usando tres multiplicaciones:

#     ..example >
#       b² = b ⋅ b
#       b⁴ = b² ⋅ b²
#       b⁸ = b⁴ ⋅ b⁴
#     < example..
    ..example >
      b² = b ⋅ b
      b⁴ = b² ⋅ b²
      b⁸ = b⁴ ⋅ b⁴
    < example..

#     This method works fine for exponents that are powers of 2. We can also take
#     advantage of successive squaring in computing exponentials in general if we
#     use the rule
    Este método funciona bien para exponentes que son potencias de 2. También
    podemos aprovechar los cuadrados sucesivos en la computación exponencial en
    general si usamos la regla

#     ..example >
#       bⁿ = (b^(n/2))²    if n is even
#       bⁿ = b ⋅ bⁿ⁻¹      if n is odd
#     < example..
    ..example >
      bⁿ = (b^(n/2))²    si n es even
      bⁿ = b ⋅ bⁿ⁻¹      si n es odd
    < example..

#     We can express this method as a procedure:
    Podemos expresar este método como un procedimiento:

#     ..src > scheme
#       (define (fast-expt b n)
#         (cond ((= n 0)
#                1)
#               ((even? n)
#                (square (fast-expt b (/ n 2))))
#               (else
#                (* b (fast-expt b (- n 1))))))
#     < src..
    ..src > scheme
      (define (fast-expt b n)
        (cond ((= n 0)
               1)
              ((even? n)
               (square (fast-expt b (/ n 2))))
              (else
               (* b (fast-expt b (- n 1))))))
    < src..

#     where the predicate to test whether an integer is even is defined in terms of
#     the primitive procedure @c(remainder) by
    Donde el predicado para probar si un entero es par se define en términos del
    procedimiento primitivo @c(remainder) por

#     ..src > scheme
#       (define (even? n)
#         (= (remainder n 2) 0))
#     < src..
    ..src > scheme
      (define (even? n)
        (= (remainder n 2) 0))
    < src..

#     The process evolved by @c(fast-expt) grows logarithmically with @m(n) in both
#     space and number of steps. To see this, observe that computing @m(b²ⁿ) using
#     @c(fast-expt) requires only one more multiplication than computing @m(bⁿ). The
#     size of the exponent we can compute therefore doubles (approximately) with
#     every new multiplication we are allowed. Thus, the number of multiplications
#     required for an exponent of @m(n) grows about as fast as the logarithm of
#     @m(n) to the base 2. The process has @m[Θ(log n)] growth.@n(37)
    El proceso evolucionado por @c(fast-expt) se desarrolla logarítmicamente con
    @m(n) tanto en el espacio como en el número de pasos. Para ver esto, observe
    que el calculo @m(b²ⁿ) usando @c(fast-expt) requiere sólo una
    multiplicación más que el calculo @m(bⁿ). El tamaño del exponente que
    podemos calcular se duplica (aproximadamente) con cada nueva multiplicación
    que se nos permite. Así, el número de multiplicaciones requeridas para un
    exponente de @m(n) crece tan rápido como el logaritmo de @m(n) a la
    base 2. El proceso tiene crecimiento @m[Θ(log n)].@n(37)

#     The difference between @m[Θ(log n)] growth and @m[Θ(n)] growth becomes
#     striking as @m(n) becomes large. For example, @c(fast-expt) for @m(n = 1000)
#     requires only 14 multiplications.@n(38) It is also possible to use the idea of
#     successive squaring to devise an iterative algorithm that computes
#     exponentials with a logarithmic number of steps (see @l(#Exercise 1.16)),
#     although, as is often the case with iterative algorithms, this is not written
#     down so straightforwardly as the recursive algorithm.@n(39)
    La diferencia entre el crecimiento de @m[Θ(log n)] y el crecimiento de
    @m[Θ(n)] se hace notoria a medida que @m(n) se hace grande. Por ejemplo,
    @c(fast-expt) para @m(n = 1000) requiere sólo 14 multiplicaciones.@n(38)
    También es posible utilizar la idea de elevar al cuadrado sucesivo para
    idear un algoritmo iterativo que calcula exponenciales con una serie
    logarítmica de pasos (véa el @l(#Ejercicio 1.16)), aunque, como suele ser el
    caso con algoritmos iterativos, esto no se escribe con tanta facilidad como
    el algoritmo recursivo.@n(39)

#     :: @t(Exercise 1.16) :: Design a procedure that evolves an iterative
#        exponentiation process that uses successive squaring and uses a logarithmic
#        number of steps, as does @c(fast-expt). (Hint: Using the observation that
#        @M[{(b^{n / 2})²} = {(b²)^{n / 2}}], keep, along with the exponent @m(n)
#        and the base @m(b), an additional state variable @m(a), and define the
#        state transformation in such a way that the product @m(abⁿ) is unchanged
#        from state to state. At the beginning of the process @m(a) is taken to be
#        1, and the answer is given by the value of @m(a) at the end of the
#        process. In general, the technique of defining an @e(invariant quantity)
#        that remains unchanged from state to state is a powerful way to think about
#        the design of iterative algorithms.)
    :: @t(Ejercicio 1.16) :: Diseñar un procedimiento que evoluciona un proceso
       de exponenciación iterativo que utiliza cuadrados sucesivos y un número
       logarítmico de pasos, como lo hace @c(fast-expt). (Sugerencia: Utilizando
       la observación de que @M[{(b^{n / 2})²} = {(b²)^{n / 2}}], mantenga,
       junto con el exponente @m(n) y la base @m(b), una variable de estado
       @m(a), y defina la transformación del estado de una manera tal que el
       producto @m(abⁿ) no cambia de estado a estado. Al principio del proceso
       @m(a) se toma como 1, y se da la respuesta viene dada por el valor de
       @m(a) al final del proceso. En general, la técnica de definir una
       @e(cantidad invariante) que permanece sin cambios de estado a estado es
       una manera poderosa de pensar en el diseño de algoritmos iterativos.)

#     :: @t(Exercise 1.17) :: The exponentiation algorithms in this section are
#        based on performing exponentiation by means of repeated multiplication. In
#        a similar way, one can perform integer multiplication by means of repeated
#        addition. The following multiplication procedure (in which it is assumed
#        that our language can only add, not multiply) is analogous to the @c(expt)
#        procedure:
    :: @t(Ejercicio 1.17) :: Los algoritmos de exponenciación en esta sección se
       basan en realizar la exponenciación mediante multiplicación repetida. De
       manera similar, se puede realizar una multiplicación entera por medio de
       adición repetida. El siguiente procedimiento de multiplicación (en el que
       se supone que nuestro lenguaje sólo puede añadir, no multiplicarse) es
       análogo al procedimiento @c(expt):

#        ..src > scheme
#          (define (* a b)
#            (if (= b 0)
#                0
#                (+ a (* a (- b 1)))))
#        < src..
       ..src > scheme
         (define (* a b)
           (if (= b 0)
               0
               (+ a (* a (- b 1)))))
       < src..

#        This algorithm takes a number of steps that is linear in @c(b). Now suppose
#        we include, together with addition, operations @c(double), which doubles an
#        integer, and @c(halve), which divides an (even) integer by 2. Using these,
#        design a multiplication procedure analogous to @c(fast-expt) that uses a
#        logarithmic number of steps.
       Este algoritmo toma una serie de pasos que es lineal en @c(b). Ahora
       supongamos que incluimos, junto con la adición, las operaciones
       @c(double), que duplica un entero, y @c(halve), que divide un entero
       (par) por 2. Usando estas, diseñamos un procedimiento de multiplicación
       análogo a @c(fast-expt) que usa un número logarítmico de pasos.

#     :: @t(Exercise 1.18) :: Using the results of @l(#Exercise 1.16) and
#        @l(#Exercise 1.17), devise a procedure that generates an iterative process
#        for multiplying two integers in terms of adding, doubling, and halving and
#        uses a logarithmic number of steps.@n(40)
    :: @t(Ejercicio 1.18) :: Utilizando los resultados del @l(#Ejercicio 1.16) y
       el @l(#Ejercicio 1.17), diseñar un procedimiento que genera un proceso
       iterativo para multiplicar dos enteros en términos de sumar, duplicar y
       reducir a la mitad y usa un número logarítmico de pasos.@n(40)

#     :: @t(Exercise 1.19) :: There is a clever algorithm for computing the
#        Fibonacci numbers in a logarithmic number of steps. Recall the
#        transformation of the state variables @m(a) and @m(b) in the @c(fib-iter)
#        process of section @l(#1.2.2): @m(a ← a + b) and @m(b ← a).  Call this
#        transformation @m(T), and observe that applying @m(T) over and over again
#        @m(n) times, starting with 1 and 0, produces the pair @m[Fib(n+1)] and
#        @m[Fib(n)]. In other words, the Fibonacci numbers are produced by applying
#        @m(Tⁿ), the @m(nᵗʰ) power of the transformation @m(T), starting with the
#        pair (1, 0). Now consider @m(T) to be the special case of @m(p=0) and
#        @m(q=1) in a family of transformations @M(T_{pq}), where @M(T_{pq})
#        transforms the pair @m[(a, b)] according to @m(a ← bq + aq + ap) and @m(b ←
#        bp + aq).  Show that if we apply such a transformation @M[T_{pq}] twice,
#        the effect is the same as using a single transformation @M[T_{p'q'}] of the
#        same form, and compute @M[p'\!] and @M[q'\!] in terms of @m(p) and
#        @m(q). This gives us an explicit way to square these transformations, and
#        thus we can compute @m(Tⁿ) using successive squaring, as in the
#        @c(fast-expt) procedure. Put this all together to complete the following
#        procedure, which runs in a logarithmic number of steps:@n(41)
    :: @t(Ejercicio 1.19) :: Existe un algoritmo inteligente para calcular los
       números de Fibonacci en un número logarítmico de pasos. Recordemos la
       transformación de las variables de estado @m(a) y @m(b) en el proceso
       @c(fib-iter) de la seccion @l(#1.2.2) : @m(a ← a + b) y @m(b ← a). Llame
       a esta transformación @m(T), y observe que aplicar @m(T) una y otra vez
       @m(n) veces, comenzando con 1 y 0, produce el par @m[Fib(n + 1)] y
       @m[Fib(n)]. En otras palabras, los números de Fibonacci se producen
       aplicando @m(Tⁿ), la potencia @m(nᵗʰ) de la transformación @m(T),
       comenzando con el par (1, 0). Ahora considere @m(T) es el caso especial
       de @m(p=0) y @m(q=1) en una familia de transformaciones @M(T_{pq}), donde
       @M(T_{pq}) transforma el par @m[(a, b)] de acuerdo con @m(a ← bq + aq +
       ap) y @m(b ← pb + aq). Demuestre que si aplicamos semejante
       transformación @M(T_{pq}) dos veces, el efecto es el mismo que usar una
       sola transformación @M(T_{p'q'}) de la misma forma y calcular @M[p'\!] y
       @M[q'\!] en términos de @m(p) y @m(q). Esto nos da una forma explícita de
       cuadrar estas transformaciones, y así podemos calcular @m(Tⁿ) usando
       cuadrados sucesivos, como en el procedimiento @c(fast-expt). Ponga todo
       esto junto para completar el siguiente procedimiento,@n(41)

#        ..src > scheme
#          (define (fib n)
#            (fib-iter 1 0 0 1 n))
#
#          (define (fib-iter a b p q count)
#            (cond ((= count 0)
#                   b)
#                  ((even? count)
#                   (fib-iter a
#                             b
#                             ⟨??⟩  ;compute p'
#                             ⟨??⟩  ;compute q'
#                             (/ count 2)))
#                  (else
#                   (fib-iter (+ (* b q)
#                                (* a q)
#                                (* a p))
#                             (+ (* b p)
#                                (* a q))
#                             p
#                             q
#                             (- count 1)))))
#        < src..
       ..src > scheme
         (define (fib n)
           (fib-iter 1 0 0 1 n))

         (define (fib-iter a b p q count)
           (cond ((= count 0)
                  b)
                 ((even? count)
                  (fib-iter a
                            b
                            ⟨??⟩  ;compute p'
                            ⟨??⟩  ;compute q'
                            (/ count 2)))
                 (else
                  (fib-iter (+ (* b q)
                               (* a q)
                               (* a p))
                            (+ (* b p)
                               (* a q))
                            p
                            q
                            (- count 1)))))
       < src..

# *** 1.2.5 <> Greatest Common Divisors
*** 1.2.5 <> Maximo Comun Divisor

#     The greatest common divisor (@A(GCD)) of two integers @m(a) and @m(b) is
#     defined to be the largest integer that divides both @m(a) and @m(b) with no
#     remainder. For example, the @A(GCD) of 16 and 28 is 4. In @l(#Chapter 2), when
#     we investigate how to implement rational-number arithmetic, we will need to be
#     able to compute @A(GCD)s in order to reduce rational numbers to lowest
#     terms. (To reduce a rational number to lowest terms, we must divide both the
#     numerator and the denominator by their @A(GCD). For example, 16/28 reduces to
#     4/7.)  One way to find the @A(GCD) of two integers is to factor them and
#     search for common factors, but there is a famous algorithm that is much more
#     efficient.
    El maximo común divisor (o @A(GCD) por greatest common divisor) de dos
    enteros @m(a) y @m(b) se define como el entero más grande que divide a @m(a)
    y @m(b) sin resto. Por ejemplo, el @A(GCD) de 16 y 28 es 4. En el
    @l(Capitulo 2), cuando investiguemos cómo implementar la aritmética del
    número racional, tendremos que ser capaces de calcular @A(GCD)s en orden
    para reducir números racionales a los términos más bajos. (Para reducir un
    número racional a los términos más bajos, debemos dividir el numerador y el
    denominador por su @A(GCD). Por ejemplo, 16/28 se reduce a 4/7.) Una forma
    de encontrar el @A(GCD) de dos entero s es factorizarlos y búscar los
    factores comunes,

#     The idea of the algorithm is based on the observation that, if @m(r) is the
#     remainder when @m(a) is divided by @m(b), then the common divisors of @m(a)
#     and @m(b) are precisely the same as the common divisors of @m(b) and
#     @m(r). Thus, we can use the equation
    La idea del algoritmo se basa en la observación de que si @m(r) es el resto
    cuando @m(a) está dividido por @m(b), entonces los divisores comunes de
    @m(a) y @m(b) son precisamente los mismos que los divisores comunes de @m(b)
    y @m(r). Así, podemos usar la ecuación

#     ..example >
#       GCD(a,b) = GCD(b,r)
#     < example..
    ..example >
      GCD(a,b) = GCD(b,r)
    < example..

#     to successively reduce the problem of computing a @A(GCD) to the problem of
#     computing the @A(GCD) of smaller and smaller pairs of integers. For example,
    para reducir sucesivamente el problema de calcular un @A(GCD) al problema de
    calcular el @A(GCD) de pares de números enteros más pequeños y más
    pequeños. Por ejemplo,

#     ..example >
#       GCD(206,40) = GCD(40,6)
#                   = GCD(6,4)
#                   = GCD(4,2)
#                   = GCD(2,0) = 2
#     < example..
    ..example >
      GCD(206,40) = GCD(40,6)
                  = GCD(6,4)
                  = GCD(4,2)
                  = GCD(2,0) = 2
    < example..

#     reduces @A(GCD)(206, 40) to @A(GCD)(2, 0), which is 2. It is possible to show
#     that starting with any two positive integers and performing repeated
#     reductions will always eventually produce a pair where the second number
#     is 0. Then the @A(GCD) is the other number in the pair. This method for
#     computing the @A(GCD) is known as @e(Euclid's Algorithm).@n(42)
    Reduce @A(GCD)(206, 40) a @A(GCD)(2, 0), que es 2. Es posible mostrar que
    comenzar con dos enteros positivos y realizar reducciones repetidas siempre
    producirá un par donde el segundo número es 0. Entonces el @A(GCD) es el
    otro número en el par. Este método para calcular el @A(GCD) se conoce como
    @e(Algoritmo de Euclides).@n(42)

#     It is easy to express Euclid's Algorithm as a procedure:
    Es fácil expresar el Algoritmo de Euclides como un procedimiento:

#     ..src > scheme
#       (define (gcd a b)
#         (if (= b 0)
#             a
#             (gcd b (remainder a b))))
#     < src..
    ..src > scheme
      (define (gcd a b)
        (if (= b 0)
            a
            (gcd b (remainder a b))))
    < src..

#     This generates an iterative process, whose number of steps grows as the
#     logarithm of the numbers involved.
    Esto genera un proceso iterativo, cuyo número de pasos crece como el
    logaritmo de los números involucrados.

#     The fact that the number of steps required by Euclid's Algorithm has
#     logarithmic growth bears an interesting relation to the Fibonacci numbers:
    El hecho de que el número de pasos requeridos por el Algoritmo de Euclides
    tenga crecimiento logarítmico tiene una interesante relación con los números
    de Fibonacci:

#     - Lamé's Theorem :: If Euclid's Algorithm requires @m(k) steps to compute the
#       @A(GCD) of some pair, then the smaller number in the pair must be greater
#       than or equal to the @m(kᵗʰ) Fibonacci number.@n(43)
    - Teorema de Lamé -: Si el Algoritmo de Euclides requiere @m(k) pasos para
      calcular el @A(GCD) de algún par, entonces el número más pequeño en el par
      debe ser mayor o igual al número de @m(kᵗʰ) Fibonacci.@n(43)

#     We can use this theorem to get an order-of-growth estimate for Euclid's
#     Algorithm. Let @m(n) be the smaller of the two inputs to the procedure. If
#     the process takes @m(k) steps, then we must have @m[n ≥ Fib(k) ≈ φᵏ/√5].
#     Therefore the number of steps @m(k) grows as the logarithm (to the base
#     @m(φ) of @m(n). Hence, the order of growth is @m[Θ(log n)].
    Podemos usar este teorema para obtener una estimación de orden de
    crecimiento para el Algoritmo de Euclides. Sea @m(n) la menor de las dos
    entradas del procedimiento. Si el proceso toma @m(k) pasos, entonces debemos
    tener @m[n ≥ Fib(k) ≈ φᵏ/√5]. Por lo tanto, el número de pasos @m(k) crece
    como el logaritmo (a la base @m(φ) de @m(n). Por lo tanto, el orden de
    crecimiento es @m[Θ(log n)].

#     :: @t(Exercise 1.20) :: The process that a procedure generates is of course
#        dependent on the rules used by the interpreter. As an example, consider the
#        iterative @c(gcd) procedure given above. Suppose we were to interpret this
#        procedure using normal-order evaluation, as discussed in section @l(#1.1.5). (The
#        normal-order-evaluation rule for @c(if) is described in @l(#Exercise 1.5).)
#        Using the substitution method (for normal order), illustrate the process
#        generated in evaluating @c[(gcd 206 40)] and indicate the @c(remainder)
#        operations that are actually performed. How many @c(remainder) operations
#        are actually performed in the normal-order evaluation of @c[(gcd 206 40)]?
#        In the applicative-order evaluation?
    :: @t(Ejercicio 1.20) :: El proceso que genera un procedimiento depende, por
       supuesto, de las reglas utilizadas por el intérprete. Como ejemplo,
       considere el procedimiento iterativo @c(gcd) anterior. Supongamos que
       debemos interpretar este procedimiento usando la evaluación de orden
       normal, como se discutió en @l(#1.1.5). (La regla de evaluación de orden
       normal para @c(if) se describe en el @l(#Ejercicio 1.5).) Usando el
       método de sustitución (para el orden normal), ilustrar el proceso
       generado en la evaluación @c[(gcd 206 40)] e indicar las operaciones
       @c(remainder) que se realizan realmente. ¿Cuántas operaciones
       @c(remainder) se realizan realmente en la evaluación de orden normal de
       @c[(gcd 206 40)]? ¿En la evaluación de orden aplicativo?

# *** 1.2.6 <> Example: Testing for Primality
*** 1.2.6 <> Ejemplo: Prueba de Primalidad

#     This section describes two methods for checking the primality of an integer
#     @m(n), one with order of growth @m[Θ(√n)], and a @"(probabilistic) algorithm
#     with order of growth @m[Θ(log n)].  The exercises at the end of this section
#     suggest programming projects based on these algorithms.
    Esta sección describe dos métodos para comprobar la primalidad de un entero
    @m(n), uno con orden de crecimiento @m[Θ(√n)] y un algoritmo
    @"(probabilístico) con orden de crecimiento @m[Θ(log n)]. Los ejercicios al
    final de esta sección sugieren proyectos de programación basados en estos
    algoritmos.

# **** Searching for divisors
**** Búsqueda de divisores

#      Since ancient times, mathematicians have been fascinated by problems
#      concerning prime numbers, and many people have worked on the problem of
#      determining ways to test if numbers are prime. One way to test if a number is
#      prime is to find the number's divisors. The following program finds the
#      smallest integral divisor (greater than 1) of a given number @m(n). It does
#      this in a straightforward way, by testing @m(n) for divisibility by successive
#      integers starting with 2.
     Desde la antigüedad, los matemáticos han estado fascinados por problemas
     relativos a los números primos, y muchas personas han trabajado en el
     problema de determinar maneras de probar si los números son primos. Una
     forma de probar si un número es primo es encontrar los divisores del
     número. El siguiente programa encuentra el divisor integral más pequeño
     (mayor que 1) de un número dado @m(n). Lo hace de una manera directa,
     probando @m(n) para la divisibilidad por enteros sucesivos comenzando
     por 2.

#      ..src > scheme
#        (define (smallest-divisor n)
#          (find-divisor n 2))
#
#        (define (find-divisor n test-divisor)
#          (cond ((> (square test-divisor) n)
#                 n)
#                ((divides? test-divisor n)
#                 test-divisor)
#                (else (find-divisor
#                       n
#                       (+ test-divisor 1)))))
#
#        (define (divides? a b)
#          (= (remainder b a) 0))
#      < src..
     ..src > scheme
       (define (smallest-divisor n)
         (find-divisor n 2))

       (define (find-divisor n test-divisor)
         (cond ((> (square test-divisor) n)
                n)
               ((divides? test-divisor n)
                test-divisor)
               (else (find-divisor
                      n
                      (+ test-divisor 1)))))

       (define (divides? a b)
         (= (remainder b a) 0))
     < src..

#      We can test whether a number is prime as follows: @m(n) is prime if and only
#      if @m(n) is its own smallest divisor.
     Podemos probar si un número es primo como sigue: @m(n) es primo si y sólo
     si @m(n) es su propio divisor más pequeño.

#      ..src > scheme
#        (define (prime? n)
#          (= n (smallest-divisor n)))
#      < src..
     ..src > scheme
       (define (prime? n)
         (= n (smallest-divisor n)))
     < src..

#      The end test for @c(find-divisor) is based on the fact that if @m(n) is not
#      prime it must have a divisor less than or equal to @m(√n).@n(44) This means
#      that the algorithm need only test divisors between 1 and @m(√n). Consequently,
#      the number of steps required to identify @m(n) as prime will have order of
#      growth @m(Θ(√n)).
     La prueba final @c(find-divisor) se basa en el hecho de que si @m(n) no es
     primo debe tener un divisor inferior o igual a @m(√n).@n(44) Esto significa
     que el algoritmo sólo necesita probar divisores entre 1 y @m(√n). En
     consecuencia, el número de pasos necesarios para identificar @m(n) como
     primo tendrá orden de crecimiento @m[Θ(√n)].

# **** The Fermat test
**** La prueba de Fermat

#      The @m[Θ(log n)] primality test is based on a result from number theory known
#      as Fermat's Little Theorem.@n(45)
     La prueba de primalidad @m[Θ(log n)] se basa en un resultado de la teoría
     de números conocida como el Pequeño Teorema de Fermat.@n(45)

#      - Fermat's Little Theorem :: If @m(n) is a prime number and @m(a) is any
#        positive integer less than @m(n), then @m(a) raised to the @m(nᵗʰ) power is
#        congruent to @m(a) modulo @m(n).
     - El pequeño teorema de Fermat :: Si @m(n) es un número primo y @m(a) es
       cualquier número entero positivo menor que @m(n), entonces @m(a) elevado
       a la @m(nᵗʰ) potencia es congruente con @m(a) modulo @m(n).

#      (Two numbers are said to be @e(congruent modulo) @m(n) if they both have the
#      same remainder when divided by @m(n). The remainder of a number @m(a) when
#      divided by @m(n) is also referred to as the @e(remainder of) @m(a) @e(modulo)
#      @m(n), or simply as @m(a) @e(modulo) @m(n).)
     (Se dice que dos números son @e(congruentes) @m(n) si ambos tienen el mismo
     resto cuando se dividen por @m(n). El resto de un número @m(a) cuando se
     divide por @m(n) también se denomina el @e(resto de) @m(a) @e(módulo)
     @m(n), o simplemente como @m(a) @e(módulo) @m(n).)

#      If @m(n) is not prime, then, in general, most of the numbers @m(a < n) will
#      not satisfy the above relation. This leads to the following algorithm for
#      testing primality: Given a number @m(n), pick a random number @m(a < n) and
#      compute the remainder of @m(aⁿ) modulo @m(n). If the result is not equal to
#      @m(a), then @m(n) is certainly not prime. If it is @m(a), then chances are
#      good that @m(n) is prime. Now pick another random number @m(a) and test it
#      with the same method. If it also satisfies the equation, then we can be even
#      more confident that @m(n) is prime. By trying more and more values of @m(a),
#      we can increase our confidence in the result. This algorithm is known as the
#      Fermat test.
     Si @m(n) no es primo, entonces, en general, la mayoría de los números @m(a
     < n) no satisfarán la relación anterior. Esto conduce al siguiente
     algoritmo para probar la primalidad: Dado un número @m(n), escoja un número
     aleatorio @m(a < n) y calcule el resto de @m(aⁿ) módulo @m(n). Si el
     resultado no es igual a @m(a), entonces @m(n) ciertamente no es primo. Si
     es @m(a), entonces las posibilidades son buenas de que @m(n) es
     primo. Ahora escoja otro número aleatorio @m(a) y pruebe con el mismo
     método. Si también satisface la ecuación, entonces podemos estar aún más
     seguros de que @m(n) es primo. Al intentar cada vez más valores de @m(a),
     podemos aumentar nuestra confianza en el resultado. Este algoritmo es
     conocido como la prueba de Fermat.

#      To implement the Fermat test, we need a procedure that computes the
#      exponential of a number modulo another number:
     Para implementar la prueba de Fermat, necesitamos un procedimiento que
     calcula el exponencial de un número modulo otro número:

#      ..src > scheme
#        (define (expmod base exp m)
#          (cond ((= exp 0) 1)
#                ((even? exp)
#                 (remainder
#                  (square (expmod base (/ exp 2) m))
#                  m))
#                (else
#                 (remainder
#                  (* base (expmod base (- exp 1) m))
#                  m))))
#      < src..
     ..src > scheme
       (define (expmod base exp m)
         (cond ((= exp 0) 1)
               ((even? exp)
                (remainder
                 (square (expmod base (/ exp 2) m))
                 m))
               (else
                (remainder
                 (* base (expmod base (- exp 1) m))
                 m))))
     < src..

#      This is very similar to the @c(fast-expt) procedure of section @l(#1.2.4).  It uses
#      successive squaring, so that the number of steps grows logarithmically with
#      the exponent.@n(46)
     Esto es muy similar al procedimiento @c(fast-expt) de la seccion
     @l(#1.2.4). Utiliza cuadrados sucesivos, de manera que el número de pasos
     crece logarítmicamente con el exponente.@n(46)

#      The Fermat test is performed by choosing at random a number @m(a) between 1
#      and @m(n-1) inclusive and checking whether the remainder modulo @m(n) of the
#      @m(nᵗʰ) power of @m(a) is equal to @m(a). The random number @m(a) is chosen
#      using the procedure @c(random), which we assume is included as a primitive in
#      Scheme. @c(Random) returns a nonnegative integer less than its integer
#      input. Hence, to obtain a random number between 1 and @m(n-1), we call
#      @c(random) with an input of @m(n-1) and add 1 to the result:
     La prueba de Fermat se realiza eligiendo al azar un número @m(a) entre 1 y
     @m(n-1) inclusive y verificando si el resto de módulo @m(n) de la patencia
     @m(nᵗʰ) de @m(a) es igual a @m(a). El número aleatorio @m(a) se elige
     utilizando el procedimiento @c(random), que suponemos que se incluye como
     primitiva en Scheme. @c(Random) Devuelve un entero no negativo menor que su
     entrada entera. Por lo tanto, para obtener un número aleatorio entre 1 y
     @m(n-1), llamamos a @c(random) con una entrada de @m(n-1) y añadimos 1 al
     resultado:

#      ..src > scheme
#        (define (fermat-test n)
#          (define (try-it a)
#            (= (expmod a n n) a))
#          (try-it (+ 1 (random (- n 1)))))
#      < src..
     ..src > scheme
       (define (fermat-test n)
         (define (try-it a)
           (= (expmod a n n) a))
         (try-it (+ 1 (random (- n 1)))))
     < src..

#      The following procedure runs the test a given number of times, as specified by
#      a parameter. Its value is true if the test succeeds every time, and false
#      otherwise.
     El siguiente procedimiento ejecuta la prueba un número dado de veces, según
     lo especificado por el parámetro. Su valor es verdadero si la prueba tiene
     éxito cada vez, y falso en caso contrario.

#      ..src > scheme
#        (define (fast-prime? n times)
#          (cond ((= times 0) true)
#                ((fermat-test n)
#                 (fast-prime? n (- times 1)))
#                (else false)))
#      < src..
     ..src > scheme
       (define (fast-prime? n times)
         (cond ((= times 0) true)
               ((fermat-test n)
                (fast-prime? n (- times 1)))
               (else false)))
     < src..

# **** Probabilistic methods
**** Métodos probabilísticos

#      The Fermat test differs in character from most familiar algorithms, in which
#      one computes an answer that is guaranteed to be correct. Here, the answer
#      obtained is only probably correct. More precisely, if @m(n) ever fails the
#      Fermat test, we can be certain that @m(n) is not prime. But the fact that
#      @m(n) passes the test, while an extremely strong indication, is still not a
#      guarantee that @m(n) is prime. What we would like to say is that for any
#      number @m(n), if we perform the test enough times and find that @m(n) always
#      passes the test, then the probability of error in our primality test can be
#      made as small as we like.
     La prueba de Fermat difiere en carácter de los algoritmos más familiares,
     en los que se calcula una respuesta que se garantiza que es correcta. Aquí,
     la respuesta obtenida es probablemente sólo correcta. Más precisamente, si
     @m(n) falla alguna vez la prueba de Fermat, podemos estar seguros de que
     @m(n) no es primo. Pero el hecho de que @m(n) pase la prueba, si bien es
     una indicación extremadamente fuerte, todavía no es una garantía de que
     @m(n) es primo. Lo que queremos decir es que para cualquier número @m(n),
     si realizamos la prueba bastantes veces y encontramos que @m(n) pasa
     siempre la prueba, entonces la probabilidad de error en nuestra prueba de
     primalidad puede hacerse tan pequeña como quisiéramos.

#      Unfortunately, this assertion is not quite correct. There do exist numbers
#      that fool the Fermat test: numbers @m(n) that are not prime and yet have the
#      property that @m(aⁿ) is congruent to @m(a) modulo @m(n) for all integers @m(a
#      < n). Such numbers are extremely rare, so the Fermat test is quite reliable in
#      practice.@n(47)
     Lamentablemente, esta afirmación no es del todo correcta. Existen números
     que engañan la prueba de Fermat: números @m(n) que no son primos y que
     tienen la propiedad de que @m(aⁿ) es congruente a @m(a) módulo @m(n) para
     todos los enteros @m(a < n). Estos números son extremadamente raros, por lo
     que la prueba de Fermat es bastante fiable en la práctica.@n(47)

#      There are variations of the Fermat test that cannot be fooled. In these tests,
#      as with the Fermat method, one tests the primality of an integer @m(n) by
#      choosing a random integer @m(a < n) and checking some condition that depends
#      upon @m(n) and @m(a). (See @l(#Exercise 1.28) for an example of such a test.)
#      On the other hand, in contrast to the Fermat test, one can prove that, for any
#      @m(n), the condition does not hold for most of the integers @m(a < n) unless
#      @m(n) is prime. Thus, if @m(n) passes the test for some random choice of
#      @m(a), the chances are better than even that @m(n) is prime. If @m(n) passes
#      the test for two random choices of @m(a), the chances are better than 3 out of
#      4 that @m(n) is prime. By running the test with more and more randomly chosen
#      values of @m(a) we can make the probability of error as small as we like.
     Hay variaciones de la prueba de Fermat que no pueden ser engañadas. En
     estas pruebas, como con el método de Fermat, se somete a prueba la
     primalidad de un número entero @m(n) por elegir un entero aleatorio @m(a <
     n) comprobando alguna condición que depende de @m(n) y @m(a). (Vea el
     @l(#Ejercicio 1.28) para un ejemplo de dicha prueba.) Por otro lado, en
     contraste con la prueba de Fermat, se puede demostrar que, para cualquier
     @m(n), la condición no se cumple para la mayoría de los enteros @m(a < n) a
     menos que @m(n) sea primo. Por lo tanto, si @m(n) pasa la prueba para
     alguna elección aleatoria de @m(a), las posibilidades son mejores incluso
     que @m(n) es primo.Si @m(n) pasa la prueba para dos opciones aleatorias de
     @m(a), las posibilidades son mejores que 3 de 4 que @m(n) es primo. Al
     ejecutar la prueba con valores cada vez más aleatorios de @m(a), podemos
     hacer que la probabilidad de error sea tan pequeña como queramos.

#      The existence of tests for which one can prove that the chance of error
#      becomes arbitrarily small has sparked interest in algorithms of this type,
#      which have come to be known as @e(probabilistic algorithms). There is a great
#      deal of research activity in this area, and probabilistic algorithms have been
#      fruitfully applied to many fields.@n(48)
     La existencia de pruebas para las cuales se puede probar que la
     probabilidad de que el error se haga arbitrariamente pequeño ha despertado
     interés en algoritmos de este tipo, que han llegado a ser conocidos como
     @e(algoritmos probabilísticos). Hay una gran cantidad de investigación en
     esta área, y los algoritmos probabilísticos se han aplicado con éxito en
     muchos campos.@n(48)

#      :: @t(Exercise 1.21) :: Use the @c(smallest-divisor) procedure to find the
#         smallest divisor of each of the following numbers: 199, 1999, 19999.
     :: @t(Ejercicio 1.21) :: Utilice el procedimiento @c(smallest-divisor) para
        encontrar el divisor más pequeño de cada uno de los siguientes números:
        199, 1999, 19999.

#      :: @t(Exercise 1.22) :: Most Lisp implementations include a primitive called
#         @c(runtime) that returns an integer that specifies the amount of time the
#         system has been running (measured, for example, in microseconds). The
#         following @c(timed-prime-test) procedure, when called with an integer
#         @m(n), prints @m(n) and checks to see if @m(n) is prime. If @m(n) is prime,
#         the procedure prints three asterisks followed by the amount of time used in
#         performing the test.
     :: @t(Ejercicio 1.22) :: La mayoría de las implementaciones Lisp incluyen
        una primitiva llamada @c(runtime) que devuelve un entero que especifica
        la cantidad de tiempo que el sistema se ha estado ejecutando (medido,
        por ejemplo, en microsegundos). El siguiente procedimiento
        @c(timed-prime-test), cuando se llama con un número entero @m(n),
        imprime @m(n) y comprueba si @m(n) es primo. Si @m(n) es primo, el
        procedimiento imprime tres asteriscos seguido de la cantidad de tiempo
        utilizado en la realización de la prueba.

#         ..src > scheme
#           (define (timed-prime-test n)
#             (newline)
#             (display n)
#             (start-prime-test n (runtime)))
#
#           (define (start-prime-test n start-time)
#             (if (prime? n)
#                 (report-prime (- (runtime)
#                                  start-time))))
#
#           (define (report-prime elapsed-time)
#             (display " *** ")
#             (display elapsed-time))
#         < src..
        ..src > scheme
          (define (timed-prime-test n)
            (newline)
            (display n)
            (start-prime-test n (runtime)))

          (define (start-prime-test n start-time)
            (if (prime? n)
                (report-prime (- (runtime)
                                 start-time))))

          (define (report-prime elapsed-time)
            (display " *** ")
            (display elapsed-time))
        < src..

#         Using this procedure, write a procedure @c(search-for-primes) that checks
#         the primality of consecutive odd integers in a specified range. Use your
#         procedure to find the three smallest primes larger than 1000; larger than
#         10,000; larger than 100,000; larger than 1,000,000. Note the time needed to
#         test each prime. Since the testing algorithm has order of growth of
#         @m[Θ(√n)], you should expect that testing for primes around 10,000 should
#         take about @m(√10) times as long as testing for primes around 1000. Do your
#         timing data bear this out?  How well do the data for 100,000 and 1,000,000
#         support the @m[Θ(√n)] prediction?  Is your result compatible with the
#         notion that programs on your machine run in time proportional to the number
#         of steps required for the computation?
        Utilizando este procedimiento, escriba un procedimiento
        @c(search-for-primes) que compruebe la primalidad de números enteros
        impares consecutivos en un rango especificado. Utilice su procedimiento
        para encontrar los tres primos más grandes menores que 1000; mayores de
        10.000; mayores de 100.000; mayores de 1.000.000. Anote el tiempo
        necesario para probar cada primo. Dado que el algoritmo de prueba tiene
        un orden de crecimiento de @m(Θ (√n)), debe esperar que la prueba de
        primos alrededor de 10.000 debe tomar alrededor de @m(√10) veces el
        tiempo que la prueba de primos alrededor de 1000. ¿Sus datos de tiempo
        soportan esto? ¿Qué tan bien los datos de 100.000 y 1.000.000 apoyan la
        predicción @m[Θ(√n)]? ¿Es su resultado compatible con la noción de que
        los programas en su máquina funcionan en el tiempo proporcional al
        número de pasos requeridos para el cálculo?

#      :: @t(Exercise 1.23) :: The @c(smallest-divisor) procedure shown at the start
#         of this section does lots of needless testing: After it checks to see if
#         the number is divisible by 2 there is no point in checking to see if it is
#         divisible by any larger even numbers. This suggests that the values used
#         for @c(test-divisor) should not be 2, 3, 4, 5, 6, …, but rather 2, 3, 5, 7,
#         9, …. To implement this change, define a procedure @c(next) that returns 3
#         if its input is equal to 2 and otherwise returns its input plus 2. Modify
#         the @c(smallest-divisor) procedure to use @c[(next test-divisor)] instead
#         of @c[(+ test-divisor 1)]. With @c(timed-prime-test) incorporating this
#         modified version of @c(smallest-divisor), run the test for each of the 12
#         primes found in @l(#Exercise 1.22). Since this modification halves the
#         number of test steps, you should expect it to run about twice as fast. Is
#         this expectation confirmed?  If not, what is the observed ratio of the
#         speeds of the two algorithms, and how do you explain the fact that it is
#         different from 2?
     :: @t(Ejercicio 1.23) :: El procedimiento @c(smallest-divisor) que se
        muestra al comienzo de esta sección hace un montón de pruebas
        innecesarias: Después de comprobar si el número es divisible por 2 no
        hay ningún punto en la comprobación para ver si es divisible por
        cualquier número par más grande. Esto sugiere que los valores utilizados
        @c(test-divisor) no deben ser 2, 3, 4, 5, 6, ..., sino más bien 2, 3, 5,
        7, 9, .... Para implementar este cambio, defina un procedimiento
        @c(next) que devuelve 3 si su entrada es igual a 2 y, de lo contrario,
        devuelve su entrada más 2. Modifique el procedimiento
        @c(smallest-divisor) a utilizar en @c[(next test-divisor)] en lugar de
        @c[(+ test-divisor 1)]. Con la @c(timed-prime-test) incorporación de
        esta versión modificada de @c(smallest-divisor), ejecute la prueba para
        cada uno de los 12 primos encontrados en el @l(#Ejercicio 1.22). Ya que
        esta modificación reduce a la mitad el número de pasos de la prueba,
        debería esperar que se ejecute aproximadamente el doble de rápido. ¿Se
        confirma esta expectativa? Si no, ¿cuál es la relación observada de las
        velocidades de los dos algoritmos, y cómo se explica el hecho de que es
        diferente de 2?

#      :: @t(Exercise 1.24) :: Modify the @c(timed-prime-test) procedure of
#         @l(#Exercise 1.22) to use @c(fast-prime?) (the Fermat method), and test
#         each of the 12 primes you found in that exercise. Since the Fermat test has
#         @m[Θ(log n)] growth, how would you expect the time to test primes near
#         1,000,000 to compare with the time needed to test primes near 1000?  Do
#         your data bear this out?  Can you explain any discrepancy you find?
     :: @t(Ejercicio 1.24) :: Modifique el procedimiento @c(timed-prime-test)
        del @l(#Ejercicio 1.22) para usar @c(fast-prime?) (el método de Fermat)
        y pruebe cada uno de los 12 primos que encontró en ese ejercicio. Dado
        que la prueba de Fermat tiene crecimiento @m[Θ(log n)], ¿cuanto tiempo
        esperaría para probar primos cerca de 1.000.000 comparado con el tiempo
        necesario para probar primos cerca de 1000? ¿Sus datos confirman esto?
        ¿Puedes explicar cualquier discrepancia que encuentres?

#      :: @t(Exercise 1.25) :: Alyssa P. Hacker complains that we went to a lot of
#         extra work in writing @c(expmod). After all, she says, since we already
#         know how to compute exponentials, we could have simply written
     :: @t(Ejercicio 1.25) :: Alyssa P. Hacker se queja de que tubimos un montón
        de trabajo extra por escribir @c(expmod). Después de todo, ella dice,
        que ya que sabemos cómo calcular exponenciales, podríamos haber escrito
        simplemente

#         ..src > scheme
#           (define (expmod base exp m)
#             (remainder (fast-expt base exp) m))
#         < src..
        ..src > scheme
          (define (expmod base exp m)
            (remainder (fast-expt base exp) m))
        < src..

#         Is she correct?  Would this procedure serve as well for our fast prime
#         tester? Explain.
        ¿Es correcto? ¿Funcionaría este procedimiento también para nuestra
        prueba de primos rapida? Explique.

#      :: @t(Exercise 1.26) :: Louis Reasoner is having great difficulty doing
#         @l(#Exercise 1.24). His @c(fast-prime?) test seems to run more slowly than
#         his @c(prime?) test. Louis calls his friend Eva Lu Ator over to help. When
#         they examine Louis's code, they find that he has rewritten the @c(expmod)
#         procedure to use an explicit multiplication, rather than calling
#         @c(square):
     :: @t(Ejercicio 1.26) :: Louis Reasoner está teniendo grandes dificultades
        para hacer el @l(#Ejercicio 1.24). Su prueba @c(fast-prime?) parece
        correr más lentamente que su prueba @c(prime?). Louis llama a su amiga
        Eva Lu Ator para ayudar. Cuando examinan el código de Louis, encuentran
        que ha reescrito el procedimiento @c(expmod) para utilizar una
        multiplicación explícita, en lugar de llamar @c(square):

#         ..src > scheme
#           (define (expmod base exp m)
#             (cond ((= exp 0) 1)
#                   ((even? exp)
#                    (remainder
#                     (* (expmod base (/ exp 2) m)
#                        (expmod base (/ exp 2) m))
#                     m))
#                   (else
#                    (remainder
#                     (* base
#                        (expmod base (- exp 1) m))
#                     m))))
#         < src..
        ..src > scheme
          (define (expmod base exp m)
            (cond ((= exp 0) 1)
                  ((even? exp)
                   (remainder
                    (* (expmod base (/ exp 2) m)
                       (expmod base (/ exp 2) m))
                    m))
                  (else
                   (remainder
                    (* base
                       (expmod base (- exp 1) m))
                    m))))
        < src..

#         @"(I don't see what difference that could make,) says Louis. @"(I do.)
#         says Eva. @"{By writing the procedure like that, you have transformed the
#         @m[Θ(log n)] process into a @m[Θ(n)] process.}  Explain.
        @"(No veo qué diferencia podría hacer), dice Louis. @"(Yo si). Dice
        Eva. @"(Al escribir el procedimiento de este modo, ha transformado el
        proceso @m[Θ(log n)] en un proceso @m[Θ(n)].) Explique.

#      :: @t(Exercise 1.27) :: Demonstrate that the Carmichael numbers listed in
#        @n(47<>Footnote 47) really do fool the Fermat test. That is, write a
#         procedure that takes an integer @m(n) and tests whether @m(aⁿ) is congruent
#         to @m(a) modulo @m(n) for every @m(a < n), and try your procedure on the
#         given Carmichael numbers.
     :: @t(Ejercicio 1.27) :: Demuestre que los números de Carmichael enumerados
        en la @n(47<>Nota 47) realmente engañan a la prueba de Fermat. Es decir,
        escriba un procedimiento que toma un entero @m(n) y prueba si @m(aⁿ) es
        congruente a @m(a) módulo @m(n) para cada @m(a < n), e intenta tu
        procedimiento en los números de Carmichael dados.

#      :: @t(Exercise 1.28) :: One variant of the Fermat test that cannot be fooled
#         is called the @e(Miller-Rabin test) (@l(#Miller 1976); @l(#Rabin
#         1980)). This starts from an alternate form of Fermat's Little Theorem,
#         which states that if @m(n) is a prime number and @m(a) is any positive
#         integer less than @m(n), then @m(a) raised to the @m[(n-1)]-st power is
#         congruent to 1 modulo @m(n). To test the primality of a number @m(n) by the
#         Miller-Rabin test, we pick a random number @m(a < n) and raise @m(a) to the
#         @m[(n-1)]-st power modulo @m(n) using the @c(expmod) procedure. However,
#         whenever we perform the squaring step in @c(expmod), we check to see if we
#         have discovered a @"(nontrivial square root of 1 modulo @m(n),) that is, a
#         number not equal to 1 or @m(n-1) whose square is equal to 1 modulo
#         @m(n). It is possible to prove that if such a nontrivial square root of 1
#         exists, then @m(n) is not prime. It is also possible to prove that if @m(n)
#         is an odd number that is not prime, then, for at least half the numbers
#         @m(a < n), computing @m(aⁿ⁻¹) in this way will reveal a nontrivial square
#         root of 1 modulo @m(n). (This is why the Miller-Rabin test cannot be
#         fooled.)  Modify the @c(expmod) procedure to signal if it discovers a
#         nontrivial square root of 1, and use this to implement the Miller-Rabin
#         test with a procedure analogous to @c(fermat-test). Check your procedure by
#         testing various known primes and non-primes. Hint: One convenient way to
#         make @c(expmod) signal is to have it return 0.
     :: @t(Ejercicio 1.28) :: Una variante de la prueba de Fermat que no puede
        ser engañada se denomina @e(prueba de Miller-Rabin) (@l(#Miller 1976),
        @l(#Rabin 1980)). Esto comienza a partir de una forma alternativa del
        Pequeño Teorema de Fermat, que establece que si @m(n) es un número primo
        y @m(a) es cualquier entero positivo menor que @m(n), entonces @m(a)
        elevado a la enesima potencia @m[(n-1)] es congruente a 1 módulo @m(n).
        Para probar la primalidad de un número @m(n) por el ensayo de
        Miller-Rabin, escogemos un número aleatorio @m(a < n) y levamos @m(a) a
        la potencia @m[(n-1)] modulo @m(n) usando el procedimiento @c(expmod).
        Sin embargo, Cada vez que realizamos el paso de cuadratura @c(expmod),
        verificamos si hemos descubierto una @"(raíz cuadrada no trivial de 1
        módulo @m(n)), es decir, un número no igual a 1 o @m(n-1) cuyo cuadrado
        es igual a 1 módulo @m(n). Es posible probar que si una raíz cuadrada no
        trivial de 1 existe, entonces @m(n) no es primo. También es posible
        probar que si @m(n) es un número impar que no es primo, entonces, para
        al menos la mitad de los números @m(a < n), calcular @m(aⁿ⁻¹) de esta
        manera revelará una raíz cuadrada no trivial de 1 módulo @m(n). (Esta es
        la razón por la prueba Miller-Rabin no puede ser engañado.) Modifique el
        procedimiento @c(expmod) para señalar si descubre una raíz cuadrada no
        trivial de 1, y usar esto para implementar la prueba de Miller-Rabin con
        un procedimiento análogo a @c(fermat-test). Revise su procedimiento
        probando varios primos conocidos y no primos. Sugerencia: Una manera
        conveniente de hacer la señal @c(expmod) es tenerla regresando 0.

# ** 1.3 <> Formulating Abstractions with Higher-Order Procedures
** 1.3 <> Formulación de abstracciones con procedimientos de orden superior

#    We have seen that procedures are, in effect, abstractions that describe
#    compound operations on numbers independent of the particular numbers. For
#    example, when we
   Hemos visto que los procedimientos son, en efecto, abstracciones que
   describen operaciones compuestas sobre números independientes de los números
   particulares. Por ejemplo, con

#    ..src > scheme
#      (define (cube x) (* x x x))
#    < src..
   ..src > scheme
     (define (cube x) (* x x x))
   < src..

#    we are not talking about the cube of a particular number, but rather about a
#    method for obtaining the cube of any number. Of course we could get along
#    without ever defining this procedure, by always writing expressions such as
   no estamos hablando del cubo de un número particular, sino más bien de un
   método para obtener el cubo de cualquier número. Por supuesto, podríamos
   seguir adelante sin definir este procedimiento, siempre escribiendo
   expresiones como

#    ..src > scheme
#      (* 3 3 3)
#      (* x x x)
#      (* y y y)
#    < src..
   ..src > scheme
     (* 3 3 3)
     (* x x x)
     (* y y y)
   < src..

#    and never mentioning @c(cube) explicitly. This would place us at a serious
#    disadvantage, forcing us to work always at the level of the particular
#    operations that happen to be primitives in the language (multiplication, in
#    this case) rather than in terms of higher-level operations. Our programs would
#    be able to compute cubes, but our language would lack the ability to express
#    the concept of cubing. One of the things we should demand from a powerful
#    programming language is the ability to build abstractions by assigning names
#    to common patterns and then to work in terms of the abstractions directly.
#    Procedures provide this ability. This is why all but the most primitive
#    programming languages include mechanisms for defining procedures.
   Y nunca mencionar @c(cube) explícitamente. Esto nos pondría en grave
   desventaja, obligándonos a trabajar siempre al nivel de las operaciones
   particulares que pasan a ser primitivas en el lenguaje (multiplicación, en
   este caso) más que en términos de operaciones de nivel superior. Nuestros
   programas serían capaces de calcular cubos, pero nuestro lenguaje carecería
   de la capacidad de expresar el concepto de cubicación. Una de las cosas que
   debemos exigir de un potente lenguaje de programación es la capacidad de
   construir abstracciones asignando nombres a patrones comunes y luego trabajar
   en términos de las abstracciones directamente. Los procedimientos
   proporcionan esta habilidad. Es por eso que todos los lenguajes de
   programación, excepto los más primitivos, incluyen mecanismos para definir
   procedimientos.

#    Yet even in numerical processing we will be severely limited in our ability to
#    create abstractions if we are restricted to procedures whose parameters must
#    be numbers. Often the same programming pattern will be used with a number of
#    different procedures. To express such patterns as concepts, we will need to
#    construct procedures that can accept procedures as arguments or return
#    procedures as values. Procedures that manipulate procedures are called
#    @e(higher-order procedures). This section shows how higher-order procedures
#    can serve as powerful abstraction mechanisms, vastly increasing the expressive
#    power of our language.
   Sin embargo, incluso en el procesamiento numérico estaremos gravemente
   limitados en nuestra capacidad de crear abstracciones si estamos restringidos
   a procedimientos cuyos parámetros deben ser números. A menudo, el mismo
   patrón de programación se utilizará con una serie de procedimientos
   diferentes. Para expresar tales patrones como conceptos, necesitaremos
   construir procedimientos que puedan aceptar procedimientos como argumentos o
   procedimientos devueltos como valores. Los procedimientos que manipulan
   procedimientos se llaman @e(procedimientos de orden superior). Esta sección
   muestra cómo los procedimientos de orden superior pueden servir como
   poderosos mecanismos de abstracción, aumentando enormemente el poder
   expresivo de nuestro lenguaje.

# *** 1.3.1 <> Procedures as Arguments
*** 1.3.1 <> Procedimientos como Argumentos

#     Consider the following three procedures. The first computes the sum of the
#     integers from @c(a) through @c(b):
    Considere los siguientes tres procedimientos. El primero calcula la suma de
    los enteros desde a @c(a) hasta @c(b):

#     ..src > scheme
#       (define (sum-integers a b)
#         (if (> a b)
#             0
#             (+ a (sum-integers (+ a 1) b))))
#     < src..
    ..src > scheme
      (define (sum-integers a b)
        (if (> a b)
            0
            (+ a (sum-integers (+ a 1) b))))
    < src..

#     The second computes the sum of the cubes of the integers in the given range:
    El segundo calcula la suma de los cubos de los enteros en el rango dado:

#     ..src > scheme
#       (define (sum-cubes a b)
#         (if (> a b)
#             0
#             (+ (cube a)
#                (sum-cubes (+ a 1) b))))
#     < src..
    ..src > scheme
      (define (sum-cubes a b)
        (if (> a b)
            0
            (+ (cube a)
               (sum-cubes (+ a 1) b))))
    < src..

#     The third computes the sum of a sequence of terms in the series
    El tercero calcula la suma de una secuencia de términos en la serie

#     ..example >
#         1       1       1
#       ––––– + ––––– + ––––– + ...
#       1 ⋅ 3   5 ⋅ 7   9 ⋅ 11
#     < example..
    ..example >
        1       1       1
      ––––– + ––––– + ––––– + ...
      1 ⋅ 3   5 ⋅ 7   9 ⋅ 11
    < example..

#     which converges to @m[π/8] (very slowly):@n(49)
    Que converge a @m(π/8) (muy lentamente):@n(49)

#     ..src > scheme
#       (define (pi-sum a b)
#         (if (> a b)
#             0
#             (+ (/ 1.0 (* a (+ a 2)))
#                (pi-sum (+ a 4) b))))
#     < src..
    ..src > scheme
      (define (pi-sum a b)
        (if (> a b)
            0
            (+ (/ 1.0 (* a (+ a 2)))
               (pi-sum (+ a 4) b))))
    < src..

#     These three procedures clearly share a common underlying pattern. They are for
#     the most part identical, differing only in the name of the procedure, the
#     function of @c(a) used to compute the term to be added, and the function
#     that provides the next value of @c(a). We could generate each of the
#     procedures by filling in slots in the same template:
    Estos tres procedimientos claramente comparten un patrón subyacente
    común. Son en su mayor parte idénticos, difiriendo sólo en el nombre del
    procedimiento, la función utiliza @c(a) para calcular el término a sumar, y
    proporciona el siguiente valor de @c(a). Podríamos generar cada uno de los
    procedimientos rellenando espacios en la misma plantilla:

#     ..src > scheme
#       (define (⟨name⟩ a b)
#         (if (> a b)
#             0
#             (+ (⟨term⟩ a)
#                (⟨name⟩ (⟨next⟩ a) b))))
#     < src..
    ..src > scheme
      (define (⟨nombre⟩ a b)
        (if (> a b)
            0
            (+ (⟨termino⟩ a)
               (⟨nombre⟩ (⟨siguiente⟩ a) b))))
    < src..

#     The presence of such a common pattern is strong evidence that there is a
#     useful abstraction waiting to be brought to the surface. Indeed,
#     mathematicians long ago identified the abstraction of @e(summation of a
#     series) and invented @"(sigma notation,) for example
    La presencia de un patrón tan común es una fuerte evidencia de que hay una
    abstracción útil esperando ser traída a la superficie. De hecho, los
    matemáticos hace tiempo identificaron la abstracción de la @e(suma de una
    serie) e inventaron la @"(notación sigma), por ejemplo

#     ..example >
#        b
#        ∑ ƒ(n) = ƒ(a) + ⋯ + ƒ(b)
#       n=a
#     < example..
    ..example >
       b
       ∑ ƒ(n) = ƒ(a) + ⋯ + ƒ(b)
      n=a
    < example..

#     to express this concept. The power of sigma notation is that it allows
#     mathematicians to deal with the concept of summation itself rather than only
#     with particular sums––for example, to formulate general results about sums
#     that are independent of the particular series being summed.
    Para expresar este concepto. El poder de la notación sigma es que permite a
    los matemáticos lidiar con el concepto de sumatoria en lugar de sólo con
    sumas particulares, por ejemplo para formular resultados generales sobre
    sumas independientes de la serie particular que se suma.

#     Similarly, as program designers, we would like our language to be powerful
#     enough so that we can write a procedure that expresses the concept of
#     summation itself rather than only procedures that compute particular sums. We
#     can do so readily in our procedural language by taking the common template
#     shown above and transforming the @"(slots) into formal parameters:
    Del mismo modo, como diseñadores de programas, queremos que nuestro lenguaje
    sea lo suficientemente poderoso para que podamos escribir un procedimiento
    que exprese el concepto de sumatoria en lugar de sólo los procedimientos que
    calculan sumas particulares. Podemos hacerlo fácilmente en nuestro lenguaje
    procedimental tomando la plantilla común mostrada arriba y transformando las
    @"(ranuras) en parámetros formales:

#     ..src > scheme
#       (define (sum term a next b)
#         (if (> a b)
#             0
#             (+ (term a)
#                (sum term (next a) next b))))
#     < src..
    ..src > scheme
      (define (sum term a next b)
        (if (> a b)
            0
            (+ (term a)
               (sum term (next a) next b))))
    < src..

#     Notice that @c(sum) takes as its arguments the lower and upper bounds @c(a)
#     and @c(b) together with the procedures @c(term) and @c(next).  We can use
#     @c(sum) just as we would any procedure. For example, we can use it (along with
#     a procedure @c(inc) that increments its argument by 1) to define
#     @c(sum-cubes):
    Observe que @c(sum) toma como argumentos los límites inferior y superior
    @c(a) y @c(b) junto con los procedimientos @c(term) y @c(next). Podemos
    utilizar @c(sum) como haríamos con cualquier procedimiento. Por ejemplo,
    podemos usarlo (junto con un procedimiento @c(inc) que incrementa su
    argumento por 1) para definir @c(sum-cubes):

#     ..src > scheme
#       (define (inc n) (+ n 1))
#
#       (define (sum-cubes a b)
#         (sum cube a inc b))
#     < src..
    ..src > scheme
      (define (inc n) (+ n 1))

      (define (sum-cubes a b)
        (sum cube a inc b))
    < src..

#     Using this, we can compute the sum of the cubes of the integers from 1 to 10:
    Utilizando esto, podemos calcular la suma de los cubos de los enteros de 1 a
    10:

#     ..srci > scheme
#       > (sum-cubes 1 10)
#       3025
#     < srci..
    ..srci > scheme
      > (sum-cubes 1 10)
      3025
    < srci..

#     With the aid of an identity procedure to compute the term, we can define
#     @c(sum-integers) in terms of @c(sum):
    Con la ayuda de un procedimiento de identidad para calcular el término,
    podemos definir @c(sum-integers) en términos de @c(sum):

#     ..src > scheme
#       (define (identity x) x)
#
#       (define (sum-integers a b)
#         (sum identity a inc b))
#     < src..
    ..src > scheme
      (define (identity x) x)

      (define (sum-integers a b)
        (sum identity a inc b))
    < src..

#     Then we can add up the integers from 1 to 10:
    Entonces podemos sumar los enteros de 1 a 10:

#     ..srci > scheme
#       > (sum-integers 1 10)
#       55
#     < srci..
    ..srci > scheme
      > (sum-integers 1 10)
      55
    < srci..

#     We can also define @c(pi-sum) in the same way:@n(50)
    También podemos definir @c(pi-sum) de la misma manera:@n(50)

#     ..src > scheme
#       (define (pi-sum a b)
#         (define (pi-term x)
#           (/ 1.0 (* x (+ x 2))))
#         (define (pi-next x)
#           (+ x 4))
#         (sum pi-term a pi-next b))
#     < src..
    ..src > scheme
      (define (pi-sum a b)
        (define (pi-term x)
          (/ 1.0 (* x (+ x 2))))
        (define (pi-next x)
          (+ x 4))
        (sum pi-term a pi-next b))
    < src..

#     Using these procedures, we can compute an approximation to @m(π):
    Usando estos procedimientos, podemos calcular una aproximación a @m(π) :

#     ..srci > scheme
#       > (* 8 (pi-sum 1 1000))
#       3.139592655589783
#     < srci..
    ..srci > scheme
      > (* 8 (pi-sum 1 1000))
      3.139592655589783
    < srci..

#     Once we have @c(sum), we can use it as a building block in formulating further
#     concepts. For instance, the definite integral of a function @m(ƒ) between the
#     limits @m(a) and @m(b) can be approximated numerically using the formula
    Una vez que tenemos @c(sum), podemos usarlo como un elemento fundamental en
    la formulación de otros conceptos. Por ejemplo, la integral definida de una
    función @m(ƒ) entre los límites @m(a) y @m(b) puede aproximarse
    numéricamente usando la fórmula

#     ..example >
#              ┌                                                          ┐
#       ╭ᵇ     │  ╭     dx ╮    ╭          dx ╮    ╭           dx ╮       │
#       │  ƒ = │ ƒ│ a + –– │ + ƒ│ a + dx + –– │ + ƒ│ a + 2dx + –– │ + ... │ dx
#       ╯ᵃ     │  ╰     2  ╯    ╰          2  ╯    ╰           2  ╯       │
#              └                                                          ┘
#     < example..
    ..example >
             ┌                                                          ┐
      ╭ᵇ     │  ╭     dx ╮    ╭          dx ╮    ╭           dx ╮       │
      │  ƒ = │ ƒ│ a + –– │ + ƒ│ a + dx + –– │ + ƒ│ a + 2dx + –– │ + ... │ dx
      ╯ᵃ     │  ╰     2  ╯    ╰          2  ╯    ╰           2  ╯       │
             └                                                          ┘
    < example..

#     for small values of @m(dx). We can express this directly as a procedure:
    Para valores pequeños de @m(dx). Podemos expresarlo directamente como un
    procedimiento:

#     ..srci > scheme
#       > (define (integral f a b dx)
#       ^   (define (add-dx x) (+ x dx))
#       ^   (* (sum f (+ a (/ dx 2.0)) add-dx b)
#       ^      dx))
#       > (integral cube 0 1 0.01)
#       .24998750000000042
#       > (integral cube 0 1 0.001)
#       .249999875000001
#     < srci..
    ..srci > scheme
      > (define (integral f a b dx)
      ^   (define (add-dx x) (+ x dx))
      ^   (* (sum f (+ a (/ dx 2.0)) add-dx b)
      ^      dx))
      > (integral cube 0 1 0.01)
      .24998750000000042
      > (integral cube 0 1 0.001)
      .249999875000001
    < srci..

#     (The exact value of the integral of @c(cube) between 0 and 1 is 1/4.)
    (El valor exacto de la integral @c(cube) entre 0 y 1 es 1/4).

#     :: @t(Exercise 1.29) :: Simpson's Rule is a more accurate method of numerical
#        integration than the method illustrated above. Using Simpson's Rule, the
#        integral of a function @m(ƒ) between @m(a) and @m(b) is approximated as
    :: @t(Ejercicio 1.29) :: La Regla de Simpson es un método más preciso de
       integración numérica que el método ilustrado anteriormente. Usando la
       Regla de Simpson, la integral de una función @m(ƒ) entre @m(a) y @m(b) se
       aproxima como

#        ..example >
#          h ┌                                                     ┐
#          – │y₀ + 4y₁ + 2y₂ + 4y₃ + 2y₄ + ... + 2yₙ₋₂ + 4yₙ₋₁ + yₙ│
#          3 └                                                     ┘
#        < example..
       ..example >
         h ┌                                                     ┐
         – │y₀ + 4y₁ + 2y₂ + 4y₃ + 2y₄ + ... + 2yₙ₋₂ + 4yₙ₋₁ + yₙ│
         3 └                                                     ┘
       < example..

#        where @m[h = (b - a)/n], for some even integer @m(n), and @m[yₙ = ƒ(a +
#        kh)]. (Increasing @m(n) increases the accuracy of the approximation.)
#        Define a procedure that takes as arguments @m(ƒ), @m(a), @m(b), and @m(n)
#        and returns the value of the integral, computed using Simpson's Rule. Use
#        your procedure to integrate @c(cube) between 0 and 1 (with @m(n = 100) and
#        @m(n = 1000), and compare the results to those of the @c(integral)
#        procedure shown above.
       donde @m[h = (b - a)/n], para algunos enteros par @m(n), y @m[yₙ = ƒ(a +
       kh)]. (Incrementando @m(n) aumenta la precisión de la aproximación.)
       Definir un procedimiento que tome como argumentos @m(ƒ), @m(a), @m(b), y
       @m(n) y devuelve el valor de la integral, utilizando la regla de
       Simpson. Utilice su procedimiento para integrar @c(cube) entre 0 y 1 (con
       @m(n = 100) y @m(n = 1000), y compare los resultados con los del
       procedimiento @c(integral) mostrado arriba.

#     :: @t(Exercise 1.30) :: The @c(sum) procedure above generates a linear
#        recursion. The procedure can be rewritten so that the sum is performed
#        iteratively. Show how to do this by filling in the missing expressions in
#        the following definition:
    :: @t(Ejercicio 1.30) :: El procedimiento @c(sum) anterior genera una
       recursión lineal. El procedimiento puede ser reescrito para que la suma
       se realice de forma iterativa. Muestre cómo hacer esto rellenando las
       expresiones que faltan en la siguiente definición:

#        ..src > scheme
#          (define (sum term a next b)
#            (define (iter a result)
#              (if ⟨??⟩
#                  ⟨??⟩
#                  (iter ⟨??⟩ ⟨??⟩)))
#            (iter ⟨??⟩ ⟨??⟩))
#        < src..
       ..src > scheme
         (define (sum term a next b)
           (define (iter a result)
             (if ⟨??⟩
                 ⟨??⟩
                 (iter ⟨??⟩ ⟨??⟩)))
           (iter ⟨??⟩ ⟨??⟩))
       < src..

#     :: @t(Exercise 1.31) ::
    :: @t(Ejercicio 1.31) ::

#        - The @c(sum) procedure is only the simplest of a vast number of similar
#          abstractions that can be captured as higher-order procedures.@n(51) Write
#          an analogous procedure called @c(product) that returns the product of the
#          values of a function at points over a given range. Show how to define
#          @c(factorial) in terms of @c(product). Also use @c(product) to compute
#          approximations to @m(π) using the formula@n(52)
       - El procedimiento @c(sum) es sólo el más simple de un gran número de
         abstracciones similares que pueden capturarse como procedimientos de
         orden superior.@n(51) Escriba un procedimiento análogo llamado
         @c(product) que devuelve el producto de los valores de una función en
         puntos sobre un rango dado. Mostrar cómo definir @c(factorial) en
         términos de @c(product). También se utiliza @c(product) para calcular
         aproximaciones a @m(π) usando la fórmula@n(52)

#          ..example >
#            π   2 ⋅ 4 ⋅ 4 ⋅ 6 ⋅ 6 ⋅ 8 ⋅ ⋯
#            – = –––––––––––––––––––––––––
#            4   3 ⋅ 3 ⋅ 5 ⋅ 5 ⋅ 7 ⋅ 7 ⋅ ⋯
#          < example..
         ..example >
           π   2 ⋅ 4 ⋅ 4 ⋅ 6 ⋅ 6 ⋅ 8 ⋅ ⋯
           – = –––––––––––––––––––––––––
           4   3 ⋅ 3 ⋅ 5 ⋅ 5 ⋅ 7 ⋅ 7 ⋅ ⋯
         < example..

#        - If your @c(product) procedure generates a recursive process, write one
#          that generates an iterative process. If it generates an iterative
#          process, write one that generates a recursive process.
       - Si su procedimiento @c(product) genera un proceso recursivo, escriba
         uno que genere un proceso iterativo. Si genera un proceso iterativo,
         escriba uno que genere un proceso recursivo.

#     :: @t(Exercise 1.32) ::
    :: @t(Ejercicio 1.32) ::

#        - Show that @c(sum) and @c(product) (@l(#Exercise 1.31)) are both special
#          cases of a still more general notion called @c(accumulate) that combines
#          a collection of terms, using some general accumulation function:
       - Demuestre que @c(sum) y @c(product) (@l(#Ejercicio 1.31)) son casos
         especiales de una noción aún más general llamada @c(accumulate) que
         combina una colección de términos, usando alguna función de acumulación
         general:

#          ..src > scheme
#            (accumulate
#             combiner null-value term a next b)
#          < src..
         ..src > scheme
           (accumulate
            combiner null-value term a next b)
         < src..

#          @c(Accumulate) takes as arguments the same term and range specifications
#          as @c(sum) and @c(product), together with a @c(combiner) procedure (of
#          two arguments) that specifies how the current term is to be combined with
#          the accumulation of the preceding terms and a @c(null-value) that
#          specifies what base value to use when the terms run out. Write
#          @c(accumulate) and show how @c(sum) and @c(product) can both be defined
#          as simple calls to @c(accumulate).
        @c(Accumulate) Toma como argumentos el mismo término y especificaciones
        de rango como @c(sum) y @c(product), junto con un procedimiento
        @c(combiner) (de dos argumentos) que especifica cómo se debe combinar el
        término actual con la acumulación de los términos anteriores y un
        @c(valor-null) que especifica qué valor base utilizar cuando los
        términos se agoten. Escribir @c(accumulate) y mostrar cómo @c(sum) y
        @c(product) pueden ser definidos como simples llamadas a @c(accumulate).

#        - If your @c(accumulate) procedure generates a recursive process, write one
#          that generates an iterative process. If it generates an iterative
#          process, write one that generates a recursive process.
       - Si su procedimiento @c(accumulate) genera un proceso recursivo, escriba
         uno que genere un proceso iterativo. Si genera un proceso iterativo,
         escriba uno que genere un proceso recursivo.

#     :: @t(Exercise 1.33) :: You can obtain an even more general version of
#        @c(accumulate) (@l(#Exercise 1.32)) by introducing the notion of a
#        @e(filter) on the terms to be combined. That is, combine only those terms
#        derived from values in the range that satisfy a specified condition. The
#        resulting @c(filtered-accumulate) abstraction takes the same arguments as
#        accumulate, together with an additional predicate of one argument that
#        specifies the filter. Write @c(filtered-accumulate) as a procedure.  Show
#        how to express the following using @c(filtered-accumulate):
    :: @t(Ejercicio 1.33) :: Puede obtener una versión aún más general de
       @c(accumulate) (@l(#Ejercicio 1.32)) introduciendo la noción de un
       @e(filtro) en los términos que se van a combinar. Es decir, combinar sólo
       aquellos términos derivados de valores en el intervalo que satisfacen una
       condición especificada. La abstraccion @c(filtered-accumulate) resultante
       toma los mismos argumentos que se acumulan, junto con un predicado
       adicional de un argumento que especifica el filtro. Escribir
       @c(filtered-accumulate) como un procedimiento. Muestre cómo expresar lo
       siguiente usando @c(filtered-accumulate):

#        - the sum of the squares of the prime numbers in the interval @m(a) to
#          @m(b) (assuming that you have a @c(prime?) predicate already written)
       - La suma de los cuadrados de los números primos en el intervalo @m(a) a
         @m(b) (suponiendo que usted tiene un predicado @c(prime?) ya escrito)

#        - the product of all the positive integers less than @m(n) that are
#          relatively prime to @m(n) (i.e., all positive integers @m(i < n) such
#          that @m[GCD(i, n) = 1].
       - El producto de todos los enteros positivos inferiores a @m(n) que son
         relativamente primos a @m(n) (es decir, todos los enteros positivos
         @m(i < n) tales que @m[GCD(i, n) = 1].

# *** 1.3.2 <> Constructing Procedures Using @c(Lambda)
*** 1.3.2 <> Construcción de Procedimientos usando @c(Lambda)

#     In using @c(sum) as in section @l(#1.3.1), it seems terribly awkward to have to define
#     trivial procedures such as @c(pi-term) and @c(pi-next) just so we can use them
#     as arguments to our higher-order procedure. Rather than define @c(pi-next) and
#     @c(pi-term), it would be more convenient to have a way to directly specify
#     @"(the procedure that returns its input incremented by 4) and @"(the procedure
#     that returns the reciprocal of its input times its input plus 2.)  We can do
#     this by introducing the special form @c(lambda), which creates
#     procedures. Using @c(lambda) we can describe what we want as
    Al usar @c(sum) como en la seccion @l(#1.3.1), parece terriblemente torpe
    tener que definir procedimientos triviales como @c(pi-term) y @c(pi-next)
    simplemente para utilizarlos como argumentos de nuestro procedimiento de
    orden superior. En lugar de definir @c(pi-next) y @c(pi-term), sería más
    conveniente tener una manera de especificar directamente @"(el procedimiento
    que devuelve su entrada incrementada por 4) y @"(el procedimiento que
    devuelve el recíproco de su entrada, las veces su entrada más 2.)  Podemos
    hacer esto introduciendo la forma especial @c(lambda), que crea
    procedimientos. Usando @c(lambda) podemos describir lo que queremos como

#     ..src > scheme
#       (lambda (x) (+ x 4))
#     < src..
    ..src > scheme
      (lambda (x) (+ x 4))
    < src..

#     and
    y

#     ..src > scheme
#       (lambda (x) (/ 1.0 (* x (+ x 2))))
#     < src..
    ..src > scheme
      (lambda (x) (/ 1.0 (* x (+ x 2))))
    < src..

#     Then our @c(pi-sum) procedure can be expressed without defining any auxiliary
#     procedures as
    Entonces nuestro procedimiento @c(pi-sum) puede expresarse sin definir
    procedimientos auxiliares como

#     ..src > scheme
#       (define (pi-sum a b)
#         (sum (lambda (x) (/ 1.0 (* x (+ x 2))))
#              a
#              (lambda (x) (+ x 4))
#              b))
#     < src..
    ..src > scheme
      (define (pi-sum a b)
        (sum (lambda (x) (/ 1.0 (* x (+ x 2))))
             a
             (lambda (x) (+ x 4))
             b))
    < src..

#     Again using @c(lambda), we can write the @c(integral) procedure without having
#     to define the auxiliary procedure @c(add-dx):
    Nuevamente utilizando @c(lambda), podemos escribir el procedimiento
    @c(integral) sin tener que definir el procedimiento auxiliar @c(add-dx):

#     ..src > scheme
#       (define (integral f a b dx)
#         (* (sum f (+ a (/ dx 2.0))
#                   (lambda (x) (+ x dx))
#                   b)
#            dx))
#     < src..
    ..src > scheme
      (define (integral f a b dx)
        (* (sum f (+ a (/ dx 2.0))
                  (lambda (x) (+ x dx))
                  b)
           dx))
    < src..

#     In general, @c(lambda) is used to create procedures in the same way as
#     @c(define), except that no name is specified for the procedure:
    En general, @c(lambda) se utiliza para crear procedimientos de la misma
    manera que @c(define), excepto que no se especifica ningún nombre para el
    procedimiento:

#     ..src > scheme
#       (lambda (⟨formal-parameters⟩) ⟨body⟩)
#     < src..
    ..src > scheme
      (lambda (⟨formal-parameters⟩) ⟨body⟩)
    < src..

#     The resulting procedure is just as much a procedure as one that is created
#     using @c(define). The only difference is that it has not been associated with
#     any name in the environment. In fact,
    El procedimiento resultante es justo un procedimiento como el que se crea
    utilizando @c(define). La única diferencia es que no se ha asociado con
    ningún nombre en el entorno. De hecho,

#     ..src > scheme
#       (define (plus4 x) (+ x 4))
#     < src..
    ..src > scheme
      (define (plus4 x) (+ x 4))
    < src..

#     is equivalent to
    es equivalente a

#     ..src > scheme
#       (define plus4 (lambda (x) (+ x 4)))
#     < src..
    ..src > scheme
      (define plus4 (lambda (x) (+ x 4)))
    < src..

#     We can read a @c(lambda) expression as follows:
    Podemos leer una expresión @c(lambda) como sigue:

#     ..example >
#       (lambda                     (x)     (+   x     4))
#           |                        |       |   |     |
#       the procedure of an argument x that adds x and 4
#     < example..
    ..example >
      (lambda                         (x)    (+   x   4))
          |                            |      |   |   |
      el precedimiento de un argumento x que suma x y 4
    < example..

#     Like any expression that has a procedure as its value, a @c(lambda) expression
#     can be used as the operator in a combination such as
    Como cualquier expresión que tiene un procedimiento como su valor, una
    expresión @c(lambda) se puede utilizar como el operador en una combinación
    como

#     ..srci > scheme
#       > ((lambda (x y z) (+ x y (square z))) 1 2 3)
#       12
#     < srci..
    ..srci > scheme
      > ((lambda (x y z) (+ x y (square z))) 1 2 3)
      12
    < srci..

#     or, more generally, in any context where we would normally use a procedure
#     name.@n(53)
    O, de manera más general, en cualquier contexto en el que normalmente
    utilizaríamos un nombre de procedimiento.@n(53)

# **** Using @c(let) to create local variables
**** Utilizar @c(let) para crear variables locales

#      Another use of @c(lambda) is in creating local variables. We often need
#      local variables in our procedures other than those that have been bound as
#      formal parameters. For example, suppose we wish to compute the function
     Otro uso de @c(lambda) está en la creación de variables locales. A menudo
     necesitamos variables locales en nuestros procedimientos distintos de
     aquellos que han sido obligados como parámetros formales. Por ejemplo,
     supongamos que deseamos calcular la función

#      ..example >
#        ƒ(x,y) = x(1 + xy)² + y(1 − y) + (1 + xy)(1 − y)
#      < example..
     ..example >
       ƒ(x,y) = x(1 + xy)² + y(1 − y) + (1 + xy)(1 − y)
     < example..

#      which we could also express as
     Que también podríamos expresar como

#      ..example >
#             a = 1 + xy
#             b = 1 − y
#        ƒ(x,y) = xa² + yb + ab
#      < example..
     ..example >
            a = 1 + xy
            b = 1 − y
       ƒ(x,y) = xa² + yb + ab
     < example..

#      In writing a procedure to compute @m(ƒ), we would like to include as local
#      variables not only @m(x) and @m(y) but also the names of intermediate
#      quantities like @m(a) and @m(b). One way to accomplish this is to use an
#      auxiliary procedure to bind the local variables:
     Al escribir un procedimiento para calcular @m(ƒ), nos gustaría incluir como
     variables locales no solo @m(x) e @m(y), sino también los nombres de
     cantidades intermedias como @m(a) y @m(b). Una manera de lograr esto es
     usar un procedimiento auxiliar para enlazar las variables locales:

#      ..src > scheme
#        (define (f x y)
#          (define (f-helper a b)
#            (+ (* x (square a))
#               (* y b)
#               (* a b)))
#          (f-helper (+ 1 (* x y))
#                    (- 1 y)))
#      < src..
     ..src > scheme
       (define (f x y)
         (define (f-helper a b)
           (+ (* x (square a))
              (* y b)
              (* a b)))
         (f-helper (+ 1 (* x y))
                   (- 1 y)))
     < src..

#      Of course, we could use a @c(lambda) expression to specify an anonymous
#      procedure for binding our local variables. The body of @c(f) then becomes a
#      single call to that procedure:
     Por supuesto, podríamos usar una expresión @c(lambda) para especificar un
     procedimiento anónimo para enlazar nuestras variables locales. El cuerpo de
     @c(f) entonces se convierte en una sola llamada a ese procedimiento:

#      ..src > scheme
#        (define (f x y)
#          ((lambda (a b)
#             (+ (* x (square a))
#                (* y b)
#                (* a b)))
#           (+ 1 (* x y))
#           (- 1 y)))
#      < src..
     ..src > scheme
       (define (f x y)
         ((lambda (a b)
            (+ (* x (square a))
               (* y b)
               (* a b)))
          (+ 1 (* x y))
          (- 1 y)))
     < src..

#      This construct is so useful that there is a special form called @c(let) to
#      make its use more convenient. Using @c(let), the @c(f) procedure could be
#      written as
     Esta construcción es tan útil que hay una forma especial llamada @c(let) para
     hacer su uso más conveniente. Usando @c(let), el procedimiento @c(f) podría
     escribirse como

#      ..src > scheme
#        (define (f x y)
#          (let ((a (+ 1 (* x y)))
#                (b (- 1 y)))
#            (+ (* x (square a))
#               (* y b)
#               (* a b))))
#      < src..
     ..src > scheme
       (define (f x y)
         (let ((a (+ 1 (* x y)))
               (b (- 1 y)))
           (+ (* x (square a))
              (* y b)
              (* a b))))
     < src..

#      The general form of a @c(let) expression is
     La forma general de una expresión @c(let) es

#      ..src > scheme
#        (let ((⟨var₁⟩ ⟨exp₁⟩)
#              (⟨var₂⟩ ⟨exp₂⟩)
#              …
#              (⟨varₙ⟩ ⟨expₙ⟩))
#          ⟨body⟩)
#      < src..
     ..src > scheme
       (let ((⟨var₁⟩ ⟨exp₁⟩)
             (⟨var₂⟩ ⟨exp₂⟩)
             …
             (⟨varₙ⟩ ⟨expₙ⟩))
         ⟨body⟩)
     < src..

#      which can be thought of as saying
     Que se puede considerar como diciendo

#      ..example >
#        let ⟨var₁⟩ have the value ⟨exp₁⟩ and
#            ⟨var₂⟩ have the value ⟨exp₂⟩ and
#            …
#            ⟨varₙ⟩ have the value ⟨expₙ⟩
#          in ⟨body⟩
#      < example..
     ..example >
       let ⟨var₁⟩ tiene el valor ⟨exp₁⟩ y
           ⟨var₂⟩ tiene el valor ⟨exp₂⟩ y
           …
           ⟨varₙ⟩ tiene el valor ⟨expₙ⟩
         in ⟨body⟩
     < example..

#      The first part of the @c(let) expression is a list of name-expression pairs.
#      When the @c(let) is evaluated, each name is associated with the value of the
#      corresponding expression. The body of the @c(let) is evaluated with these
#      names bound as local variables. The way this happens is that the @c(let)
#      expression is interpreted as an alternate syntax for
     La primera parte de la expresión @c(let) es una lista de pares
     nombre-expresión. Cuando @c(let) se evalúa, cada nombre está asociado con
     el valor de la expresión correspondiente. El cuerpo de @c(let) se evalúa
     con estos nombres vinculados como variables locales. La forma en que esto
     ocurre es que la expresión @c(let) se interpreta como una sintaxis
     alternativa para

#      ..src > scheme
#        ((lambda (⟨var₁⟩ … ⟨varₙ⟩)
#           ⟨body⟩)
#         ⟨exp₁⟩
#         …
#         ⟨expₙ⟩)
#      < src..
     ..src > scheme
       ((lambda (⟨var₁⟩ … ⟨varₙ⟩)
          ⟨body⟩)
        ⟨exp₁⟩
        …
        ⟨expₙ⟩)
     < src..

#      No new mechanism is required in the interpreter in order to provide local
#      variables. A @c(let) expression is simply syntactic sugar for the underlying
#      @c(lambda) application.
     No se requiere un nuevo mecanismo en el intérprete para proporcionar
     variables locales. Una expresión @c(let) es simplemente azúcar sintáctico
     para aplicar la @c(lambda) subyacente.

#      We can see from this equivalence that the scope of a variable specified by a
#      @c(let) expression is the body of the @c(let). This implies that:
     Podemos ver a partir de esta equivalencia que el alcance de una variable
     especificada por una expresión @c(let) es el cuerpo de @c(let). Esto
     implica que:

#      - @c(Let) allows one to bind variables as locally as possible to where they
#        are to be used. For example, if the value of @c(x) is 5, the value of the
#        expression
     - @c(Let) Permite enlazar las variables lo más localmente posible a donde
       se van a utilizar. Por ejemplo, si el valor de @c(x) es 5, el valor de la
       expresión

#        ..src > scheme
#          (+ (let ((x 3))
#               (+ x (* x 10)))
#             x)
#        < src..
       ..src > scheme
         (+ (let ((x 3))
              (+ x (* x 10)))
            x)
       < src..

#        is 38. Here, the @c(x) in the body of the @c(let) is 3, so the value of the
#        @c(let) expression is 33. On the other hand, the @c(x) that is the second
#        argument to the outermost @c(+) is still 5.
       es 38. Aquí, @c(x) en el cuerpo de @c(let) es 3, por lo que el valor de
       la expresión @c(let) es 33. Por otra parte, el segundo argumento @c(x) a
       más externo a @c(+) es todavía 5.

#      - The variables' values are computed outside the @c(let). This matters when
#        the expressions that provide the values for the local variables depend upon
#        variables having the same names as the local variables themselves. For
#        example, if the value of @c(x) is 2, the expression
     - Los valores de las variables se calculan fuera de @c(let). Esto es
       importante cuando las expresiones que proporcionan los valores para las
       variables locales dependen de variables que tengan los mismos nombres que
       las variables locales. Por ejemplo, si el valor de @c(x) es 2, la
       expresión

#        ..src > scheme
#          (let ((x 3)
#                (y (+ x 2)))
#            (* x y))
#        < src..
       ..src > scheme
         (let ((x 3)
               (y (+ x 2)))
           (* x y))
       < src..

#        will have the value 12 because, inside the body of the @c(let), @c(x) will
#        be 3 and @c(y) will be 4 (which is the outer @c(x) plus 2).
       Tendrá el valor 12 porque, dentro del cuerpo del @c(let), @c(x) será 3 y
       @c(y) será 4 (que es el @c(x) exterior más 2).


#      Sometimes we can use internal definitions to get the same effect as with
#      @c(let). For example, we could have defined the procedure @c(f) above as
     A veces podemos usar definiciones internas para obtener el mismo efecto que
     con @c(let). Por ejemplo, podríamos haber definido el anterior
     procedimiento @c(f) como

#      ..src > scheme
#        (define (f x y)
#          (define a
#            (+ 1 (* x y)))
#          (define b (- 1 y))
#          (+ (* x (square a))
#             (* y b)
#             (* a b)))
#      < src..
     ..src > scheme
       (define (f x y)
         (define a
           (+ 1 (* x y)))
         (define b (- 1 y))
         (+ (* x (square a))
            (* y b)
            (* a b)))
     < src..

#      We prefer, however, to use @c(let) in situations like this and to use internal
#      @c(define) only for internal procedures.@n(54)
     Preferimos, sin embargo, utilizar @c(let) en situaciones como esta y utilizar
     @c(define) internos sólo para procedimientos internos.@n(54)

#      :: @t(Exercise 1.34) :: Suppose we define the procedure
     :: @t(Ejercicio 1.34) :: Supongamos que definimos el procedimiento

#         ..src > scheme
#           (define (f g) (g 2))
#         < src..
        ..src > scheme
          (define (f g) (g 2))
        < src..

#         Then we have
        Entonces nosotros tenemos

#         ..srci > scheme
#           > (f square)
#           4
#           > (f (lambda (z) (* z (+ z 1))))
#           6
#         < srci..
        ..srci > scheme
          > (f square)
          4
          > (f (lambda (z) (* z (+ z 1))))
          6
        < srci..

#         What happens if we (perversely) ask the interpreter to evaluate the
#         combination @c[(f f)]?  Explain.
        ¿Qué sucede si pedimos (perversamente) al intérprete que evalúe la
        combinación @c[(f f)]? Explique.

# *** 1.3.3 <> Procedures as General Methods
*** 1.3.3 <> Procedimientos como Métodos Generales

#     We introduced compound procedures in section @l(#1.1.4) as a mechanism for
#     abstracting patterns of numerical operations so as to make them independent
#     of the particular numbers involved. With higher-order procedures, such as
#     the @c(integral) procedure of section @l(#1.3.1), we began to see a more
#     powerful kind of abstraction: procedures used to express general methods of
#     computation, independent of the particular functions involved. In this
#     section we discuss two more elaborate examples––general methods for finding
#     zeros and fixed points of functions––and show how these methods can be
#     expressed directly as procedures.
    Introdujimos los procedimientos compuestos en la seccion @l(#1.1.4) como un
    mecanismo para abstraer los patrones de las operaciones numéricas para
    hacerlos independientes de los números particulares involucrados. Con
    procedimientos de orden superior, como el procedimiento @c(integral) de la
    seccion @l(#1.3.1), comenzamos a ver un tipo más poderoso de abstracción:
    procedimientos usados para expresar métodos generales de computación,
    independientemente de las funciones particulares involucradas. En esta
    sección discutiremos dos ejemplos más elaborados––métodos generales para
    encontrar ceros y puntos fijos de funciones––y mostraremos cómo estos
    métodos pueden expresarse directamente como procedimientos.

# **** Finding roots of equations by the half-interval method
**** Encontrar raíces de ecuaciones por el método de intervalo medio

#      The @e(half-interval method) is a simple but powerful technique for finding
#      roots of an equation @m[ƒ(x) = 0], where @m(ƒ) is a continuous function. The
#      idea is that, if we are given points @m(a) and @m(b) such that @m[ƒ(a) < 0 <
#      ƒ(b)], then @m(ƒ) must have at least one zero between @m(a) and @m(b). To
#      locate a zero, let @m(x) be the average of @m(a) and @m(b), and compute
#      @m[ƒ(x)]. If @m[ƒ(x) > 0], then @m(ƒ) must have a zero between @m(a) and
#      @m(x). If @m[ƒ(x) < 0], then @m(ƒ) must have a zero between @m(x) and
#      @m(b). Continuing in this way, we can identify smaller and smaller intervals
#      on which @m(ƒ) must have a zero. When we reach a point where the interval is
#      small enough, the process stops. Since the interval of uncertainty is reduced
#      by half at each step of the process, the number of steps required grows as
#      @m[Θ(log(L / T))], where @m(L) is the length of the original interval and
#      @m(T) is the error tolerance (that is, the size of the interval we will
#      consider @"(small enough). Here is a procedure that implements this strategy:
     El @e(método de intervalo medio) es una técnica simple pero de gran
     alcance para encontrar raíces de una ecuación @m[ƒ(x) = 0], donde @m(ƒ) es
     una función continua. La idea es que, si se nos dan los puntos @m(a) y
     @m(b) tales que @m[ƒ(a) < 0 < ƒ(b)], entonces @m(ƒ) debe tener al
     menos un cero entre @m(a) y @m(b). Para localizar un cero, dejar que @m(x)
     sea el promedio de @m(a) y @m(b), y calcular @m[ƒ(x)]. Si @m[ƒ(x) >
     0], entonces @m(ƒ) debe tener un cero entre @m(a) y @m(x). Si @m[ƒ(x)
     < 0], entonces @m(ƒ) debe tener un cero entre @m(x) y @m(b). Continuando
     de esta manera, podemos identificar intervalos cada vez más pequeños en los
     que @m(ƒ) debe tener un cero. Cuando llegamos a un punto donde el intervalo
     es lo suficientemente pequeño, el proceso se detiene. Dado que el intervalo
     de incertidumbre se reduce a la mitad en cada paso del proceso, el número
     de pasos requeridos crece como @m[Θ(log(L / T))], donde @m(L) es la
     longitud del intervalo original y @m(T) es la tolerancia de error Es, el
     tamaño del intervalo que vamos a considerar lo @"(suficientemente pequeño).
     Aquí está un procedimiento que implementa esta estrategia:

#      ..src > scheme
#        (define (search f neg-point pos-point)
#          (let ((midpoint
#                 (average neg-point pos-point)))
#            (if (close-enough? neg-point pos-point)
#                midpoint
#                (let ((test-value (f midpoint)))
#                  (cond
#                   ((positive? test-value)
#                    (search f neg-point midpoint))
#                   ((negative? test-value)
#                    (search f midpoint pos-point))
#                   (else midpoint))))))
#      < src..
     ..src > scheme
       (define (search f neg-point pos-point)
         (let ((midpoint
                (average neg-point pos-point)))
           (if (close-enough? neg-point pos-point)
               midpoint
               (let ((test-value (f midpoint)))
                 (cond
                  ((positive? test-value)
                   (search f neg-point midpoint))
                  ((negative? test-value)
                   (search f midpoint pos-point))
                  (else midpoint))))))
     < src..

#      We assume that we are initially given the function @m(ƒ) together with points
#      at which its values are negative and positive. We first compute the midpoint
#      of the two given points. Next we check to see if the given interval is small
#      enough, and if so we simply return the midpoint as our answer. Otherwise, we
#      compute as a test value the value of @m(ƒ) at the midpoint. If the test value
#      is positive, then we continue the process with a new interval running from the
#      original negative point to the midpoint. If the test value is negative, we
#      continue with the interval from the midpoint to the positive point. Finally,
#      there is the possibility that the test value is 0, in which case the midpoint
#      is itself the root we are searching for.
     Suponemos que se nos da inicialmente la función @m(ƒ) junto con los puntos
     en que sus valores son negativos y positivos. Primero calculamos el punto
     medio de los dos puntos dados. A continuación verificamos si el intervalo
     dado es lo suficientemente pequeño, y si es así simplemente devolvemos el
     punto medio como nuestra respuesta. De lo contrario, calculamos como valor
     de prueba el valor de @m(ƒ) en el punto medio. Si el valor de la prueba es
     positivo, entonces continuamos el proceso con un nuevo intervalo que va
     desde el punto negativo original hasta el punto medio. Si el valor de la
     prueba es negativo, continuamos con el intervalo desde el punto medio hasta
     el punto positivo. Finalmente, existe la posibilidad de que el valor de
     prueba sea 0, en cuyo caso el punto medio es en sí mismo la raíz que
     estamos buscando.

#      To test whether the endpoints are @"(close enough) we can use a procedure
#      similar to the one used in section @l(#1.1.7) for computing square roots:@n(55)
     Para probar si los puntos finales están @"(lo suficientemente cerca)
     podemos usar un procedimiento similar al usado en la seccion @l(#1.1.7) para
     calcular raíces cuadradas:@n(55)

#      ..src > scheme
#        (define (close-enough? x y)
#          (< (abs (- x y)) 0.001))
#      < src..
     ..src > scheme
       (define (close-enough? x y)
         (< (abs (- x y)) 0.001))
     < src..

#      @c(search) is awkward to use directly, because we can accidentally give it
#      points at which @m(ƒ)'s values do not have the required sign, in which case we
#      get a wrong answer. Instead we will use @c(search) via the following
#      procedure, which checks to see which of the endpoints has a negative function
#      value and which has a positive value, and calls the @c(search) procedure
#      accordingly. If the function has the same sign on the two given points, the
#      half-interval method cannot be used, in which case the procedure signals an
#      error.@n(56)
     @c(search) Es incómodo de usar directamente, porque podemos accidentalmente
     darle puntos en los que los valores de @m(ƒ) no tienen el signo requerido,
     en cuyo caso recibimos una respuesta equivocada. En su lugar, utilizaremos
     @c(search) el siguiente procedimiento, que verifica cuál de los puntos
     finales tiene un valor de función negativo y cuál tiene un valor positivo,
     y llama al procedimiento @c(search) en consecuencia. Si la función tiene el
     mismo signo en los dos puntos dados, no se puede utilizar el método de
     medio intervalo, en cuyo caso el procedimiento indica un error.@n(56)

#      ..src > scheme
#        (define (half-interval-method f a b)
#          (let ((a-value (f a))
#                (b-value (f b)))
#            (cond ((and (negative? a-value)
#                        (positive? b-value))
#                   (search f a b))
#                  ((and (negative? b-value)
#                        (positive? a-value))
#                   (search f b a))
#                  (else
#                   (error "Values are not of
#                           opposite sign" a b)))))
#      < src..
     ..src > scheme
       (define (half-interval-method f a b)
         (let ((a-value (f a))
               (b-value (f b)))
           (cond ((and (negative? a-value)
                       (positive? b-value))
                  (search f a b))
                 ((and (negative? b-value)
                       (positive? a-value))
                  (search f b a))
                 (else
                  (error "Values are not of
                          opposite sign" a b)))))
     < src..

#      The following example uses the half-interval method to approximate @m(π) as
#      the root between 2 and 4 of @m(sin x = 0):
     El siguiente ejemplo utiliza el método de medio intervalo para aproximar
     @m(π) como la raíz entre 2 y 4 de @m(sin x = 0) :

#      ..srci > scheme
#        (half-interval-method sin 2.0 4.0)
#        3.14111328125
#      < srci..
     ..srci > scheme
       (half-interval-method sin 2.0 4.0)
       3.14111328125
     < srci..

#      Here is another example, using the half-interval method to search for a root
#      of the equation @m(x³ − 2x − 3 = 0) between 1 and 2:
     Aquí hay otro ejemplo, usando el método de medio intervalo para buscar una
     raíz de la ecuación @m(x³ − 2x − 3 = 0) entre 1 y 2:

#      ..srci > scheme
#        > (half-interval-method
#        ^  (lambda (x) (- (* x x x) (* 2 x) 3))
#        ^  1.0
#        ^  2.0)
#        1.89306640625
#      < srci..
     ..srci > scheme
       > (half-interval-method
       ^  (lambda (x) (- (* x x x) (* 2 x) 3))
       ^  1.0
       ^  2.0)
       1.89306640625
     < srci..

# **** Finding fixed points of functions
**** Encontrar puntos fijos de funciones

#      A number @m(x) is called a @e(fixed point) of a function @m(ƒ) if @m(x)
#      satisfies the equation @m[ƒ(x) = x]. For some functions @m(ƒ) we can locate a
#      fixed point by beginning with an initial guess and applying @m(ƒ) repeatedly,
     Un número @m(x) se denomina un @e(punto fijo) de una función @m(ƒ) si @m(x)
     satisface la ecuación @m(ƒ(x) = x). Para algunas funciones @m(ƒ) podemos
     localizar un punto fijo empezando con una conjetura inicial y aplicando
     @m(ƒ) repetidamente,

#      ..example >
#        ƒ(x), ƒ(ƒ(x)), ƒ(ƒ(ƒ(x))), ...
#      < example..
     ..example >
       ƒ(x), ƒ(ƒ(x)), ƒ(ƒ(ƒ(x))), ...
     < example..

#      until the value does not change very much. Using this idea, we can devise a
#      procedure @c(fixed-point) that takes as inputs a function and an initial guess
#      and produces an approximation to a fixed point of the function. We apply the
#      function repeatedly until we find two successive values whose difference is
#      less than some prescribed tolerance:
     Hasta que el valor no cambie mucho. Usando esta idea, podemos idear un
     procedimiento @c(fixed-point) que toma como entradas una función y una
     conjetura inicial y produce una aproximación a un punto fijo de la
     función. Aplicamos la función repetidamente hasta encontrar dos valores
     sucesivos cuya diferencia es menor que alguna tolerancia prescrita:

#      ..src > scheme
#        (define tolerance 0.00001)
#
#        (define (fixed-point f first-guess)
#          (define (close-enough? v1 v2)
#            (< (abs (- v1 v2))
#               tolerance))
#          (define (try guess)
#            (let ((next (f guess)))
#              (if (close-enough? guess next)
#                  next
#                  (try next))))
#          (try first-guess))
#      < src..
     ..src > scheme
       (define tolerance 0.00001)

       (define (fixed-point f first-guess)
         (define (close-enough? v1 v2)
           (< (abs (- v1 v2))
              tolerance))
         (define (try guess)
           (let ((next (f guess)))
             (if (close-enough? guess next)
                 next
                 (try next))))
         (try first-guess))
     < src..

#      For example, we can use this method to approximate the fixed point of the
#      cosine function, starting with 1 as an initial approximation:@n(57)
     Por ejemplo, podemos usar este método para aproximar el punto fijo de la
     función coseno, comenzando con 1 como una aproximación inicial:@n(57)

#      ..srci > scheme
#        > (fixed-point cos 1.0)
#        .7390822985224023
#      < srci..
     ..srci > scheme
       > (fixed-point cos 1.0)
       .7390822985224023
     < srci..

#      Similarly, we can find a solution to the equation @m(y = sin y + cos y):
     Del mismo modo, podemos encontrar una solución a la ecuación @m(y = sin y +
     cos y) :

#      ..srci > scheme
#        > (fixed-point (lambda (y) (+ (sin y) (cos y)))
#        ^              1.0)
#        1.2587315962971173
#      < srci..
     ..srci > scheme
       > (fixed-point (lambda (y) (+ (sin y) (cos y)))
       ^              1.0)
       1.2587315962971173
     < srci..

#      The fixed-point process is reminiscent of the process we used for finding
#      square roots in section @l(#1.1.7). Both are based on the idea of repeatedly improving
#      a guess until the result satisfies some criterion. In fact, we can readily
#      formulate the square-root computation as a fixed-point search.  Computing the
#      square root of some number @m(x) requires finding a @m(y) such that @m(y² =
#      x). Putting this equation into the equivalent form @m(y = x/y), we recognize
#      that we are looking for a fixed point of the function@n(58) @m(y ↦ x/y), and
#      we can therefore try to compute square roots as
     El proceso de punto fijo es una reminiscencia del proceso que usamos para
     encontrar raíces cuadradas en la seccion @l(#1.1.7). Ambos se basan en la
     idea de mejorar repetidamente una conjetura hasta que el resultado
     satisface algún criterio. De hecho, podemos formular fácilmente el cálculo
     de raíz cuadrada como una búsqueda de punto fijo. Calculando la raíz
     cuadrada de un cierto número @m(x) se requiere encontrar a @m(y) tal que
     @m(y² = x). Poniendo esta ecuación en la forma equivalente @m(y = x/y),
     reconocemos que estamos buscando un punto fijo de la función@n(58) @m(y ↦
     x/y), por lo que podemos tratar de calcular las raíces cuadradas como

#      ..src > scheme
#        (define (sqrt x)
#          (fixed-point (lambda (y) (/ x y))
#                       1.0))
#      < src..
     ..src > scheme
       (define (sqrt x)
         (fixed-point (lambda (y) (/ x y))
                      1.0))
     < src..

#      Unfortunately, this fixed-point search does not converge. Consider an initial
#      guess @m(y₁). The next guess is @m(y₂ = x/y₁) and the next guess is @m[y₃ =
#      x/y₂ = x/(x/y₁) = y₁]. This results in an infinite loop in which the two
#      guesses @m(y₁) and @m(y₂) repeat over and over, oscillating about the answer.
     Desafortunadamente, esta búsqueda de punto fijo no converge. Considere una
     conjetura inicial @m(y₁). La siguiente suposición es @m(y₂ = x / y₁) y la
     siguiente conjetura es @m(y₃ = x/y₂ = x/(x/y₁) = y₁). Esto da como
     resultado un bucle infinito en el que las dos conjeturas @m(y₁) y @m(y₂) se
     repiten una y otra vez, oscilando alrededor de la respuesta.

#      One way to control such oscillations is to prevent the guesses from changing
#      so much. Since the answer is always between our guess @m(y) and @m(x/y), we
#      can make a new guess that is not as far from @m(y) as @m(x/y) by averaging
#      @m(y) with @m(x/y), so that the next guess after @m(y) is @m[(1/2)(y + x/y)]
#      instead of @m(x/y). The process of making such a sequence of guesses is
#      simply the process of looking for a fixed point of @m(y ↦ (1/2)(y + x/y)):
     Una forma de controlar tales oscilaciones es evitar que las suposiciones
     cambien tanto. Puesto que la respuesta está siempre entre nuestra conjetura
     @m(y) y @m(x/y), podemos hacer una nueva conjetura que no esté tan lejos de
     @m(y) como @m(x/y) promediando @m(y) con @m(x/y), de modo que la próxima
     conjetura después de @m(y) sea @m[(1/2)(y + X/y)] en lugar de @m(x/y). El
     proceso de hacer tal secuencia de conjeturas es simplemente el proceso de
     buscar un punto fijo de @m(y ↦ (1/2)(y + x/y)):

#      ..src > scheme
#        (define (sqrt x)
#          (fixed-point
#           (lambda (y) (average y (/ x y)))
#           1.0))
#      < src..
     ..src > scheme
       (define (sqrt x)
         (fixed-point
          (lambda (y) (average y (/ x y)))
          1.0))
     < src..

#      (Note that @m[y = (1/2)(y + x/y)] is a simple transformation of the equation
#      @m(y = x/y); to derive it, add @m(y) to both sides of the equation and
#      divide by 2.)
     (Obsérvese que @m[y = (1/2)(y + x/y)] es una transformación simple de la
     ecuación @m(y = x/y), para derivarla, añada @m(y) a ambos lados de la
     ecuación y divida por 2.)

#      With this modification, the square-root procedure works. In fact, if we
#      unravel the definitions, we can see that the sequence of approximations to the
#      square root generated here is precisely the same as the one generated by our
#      original square-root procedure of section @l(#1.1.7). This approach of averaging
#      successive approximations to a solution, a technique that we call @e(average
#      damping), often aids the convergence of fixed-point searches.
     Con esta modificación, el procedimiento de raíz cuadrada funciona. De
     hecho, si desentrañamos las definiciones, podemos ver que la secuencia de
     aproximaciones a la raíz cuadrada generada aquí es precisamente la misma
     que la generada por nuestro procedimiento de raíz cuadrada original de la
     seccion @l(#1.1.7). Este enfoque de promediar aproximaciones sucesivas a
     una solución, es una técnica que llamamos @e(amortiguación promedio), a
     menudo ayuda a la convergencia de búsquedas de punto fijo.

#      :: @t(Exercise 1.35) :: Show that the golden ratio @m(φ) (section @l(#1.2.2)) is a
#         fixed point of the transformation @m(x ↦ 1 + 1/x), and use this fact to
#         compute @m(φ) by means of the @c(fixed-point) procedure.
     :: @t(Ejercicio 1.35) :: Demuestre que la proporcion aurea @m(φ) (seccion
        @l(#1.2.2)) es un punto fijo de la transformación @m(x ↦ 1 + 1/x), y
        utilice este hecho para calcular @m(φ) mediante el procedimiento
        @c(fixed-point).

#      :: @t(Exercise 1.36) :: Modify @c(fixed-point) so that it prints the sequence
#         of approximations it generates, using the @c(newline) and @c(display)
#         primitives shown in @l(#Exercise 1.22). Then find a solution to @m(xˣ
#         = 1000) by finding a fixed point of @m[x ↦ log(1000)/log(x)]. (Use
#         Scheme's primitive @c(log) procedure, which computes natural logarithms.)
#         Compare the number of steps this takes with and without average
#         damping. (Note that you cannot start @c(fixed-point) with a guess of 1, as
#         this would cause division by @m[log(1) = 0].)
     :: @t(Ejercicio 1.36) :: Modifique @c(fixed-point) para que imprima la
        secuencia de aproximaciones que genera, usando las primitivas
        @c(newline) y @c(display) mostradas en el @l(#Ejercicio 1.22). A
        continuación, encontrar una solución a @m(xˣ = 1000) mediante la
        búsqueda de un punto fijo de @m[x ↦ log(1000)/log(x)]. (Utilice el
        procedimiento primitivo @c(log) de Scheme, que calcula los logaritmos
        naturales.) Compare el número de pasos que lleva con y sin
        amortiguamiento promedio. (Tenga en cuenta que no puede comenzar
        @c(fixed-point) con una conjetura de 1, ya que esto causaría división
        por @m[log(1) = 0].)

#      :: @t(Exercise 1.37) ::
     :: @t(Ejercicio 1.37) ::

#         1. An infinite @e(continued fraction) is an expression of the form
        1. Una @e(fracción continua) infinita es una expresión de la forma

#            ..example >
#                         N₁
#              ƒ = ––––––––––––––––––––
#                             N₂
#                  D₁  + ––––––––––––––
#                                 N₃
#                        D₂ + –––––––––
#                             D₃ + ⋅⋅⋅
#            < example..
           ..example >
                        N₁
             ƒ = ––––––––––––––––––––
                            N₂
                 D₁  + ––––––––––––––
                                N₃
                       D₂ + –––––––––
                            D₃ + ⋅⋅⋅
           < example..

#            As an example, one can show that the infinite continued fraction
#            expansion with the @m(Nᵢ) and the @m(Dᵢ) all equal to 1 produces
#            @m(1/φ), where @m(φ) is the golden ratio (described in section
#            @l(#1.2.2)). One way to approximate an infinite continued fraction
#            is to truncate the expansion after a given number of terms. Such a
#            truncation––a so-called @e(@i{k}-term finite continued
#            fraction)––has the form
           A modo de ejemplo, se puede demostrar que la expansión de la fracción
           continua infinita con @m(Nᵢ) y @m(Dᵢ) igual a 1 produce @m(1/φ),
           donde @m(φ) es la proporción aurea (descrita en la seccion @l(#1.2.2)).
           Una forma de aproximar una fracción continua infinita es truncar la
           expansión después de un número dado de términos. Tal truncamiento––se
           denomina como @e(termino @i(i) de una fraccion finita continua––tiene
           la forma

#            ..example >
#                     N₁
#              –––––––––––––––––
#                        N₂
#              D₁ + ––––––––––––
#                            Nₙ
#                    ⋱  + –––––
#                            Dₙ
#            < example..
           ..example >
                    N₁
             –––––––––––––––––
                       N₂
             D₁ + ––––––––––––
                           Nₙ
                   ⋱  + –––––
                           Dₙ
           < example..

#            Suppose that @c(n) and @c(d) are procedures of one argument (the term
#            index @m(i)) that return the @m(Nᵢ) and @m(Dᵢ) of the terms of the
#            continued fraction. Define a procedure @c(cont-frac) such that
#            evaluating @c[(cont-frac n d k)] computes the value of the @m(k)-term
#            finite continued fraction. Check your procedure by approximating
#            @m(1/φ) using
           Supongamos que @c(n) y @c(d) son procedimientos de un argumento
           (el término índice @m(i)) que devuelve @m(Nᵢ) y @m(Dᵢ) de los
           términos de la fracción continua) Defina un procedimiento
           @c(cont-frac) donde la evaluación @c[(cont-frac n d k)] calcula el
           valor de la fracción continuada finita de termino-@m(k). Revise su
           procedimiento por aproximacion usando @m(1/φ) usando

#            ..src > scheme
#              (cont-frac (lambda (i) 1.0)
#              (lambda (i) 1.0)
#              k)
#            < src..
           ..src > scheme
             (cont-frac (lambda (i) 1.0)
             (lambda (i) 1.0)
             k)
           < src..

#            for successive values of @c(k). How large must you make @c(k) in order
#            to get an approximation that is accurate to 4 decimal places?
           Para sucesivos valores de @c(k). ¿Cuánto debe hacer @c(k) para
           obtener una aproximación que sea exacta a 4 decimales?

#         2. If your @c(cont-frac) procedure generates a recursive process, write one
#            that generates an iterative process. If it generates an iterative
#            process, write one that generates a recursive process.
        2. Si su procedimiento @c(cont-frac) genera un proceso recursivo,
           escriba uno que genere un proceso iterativo. Si genera un proceso
           iterativo, escriba uno que genere un proceso recursivo.


#      :: @t(Exercise 1.38) :: In 1737, the Swiss mathematician Leonhard Euler
#         published a memoir @q(De Fractionibus Continuis), which included a
#         continued fraction expansion for @m(e − 2), where @m(e) is the base of the
#         natural logarithms. In this fraction, the @m(Nᵢ) are all 1, and the @m(Dᵢ)
#         are successively 1, 2, 1, 1, 4, 1, 1, 6, 1, 1, 8, ….  Write a program that
#         uses your @c(cont-frac) procedure from @l(#Exercise 1.37) to approximate
#         @m(e), based on Euler's expansion.
     :: @t(Ejercicio 1.38) :: En 1737, el matemático Suizo Leonhard Euler
        publicó una memoria @q(De Fractionibus Continuis), que incluía una
        expansión de fracción continua para @m(e − 2), donde @m(e) es la base de
        los logaritmos naturales. En esta fracción, los @m(Nᵢ) son todos 1, y
        los @m(Dᵢ) son sucesivamente 1, 2, 1, 1, 4, 1, 1, 6, 1, 1, 8, …. Escriba
        un programa que use su procedimiento @c(cont-frac) del @l(#Ejercicio
        1.37) para aproximarse a @m(e), basado en la expansión de Euler.

#      :: @t(Exercise 1.39) :: A continued fraction representation of the tangent
#         function was published in 1770 by the German mathematician J.H. Lambert:
     :: @t(Ejercicio 1.39) :: Una representación fraccionada continua de la
        función tangente fue publicada en 1770 por el matemático alemán JH Lambert:

#         ..example >
#                         x
#           tan x = –––––––––––––––
#                           x²
#                   1 − –––––––––––
#                             x²
#                       3 − –––––––
#                           5 − ⋱
#         < example..
        ..example >
                        x
          tan x = –––––––––––––––
                          x²
                  1 − –––––––––––
                            x²
                      3 − –––––––
                          5 − ⋱
        < example..

#         where @m(x) is in radians. Define a procedure @c[(tan-cf x k)] that
#         computes an approximation to the tangent function based on Lambert's
#         formula.  @c(k) specifies the number of terms to compute, as in
#         @l(#Exercise 1.37).
        Donde @m(x) es en radianes. Definir un procedimiento @c[(tan-cf x k)]
        que calcula una aproximación a la función tangente basada en la fórmula
        de Lambert. @c(k) Especifica el número de términos a calcular, como en
        el @l(#Ejercicio 1.37).

# *** 1.3.4 <> Procedures as Returned Values
*** 1.3.4 <> Procedimientos como Valores Devueltos

#     The above examples demonstrate how the ability to pass procedures as arguments
#     significantly enhances the expressive power of our programming language. We
#     can achieve even more expressive power by creating procedures whose returned
#     values are themselves procedures.
    Los ejemplos anteriores demuestran cómo la capacidad de pasar procedimientos
    como argumentos mejora significativamente el poder expresivo de nuestro
    lenguaje de programación. Podemos lograr un poder aún más expresivo creando
    procedimientos cuyos valores devueltos son procedimientos propios.

#     We can illustrate this idea by looking again at the fixed-point example
#     described at the end of section @l(#1.3.3). We formulated a new version of the
#     square-root procedure as a fixed-point search, starting with the observation
#     that @m(√x) is a fixed-point of the function @m(y ↦ x/y). Then we used
#     average damping to make the approximations converge.  Average damping is a
#     useful general technique in itself. Namely, given a function @m(ƒ), we
#     consider the function whose value at @m(x) is equal to the average of @m(x)
#     and @m[ƒ(x)].
    Podemos ilustrar esta idea mirando de nuevo el ejemplo de punto fijo
    descrito al final de la seccion @l(#1.3.3). Hemos formulado una nueva
    versión del procedimiento de raíz cuadrada como una búsqueda de punto fijo,
    comenzando con la observación de que @m(√x) es un punto fijo de la función
    @m(y ↦ x/y). Luego usamos el amortiguamiento promedio para hacer converger
    las aproximaciones. El amortiguamiento promedio es una técnica general útil
    en sí misma. Es decir, dada una función @m(ƒ), consideramos que la función
    cuyo valor en @m(x) es igual a la media de @m(x) y @m(ƒ(x)).

#     We can express the idea of average damping by means of the following
#     procedure:
    Podemos expresar la idea del amortiguamiento promedio mediante el siguiente
    procedimiento:

#     ..src > scheme
#       (define (average-damp f)
#         (lambda (x)
#           (average x (f x))))
#     < src..
    ..src > scheme
      (define (average-damp f)
        (lambda (x)
          (average x (f x))))
    < src..

#     @c(average-damp) is a procedure that takes as its argument a procedure
#     @c(f) and returns as its value a procedure (produced by the @c(lambda))
#     that, when applied to a number @c(x), produces the average of @c(x) and
#     @c[(f x)]. For example, applying @c(average-damp) to the @c(square)
#     procedure produces a procedure whose value at some number @m(x) is the average
#     of @m(x) and @m(x²). Applying this resulting procedure to 10 returns the
#     average of 10 and 100, or 55:@n(59)
    @c(average-damp) Es un procedimiento que toma como argumento un
    procedimiento @c(f) y devuelve como su valor un procedimiento (producido por
    el @c(lambda)) que, cuando se aplica a un número @c(x), produce el promedio
    de @c(x) y @c[(f x)]. Por ejemplo, aplicar @c(average-damp) al procedimiento
    @c(square) produce un procedimiento cuyo valor en cierto número @m(x) es la
    media de @m(x) y @m(x²). Aplicación de este procedimiento devuelto a 10
    regresa el promedio de 10 y 100, o 55:@n(59)

#     ..srci > scheme
#       > ((average-damp square) 10)
#       55
#     < srci..
    ..srci > scheme
      > ((average-damp square) 10)
      55
    < srci..

#     Using @c(average-damp), we can reformulate the square-root procedure as
#     follows:
    Usando @c(average-damp), podemos reformular el procedimiento de raíz
    cuadrada de la siguiente manera:

#     ..src > scheme
#       (define (sqrt x)
#         (fixed-point
#          (average-damp
#           (lambda (y) (/ x y)))
#          1.0))
#     < src..
    ..src > scheme
      (define (sqrt x)
        (fixed-point
         (average-damp
          (lambda (y) (/ x y)))
         1.0))
    < src..

#     Notice how this formulation makes explicit the three ideas in the method:
#     fixed-point search, average damping, and the function @m(y ↦ x/y).  It is
#     instructive to compare this formulation of the square-root method with the
#     original version given in section @l(#1.1.7). Bear in mind that these procedures
#     express the same process, and notice how much clearer the idea becomes when we
#     express the process in terms of these abstractions. In general, there are many
#     ways to formulate a process as a procedure.  Experienced programmers know how
#     to choose procedural formulations that are particularly perspicuous, and where
#     useful elements of the process are exposed as separate entities that can be
#     reused in other applications. As a simple example of reuse, notice that the
#     cube root of @m(x) is a fixed point of the function @m(y ↦ x/y²), so we can
#     immediately generalize our square-root procedure to one that extracts cube
#     roots:@n(60)
    Observe cómo esta formulación hace explícitas las tres ideas en el método:
    búsqueda en punto fijo, amortiguación promedio y la función @m(y ↦ x/y). Es
    instructivo comparar esta formulación del método de raíz cuadrada con la
    versión original dada en la seccion @l(#1.1.7). Tenga en cuenta que estos
    procedimientos expresan el mismo proceso y advierta cuánto más clara se
    vuelve la idea cuando expresamos el proceso en términos de estas
    abstracciones. En general, hay muchas maneras de formular un proceso como un
    procedimiento. Los programadores experimentados saben elegir fórmulas de
    procedimiento que son particularmente perspicuas, y donde los elementos
    útiles del proceso están expuestos como entidades separadas que pueden ser
    reutilizadas en otras aplicaciones. Como un simple ejemplo de reutilización,
    observe que la raíz cúbica de @m(x) es un punto fijo de la función @m(y ↦
    x/y²), por lo que inmediatamente podemos generalizar nuestro procedimiento
    de raíz cuadrada a uno que extrae raíces cúbicas:@n(60)

#     ..src > scheme
#       (define (cube-root x)
#         (fixed-point
#          (average-damp
#           (lambda (y)
#             (/ x (square y))))
#          1.0))
#     < src..
    ..src > scheme
      (define (cube-root x)
        (fixed-point
         (average-damp
          (lambda (y)
            (/ x (square y))))
         1.0))
    < src..

# **** Newton's method
**** El Método Newton

#      When we first introduced the @c(square-root) procedure, in section @l(#1.1.7), we
#      mentioned that this was a special case of @e(Newton's method).  If @m[x ↦
#      g(x)] is a differentiable function, then a solution of the equation @m[g(x) =
#      0] is a fixed point of the function @m[x ↦ ƒ(x)] where
     Cuando introdujimos el procedimiento @c(square-root), en la seccion
     @l(#1.1.7), mencionamos que este era un caso especial del @e(método
     @e(Newton). Si @m[x ↦ g(x)] es una función diferenciable, entonces una
     solución de la ecuación @m[g(x) = 0] es un punto fijo de la función @m[x ↦
     ƒ(x)] donde

#      ..example >
#                    g(x)
#        ƒ(x) = x − –––––
#                   Dg(x)
#      < example..
     ..example >
                   g(x)
       ƒ(x) = x − –––––
                  Dg(x)
     < example..

#      and @m[Dg(x)] is the derivative of @m(g) evaluated at @m(x). Newton's method
#      is the use of the fixed-point method we saw above to approximate a solution of
#      the equation by finding a fixed point of the function @m(ƒ).@n(61)
#      For many functions @m(g) and for sufficiently good initial guesses for @m(x),
#      Newton's method converges very rapidly to a solution of @m[g(x) = 0].@n(62)
     Y @m[Dg(x)] es la derivada de @m(g) evaluada en @m(x). El método Newton es
     el uso del método de punto fijo que vimos anteriormente para aproximar una
     solución de la ecuación encontrando un punto fijo de la función @m(ƒ).@n(61)
     Para muchas funciones @m(g) y para las suposiciones iniciales
     suficientemente buenas para @m(x), el método de Newton converge muy
     rápidamente a una solución de @m[g(x) = 0].@n(62)

#      In order to implement Newton's method as a procedure, we must first express
#      the idea of derivative. Note that @"(derivative), like average damping, is
#      something that transforms a function into another function. For instance, the
#      derivative of the function @m(x ↦ x³) is the function @m(x ↦ 3x²).  In
#      general, if @m(g) is a function and @m(dx) is a small number, then the
#      derivative @m(Dg) of @m(g) is the function whose value at any number @m(x) is
#      given (in the limit of small @m(dx)) by
     Para implementar el método Newton como un procedimiento, primero debemos
     expresar la idea de derivada. Obsérvese que la @"(derivada), como el
     amortiguamiento promedio, es algo que transforma una función en otra
     función. Por ejemplo, la derivada de la función @m(x ↦ x³) es la función
     @m(x ↦ 3x²). En general, si @m(g) es una función y @m(dx) es un número
     pequeño, entonces la derivada @m(Dg) de @m(g) es la función cuyo valor en
     cualquier número @m(x) es dado (en el límite menor de @m(dx)) por

#      ..example >
#                g(x + dx) − g(x)
#        Dg(x) = ––––––––––––––––
#                       dx
#      < example..
     ..example >
               g(x + dx) − g(x)
       Dg(x) = ––––––––––––––––
                      dx
     < example..

#      Thus, we can express the idea of derivative (taking @m(dx) to be, say,
#      0.00001) as the procedure
     Así, podemos expresar la idea de derivada (tomando @m(dx) como, por
     ejemplo, 0.00001) como el procedimiento

#      ..src > scheme
#        (define (deriv g)
#          (lambda (x)
#            (/ (- (g (+ x dx)) (g x))
#               dx)))
#      < src..
     ..src > scheme
       (define (deriv g)
         (lambda (x)
           (/ (- (g (+ x dx)) (g x))
              dx)))
     < src..

#      along with the definition
     Junto con la definición

#      ..src > scheme
#        (define dx 0.00001)
#      < src..
     ..src > scheme
       (define dx 0.00001)
     < src..

#      Like @c(average-damp), @c(deriv) is a procedure that takes a procedure as
#      argument and returns a procedure as value. For example, to approximate the
#      derivative of @m(x ↦ x³) at 5 (whose exact value is 75) we can evaluate
     Al igual que @c(average-damp), @c(deriv) es un procedimiento que toma un
     procedimiento como argumento y devuelve un procedimiento como valor. Por
     ejemplo, para aproximar la derivada de @m(x ↦ x³) a 5 (cuyo valor exacto
     es 75) podemos evaluar

#      ..srci > scheme
#        > (define (cube x) (* x x x))
#        > ((deriv cube) 5)
#        75.00014999664018
#      < srci..
     ..srci > scheme
       > (define (cube x) (* x x x))
       > ((deriv cube) 5)
       75.00014999664018
     < srci..

#      With the aid of @c(deriv), we can express Newton's method as a fixed-point
#      process:
     Con la ayuda de @c(deriv), podemos expresar el método de Newton como un
     proceso de punto fijo:

#      ..src > scheme
#        (define (newton-transform g)
#          (lambda (x)
#            (- x (/ (g x)
#                    ((deriv g) x)))))
#
#        (define (newtons-method g guess)
#          (fixed-point (newton-transform g)
#                       guess))
#      < src..
     ..src > scheme
       (define (newton-transform g)
         (lambda (x)
           (- x (/ (g x)
                   ((deriv g) x)))))

       (define (newtons-method g guess)
         (fixed-point (newton-transform g)
                      guess))
     < src..

#      The @c(newton-transform) procedure expresses the formula at the beginning of
#      this section, and @c(newtons-method) is readily defined in terms of this.  It
#      takes as arguments a procedure that computes the function for which we want to
#      find a zero, together with an initial guess. For instance, to find the square
#      root of @m(x), we can use Newton's method to find a zero of the function @m(y
#      ↦ y² − x) starting with an initial guess of 1.@n(63)
     El procedimiento @c(newton-transform) expresa la fórmula al principio de
     esta sección, y @c(newtons-method) se define fácilmente en términos de
     este. Se toman como argumentos un procedimiento que calcula la función para
     la que queremos encontrar un cero, junto con una conjetura inicial. Por
     ejemplo, para encontrar la raíz cuadrada de @m(x), podemos usar el método
     Newton para encontrar un cero de la función @m(y ↦ y² − x) comenzando
     con una conjetura inicial de 1.@n(63)

#      This provides yet another form of the @c(square-root) procedure:
     Esto proporciona otra forma del procedimiento @c(square-root):

#      ..src > scheme
#        (define (sqrt x)
#          (newtons-method
#           (lambda (y)
#             (- (square y) x))
#           1.0))
#      < src..
     ..src > scheme
       (define (sqrt x)
         (newtons-method
          (lambda (y)
            (- (square y) x))
          1.0))
     < src..

# **** Abstractions and first-class procedures
**** Abstracciones y procedimientos de primera clase

#      We've seen two ways to express the @c(square-root) computation as an instance of a
#      more general method, once as a fixed-point search and once using Newton's
#      method. Since Newton's method was itself expressed as a fixed-point process,
#      we actually saw two ways to compute square roots as fixed points. Each method
#      begins with a function and finds a fixed point of some transformation of the
#      function. We can express this general idea itself as a procedure:
     Hemos visto dos maneras de expresar el cálculo @c(square-root) como una
     instancia de un método más general, tambien como una búsqueda de punto fijo
     y utilizando el método Newton. Dado que el método Newton se expresaba
     como un proceso de punto fijo, en realidad vimos dos maneras de calcular
     raíces cuadradas como puntos fijos. Cada método comienza con una función y
     encuentra un punto fijo de alguna transformación de la función. Podemos
     expresar esta idea general como un procedimiento:

#      ..src > scheme
#        (define (fixed-point-of-transform
#                 g transform guess)
#          (fixed-point (transform g) guess))
#      < src..
     ..src > scheme
       (define (fixed-point-of-transform
                g transform guess)
         (fixed-point (transform g) guess))
     < src..

#      This very general procedure takes as its arguments a procedure @c(g) that
#      computes some function, a procedure that transforms @c(g), and an initial
#      guess. The returned result is a fixed point of the transformed function.
     Este procedimiento basten general toma como argumentos un procedimiento
     @c(g) que computa alguna función, un procedimiento que transforma @c(g) y
     una conjetura inicial. El resultado devuelto es un punto fijo de la función
     transformada.

#      Using this abstraction, we can recast the first square-root computation from
#      this section (where we look for a fixed point of the average-damped version of
#      @m(y ↦ x/y)) as an instance of this general method:
     Usando esta abstracción, podemos plantear el primer cálculo de raiz cuadrada
     de esta sección (donde buscamos un punto fijo de la versión amortiguada
     promedio de @m(y ↦ x/y)) como una instancia de este método general:

#      ..src > scheme
#        (define (sqrt x)
#          (fixed-point-of-transform
#           (lambda (y) (/ x y))
#           average-damp
#           1.0))
#      < src..
     ..src > scheme
       (define (sqrt x)
         (fixed-point-of-transform
          (lambda (y) (/ x y))
          average-damp
          1.0))
     < src..

#      Similarly, we can express the second square-root computation from this section
#      (an instance of Newton's method that finds a fixed point of the Newton
#      transform of @m(y ↦ y² − x)) as
     Del mismo modo, podemos expresar el segundo cálculo de raíz cuadrada de
     esta sección (una instancia del método Newton que encuentra un punto
     fijo de la transformada de Newton de @m(y ↦ y² − x)) como

#      ..src > scheme
#        (define (sqrt x)
#          (fixed-point-of-transform
#           (lambda (y) (- (square y) x))
#           newton-transform
#           1.0))
#      < src..
     ..src > scheme
       (define (sqrt x)
         (fixed-point-of-transform
          (lambda (y) (- (square y) x))
          newton-transform
          1.0))
     < src..

#      We began section @l(#1.3) with the observation that compound procedures are a
#      crucial abstraction mechanism, because they permit us to express general
#      methods of computing as explicit elements in our programming language. Now
#      we've seen how higher-order procedures permit us to manipulate these general
#      methods to create further abstractions.
     Comenzamos la sección @l(#1.3) con la observación de que los procedimientos
     compuestos son un mecanismo de abstracción crucial, porque nos permiten
     expresar los métodos generales de computación como elementos explícitos en
     nuestro lenguaje de programación. Ahora hemos visto cómo los procedimientos
     de orden superior nos permiten manipular estos métodos generales para crear
     más abstracciones.

#      As programmers, we should be alert to opportunities to identify the underlying
#      abstractions in our programs and to build upon them and generalize them to
#      create more powerful abstractions. This is not to say that one should always
#      write programs in the most abstract way possible; expert programmers know how
#      to choose the level of abstraction appropriate to their task. But it is
#      important to be able to think in terms of these abstractions, so that we can
#      be ready to apply them in new contexts. The significance of higher-order
#      procedures is that they enable us to represent these abstractions explicitly
#      as elements in our programming language, so that they can be handled just like
#      other computational elements.
     Como programadores, debemos estar atentos a las oportunidades de
     identificar las abstracciones subyacentes en nuestros programas y construir
     sobre ellos y generalizarlos para crear abstracciones más poderosas. Esto
     no quiere decir que uno siempre debe escribir programas de la manera más
     abstracta posible; Los programadores expertos saben elegir el nivel de
     abstracción apropiado para su tarea. Pero es importante poder pensar en
     términos de estas abstracciones, para que podamos estar listos para
     aplicarlos en nuevos contextos. La importancia de los procedimientos de
     orden superior es que nos permiten representar explícitamente estas
     abstracciones como elementos en nuestro lenguaje de programación, para que
     puedan ser manejados como otros elementos computacionales.

#      In general, programming languages impose restrictions on the ways in which
#      computational elements can be manipulated. Elements with the fewest
#      restrictions are said to have @e(first-class) status. Some of the @"(rights
#      and privileges) of first-class elements are:@n(64)
     En general, los lenguajes de programación imponen restricciones a las
     formas en que los elementos computacionales pueden ser manipulados. Se dice
     que los elementos con la menor cantidad de restricciones tienen estatus de
     @e(primera clase). Algunos de los @"(derechos y privilegios) de los
     elementos de primera clase son:@n(64)

#      - They may be named by variables.
     - Pueden ser nombrados por variables.
#      - They may be passed as arguments to procedures.
     - Pueden pasar como argumentos a los procedimientos.
#      - They may be returned as the results of procedures.
     - Pueden ser devueltos como los resultados de los procedimientos.
#      - They may be included in data structures.@n(65)
     - Pueden ser incluidos en las estructuras de datos.@n(65)

#      Lisp, unlike other common programming languages, awards procedures full
#      first-class status. This poses challenges for efficient implementation, but
#      the resulting gain in expressive power is enormous.@n(66)
     Lisp, a diferencia de otros lenguajes de programación comunes, otorga
     procedimientos plenos de primera clase. Esto plantea retos para una
     implementación eficiente, pero la ganancia resultante en el poder expresivo
     es enorme.@n(66)

#      :: @t(Exercise 1.40) :: Define a procedure @c(cubic) that can be used together
#         with the @c(newtons-method) procedure in expressions of the form
     :: @t(Ejercicio 1.40) :: Definir un procedimiento @c(cubic) que se puede
        utilizar junto con el procedimiento @c(newtons-method) en las
        expresiones del formato

#         ..src > scheme
#           (newtons-method (cubic a b c) 1)
#         < src..
        ..src > scheme
          (newtons-method (cubic a b c) 1)
        < src..

#         to approximate zeros of the cubic @m(x³ + ax² + bx + c).
        Para aproximar ceros del cubo @m(x³ + ax² + bx + c).

#      :: @t(Exercise 1.41) :: Define a procedure @c(double) that takes a procedure
#         of one argument as argument and returns a procedure that applies the
#         original procedure twice. For example, if @c(inc) is a procedure that adds
#         1 to its argument, then @c[(double inc)] should be a procedure that
#         adds 2. What value is returned by
     :: @t(Ejercicio 1.41) :: Defina un procedimiento @c(double) que toma un
        procedimiento de un argumento como argumento y devuelve un procedimiento
        que aplica el procedimiento original dos veces. Por ejemplo, si @c(inc)
        es un procedimiento que añade 1 a su argumento, entonces @c[(double
        inc)] debe ser un procedimiento que agrega 2. ¿Qué valor es devuelto por

#         ..src > scheme
#           (((double (double double)) inc) 5)
#         < src..
        ..src > scheme
          (((double (double double)) inc) 5)
        < src..

#      :: @t(Exercise 1.42) :: Let @m(ƒ) and @m(g) be two one-argument functions. The
#         @e(composition) @m(ƒ) after @m(g) is defined to be the function @m[x ↦
#         ƒ(g(x))]. Define a procedure @c(compose) that implements composition. For
#         example, if @c(inc) is a procedure that adds 1 to its argument,
     :: @t(Ejercicio 1.42) :: Siendo que @m(ƒ) y @m(g) son dos funciones de un
     argumento. La @e(composición) @m(ƒ) después de @m(g) se define como la
     función @m[x ↦ ƒ(g(x))]. Defina un procedimiento @c(compose) que implemente
     la composición. Por ejemplo, si @c(inc) es un procedimiento que añade 1 a
     su argumento,

#         ..srci > scheme
#           > ((compose square inc) 6)
#           49
#         < srci..
        ..srci > scheme
          > ((compose square inc) 6)
          49
        < srci..

#      :: @t(Exercise 1.43) :: If @m(ƒ) is a numerical function and @m(n) is a
#         positive integer, then we can form the @m(nᵗʰ) repeated application of
#         @m(ƒ), which is defined to be the function whose value at @m(x) is @m[ƒ(ƒ(…
#         (ƒ(x))…))]. For example, if @m(ƒ) is the function @m(x ↦ x + 1), then the
#         @m(nᵗʰ) repeated application of @m(ƒ) is the function @m(x ↦ x + n). If
#         @m(ƒ) is the operation of squaring a number, then the @m(nᵗʰ) repeated
#         application of @m(ƒ) is the function that raises its argument to the
#         @m(2ⁿ-th) power. Write a procedure that takes as inputs a procedure that
#         computes @m(ƒ) and a positive integer @m(n) and returns the procedure that
#         computes the @m(nᵗʰ) repeated application of @m(ƒ). Your procedure should
#         be able to be used as follows:
     :: @t(Ejercicio 1.43) :: Si @m(ƒ) es una función numérica y @m(n) es un
        entero positivo, entonces podemos formar la aplicación de @m(ƒ) repetida
        @m(nᵗʰ), que se define como la función cuyo valor en @m(x) es
        @m[ƒ(ƒ(…(ƒ(x))…))]. Por ejemplo, si @m(ƒ) es la función @m(x ↦ x + 1),
        entonces el @m(nᵗʰ) aplicación repetida de @m(ƒ) es la función @m(x ↦
        x + n). Si @m(ƒ) es la operación de elevar al cuadrado un número,
        entonces la @m(nᵗʰ) aplicación repetida de @m(ƒ) es la función que eleva
        su argumento a la @m(2ⁿ-ésima) potencia. Escribir un procedimiento que
        toma como entradas un procedimiento que calcula @m(ƒ) y un entero
        positivo @m(n) y devuelve el procedimiento que calcula la aplicación
        repetida @m(nᵗʰ) de @m(ƒ). Su procedimiento debe ser capaz de ser
        utilizado de la siguiente manera:

#         ..srci > scheme
#           > ((repeated square 2) 5)
#           625
#         < srci..
        ..srci > scheme
          > ((repeated square 2) 5)
          625
        < srci..

#         Hint: You may find it convenient to use @c(compose) from @l(#Exercise
#         1.42).
        Sugerencia: Puede resultar conveniente utilizarlo @c(compose) del
        @l(#Ejercicio 1.42).

#      :: @t(Exercise 1.44) :: The idea of @e(smoothing) a function is an important
#         concept in signal processing. If @m(ƒ) is a function and @m(dx) is some
#         small number, then the smoothed version of @m(ƒ) is the function whose
#         value at a point @m(x) is the average of @m[ƒ(x − dx)], @m[ƒ(x)], and
#         @m[ƒ(x + dx)]. Write a procedure @c(smooth) that takes as input a procedure
#         that computes @m(ƒ) and returns a procedure that computes the smoothed
#         @m(ƒ). It is sometimes valuable to repeatedly smooth a function (that is,
#         smooth the smoothed function, and so on) to obtain the @e(@i{n}-fold
#         smoothed function). Show how to generate the @i{n}-fold smoothed function
#         of any given function using @c(smooth) and @c(repeated) from @l(#Exercise
#         1.43).
     :: @t(Ejercicio 1.44) :: La idea de @e(suavizar) una función es un concepto
        importante en el procesamiento de señales. Si @m(ƒ) es una función y
        @m(dx) es un número pequeño, entonces la versión suavizada de @m(ƒ) es
        la función cuyo valor en un punto @m(x) es la media de @m[ƒ(x − dx)],
        @m[ƒ(x)], y @m[ƒ(x + dx)]. Escriba un procedimiento @c(smooth) que toma
        como entrada un procedimiento que calcula @m(ƒ) y devuelve un
        procedimiento que calcula @m(ƒ) suavisado. A veces es valioso suavizar
        repetidamente una función (es decir, suavizar la función suavizada, y
        así sucesivamente) para obtener la @e(función suavizada @i(n)-plegada)
        de cualquier funcion dada usando @c(smooth) del @l(#Ejercicio 1.43)

#      :: @t(Exercise 1.45) :: We saw in section @l(#1.3.3) that attempting to compute square
#         roots by naively finding a fixed point of @m(y ↦ x/y) does not converge,
#         and that this can be fixed by average damping. The same method works for
#         finding cube roots as fixed points of the average-damped @m(y ↦ x /
#         y²). Unfortunately, the process does not work for fourth roots––a single
#         average damp is not enough to make a fixed-point search for @m(y ↦ x/y³)
#         converge. On the other hand, if we average damp twice (i.e., use the
#         average damp of the average damp of @m(y ↦ x/y³) the fixed-point search
#         does converge. Do some experiments to determine how many average damps are
#         required to compute @m(nᵗʰ) roots as a fixed-point search based upon
#         repeated average damping of @m(y ↦ x/yⁿ⁻¹).  Use this to implement a
#         simple procedure for computing @m(nᵗʰ) roots using @c(fixed-point),
#         @c(average-damp), and the @c(repeated) procedure of @l(#Exercise
#         1.43). Assume that any arithmetic operations you need are available as
#         primitives.
     :: @t(Ejercicio 1.45) :: Vimos en la seccion @l(#1.3.3) que el intento de
        calcular las raíces cuadradas por encontrar ingenuamente un punto fijo
        de @m(y ↦ x/y) no converge, y que esto puede ser fijado por
        amortiguamiento promedio. El mismo método funciona para encontrar raíces
        cúbicas como puntos fijos de amortiguamiento promedio @m(y ↦ x/y²).
        Desafortunadamente, el proceso no funciona para las raíces
        cuadraticas––un amortiguamiento promedio no es suficiente para hacer una
        búsqueda de punto fijo para converger @m(y ↦ x/y³). Por otro lado, si
        @m(medimos) el amortiguamiento dos veces (es decir, usamos el
        amortiguamiento promedio del amortiguamiento promedio de @m(y ↦ x/y³) la
        búsqueda de punto fijo converge. Hacer algunos experimentos para
        determinar cuántos amortiguamientos promedio se requieren para calcular
        la enesima raiz como una búsqueda de punto fijo sobre la base de
        amortiguamiento promedio repetida de @m(y ↦ x/yⁿ⁻¹). Usar esto para poner
        en práctica un procedimiento simple para calcular las @m(nᵗʰ) raíces usando
        @c(fixed-point), @c(average-damp) y el procedimiento @c(repeated) del
        @l(#Ejercicio 1.43). Suponga que las operaciones aritméticas que
        necesita están disponibles como primitivas.

#      :: @t(Exercise 1.46) :: Several of the numerical methods
#         described in this chapter are instances of an extremely general computational
#         strategy known as @e(iterative improvement). Iterative improvement says
#         that, to compute something, we start with an initial guess for the answer, test
#         if the guess is good enough, and otherwise improve the guess and continue the
#         process using the improved guess as the new guess. Write a procedure
#         @c(iterative-improve) that takes two procedures as arguments: a method for
#         telling whether a guess is good enough and a method for improving a guess.
#         @c(iterative-improve) should return as its value a procedure that takes a
#         guess as argument and keeps improving the guess until it is good enough.
#         Rewrite the @c(sqrt) procedure of section @l(#1.1.7) and the
#         @c(fixed-point) procedure of section @l(#1.3.3) in terms of
#         @c(iterative-improve).
     :: @t(Ejercicio 1.46) :: Varios de los métodos numéricos descritos en este
        capítulo son ejemplos de una estrategia computacional extremadamente
        general conocida como @e(mejora iterativa). La mejora iterativa dice
        que, para calcular algo, empezamos con una conjetura inicial para la
        respuesta, probamos si la suposición es lo suficientemente buena y
        mejoramos la conjetura y continuamos el proceso usando la conjetura
        mejorada como nueva conjetura. Escriba un procedimiento
        @c(iterative-improve) que tome dos procedimientos como argumentos: un
        método para decir si una suposición es lo suficientemente buena y un
        método para mejorar una conjetura. @c(iterative-improve) debe devolver
        como su valor un procedimiento que toma una suposición como argumento y
        sigue mejorando la conjetura hasta que es lo suficientemente bueno.
        Reescribir el procedimiento @c(sqrt) de la seccion @l(#1.1.7) y el
        procedimiento @c(fixed-point) de la seccion @l(#1.3.3)
        @c(iterative-improve)

# * Chapter 2 <> Building Abstractions with Data
* Capitulo 2 <> Creación de abstracciones con datos

#   ..quote >
  ..quote >
#     We now come to the decisive step of mathematical abstraction: we forget
#     about what the symbols stand for. … [The mathematician] need not be idle;
#     there are many operations which he may carry out with these symbols, without
#     ever having to look at the things they stand for.
    Ahora llegamos al paso decisivo de la abstracción matemática: olvidamos lo
    que significan los símbolos. ... [El matemático] no necesita estar ocioso;
    Hay muchas operaciones que puede llevar a cabo con estos símbolos, sin tener
    que mirar nunca las cosas que representan.

#     --Hermann Weyl, @q(The Mathematical Way of Thinking)
    --Hermann Weyl, @q(The Mathematical Way of Thinking)
#   < quote..
  < quote..

#   We concentrated in @l(#Chapter 1) on computational processes and on the role
#   of procedures in program design. We saw how to use primitive data (numbers)
#   and primitive operations (arithmetic operations), how to combine procedures to
#   form compound procedures through composition, conditionals, and the use of
#   parameters, and how to abstract procedures by using @c(define). We saw that a
#   procedure can be regarded as a pattern for the local evolution of a process,
#   and we classified, reasoned about, and performed simple algorithmic analyses
#   of some common patterns for processes as embodied in procedures. We also saw
#   that higher-order procedures enhance the power of our language by enabling us
#   to manipulate, and thereby to reason in terms of, general methods of
#   computation.  This is much of the essence of programming.
  Nos concentramos en el @l(Capitulo 1) sobre los procesos
  computacionales y sobre el papel de los procedimientos en el diseño del
  programa. Vimos cómo usar datos primitivos (números) y operaciones primitivas
  (operaciones aritméticas), cómo combinar procedimientos para formar
  procedimientos compuestos a través de la composición, condicionales, y el uso
  de parámetros, y cómo abstraer procedimientos usando @c(define). Vimos que un
  procedimiento puede considerarse como un patrón para la evolución local de un
  proceso, y clasificamos, razonamos y realizamos análisis algorítmicos simples
  de algunos patrones comunes para procesos tal como se incorporan en
  procedimientos. También vimos que los procedimientos de orden superior
  aumentan el poder de nuestro lenguaje al permitirnos manipular y por lo tanto
  razonar en términos de métodos generales de computación. Esto es mucho de la
  esencia de la programación.

#   In this chapter we are going to look at more complex data. All the procedures
#   in chapter 1 operate on simple numerical data, and simple data are not
#   sufficient for many of the problems we wish to address using computation.
#   Programs are typically designed to model complex phenomena, and more often
#   than not one must construct computational objects that have several parts in
#   order to model real-world phenomena that have several aspects. Thus, whereas
#   our focus in chapter 1 was on building abstractions by combining procedures to
#   form compound procedures, we turn in this chapter to another key aspect of any
#   programming language: the means it provides for building abstractions by
#   combining data objects to form @e(compound data).
  En este capítulo vamos a ver datos más complejos. Todos los procedimientos del
  capítulo 1 funcionan con datos numéricos sencillos, y los datos simples no son
  suficientes para muchos de los problemas que queremos abordar mediante el
  cálculo. Los programas suelen ser diseñados para modelar fenómenos complejos,
  y más a menudo que no se debe construir objetos computacionales que tienen
  varias partes con el fin de modelar los fenómenos del mundo real que tienen
  varios aspectos. Por lo tanto, mientras que nuestro enfoque en el capítulo 1
  estaba en la construcción de abstracciones mediante la combinación de
  procedimientos para formar procedimientos compuestos, pasamos a este capítulo
  a otro aspecto clave de cualquier lenguaje de programación: los medios que
  proporciona para crear abstracciones combinando objetos de datos para formar
  @e(datos compuestos).

#   Why do we want compound data in a programming language?  For the same reasons
#   that we want compound procedures: to elevate the conceptual level at which we
#   can design our programs, to increase the modularity of our designs, and to
#   enhance the expressive power of our language. Just as the ability to define
#   procedures enables us to deal with processes at a higher conceptual level than
#   that of the primitive operations of the language, the ability to construct
#   compound data objects enables us to deal with data at a higher conceptual
#   level than that of the primitive data objects of the language.
  ¿Por qué queremos datos compuestos en un lenguaje de programación? Por las
  mismas razones que queremos que sean procedimientos compuestos: elevar el
  nivel conceptual en el que podemos diseñar nuestros programas, aumentar la
  modularidad de nuestros diseños y mejorar el poder expresivo de nuestro
  lenguaje. Así como la capacidad de definir procedimientos nos permite lidiar
  con procesos a un nivel conceptual más alto que el de las operaciones
  primitivas del lenguaje, la capacidad de construir objetos de datos compuestos
  nos permite tratar con datos a un nivel conceptual más alto que el de la
  Objetos de datos primitivos del lenguaje.

#   Consider the task of designing a system to perform arithmetic with rational
#   numbers. We could imagine an operation @c(add-rat) that takes two rational
#   numbers and produces their sum. In terms of simple data, a rational number can
#   be thought of as two integers: a numerator and a denominator. Thus, we could
#   design a program in which each rational number would be represented by two
#   integers (a numerator and a denominator) and where @c(add-rat) would be
#   implemented by two procedures (one producing the numerator of the sum and one
#   producing the denominator). But this would be awkward, because we would then
#   need to explicitly keep track of which numerators corresponded to which
#   denominators. In a system intended to perform many operations on many rational
#   numbers, such bookkeeping details would clutter the programs substantially, to
#   say nothing of what they would do to our minds. It would be much better if we
#   could @"(glue together) a numerator and denominator to form a pair––a
#   @e(compound data object)––that our programs could manipulate in a way that
#   would be consistent with regarding a rational number as a single conceptual
#   unit.
  Considere la tarea de diseñar un sistema para realizar la aritmética con
  números racionales. Podemos imaginar una operación @c(add-rat) que toma dos
  números racionales y produce su suma. En términos de datos simples, un número
  racional puede ser pensado como dos enteros: un numerador y un
  denominador. Así, podríamos diseñar un programa en el que cada número racional
  sería representado por dos enteros (un numerador y un denominador) y donde
  @c(add-rat) se implementaría mediante dos procedimientos (uno produciendo el
  numerador de la suma y otro produciendo el denominador). Pero esto sería
  incómodo, porque entonces tendríamos que seguir explícitamente qué numeradores
  correspondían a qué denominadores. En un sistema destinado a realizar muchas
  operaciones en muchos números racionales, tales detalles de contabilidad
  desordenarían los programas sustancialmente, Por no hablar de lo que harían
  con nuestras mentes. @"(Sería mucho mejor si pudiéramos unir) un numerador y
  un denominador para formar un par - un @e(objeto compuesto de datos) - que
  nuestros programas pudieran manipular de una manera que sería consistente con
  considerar un número racional como una unidad conceptual única.

#   The use of compound data also enables us to increase the modularity of our
#   programs. If we can manipulate rational numbers directly as objects in their
#   own right, then we can separate the part of our program that deals with
#   rational numbers per se from the details of how rational numbers may be
#   represented as pairs of integers. The general technique of isolating the parts
#   of a program that deal with how data objects are represented from the parts of
#   a program that deal with how data objects are used is a powerful design
#   methodology called @e(data abstraction). We will see how data abstraction
#   makes programs much easier to design, maintain, and modify.
  El uso de datos compuestos también nos permite aumentar la modularidad de
  nuestros programas. Si podemos manipular los números racionales directamente
  como objetos por derecho propio, entonces podemos separar la parte de nuestro
  programa que trata de los números racionales per se a partir de los detalles
  de cómo los números racionales pueden representarse como pares de números
  enteros. La técnica general de aislar las partes de un programa que se ocupan
  de cómo se representan los objetos de datos de las partes de un programa que
  se ocupan de cómo se utilizan los objetos de datos es una poderosa metodología
  de diseño llamada @e(abstracción de datos). Veremos cómo la abstracción de
  datos hace que los programas sean mucho más fáciles de diseñar, mantener y
  modificar.

#   The use of compound data leads to a real increase in the expressive power of
#   our programming language. Consider the idea of forming a @"(linear
#   combination) @m(ax + by). We might like to write a procedure that would accept
#   @m(a), @m(b), @m(x), and @m(y) as arguments and return the value of @m(ax +
#   by). This presents no difficulty if the arguments are to be numbers, because
#   we can readily define the procedure
  El uso de datos compuestos conduce a un aumento real en el poder expresivo de
  nuestro lenguaje de programación. Considere la idea de formar una
  @"(combinación lineal ) @m(ax + by). Nos gustaría escribir un procedimiento
  que aceptaría @m(a), @m(b), @m(x), y @m(y) como argumentos y devuelve el
  valor de @m(ax + by). Esto no presenta ninguna dificultad si los argumentos
  son números, porque podemos definir fácilmente el procedimiento

#   ..src > scheme
#     (define (linear-combination a b x y)
#       (+ (* a x) (* b y)))
#   < src..
  ..src > scheme
    (define (linear-combination a b x y)
      (+ (* a x) (* b y)))
  < src..

#   But suppose we are not concerned only with numbers. Suppose we would like to
#   express, in procedural terms, the idea that one can form linear combinations
#   whenever addition and multiplication are defined––for rational numbers,
#   complex numbers, polynomials, or whatever. We could express this as a
#   procedure of the form
  Pero supongamos que no nos interesan sólo los números. Supongamos que queremos
  expresar, en términos de procedimiento, la idea de que se pueden formar
  combinaciones lineales siempre que se definan la adición y la multiplicación -
  para números racionales, números complejos, polinomios o lo que sea. Podríamos
  expresarlo como un procedimiento del formulario

#   ..src > scheme
#     (define (linear-combination a b x y)
#       (add (mul a x) (mul b y)))
#   < src..
  ..src > scheme
    (define (linear-combination a b x y)
      (add (mul a x) (mul b y)))
  < src..

#   where @c(add) and @c(mul) are not the primitive procedures @c(+) and @c(*) but
#   rather more complex things that will perform the appropriate operations for
#   whatever kinds of data we pass in as the arguments @c(a), @c(b), @c(x), and
#   @c(y). The key point is that the only thing @c(linear-combination) should need
#   to know about @c(a), @c(b), @c(x), and @c(y) is that the procedures @c(add)
#   and @c(mul) will perform the appropriate manipulations. From the perspective
#   of the procedure @c(linear-combination), it is irrelevant what @c(a), @c(b),
#   @c(x), and @c(y) are and even more irrelevant how they might happen to be
#   represented in terms of more primitive data. This same example shows why it is
#   important that our programming language provide the ability to manipulate
#   compound objects directly: Without this, there is no way for a procedure such
#   as @c(linear-combination) to pass its arguments along to @c(add) and @c(mul)
#   without having to know their detailed structure.@n(67)
  donde @c(add) y @c(mul) no son los procedimientos primitivos @c(+) y @c(*)
  pero las cosas bastante más complejas que llevarán a cabo las operaciones
  apropiadas para cualquier tipo de datos que pase en los argumentos como @c(a),
  @c(b), @c(x), y @c(y). El punto clave es que lo único que
  @c(linear-combination) debería necesitar saber acerca de @c(a), @c(b), @c(x),
  y @c(y) es que los procedimientos @c(add) y @c(mul) llevará a cabo las
  manipulaciones apropiadas. Desde el punto de vista del procedimiento
  @c(linear-combination), es irrelevante lo que @c(a), @c(b), @c(x), y @c(y) son
  aún más irrelevante y cómo podrían pasar a ser representado en términos de
  datos más primitivas. @c(linear-combination) Este mismo ejemplo muestra por
  qué es importante que nuestro lenguaje de programación proporcione la
  capacidad de manipular objetos compuestos directamente: Sin esto, no hay forma
  de un procedimiento tal como pasar sus argumentos a lo largo de @c(add) y
  @c(mul) sin tener que conocer su estructura detallada.@n(67)

#   We begin this chapter by implementing the rational-number arithmetic system
#   mentioned above. This will form the background for our discussion of compound
#   data and data abstraction. As with compound procedures, the main issue to be
#   addressed is that of abstraction as a technique for coping with complexity,
#   and we will see how data abstraction enables us to erect suitable
#   @e(abstraction barriers) between different parts of a program.
  Comenzamos este capítulo implementando el sistema aritmético de números
  racionales mencionado anteriormente. Esto formará el fondo para nuestra
  discusión de datos compuestos y abstracción de datos. Al igual que con los
  procedimientos compuestos, el tema principal a tratar es el de la abstracción
  como una técnica para hacer frente a la complejidad, y veremos cómo la
  abstracción de datos nos permite erigir @e(barreras de abstracción) adecuadas
  entre las diferentes partes de un programa.

#   We will see that the key to forming compound data is that a programming
#   language should provide some kind of @"(glue) so that data objects can be
#   combined to form more complex data objects. There are many possible kinds of
#   glue. Indeed, we will discover how to form compound data using no special
#   @"(data) operations at all, only procedures. This will further blur the
#   distinction between @"(procedure) and @"(data,) which was already becoming
#   tenuous toward the end of chapter 1. We will also explore some conventional
#   techniques for representing sequences and trees. One key idea in dealing with
#   compound data is the notion of @e(closure)––that the glue we use for combining
#   data objects should allow us to combine not only primitive data objects, but
#   compound data objects as well. Another key idea is that compound data objects
#   can serve as @e(conventional interfaces) for combining program modules in
#   mix-and-match ways. We illustrate some of these ideas by presenting a simple
#   graphics language that exploits closure.
  Veremos que la clave para formar datos compuestos es que un lenguaje de
  programación debe proporcionar algún tipo de @"(pegamento) para que los
  objetos de datos puedan combinarse para formar objetos de datos más
  complejos. Hay muchos tipos posibles de pegamento. De hecho, vamos a descubrir
  cómo formar datos compuestos sin operaciones de @"(datos) especiales en
  absoluto, sólo los procedimientos. Esto distorsionará aún más la distinción
  entre @"(procedimiento) y @"(datos,) que ya se estaba volviendo tenue hacia el
  final del capítulo 1. También exploraremos algunas técnicas convencionales
  para representar secuencias y árboles. Una idea clave al tratar con los datos
  compuestos es la noción de @e(cierre) - que el pegamento que usamos para
  combinar objetos de datos debe permitirnos combinar no sólo objetos de datos
  primitivos, Sino también objetos de datos compuestos. @e(Otra idea clave es
  que los objetos de datos compuestos pueden servir como interfaces
  convencionales) para combinar módulos de programa de manera
  mix-and-match. Ilustramos algunas de estas ideas presentando un lenguaje
  gráfico simple que explora el cierre.

#   We will then augment the representational power of our language by introducing
#   @e(symbolic expressions)––data whose elementary parts can be arbitrary symbols
#   rather than only numbers. We explore various alternatives for representing
#   sets of objects. We will find that, just as a given numerical function can be
#   computed by many different computational processes, there are many ways in
#   which a given data structure can be represented in terms of simpler objects,
#   and the choice of representation can have significant impact on the time and
#   space requirements of processes that manipulate the data. We will investigate
#   these ideas in the context of symbolic differentiation, the representation of
#   sets, and the encoding of information.
  Aumentaremos entonces el poder de representación de nuestro lenguaje
  introduciendo @e(expresiones simbólicas) -datos cuyas partes elementales
  pueden ser símbolos arbitrarios y no sólo números. Exploramos varias
  alternativas para representar conjuntos de objetos. Encontraremos que, así
  como una función numérica dada puede ser computada por muchos procesos
  computacionales diferentes, hay muchas maneras en que una estructura de datos
  dada puede representarse en términos de objetos más simples, y la elección de
  la representación puede tener un impacto significativo en la Tiempo y espacio
  de los procesos que manipulan los datos. Investigaremos estas ideas en el
  contexto de la diferenciación simbólica, la representación de los conjuntos y
  la codificación de la información.

#   Next we will take up the problem of working with data that may be represented
#   differently by different parts of a program. This leads to the need to
#   implement @e(generic operations), which must handle many different types of
#   data. Maintaining modularity in the presence of generic operations requires
#   more powerful abstraction barriers than can be erected with simple data
#   abstraction alone. In particular, we introduce @e(data-directed programming)
#   as a technique that allows individual data representations to be designed in
#   isolation and then combined @e(additively) (i.e., without modification). To
#   illustrate the power of this approach to system design, we close the chapter
#   by applying what we have learned to the implementation of a package for
#   performing symbolic arithmetic on polynomials, in which the coefficients of
#   the polynomials can be integers, rational numbers, complex numbers, and even
#   other polynomials.
  A continuación abordaremos el problema de trabajar con datos que pueden ser
  representados de manera diferente por diferentes partes de un programa. Esto
  lleva a la necesidad de implementar @e(operaciones genéricas), que deben
  manejar muchos tipos diferentes de datos. Mantener la modularidad en la
  presencia de operaciones genéricas requiere barreras de abstracción más
  poderosas que las que pueden ser erigidas con la simple abstracción de
  datos. En particular, introducimos @e(la programación dirigida a datos) como
  una técnica que permite diseñar las representaciones individuales de datos de
  forma aislada y combinarlas de forma @e(aditiva) (es decir, sin
  modificaciones). Para ilustrar el poder de este enfoque al diseño del sistema,
  cerramos el capítulo aplicando lo que hemos aprendido a la implementación de
  un paquete para realizar la aritmética simbólica en polinomios,

# ** 2.1 <> Introduction to Data Abstraction
** 2.1 <> Introducción a la abstracción de datos

#    in section @l(#1.1.8), we noted that a procedure used as an element in creating a more
#    complex procedure could be regarded not only as a collection of particular
#    operations but also as a procedural abstraction. That is, the details of how
#    the procedure was implemented could be suppressed, and the particular
#    procedure itself could be replaced by any other procedure with the same
#    overall behavior. In other words, we could make an abstraction that would
#    separate the way the procedure would be used from the details of how the
#    procedure would be implemented in terms of more primitive procedures. The
#    analogous notion for compound data is called @e(data abstraction). Data
#    abstraction is a methodology that enables us to isolate how a compound data
#    object is used from the details of how it is constructed from more primitive
#    data objects.
   en la seccion @l(#1.1.8), observamos que un procedimiento utilizado como elemento
   en la creación de un procedimiento más complejo podría considerarse no sólo
   como una colección de operaciones particulares, sino también como una
   abstracción procesal. Es decir, los detalles de cómo se implementó el
   procedimiento podrían ser suprimidos y el propio procedimiento en sí podría
   ser reemplazado por cualquier otro procedimiento con el mismo comportamiento
   general. En otras palabras, podríamos hacer una abstracción que separaría la
   forma en que se usaría el procedimiento de los detalles de cómo se
   implementaría el procedimiento en términos de procedimientos más
   primitivos. La noción análoga para los datos compuestos se llama
   @e(abstracción de datos).

#    The basic idea of data abstraction is to structure the programs that are to
#    use compound data objects so that they operate on @"(abstract data.) That is,
#    our programs should use data in such a way as to make no assumptions about the
#    data that are not strictly necessary for performing the task at hand. At the
#    same time, a @"(concrete) data representation is defined independent of the
#    programs that use the data. The interface between these two parts of our
#    system will be a set of procedures, called @e(selectors) and @e(constructors),
#    that implement the abstract data in terms of the concrete representation. To
#    illustrate this technique, we will consider how to design a set of procedures
#    for manipulating rational numbers.
   La idea básica de la abstracción de datos es estructurar los programas que
   utilizan objetos de datos compuestos para que funcionen con @"(datos
   abstractos. ) Es decir, nuestros programas deben utilizar los datos de tal
   manera que no hagan suposiciones sobre los datos que no son estrictamente
   necesarios para realizar la tarea en cuestión. Al mismo tiempo, una
   representación @"(concreta de) datos se define independientemente de los
   programas que utilizan los datos. La interfaz entre estas dos partes de
   nuestro sistema será un conjunto de procedimientos, llamados @e(selectores) y
   @e(constructores), que implementarán los datos abstractos en términos de la
   representación concreta. Para ilustrar esta técnica, consideraremos cómo
   diseñar un conjunto de procedimientos para manipular números racionales.

# *** 2.1.1 <> Example: Arithmetic Operations for Rational Numbers
*** 2.1.1 <> Ejemplo: Operaciones aritméticas para números racionales

#     Suppose we want to do arithmetic with rational numbers. We want to be able to
#     add, subtract, multiply, and divide them and to test whether two rational
#     numbers are equal.
    Supongamos que queremos hacer la aritmética con números racionales. Queremos
    ser capaces de sumar, restar, multiplicar y dividir y probar si dos números
    racionales son iguales.

#     Let us begin by assuming that we already have a way of constructing a rational
#     number from a numerator and a denominator. We also assume that, given a
#     rational number, we have a way of extracting (or selecting) its numerator and
#     its denominator. Let us further assume that the constructor and selectors are
#     available as procedures:
    Comencemos por suponer que ya tenemos una manera de construir un número
    racional a partir de un numerador y un denominador. También suponemos que,
    dado un número racional, tenemos una manera de extraer (o seleccionar) su
    numerador y su denominador. Supongamos además que el constructor y los
    selectores están disponibles como procedimientos:

#     - @c[(make-rat ⟨n⟩ ⟨d⟩)] returns the rational number whose numerator is the
#       integer @c(⟨n⟩) and whose denominator is the integer @c(⟨d⟩).
    - @c[(make-rat ⟨n⟩ ⟨d⟩)] Devuelve el número racional cuyo numerador es el
      entero @c(⟨n⟩) y cuyo denominador es el entero @c(⟨d⟩).

#     - @c[(numer ⟨x⟩)] returns the numerator of the rational number @c(⟨x⟩).
    - @c[(numer ⟨x⟩)] Devuelve el numerador del número racional @c(⟨x⟩).

#     - @c[(denom ⟨x⟩)] returns the denominator of the rational number @c(⟨x⟩).
    - @c[(denom ⟨x⟩)] Devuelve el denominador del número racional @c(⟨x⟩).

#     We are using here a powerful strategy of synthesis: @e(wishful thinking).  We
#     haven't yet said how a rational number is represented, or how the procedures
#     @c(numer), @c(denom), and @c(make-rat) should be implemented. Even so, if we
#     did have these three procedures, we could then add, subtract, multiply,
#     divide, and test equality by using the following relations:
    Estamos utilizando aquí una poderosa estrategia de síntesis: el
    @e(pensamiento ilusorio). Todavía no hemos dicho cómo se representa un
    número racional, o cómo los procedimientos @c(numer), @c(denom) y
    @c(make-rat) se deben implementar. Aun así, si tuviéramos estos tres
    procedimientos, podríamos entonces sumar, restar, multiplicar, dividir y
    probar la igualdad usando las siguientes relaciones:

#     ..example >
#       n₁   n₂   n₁ d₂ + n₂ d₁
#       -- + -- = -------------
#       d₁   d₂       d₁ d₂
#
#       n₁   n₂   n₁ d₂ − n₂ d₁
#       -- − -- = -------------
#       d₁   d₂      d₁ d₂
#
#       n₁   n₂   n₁ n₂
#       -- ⋅ -- = -----
#       d₁   d₂   d₁ d₂
#
#       n₁ / d₁   n₁ d₂
#       ------- = -----
#       n₂ / d₂   d₁ n₂
#
#       n₁   n₂
#       -- = --  if and only if n₁ d₂ = n₂ d₁
#       d₁   d₂
#     < example..
    ..example >
      n₁   n₂   n₁ d₂ + n₂ d₁
      -- + -- = -------------
      d₁   d₂       d₁ d₂

      n₁   n₂   n₁ d₂ − n₂ d₁
      -- − -- = -------------
      d₁   d₂      d₁ d₂

      n₁   n₂   n₁ n₂
      -- ⋅ -- = -----
      d₁   d₂   d₁ d₂

      n₁ / d₁   n₁ d₂
      ------- = -----
      n₂ / d₂   d₁ n₂

      n₁   n₂
      -- = --  if and only if n₁ d₂ = n₂ d₁
      d₁   d₂
    < example..

#     We can express these rules as procedures:
    Podemos expresar estas reglas como procedimientos:

#     ..src > scheme
#       (define (add-rat x y)
#         (make-rat (+ (* (numer x) (denom y))
#                      (* (numer y) (denom x)))
#                   (* (denom x) (denom y))))
#
#       (define (sub-rat x y)
#         (make-rat (- (* (numer x) (denom y))
#                      (* (numer y) (denom x)))
#                   (* (denom x) (denom y))))
#
#       (define (mul-rat x y)
#         (make-rat (* (numer x) (numer y))
#                   (* (denom x) (denom y))))
#
#       (define (div-rat x y)
#         (make-rat (* (numer x) (denom y))
#                   (* (denom x) (numer y))))
#
#       (define (equal-rat? x y)
#         (= (* (numer x) (denom y))
#            (* (numer y) (denom x))))
#     < src..
    ..src > scheme
      (define (add-rat x y)
        (make-rat (+ (* (numer x) (denom y))
                     (* (numer y) (denom x)))
                  (* (denom x) (denom y))))

      (define (sub-rat x y)
        (make-rat (- (* (numer x) (denom y))
                     (* (numer y) (denom x)))
                  (* (denom x) (denom y))))

      (define (mul-rat x y)
        (make-rat (* (numer x) (numer y))
                  (* (denom x) (denom y))))

      (define (div-rat x y)
        (make-rat (* (numer x) (denom y))
                  (* (denom x) (numer y))))

      (define (equal-rat? x y)
        (= (* (numer x) (denom y))
           (* (numer y) (denom x))))
    < src..

#     Now we have the operations on rational numbers defined in terms of the
#     selector and constructor procedures @c(numer), @c(denom), and @c(make-rat).
#     But we haven't yet defined these. What we need is some way to glue together a
#     numerator and a denominator to form a rational number.
    Ahora tenemos las operaciones con números racionales definidos en términos
    de los procedimientos y de selector de constructores @c(numer), @c(denom) y
    @c(make-rat). Pero aún no los hemos definido. Lo que necesitamos es una
    forma de juntar un numerador y un denominador para formar un número
    racional.

# **** Pairs
**** Pares

#      To enable us to implement the concrete level of our data abstraction, our
#      language provides a compound structure called a @e(pair), which can be
#      constructed with the primitive procedure @c(cons). This procedure takes two
#      arguments and returns a compound data object that contains the two arguments
#      as parts. Given a pair, we can extract the parts using the primitive
#      procedures @c(car) and @c(cdr).@n(68) Thus, we can use @c(cons), @c(car), and
#      @c(cdr) as follows:
     Para poder implementar el nivel concreto de nuestra abstracción de datos,
     nuestro lenguaje proporciona una estructura compuesta llamada @e(par), que
     puede ser construida con el procedimiento primitivo @c(cons). Este
     procedimiento toma dos argumentos y devuelve un objeto de datos compuesto
     que contiene los dos argumentos como partes. Dado un par, podemos extraer
     las partes usando los procedimientos primitivos @c(car) y
     @c(cdr).@n(68) Por lo tanto, podemos utilizar @c(cons), @c(car) y
     @c(cdr) de la siguiente manera:

#      ..srci > scheme
#        > (define x (cons 1 2))
#        > (car x)
#        1
#        > (cdr x)
#        2
#      < srci..
     ..srci > scheme
       > (define x (cons 1 2))
       > (car x)
       1
       > (cdr x)
       2
     < srci..

#      Notice that a pair is a data object that can be given a name and manipulated,
#      just like a primitive data object. Moreover, @c(cons) can be used to form
#      pairs whose elements are pairs, and so on:
     Observe que un par es un objeto de datos al que se le puede dar un nombre y
     manipularlo, igual que un objeto de datos primitivo. Además, @c(cons)
     pueden utilizarse para formar pares cuyos elementos son pares, y así
     sucesivamente:

#      ..srci > scheme
#        > (define x (cons 1 2))
#        > (define y (cons 3 4))
#        > (define z (cons x y))
#        > (car (car z))
#        1
#        > (car (cdr z))
#        3
#      < srci..
     ..srci > scheme
       > (define x (cons 1 2))
       > (define y (cons 3 4))
       > (define z (cons x y))
       > (car (car z))
       1
       > (car (cdr z))
       3
     < srci..

#      in section @l(#2.2) we will see how this ability to combine pairs means that pairs can
#      be used as general-purpose building blocks to create all sorts of complex data
#      structures. The single compound-data primitive @e(pair), implemented by the
#      procedures @c(cons), @c(car), and @c(cdr), is the only glue we need. Data
#      objects constructed from pairs are called @e(list-structured) data.
     en la seccion @l(#2.2) veremos cómo esta capacidad de combinar pares significa
     que los pares pueden ser utilizados como bloques de construcción de
     propósito general para crear todo tipo de estructuras de datos
     complejas. La primitiva compuesto de datos único @e(par), implementado por
     los procedimientos @c(cons), @c(car) y @c(cdr), es la única pegamento que
     necesitamos. Los objetos de datos construidos a partir de pares se
     denominan datos @e(estructurados por listas).

# **** Representing rational numbers
**** Representando números racionales

#      Pairs offer a natural way to complete the rational-number system. Simply
#      represent a rational number as a pair of two integers: a numerator and a
#      denominator. Then @c(make-rat), @c(numer), and @c(denom) are readily
#      implemented as follows:@n(69)
     Los pares ofrecen una forma natural de completar el sistema de números
     racionales. Simplemente represente un número racional como un par de dos
     enteros: un numerador y un denominador. Luego @c(make-rat), @c(numer) y
     @c(denom) se implementan fácilmente de la siguiente manera:@n(69)

#      ..src > scheme
#        (define (make-rat n d) (cons n d))
#        (define (numer x) (car x))
#        (define (denom x) (cdr x))
#      < src..
     ..src > scheme
       (define (make-rat n d) (cons n d))
       (define (numer x) (car x))
       (define (denom x) (cdr x))
     < src..

#      Also, in order to display the results of our computations, we can print
#      rational numbers by printing the numerator, a slash, and the
#      denominator:@n(70)
     Además, para mostrar los resultados de nuestros cálculos, podemos imprimir
     números racionales imprimiendo el numerador, una barra y el denominador:
    @n(70)

#      ..src > scheme
#        (define (print-rat x)
#          (newline)
#          (display (numer x))
#          (display "/")
#          (display (denom x)))
#      < src..
     ..src > scheme
       (define (print-rat x)
         (newline)
         (display (numer x))
         (display "/")
         (display (denom x)))
     < src..

#      Now we can try our rational-number procedures:
     Ahora podemos probar nuestros procedimientos de números racionales:

#      ..srci > scheme
#        > (define one-half (make-rat 1 2))
#        > (print-rat one-half)
#        1/2
#        > (define one-third (make-rat 1 3))
#        > (print-rat
#        ^  (add-rat one-half one-third))
#        5/6
#        > (print-rat
#        ^  (mul-rat one-half one-third))
#        1/6
#        > (print-rat
#        ^  (add-rat one-third one-third))
#        6/9
#      < srci..
     ..srci > scheme
       > (define one-half (make-rat 1 2))
       > (print-rat one-half)
       1/2
       > (define one-third (make-rat 1 3))
       > (print-rat
       ^  (add-rat one-half one-third))
       5/6
       > (print-rat
       ^  (mul-rat one-half one-third))
       1/6
       > (print-rat
       ^  (add-rat one-third one-third))
       6/9
     < srci..

#      As the final example shows, our rational-number implementation does not reduce
#      rational numbers to lowest terms. We can remedy this by changing
#      @c(make-rat). If we have a @c(gcd) procedure like the one in section @l(#1.2.5) that
#      produces the greatest common divisor of two integers, we can use @c(gcd) to
#      reduce the numerator and the denominator to lowest terms before constructing
#      the pair:
     Como muestra el ejemplo final, nuestra implementación del número racional
     no reduce los números racionales a los términos más bajos. Podemos remediar
     esto cambiando @c(make-rat). Si tenemos un procedimiento @c(gcd) como el de
     @l(#1.2.5) que produce el mayor divisor común de dos enteros,
     podemos utilizar @c(gcd) para reducir el numerador y el denominador a los
     términos más bajos antes de construir el par:

#      ..src > scheme
#        (define (make-rat n d)
#          (let ((g (gcd n d)))
#            (cons (/ n g)
#                  (/ d g))))
#      < src..
     ..src > scheme
       (define (make-rat n d)
         (let ((g (gcd n d)))
           (cons (/ n g)
                 (/ d g))))
     < src..

#      Now we have
     Ahora tenemos

#      ..srci > scheme
#        > (print-rat
#        ^  (add-rat one-third one-third))
#        2/3
#      < srci..
     ..srci > scheme
       > (print-rat
       ^  (add-rat one-third one-third))
       2/3
     < srci..

#      as desired. This modification was accomplished by changing the constructor
#      @c(make-rat) without changing any of the procedures (such as @c(add-rat) and
#      @c(mul-rat)) that implement the actual operations.
     como se desee. Esta modificación se realizó cambiando el constructor
     @c(make-rat) sin cambiar ninguno de los procedimientos (como @c(add-rat) y
     @c(mul-rat)) que implementan las operaciones reales.

#      :: @t(Exercise 2.1) :: Define a better version of @c(make-rat) that handles
#         both positive and negative arguments.  @c(Make-rat) should normalize the
#         sign so that if the rational number is positive, both the numerator and
#         denominator are positive, and if the rational number is negative, only the
#         numerator is negative.
     :: @t(Ejercicio 2.1) :: Definir una mejor versión de @c(make-rat) que
        maneja ambos argumentos positivos y negativos.  @c(Make-rat) Debe
        normalizar el signo de modo que si el número racional es positivo, tanto
        el numerador como el denominador son positivos, y si el número racional
        es negativo, sólo el numerador es negativo.

# *** 2.1.2 <> Abstraction Barriers
*** 2.1.2 <> Barreras de la abstracción

#     Before continuing with more examples of compound data and data abstraction,
#     let us consider some of the issues raised by the rational-number example. We
#     defined the rational-number operations in terms of a constructor @c(make-rat)
#     and selectors @c(numer) and @c(denom). In general, the underlying idea of data
#     abstraction is to identify for each type of data object a basic set of
#     operations in terms of which all manipulations of data objects of that type
#     will be expressed, and then to use only those operations in manipulating the
#     data.
    Antes de continuar con más ejemplos de datos compuestos y abstracción de
    datos, consideremos algunas de las cuestiones planteadas por el ejemplo del
    número racional. Definimos las operaciones de números racionales en términos
    de un constructor @c(make-rat) y selectores @c(numer) y @c(denom). En
    general, la idea subyacente de la abstracción de datos es identificar para
    cada tipo de objeto de datos un conjunto básico de operaciones en términos
    de las cuales se expresarán todas las manipulaciones de objetos de datos de
    ese tipo y luego usar sólo aquellas operaciones en la manipulación de los
    datos.

#     We can envision the structure of the rational-number system as shown in
#     @l(#Figure 2.1). The horizontal lines represent @e(abstraction barriers) that
#     isolate different @"(levels) of the system. At each level, the barrier
#     separates the programs (above) that use the data abstraction from the programs
#     (below) that implement the data abstraction. Programs that use rational
#     numbers manipulate them solely in terms of the procedures supplied @"(for
#     public use) by the rational-number package: @c(add-rat), @c(sub-rat),
#     @c(mul-rat), @c(div-rat), and @c(equal-rat?). These, in turn, are implemented
#     solely in terms of the constructor and selectors @c(make-rat), @c(numer), and
#     @c(denom), which themselves are implemented in terms of pairs. The details of
#     how pairs are implemented are irrelevant to the rest of the rational-number
#     package so long as pairs can be manipulated by the use of @c(cons), @c(car),
#     and @c(cdr). In effect, procedures at each level are the interfaces that
#     define the abstraction barriers and connect the different levels.
    Podemos visualizar la estructura del sistema de números racionales como se
    muestra en la @l(#Figura 2.1). Las líneas horizontales
    representan @e(barreras de abstracción) que aíslan diferentes @"(niveles)
    del sistema. En cada nivel, la barrera separa los programas (arriba) que
    usan la abstracción de datos de los programas (abajo) que implementan la
    abstracción de datos. Los programas que utilizan números racionales ellos
    manipulan únicamente en términos de los procedimientos suministrados @"(para
    el uso público) por el paquete de números racionales: @c(add-rat),
    @c(sub-rat), @c(mul-rat), @c(div-rat), y @c(equal-rat?). Estos, a su vez, se
    implementan únicamente en términos de la constructor y selectores
    @c(make-rat), @c(numer) y @c(denom), que por sí mismos se implementan en
    términos de pares. @c(cons) Los detalles de cómo se implementan pares son
    irrelevantes para el resto del paquete número racional tanto tiempo como
    pares pueden ser manipulados por la utilización de, @c(car), y @c(cdr). En
    efecto, los procedimientos en cada nivel son las interfaces que definen las
    barreras de abstracción y conectan los diferentes niveles.

#     ..figure > @t(Figure 2.1) Data-abstraction barriers in the rational-number package.
    ..figure > @t(Figura 2.1) Barreras de abstracción de datos en el paquete de
      números racionales.

#       ..art >
#                 ╭────────────────────────────────────╮
#         ────────┤ Programs that use rational numbers ├────────
#                 ╰────────────────────────────────────╯
#                   Rational numbers in problem domain
#                     ╭───────────────────────────╮
#         ────────────┤   add-rat  sub-rat  ...   ├─────────────
#                     ╰───────────────────────────╯
#            Rational numbers as numerators and denominators
#                       ╭────────────────────────╮
#         ──────────────┤ make-rat  numer  denom ├──────────────
#                       ╰────────────────────────╯
#                       Rational numbers as pairs
#                           ╭────────────────╮
#         ──────────────────┤ cons  car  cdr ├──────────────────
#                           ╰────────────────╯
#                     However pairs are implemented
#       < art..
      ..art >
                ╭────────────────────────────────────╮
        ────────┤ Programs that use rational numbers ├────────
                ╰────────────────────────────────────╯
                  Rational numbers in problem domain
                    ╭───────────────────────────╮
        ────────────┤   add-rat  sub-rat  ...   ├─────────────
                    ╰───────────────────────────╯
           Rational numbers as numerators and denominators
                      ╭────────────────────────╮
        ──────────────┤ make-rat  numer  denom ├──────────────
                      ╰────────────────────────╯
                      Rational numbers as pairs
                          ╭────────────────╮
        ──────────────────┤ cons  car  cdr ├──────────────────
                          ╰────────────────╯
                    However pairs are implemented
      < art..

# @   ..img > img/chap2/Fig2.1d.std.svg
@   ..img > img/chap2/Fig2.1d.std.svg

#     This simple idea has many advantages. One advantage is that it makes programs
#     much easier to maintain and to modify. Any complex data structure can be
#     represented in a variety of ways with the primitive data structures provided
#     by a programming language. Of course, the choice of representation influences
#     the programs that operate on it; thus, if the representation were to be
#     changed at some later time, all such programs might have to be modified
#     accordingly. This task could be time-consuming and expensive in the case of
#     large programs unless the dependence on the representation were to be confined
#     by design to a very few program modules.
    Esta idea simple tiene muchas ventajas. Una ventaja es que hace que los
    programas sean mucho más fáciles de mantener y modificar. Cualquier
    estructura de datos compleja se puede representar en una variedad de formas
    con las estructuras de datos primitivas proporcionadas por un lenguaje de
    programación. Por supuesto, la elección de la representación influye en los
    programas que operan en ella; Por lo tanto, si la representación se cambiara
    en algún momento posterior, todos estos programas tendrían que ser
    modificados en consecuencia. Esta tarea podría ser costosa y costosa en el
    caso de los grandes programas, a menos que la dependencia de la
    representación se limitara por diseño a muy pocos módulos de programa.

#     For example, an alternate way to address the problem of reducing rational
#     numbers to lowest terms is to perform the reduction whenever we access the
#     parts of a rational number, rather than when we construct it. This leads to
#     different constructor and selector procedures:
    Por ejemplo, una manera alternativa de abordar el problema de reducir
    números racionales a los términos más bajos es realizar la reducción cada
    vez que accedemos a las partes de un número racional, en lugar de cuando lo
    construimos. Esto lleva a diferentes procedimientos constructor y selector:

#     ..src > scheme
#       (define (make-rat n d)
#         (cons n d))
#
#       (define (numer x)
#         (let ((g (gcd (car x) (cdr x))))
#           (/ (car x) g)))
#
#       (define (denom x)
#         (let ((g (gcd (car x) (cdr x))))
#           (/ (cdr x) g)))
#     < src..
    ..src > scheme
      (define (make-rat n d)
        (cons n d))

      (define (numer x)
        (let ((g (gcd (car x) (cdr x))))
          (/ (car x) g)))

      (define (denom x)
        (let ((g (gcd (car x) (cdr x))))
          (/ (cdr x) g)))
    < src..

#     The difference between this implementation and the previous one lies in when
#     we compute the @c(gcd). If in our typical use of rational numbers we access
#     the numerators and denominators of the same rational numbers many times, it
#     would be preferable to compute the @c(gcd) when the rational numbers are
#     constructed. If not, we may be better off waiting until access time to compute
#     the @c(gcd). In any case, when we change from one representation to the other,
#     the procedures @c(add-rat), @c(sub-rat), and so on do not have to be modified
#     at all.
    La diferencia entre esta implementación y la anterior está en el momento en
    que calculamos la @c(gcd). Si en nuestro uso típico de números racionales
    accedemos a los numeradores y denominadores de los mismos números racionales
    muchas veces, sería preferible calcular @c(gcd) cuándo se construyen los
    números racionales. Si no, podemos estar mejor esperando hasta que el tiempo
    de acceso para calcular el @c(gcd). En cualquier caso, cuando cambiamos de
    una representación a otra, los procedimientos @c(add-rat), @c(sub-rat) etc.,
    no tienen por qué ser modificados en absoluto.

#     Constraining the dependence on the representation to a few interface
#     procedures helps us design programs as well as modify them, because it allows
#     us to maintain the flexibility to consider alternate implementations. To
#     continue with our simple example, suppose we are designing a rational-number
#     package and we can't decide initially whether to perform the @c(gcd) at
#     construction time or at selection time. The data-abstraction methodology gives
#     us a way to defer that decision without losing the ability to make progress on
#     the rest of the system.
    Limitar la dependencia de la representación a unos pocos procedimientos de
    interfaz nos ayuda a diseñar programas y modificarlos, ya que nos permite
    mantener la flexibilidad para considerar implementaciones alternativas. Para
    continuar con nuestro ejemplo simple, supongamos que estamos diseñando un
    paquete de números racionales y no podemos decidir inicialmente si realizar
    el @c(gcd) tiempo de construcción o en el momento de la selección. La
    metodología de abstracción de datos nos da una forma de aplazar esa decisión
    sin perder la capacidad de avanzar en el resto del sistema.

#     :: @t(Exercise 2.2) :: Consider the problem of representing line segments in a
#        plane. Each segment is represented as a pair of points: a starting point
#        and an ending point. Define a constructor @c(make-segment) and selectors
#        @c(start-segment) and @c(end-segment) that define the representation of
#        segments in terms of points. Furthermore, a point can be represented as a
#        pair of numbers: the @m(x) coordinate and the @m(y)
#        coordinate. Accordingly, specify a constructor @c(make-point) and selectors
#        @c(x-point) and @c(y-point) that define this representation.  Finally,
#        using your selectors and constructors, define a procedure
#        @c(midpoint-segment) that takes a line segment as argument and returns its
#        midpoint (the point whose coordinates are the average of the coordinates of
#        the endpoints). To try your procedures, you'll need a way to print points:
    :: @t(Ejercicio 2.2) :: Considere el problema de representar segmentos de
       línea en un plano. Cada segmento se representa como un par de puntos: un
       punto inicial y un punto final. Definir un constructor @c(make-segment) y
       selectores @c(start-segment) y @c(end-segment) que definen la
       representación de segmentos en términos de puntos. Además, un punto puede
       ser representado como un par de números: el @m(x) de coordenadas y la
       @m(Y) de coordenadas. En consecuencia, especifique un constructor
       @c(make-point) y selectores @c(x-point) y @c(y-point) que definan esta
       representación. Por último, utilizando sus selectores y constructores,
       defina un procedimiento @c(midpoint-segment) que toma un segmento de
       línea como argumento y devuelve su punto medio (el punto cuyas
       coordenadas son la media de las coordenadas de los extremos). Para probar
       sus procedimientos, necesitará una forma de imprimir puntos:

#        ..src > scheme
#          (define (print-point p)
#            (newline)
#            (display "(")
#            (display (x-point p))
#            (display ",")
#            (display (y-point p))
#            (display ")"))
#        < src..
       ..src > scheme
         (define (print-point p)
           (newline)
           (display "(")
           (display (x-point p))
           (display ",")
           (display (y-point p))
           (display ")"))
       < src..

#     :: @t(Exercise 2.3) :: Implement a representation for rectangles in a
#        plane. (Hint: You may want to make use of @l(#Exercise 2.2).)  In terms of
#        your constructors and selectors, create procedures that compute the
#        perimeter and the area of a given rectangle. Now implement a different
#        representation for rectangles. Can you design your system with suitable
#        abstraction barriers, so that the same perimeter and area procedures will
#        work using either representation?
    :: @t(Ejercicio 2.3) :: Implemente una representación de rectángulos en un
       plano. (Sugerencia: Es posible que desee hacer uso del
       @l(#Ejercicio 2.2) .) En términos de sus constructores y
       selectores, crear procedimientos que calculan el perímetro y el área de
       un rectángulo dado. Ahora implemente una representación diferente para
       los rectángulos. ¿Puede diseñar su sistema con barreras de abstracción
       adecuadas, de modo que el mismo perímetro y los procedimientos de área
       funcionarán utilizando cualquiera de las representaciones?

# *** 2.1.3 <> What Is Meant by Data?
*** 2.1.3 <> ¿Qué es el significado de los datos?

#     We began the rational-number implementation in section @l(#2.1.1) by implementing the
#     rational-number operations @c(add-rat), @c(sub-rat), and so on in terms of
#     three unspecified procedures: @c(make-rat), @c(numer), and @c(denom). At that
#     point, we could think of the operations as being defined in terms of data
#     objects––numerators, denominators, and rational numbers––whose behavior was
#     specified by the latter three procedures.
    Comenzamos la implementación de números racionales en la seccion @l(#2.1.1)
    mediante la implementación de las operaciones de números racionales
    @c(add-rat), @c(sub-rat) y así sucesivamente en función de tres
    procedimientos no especificados: @c(make-rat), @c(numer), y @c(denom). En
    ese momento, podríamos pensar en las operaciones como definidas en términos
    de objetos de datos - numeradores, denominadores y números racionales - cuyo
    comportamiento fue especificado por los tres últimos procedimientos.

#     But exactly what is meant by @e(data)?  It is not enough to say @"(whatever is
#     implemented by the given selectors and constructors.)  Clearly, not every
#     arbitrary set of three procedures can serve as an appropriate basis for the
#     rational-number implementation. We need to guarantee that, if we construct a
#     rational number @c(x) from a pair of integers @c(n) and @c(d), then extracting
#     the @c(numer) and the @c(denom) of @c(x) and dividing them should yield the
#     same result as dividing @c(n) by @c(d).  In other words, @c(make-rat),
#     @c(numer), and @c(denom) must satisfy the condition that, for any integer
#     @c(n) and any non-zero integer @c(d), if @c(x) is @c[(make-rat n d)], then
    ¿Pero exactamente qué se entiende por @e(datos) ? No es suficiente decir
    @"(lo que es implementado por los selectores y constructores dados. )
    Claramente, no todos los conjuntos arbitrarios de tres procedimientos pueden
    servir como una base apropiada para la implementación del número
    racional. Necesitamos garantizar que si construimos un número racional a
    @c(x) partir de un par de números enteros @c(n) y @c(d), a continuación,
    extraer el @c(numer) y el @c(denom) de @c(x) y dividirlos debe dar el mismo
    resultado que dividir @c(n) por @c(d). En otras palabras, @c(make-rat),
    @c(numer), y @c(denom) debe satisfacer la condición de que, para cualquier
    número entero @c(n) y cualquier número entero no nulo @c(d), si @c(x) es
    @c[(make-rat n d)], entonces

#     ..example >
#       (numer x)    n
#       --------- = ---
#       (denom x)    d
#     < example..
    ..example >
      (numer x)    n
      --------- = ---
      (denom x)    d
    < example..

#     In fact, this is the only condition @c(make-rat), @c(numer), and @c(denom)
#     must fulfill in order to form a suitable basis for a rational-number
#     representation. In general, we can think of data as defined by some collection
#     of selectors and constructors, together with specified conditions that these
#     procedures must fulfill in order to be a valid representation.@n(71)
    De hecho, esta es la única condición @c(make-rat), @c(numer) y @c(denom)
    debe cumplir para formar una base adecuada para una representación del
    número racional. En general, podemos pensar en datos definidos por alguna
    colección de selectores y constructores, junto con las condiciones
    especificadas que estos procedimientos deben cumplir para ser una
    representación válida.@n(71)

#     This point of view can serve to define not only @"(high-level) data objects,
#     such as rational numbers, but lower-level objects as well. Consider the notion
#     of a pair, which we used in order to define our rational numbers. We never
#     actually said what a pair was, only that the language supplied procedures
#     @c(cons), @c(car), and @c(cdr) for operating on pairs. But the only thing we
#     need to know about these three operations is that if we glue two objects
#     together using @c(cons) we can retrieve the objects using @c(car) and
#     @c(cdr). That is, the operations satisfy the condition that, for any objects
#     @c(x) and @c(y), if @c(z) is @c[(cons x y)] then @c[(car z)] is @c(x) and
#     @c[(cdr z)] is @c(y). Indeed, we mentioned that these three procedures are
#     included as primitives in our language. However, any triple of procedures that
#     satisfies the above condition can be used as the basis for implementing
#     pairs. This point is illustrated strikingly by the fact that we could
#     implement @c(cons), @c(car), and @c(cdr) without using any data structures at
#     all but only using procedures. Here are the definitions:
    Este punto de vista puede servir para definir no sólo los objetos de datos
    de @"(alto nivel), como los números racionales, sino también los objetos de
    nivel inferior. Consideremos la noción de un par, que usamos para definir
    nuestros números racionales. En realidad nunca dijo lo que era una pareja,
    sólo que el lenguaje suministra procedimientos @c(cons), @c(car) y @c(cdr)
    para operar en pares. Pero lo único que necesitamos saber acerca de estas
    tres operaciones es que si pegamos dos objetos juntos usando @c(cons)
    podemos recuperar los objetos usando @c(car) y @c(cdr). Es decir, las
    operaciones satisfacen la condición de que, para cualquier objeto @c(x) y
    @c(y), si @c(z) es @c[(cons x y)] entonces, @c[(car z)] es @c(x) y @c[(cdr
    z)] es @c(y). En efecto, Mencionamos que estos tres procedimientos están
    incluidos como primitivos en nuestro lenguaje. Sin embargo, cualquier triple
    de procedimientos que satisface la condición anterior puede ser utilizado
    como base para implementar parejas. @c(cons) Este punto se ilustra
    sorprendentemente por el hecho de que podíamos poner en práctica, @c(car) y
    @c(cdr) sin el uso de estructuras de datos en absoluto, sino solamente
    utilizando procedimientos. Aquí están las definiciones:

#     ..src > scheme
#       (define (cons x y)
#         (define (dispatch m)
#           (cond ((= m 0) x)
#                 ((= m 1) y)
#                 (else
#                  (error "Argument not 0 or 1:
#                          CONS" m))))
#         dispatch)
#
#       (define (car z) (z 0))
#       (define (cdr z) (z 1))
#     < src..
    ..src > scheme
      (define (cons x y)
        (define (dispatch m)
          (cond ((= m 0) x)
                ((= m 1) y)
                (else
                 (error "Argument not 0 or 1:
                         CONS" m))))
        dispatch)

      (define (car z) (z 0))
      (define (cdr z) (z 1))
    < src..

#     This use of procedures corresponds to nothing like our intuitive notion of
#     what data should be. Nevertheless, all we need to do to show that this is a
#     valid way to represent pairs is to verify that these procedures satisfy the
#     condition given above.
    Este uso de los procedimientos no corresponde a nada como nuestra noción
    intuitiva de lo que los datos deben ser. Sin embargo, todo lo que
    necesitamos hacer para demostrar que esta es una forma válida de representar
    pares es verificar que estos procedimientos satisfacen la condición dada
    anteriormente.

#     The subtle point to notice is that the value returned by @c[(cons x y)] is a
#     procedure––namely the internally defined procedure @c(dispatch), which takes
#     one argument and returns either @c(x) or @c(y) depending on whether the
#     argument is 0 or 1. Correspondingly, @c[(car z)] is defined to apply @c(z)
#     to 0. Hence, if @c(z) is the procedure formed by @c[(cons x y)], then @c(z)
#     applied to 0 will yield @c(x). Thus, we have shown that @c[(car (cons x y))]
#     yields @c(x), as desired. Similarly, @c[(cdr (cons x y))] applies the
#     procedure returned by @c[(cons x y)] to 1, which returns @c(y). Therefore,
#     this procedural implementation of pairs is a valid implementation, and if we
#     access pairs using only @c(cons), @c(car), and @c(cdr) we cannot distinguish
#     this implementation from one that uses @"(real) data structures.
    El punto sutil a notar es que el valor devuelto por @c[(cons x y)] es un
    procedimiento - es decir, el procedimiento definido internamente
    @c(dispatch), que toma un argumento y devuelve @c(x) o bien @c(y)
    dependiendo de si el argumento es 0 o 1. Correspondientemente, @c[(car z)]
    se define que se aplica @c(z) a 0. Por lo tanto, Si @c(z) es el
    procedimiento formado por @c[(cons x y)], entonces @c(z) aplicado a 0 dará
    @c(x). Así, hemos demostrado que los @c[(car (cons x y))] rendimientos
    @c(x), como se desea. De manera similar, se @c[(cdr (cons x y))] aplica el
    procedimiento devuelto por @c[(cons x y)] a 1, que devuelve @c(y). Por lo
    tanto, esta implementación de procedimientos de pares es una aplicación
    válida, y si accedemos a pares utilizando únicamente @c(cons),
    @c(car),@c(cdr)@"()

#     The point of exhibiting the procedural representation of pairs is not that our
#     language works this way (Scheme, and Lisp systems in general, implement pairs
#     directly, for efficiency reasons) but that it could work this way. The
#     procedural representation, although obscure, is a perfectly adequate way to
#     represent pairs, since it fulfills the only conditions that pairs need to
#     fulfill. This example also demonstrates that the ability to manipulate
#     procedures as objects automatically provides the ability to represent compound
#     data. This may seem a curiosity now, but procedural representations of data
#     will play a central role in our programming repertoire. This style of
#     programming is often called @e(message passing), and we will be using it as a
#     basic tool in @l(#Chapter 3) when we address the issues of modeling and
#     simulation.
    El punto de exhibir la representación procedural de los pares no es que
    nuestro lenguaje trabaje de esta manera (Scheme, y los sistemas Lisp en
    general, implementar pares directamente, por razones de eficiencia) pero que
    podría funcionar de esta manera. La representación procesal, aunque oscura,
    es una forma perfectamente adecuada de representar pares, ya que cumple las
    únicas condiciones que los pares deben cumplir. Este ejemplo también
    demuestra que la capacidad de manipular procedimientos como objetos
    proporciona automáticamente la capacidad de representar datos
    compuestos. Esto puede parecer una curiosidad ahora, pero las
    representaciones procesales de los datos jugarán un papel central en nuestro
    repertorio de programación. Este estilo de programación se llama a menudo el
    @e(paso del mensaje) , @l(Capitulo 3)

#     :: @t(Exercise 2.4) :: Here is an alternative procedural representation of
#        pairs. For this representation, verify that @c[(car (cons x y))] yields
#        @c(x) for any objects @c(x) and @c(y).
    :: @t(Ejercicio 2.4) :: Aquí hay una representación procesal alternativa de
       pares. Para esta representación, verifique que los @c[(car (cons x y))]
       rendimientos @c(x) para cualquier objeto @c(x) y @c(y).

#        ..src > scheme
#          (define (cons x y)
#            (lambda (m) (m x y)))
#
#          (define (car z)
#            (z (lambda (p q) p)))
#        < src..
       ..src > scheme
         (define (cons x y)
           (lambda (m) (m x y)))

         (define (car z)
           (z (lambda (p q) p)))
       < src..

#        What is the corresponding definition of @c(cdr)? (Hint: To verify that this
#        works, make use of the substitution model of section @l(#1.1.5).)
       ¿Cuál es la definición correspondiente de @c(cdr)? (Sugerencia: Para
       verificar que esto funciona, haga uso del modelo de sustitución de
       @l(#1.1.5) .)

#     :: @t(Exercise 2.5) :: Show that we can represent pairs of nonnegative
#        integers using only numbers and arithmetic operations if we represent the
#        pair @m(a) and @m(b) as the integer that is the product @m(2ᵃ 3ᵇ).  Give
#        the corresponding definitions of the procedures @c(cons), @c(car), and
#        @c(cdr).
    :: @t(Ejercicio 2.5) :: Demuestre que podemos representar pares de números
       enteros no negativos usando sólo números y operaciones aritméticas si
       representamos el par @m(a) y @m(b) como el entero que es el producto
       @m(2ᵃ 3ᵇ). Dar las definiciones correspondientes de los procedimientos
       @c(cons), @c(car) y @c(cdr).

#     :: @t(Exercise 2.6) :: In case representing pairs as procedures wasn't
#        mind-boggling enough, consider that, in a language that can manipulate
#        procedures, we can get by without numbers (at least insofar as nonnegative
#        integers are concerned) by implementing 0 and the operation of adding 1 as
    :: @t(Ejercicio 2.6) :: En el caso de que representar a pares como
       procedimientos no era alucinante suficiente, considere que, en un
       lenguaje que puede manipular procedimientos, podemos pasar sin números
       (al menos en lo que respecta a enteros no negativos) mediante la
       implementación de 0 y la operación de añadir 1 como

#        ..src > scheme
#          (define zero (lambda (f) (lambda (x) x)))
#
#          (define (add-1 n)
#            (lambda (f) (lambda (x) (f ((n f) x)))))
#        < src..
       ..src > scheme
         (define zero (lambda (f) (lambda (x) x)))

         (define (add-1 n)
           (lambda (f) (lambda (x) (f ((n f) x)))))
       < src..

#        This representation is known as @e(Church numerals), after its inventor,
#        Alonzo Church, the logician who invented the λ-calculus.
       Esta representación se conoce como @e(números de la iglesia), después de
       su inventor, Iglesia de Alonzo, el lógico que inventó el cálculo-λ.

#        Define @c(one) and @c(two) directly (not in terms of @c(zero) and
#        @c(add-1)). (Hint: Use substitution to evaluate @c[(add-1 zero)]). Give a
#        direct definition of the addition procedure @c(+) (not in terms of repeated
#        application of @c(add-1)).
       Definir @c(one) y @c(two) directamente (no en términos de @c(zero) y
       @c(add-1)). (Sugerencia: utilice la sustitución para evaluar @c[(add-1
       zero)]). Dar una definición directa del procedimiento de adición @c(+)(no
       en términos de aplicación repetida de @c(add-1)).

# *** 2.1.4 <> Extended Exercise: Interval Arithmetic
*** 2.1.4 <> Ejercicio Extendido: Aritmética de Intervalos

#     Alyssa P. Hacker is designing a system to help people solve engineering
#     problems. One feature she wants to provide in her system is the ability to
#     manipulate inexact quantities (such as measured parameters of physical
#     devices) with known precision, so that when computations are done with such
#     approximate quantities the results will be numbers of known precision.
    Alyssa P. Hacker está diseñando un sistema para ayudar a la gente a resolver
    problemas de ingeniería. Una característica que quiere proporcionar en su
    sistema es la capacidad de manipular cantidades inexactas (como parámetros
    medidos de dispositivos físicos) con una precisión conocida, de modo que
    cuando se hacen cálculos con cantidades aproximadas, los resultados serán
    números de precisión conocida.

#     Electrical engineers will be using Alyssa's system to compute electrical
#     quantities. It is sometimes necessary for them to compute the value of a
#     parallel equivalent resistance @m(Rₚ) of two resistors @m(R₁) and @m(R₂) using
#     the formula
    Los ingenieros eléctricos utilizarán el sistema de Alyssa para calcular las
    cantidades eléctricas. A veces es necesario para ellos para calcular el
    valor de una resistencia equivalente en paralelo @m(Rₚ) de dos resistencias
    @m(R $ ₁ $) y @m(R $ ₂ $) utilizando la fórmula

#     ..example >
#                 1
#       Rₚ = -----------
#            1/R₁ + 1/R₂
#     < example..
    ..example >
                1
      Rₚ = -----------
           1/R₁ + 1/R₂
    < example..

#     Resistance values are usually known only up to some tolerance guaranteed by
#     the manufacturer of the resistor. For example, if you buy a resistor labeled
#     @"(6.8 ohms with 10% tolerance) you can only be sure that the resistor has a
#     resistance between 6.8 − 0.68 = 6.12 and 6.8 + 0.68 = 7.48 ohms. Thus, if you
#     have a 6.8-ohm 10% resistor in parallel with a 4.7-ohm 5% resistor, the
#     resistance of the combination can range from about 2.58 ohms (if the two
#     resistors are at the lower bounds) to about 2.97 ohms (if the two resistors
#     are at the upper bounds).
    Los valores de resistencia normalmente se conocen sólo hasta cierto grado de
    tolerancia garantizado por el fabricante de la resistencia. Por ejemplo, si
    compra una resistencia de @"(6,8 ohmios con 10% de tolerancia), sólo puede
    estar seguro de que la resistencia tiene una resistencia entre 6,8 - 0,68 =
    6,12 y 6,8 + 0,68 = 7,48 ohmios. Por lo tanto, si usted tiene una
    resistencia de 6,8 ohm 10% en paralelo con una resistencia de 4,7 ohm 5%, la
    resistencia de la combinación puede variar de alrededor de 2,58 ohmios (si
    las dos resistencias están en los límites inferiores) a alrededor de 2,97
    ohms Si las dos resistencias están en los límites superiores).

#     Alyssa's idea is to implement @"(interval arithmetic) as a set of arithmetic
#     operations for combining @"(intervals) (objects that represent the range of
#     possible values of an inexact quantity). The result of adding, subtracting,
#     multiplying, or dividing two intervals is itself an interval, representing the
#     range of the result.
    La idea de Alyssa es implementar la @"(aritmética de intervalos) como un
    conjunto de operaciones aritméticas para combinar @"(intervalos) (objetos
    que representan el rango de valores posibles de una cantidad inexacta). El
    resultado de sumar, restar, multiplicar o dividir dos intervalos es en sí
    mismo un intervalo, que representa el rango del resultado.

#     Alyssa postulates the existence of an abstract object called an @"(interval)
#     that has two endpoints: a lower bound and an upper bound. She also presumes
#     that, given the endpoints of an interval, she can construct the interval using
#     the data constructor @c(make-interval). Alyssa first writes a procedure for
#     adding two intervals. She reasons that the minimum value the sum could be is
#     the sum of the two lower bounds and the maximum value it could be is the sum
#     of the two upper bounds:
    Alyssa postula la existencia de un objeto abstracto llamado @"(intervalo)
    que tiene dos puntos finales: un límite inferior y un límite
    superior. También presume que, dado los puntos extremos de un intervalo,
    puede construir el intervalo usando el constructor de datos
    @c(make-interval). Alyssa escribe primero un procedimiento para agregar dos
    intervalos. Ella razona que el valor mínimo que la suma podría ser es la
    suma de los dos límites inferiores y el valor máximo que podría ser es la
    suma de los dos límites superiores:

#     ..src > scheme
#       (define (add-interval x y)
#         (make-interval (+ (lower-bound x)
#                           (lower-bound y))
#                        (+ (upper-bound x)
#                           (upper-bound y))))
#     < src..
    ..src > scheme
      (define (add-interval x y)
        (make-interval (+ (lower-bound x)
                          (lower-bound y))
                       (+ (upper-bound x)
                          (upper-bound y))))
    < src..

#     Alyssa also works out the product of two intervals by finding the minimum and
#     the maximum of the products of the bounds and using them as the bounds of the
#     resulting interval. (@c(Min) and @c(max) are primitives that find the minimum
#     or maximum of any number of arguments.)
    Alyssa también trabaja el producto de dos intervalos encontrando el mínimo y
    el máximo de los productos de los límites y usándolos como los límites del
    intervalo resultante. (@c(Min) Y @c(max) son primitivos que encuentran el
    mínimo o el máximo de cualquier número de argumentos.)

#     ..src > scheme
#       (define (mul-interval x y)
#         (let ((p1 (* (lower-bound x)
#                      (lower-bound y)))
#               (p2 (* (lower-bound x)
#                      (upper-bound y)))
#               (p3 (* (upper-bound x)
#                      (lower-bound y)))
#               (p4 (* (upper-bound x)
#                      (upper-bound y))))
#           (make-interval (min p1 p2 p3 p4)
#                          (max p1 p2 p3 p4))))
#     < src..
    ..src > scheme
      (define (mul-interval x y)
        (let ((p1 (* (lower-bound x)
                     (lower-bound y)))
              (p2 (* (lower-bound x)
                     (upper-bound y)))
              (p3 (* (upper-bound x)
                     (lower-bound y)))
              (p4 (* (upper-bound x)
                     (upper-bound y))))
          (make-interval (min p1 p2 p3 p4)
                         (max p1 p2 p3 p4))))
    < src..

#     To divide two intervals, Alyssa multiplies the first by the reciprocal of the
#     second. Note that the bounds of the reciprocal interval are the reciprocal of
#     the upper bound and the reciprocal of the lower bound, in that order.
    Para dividir dos intervalos, Alyssa multiplica la primera por el recíproco
    de la segunda. Obsérvese que los límites del intervalo recíproco son el
    recíproco del límite superior y el recíproco del límite inferior, en ese
    orden.

#     ..src > scheme
#       (define (div-interval x y)
#         (mul-interval x
#                       (make-interval
#                        (/ 1.0 (upper-bound y))
#                        (/ 1.0 (lower-bound y)))))
#     < src..
    ..src > scheme
      (define (div-interval x y)
        (mul-interval x
                      (make-interval
                       (/ 1.0 (upper-bound y))
                       (/ 1.0 (lower-bound y)))))
    < src..

#     :: @t(Exercise 2.7) :: Alyssa's program is incomplete because she has not
#        specified the implementation of the interval abstraction.  Here is a
#        definition of the interval constructor:
    :: @t(Ejercicio 2.7) :: El programa de Alyssa es incompleto porque no ha
       especificado la implementación de la abstracción de intervalos. Aquí hay
       una definición del constructor del intervalo:

#        ..src > scheme
#          (define (make-interval a b) (cons a b))
#        < src..
       ..src > scheme
         (define (make-interval a b) (cons a b))
       < src..

#        Define selectors @c(upper-bound) and @c(lower-bound) to complete the
#        implementation.
       Definir selectores @c(upper-bound) y @c(lower-bound) completar la
       implementación.

#     :: @t(Exercise 2.8) :: Using reasoning analogous to Alyssa's, describe how the
#        difference of two intervals may be computed. Define a corresponding
#        subtraction procedure, called @c(sub-interval).
    :: @t(Ejercicio 2.8) :: Utilizando razonamientos análogos a los de Alyssa,
       describa cómo se puede calcular la diferencia de dos intervalos. Definir
       un procedimiento de sustracción correspondiente, llamado
       @c(sub-interval).

#     :: @t(Exercise 2.9) :: The @e(width) of an interval is half of the difference
#        between its upper and lower bounds. The width is a measure of the
#        uncertainty of the number specified by the interval. For some arithmetic
#        operations the width of the result of combining two intervals is a function
#        only of the widths of the argument intervals, whereas for others the width
#        of the combination is not a function of the widths of the argument
#        intervals. Show that the width of the sum (or difference) of two intervals
#        is a function only of the widths of the intervals being added (or
#        subtracted).  Give examples to show that this is not true for
#        multiplication or division.
    :: @t(Ejercicio 2.9) :: El @e(ancho) de un intervalo es la mitad de la
       diferencia entre sus límites superior e inferior. La anchura es una
       medida de la incertidumbre del número especificado por el intervalo. Para
       algunas operaciones aritméticas, el ancho del resultado de combinar dos
       intervalos es una función solamente de los anchos de los intervalos de
       argumento, mientras que para otros el ancho de la combinación no es una
       función de los anchos de los intervalos de argumento. Demuestre que el
       ancho de la suma (o diferencia) de dos intervalos es una función
       solamente de los anchos de los intervalos que se agregan (o se
       restan). Dar ejemplos para demostrar que esto no es cierto para la
       multiplicación o división.

#     :: @t(Exercise 2.10) :: Ben Bitdiddle, an expert systems programmer, looks
#        over Alyssa's shoulder and comments that it is not clear what it means to
#        divide by an interval that spans zero. Modify Alyssa's code to check for
#        this condition and to signal an error if it occurs.
    :: @t(Ejercicio 2.10) :: Ben Bitdiddle, un programador de sistemas expertos,
       mira sobre el hombro de Alyssa y comenta que no está claro lo que
       significa dividir por un intervalo que se extiende a cero. Modifique el
       código de Alyssa para verificar esta condición y para señalar un error si
       ocurre.

#     :: @t(Exercise 2.11) :: In passing, Ben also cryptically comments: @"(By
#        testing the signs of the endpoints of the intervals, it is possible to
#        break @c(mul-interval) into nine cases, only one of which requires more
#        than two multiplications.)  Rewrite this procedure using Ben's suggestion.
    :: @t(Ejercicio 2.11) :: Al pasar, Ben también comenta críticamente: @"(Al
       probar los signos de los extremos de los intervalos, es posible romperse
       @c(mul-interval) en nueve casos, sólo uno de los cuales requiere más de
       dos multiplicaciones. )  Vuelva a escribir este procedimiento utilizando
       la sugerencia de Ben.

#        After debugging her program, Alyssa shows it to a potential user, who
#        complains that her program solves the wrong problem. He wants a program
#        that can deal with numbers represented as a center value and an additive
#        tolerance; for example, he wants to work with intervals such as 3.5 @m(±)
#        0.15 rather than [3.35, 3.65]. Alyssa returns to her desk and fixes this
#        problem by supplying an alternate constructor and alternate selectors:
       Después de depurar su programa, Alyssa lo muestra a un usuario potencial,
       quien se queja de que su programa resuelve el problema equivocado. Quiere
       un programa que pueda ocuparse de los números representados como un valor
       central y una tolerancia aditiva; Por ejemplo, quiere trabajar con
       intervalos tales como 3.5 @m(±) 0.15 en lugar de [3.35, 3.65]. Alyssa
       vuelve a su escritorio y corrige este problema suministrando un
       constructor alternativo y selectores alternos:

#        ..src > scheme
#          (define (make-center-width c w)
#            (make-interval (- c w) (+ c w)))
#
#          (define (center i)
#            (/ (+ (lower-bound i)
#                  (upper-bound i))
#               2))
#
#          (define (width i)
#            (/ (- (upper-bound i)
#                  (lower-bound i))
#               2))
#        < src..
       ..src > scheme
         (define (make-center-width c w)
           (make-interval (- c w) (+ c w)))

         (define (center i)
           (/ (+ (lower-bound i)
                 (upper-bound i))
              2))

         (define (width i)
           (/ (- (upper-bound i)
                 (lower-bound i))
              2))
       < src..

#        Unfortunately, most of Alyssa's users are engineers. Real engineering
#        situations usually involve measurements with only a small uncertainty,
#        measured as the ratio of the width of the interval to the midpoint of the
#        interval.  Engineers usually specify percentage tolerances on the
#        parameters of devices, as in the resistor specifications given earlier.
       Desafortunadamente, la mayoría de los usuarios de Alyssa son
       ingenieros. Las situaciones reales de ingeniería suelen implicar
       mediciones con sólo una pequeña incertidumbre, medida como la relación
       entre el ancho del intervalo y el punto medio del intervalo. Los
       ingenieros generalmente especifican tolerancias porcentuales en los
       parámetros de los dispositivos, como en las especificaciones de
       resistencias dadas anteriormente.

#     :: @t(Exercise 2.12) :: Define a constructor @c(make-center-percent) that
#        takes a center and a percentage tolerance and produces the desired
#        interval. You must also define a selector @c(percent) that produces the
#        percentage tolerance for a given interval. The @c(center) selector is the
#        same as the one shown above.
    :: @t(Ejercicio 2.12) :: Definir un constructor @c(make-center-percent) que
       toma un centro y un porcentaje de tolerancia y produce el intervalo
       deseado. También debe definir un selector @c(percent) que produzca el
       porcentaje de tolerancia para un intervalo dado. El @c(center) selector
       es el mismo que el mostrado arriba.

#     :: @t(Exercise 2.13) :: Show that under the assumption of small percentage
#        tolerances there is a simple formula for the approximate percentage
#        tolerance of the product of two intervals in terms of the tolerances of the
#        factors. You may simplify the problem by assuming that all numbers are
#        positive.
    :: @t(Ejercicio 2.13) :: Demuestre que, bajo el supuesto de un porcentaje
       pequeño de tolerancia, existe una fórmula simple para el porcentaje de
       tolerancia aproximada del producto de dos intervalos en función de las
       tolerancias de los factores. Puede simplificar el problema asumiendo que
       todos los números son positivos.

#        After considerable work, Alyssa P. Hacker delivers her finished system.
#        Several years later, after she has forgotten all about it, she gets a
#        frenzied call from an irate user, Lem E. Tweakit. It seems that Lem has
#        noticed that the formula for parallel resistors can be written in two
#        algebraically equivalent ways:
       Después de un trabajo considerable, Alyssa P. Hacker entrega su sistema
       terminado. Varios años más tarde, después de que se haya olvidado de
       todo, recibe una frenética llamada de un usuario furioso, Lem
       E. Tweakit. Parece que Lem ha notado que la fórmula para resistencias
       paralelas puede escribirse en dos formas algebraicamente equivalentes:

#        ..example >
#           R₁ R₂
#          -------
#          R₁ + R₂
#        < example..
       ..example >
          R₁ R₂
         -------
         R₁ + R₂
       < example..

#        and
       y
#        ..example >
#               1
#          -----------
#          1/R₁ + 1/R₂
#        < example..
       ..example >
              1
         -----------
         1/R₁ + 1/R₂
       < example..

#        He has written the following two programs, each of which computes the
#        parallel-resistors formula differently:
       Ha escrito los siguientes dos programas, cada uno de los cuales calcula
       la fórmula de las resistencias paralelas de manera diferente:

#        ..src > scheme
#          (define (par1 r1 r2)
#            (div-interval
#             (mul-interval r1 r2)
#             (add-interval r1 r2)))
#
#          (define (par2 r1 r2)
#            (let ((one (make-interval 1 1)))
#              (div-interval
#               one
#               (add-interval
#                (div-interval one r1)
#                (div-interval one r2)))))
#        < src..
       ..src > scheme
         (define (par1 r1 r2)
           (div-interval
            (mul-interval r1 r2)
            (add-interval r1 r2)))

         (define (par2 r1 r2)
           (let ((one (make-interval 1 1)))
             (div-interval
              one
              (add-interval
               (div-interval one r1)
               (div-interval one r2)))))
       < src..

#        Lem complains that Alyssa's program gives different answers for the two
#        ways of computing. This is a serious complaint.
       Lem se queja de que el programa de Alyssa da respuestas diferentes para
       las dos formas de computación. Esta es una queja seria.

#     :: @t(Exercise 2.14) :: Demonstrate that Lem is right.  Investigate the
#        behavior of the system on a variety of arithmetic expressions. Make some
#        intervals @m(a) and @m(B), and use them in computing the expressions @m(A /
#        A) and @m(A / B). You will get the most insight by using intervals whose
#        width is a small percentage of the center value. Examine the results of the
#        computation in center-percent form (see @l(#Exercise 2.12)).
    :: @t(Ejercicio 2.14) :: Demostrar que Lem tiene razón. Investigue el
       comportamiento del sistema en una variedad de expresiones
       aritméticas. Hacer un poco de intervalos de @m(a) y @m(B), y
       utilizarlos en el cálculo de las expresiones @m(de A / A) y @m(A /
       B). Usted obtendrá la mayoría de la visión mediante el uso de intervalos
       cuya anchura es un pequeño porcentaje del valor del centro. Examinar los
       resultados del cálculo en forma de centro por ciento (véase el
       @l(#Ejercicio 2.12) ).

#     :: @t(Exercise 2.15) :: Eva Lu Ator, another user, has also noticed the
#        different intervals computed by different but algebraically equivalent
#        expressions. She says that a formula to compute with intervals using
#        Alyssa's system will produce tighter error bounds if it can be written in
#        such a form that no variable that represents an uncertain number is
#        repeated. Thus, she says, @c(par2) is a @"(better) program for parallel
#        resistances than @c(par1). Is she right?  Why?
    :: @t(Ejercicio 2.15) :: Eva Lu Ator, otro usuario, también ha notado los
       diferentes intervalos calculados por diferentes expresiones
       algebraicamente equivalentes. Ella dice que una fórmula para calcular con
       intervalos utilizando el sistema de Alyssa producirá límites de error más
       estrictos si se puede escribir de tal forma que no se repite ninguna
       variable que represente un número incierto. Así, ella dice, @c(par2) es
       un @"(mejor) programa para las resistencias paralelas que
       @c(par1). ¿Tiene razón? ¿Por qué?

#     :: @t(Exercise 2.16) :: Explain, in general, why equivalent algebraic
#        expressions may lead to different answers. Can you devise an
#        interval-arithmetic package that does not have this shortcoming, or is this
#        task impossible?  (Warning: This problem is very difficult.)
    :: @t(Ejercicio 2.16) :: Explique, en general, por qué las expresiones
       algebraicas equivalentes pueden dar lugar a respuestas diferentes. ¿Puede
       diseñar un paquete de aritmética de intervalos que no tenga esta
       deficiencia, o es esta tarea imposible? (Advertencia: Este problema es
       muy difícil.)

# ** 2.2 <> Hierarchical Data and the Closure Property
** 2.2 <> Datos jerárquicos y la propiedad de cierre

#    As we have seen, pairs provide a primitive @"(glue) that we can use to
#    construct compound data objects. @l(#Figure 2.2) shows a standard way to
#    visualize a pair––in this case, the pair formed by @c[(cons 1 2)]. In this
#    representation, which is called @e(box-and-pointer notation), each object is
#    shown as a @e(pointer) to a box. The box for a primitive object contains a
#    representation of the object. For example, the box for a number contains a
#    numeral. The box for a pair is actually a double box, the left part containing
#    (a pointer to) the @c(car) of the pair and the right part containing the
#    @c(cdr).
   Como hemos visto, los pares proporcionan un @"(pegamento) primitivo que
   podemos usar para construir objetos de datos compuestos. @l(#Figure-2.2<>La
   figura 2.2) muestra una forma estándar de visualizar un par - en este caso,
   el par formado por @c[(cons 1 2)]. En esta representación, que se denomina
   @e(anotación de caja y puntero), cada objeto se muestra como un @e(puntero) a
   un cuadro. El cuadro de un objeto primitivo contiene una representación del
   objeto. Por ejemplo, la casilla de un número contiene un número. La caja de
   un par es en realidad una caja doble, la parte izquierda que contiene (un
   puntero a) el @c(car) del par y la parte derecha que contiene el @c(cdr).

#    ..figure > @t(Figure 2.2) Box-and-pointer representation of @c[(cons 1 2)].
   ..figure > @t(Figura 2.2) Representación en caja y puntero de @c[(cons 1 2)].

#      ..art >
#             ╭───┬───╮     ╭───╮
#        ────▶│ ◆ │ ◆ ┼────▶│ 2 │
#             ╰─┼─┴───╯     ╰───╯
#               │
#               ▼
#             ╭───╮
#             │ 1 │
#             ╰───╯
#      < art..
     ..art >
            ╭───┬───╮     ╭───╮
       ────▶│ ◆ │ ◆ ┼────▶│ 2 │
            ╰─┼─┴───╯     ╰───╯
              │
              ▼
            ╭───╮
            │ 1 │
            ╰───╯
     < art..

# @  ..img > img/chap2/Fig2.2e.std.svg
@  ..img > img/chap2/Fig2.2e.std.svg

#    We have already seen that @c(cons) can be used to combine not only numbers but
#    pairs as well. (You made use of this fact, or should have, in doing
#    @l(#Exercise 2.2) and @l(#Exercise 2.3).)  As a consequence, pairs provide a
#    universal building block from which we can construct all sorts of data
#    structures. @l(#Figure 2.3) shows two ways to use pairs to combine the numbers
#    1, 2, 3, and 4.
   Ya hemos visto que @c(cons) se puede utilizar para combinar no sólo números
   sino también pares. (Usted hizo uso de este hecho, o debería tener, al hacer
   el @l(#Ejercicio 2.2) y el @l(#Ejercicio 2.3)
   ). Como consecuencia, los pares proporcionan un bloque de construcción
   universal del cual podemos construir todo tipo de estructuras de
   datos. @l(#Figura 2.3) muestra dos formas de utilizar pares
   para combinar los números 1, 2, 3 y 4.

#    ..figure > @t(Figure 2.3) Two ways to combine 1, 2, 3, and 4 using pairs.
   ..figure > @t(Figura 2.3) Dos formas de combinar 1, 2, 3 y 4 usando pares.

#      ..art >
#             ╭───┬───╮     ╭───┬───╮         ╭───┬───╮     ╭───╮
#        ────▶│ ◆ │ ◆ ┼────▶│ ◆ │ ◆ │    ────▶│ ◆ │ ◆ ┼────▶│ 4 │
#             ╰─┼─┴───╯     ╰─┼─┴─┼─╯         ╰─┼─┴───╯     ╰───╯
#               │             │   │             │
#               ▼             ▼   ▼             ▼
#           ╭───┬───╮      ╭───╮ ╭───╮      ╭───┬───╮     ╭───┬───╮
#           │ ◆ │ ◆ │      │ 3 │ │ 4 │      │ ◆ │ ◆ ┼────▶│ ◆ │ ◆ │
#           ╰─┼─┴─┼─╯      ╰───╯ ╰───╯      ╰─┼─┴───╯     ╰─┼─┴─┼─╯
#             │   │                           │             │   │
#             ▼   ▼                           ▼             ▼   ▼
#          ╭───╮ ╭───╮                      ╭───╮        ╭───╮ ╭───╮
#          │ 1 │ │ 2 │                      │ 1 │        │ 2 │ │ 3 │
#          ╰───╯ ╰───╯                      ╰───╯        ╰───╯ ╰───╯
#
#          (cons (cons 1 2)                 (cons (cons 1
#                (cons 3 4))                            (cons 2 3))
#                                                 4)
#      < art..
     ..art >
            ╭───┬───╮     ╭───┬───╮         ╭───┬───╮     ╭───╮
       ────▶│ ◆ │ ◆ ┼────▶│ ◆ │ ◆ │    ────▶│ ◆ │ ◆ ┼────▶│ 4 │
            ╰─┼─┴───╯     ╰─┼─┴─┼─╯         ╰─┼─┴───╯     ╰───╯
              │             │   │             │
              ▼             ▼   ▼             ▼
          ╭───┬───╮      ╭───╮ ╭───╮      ╭───┬───╮     ╭───┬───╮
          │ ◆ │ ◆ │      │ 3 │ │ 4 │      │ ◆ │ ◆ ┼────▶│ ◆ │ ◆ │
          ╰─┼─┴─┼─╯      ╰───╯ ╰───╯      ╰─┼─┴───╯     ╰─┼─┴─┼─╯
            │   │                           │             │   │
            ▼   ▼                           ▼             ▼   ▼
         ╭───╮ ╭───╮                      ╭───╮        ╭───╮ ╭───╮
         │ 1 │ │ 2 │                      │ 1 │        │ 2 │ │ 3 │
         ╰───╯ ╰───╯                      ╰───╯        ╰───╯ ╰───╯

         (cons (cons 1 2)                 (cons (cons 1
               (cons 3 4))                            (cons 2 3))
                                                4)
     < art..

# @  ..img > img/chap2/Fig2.3e.std.svg
@  ..img > img/chap2/Fig2.3e.std.svg

#    The ability to create pairs whose elements are pairs is the essence of list
#    structure's importance as a representational tool. We refer to this ability as
#    the @e(closure property) of @c(cons). In general, an operation for combining
#    data objects satisfies the closure property if the results of combining things
#    with that operation can themselves be combined using the same operation.@n(72)
#    Closure is the key to power in any means of combination because it permits us
#    to create @e(hierarchical) structures––structures made up of parts, which
#    themselves are made up of parts, and so on.
   La capacidad de crear pares cuyos elementos son pares es la esencia de la
   importancia de la estructura de lista como herramienta de representación. Nos
   referimos a esta capacidad como la @e(propiedad) de @e(cierre) de
   @c(cons). En general, una operación para combinar objetos de datos satisface
   la propiedad de cierre si los resultados de combinar cosas con esa operación
   pueden combinarse por sí mismos usando la misma operación.@n(72)
   cierre es la clave del poder en cualquier medio de combinación, ya que nos
   permite crear estructuras @e(jerárquicas) - estructuras compuestas de partes,
   que a su vez están formadas por partes, y así sucesivamente.

#    From the outset of @l(#Chapter 1), we've made essential use of closure in
#    dealing with procedures, because all but the very simplest programs rely on
#    the fact that the elements of a combination can themselves be combinations. In
#    this section, we take up the consequences of closure for compound data. We
#    describe some conventional techniques for using pairs to represent sequences
#    and trees, and we exhibit a graphics language that illustrates closure in a
#    vivid way.@n(73)
   Desde el comienzo del @l(#Capitulo 1), hemos hecho uso esencial
   del cierre en el trato con los procedimientos, porque todos, excepto los
   programas más simples, se basan en el hecho de que los elementos de una
   combinación pueden ser combinaciones. En esta sección, tomamos las
   consecuencias del cierre para los datos compuestos. Describimos algunas
   técnicas convencionales para el uso de pares para representar secuencias y
   árboles, y exhibimos un lenguaje gráfico que ilustra el cierre de una manera
   vívida.@n(73)

# *** 2.2.1 <> Representing Sequences
*** 2.2.1 <> Representación de secuencias

#     One of the useful structures we can build with pairs is a @e(sequence)––an
#     ordered collection of data objects. There are, of course, many ways to
#     represent sequences in terms of pairs. One particularly straightforward
#     representation is illustrated in @l(#Figure 2.4), where the sequence 1, 2, 3,
#     4 is represented as a chain of pairs. The @c(car) of each pair is the
#     corresponding item in the chain, and the @c(cdr) of the pair is the next pair
#     in the chain. The @c(cdr) of the final pair signals the end of the sequence by
#     pointing to a distinguished value that is not a pair, represented in
#     box-and-pointer diagrams as a diagonal line and in programs as the value of
#     the variable @c(nil). The entire sequence is constructed by nested @c(cons)
#     operations:
    Una de las estructuras útiles podemos construir con pares es una
    @e(secuencia) --un ordenó colección de objetos de datos. Hay, por supuesto,
    muchas maneras de representar secuencias en términos de pares. Una
    representación particularmente directa se ilustra en la
    @l(#Figura 2.4), donde la secuencia 1, 2, 3, 4 se representa
    como una cadena de pares. El @c(car) de cada par es el elemento
    correspondiente en la cadena, y el @c(cdr) del par es el siguiente par en la
    cadena. El @c(cdr) del par final señala el final de la secuencia apuntando a
    un valor distinguido que no es un par, representado en diagramas de cuadro y
    puntero como una línea diagonal y en programas como el valor de la variable
    @c(nil). Toda la secuencia se construye mediante @c(cons) operaciones
    anidadas :

#     ..src > scheme
#       (cons 1
#             (cons 2
#                   (cons 3
#                         (cons 4 nil))))
#     < src..
    ..src > scheme
      (cons 1
            (cons 2
                  (cons 3
                        (cons 4 nil))))
    < src..

#     ..figure > @t(Figure 2.4) The sequence 1, 2, 3, 4 represented as a chain of pairs.
    ..figure > @t(Figura 2.4) La secuencia 1, 2, 3, 4 representada como una
    cadena de pares.

#       ..art >
#              ╭───┬───╮     ╭───┬───╮     ╭───┬───╮     ╭───┬───╮
#         ────▶│ ◆ │ ◆ ┼────▶│ ◆ │ ◆ ┼────▶│ ◆ │ ◆ ┼────▶│ ◆ │ ╱ │
#              ╰─┼─┴───╯     ╰─┼─┴───╯     ╰─┼─┴───╯     ╰─┼─┴───╯
#                │             │             │             │
#                ▼             ▼             ▼             ▼
#              ╭───╮         ╭───╮         ╭───╮         ╭───╮
#              │ 1 │         │ 2 │         │ 3 │         │ 4 │
#              ╰───╯         ╰───╯         ╰───╯         ╰───╯
#       < art..
      ..art >
             ╭───┬───╮     ╭───┬───╮     ╭───┬───╮     ╭───┬───╮
        ────▶│ ◆ │ ◆ ┼────▶│ ◆ │ ◆ ┼────▶│ ◆ │ ◆ ┼────▶│ ◆ │ ╱ │
             ╰─┼─┴───╯     ╰─┼─┴───╯     ╰─┼─┴───╯     ╰─┼─┴───╯
               │             │             │             │
               ▼             ▼             ▼             ▼
             ╭───╮         ╭───╮         ╭───╮         ╭───╮
             │ 1 │         │ 2 │         │ 3 │         │ 4 │
             ╰───╯         ╰───╯         ╰───╯         ╰───╯
      < art..

# @   ..img > img/chap2/Fig2.4e.std.svg
@   ..img > img/chap2/Fig2.4e.std.svg

#     Such a sequence of pairs, formed by nested @c(cons)es, is called a @e(list),
#     and Scheme provides a primitive called @c(list) to help in constructing
#     lists.@n(74) The above sequence could be produced by @c[(list 1 2 3 4)].  In
#     general,
    Tal secuencia de pares, formada por @c(cons) es anidados, se llama una
    @e(lista), y Scheme proporciona una primitiva llamada @c(list) para ayudar
    en la construcción de listas.@n(74) La secuencia anterior podría ser
    producida por @c[(list 1 2 3 4)]. En general,

#     ..src > scheme
#       (list ⟨a₁⟩ ⟨a₂⟩ … ⟨aₙ⟩)
#     < src..
    ..src > scheme
      (list ⟨a₁⟩ ⟨a₂⟩ … ⟨aₙ⟩)
    < src..

#     is equivalent to
    es equivalente a

#     ..src > scheme
#       (cons ⟨a₁⟩
#             (cons ⟨a₂⟩
#                   (cons …
#                        (cons ⟨aₙ⟩
#                              nil)…)))
#     < src..
    ..src > scheme
      (cons ⟨a₁⟩
            (cons ⟨a₂⟩
                  (cons …
                       (cons ⟨aₙ⟩
                             nil)…)))
    < src..

#     Lisp systems conventionally print lists by printing the sequence of elements,
#     enclosed in parentheses. Thus, the data object in @l(#Figure 2.4) is printed
#     as @c[(1 2 3 4)]:
    Lisp sistemas de impresión de forma convencional listas mediante la
    impresión de la secuencia de elementos, entre paréntesis. Por lo tanto, el
    objeto de datos en la @l(#Figura 2.4) se imprime como @c[(1 2 3
    4)]:

#     ..srci > scheme
#       > (define one-through-four (list 1 2 3 4))
#       one-through-four
#       > (1 2 3 4)
#     < srci..
    ..srci > scheme
      > (define one-through-four (list 1 2 3 4))
      one-through-four
      > (1 2 3 4)
    < srci..

#     Be careful not to confuse the expression @c[(list 1 2 3 4)] with the list
#     @c[(1 2 3 4)], which is the result obtained when the expression is
#     evaluated. Attempting to evaluate the expression @c[(1 2 3 4)] will signal an
#     error when the interpreter tries to apply the procedure @c(1) to arguments
#     @c(2), @c(3), @c(4).
    Tenga cuidado de no confundir la expresión @c[(list 1 2 3 4)] con la lista
    @c[(1 2 3 4)], que es el resultado obtenido cuando se evalúa la
    expresión. El intento de evaluar la expresión @c[(1 2 3 4)] señalará un
    error cuando el intérprete trata de aplicar el procedimiento @c(1) de
    argumentos @c(2), @c(3), @c(4).

#     We can think of @c(car) as selecting the first item in the list, and of
#     @c(cdr) as selecting the sublist consisting of all but the first item.  Nested
#     applications of @c(car) and @c(cdr) can be used to extract the second, third,
#     and subsequent items in the list.@n(75) The constructor @c(cons) makes a list
#     like the original one, but with an additional item at the beginning.
    Podemos pensar en @c(car) como seleccionar el primer elemento de la lista, y
    de @c(cdr) como seleccionar la sublista que consiste en todo menos el primer
    elemento. Aplicaciones anidadas de @c(car) y @c(cdr) se pueden utilizar para
    extraer los artículos segundo, tercero y subsiguientes de la
    lista.@n(75) El constructor @c(cons) hace una lista como la original,
    pero con un elemento adicional al principio.

#     ..srci > scheme
#       > (car one-through-four)
#       1
#       > (cdr one-through-four)
#       (2 3 4)
#       > (car (cdr one-through-four))
#       2
#       > (cons 10 one-through-four)
#       (10 1 2 3 4)
#       > (cons 5 one-through-four)
#       (5 1 2 3 4)
#     < srci..
    ..srci > scheme
      > (car one-through-four)
      1
      > (cdr one-through-four)
      (2 3 4)
      > (car (cdr one-through-four))
      2
      > (cons 10 one-through-four)
      (10 1 2 3 4)
      > (cons 5 one-through-four)
      (5 1 2 3 4)
    < srci..

#     The value of @c(nil), used to terminate the chain of pairs, can be thought of
#     as a sequence of no elements, the @e(empty list). The word @e(nil) is a
#     contraction of the Latin word @e(nihil), which means @"(nothing.)@n(76)
    El valor de @c(nil), usado para terminar la cadena de pares, puede ser
    pensado como una secuencia de no elementos, la @e(lista vacía). La palabra
    @e(nil) es una contracción de la palabra latina @e(nihil), que @"(no)
    significa @"(nada. )@n(76)

# **** List operations
**** Listar operaciones

#      The use of pairs to represent sequences of elements as lists is accompanied by
#      conventional programming techniques for manipulating lists by successively
#      @"(@c(cdr)ing down) the lists. For example, the procedure @c(list-ref) takes
#      as arguments a list and a number @m(n) and returns the @m(nᵗʰ) item of the
#      list. It is customary to number the elements of the list beginning with 0.
#      The method for computing @c(list-ref) is the following:
     El uso de parejas para representar secuencias de elementos como listas se
     acompaña de técnicas de programación convencionales para manipular listas,
     mediante la sucesiva @"(@c(cdr) reducción de) las listas. Por ejemplo, el
     procedimiento @c(list-ref) toma como argumentos una lista y un número
     @m(ny) devuelve el elemento @m(nᵗʰ) de la lista. Es habitual numerar los
     elementos de la lista comenzando por 0. El método de cálculo @c(list-ref)
     es el siguiente:

#      - For @m(n = 0), @c(list-ref) should return the @c(car) of the list.
     - Para @m(n = 0), @c(list-ref) debe devolver el @c(car) de la lista.

#      - Otherwise, @c(list-ref) should return the @m[(n - 1)]-st item of the @c(cdr)
#        of the list.
     - De lo contrario, @c(list-ref) debe devolver el elemento @m[(n - 1)] -st
       @c(cdr) de la lista.

#      ..srci > scheme
#        > (define (list-ref items n)
#        ^   (if (= n 0)
#        ^       (car items)
#        ^       (list-ref (cdr items)
#        ^                 (- n 1))))
#        > (define squares
#        ^   (list 1 4 9 16 25))
#        > (list-ref squares 3)
#        16
#      < srci..
     ..srci > scheme
       > (define (list-ref items n)
       ^   (if (= n 0)
       ^       (car items)
       ^       (list-ref (cdr items)
       ^                 (- n 1))))
       > (define squares
       ^   (list 1 4 9 16 25))
       > (list-ref squares 3)
       16
     < srci..

#      Often we @c(cdr) down the whole list. To aid in this, Scheme includes a
#      primitive predicate @c(null?), which tests whether its argument is the empty
#      list. The procedure @c(length), which returns the number of items in a list,
#      illustrates this typical pattern of use:
     A menudo, @c(cdr) la lista completa. Para ayudar en esto, Scheme incluye un
     predicado primitivo @c(null?), que comprueba si su argumento es la lista
     vacía. El procedimiento @c(length), que devuelve el número de elementos de
     una lista, ilustra este patrón típico de uso:

#      ..srci > scheme
#        > (define (length items)
#        ^   (if (null? items)
#        ^       0
#        ^       (+ 1 (length (cdr items)))))
#        > (define odds
#        ^   (list 1 3 5 7))
#        > (length odds)
#        4
#      < srci..
     ..srci > scheme
       > (define (length items)
       ^   (if (null? items)
       ^       0
       ^       (+ 1 (length (cdr items)))))
       > (define odds
       ^   (list 1 3 5 7))
       > (length odds)
       4
     < srci..

#      The @c(length) procedure implements a simple recursive plan. The reduction
#      step is:
     El procedimiento @c(length) implementa un plan recursivo simple. El paso de
     reducción es:

#      - The @c(length) of any list is 1 plus the @c(length) of the @c(cdr) of the
#        list.
     - El @c(length) de cualquier lista es 1 más el @c(length) de la @c(cdr) de
       la lista.

#      This is applied successively until we reach the base case:
     Esto se aplica sucesivamente hasta llegar al caso base:

#      - The @c(length) of the empty list is 0.
     - El @c(length) de la lista vacía es 0.

#      We could also compute @c(length) in an iterative style:
     También podríamos calcular @c(length) en un estilo iterativo:

#      ..src > scheme
#        (define (length items)
#          (define (length-iter a count)
#            (if (null? a)
#                count
#                (length-iter (cdr a)
#                             (+ 1 count))))
#          (length-iter items 0))
#      < src..
     ..src > scheme
       (define (length items)
         (define (length-iter a count)
           (if (null? a)
               count
               (length-iter (cdr a)
                            (+ 1 count))))
         (length-iter items 0))
     < src..

#      Another conventional programming technique is to @"(@c(cons) up) an answer
#      list while @c(cdr)ing down a list, as in the procedure @c(append), which takes
#      two lists as arguments and combines their elements to make a new list:
     Otra técnica de programación convencional consiste en @"(@c(cons) subir)
     una lista de respuestas mientras se @c(cdr) desplaza por una lista, como en
     el procedimiento @c(append), que toma dos listas como argumentos y combina
     sus elementos para crear una nueva lista:

#      ..srci > scheme
#        > (append squares odds)
#        (1 4 9 16 25 1 3 5 7)
#        > (append odds squares)
#        (1 3 5 7 1 4 9 16 25)
#      < srci..
     ..srci > scheme
       > (append squares odds)
       (1 4 9 16 25 1 3 5 7)
       > (append odds squares)
       (1 3 5 7 1 4 9 16 25)
     < srci..

#      @c(Append) is also implemented using a recursive plan. To @c(append) lists
#      @c(list1) and @c(list2), do the following:
     @c(Append) También se implementa utilizando un plan recursivo. A las
     @c(append) listas @c(list1) y @c(list2), haga lo siguiente:

#      - If @c(list1) is the empty list, then the result is just @c(list2).
     - Si @c(list1) es la lista vacía, entonces el resultado es justo @c(list2).

#      - Otherwise, @c(append) the @c(cdr) of @c(list1) and @c(list2), and @c(cons)
#        the @c(car) of @c(list1) onto the result:
     - De lo contrario, @c(append) el @c(cdr) de @c(list1) y @c(list2), y
       @c(cons) el @c(car) de @c(list1) en el resultado:


#      ..src > scheme
#        (define (append list1 list2)
#          (if (null? list1)
#              list2
#              (cons (car list1)
#                    (append (cdr list1)
#                            list2))))
#      < src..
     ..src > scheme
       (define (append list1 list2)
         (if (null? list1)
             list2
             (cons (car list1)
                   (append (cdr list1)
                           list2))))
     < src..

#      :: @t(Exercise 2.17) :: Define a procedure @c(last-pair) that returns the list
#         that contains only the last element of a given (nonempty) list:
     :: @t(Ejercicio 2.17) :: Definir un procedimiento @c(last-pair) que
        devuelve la lista que contiene sólo el último elemento de una lista dada
        (no vacía):

#         ..srci > scheme
#           > (last-pair (list 23 72 149 34))
#           (34)
#         < srci..
        ..srci > scheme
          > (last-pair (list 23 72 149 34))
          (34)
        < srci..

#      :: @t(Exercise 2.18) :: Define a procedure @c(reverse) that takes a list as
#         argument and returns a list of the same elements in reverse order:
     :: @t(Ejercicio 2.18) :: Defina un procedimiento @c(reverse) que toma una
        lista como argumento y devuelve una lista de los mismos elementos en
        orden inverso:

#         ..srci > scheme
#           > (reverse (list 1 4 9 16 25))
#           (25 16 9 4 1)
#         < srci..
        ..srci > scheme
          > (reverse (list 1 4 9 16 25))
          (25 16 9 4 1)
        < srci..

#      :: @t(Exercise 2.19) :: Consider the change-counting program of section @l(#1.2.2). It
#         would be nice to be able to easily change the currency used by the program,
#         so that we could compute the number of ways to change a British pound, for
#         example. As the program is written, the knowledge of the currency is
#         distributed partly into the procedure @c(first-denomination) and partly
#         into the procedure @c(count-change) (which knows that there are five kinds
#         of U.S. coins). It would be nicer to be able to supply a list of coins to
#         be used for making change.
     :: @t(Ejercicio 2.19) :: Considere el programa de recuento de cambios de
        @l(#1.2.2). Sería bueno ser capaz de cambiar fácilmente la moneda
        utilizada por el programa, por lo que podríamos calcular el número de
        formas de cambiar una libra esterlina, por ejemplo. A medida que el
        programa está escrito, el conocimiento de la moneda se distribuye
        parcialmente en el procedimiento @c(first-denomination) y en parte en el
        procedimiento @c(count-change)(que sabe que hay cinco tipos de monedas
        estadounidenses). Sería más agradable ser capaz de proporcionar una
        lista de monedas que se utilizarán para hacer el cambio.

#         We want to rewrite the procedure @c(cc) so that its second argument is a
#         list of the values of the coins to use rather than an integer specifying
#         which coins to use. We could then have lists that defined each kind of
#         currency:
        Queremos reescribir el procedimiento @c(cc) para que su segundo
        argumento sea una lista de los valores de las monedas que se usen en
        lugar de un número entero que especifique qué monedas
        utilizar. Podríamos entonces tener listas que definieran cada tipo de
        moneda:

#         ..src > scheme
#           (define us-coins
#             (list 50 25 10 5 1))
#
#           (define uk-coins
#             (list 100 50 20 10 5 2 1 0.5))
#         < src..
        ..src > scheme
          (define us-coins
            (list 50 25 10 5 1))

          (define uk-coins
            (list 100 50 20 10 5 2 1 0.5))
        < src..

#         We could then call @c(cc) as follows:
        Podríamos entonces llamar @c(cc) como sigue:

#         ..srci > scheme
#           > (cc 100 us-coins)
#           292
#         < srci..
        ..srci > scheme
          > (cc 100 us-coins)
          292
        < srci..

#         To do this will require changing the program @c(cc) somewhat. It will still
#         have the same form, but it will access its second argument differently, as
#         follows:
        Para hacer esto se requiere cambiar el programa de @c(cc) alguna
        manera. Seguirá teniendo la misma forma, pero accederá a su segundo
        argumento de manera diferente, como sigue:

#         ..src > scheme
#           (define (cc amount coin-values)
#             (cond ((= amount 0)
#                    1)
#                   ((or (< amount 0)
#                        (no-more? coin-values))
#                    0)
#                   (else
#                    (+ (cc
#                        amount
#                        (except-first-denomination
#                         coin-values))
#                       (cc
#                        (- amount
#                           (first-denomination
#                            coin-values))
#                        coin-values)))))
#         < src..
        ..src > scheme
          (define (cc amount coin-values)
            (cond ((= amount 0)
                   1)
                  ((or (< amount 0)
                       (no-more? coin-values))
                   0)
                  (else
                   (+ (cc
                       amount
                       (except-first-denomination
                        coin-values))
                      (cc
                       (- amount
                          (first-denomination
                           coin-values))
                       coin-values)))))
        < src..

#         Define the procedures @c(first-denomination), @c(except-first-denomination)
#         and @c(no-more?) in terms of primitive operations on list structures. Does
#         the order of the list @c(coin-values) affect the answer produced by @c(cc)?
#         Why or why not?
        Definir los procedimientos @c(first-denomination),
        @c(except-first-denomination) y @c(no-more?) en términos de operaciones
        primitivas en estructuras de lista. ¿El orden de la lista
        @c(coin-values) afecta a la respuesta producida por @c(cc)? ¿Por qué o
        por qué no?

#      :: @t(Exercise 2.20) :: The procedures @c(+), @c(*), and @c(list) take
#         arbitrary numbers of arguments. One way to define such procedures is to use
#         @c(define) with @e(dotted-tail notation).  In a procedure definition, a
#         parameter list that has a dot before the last parameter name indicates
#         that, when the procedure is called, the initial parameters (if any) will
#         have as values the initial arguments, as usual, but the final parameter's
#         value will be a @e(list) of any remaining arguments. For instance, given
#         the definition
     :: @t(Ejercicio 2.20) :: Los procedimientos @c(+), @c(*) y @c(list) toman
        un número arbitrario de argumentos. Una forma de definir tales
        procedimientos es usar @c(define) con la @e(notación de punta de
        cola). En una definición de procedimiento, una lista de parámetros que
        tiene un punto antes del último nombre de parámetro indica que, cuando
        se llama al procedimiento, los parámetros iniciales (si los hay) tendrán
        como valores los argumentos iniciales, como de costumbre, pero el valor
        del parámetro final será Ser una @e(lista) de los argumentos
        restantes. Por ejemplo, dada la definición

#         ..src > scheme
#           (define (f x y . z) ⟨body⟩)
#         < src..
        ..src > scheme
          (define (f x y . z) ⟨body⟩)
        < src..

#         the procedure @c(f) can be called with two or more arguments. If we
#         evaluate
        El procedimiento @c(f) se puede llamar con dos o más argumentos. Si
        evaluamos

#         ..src > scheme
#           (f 1 2 3 4 5 6)
#         < src..
        ..src > scheme
          (f 1 2 3 4 5 6)
        < src..

#         then in the body of @c(f), @c(x) will be 1, @c(y) will be 2, and @c(z) will
#         be the list @c[(3 4 5 6)]. Given the definition
        Entonces en el cuerpo de @c(f), @c(x) será 1, @c(y) será 2, y @c(z) será
        la lista @c[(3 4 5 6)]. Dada la definición

#         ..src > scheme
#           (define (g . w) ⟨body⟩)
#         < src..
        ..src > scheme
          (define (g . w) ⟨body⟩)
        < src..

#         the procedure @c(g) can be called with zero or more arguments. If we
#         evaluate
        El procedimiento @c(g) se puede llamar con cero o más argumentos. Si
        evaluamos

#         ..src > scheme
#           (g 1 2 3 4 5 6)
#         < src..
        ..src > scheme
          (g 1 2 3 4 5 6)
        < src..

#         then in the body of @c(g), @c(w) will be the list @c[(1 2 3 4 5 6)].@n(77)
        Entonces en el cuerpo de @c(g), @c(w) será la lista @c[(1 2 3 4 5
        6)].@n(77)

#         Use this notation to write a procedure @c(same-parity) that takes one or
#         more integers and returns a list of all the arguments that have the same
#         even-odd parity as the first argument. For example,
        Utilice esta notación para escribir un procedimiento @c(same-parity) que
        toma uno o más enteros y devuelve una lista de todos los argumentos que
        tienen la misma paridad pares-impares que el primer argumento. Por
        ejemplo,

#         ..srci > scheme
#           > (same-parity 1 2 3 4 5 6 7)
#           (1 3 5 7)
#           > (same-parity 2 3 4 5 6 7)
#           (2 4 6)
#         < srci..
        ..srci > scheme
          > (same-parity 1 2 3 4 5 6 7)
          (1 3 5 7)
          > (same-parity 2 3 4 5 6 7)
          (2 4 6)
        < srci..

# **** Mapping over lists
**** Mapeo de listas

#      One extremely useful operation is to apply some transformation to each element
#      in a list and generate the list of results. For instance, the following
#      procedure scales each number in a list by a given factor:
     Una operación extremadamente útil es aplicar alguna transformación a cada
     elemento en una lista y generar la lista de resultados. Por ejemplo, el
     siguiente procedimiento escala cada número en una lista por un factor dado:

#      ..srci > scheme
#        > (define (scale-list items factor)
#        ^   (if (null? items)
#        ^       nil
#        ^       (cons (* (car items) factor)
#        ^             (scale-list (cdr items)
#        ^                         factor))))
#
#        > (scale-list (list 1 2 3 4 5) 10)
#        (10 20 30 40 50)}
#      < srci..
     ..srci > scheme
       > (define (scale-list items factor)
       ^   (if (null? items)
       ^       nil
       ^       (cons (* (car items) factor)
       ^             (scale-list (cdr items)
       ^                         factor))))

       > (scale-list (list 1 2 3 4 5) 10)
       (10 20 30 40 50)}
     < srci..

#      We can abstract this general idea and capture it as a common pattern expressed
#      as a higher-order procedure, just as in section @l(#1.3). The higher-order procedure
#      here is called @c(map). @c(Map) takes as arguments a procedure of one argument
#      and a list, and returns a list of the results produced by applying the
#      procedure to each element in the list:@n(78)
     Podemos abstraer esta idea general y capturarla como un patrón común
     expresado como un procedimiento de orden superior, al igual que en
     @l(#1.3). Aquí se llama el procedimiento de orden superior
     @c(map). @c(Map) Toma como argumentos un procedimiento de un argumento y
     una lista y devuelve una lista de los resultados producidos aplicando el
     procedimiento a cada elemento de la lista:@n(78)

#      ..srci > scheme
#        > (define (map proc items)
#        ^   (if (null? items)
#        ^       nil
#        ^       (cons (proc (car items))
#        ^             (map proc (cdr items)))))
#
#        > (map abs (list -10 2.5 -11.6 17))
#        (10 2.5 11.6 17)
#        > (map (lambda (x) (* x x)) (list 1 2 3 4))
#        (1 4 9 16)
#      < srci..
     ..srci > scheme
       > (define (map proc items)
       ^   (if (null? items)
       ^       nil
       ^       (cons (proc (car items))
       ^             (map proc (cdr items)))))

       > (map abs (list -10 2.5 -11.6 17))
       (10 2.5 11.6 17)
       > (map (lambda (x) (* x x)) (list 1 2 3 4))
       (1 4 9 16)
     < srci..

#      Now we can give a new definition of @c(scale-list) in terms of @c(map):
     Ahora podemos dar una nueva definición de @c(scale-list) en términos de
     @c(map):

#      ..src > scheme
#        (define (scale-list items factor)
#          (map (lambda (x) (* x factor))
#               items))
#      < src..
     ..src > scheme
       (define (scale-list items factor)
         (map (lambda (x) (* x factor))
              items))
     < src..

#      @c(Map) is an important construct, not only because it captures a common
#      pattern, but because it establishes a higher level of abstraction in dealing
#      with lists. In the original definition of @c(scale-list), the recursive
#      structure of the program draws attention to the element-by-element processing
#      of the list. Defining @c(scale-list) in terms of @c(map) suppresses that level
#      of detail and emphasizes that scaling transforms a list of elements to a list
#      of results. The difference between the two definitions is not that the
#      computer is performing a different process (it isn't) but that we think about
#      the process differently. In effect, @c(map) helps establish an abstraction
#      barrier that isolates the implementation of procedures that transform lists
#      from the details of how the elements of the list are extracted and combined.
#      Like the barriers shown in @l(#Figure 2.1), this abstraction gives us the
#      flexibility to change the low-level details of how sequences are implemented,
#      while preserving the conceptual framework of operations that transform
#      sequences to sequences. Section @l(#2.2.3) expands on this use of sequences as
#      a framework for organizing programs.
     @c(Map) Es un constructo importante, no sólo porque captura un patrón
     común, sino porque establece un nivel superior de abstracción al tratar con
     las listas. En la definición original de @c(scale-list), la estructura
     recursiva del programa llama la atención sobre el procesamiento elemento
     por elemento de la lista. La definición @c(scale-list) en términos de
     @c(map) suprime ese nivel de detalle y enfatiza que la escala transforma
     una lista de elementos en una lista de resultados. La diferencia entre las
     dos definiciones no es que la computadora está realizando un proceso
     diferente (no lo es), sino que pensamos en el proceso de manera
     diferente. En efecto, @c(map) ayuda a establecer una barrera de abstracción
     que aisla la implementación de procedimientos que transforman listas de los
     detalles de cómo se extraen y combinan los elementos de la
     lista. @l(#Figure-2.1<>Al igual que las barreras mostradas en la Figura
     2.1), esta abstracción nos da la flexibilidad para cambiar los detalles de
     bajo nivel de cómo se implementan las secuencias, preservando al mismo
     tiempo el marco conceptual de las operaciones que transforman las
     secuencias en secuencias. La sección @l(#2.2.3) amplía este uso de
     secuencias como un marco para organizar programas.

#      :: @t(Exercise 2.21) :: The procedure @c(square-list) takes a list of numbers
#         as argument and returns a list of the squares of those numbers.
     :: @t(Ejercicio 2.21) :: El procedimiento @c(square-list) toma una lista de
        números como argumento y devuelve una lista de los cuadrados de esos
        números.

#         ..src > scheme
#           (square-list (list 1 2 3 4))
#           @i{(1 4 9 16)}
#         < src..
        ..src > scheme
          (square-list (list 1 2 3 4))
          @i{(1 4 9 16)}
        < src..

#         Here are two different definitions of @c(square-list). Complete both of
#         them by filling in the missing expressions:
        Aquí hay dos definiciones diferentes de @c(square-list). Complete ambos
        rellenando las expresiones que faltan:

#         ..src > scheme
#           (define (square-list items)
#             (if (null? items)
#                 nil
#                 (cons ⟨??⟩ ⟨??⟩)))
#
#           (define (square-list items)
#             (map ⟨??⟩ ⟨??⟩))
#         < src..
        ..src > scheme
          (define (square-list items)
            (if (null? items)
                nil
                (cons ⟨??⟩ ⟨??⟩)))

          (define (square-list items)
            (map ⟨??⟩ ⟨??⟩))
        < src..

#      :: @t(Exercise 2.22) :: Louis Reasoner tries to rewrite the first
#         @c(square-list) procedure of @l(#Exercise 2.21) so that it evolves an
#         iterative process:
     :: @t(Ejercicio 2.22) :: Louis Reasoner trata de reescribir el primer
        procedimiento @c(square-list) del @l(#Ejercicio 2.21)
        para que desarrolle un proceso iterativo:

#         ..src > scheme
#           (define (square-list items)
#             (define (iter things answer)
#               (if (null? things)
#                   answer
#                   (iter (cdr things)
#                         (cons (square (car things))
#                               answer))))
#             (iter items nil))
#         < src..
        ..src > scheme
          (define (square-list items)
            (define (iter things answer)
              (if (null? things)
                  answer
                  (iter (cdr things)
                        (cons (square (car things))
                              answer))))
            (iter items nil))
        < src..

#         Unfortunately, defining @c(square-list) this way produces the answer list
#         in the reverse order of the one desired. Why?
        Desafortunadamente, la definición de @c(square-list) esta manera produce
        la lista de respuestas en el orden inverso del deseado. ¿Por qué?

#         Louis then tries to fix his bug by interchanging the arguments to @c(cons):
        Louis entonces intenta arreglar su insecto intercambiando los argumentos
        a @c(cons):

#         ..src > scheme
#           (define (square-list items)
#             (define (iter things answer)
#               (if (null? things)
#                   answer
#                   (iter (cdr things)
#                         (cons answer
#                               (square
#                                (car things))))))
#             (iter items nil))
#         < src..
        ..src > scheme
          (define (square-list items)
            (define (iter things answer)
              (if (null? things)
                  answer
                  (iter (cdr things)
                        (cons answer
                              (square
                               (car things))))))
            (iter items nil))
        < src..

#         This doesn't work either. Explain.
        Esto tampoco funciona. Explique.

#      :: @t(Exercise 2.23) :: The procedure @c(for-each) is similar to @c(map). It
#         takes as arguments a procedure and a list of elements. However, rather than
#         forming a list of the results, @c(for-each) just applies the procedure to
#         each of the elements in turn, from left to right.  The values returned by
#         applying the procedure to the elements are not used at all––@c(for-each) is
#         used with procedures that perform an action, such as printing. For example,
     :: @t(Ejercicio 2.23) :: El procedimiento @c(for-each) es similar a
        @c(map). Toma como argumentos un procedimiento y una lista de
        elementos. Sin embargo, en lugar de formar una lista de los resultados,
        @c(for-each) sólo aplica el procedimiento a cada uno de los elementos a
        su vez, de izquierda a derecha. Los valores devueltos mediante la
        aplicación del procedimiento a los elementos no se utilizan en
        absoluto - @c(for-each) se utiliza con los procedimientos que realizan
        una acción, como la impresión. Por ejemplo,

#         ..srci > scheme
#           > (for-each
#           ^  (lambda (x) (newline) (display x))
#           ^  (list 57 321 88))
#           57
#           321
#           88
#         < srci..
        ..srci > scheme
          > (for-each
          ^  (lambda (x) (newline) (display x))
          ^  (list 57 321 88))
          57
          321
          88
        < srci..

#         The value returned by the call to @c(for-each) (not illustrated above) can
#         be something arbitrary, such as true. Give an implementation of
#         @c(for-each).
        El valor devuelto por la llamada a @c(for-each)(no ilustrado
        anteriormente) puede ser algo arbitrario, como true. Dar una
        implementación de @c(for-each).

# *** 2.2.2 <> Hierarchical Structures
*** 2.2.2 <> Estructuras jerárquicas

#     The representation of sequences in terms of lists generalizes naturally to
#     represent sequences whose elements may themselves be sequences. For example,
#     we can regard the object @c[((1 2) 3 4)] constructed by
    La representación de secuencias en términos de listas generaliza
    naturalmente para representar secuencias cuyos elementos pueden ser
    secuencias. Por ejemplo, podemos considerar el objeto @c[((1 2) 3 4)]
    construido por

#     ..src > scheme
#       (cons (list 1 2) (list 3 4))
#     < src..
    ..src > scheme
      (cons (list 1 2) (list 3 4))
    < src..

#     as a list of three items, the first of which is itself a list, @c[(1 2)].
#     Indeed, this is suggested by the form in which the result is printed by the
#     interpreter. @l(#Figure 2.5) shows the representation of this structure in
#     terms of pairs.
    Como una lista de tres elementos, el primero de los cuales es en sí mismo
    una lista @c[(1 2)],. De hecho, esto es sugerido por la forma en que el
    resultado es impreso por el intérprete. @l(#Figura 2.5)
    muestra la representación de esta estructura en términos de pares.

#     ..figure > @t(Figure 2.5) Structure formed by @c[(cons (list 1 2) (list 3 4))].
    ..figure > @t(Figura 2.5) Estructura formada por @c[(cons (list 1 2) (list 3
    4))].

#       ..art >
#               ((1 2) 3 4)                   (3 4)
#                    │                          │
#                    ▼                          ▼
#                ╭───┬───╮                  ╭───┬───╮     ╭───┬───╮
#                │ ◆ │ ◆ ┼─────────────────▶│ ◆ │ ◆ ┼────▶│ ◆ │ ╱ │
#                ╰─┼─┴───╯                  ╰─┼─┴───╯     ╰─┼─┴───╯
#                  │                          │             │
#                  ▼                          ▼             ▼
#         (1 2)  ╭───┬───╮     ╭───┬───╮    ╭───╮         ╭───╮
#         ──────▶│ ◆ │ ◆ ┼────▶│ ◆ │ ╱ │    │ 3 │         │ 4 │
#                ╰─┼─┴───╯     ╰─┼─┴───╯    ╰───╯         ╰───╯
#                  │             │
#                  ▼             ▼
#                ╭───╮         ╭───╮
#                │ 1 │         │ 2 │
#                ╰───╯         ╰───╯
#       < art..
      ..art >
              ((1 2) 3 4)                   (3 4)
                   │                          │
                   ▼                          ▼
               ╭───┬───╮                  ╭───┬───╮     ╭───┬───╮
               │ ◆ │ ◆ ┼─────────────────▶│ ◆ │ ◆ ┼────▶│ ◆ │ ╱ │
               ╰─┼─┴───╯                  ╰─┼─┴───╯     ╰─┼─┴───╯
                 │                          │             │
                 ▼                          ▼             ▼
        (1 2)  ╭───┬───╮     ╭───┬───╮    ╭───╮         ╭───╮
        ──────▶│ ◆ │ ◆ ┼────▶│ ◆ │ ╱ │    │ 3 │         │ 4 │
               ╰─┼─┴───╯     ╰─┼─┴───╯    ╰───╯         ╰───╯
                 │             │
                 ▼             ▼
               ╭───╮         ╭───╮
               │ 1 │         │ 2 │
               ╰───╯         ╰───╯
      < art..

# @   ..img > img/chap2/Fig2.5e.std.svg
@   ..img > img/chap2/Fig2.5e.std.svg

#     Another way to think of sequences whose elements are sequences is as
#     @e(trees). The elements of the sequence are the branches of the tree, and
#     elements that are themselves sequences are subtrees. @l(#Figure 2.6) shows the
#     structure in @l(#Figure 2.5) viewed as a tree.
    Otra forma de pensar en secuencias cuyos elementos son secuencias es como
    @e(árboles). Los elementos de la secuencia son las ramas del árbol, y los
    elementos que son ellos mismos secuencias son subárboles. @l(#Figura 2.6) muestra la estructura de la @l(#Figura 2.5) vista
    como un árbol.

#     ..figure > @t(Figure 2.6) The list structure in @l(#Figure 2.5) viewed as a tree.
    ..figure > @t(Figura 2.6) La estructura de lista en la
      @l(#Figura 2.5 se) ve como un árbol.

#       ..art >
#            ((1 2) 3 4)
#                /|\
#               / | \
#              /  |  \
#             /   |   \
#          (1 2)  3    4
#           / \
#          /   \
#         1     2
#       < art..
      ..art >
           ((1 2) 3 4)
               /|\
              / | \
             /  |  \
            /   |   \
         (1 2)  3    4
          / \
         /   \
        1     2
      < art..

# @   ..img > img/chap2/Fig2.6b.std.svg
@   ..img > img/chap2/Fig2.6b.std.svg

#     Recursion is a natural tool for dealing with tree structures, since we can
#     often reduce operations on trees to operations on their branches, which reduce
#     in turn to operations on the branches of the branches, and so on, until we
#     reach the leaves of the tree. As an example, compare the @c(length) procedure
#     of section @l(#2.2.1) with the @c(count-leaves) procedure, which returns the total
#     number of leaves of a tree:
    La recursión es una herramienta natural para tratar con las estructuras
    arbóreas, ya que a menudo podemos reducir las operaciones de los árboles a
    las operaciones en sus ramas, lo que reduce a su vez las operaciones en las
    ramas de las ramas, y así sucesivamente, hasta llegar a las hojas del
    árbol. Como ejemplo, compare el procedimiento @c(length) de
    @l(#2.2.1) con el procedimiento @c(count-leaves), que devuelve el
    número total de hojas de un árbol:

#     ..srci > scheme
#       > (define x (cons (list 1 2) (list 3 4)))
#       > (length x)
#       3
#       > (count-leaves x)
#       4
#       > (list x x)
#       (((1 2) 3 4) ((1 2) 3 4))
#       > (length (list x x))
#       2
#       > (count-leaves (list x x))
#       8
#     < srci..
    ..srci > scheme
      > (define x (cons (list 1 2) (list 3 4)))
      > (length x)
      3
      > (count-leaves x)
      4
      > (list x x)
      (((1 2) 3 4) ((1 2) 3 4))
      > (length (list x x))
      2
      > (count-leaves (list x x))
      8
    < srci..

#     To implement @c(count-leaves), recall the recursive plan for computing
#     @c(length):
    Para implementar @c(count-leaves), recordar el plan recursivo para la
    informática @c(length):

#     - @c(Length) of a list @c(x) is 1 plus @c(length) of the @c(cdr) of @c(x).
    - @c(Length) De una lista @c(x) es 1 más @c(length) de la @c(cdr) de @c(x).

#     - @c(Length) of the empty list is 0.
    - @c(Length) De la lista vacía es 0.


#     @c(Count-leaves) is similar. The value for the empty list is the same:
    @c(Count-leaves) es similar. El valor de la lista vacía es el mismo:

#     - @c(Count-leaves) of the empty list is 0.
    - @c(Count-leaves) De la lista vacía es 0.

#     But in the reduction step, where we strip off the @c(car) of the list, we must
#     take into account that the @c(car) may itself be a tree whose leaves we need
#     to count. Thus, the appropriate reduction step is
    Pero en el paso de la reducción, donde despojamos el @c(car) de la lista,
    debemos tener en cuenta que el @c(car) mismo puede ser un árbol cuyas hojas
    necesitamos contar. Así, la etapa de reducción apropiada es

#     - @c(Count-leaves) of a tree @c(x) is @c(count-leaves) of the @c(car) of @c(x)
#       plus @c(count-leaves) of the @c(cdr) of @c(x).
    - @c(Count-leaves) De un árbol @c(x) es @c(count-leaves) de la @c(car) de
      @c(x) más @c(count-leaves) de la @c(cdr) de @c(x).

#     Finally, by taking @c(car)s we reach actual leaves, so we need another base
#     case:
    Finalmente, al tomar @c(car) s llegamos a las hojas reales, por lo que
    necesitamos otro caso base:

#     - @c(Count-leaves) of a leaf is 1.
    - @c(Count-leaves) De una hoja es 1.

#     To aid in writing recursive procedures on trees, Scheme provides the primitive
#     predicate @c(pair?), which tests whether its argument is a pair. Here is the
#     complete procedure:@n(79)
    Para ayudar en la escritura de procedimientos recursivos en los árboles,
    Scheme proporciona el predicado primitivo @c(pair?), que comprueba si su
    argumento es un par. Aquí está el procedimiento completo:@n(79)

#     ..src > scheme
#       (define (count-leaves x)
#         (cond ((null? x) 0)
#               ((not (pair? x)) 1)
#               (else (+ (count-leaves (car x))
#                        (count-leaves (cdr x))))))
#     < src..
    ..src > scheme
      (define (count-leaves x)
        (cond ((null? x) 0)
              ((not (pair? x)) 1)
              (else (+ (count-leaves (car x))
                       (count-leaves (cdr x))))))
    < src..

#     :: @t(Exercise 2.24) :: Suppose we evaluate the expression @c[(list 1 (list 2
#        (list 3 4)))]. Give the result printed by the interpreter, the
#        corresponding box-and-pointer structure, and the interpretation of this as
#        a tree (as in @l(#Figure 2.6)).
    :: @t(Ejercicio 2.24) :: Supongamos que evaluamos la expresión @c[(list 1
       (list 2 (list 3 4)))]. Dé el resultado impreso por el intérprete, la
       estructura de cuadro y puntero correspondiente, y la interpretación de
       esto como un árbol (como en la @l(#Figura 2.6) ).

#     :: @t(Exercise 2.25) :: Give combinations of @c(car)s and @c(cdr)s that will
#        pick 7 from each of the following lists:
    :: @t(Ejercicio 2.25) :: Dé las combinaciones de @c(car) s y @c(cdr) s que
       escogerán 7 de cada una de las siguientes listas:

#        ..src > scheme
#          (1 3 (5 7) 9)
#          ((7))
#          (1 (2 (3 (4 (5 (6 7))))))
#        < src..
       ..src > scheme
         (1 3 (5 7) 9)
         ((7))
         (1 (2 (3 (4 (5 (6 7))))))
       < src..

#     :: @t(Exercise 2.26) :: Suppose we define @c(x) and @c(y) to be two lists:
    :: @t(Ejercicio 2.26) :: Supongamos que definimos @c(x) y hacemos @c(y) dos
       listas:

#        ..src > scheme
#          (define x (list 1 2 3))
#          (define y (list 4 5 6))
#        < src..
       ..src > scheme
         (define x (list 1 2 3))
         (define y (list 4 5 6))
       < src..

#        What result is printed by the interpreter in response to evaluating each of
#        the following expressions:
       Qué resultado se imprime por el intérprete en respuesta a la evaluación
       de cada una de las siguientes expresiones:

#        ..src > scheme
#          (append x y)
#          (cons x y)
#          (list x y)
#        < src..
       ..src > scheme
         (append x y)
         (cons x y)
         (list x y)
       < src..

#     :: @t(Exercise 2.27) :: Modify your @c(reverse) procedure of @l(#Exercise
#        2.18) to produce a @c(deep-reverse) procedure that takes a list as argument
#        and returns as its value the list with its elements reversed and with all
#        sublists deep-reversed as well. For example,
    :: @t(Ejercicio 2.27) :: Modifique su procedimiento @c(reverse) del
       @l(#Ejercicio 2.18) para producir un procedimiento @c(deep-reverse) que toma una lista como argumento y devuelve como su valor
       la lista con sus elementos invertidos y con todas las sublistas
       revertidas profundamente también. Por ejemplo,

#        ..srci > scheme
#          > (define x
#          ^   (list (list 1 2) (list 3 4)))
#          > x
#          ((1 2) (3 4))
#          > (reverse x)
#          ((3 4) (1 2))
#          > (deep-reverse x)
#          ((4 3) (2 1))
#        < srci..
       ..srci > scheme
         > (define x
         ^   (list (list 1 2) (list 3 4)))
         > x
         ((1 2) (3 4))
         > (reverse x)
         ((3 4) (1 2))
         > (deep-reverse x)
         ((4 3) (2 1))
       < srci..

#     :: @t(Exercise 2.28) :: Write a procedure @c(fringe) that takes as argument a
#        tree (represented as a list) and returns a list whose elements are all the
#        leaves of the tree arranged in left-to-right order. For example,
    :: @t(Ejercicio 2.28) :: Escribe un procedimiento @c(fringe) que toma como
    argumento un árbol (representado como una lista) y devuelve una lista cuyos
    elementos son todas las hojas del árbol ordenadas de izquierda a
    derecha. Por ejemplo,

#        ..srci > scheme
#          > (define x
#          ^   (list (list 1 2) (list 3 4)))
#
#          > (fringe x)
#          (1 2 3 4)
#          > (fringe (list x x))
#          (1 2 3 4 1 2 3 4)
#        < srci..
       ..srci > scheme
         > (define x
         ^   (list (list 1 2) (list 3 4)))

         > (fringe x)
         (1 2 3 4)
         > (fringe (list x x))
         (1 2 3 4 1 2 3 4)
       < srci..

#     :: @t(Exercise 2.29) :: A binary mobile consists of two branches, a left
#        branch and a right branch. Each branch is a rod of a certain length, from
#        which hangs either a weight or another binary mobile. We can represent a
#        binary mobile using compound data by constructing it from two branches (for
#        example, using @c(list)):
    :: @t(Ejercicio 2.29) :: Un móvil binario consta de dos ramas, una rama
       izquierda y una rama derecha. Cada rama es una barra de una cierta
       longitud, de la que cuelga un peso u otro móvil binario. Podemos
       representar un móvil binario usando datos compuestos construyéndolo a
       partir de dos ramas (por ejemplo, usando @c(list)):

#        ..src > scheme
#          (define (make-mobile left right)
#            (list left right))
#        < src..
       ..src > scheme
         (define (make-mobile left right)
           (list left right))
       < src..

#        A branch is constructed from a @c(length) (which must be a number) together
#        with a @c(structure), which may be either a number (representing a simple
#        weight) or another mobile:
       Una rama se construye de a @c(length)(que debe ser un número) junto con a
       @c(structure), que puede ser un número (que representa un peso simple) u
       otro móvil:

#        ..src > scheme
#          (define (make-branch length structure)
#            (list length structure))
#        < src..
       ..src > scheme
         (define (make-branch length structure)
           (list length structure))
       < src..

#        1. Write the corresponding selectors @c(left-branch) and @c(right-branch),
#           which return the branches of a mobile, and @c(branch-length) and
#           @c(branch-structure), which return the components of a branch.
       1. Escribe los selectores correspondientes @c(left-branch) y
          @c(right-branch), que devuelven las ramas de un móvil, y
          @c(branch-length) y @c(branch-structure), que devuelven los
          componentes de una rama.

#        2. Using your selectors, define a procedure @c(total-weight) that returns
#           the total weight of a mobile.
       2. Utilizando sus selectores, defina un procedimiento @c(total-weight)
          que devuelva el peso total de un móvil.

#        3. A mobile is said to be @e(balanced) if the torque applied by its
#           top-left branch is equal to that applied by its top-right branch (that
#           is, if the length of the left rod multiplied by the weight hanging from
#           that rod is equal to the corresponding product for the right side) and
#           if each of the submobiles hanging off its branches is balanced. Design a
#           predicate that tests whether a binary mobile is balanced.
       3. Se dice que un móvil está @e(equilibrado) si el par aplicado por su
          rama superior izquierda es igual al aplicado por su rama
          superior-derecha (es decir, si la longitud de la varilla izquierda
          multiplicada por el peso que cuelga de esa varilla es igual a El
          producto correspondiente para el lado derecho) y si cada uno de los
          submobiles que cuelgan de sus ramas es equilibrado. Diseñe un
          predicado que compruebe si un móvil binario está equilibrado.

#        4. Suppose we change the representation of mobiles so that the constructors
#           are
       4. Supongamos que cambiamos la representación de los móviles para que los
          constructores

#           ..src > scheme
#             (define (make-mobile left right)
#               (cons left right))
#
#             (define (make-branch length structure)
#               (cons length structure))
#           < src..
          ..src > scheme
            (define (make-mobile left right)
              (cons left right))

            (define (make-branch length structure)
              (cons length structure))
          < src..

#           How much do you need to change your programs to convert to the new
#           representation?
          ¿Cuánto necesita cambiar sus programas para convertir a la nueva
          representación?

# **** Mapping over trees
**** Mapeo de árboles

#      Just as @c(map) is a powerful abstraction for dealing with sequences, @c(map)
#      together with recursion is a powerful abstraction for dealing with trees. For
#      instance, the @c(scale-tree) procedure, analogous to @c(scale-list) of
#      @l(#2.2.1), takes as arguments a numeric factor and a tree whose leaves are
#      numbers. It returns a tree of the same shape, where each number is multiplied
#      by the factor. The recursive plan for @c(scale-tree) is similar to the one for
#      @c(count-leaves):
     Al igual @c(map) que una poderosa abstracción para tratar secuencias,
     @c(map) junto con la recursión es una poderosa abstracción para tratar con
     los árboles. Por ejemplo, el procedimiento @c(scale-tree), análogo al
     @c(scale-list) de la seccion @l(#2.2.1), toma como argumentos un factor
     numérico y un árbol cuyas hojas son números. Devuelve un árbol de la misma
     forma, donde cada número es multiplicado por el factor. El plan recursivo
     @c(scale-tree) es similar al de @c(count-leaves):

#      ..srci > scheme
#        > (define (scale-tree tree factor)
#        ^   (cond ((null? tree) nil)
#        ^         ((not (pair? tree))
#        ^          (* tree factor))
#        ^         (else
#        ^          (cons (scale-tree (car tree)
#        ^                            factor)
#        ^                (scale-tree (cdr tree)
#        ^                            factor)))))
#
#        > (scale-tree (list 1
#        ^                   (list 2 (list 3 4) 5)
#        ^                   (list 6 7))
#        ^             10)
#        (10 (20 (30 40) 50) (60 70))
#      < srci..
     ..srci > scheme
       > (define (scale-tree tree factor)
       ^   (cond ((null? tree) nil)
       ^         ((not (pair? tree))
       ^          (* tree factor))
       ^         (else
       ^          (cons (scale-tree (car tree)
       ^                            factor)
       ^                (scale-tree (cdr tree)
       ^                            factor)))))

       > (scale-tree (list 1
       ^                   (list 2 (list 3 4) 5)
       ^                   (list 6 7))
       ^             10)
       (10 (20 (30 40) 50) (60 70))
     < srci..

#      Another way to implement @c(scale-tree) is to regard the tree as a sequence of
#      sub-trees and use @c(map). We map over the sequence, scaling each sub-tree in
#      turn, and return the list of results. In the base case, where the tree is a
#      leaf, we simply multiply by the factor:
     Otra forma de implementar @c(scale-tree) es considerar el árbol como una
     secuencia de sub-árboles y usarlo @c(map). Mapeamos la secuencia, escalando
     cada sub-árbol a su vez y devolviendo la lista de resultados. En el caso
     base, donde el árbol es una hoja, simplemente multiplicamos por el factor:

#      ..src > scheme
#        (define (scale-tree tree factor)
#          (map (lambda (sub-tree)
#                 (if (pair? sub-tree)
#                     (scale-tree sub-tree factor)
#                     (* sub-tree factor)))
#               tree))
#      < src..
     ..src > scheme
       (define (scale-tree tree factor)
         (map (lambda (sub-tree)
                (if (pair? sub-tree)
                    (scale-tree sub-tree factor)
                    (* sub-tree factor)))
              tree))
     < src..

#      Many tree operations can be implemented by similar combinations of sequence
#      operations and recursion.
     Muchas operaciones de árbol pueden ser implementadas por combinaciones
     similares de operaciones de secuencia y recursión.

#      :: @t(Exercise 2.30) :: Define a procedure @c(square-tree) analogous to the
#         @c(square-list) procedure of @l(#Exercise 2.21). That is, @c(square-tree)
#         should behave as follows:
     :: @t(Ejercicio 2.30) :: Definir un procedimiento @c(square-tree) análogo
        al procedimiento @c(square-list) del @l(#Ejercicio
        2.21). Es decir, @c(square-tree) debe comportarse de la siguiente
        manera:

#         ..srci > scheme
#           > (square-tree
#           ^  (list 1
#           ^        (list 2 (list 3 4) 5)
#           ^        (list 6 7)))
#           (1 (4 (9 16) 25) (36 49))
#         < srci..
        ..srci > scheme
          > (square-tree
          ^  (list 1
          ^        (list 2 (list 3 4) 5)
          ^        (list 6 7)))
          (1 (4 (9 16) 25) (36 49))
        < srci..

#         Define @c(square-tree) both directly (i.e., without using any higher-order
#         procedures) and also by using @c(map) and recursion.
        Definir @c(square-tree) tanto directamente (es decir, sin utilizar
        ningún procedimiento de orden superior) y también mediante el uso
        @c(map) y la recursión.

#      :: @t(Exercise 2.31) :: Abstract your answer to @l(#Exercise 2.30) to produce
#         a procedure @c(tree-map) with the property that @c(square-tree) could be
#         defined as
     :: @t(Ejercicio 2.31) :: Resuma su respuesta al
        @l(#Ejercicio 2.30) para producir un procedimiento
        @c(tree-map) con la propiedad que @c(square-tree) podría definirse como

#         ..src > scheme
#           (define (square-tree tree)
#             (tree-map square tree))
#         < src..
        ..src > scheme
          (define (square-tree tree)
            (tree-map square tree))
        < src..

#      :: @t(Exercise 2.32) :: We can represent a set as a list of distinct elements,
#         and we can represent the set of all subsets of the set as a list of
#         lists. For example, if the set is @c[(1 2 3)], then the set of all subsets
#         is @c[(() (3) (2) (2 3) (1) (1 3) (1 2) (1 2 3))]. Complete the following
#         definition of a procedure that generates the set of subsets of a set and
#         give a clear explanation of why it works:
     :: @t(Ejercicio 2.32) :: Podemos representar un conjunto como una lista de
        elementos distintos, y podemos representar el conjunto de todos los
        subconjuntos del conjunto como una lista de listas. Por ejemplo, si el
        conjunto es @c[(1 2 3)], entonces el conjunto de todos los subconjuntos
        es @c[(() (3) (2) (2 3) (1) (1 3) (1 2) (1 2 3))]. Complete la siguiente
        definición de un procedimiento que genere el conjunto de subconjuntos de
        un conjunto y dé una explicación clara de por qué funciona:

#         ..src > scheme
#           (define (subsets s)
#             (if (null? s)
#                 (list nil)
#                 (let ((rest (subsets (cdr s))))
#                   (append rest (map ⟨??⟩ rest)))))
#         < src..
        ..src > scheme
          (define (subsets s)
            (if (null? s)
                (list nil)
                (let ((rest (subsets (cdr s))))
                  (append rest (map ⟨??⟩ rest)))))
        < src..

# *** 2.2.3 <> Sequences as Conventional Interfaces
*** 2.2.3 <> Secuencias como interfaces convencionales

#     In working with compound data, we've stressed how data abstraction permits us
#     to design programs without becoming enmeshed in the details of data
#     representations, and how abstraction preserves for us the flexibility to
#     experiment with alternative representations. In this section, we introduce
#     another powerful design principle for working with data structures––the use of
#     @e(conventional interfaces).
    Al trabajar con datos compuestos, hemos resaltado cómo la abstracción de
    datos nos permite diseñar programas sin involucrarnos en los detalles de las
    representaciones de datos y cómo la abstracción nos preserva la flexibilidad
    para experimentar con representaciones alternativas. En esta sección,
    introducimos otro poderoso principio de diseño para trabajar con estructuras
    de datos: el uso de @e(interfaces convencionales).

#     in section @l(#1.3) we saw how program abstractions, implemented as higher-order
#     procedures, can capture common patterns in programs that deal with numerical
#     data. Our ability to formulate analogous operations for working with compound
#     data depends crucially on the style in which we manipulate our data
#     structures. Consider, for example, the following procedure, analogous to the
#     @c(count-leaves) procedure of section @l(#2.2.2), which takes a tree as argument and
#     computes the sum of the squares of the leaves that are odd:
    en la seccion @l(#1.3) vimos cómo las abstracciones de programas, implementadas
    como procedimientos de orden superior, pueden capturar patrones comunes en
    programas que tratan con datos numéricos. Nuestra capacidad de formular
    operaciones análogas para trabajar con datos compuestos depende crucialmente
    del estilo en el que manipulamos nuestras estructuras de
    datos. Consideremos, por ejemplo, el siguiente procedimiento, análogo al
    procedimiento @c(count-leaves) de la seccion @l(#2.2.2), que toma un árbol como
    argumento y calcula la suma de los cuadrados de las hojas que son impares:

#     ..src > scheme
#       (define (sum-odd-squares tree)
#         (cond ((null? tree) 0)
#               ((not (pair? tree))
#                (if (odd? tree) (square tree) 0))
#               (else (+ (sum-odd-squares
#                         (car tree))
#                        (sum-odd-squares
#                         (cdr tree))))))
#     < src..
    ..src > scheme
      (define (sum-odd-squares tree)
        (cond ((null? tree) 0)
              ((not (pair? tree))
               (if (odd? tree) (square tree) 0))
              (else (+ (sum-odd-squares
                        (car tree))
                       (sum-odd-squares
                        (cdr tree))))))
    < src..

#     On the surface, this procedure is very different from the following one, which
#     constructs a list of all the even Fibonacci numbers @m[Fib(k)], where @m(k) is
#     less than or equal to a given integer @m(n):
    En la superficie, este procedimiento es muy diferente del siguiente, que
    construye una lista de todos los números pares de Fibonacci @m(Fib (k)),
    donde @m(k) es menor o igual que un entero dado @m(n) :

#     ..src > scheme
#       (define (even-fibs n)
#         (define (next k)
#           (if (> k n)
#               nil
#               (let ((f (fib k)))
#                 (if (even? f)
#                     (cons f (next (+ k 1)))
#                     (next (+ k 1))))))
#         (next 0))
#     < src..
    ..src > scheme
      (define (even-fibs n)
        (define (next k)
          (if (> k n)
              nil
              (let ((f (fib k)))
                (if (even? f)
                    (cons f (next (+ k 1)))
                    (next (+ k 1))))))
        (next 0))
    < src..

#     Despite the fact that these two procedures are structurally very different, a
#     more abstract description of the two computations reveals a great deal of
#     similarity. The first program
    A pesar de que estos dos procedimientos son estructuralmente muy diferentes,
    una descripción más abstracta de los dos cálculos revela una gran
    similitud. El primer programa

#     - enumerates the leaves of a tree;
    - Enumera las hojas de un árbol;

#     - filters them, selecting the odd ones;
    - Los filtra, seleccionando los impares;

#     - squares each of the selected ones; and
    - Cuadrados cada uno de los seleccionados; y

#     - accumulates the results using @c(+), starting with 0.
    - Acumula los resultados usando @c(+), comenzando con 0.

#     The second program
    El segundo programa

#     - enumerates the integers from 0 to @m(n);
    - Enumera los enteros de 0 a @m(n) ;

#     - computes the Fibonacci number for each integer;
    - Calcula el número de Fibonacci para cada número entero;

#     - filters them, selecting the even ones; and
    - Los filtra, seleccionando los pares; y

#     - accumulates the results using @c(cons), starting with the empty list.
    - Acumula los resultados utilizando @c(cons), comenzando con la lista vacía.


#     A signal-processing engineer would find it natural to conceptualize these
#     processes in terms of signals flowing through a cascade of stages, each of
#     which implements part of the program plan, as shown in @l(#Figure 2.7). In
#     @c(sum-odd-squares), we begin with an @e(enumerator), which generates a
#     @"(signal) consisting of the leaves of a given tree. This signal is passed
#     through a @e(filter), which eliminates all but the odd elements. The resulting
#     signal is in turn passed through a @e(map), which is a @"(transducer) that
#     applies the @c(square) procedure to each element. The output of the map is
#     then fed to an @e(accumulator), which combines the elements using @c(+),
#     starting from an initial 0. The plan for @c(even-fibs) is analogous.
    Un ingeniero de procesamiento de señales encontraría natural conceptualizar
    estos procesos en términos de señales que fluyen a través de una cascada de
    etapas, cada una de las cuales implementa parte del plan del programa, como
    se muestra en la @l(#Figura 2.7). En @c(sum-odd-squares),
    comenzamos con un @e(enumerador), que genera una @"(señal que) consiste en
    las hojas de un árbol dado. Esta señal se pasa a través de un @e(filtro),
    que elimina todos excepto los elementos impares. La señal resultante se pasa
    a su vez a través de un @e(mapa), que es un @"(transductor) que aplica el
    procedimiento @c(square) a cada elemento. La salida del mapa es entonces
    alimentada a un @e(acumulador), que combina los elementos usando @c(+), a
    partir de un 0 inicial.@c(even-fibs)

#     ..figure > @t(Figure 2.7) The signal-flow plans for the procedures
#       @c(sum-odd-squares) (top) and @c(even-fibs) (bottom) reveal the commonality
#       between the two programs.
    ..figure > @t(Figura 2.7) Los planes de flujo de señal para los
      procedimientos @c(sum-odd-squares)(arriba) y @c(even-fibs)(abajo) revelan
      la coincidencia entre los dos programas.

#       ..art >
#         ╭─────────────╮   ╭──────────╮   ╭─────────╮   ╭─────────────╮
#         │ enumerate:  ├──▶│ filter:  ├──▶│ map:    ├──▶│ accumulate: │
#         │ tree leaves │   │ odd?     │   │ square  │   │ +, 0        │
#         ╰─────────────╯   ╰──────────╯   ╰─────────╯   ╰─────────────╯
#
#         ╭─────────────╮   ╭──────────╮   ╭─────────╮   ╭─────────────╮
#         │ enumerate:  ├──▶│ map:     ├──▶│ filter: ├──▶│ accumulate: │
#         │ integers    │   │ fib      │   │ even?   │   │ cons, ()    │
#         ╰─────────────╯   ╰──────────╯   ╰─────────╯   ╰─────────────╯
#       < art..
      ..art >
        ╭─────────────╮   ╭──────────╮   ╭─────────╮   ╭─────────────╮
        │ enumerate:  ├──▶│ filter:  ├──▶│ map:    ├──▶│ accumulate: │
        │ tree leaves │   │ odd?     │   │ square  │   │ +, 0        │
        ╰─────────────╯   ╰──────────╯   ╰─────────╯   ╰─────────────╯

        ╭─────────────╮   ╭──────────╮   ╭─────────╮   ╭─────────────╮
        │ enumerate:  ├──▶│ map:     ├──▶│ filter: ├──▶│ accumulate: │
        │ integers    │   │ fib      │   │ even?   │   │ cons, ()    │
        ╰─────────────╯   ╰──────────╯   ╰─────────╯   ╰─────────────╯
      < art..

# @   ..img > img/chap2/Fig2.7e.std.svg
@   ..img > img/chap2/Fig2.7e.std.svg

#     Unfortunately, the two procedure definitions above fail to exhibit this
#     signal-flow structure. For instance, if we examine the @c(sum-odd-squares)
#     procedure, we find that the enumeration is implemented partly by the @c(null?)
#     and @c(pair?) tests and partly by the tree-recursive structure of the
#     procedure. Similarly, the accumulation is found partly in the tests and partly
#     in the addition used in the recursion. In general, there are no distinct parts
#     of either procedure that correspond to the elements in the signal-flow
#     description. Our two procedures decompose the computations in a different way,
#     spreading the enumeration over the program and mingling it with the map, the
#     filter, and the accumulation. If we could organize our programs to make the
#     signal-flow structure manifest in the procedures we write, this would increase
#     the conceptual clarity of the resulting code.
    Desafortunadamente, las dos definiciones de procedimiento anteriores no
    presentan esta estructura de flujo de señal. Por ejemplo, si examinamos el
    procedimiento @c(sum-odd-squares), nos encontramos con que la enumeración se
    aplica en parte por los @c(null?) y las @c(pair?) pruebas y en parte por la
    estructura recursiva-árbol del procedimiento. De forma similar, la
    acumulación se encuentra en parte en las pruebas y en parte en la adición
    utilizada en la recursión. En general, no hay partes distintas de ninguno de
    los procedimientos que corresponden a los elementos de la descripción de
    flujo de señal. Nuestros dos procedimientos descomponen los cálculos de una
    manera diferente, difundiendo la enumeración sobre el programa y mezclándola
    con el mapa, el filtro y la acumulación. Si pudiéramos organizar nuestros
    programas para hacer que la estructura señal-flujo se manifieste en los
    procedimientos que escribimos,

# **** Sequence Operations
**** Operaciones de Secuencia

#      The key to organizing programs so as to more clearly reflect the signal-flow
#      structure is to concentrate on the @"(signals) that flow from one stage in the
#      process to the next. If we represent these signals as lists, then we can use
#      list operations to implement the processing at each of the stages. For
#      instance, we can implement the mapping stages of the signal-flow diagrams
#      using the @c(map) procedure from @l(#2.2.1):
     La clave para organizar los programas a fin de reflejar más claramente la
     estructura de flujo de señal es concentrarse en las @"(señales) que fluyen
     de una etapa en el proceso a la siguiente. Si representamos estas señales
     como listas, entonces podemos usar operaciones de lista para implementar el
     procesamiento en cada una de las etapas. Por ejemplo, podemos implementar
     las etapas de mapeo de los diagramas de flujo de señal usando el
     procedimiento @c(map) de la seccion @l(#2.2.1) :

#      ..srci > scheme
#        > (map square (list 1 2 3 4 5))
#        (1 4 9 16 25)
#      < srci..
     ..srci > scheme
       > (map square (list 1 2 3 4 5))
       (1 4 9 16 25)
     < srci..

#      Filtering a sequence to select only those elements that satisfy a given
#      predicate is accomplished by
     Filtrar una secuencia para seleccionar sólo aquellos elementos que
     satisfacen un predicado dado se logra mediante

#      ..src > scheme
#        (define (filter predicate sequence)
#          (cond ((null? sequence) nil)
#                ((predicate (car sequence))
#                 (cons (car sequence)
#                       (filter predicate
#                               (cdr sequence))))
#                (else  (filter predicate
#                               (cdr sequence)))))
#      < src..
     ..src > scheme
       (define (filter predicate sequence)
         (cond ((null? sequence) nil)
               ((predicate (car sequence))
                (cons (car sequence)
                      (filter predicate
                              (cdr sequence))))
               (else  (filter predicate
                              (cdr sequence)))))
     < src..

#      For example,
     Por ejemplo,

#      ..srci > scheme
#        > (filter odd? (list 1 2 3 4 5))
#        (1 3 5)
#      < srci..
     ..srci > scheme
       > (filter odd? (list 1 2 3 4 5))
       (1 3 5)
     < srci..

#      Accumulations can be implemented by
     Las acumulaciones pueden ser implementadas por

#      ..srci > scheme
#        > (define (accumulate op initial sequence)
#        ^   (if (null? sequence)
#        ^       initial
#        ^       (op (car sequence)
#        ^           (accumulate op
#        ^                       initial
#        ^                       (cdr sequence)))))
#
#        > (accumulate + 0 (list 1 2 3 4 5))
#        15
#        > (accumulate * 1 (list 1 2 3 4 5))
#        120
#        > (accumulate cons nil (list 1 2 3 4 5))
#        (1 2 3 4 5)
#      < srci..
     ..srci > scheme
       > (define (accumulate op initial sequence)
       ^   (if (null? sequence)
       ^       initial
       ^       (op (car sequence)
       ^           (accumulate op
       ^                       initial
       ^                       (cdr sequence)))))

       > (accumulate + 0 (list 1 2 3 4 5))
       15
       > (accumulate * 1 (list 1 2 3 4 5))
       120
       > (accumulate cons nil (list 1 2 3 4 5))
       (1 2 3 4 5)
     < srci..

#      All that remains to implement signal-flow diagrams is to enumerate the
#      sequence of elements to be processed. For @c(even-fibs), we need to generate
#      the sequence of integers in a given range, which we can do as follows:
     Todo lo que resta para implementar diagramas de flujo de señal es enumerar
     la secuencia de elementos a procesar. Para @c(even-fibs), tenemos que
     generar la secuencia de enteros en un rango dado, que podemos hacer de la
     siguiente manera:

#      ..srci > scheme
#        > (define (enumerate-interval low high)
#        ^   (if (> low high)
#        ^       nil
#        ^       (cons low
#        ^             (enumerate-interval
#        ^              (+ low 1)
#        ^              high))))
#        > (enumerate-interval 2 7)
#        (2 3 4 5 6 7)
#      < srci..
     ..srci > scheme
       > (define (enumerate-interval low high)
       ^   (if (> low high)
       ^       nil
       ^       (cons low
       ^             (enumerate-interval
       ^              (+ low 1)
       ^              high))))
       > (enumerate-interval 2 7)
       (2 3 4 5 6 7)
     < srci..

#      To enumerate the leaves of a tree, we can use@n(80)
     Para enumerar las hojas de un árbol, podemos usar@n(80)

#      ..srci > scheme
#        > (define (enumerate-tree tree)
#        ^   (cond ((null? tree) nil)
#        ^         ((not (pair? tree)) (list tree))
#        ^         (else (append
#        ^                (enumerate-tree (car tree))
#        ^                (enumerate-tree (cdr tree))))))
#        > (enumerate-tree (list 1 (list 2 (list 3 4)) 5))
#        (1 2 3 4 5)
#      < srci..
     ..srci > scheme
       > (define (enumerate-tree tree)
       ^   (cond ((null? tree) nil)
       ^         ((not (pair? tree)) (list tree))
       ^         (else (append
       ^                (enumerate-tree (car tree))
       ^                (enumerate-tree (cdr tree))))))
       > (enumerate-tree (list 1 (list 2 (list 3 4)) 5))
       (1 2 3 4 5)
     < srci..

#      Now we can reformulate @c(sum-odd-squares) and @c(even-fibs) as in the
#      signal-flow diagrams. For @c(sum-odd-squares), we enumerate the sequence of
#      leaves of the tree, filter this to keep only the odd numbers in the sequence,
#      square each element, and sum the results:
     Ahora podemos reformular @c(sum-odd-squares) y @c(even-fibs) como en los
     diagramas de flujo de señal. Para @c(sum-odd-squares), enumeramos la
     secuencia de las hojas del árbol, filtramos esto para guardar solamente los
     números impares en la secuencia, cuadramos cada elemento, y suma los
     resultados:

#      ..src > scheme
#        (define (sum-odd-squares tree)
#          (accumulate
#           +
#           0
#           (map square
#                (filter odd?
#                        (enumerate-tree tree)))))
#      < src..
     ..src > scheme
       (define (sum-odd-squares tree)
         (accumulate
          +
          0
          (map square
               (filter odd?
                       (enumerate-tree tree)))))
     < src..

#      For @c(even-fibs), we enumerate the integers from 0 to @m(n), generate the
#      Fibonacci number for each of these integers, filter the resulting sequence to
#      keep only the even elements, and accumulate the results into a list:
     Para @c(even-fibs), enumerar los números enteros de 0 a @m(n), generar el
     número de Fibonacci para cada uno de estos números enteros, filtrar la
     secuencia resultante para mantener sólo los elementos pares, y acumular los
     resultados en una lista:

#      ..src > scheme
#        (define (even-fibs n)
#          (accumulate
#           cons
#           nil
#           (filter even?
#                   (map fib
#                        (enumerate-interval 0 n)))))
#      < src..
     ..src > scheme
       (define (even-fibs n)
         (accumulate
          cons
          nil
          (filter even?
                  (map fib
                       (enumerate-interval 0 n)))))
     < src..

#      The value of expressing programs as sequence operations is that this helps us
#      make program designs that are modular, that is, designs that are constructed
#      by combining relatively independent pieces. We can encourage modular design by
#      providing a library of standard components together with a conventional
#      interface for connecting the components in flexible ways.
     El valor de expresar programas como operaciones de secuencia es que esto
     nos ayuda a hacer diseños de programas que son modulares, es decir, diseños
     que se construyen combinando piezas relativamente independientes. Podemos
     fomentar el diseño modular proporcionando una libreria de componentes
     estándar junto con una interfaz convencional para conectar los componentes
     de maneras flexibles.

#      Modular construction is a powerful strategy for controlling complexity in
#      engineering design. In real signal-processing applications, for example,
#      designers regularly build systems by cascading elements selected from
#      standardized families of filters and transducers. Similarly, sequence
#      operations provide a library of standard program elements that we can mix and
#      match. For instance, we can reuse pieces from the @c(sum-odd-squares) and
#      @c(even-fibs) procedures in a program that constructs a list of the squares of
#      the first @m(n + 1) Fibonacci numbers:
     La construcción modular es una poderosa estrategia para controlar la
     complejidad en el diseño de ingeniería. En aplicaciones de procesamiento de
     señales reales, por ejemplo, los diseñadores construyen regularmente
     sistemas mediante elementos en cascada seleccionados de familias
     estandarizadas de filtros y transductores. De manera similar, las
     operaciones de secuencia proporcionan una libreria de elementos de
     programa estándar que podemos mezclar y combinar. Por ejemplo, podemos
     reutilizar partes de los procedimientos @c(sum-odd-squares) y @c(even-fibs)
     en un programa que construye una lista de los cuadrados de los primeros
     @m(n + 1) números de Fibonacci:

#      ..srci > scheme
#        > (define (list-fib-squares n)
#        ^   (accumulate
#        ^    cons
#        ^    nil
#        ^    (map square
#        ^         (map fib
#        ^              (enumerate-interval 0 n)))))
#
#        > (list-fib-squares 10)
#        (0 1 1 4 9 25 64 169 441 1156 3025)
#      < srci..
     ..srci > scheme
       > (define (list-fib-squares n)
       ^   (accumulate
       ^    cons
       ^    nil
       ^    (map square
       ^         (map fib
       ^              (enumerate-interval 0 n)))))

       > (list-fib-squares 10)
       (0 1 1 4 9 25 64 169 441 1156 3025)
     < srci..

#      We can rearrange the pieces and use them in computing the product of the
#      squares of the odd integers in a sequence:
     Podemos reorganizar las piezas y utilizarlas para calcular el producto de
     los cuadrados de los números impares en una secuencia:

#      ..srci > scheme
#        > (define
#        ^   (product-of-squares-of-odd-elements
#        ^    sequence)
#        ^   (accumulate
#        ^    *
#        ^    1
#        ^    (map square (filter odd? sequence))))
#
#        > (product-of-squares-of-odd-elements
#        ^  (list 1 2 3 4 5))
#        225
#      < srci..
     ..srci > scheme
       > (define
       ^   (product-of-squares-of-odd-elements
       ^    sequence)
       ^   (accumulate
       ^    *
       ^    1
       ^    (map square (filter odd? sequence))))

       > (product-of-squares-of-odd-elements
       ^  (list 1 2 3 4 5))
       225
     < srci..

#      We can also formulate conventional data-processing applications in terms of
#      sequence operations. Suppose we have a sequence of personnel records and we
#      want to find the salary of the highest-paid programmer. Assume that we have a
#      selector @c(salary) that returns the salary of a record, and a predicate
#      @c(programmer?) that tests if a record is for a programmer. Then we can write
     También podemos formular aplicaciones convencionales de procesamiento de
     datos en términos de operaciones de secuencia. Supongamos que tenemos una
     secuencia de registros de personal y queremos encontrar el salario del
     programador mejor pagado. Supongamos que tenemos un selector @c(salary) que
     devuelve el salario de un registro y un predicado @c(programmer?) que
     prueba si un registro es para un programador. Entonces podemos escribir

#      ..src > scheme
#        (define
#          (salary-of-highest-paid-programmer
#           records)
#          (accumulate
#           max
#           0
#           (map salary
#                (filter programmer? records))))
#      < src..
     ..src > scheme
       (define
         (salary-of-highest-paid-programmer
          records)
         (accumulate
          max
          0
          (map salary
               (filter programmer? records))))
     < src..

#      These examples give just a hint of the vast range of operations that can be
#      expressed as sequence operations.@n(81)
     Estos ejemplos dan sólo una pizca de la amplia gama de operaciones que se
     pueden expresar como operaciones de secuencia.@n(81)

#      Sequences, implemented here as lists, serve as a conventional interface that
#      permits us to combine processing modules. Additionally, when we uniformly
#      represent structures as sequences, we have localized the data-structure
#      dependencies in our programs to a small number of sequence operations. By
#      changing these, we can experiment with alternative representations of
#      sequences, while leaving the overall design of our programs intact. We will
#      exploit this capability in section @l(#3.5), when we generalize the
#      sequence-processing paradigm to admit infinite sequences.
     Las secuencias, implementadas aquí como listas, sirven como una interfaz
     convencional que nos permite combinar módulos de
     procesamiento. Adicionalmente, cuando uniformemente representamos
     estructuras como secuencias, hemos localizado las dependencias de
     estructura de datos en nuestros programas a un pequeño número de
     operaciones de secuencia. Al cambiar estos, podemos experimentar con
     representaciones alternativas de secuencias, dejando el diseño global de
     nuestros programas intactos. Exploraremos esta capacidad en la seccion @l(#3.5),
     cuando generalizamos el paradigma de procesamiento de secuencias para
     admitir secuencias infinitas.

#      :: @t(Exercise 2.33) :: Fill in the missing expressions to complete the
#         following definitions of some basic list-manipulation operations as
#         accumulations:
     :: @t(Ejercicio 2.33) :: Complete las expresiones que faltan para completar
        las siguientes definiciones de algunas operaciones básicas de
        manipulación de listas como acumulaciones:

#         ..src > scheme
#           (define (map p sequence)
#             (accumulate (lambda (x y) ⟨??⟩)
#                         nil sequence))
#
#           (define (append seq1 seq2)
#             (accumulate cons ⟨??⟩ ⟨??⟩))
#
#           (define (length sequence)
#             (accumulate ⟨??⟩ 0 sequence))
#         < src..
        ..src > scheme
          (define (map p sequence)
            (accumulate (lambda (x y) ⟨??⟩)
                        nil sequence))

          (define (append seq1 seq2)
            (accumulate cons ⟨??⟩ ⟨??⟩))

          (define (length sequence)
            (accumulate ⟨??⟩ 0 sequence))
        < src..

#      :: @t(Exercise 2.34) :: Evaluating a polynomial in @m(x) at a given value of
#         @m(x) can be formulated as an accumulation. We evaluate the polynomial
     :: @t(Ejercicio 2.34) :: La evaluación de un polinomio en @m(x) con un
        valor dado de @m(x) puede formularse como una acumulación. Se evalúa el
        polinomio

#         ..example >
#           aₙxⁿ + a₍ₙ₋₁₎x⁽ⁿ⁻¹⁾ + ... + a₁x + a₀
#         < example..
        ..example >
          aₙxⁿ + a₍ₙ₋₁₎x⁽ⁿ⁻¹⁾ + ... + a₁x + a₀
        < example..

#         using a well-known algorithm called @e(Horner's rule), which structures the
#         computation as
        Usando un algoritmo bien conocido llamado @e(regla de Horner), que
        estructura el cálculo como

#         ..example >
#           (... (aₙx + a₍ₙ₋₁₎)x + ... + a₁)x + a₀
#         < example..
        ..example >
          (... (aₙx + a₍ₙ₋₁₎)x + ... + a₁)x + a₀
        < example..

#         In other words, we start with @m(aₙ), multiply by @m(x), add @m(aₙ₋₁),
#         multiply by @m(x), and so on, until we reach @m(a₀).@n(82)
        En otras palabras, comenzamos con @m(aₙ), multiplicamos por @m(x),
        añadimos @m(aₙ₋₁), multiplicamos por @m(x), y así sucesivamente, hasta
        alcanzar @m(a₀).@n(82)

#         Fill in the following template to produce a procedure that evaluates a
#         polynomial using Horner's rule. Assume that the coefficients of the
#         polynomial are arranged in a sequence, from @m(a₀) through @m(aₙ).
        Complete la siguiente plantilla para producir un procedimiento que
        evalúa un polinomio usando la regla de Horner. Supongamos que los
        coeficientes del polinomio están dispuestos en una secuencia, de @m(a₀)
        a @m(aₙ).

#         ..src > scheme
#           (define
#             (horner-eval x coefficient-sequence)
#             (accumulate
#              (lambda (this-coeff higher-terms)
#                ⟨??⟩)
#              0
#              coefficient-sequence))
#         < src..
        ..src > scheme
          (define
            (horner-eval x coefficient-sequence)
            (accumulate
             (lambda (this-coeff higher-terms)
               ⟨??⟩)
             0
             coefficient-sequence))
        < src..

#         For example, to compute @m(1 + 3x + 5x³ + x⁵) at @m(x = 2) you would
#         evaluate
        Por ejemplo, para calcular @m(1 + 3x + 5x³ + x⁵) en @m(x = 2) se
        evaluaría

#         ..src > scheme
#           (horner-eval 2 (list 1 3 0 5 0 1))
#         < src..
        ..src > scheme
          (horner-eval 2 (list 1 3 0 5 0 1))
        < src..

#      :: @t(Exercise 2.35) :: Redefine @c(count-leaves) from @l(#2.2.2) as an
#         accumulation:
     :: @t(Ejercicio 2.35) :: Redefinir @c(count-leaves) de la seccion @l(#2.2.2)
     como acumulación:

#         ..src > scheme
#           (define (count-leaves t)
#             (accumulate ⟨??⟩ ⟨??⟩ (map ⟨??⟩ ⟨??⟩)))
#         < src..
        ..src > scheme
          (define (count-leaves t)
            (accumulate ⟨??⟩ ⟨??⟩ (map ⟨??⟩ ⟨??⟩)))
        < src..

#      :: @t(Exercise 2.36) :: The procedure @c(accumulate-n) is similar to
#         @c(accumulate) except that it takes as its third argument a sequence of
#         sequences, which are all assumed to have the same number of elements. It
#         applies the designated accumulation procedure to combine all the first
#         elements of the sequences, all the second elements of the sequences, and so
#         on, and returns a sequence of the results. For instance, if @c(s) is a
#         sequence containing four sequences, @c[((1 2 3) (4 5 6) (7 8 9) (10 11
#         12))], then the value of @c[(accumulate-n + 0 s)] should be the sequence
#         @c[(22 26 30)]. Fill in the missing expressions in the following definition
#         of @c(accumulate-n):
     :: @t(Ejercicio 2.36) :: El procedimiento @c(accumulate-n) es similar a
        @c(accumulate) excepto que toma como su tercer argumento una secuencia
        de secuencias, que se supone que tienen el mismo número de
        elementos. Aplica el procedimiento de acumulación designado para
        combinar todos los primeros elementos de las secuencias, todos los
        segundos elementos de las secuencias, y así sucesivamente, y devuelve
        una secuencia de los resultados. Por ejemplo, si @c(s) es una secuencia
        que contiene cuatro secuencias @c[((1 2 3) (4 5 6) (7 8 9) (10 11 12))],
        entonces el valor de @c[(accumulate-n + 0 s)] debe ser la secuencia
        @c[(22 26 30)]. Rellene las expresiones que faltan en la siguiente
        definición de @c(accumulate-n):

#         ..src > scheme
#           (define (accumulate-n op init seqs)
#             (if (null? (car seqs))
#                 nil
#                 (cons (accumulate op init ⟨??⟩)
#                       (accumulate-n op init ⟨??⟩))))
#         < src..
        ..src > scheme
          (define (accumulate-n op init seqs)
            (if (null? (car seqs))
                nil
                (cons (accumulate op init ⟨??⟩)
                      (accumulate-n op init ⟨??⟩))))
        < src..

#      :: @t(Exercise 2.37) :: Suppose we represent vectors @b{v} = @m[(vᵢ)] as
#         sequences of numbers, and matrices @b{m} = @m[(mᵢⱼ)] as sequences of
#         vectors (the rows of the matrix). For example, the matrix
     :: @t(Ejercicio 2.37) :: Supongamos que representamos los vectores @b(v) =
        @m[(vᵢ)] como secuencias de números y matrices @b(m) = @m[(mᵢⱼ)] como
        secuencias de vectores (las filas de la matriz). Por ejemplo, la matriz

#         ..example >
#           ╭          ╮
#           │  1 2 3 4 │
#           │  4 5 6 6 │
#           │  6 7 8 9 │
#           ╰          ╯
#         < example..
        ..example >
          ╭          ╮
          │  1 2 3 4 │
          │  4 5 6 6 │
          │  6 7 8 9 │
          ╰          ╯
        < example..

#         is represented as the sequence @c[((1 2 3 4) (4 5 6 6) (6 7 8 9))]. With
#         this representation, we can use sequence operations to concisely express
#         the basic matrix and vector operations. These operations (which are
#         described in any book on matrix algebra) are the following:
        Se representa como la secuencia @c[((1 2 3 4) (4 5 6 6) (6 7 8 9))]. Con
        esta representación, podemos utilizar operaciones de secuencia para
        expresar concisamente las operaciones básicas de matriz y vector. Estas
        operaciones (que se describen en cualquier libro sobre álgebra
        matricial) son las siguientes:

#         ..example >
#               (dot-product v w)  returns the sum ∑ᵢ vᵢ wᵢ
#
#           (matrix-*-vector m v)  returns the vector t,
#
#                                  where tᵢ = ∑ⱼmᵢⱼvⱼ
#
#           (matrix-*-matrix m n)  returns the matrix p,
#
#                                  where pᵢⱼ = ∑ₙmᵢₖnₖⱼ
#
#                   (transpose m)  returns the matrix n,
#                                  where nᵢⱼ = mⱼᵢ
#         < example..
        ..example >
              (dot-product v w)  returns the sum ∑ᵢ vᵢ wᵢ

          (matrix-*-vector m v)  returns the vector t,

                                 where tᵢ = ∑ⱼmᵢⱼvⱼ

          (matrix-*-matrix m n)  returns the matrix p,

                                 where pᵢⱼ = ∑ₙmᵢₖnₖⱼ

                  (transpose m)  returns the matrix n,
                                 where nᵢⱼ = mⱼᵢ
        < example..

#         We can define the dot product as@n(83)
        Podemos definir el producto punto como@n(83)

#         ..src > scheme
#           (define (dot-product v w)
#             (accumulate + 0 (map * v w)))
#         < src..
        ..src > scheme
          (define (dot-product v w)
            (accumulate + 0 (map * v w)))
        < src..

#         Fill in the missing expressions in the following procedures for computing
#         the other matrix operations. (The procedure @c(accumulate-n) is defined in
#         @l(#Exercise 2.36).)
        Rellene las expresiones que faltan en los siguientes procedimientos para
        calcular las otras operaciones matriciales. (El procedimiento
        @c(accumulate-n) se define en el @l(#Ejercicio 2.36) .)

#         ..src > scheme
#           (define (matrix-*-vector m v)
#             (map ⟨??⟩ m))
#
#           (define (transpose mat)
#             (accumulate-n ⟨??⟩ ⟨??⟩ mat))
#
#           (define (matrix-*-matrix m n)
#             (let ((cols (transpose n)))
#               (map ⟨??⟩ m)))
#         < src..
        ..src > scheme
          (define (matrix-*-vector m v)
            (map ⟨??⟩ m))

          (define (transpose mat)
            (accumulate-n ⟨??⟩ ⟨??⟩ mat))

          (define (matrix-*-matrix m n)
            (let ((cols (transpose n)))
              (map ⟨??⟩ m)))
        < src..

#      :: @t(Exercise 2.38) :: The @c(accumulate) procedure is also known as
#         @c(fold-right), because it combines the first element of the sequence with
#         the result of combining all the elements to the right. There is also a
#         @c(fold-left), which is similar to @c(fold-right), except that it combines
#         elements working in the opposite direction:
     :: @t(Ejercicio 2.38) :: El procedimiento @c(accumulate) también se conoce
        como @c(fold-right), porque combina el primer elemento de la secuencia
        con el resultado de combinar todos los elementos a la derecha. Hay
        también a @c(fold-left), que es similar a @c(fold-right), excepto que
        combina elementos que trabajan en la dirección opuesta:

#         ..src > scheme
#           (define (fold-left op initial sequence)
#             (define (iter result rest)
#               (if (null? rest)
#                   result
#                   (iter (op result (car rest))
#                         (cdr rest))))
#             (iter initial sequence))
#         < src..
        ..src > scheme
          (define (fold-left op initial sequence)
            (define (iter result rest)
              (if (null? rest)
                  result
                  (iter (op result (car rest))
                        (cdr rest))))
            (iter initial sequence))
        < src..

#         What are the values of
        ¿Cuáles son los valores de

#         ..src > scheme
#           (fold-right / 1 (list 1 2 3))
#           (fold-left  / 1 (list 1 2 3))
#           (fold-right list nil (list 1 2 3))
#           (fold-left  list nil (list 1 2 3))
#         < src..
        ..src > scheme
          (fold-right / 1 (list 1 2 3))
          (fold-left  / 1 (list 1 2 3))
          (fold-right list nil (list 1 2 3))
          (fold-left  list nil (list 1 2 3))
        < src..

#         Give a property that @c(op) should satisfy to guarantee that @c(fold-right)
#         and @c(fold-left) will produce the same values for any sequence.
        Dar una propiedad que @c(op) debe satisfacer para garantizar que
        @c(fold-right) y @c(fold-left) producirá los mismos valores para
        cualquier secuencia.

#      :: @t(Exercise 2.39) :: Complete the following definitions of @c(reverse)
#         (@l(#Exercise 2.18)) in terms of @c(fold-right) and @c(fold-left) from
#         @l(#Exercise 2.38):
     :: @t(Ejercicio 2.39) :: Complete las siguientes definiciones de
     @c(reverse) (@l(#Ejercicio 2.18) ) en términos de
     @c(fold-right) y @c(fold-left) desde el @l(#Ejercicio
     2.38) :

#         ..src > scheme
#           (define (reverse sequence)
#             (fold-right
#              (lambda (x y) ⟨??⟩) nil sequence))
#
#           (define (reverse sequence)
#             (fold-left
#              (lambda (x y) ⟨??⟩) nil sequence))
#         < src..
        ..src > scheme
          (define (reverse sequence)
            (fold-right
             (lambda (x y) ⟨??⟩) nil sequence))

          (define (reverse sequence)
            (fold-left
             (lambda (x y) ⟨??⟩) nil sequence))
        < src..

# **** Nested Mappings
**** Mappings anidados

#      We can extend the sequence paradigm to include many computations that are
#      commonly expressed using nested loops.@n(84) Consider this problem: Given a
#      positive integer @m(n), find all ordered pairs of distinct positive integers
#      @m(i) and @m(j), where @m(1 ≤ j < i ≤ n), such that @m(i + j) is prime. For
#      example, if @m(n) is 6, then the pairs are the following:
     Podemos extender el paradigma de secuencia para incluir muchos cálculos que
     se expresan comúnmente utilizando bucles anidados.@n(84) Considere
     este problema: Dado un número entero positivo @m(n), encontrar todos los
     pares ordenados de números enteros distintos positivas @m(i) y @m(j), donde
     @m(1 ≤ j <i ≤ n), tal que @m(i + j) es primo. Por ejemplo, si @m(n) es
     6, entonces los pares son los siguientes:

#      ..example >
#          i   | 2 3 4 4 5 6 6
#          j   | 1 2 1 3 2 1 5
#        ------+---------------
#        i + j | 3 5 5 7 7 7 11
#      < example..
     ..example >
         i   | 2 3 4 4 5 6 6
         j   | 1 2 1 3 2 1 5
       ------+---------------
       i + j | 3 5 5 7 7 7 11
     < example..

#      A natural way to organize this computation is to generate the sequence of all
#      ordered pairs of positive integers less than or equal to @m(n), filter to
#      select those pairs whose sum is prime, and then, for each pair @m[(i, j)] that
#      passes through the filter, produce the triple @m[(i, j, i + j)].
     Una forma natural de organizar este cálculo es generar la secuencia de
     todos los pares ordenados de enteros positivos menores o iguales a @m(n),
     filtrar para seleccionar aquellos pares cuya suma es primo, y luego, para
     cada par @m[(i, j)] que pasa por El filtro, produce el triple @m[(i, j, i +
     j)].

#      Here is a way to generate the sequence of pairs: For each integer @m(i ≤ n),
#      enumerate the integers @m(j < i), and for each such @m(i) and @m(j) generate
#      the pair @m[(i, j)]. In terms of sequence operations, we map along the
#      sequence @c[(enumerate-interval 1 n)]. For each @m(i) in this sequence, we map
#      along the sequence @c[(enumerate-interval 1 (- i 1))]. For each @m(j) in this
#      latter sequence, we generate the pair @c[(list i j)]. This gives us a sequence
#      of pairs for each @m(i). Combining all the sequences for all the @m(i) (by
#      accumulating with @c(append)) produces the required sequence of pairs:@n(85)
     Aquí es una manera de generar la secuencia de pares: Para cada entero @m(i
     ≤ n), enumerar los enteros @m(j <i), y para cada uno de tales @m(i) y
     @m(j) generar el par @m[(i, j)]. En términos de operaciones de secuencias,
     nos correlacionamos a lo largo de la secuencia @c[(enumerate-interval 1
     n)]. Para cada @m(i) en esta secuencia, mapeamos a lo largo de la secuencia
     @c[(enumerate-interval 1 (- i 1))]. Para cada @m(j) en esta última
     secuencia, generamos el par @c[(list i j)]. Esto nos da una secuencia de
     pares para cada @m(i). La combinación de todas las secuencias para todos
     los @m(i) (acumulando con @c(append)) produce la secuencia de pares
     requerida:@n(85)

#      ..src > scheme
#        (accumulate
#         append
#         nil
#         (map (lambda (i)
#                (map (lambda (j)
#                       (list i j))
#                     (enumerate-interval 1 (- i 1))))
#              (enumerate-interval 1 n)))
#      < src..
     ..src > scheme
       (accumulate
        append
        nil
        (map (lambda (i)
               (map (lambda (j)
                      (list i j))
                    (enumerate-interval 1 (- i 1))))
             (enumerate-interval 1 n)))
     < src..

#      The combination of mapping and accumulating with @c(append) is so common in
#      this sort of program that we will isolate it as a separate procedure:
     La combinación de mapeo y acumulación con @c(append) es tan común en este
     tipo de programa que lo aislaremos como un procedimiento separado:

#      ..src > scheme
#        (define (flatmap proc seq)
#          (accumulate append nil (map proc seq)))
#      < src..
     ..src > scheme
       (define (flatmap proc seq)
         (accumulate append nil (map proc seq)))
     < src..

#      Now filter this sequence of pairs to find those whose sum is prime. The filter
#      predicate is called for each element of the sequence; its argument is a pair
#      and it must extract the integers from the pair. Thus, the predicate to apply
#      to each element in the sequence is
     Ahora filtre esta secuencia de pares para encontrar aquellos cuya suma es
     primo. El predicado del filtro se llama para cada elemento de la secuencia;
     Su argumento es un par y debe extraer los enteros del par. Por lo tanto, el
     predicado que se aplica a cada elemento en la secuencia es

#      ..src > scheme
#        (define (prime-sum? pair)
#          (prime? (+ (car pair) (cadr pair))))
#      < src..
     ..src > scheme
       (define (prime-sum? pair)
         (prime? (+ (car pair) (cadr pair))))
     < src..

#      Finally, generate the sequence of results by mapping over the filtered pairs
#      using the following procedure, which constructs a triple consisting of the two
#      elements of the pair along with their sum:
     Por último, generar la secuencia de resultados mediante la cartografía
     sobre los pares filtrados utilizando el siguiente procedimiento, que
     construye un triple que consiste en los dos elementos del par junto con su
     suma:

#      ..src > scheme
#        (define (make-pair-sum pair)
#          (list (car pair)
#                (cadr pair)
#                (+ (car pair) (cadr pair))))
#      < src..
     ..src > scheme
       (define (make-pair-sum pair)
         (list (car pair)
               (cadr pair)
               (+ (car pair) (cadr pair))))
     < src..

#      Combining all these steps yields the complete procedure:
     Combinando todos estos pasos se obtiene el procedimiento completo:

#      ..src > scheme
#        (define (prime-sum-pairs n)
#          (map make-pair-sum
#               (filter
#                prime-sum?
#                (flatmap
#                 (lambda (i)
#                   (map (lambda (j)
#                          (list i j))
#                        (enumerate-interval
#                         1
#                         (- i 1))))
#                 (enumerate-interval 1 n)))))
#      < src..
     ..src > scheme
       (define (prime-sum-pairs n)
         (map make-pair-sum
              (filter
               prime-sum?
               (flatmap
                (lambda (i)
                  (map (lambda (j)
                         (list i j))
                       (enumerate-interval
                        1
                        (- i 1))))
                (enumerate-interval 1 n)))))
     < src..

#      Nested mappings are also useful for sequences other than those that enumerate
#      intervals. Suppose we wish to generate all the permutations of a set @m(S);
#      that is, all the ways of ordering the items in the set. For instance, the
#      permutations of @m({1, 2, 3}) are @m({1, 2, 3}), @m({1, 3, 2}), @m({2, 1, 3}),
#      @m({2, 3, 1}), @m({3, 1, 2}), and @m({3, 2, 1}). Here is a plan for generating
#      the permutations of @m(S): For each item @m(x) in @m(S), recursively generate
#      the sequence of permutations of @m(S - x),@n(86) and adjoin @m(x) to the front
#      of each one.  This yields, for each @m(x) in @m(S), the sequence of
#      permutations of @m(S) that begin with @m(x). Combining these sequences for all
#      @m(x) gives all the permutations of @m(S):@n(87)
     Las asignaciones anidadas también son útiles para secuencias distintas de
     aquellas que enumeran intervalos. Supongamos que queremos generar todas las
     permutaciones de un conjunto @m(S) ; Es decir, todas las formas de ordenar
     los elementos en el conjunto. Por ejemplo, las permutaciones de @m({1, 2,
     3}) son @m({1, 2, 3}), @m({1, 3, 2}), @m({2, 1, 3}), @m({2, 3, 1}), @m({3,
     1, 2}), y @m({3, 2, 1}). Aquí hay un plan para generar las permutaciones de
     @m(S) : Para cada ítem @m(x) en @m(S), recursivamente generar la secuencia
     de permutaciones de @m(S - x),@n(86) y adjuntar @m(x) al frente de
     cada uno. Esto produce, @m(Para cada x) en @m(S), la secuencia de
     permutaciones de @m(S) que comienzan con @m(x). La combinación de estas
     secuencias para todo @m(x) proporciona todas las permutaciones de @m(S) :
    @n(87)

#      ..src > scheme
#        (define (permutations s)
#          (if (null? s)   ; empty set?
#              (list nil)  ; sequence containing empty set
#              (flatmap (lambda (x)
#                         (map (lambda (p)
#                                (cons x p))
#                              (permutations
#                               (remove x s))))
#                       s)))
#      < src..
     ..src > scheme
       (define (permutations s)
         (if (null? s)   ; empty set?
             (list nil)  ; sequence containing empty set
             (flatmap (lambda (x)
                        (map (lambda (p)
                               (cons x p))
                             (permutations
                              (remove x s))))
                      s)))
     < src..

#      Notice how this strategy reduces the problem of generating permutations of
#      @m(S) to the problem of generating the permutations of sets with fewer elements
#      than @m(S). In the terminal case, we work our way down to the empty list,
#      which represents a set of no elements. For this, we generate @c[(list
#      nil)], which is a sequence with one item, namely the set with no elements. The
#      @c(remove) procedure used in @c(permutations) returns all the items in a
#      given sequence except for a given item. This can be expressed as a simple
#      filter:
     Observe cómo esta estrategia reduce el problema de generar permutaciones de
     @m(S) para el problema de la generación de las permutaciones de conjuntos
     con menos elementos que @m(S). En el caso terminal, trabajamos nuestra
     manera abajo a la lista vacía, que representa un sistema de ningunos
     elementos. Para ello, generamos @c[(list nil)], que es una secuencia con un
     elemento, es decir, el conjunto sin elementos. El procedimiento @c(remove)
     utilizado en @c(permutations) devuelve todos los elementos de una secuencia
     dada, excepto para un elemento determinado. Esto puede expresarse como un
     simple filtro:

#      ..src > scheme
#        (define (remove item sequence)
#          (filter (lambda (x) (not (= x item)))
#                  sequence))
#      < src..
     ..src > scheme
       (define (remove item sequence)
         (filter (lambda (x) (not (= x item)))
                 sequence))
     < src..

#      :: @t(Exercise 2.40) :: Define a procedure @c(unique-pairs) that, given an
#         integer @m(n), generates the sequence of pairs @m[(i, j)] with @m(1 ≤ j < i
#         ≤ n). Use @c(unique-pairs) to simplify the definition of
#         @c(prime-sum-pairs) given above.
     :: @t(Ejercicio 2.40) :: Definir un procedimiento @c(unique-pairs) que,
        dado un número entero @m(n), genera la secuencia de pares @m[(i, j)] con
        @m(1 ≤ j <i ≤ n). Utilizar @c(unique-pairs) para simplificar la
        definición de @c(prime-sum-pairs) dado arriba.

#      :: @t(Exercise 2.41) :: Write a procedure to find all ordered triples of
#         distinct positive integers @m(i), @m(j), and @m(k) less than or equal to a
#         given integer @m(n) that sum to a given integer @m(s).
     :: @t(Ejercicio 2.41) :: Escribir un procedimiento para encontrar todos los
        triples ordenados de números enteros positivos distintos @m(i), @m(j), y
        @m(k) menor que o igual a un número entero dado @m(n) que suma a un
        entero dado @m(s).

#      :: @t(Exercise 2.42) :: The @"(eight-queens puzzle) asks how to place eight
#         queens on a chessboard so that no queen is in check from any other (i.e.,
#         no two queens are in the same row, column, or diagonal). One possible
#         solution is shown in @l(#Figure 2.8). One way to solve the puzzle is to
#         work across the board, placing a queen in each column. Once we have placed
#         @m(k - 1) queens, we must place the @m(kᵗʰ) queen in a position where it
#         does not check any of the queens already on the board. We can formulate
#         this approach recursively: Assume that we have already generated the
#         sequence of all possible ways to place @m(k - 1) queens in the first
#         @m(k - 1) columns of the board. For each of these ways, generate an
#         extended set of positions by placing a queen in each row of the @m(kᵗʰ)
#         column. Now filter these, keeping only the positions for which the queen in
#         the @m(kᵗʰ) column is safe with respect to the other queens. This produces
#         the sequence of all ways to place @m(k) queens in the first @m(k)
#         columns. By continuing this process, we will produce not only one solution,
#         but all solutions to the puzzle.
     :: @t(Ejercicio 2.42) :: El @"(rompecabezas de ocho reinas) pregunta cómo
        colocar ocho reinas en un tablero de ajedrez para que ninguna reina esté
        bajo control de ninguna otra (es decir, no hay dos reinas en la misma
        fila, columna o diagonal). Una posible solución se muestra en la
        @l(#Figura 2.8). Una manera de resolver el rompecabezas es
        trabajar a través de la tabla, colocando una reina en cada columna. Una
        vez que hemos colocado @m(k-1) reinas, debemos colocar la reina @m(k) in
        en una posición en la que no verifica ninguna de las reinas que ya están
        en el tablero. Podemos formular este enfoque recursivamente: Supongamos
        que ya hemos generado la secuencia de todas las formas posibles de
        colocar @m(k - 1) reinas en las primeras @m(k - 1) columnas de la
        tabla. Para cada una de estas formas, Generan un conjunto extendido de
        posiciones colocando una reina en cada fila de la columna @m(kᵗʰ). Ahora
        filtre estos, manteniendo sólo las posiciones para las cuales la reina
        en la columna @m(k) is es segura con respecto a las otras reinas. Esto
        produce la secuencia de todas las formas de colocar @m(k) reinas en las
        primeras @m(k) columnas. Al continuar este proceso, vamos a producir no
        sólo una solución, sino todas las soluciones para el rompecabezas.

#         ..figure > @t(Figure 2.8) A solution to the eight-queens puzzle.
        ..figure > @t(Figura 2.8) Una solución al rompecabezas de ocho reinas.

#           ..img  > img/chap2/Fig2.8c.std.svg
          ..img  > img/chap2/Fig2.8c.std.svg

#         We implement this solution as a procedure @c(queens), which returns a
#         sequence of all solutions to the problem of placing @m(n) queens on an @m(n
#         × n) chessboard. @c(Queens) has an internal procedure @c(queen-cols) that
#         returns the sequence of all ways to place queens in the first @m(k) columns
#         of the board.
        Implementamos esta solución como un procedimiento @c(queens), que
        devuelve una secuencia de todas las soluciones al problema de colocar
        @m(n) reinas en un tablero de ajedrez @m(n × n). @c(Queens) Tiene un
        procedimiento interno @c(queen-cols) que devuelve la secuencia de todas
        las formas de colocar reinas en las primeras @m(k) columnas de la tabla.

#         ..src > scheme
#           (define (queens board-size)
#             (define (queen-cols k)
#               (if (= k 0)
#                   (list empty-board)
#                   (filter
#                    (lambda (positions)
#                      (safe? k positions))
#                    (flatmap
#                     (lambda (rest-of-queens)
#                       (map (lambda (new-row)
#                              (adjoin-position
#                               new-row
#                               k
#                               rest-of-queens))
#                            (enumerate-interval
#                             1
#                             board-size)))
#                     (queen-cols (- k 1))))))
#             (queen-cols board-size))
#         < src..
        ..src > scheme
          (define (queens board-size)
            (define (queen-cols k)
              (if (= k 0)
                  (list empty-board)
                  (filter
                   (lambda (positions)
                     (safe? k positions))
                   (flatmap
                    (lambda (rest-of-queens)
                      (map (lambda (new-row)
                             (adjoin-position
                              new-row
                              k
                              rest-of-queens))
                           (enumerate-interval
                            1
                            board-size)))
                    (queen-cols (- k 1))))))
            (queen-cols board-size))
        < src..

#         In this procedure @c(rest-of-queens) is a way to place @m(k - 1) queens in
#         the first @m(k - 1) columns, and @c(new-row) is a proposed row in which to
#         place the queen for the @m(kᵗʰ) column. Complete the program by
#         implementing the representation for sets of board positions, including the
#         procedure @c(adjoin-position), which adjoins a new row-column position to a
#         set of positions, and @c(empty-board), which represents an empty set of
#         positions.  You must also write the procedure @c(safe?), which determines
#         for a set of positions, whether the queen in the @m(kᵗʰ) column is safe
#         with respect to the others. (Note that we need only check whether the new
#         queen is safe––the other queens are already guaranteed safe with respect to
#         each other.)
        En este procedimiento @c(rest-of-queens) es una forma de colocar
        @m(k - 1) reinas en las primeras @m(k - 1) columnas, y @c(new-row) es
        una fila propuesta en la que colocar la reina para la columna
        @m(kᵗʰ). Completar el programa mediante la implementación de la
        representación de conjuntos de posiciones del tablero, incluyendo el
        procedimiento @c(adjoin-position), que se une a una nueva posición de
        fila de columna a un conjunto de posiciones, y @c(empty-board), lo que
        representa un conjunto vacío de posiciones. También debe escribir el
        procedimiento @c(safe?), que determina para un conjunto de posiciones,
        si la reina en la columna @m(k) is es segura con respecto a las
        otras. (Tenga en cuenta que sólo necesitamos comprobar si la nueva reina
        está a salvo - las otras reinas ya están garantizadas con respecto a la
        otra.)

#      :: @t(Exercise 2.43) :: Louis Reasoner is having a terrible time doing
#         @l(#Exercise 2.42). His @c(queens) procedure seems to work, but it runs
#         extremely slowly. (Louis never does manage to wait long enough for it to
#         solve even the @m(6×6) case.)  When Louis asks Eva Lu Ator for help, she
#         points out that he has interchanged the order of the nested mappings in the
#         @c(flatmap), writing it as
     :: @t(Ejercicio 2.43) :: Louis Reasoner está teniendo un tiempo terrible
        haciendo el @l(#Ejercicio 2.42). Su procedimiento @c(queens) parece funcionar, pero funciona muy lentamente. (Louis
        nunca se las arregla para esperar el tiempo suficiente para que pueda
        resolver incluso el caso @m(6 × 6) ). Cuando Louis pide ayuda a Eva Lu
        Ator, señala que ha intercambiado el orden de las asignaciones anidadas
        en el @c(flatmap), escribiéndolo como


#         ..src > scheme
#           (flatmap
#            (lambda (new-row)
#              (map (lambda (rest-of-queens)
#                     (adjoin-position
#                      new-row k rest-of-queens))
#                   (queen-cols (- k 1))))
#            (enumerate-interval 1 board-size))
#         < src..
        ..src > scheme
          (flatmap
           (lambda (new-row)
             (map (lambda (rest-of-queens)
                    (adjoin-position
                     new-row k rest-of-queens))
                  (queen-cols (- k 1))))
           (enumerate-interval 1 board-size))
        < src..

#         Explain why this interchange makes the program run slowly. Estimate how
#         long it will take Louis's program to solve the eight-queens puzzle,
#         assuming that the program in @l(#Exercise 2.42) solves the puzzle in time
#         @m(T).
        Explique por qué este intercambio hace que el programa funcione
        lentamente. Estimar cuánto tiempo tardará el programa de Louis para
        resolver el rompecabezas de ocho reinas, en el supuesto de que el
        programa de @l(#Ejercicio 2.42) resuelve el rompecabezas
        en el tiempo @m(t).

# *** 2.2.4 <> Example: A Picture Language
*** 2.2.4 <> Ejemplo: A Picture Language

#     This section presents a simple language for drawing pictures that illustrates
#     the power of data abstraction and closure, and also exploits higher-order
#     procedures in an essential way. The language is designed to make it easy to
#     experiment with patterns such as the ones in @l(#Figure 2.9), which are
#     composed of repeated elements that are shifted and scaled.@n(88) In this
#     language, the data objects being combined are represented as procedures rather
#     than as list structure. Just as @c(cons), which satisfies the closure
#     property, allowed us to easily build arbitrarily complicated list structure,
#     the operations in this language, which also satisfy the closure property,
#     allow us to easily build arbitrarily complicated patterns.
    Esta sección presenta un lenguaje sencillo para dibujar ilustraciones que
    ilustran el poder de la abstracción y el cierre de datos, y también explora
    los procedimientos de orden superior de una manera esencial. El lenguaje
    está diseñado para que sea fácil experimentar con patrones como los de la
    @l(#Figura 2.9), que están compuestos por elementos repetidos
    que se desplazan y se escalan.@n(88) En este lenguaje, los objetos de
    datos que se combinan se representan como procedimientos y no como
    estructura de lista. Así como @c(cons), lo que satisface la propiedad de
    cierre, nos permitió construir fácilmente estructura de lista
    arbitrariamente complicada, las operaciones en este lenguaje, que también
    satisfacen la propiedad de cierre, nos permiten construir fácilmente
    patrones arbitrariamente complicados.

#     ..figure > @t(Figure 2.9) Designs generated with the picture language.
    ..figure > @t(Figura 2.9) Diseños generados con el lenguaje de imagen.

#       ..img  > img/chap2/Fig2.9.std.svg
      ..img  > img/chap2/Fig2.9.std.svg

# **** The picture language
**** El lenguaje de la imagen

#      When we began our study of programming in section @l(#1.1), we emphasized the
#      importance of describing a language by focusing on the language's primitives,
#      its means of combination, and its means of abstraction. We'll follow that
#      framework here.
     Cuando comenzamos nuestro estudio de la programación en la seccion @l(#1.1),
     enfatizamos la importancia de describir un lenguaje centrándonos en los
     primitivos del lenguaje, sus medios de combinación y sus medios de
     abstracción. Seguiremos ese marco aquí.

#      Part of the elegance of this picture language is that there is only one kind
#      of element, called a @e(painter). A painter draws an image that is shifted and
#      scaled to fit within a designated parallelogram-shaped frame. For example,
#      there's a primitive painter we'll call @c(wave) that makes a crude line
#      drawing, as shown in @l(#Figure 2.10). The actual shape of the drawing depends
#      on the frame––all four images in figure 2.10 are produced by the same @c(wave)
#      painter, but with respect to four different frames. Painters can be more
#      elaborate than this: The primitive painter called @c(rogers) paints a picture
#      of @A(MIT)'s founder, William Barton Rogers, as shown in @l(#Figure
#      2.11).@n(89) The four images in figure 2.11 are drawn with respect to the same
#      four frames as the @c(wave) images in figure 2.10.
     Parte de la elegancia de este lenguaje de imagen es que sólo hay un tipo de
     elemento, llamado un @e(pintor). Un pintor dibuja una imagen que es
     desplazada y escalada para ajustarse dentro de un marco designado en forma
     de paralelogramo. Por ejemplo, hay un pintor primitivo que llamaremos
     @c(wave) que hace un dibujo en bruto, como se muestra en la
     @l(#Figura 2.10). La forma real del dibujo depende del marco -
     las cuatro imágenes de la figura 2.10 son producidas por el mismo @c(wave)
     pintor, pero con respecto a cuatro marcos diferentes. Los pintores pueden
     ser más elaborados que esto: El pintor primitivo llamado @c(rogers) pinta
     una imagen del fundador del @A(MIT), William Barton Rogers, como se muestra
     en la @l(#Figura 2.11).@n(89) Las cuatro imágenes de la
     figura 2.@c(wave)

#      ..figure > @t(Figure 2.10) Images produced by the @c(wave) painter, with
#        respect to four different frames. The frames, shown with dotted lines, are
#        not part of the images.
     ..figure > @t(Figura 2.10) Imágenes producidas por el @c(wave) pintor, con
       respecto a cuatro marcos diferentes. Los marcos, mostrados con líneas de
       puntos, no forman parte de las imágenes.

#        ..img  > img/chap2/Fig2.10.std.svg
       ..img  > img/chap2/Fig2.10.std.svg

#      ..figure > @t(Figure 2.11) Images of William Barton Rogers, founder and first
#        president of @A(MIT), painted with respect to the same four frames as in
#        @l(#Figure 2.10) (original image reprinted with the permission of the
#        @A(MIT) Museum).
     ..figure > @t(Figura 2.11) Imágenes de William Barton Rogers, fundador y
       primer presidente del @A(MIT), pintado con respecto a los mismos cuatro
       cuadros que en la @l(#Figura 2.10) (imagen original
       reimpreso con el permiso del Museo del @A(MIT) ).

#        ..img  > img/chap2/Fig2.11.std.svg
       ..img  > img/chap2/Fig2.11.std.svg


#      To combine images, we use various operations that construct new painters from
#      given painters. For example, the @c(beside) operation takes two painters and
#      produces a new, compound painter that draws the first painter's image in the
#      left half of the frame and the second painter's image in the right half of the
#      frame. Similarly, @c(below) takes two painters and produces a compound painter
#      that draws the first painter's image below the second painter's image.  Some
#      operations transform a single painter to produce a new painter. For example,
#      @c(flip-vert) takes a painter and produces a painter that draws its image
#      upside-down, and @c(flip-horiz) produces a painter that draws the original
#      painter's image left-to-right reversed.
     Para combinar imágenes, usamos diversas operaciones que construyen nuevos
     pintores de pintores dados. Por ejemplo, la @c(beside) operación toma dos
     pintores y produce un nuevo pintor compuesto que dibuja la primera imagen
     del pintor en la mitad izquierda del marco y la imagen del segundo pintor
     en la mitad derecha del marco. Del mismo modo, @c(below) toma dos pintores
     y produce un pintor compuesto que dibuja la imagen del primer pintor debajo
     de la imagen del segundo pintor. Algunas operaciones transforman a un solo
     pintor para producir un nuevo pintor. Por ejemplo, @c(flip-vert) toma un
     pintor y produce un pintor que dibuja su imagen al revés, y @c(flip-horiz)
     produce un pintor que dibuja la imagen del pintor original de izquierda a
     derecha invertida.

#      @l(#Figure 2.12) shows the drawing of a painter called @c(wave4) that is built
#      up in two stages starting from @c(wave):
     @l(#Figura 2.12) muestra el dibujo de un pintor llamado
     @c(wave4) que se construye en dos etapas a partir de @c(wave):

#      ..src > scheme
#        (define wave2 (beside wave (flip-vert wave)))
#        (define wave4 (below wave2 wave2))
#      < src..
     ..src > scheme
       (define wave2 (beside wave (flip-vert wave)))
       (define wave4 (below wave2 wave2))
     < src..

#      ..figure > @t(Figure 2.12) Creating a complex figure, starting from the
#        @c(wave) painter of @l(#Figure 2.10).
     ..figure > @t(Figura 2.12) Creación de una figura compleja, a partir del
       @c(wave) pintor de la @l(#Figura 2.10).

#        ..img  > img/chap2/Fig2.12.std.svg
       ..img  > img/chap2/Fig2.12.std.svg

#        ..cols >
       ..cols >
#          ..src > scheme
#            (define wave4
#              (below wave2 wave2))
#          < src..
         ..src > scheme
           (define wave4
             (below wave2 wave2))
         < src..

#          ::
         ::

#          ..src > scheme
#            (define wave4
#              (below wave2 wave2))
#          < src..
         ..src > scheme
           (define wave4
             (below wave2 wave2))
         < src..


#      In building up a complex image in this manner we are exploiting the fact that
#      painters are closed under the language's means of combination. The @c(beside)
#      or @c(below) of two painters is itself a painter; therefore, we can use it as
#      an element in making more complex painters. As with building up list structure
#      using @c(cons), the closure of our data under the means of combination is
#      crucial to the ability to create complex structures while using only a few
#      operations.
     En la construcción de una imagen compleja de esta manera estamos explotando
     el hecho de que los pintores se cierran bajo los medios de la lengua de la
     combinación. El @c(beside) o @c(below) de dos pintores es en sí mismo un
     pintor; Por lo tanto, podemos utilizarlo como un elemento para hacer
     pintores más complejos. Al igual que con la construcción de estructura de
     lista utilizando @c(cons), el cierre de nuestros datos bajo los medios de
     combinación es crucial para la capacidad de crear estructuras complejas,
     mientras que el uso de sólo unas pocas operaciones.

#      Once we can combine painters, we would like to be able to abstract typical
#      patterns of combining painters. We will implement the painter operations as
#      Scheme procedures. This means that we don't need a special abstraction
#      mechanism in the picture language: Since the means of combination are ordinary
#      Scheme procedures, we automatically have the capability to do anything with
#      painter operations that we can do with procedures. For example, we can
#      abstract the pattern in @c(wave4) as
     Una vez que podamos combinar pintores, nos gustaría ser capaces de abstraer
     los patrones típicos de la combinación de pintores. Implementaremos las
     operaciones del pintor como procedimientos Scheme. Esto significa que no
     necesitamos un mecanismo de abstracción especial en el lenguaje de imagen:
     Dado que los medios de combinación son procedimientos ordinarios de Scheme,
     automáticamente tenemos la capacidad de hacer cualquier cosa con
     operaciones de pintor que podamos hacer con procedimientos. Por ejemplo,
     podemos abstraer el patrón @c(wave4) como

#      ..src > scheme
#        (define (flipped-pairs painter)
#          (let ((painter2
#                 (beside painter
#                         (flip-vert painter))))
#            (below painter2 painter2)))
#      < src..
     ..src > scheme
       (define (flipped-pairs painter)
         (let ((painter2
                (beside painter
                        (flip-vert painter))))
           (below painter2 painter2)))
     < src..

#      and define @c(wave4) as an instance of this pattern:
     Y definir @c(wave4) como una instancia de este patrón:

#      ..src > scheme
#        (define wave4 (flipped-pairs wave))
#      < src..
     ..src > scheme
       (define wave4 (flipped-pairs wave))
     < src..

#      We can also define recursive operations. Here's one that makes painters split
#      and branch towards the right as shown in @l(#Figure 2.13) and @l(#Figure
#      2.14):
     También podemos definir operaciones recursivas. Aquí hay una que hace que
     los pintores se dividan y se ramifican hacia la derecha como se muestra en
     la @l(#Figura 2.13) y la @l(#Figura 2.14) :

#      ..src > scheme
#        (define (right-split painter n)
#          (if (= n 0)
#              painter
#              (let ((smaller (right-split painter
#                                          (- n 1))))
#                (beside painter
#                        (below smaller smaller)))))
#      < src..
     ..src > scheme
       (define (right-split painter n)
         (if (= n 0)
             painter
             (let ((smaller (right-split painter
                                         (- n 1))))
               (beside painter
                       (below smaller smaller)))))
     < src..

#      ..figure > @t(Figure 2.13) Recursive plans for @c(right-split) and @c(corner-split).
     ..figure > @t(Figura 2.13) Planes recursivos para @c(right-split) y
     @c(corner-split).

#        ..art >
#          ╭─────────────┬─────────────╮    ╭──────┬──────┬─────────────╮
#          │             │             │    │ up-  │ up-  │             │
#          │             │ right-split │    │ split│ split│ corner-split│
#          │             │             │    │      │      │             │
#          │             │     n-1     │    │  n-1 │  n-1 │     n-1     │
#          │             │             │    │      │      │             │
#          │  identity   ├─────────────┤    ├──────┴──────┼─────────────┤
#          │             │             │    │             │ right-split │
#          │             │ right-split │    │             │     n-1     │
#          │             │             │    │  identity   ├─────────────┤
#          │             │     n-1     │    │             │ right-split │
#          │             │             │    │             │     n-1     │
#          ╰─────────────┴─────────────╯    ╰─────────────┴─────────────╯
#
#                 right-split n                    corner-split n
#        < art..
       ..art >
         ╭─────────────┬─────────────╮    ╭──────┬──────┬─────────────╮
         │             │             │    │ up-  │ up-  │             │
         │             │ right-split │    │ split│ split│ corner-split│
         │             │             │    │      │      │             │
         │             │     n-1     │    │  n-1 │  n-1 │     n-1     │
         │             │             │    │      │      │             │
         │  identity   ├─────────────┤    ├──────┴──────┼─────────────┤
         │             │             │    │             │ right-split │
         │             │ right-split │    │             │     n-1     │
         │             │             │    │  identity   ├─────────────┤
         │             │     n-1     │    │             │ right-split │
         │             │             │    │             │     n-1     │
         ╰─────────────┴─────────────╯    ╰─────────────┴─────────────╯

                right-split n                    corner-split n
       < art..

# @    ..img > img/chap2/Fig2.13a.std.svg
@    ..img > img/chap2/Fig2.13a.std.svg

#      We can produce balanced patterns by branching upwards as well as towards the
#      right (see @l(#Exercise 2.44), @l(#Figure 2.13) and @l(#Figure 2.14)):
     Podemos producir patrones equilibrados ramificando hacia arriba y hacia la
     derecha (véase el @l(#Ejercicio 2.44),
     @l(#Figura 2.13) y @l(#Figura 2.14) ):

#      ..src > scheme
#        (define (corner-split painter n)
#          (if (= n 0)
#              painter
#              (let ((up (up-split painter (- n 1)))
#                    (right (right-split painter
#                                        (- n 1))))
#                (let ((top-left (beside up up))
#                      (bottom-right (below right
#                                           right))
#                      (corner (corner-split painter
#                                            (- n 1))))
#                  (beside (below painter top-left)
#                          (below bottom-right
#                                 corner))))))
#      < src..
     ..src > scheme
       (define (corner-split painter n)
         (if (= n 0)
             painter
             (let ((up (up-split painter (- n 1)))
                   (right (right-split painter
                                       (- n 1))))
               (let ((top-left (beside up up))
                     (bottom-right (below right
                                          right))
                     (corner (corner-split painter
                                           (- n 1))))
                 (beside (below painter top-left)
                         (below bottom-right
                                corner))))))
     < src..

#      ..figure > @t(Figure 2.14) The recursive operations @c(right-split) and
#        @c(corner-split) applied to the painters @c(wave) and @c(rogers).
#        Combining four @c(corner-split) figures produces symmetric
#        @c(square-limit) designs as shown in @l(#Figure 2.9).
     ..figure > @t(Figura 2.14) Las operaciones recursivas @c(right-split) y
       @c(corner-split) aplicadas a los pintores @c(wave) y @c(rogers). La
       combinación de cuatro @c(corner-split) figuras produce @c(square-limit)
       diseños simétricos como se muestra en la @l(#Figura 2.9).

#        ..img  > img/chap2/Fig2.14b.std.svg
       ..img  > img/chap2/Fig2.14b.std.svg


#      By placing four copies of a @c(corner-split) appropriately, we obtain a
#      pattern called @c(square-limit), whose application to @c(wave) and @c(rogers)
#      is shown in @l(#Figure 2.9):
     Mediante la colocación de cuatro copias de una @c(corner-split)
     apropiadamente, obtenemos un patrón llamado @c(square-limit), cuya
     aplicación a @c(wave) y @c(rogers) se muestra en la @l(#Figura
     2.9) :

#      ..src > scheme
#        (define (square-limit painter n)
#          (let ((quarter (corner-split painter n)))
#            (let ((half (beside (flip-horiz quarter)
#                                quarter)))
#              (below (flip-vert half) half))))
#      < src..
     ..src > scheme
       (define (square-limit painter n)
         (let ((quarter (corner-split painter n)))
           (let ((half (beside (flip-horiz quarter)
                               quarter)))
             (below (flip-vert half) half))))
     < src..

#      :: @t(Exercise 2.44) :: Define the procedure @c(up-split) used by
#         @c(corner-split). It is similar to @c(right-split), except that it switches
#         the roles of @c(below) and @c(beside).
     :: @t(Ejercicio 2.44) :: Definir el procedimiento @c(up-split) utilizado
        por @c(corner-split). Es similar a @c(right-split), excepto que cambia
        los roles de @c(below) y @c(beside).

# **** Higher-order operations
**** Operaciones de orden superior

#      In addition to abstracting patterns of combining painters, we can work at a
#      higher level, abstracting patterns of combining painter operations. That is,
#      we can view the painter operations as elements to manipulate and can write
#      means of combination for these elements––procedures that take painter
#      operations as arguments and create new painter operations.
     Además de abstraer los patrones de la combinación de pintores, podemos
     trabajar en un nivel superior, abstraer los patrones de combinar las
     operaciones del pintor. Es decir, podemos ver las operaciones del pintor
     como elementos para manipular y podemos escribir medios de combinación para
     estos elementos - procedimientos que toman las operaciones del pintor como
     argumentos y crean nuevas operaciones de pintor.

#      For example, @c(flipped-pairs) and @c(square-limit) each arrange four copies
#      of a painter's image in a square pattern; they differ only in how they orient
#      the copies. One way to abstract this pattern of painter combination is with
#      the following procedure, which takes four one-argument painter operations and
#      produces a painter operation that transforms a given painter with those four
#      operations and arranges the results in a square. @c(Tl), @c(tr), @c(bl), and
#      @c(br) are the transformations to apply to the top left copy, the top right
#      copy, the bottom left copy, and the bottom right copy, respectively.
     Por ejemplo, @c(flipped-pairs) y @c(square-limit) cada uno organizar cuatro
     copias de la imagen de un pintor en un patrón cuadrado, Sólo difieren en
     cómo orientan las copias. Una forma de abstraer este patrón de combinación
     de pintores es con el siguiente procedimiento, el cual toma cuatro
     operaciones de un solo argumento y produce una operación de pintor que
     transforma un pintor dado con esas cuatro operaciones y organiza los
     resultados en un cuadrado. @c(Tl), @c(tr), @c(bl), Y @c(br) son las
     transformaciones a aplicar a la copia superior izquierda, la copia de
     arriba a la derecha, la copia abajo a la izquierda, y la copia abajo a la
     derecha, respectivamente.

#      ..src > scheme
#        (define (square-of-four tl tr bl br)
#          (lambda (painter)
#            (let ((top (beside (tl painter)
#                               (tr painter)))
#                  (bottom (beside (bl painter)
#                                  (br painter))))
#              (below bottom top))))
#      < src..
     ..src > scheme
       (define (square-of-four tl tr bl br)
         (lambda (painter)
           (let ((top (beside (tl painter)
                              (tr painter)))
                 (bottom (beside (bl painter)
                                 (br painter))))
             (below bottom top))))
     < src..

#      Then @c(flipped-pairs) can be defined in terms of @c(square-of-four) as
#      follows:@n(90)
     Entonces @c(flipped-pairs) se puede definir en términos de
     @c(square-of-four) lo siguiente:@n(90)

#      ..src > scheme
#        (define (flipped-pairs painter)
#          (let ((combine4
#                 (square-of-four identity
#                                 flip-vert
#                                 identity
#                                 flip-vert)))
#            (combine4 painter)))
#      < src..
     ..src > scheme
       (define (flipped-pairs painter)
         (let ((combine4
                (square-of-four identity
                                flip-vert
                                identity
                                flip-vert)))
           (combine4 painter)))
     < src..

#      and @c(square-limit) can be expressed as@n(91)
     Y @c(square-limit) puede expresarse como@n(91)

#      ..src > scheme
#        (define (square-limit painter n)
#          (let ((combine4
#                 (square-of-four flip-horiz
#                                 identity
#                                 rotate180
#                                 flip-vert)))
#            (combine4 (corner-split painter n))))
#      < src..
     ..src > scheme
       (define (square-limit painter n)
         (let ((combine4
                (square-of-four flip-horiz
                                identity
                                rotate180
                                flip-vert)))
           (combine4 (corner-split painter n))))
     < src..

#      :: @t(Exercise 2.45) :: @c(Right-split) and @c(up-split) can be expressed as
#         instances of a general splitting operation.  Define a procedure @c(split)
#         with the property that evaluating
     :: @t(Ejercicio 2.45) :: @c(Right-split) Y @c(up-split) puede expresarse
        como instancias de una operación de división general. Definir un
        procedimiento @c(split) con la propiedad que la evaluación

#         ..src > scheme
#           (define right-split (split beside below))
#           (define up-split (split below beside))
#         < src..
        ..src > scheme
          (define right-split (split beside below))
          (define up-split (split below beside))
        < src..

#         produces procedures @c(right-split) and @c(up-split) with the same
#         behaviors as the ones already defined.
        Produce procedimientos @c(right-split) y @c(up-split) con los mismos
        comportamientos que los ya definidos.

# **** Frames
**** Cuadros

#      Before we can show how to implement painters and their means of combination,
#      we must first consider frames. A frame can be described by three vectors––an
#      origin vector and two edge vectors. The origin vector specifies the offset of
#      the frame's origin from some absolute origin in the plane, and the edge
#      vectors specify the offsets of the frame's corners from its origin. If the
#      edges are perpendicular, the frame will be rectangular. Otherwise the frame
#      will be a more general parallelogram.
     Antes de poder mostrar cómo implementar a los pintores y sus medios de
     combinación, primero debemos considerar marcos. Un marco puede ser descrito
     por tres vectores - un vector de origen y dos vectores de borde. El vector
     de origen especifica el desplazamiento del origen del marco desde algún
     origen absoluto en el plano, y los vectores de borde especifican los
     desplazamientos de las esquinas del marco desde su origen. Si los bordes
     son perpendiculares, el marco será rectangular. De lo contrario, el marco
     será un paralelogramo más general.

#      @l(#Figure 2.15) shows a frame and its associated vectors.  In accordance with
#      data abstraction, we need not be specific yet about how frames are
#      represented, other than to say that there is a constructor @c(make-frame),
#      which takes three vectors and produces a frame, and three corresponding
#      selectors @c(origin-frame), @c(edge1-frame), and @c(edge2-frame) (see
#      @l(#Exercise 2.47)).
     @l(#Figura 2.15) muestra un marco y sus vectores
     asociados. De acuerdo con el resumen de los datos, no tenemos que ser
     específico todavía acerca de cómo se representan los marcos, aparte de
     decir que hay un constructor @c(make-frame), que tiene tres vectores y
     produce un cuadro, y tres selectores correspondientes @c(origin-frame),
     @c(edge1-frame) y @c(edge2-frame)(ver @l(#Ejercicio 2.47) ).

#      ..figure > @t(Figure 2.15) A frame is described by three vectors -- an origin
#        and two edges.
     ..figure > @t(Figura 2.15) Un marco es descrito por tres vectores - un
       origen y dos bordes.

#        ..art >
#                                   __
#                               __--  \
#                           __--       \
#                       __--            \
#                   __--                 \
#                 _-                      \
#                 ◤                   __-◥
#          frame   \              __--
#          edge2    \         __--    frame
#          vector    \    __--        edge1
#                     \_--            vector
#                      - ◀╮
#                         ╰───╮
#                   frame     │
#                   origin    ╰ (0, 0) point
#                   vector      on display screen
#        < art..
       ..art >
                                  __
                              __--  \
                          __--       \
                      __--            \
                  __--                 \
                _-                      \
                ◤                   __-◥
         frame   \              __--
         edge2    \         __--    frame
         vector    \    __--        edge1
                    \_--            vector
                     - ◀╮
                        ╰───╮
                  frame     │
                  origin    ╰ (0, 0) point
                  vector      on display screen
       < art..

# @      ..img > img/chap2/Fig2.15a.std.svg
@      ..img > img/chap2/Fig2.15a.std.svg

#      We will use coordinates in the unit square @m[(0 ≤ x, y ≤ 1)] to specify
#      images. With each frame, we associate a @e(frame coordinate map), which will
#      be used to shift and scale images to fit the frame. The map transforms the
#      unit square into the frame by mapping the vector @m(v = (x, y)] to the vector
#      sum
     Utilizaremos coordenadas en el cuadrado unitario @m[(0 ≤ x, y ≤ 1)] para
     especificar las imágenes. Con cada trama, asociamos un @e(mapa de
     coordenadas de trama), que se utilizará para desplazar y escalar las
     imágenes para ajustarlas al marco. El mapa transforma el cuadrado de
     unidades en el marco mapeando el vector @m(v = (x, y) ] a la suma vectorial

#      ..example >
#        Origin(Frame) + x ⋅ Edge₁(Frame) + y ⋅ Edge₂(Frame)
#      < example..
     ..example >
       Origin(Frame) + x ⋅ Edge₁(Frame) + y ⋅ Edge₂(Frame)
     < example..

#      For example, (0, 0) is mapped to the origin of the frame, (1, 1) to the vertex
#      diagonally opposite the origin, and (0.5, 0.5) to the center of the frame. We
#      can create a frame's coordinate map with the following procedure:@n(92)
     Por ejemplo, se asigna (0, 0) al origen de la trama, (1, 1) al vértice
     diagonalmente opuesto al origen, y (0,5, 0,5) al centro de la
     trama. Podemos crear el mapa de coordenadas de un marco con el siguiente
     procedimiento:@n(92)

#      ..src > scheme
#        (define (frame-coord-map frame)
#          (lambda (v)
#            (add-vect
#             (origin-frame frame)
#             (add-vect
#              (scale-vect (xcor-vect v)
#                          (edge1-frame frame))
#              (scale-vect (ycor-vect v)
#                          (edge2-frame frame))))))
#      < src..
     ..src > scheme
       (define (frame-coord-map frame)
         (lambda (v)
           (add-vect
            (origin-frame frame)
            (add-vect
             (scale-vect (xcor-vect v)
                         (edge1-frame frame))
             (scale-vect (ycor-vect v)
                         (edge2-frame frame))))))
     < src..

#      Observe that applying @c(frame-coord-map) to a frame returns a procedure that,
#      given a vector, returns a vector. If the argument vector is in the unit
#      square, the result vector will be in the frame. For example,
     Observe que aplicar @c(frame-coord-map) a un marco devuelve un
     procedimiento que, dado un vector, devuelve un vector. Si el vector de
     argumento está en la unidad cuadrada, el vector de resultado estará en el
     marco. Por ejemplo,

#      ..src > scheme
#        ((frame-coord-map a-frame) (make-vect 0 0))
#      < src..
     ..src > scheme
       ((frame-coord-map a-frame) (make-vect 0 0))
     < src..

#      returns the same vector as
     Devuelve el mismo vector que

#      ..src > scheme
#        (origin-frame a-frame)
#      < src..
     ..src > scheme
       (origin-frame a-frame)
     < src..

#      :: @t(Exercise 2.46) :: A two-dimensional vector @m(v) running from the origin
#         to a point can be represented as a pair consisting of an @m(x)-coordinate
#         and a @m(y)-coordinate. Implement a data abstraction for vectors by giving
#         a constructor @c(make-vect) and corresponding selectors @c(xcor-vect) and
#         @c(ycor-vect). In terms of your selectors and constructor, implement
#         procedures @c(add-vect), @c(sub-vect), and @c(scale-vect) that perform the
#         operations vector addition, vector subtraction, and multiplying a vector by
#         a scalar:
     :: @t(Ejercicio 2.46) :: Un vector bidimensional @m(v que se) ejecuta desde
       el origen hasta un punto puede representarse como un par que consiste en
       una coordenada @m(x) y una coordenada @m(y). Implementar un resumen de
       los datos para los vectores dando un constructor @c(make-vect) y
       selectores correspondiente @c(xcor-vect) y @c(ycor-vect). En términos de
       sus selectores y constructor, implementar procedimientos @c(add-vect),
       @c(sub-vect) y @c(scale-vect) que realizan las operaciones vectoriales de
       adición, sustracción vectorial y multiplicando un vector por un escalar:

#         ..example >
#           (x₁, y₁) + (x₂, y₂) = (x₁ + x₂, y₁ + y₂)
#           (x₁, y₁) − (x₂, y₂) = (x₁ − x₂, y₁ − y₂)
#                    s ⋅ (x, y) = (sx, sy)
#         < example..
        ..example >
          (x₁, y₁) + (x₂, y₂) = (x₁ + x₂, y₁ + y₂)
          (x₁, y₁) − (x₂, y₂) = (x₁ − x₂, y₁ − y₂)
                   s ⋅ (x, y) = (sx, sy)
        < example..

#      :: @t(Exercise 2.47) :: Here are two possible constructors for frames:
     :: @t(Ejercicio 2.47) :: Aquí hay dos constructores posibles para los
        marcos:

#         ..src > scheme
#           (define (make-frame origin edge1 edge2)
#             (list origin edge1 edge2))
#
#           (define (make-frame origin edge1 edge2)
#             (cons origin (cons edge1 edge2)))
#         < src..
        ..src > scheme
          (define (make-frame origin edge1 edge2)
            (list origin edge1 edge2))

          (define (make-frame origin edge1 edge2)
            (cons origin (cons edge1 edge2)))
        < src..

#         For each constructor supply the appropriate selectors to produce an
#         implementation for frames.
        Para cada constructor suministrar los selectores adecuados para producir
        una implementación de marcos.

# **** Painters
**** Pintores

#      A painter is represented as a procedure that, given a frame as argument, draws
#      a particular image shifted and scaled to fit the frame. That is to say, if
#      @c(p) is a painter and @c(f) is a frame, then we produce @c(p)'s image in
#      @c(f) by calling @c(p) with @c(f) as argument.
     Un pintor es representado como un procedimiento que, dado un marco como
     argumento, dibuja una imagen particular desplazada y escalada para
     ajustarse al marco. Es decir, si @c(p) es un pintor y @c(f) es un marco,
     entonces producimos @c(p) la imagen en @c(f) llamando @c(p) con @c(f) como
     argumento.

#      The details of how primitive painters are implemented depend on the particular
#      characteristics of the graphics system and the type of image to be drawn. For
#      instance, suppose we have a procedure @c(draw-line) that draws a line on the
#      screen between two specified points. Then we can create painters for line
#      drawings, such as the @c(wave) painter in @l(#Figure 2.10), from lists of line
#      segments as follows:@n(93)
     Los detalles de cómo se implementan los pintores primitivos dependen de las
     características particulares del sistema gráfico y del tipo de imagen a
     dibujar. Por ejemplo, supongamos que tenemos un procedimiento @c(draw-line)
     que dibuja una línea en la pantalla entre dos puntos
     especificados. Entonces podemos crear pintores para dibujos lineales, como
     el @c(wave) pintor en la @l(#Figura 2.10), de listas de
     segmentos de línea como sigue:@n(93)

#      ..src > scheme
#        (define (segments->painter segment-list)
#          (lambda (frame)
#            (for-each
#             (lambda (segment)
#               (draw-line
#                ((frame-coord-map frame)
#                 (start-segment segment))
#                ((frame-coord-map frame)
#                 (end-segment segment))))
#             segment-list)))
#      < src..
     ..src > scheme
       (define (segments->painter segment-list)
         (lambda (frame)
           (for-each
            (lambda (segment)
              (draw-line
               ((frame-coord-map frame)
                (start-segment segment))
               ((frame-coord-map frame)
                (end-segment segment))))
            segment-list)))
     < src..

#      The segments are given using coordinates with respect to the unit square. For
#      each segment in the list, the painter transforms the segment endpoints with
#      the frame coordinate map and draws a line between the transformed points.
     Los segmentos se dan usando coordenadas con respecto al cuadrado
     unitario. Para cada segmento de la lista, el pintor transforma los puntos
     finales del segmento con el mapa de coordenadas de trama y dibuja una línea
     entre los puntos transformados.

#      Representing painters as procedures erects a powerful abstraction barrier in
#      the picture language. We can create and intermix all sorts of primitive
#      painters, based on a variety of graphics capabilities. The details of their
#      implementation do not matter. Any procedure can serve as a painter, provided
#      that it takes a frame as argument and draws something scaled to fit the
#      frame.@n(94)
     Representar a los pintores como procedimientos erige una poderosa barrera
     de abstracción en el lenguaje de los dibujos. Podemos crear y mezclar todo
     tipo de pintores primitivos, basados en una variedad de capacidades
     gráficas. Los detalles de su implementación no importan. Cualquier
     procedimiento puede servir como un pintor, siempre que se tome un marco
     como argumento y dibuja algo escalado para ajustarse al marco.@n(94)

#      :: @t(Exercise 2.48) :: A directed line segment in the plane can be
#         represented as a pair of vectors––the vector running from the origin to the
#         start-point of the segment, and the vector running from the origin to the
#         end-point of the segment. Use your vector representation from @l(#Exercise
#         2.46) to define a representation for segments with a constructor
#         @c(make-segment) and selectors @c(start-segment) and @c(end-segment).
     :: @t(Ejercicio 2.48) :: Un segmento de línea dirigida en el plano puede
        representarse como un par de vectores - el vector que se extiende desde
        el origen hasta el punto inicial del segmento, y el vector que discurre
        desde el origen hasta el punto final del segmento. Utilice su
        representación vectorial del @l(#Ejercicio 2.46) para
        definir una representación para segmentos con un constructor
        @c(make-segment) y selectores @c(start-segment) y @c(end-segment).

#      :: @t(Exercise 2.49) :: Use @c(segments->painter) to define the following
#         primitive painters:
     :: @t(Ejercicio 2.49) :: Utilizar @c(segments->painter) para definir los
        siguientes pintores primitivos:

#         1. The painter that draws the outline of the designated frame.
     1. El pintor que dibuja el contorno del marco designado.

#         2. The painter that draws an @"(X) by connecting opposite corners of the
#            frame.
     2. El pintor que dibuja una @"(X) conectando esquinas opuestas del marco.

#         3. The painter that draws a diamond shape by connecting the midpoints of
#            the sides of the frame.
     3. El pintor que dibuja una forma de diamante mediante la conexión de los
        puntos medios de los lados del marco.

#         4. The @c(wave) painter.
     4. El @c(wave) pintor.

# **** Transforming and combining painters
**** Transformar y combinar pintores

#      An operation on painters (such as @c(flip-vert) or @c(beside)) works by
#      creating a painter that invokes the original painters with respect to frames
#      derived from the argument frame. Thus, for example, @c(flip-vert) doesn't have
#      to know how a painter works in order to flip it––it just has to know how to
#      turn a frame upside down: The flipped painter just uses the original painter,
#      but in the inverted frame.
     Una operación sobre pintores (como @c(flip-vert) o @c(beside)) funciona
     creando un pintor que invoca a los pintores originales con respecto a los
     marcos derivados de la trama del argumento. Así, por ejemplo, @c(flip-vert)
     no tiene que saber cómo funciona un pintor con el fin de voltearlo - sólo
     tiene que saber cómo convertir un marco al revés: El pintor volteado sólo
     utiliza el pintor original, pero en el marco invertido.

#      Painter operations are based on the procedure @c(transform-painter), which
#      takes as arguments a painter and information on how to transform a frame and
#      produces a new painter. The transformed painter, when called on a frame,
#      transforms the frame and calls the original painter on the transformed frame.
#      The arguments to @c(transform-painter) are points (represented as vectors)
#      that specify the corners of the new frame: When mapped into the frame, the
#      first point specifies the new frame's origin and the other two specify the
#      ends of its edge vectors. Thus, arguments within the unit square specify a
#      frame contained within the original frame.
     Las operaciones del pintor se basan en el procedimiento
     @c(transform-painter), que toma como argumentos un pintor e información
     sobre cómo transformar un marco y produce un nuevo pintor. El pintor
     transformado, cuando se le llama en un marco, transforma el marco y llama
     al pintor original sobre el marco transformado. Los argumentos a
     @c(transform-painter) son puntos (representados como vectores) que
     especifican las esquinas del nuevo marco: Cuando se asigna al marco, el
     primer punto especifica el origen del nuevo marco y los otros dos
     especifican los extremos de sus vectores de borde. Así, los argumentos
     dentro del cuadrado de la unidad especifican un marco contenido dentro del
     marco original.

#      ..src > scheme
#        (define (transform-painter
#                 painter origin corner1 corner2)
#          (lambda (frame)
#            (let ((m (frame-coord-map frame)))
#              (let ((new-origin (m origin)))
#                (painter (make-frame new-origin
#                          (sub-vect (m corner1)
#                                    new-origin)
#                          (sub-vect (m corner2)
#                                    new-origin)))))))
#      < src..
     ..src > scheme
       (define (transform-painter
                painter origin corner1 corner2)
         (lambda (frame)
           (let ((m (frame-coord-map frame)))
             (let ((new-origin (m origin)))
               (painter (make-frame new-origin
                         (sub-vect (m corner1)
                                   new-origin)
                         (sub-vect (m corner2)
                                   new-origin)))))))
     < src..

#      Here's how to flip painter images vertically:
     A continuación se muestra cómo invertir las imágenes del pintor
     verticalmente:

#      ..src > scheme
#        (define (flip-vert painter)
#          (transform-painter
#           painter
#           (make-vect 0.0 1.0)   ; new origin
#           (make-vect 1.0 1.0)   ; new end of edge1
#           (make-vect 0.0 0.0))) ; new end of edge2
#      < src..
     ..src > scheme
       (define (flip-vert painter)
         (transform-painter
          painter
          (make-vect 0.0 1.0)   ; new origin
          (make-vect 1.0 1.0)   ; new end of edge1
          (make-vect 0.0 0.0))) ; new end of edge2
     < src..

#      Using @c(transform-painter), we can easily define new transformations.  For
#      example, we can define a painter that shrinks its image to the upper-right
#      quarter of the frame it is given:
     Usando @c(transform-painter), podemos definir fácilmente nuevas
     transformaciones. Por ejemplo, podemos definir un pintor que encoge su
     imagen al cuarto superior derecho del marco que se le da:

#      ..src > scheme
#        (define (shrink-to-upper-right painter)
#          (transform-painter painter
#                             (make-vect 0.5 0.5)
#                             (make-vect 1.0 0.5)
#                             (make-vect 0.5 1.0)))
#      < src..
     ..src > scheme
       (define (shrink-to-upper-right painter)
         (transform-painter painter
                            (make-vect 0.5 0.5)
                            (make-vect 1.0 0.5)
                            (make-vect 0.5 1.0)))
     < src..

#      Other transformations rotate images counterclockwise by 90 degrees@n(95)
     Otras transformaciones giran las imágenes en sentido antihorario 90 grados
    @n(95)

#      ..src > scheme
#        (define (rotate90 painter)
#          (transform-painter painter
#                             (make-vect 1.0 0.0)
#                             (make-vect 1.0 1.0)
#                             (make-vect 0.0 0.0)))
#      < src..
     ..src > scheme
       (define (rotate90 painter)
         (transform-painter painter
                            (make-vect 1.0 0.0)
                            (make-vect 1.0 1.0)
                            (make-vect 0.0 0.0)))
     < src..

#      or squash images towards the center of the frame:@n(96)
     O imágenes de squash hacia el centro del cuadro:@n(96)

#      ..src > scheme
#        (define (squash-inwards painter)
#          (transform-painter painter
#                             (make-vect 0.0 0.0)
#                             (make-vect 0.65 0.35)
#                             (make-vect 0.35 0.65)))
#      < src..
     ..src > scheme
       (define (squash-inwards painter)
         (transform-painter painter
                            (make-vect 0.0 0.0)
                            (make-vect 0.65 0.35)
                            (make-vect 0.35 0.65)))
     < src..

#      Frame transformation is also the key to defining means of combining two or
#      more painters. The @c(beside) procedure, for example, takes two painters,
#      transforms them to paint in the left and right halves of an argument frame
#      respectively, and produces a new, compound painter. When the compound painter
#      is given a frame, it calls the first transformed painter to paint in the left
#      half of the frame and calls the second transformed painter to paint in the
#      right half of the frame:
     La transformación del marco es también la clave para definir los medios de
     combinar dos o más pintores. El procedimiento @c(beside), por ejemplo, toma
     dos pintores, los transforma para pintar en las mitades izquierda y derecha
     de un marco de argumento, respectivamente, y produce un nuevo pintor
     compuesto. Cuando el pintor compuesto recibe un marco, llama al primer
     pintor transformado a pintar en la mitad izquierda del marco y llama al
     segundo pintor transformado a pintar en la mitad derecha del marco:

#      ..src > scheme
#        (define (beside painter1 painter2)
#          (let ((split-point (make-vect 0.5 0.0)))
#            (let ((paint-left  (transform-painter
#                                painter1
#                                (make-vect 0.0 0.0)
#                                split-point
#                                (make-vect 0.0 1.0)))
#                  (paint-right (transform-painter
#                                painter2
#                                split-point
#                                (make-vect 1.0 0.0)
#                                (make-vect 0.5 1.0))))
#              (lambda (frame)
#                (paint-left frame)
#                (paint-right frame)))))
#      < src..
     ..src > scheme
       (define (beside painter1 painter2)
         (let ((split-point (make-vect 0.5 0.0)))
           (let ((paint-left  (transform-painter
                               painter1
                               (make-vect 0.0 0.0)
                               split-point
                               (make-vect 0.0 1.0)))
                 (paint-right (transform-painter
                               painter2
                               split-point
                               (make-vect 1.0 0.0)
                               (make-vect 0.5 1.0))))
             (lambda (frame)
               (paint-left frame)
               (paint-right frame)))))
     < src..

#      Observe how the painter data abstraction, and in particular the representation
#      of painters as procedures, makes @c(beside) easy to implement. The @c(beside)
#      procedure need not know anything about the details of the component painters
#      other than that each painter will draw something in its designated frame.
     Observe cómo la abstracción de datos del pintor, y en particular la
     representación de los pintores como procedimientos, @c(beside) facilita su
     implementación. El procedimiento @c(beside) no necesita saber nada acerca
     de los detalles de los pintores componentes, aparte de que cada pintor
     dibujará algo en su marco designado.

#      :: @t(Exercise 2.50) :: Define the transformation @c(flip-horiz), which flips
#         painters horizontally, and transformations that rotate painters
#         counterclockwise by 180 degrees and 270 degrees.
     :: @t(Ejercicio 2.50) :: Defina la transformación @c(flip-horiz), que
        invierte horizontalmente a los pintores, y las transformaciones que
        giran a los pintores en sentido contrario a las agujas del reloj en 180
        grados y 270 grados.

#      :: @t(Exercise 2.51) :: Define the @c(below) operation for painters. @c(Below)
#         takes two painters as arguments. The resulting painter, given a frame,
#         draws with the first painter in the bottom of the frame and with the second
#         painter in the top. Define @c(below) in two different ways––first by
#         writing a procedure that is analogous to the @c(beside) procedure given
#         above, and again in terms of @c(beside) and suitable rotation operations
#         (from @l(#Exercise 2.50)).
     :: @t(Ejercicio 2.51) :: Definir la @c(below) operación para los
        pintores. @c(Below) Toma dos pintores como argumentos. El pintor
        resultante, dado un marco, dibuja con el primer pintor en la parte
        inferior del marco y con el segundo pintor en la parte superior. Definir
        @c(below) de dos maneras diferentes - primero escribiendo un
        procedimiento que es análogo al procedimiento @c(beside) dado arriba, y
        otra vez en términos de @c(beside) y operaciones de rotación apropiadas
        (del @l(#Ejercicio 2.50) ).

# **** Levels of language for robust design
**** Niveles de lenguaje para un diseño robusto

#      The picture language exercises some of the critical ideas we've introduced
#      about abstraction with procedures and data. The fundamental data abstractions,
#      painters, are implemented using procedural representations, which enables the
#      language to handle different basic drawing capabilities in a uniform way. The
#      means of combination satisfy the closure property, which permits us to easily
#      build up complex designs. Finally, all the tools for abstracting procedures
#      are available to us for abstracting means of combination for painters.
     El lenguaje de imagen ejerce algunas de las ideas críticas que hemos
     introducido sobre la abstracción con procedimientos y datos. Las
     abstracciones de datos fundamentales, los pintores, se implementan mediante
     representaciones procedurales, lo que permite al lenguaje manejar
     diferentes capacidades básicas de dibujo de una manera uniforme. Los medios
     de combinación satisfacen la propiedad de cierre, lo que nos permite
     construir fácilmente diseños complejos. Finalmente, todas las herramientas
     para los procedimientos de abstracción están disponibles para abstraer los
     medios de combinación para los pintores.

#      We have also obtained a glimpse of another crucial idea about languages and
#      program design. This is the approach of @e(stratified design), the notion that
#      a complex system should be structured as a sequence of levels that are
#      described using a sequence of languages. Each level is constructed by
#      combining parts that are regarded as primitive at that level, and the parts
#      constructed at each level are used as primitives at the next level. The
#      language used at each level of a stratified design has primitives, means of
#      combination, and means of abstraction appropriate to that level of detail.
     También hemos obtenido una visión de otra idea crucial sobre los idiomas y
     el diseño del programa. Este es el enfoque del @e(diseño estratificado), la
     noción de que un sistema complejo debe estructurarse como una secuencia de
     niveles que se describen utilizando una secuencia de lenguajes. Cada nivel
     se construye combinando partes que se consideran primitivas a ese nivel, y
     las partes construidas en cada nivel se usan como primitivas en el
     siguiente nivel. El lenguaje utilizado en cada nivel de un diseño
     estratificado tiene primitivas, medios de combinación y medios de
     abstracción adecuados a ese nivel de detalle.

#      Stratified design pervades the engineering of complex systems. For example, in
#      computer engineering, resistors and transistors are combined (and described
#      using a language of analog circuits) to produce parts such as and-gates and
#      or-gates, which form the primitives of a language for digital-circuit
#      design.@n(97) These parts are combined to build processors, bus structures,
#      and memory systems, which are in turn combined to form computers, using
#      languages appropriate to computer architecture. Computers are combined to form
#      distributed systems, using languages appropriate for describing network
#      interconnections, and so on.
     El diseño estratificado impregna la ingeniería de sistemas complejos. Por
     ejemplo, en la ingeniería informática, las resistencias y los transistores
     se combinan (y se describen usando un lenguaje de circuitos analógicos)
     para producir partes tales como y-puertas y puertas o puertas que forman
     las primitivas de un lenguaje para diseño de circuitos
     digitales.@n(97) Estas piezas se combinan para construir
     procesadores, estructuras de bus, y sistemas de memoria, que a su vez se
     combinan para formar los equipos, utilizando los lenguajes adecuados a la
     arquitectura de computadores. Las computadoras se combinan para formar
     sistemas distribuidos, utilizando lenguajes apropiados para describir las
     interconexiones de red, etc.

#      As a tiny example of stratification, our picture language uses primitive
#      elements (primitive painters) that are created using a language that specifies
#      points and lines to provide the lists of line segments for
#      @c(segments->painter), or the shading details for a painter like
#      @c(rogers). The bulk of our description of the picture language focused on
#      combining these primitives, using geometric combiners such as @c(beside) and
#      @c(below). We also worked at a higher level, regarding @c(beside) and
#      @c(below) as primitives to be manipulated in a language whose operations, such
#      as @c(square-of-four), capture common patterns of combining geometric
#      combiners.
     Como un pequeño ejemplo de estratificación, nuestro lenguaje de imagen
     utiliza elementos primitivos (pintores primitivos) que se crean utilizando
     un lenguaje que especifica puntos y líneas para proporcionar las listas de
     segmentos de línea para @c(segments->painter), o los detalles de
     sombreado para un pintor como @c(rogers). La mayor parte de nuestra
     descripción del lenguaje de la imagen se centró en la combinación de estas
     primitivas, utilizando combinadores geométricos como @c(beside) y
     @c(below). También trabajamos en un nivel superior, con respecto @c(beside)
     y @c(below) como primitivos para ser manipulados en un idioma cuyas
     operaciones, como @c(square-of-four), capturar patrones comunes de combinar
     combinadores geométricos.

#      Stratified design helps make programs @e(robust), that is, it makes it likely
#      that small changes in a specification will require correspondingly small
#      changes in the program. For instance, suppose we wanted to change the image
#      based on @c(wave) shown in @l(#Figure 2.9). We could work at the lowest level
#      to change the detailed appearance of the @c(wave) element; we could work at
#      the middle level to change the way @c(corner-split) replicates the @c(wave);
#      we could work at the highest level to change how @c(square-limit) arranges the
#      four copies of the corner. In general, each level of a stratified design
#      provides a different vocabulary for expressing the characteristics of the
#      system, and a different kind of ability to change it.
     El diseño estratificado ayuda a que los programas sean @e(robustos), es
     decir, hace probable que pequeños cambios en una especificación requieran
     cambios correspondientemente pequeños en el programa. Por ejemplo,
     supongamos que queremos cambiar la imagen basándonos @c(wave) en la
     @l(#Figura 2.9). Podríamos trabajar en el nivel más bajo para
     cambiar la apariencia detallada del @c(wave) elemento; Podríamos trabajar
     en el nivel medio para cambiar la forma de @c(corner-split) replicar el
     @c(wave); Podríamos trabajar al nivel más alto para cambiar cómo
     @c(square-limit) arregla las cuatro copias de la esquina. En general, cada
     nivel de un diseño estratificado proporciona un vocabulario diferente para
     expresar las características del sistema, y un tipo diferente de capacidad
     para cambiarlo.

#      :: @t(Exercise 2.52) :: Make changes to the square limit of @c(wave) shown in
#         @l(#Figure 2.9) by working at each of the levels described above. In
#         particular:
     :: @t(Ejercicio 2.52) :: Hacer cambios en el límite cuadrado de @c(wave)
        muestra en la @l(#Figura 2.9), trabajando en cada uno de los
        niveles descritos anteriormente. En particular:

#         1. Add some segments to the primitive @c(wave) painter of @l(#Exercise
#            2.49) (to add a smile, for example).
     1. Añadir algunos segmentos al @c(wave) pintor primitivo del
        @l(#Ejercicio 2.49) (para agregar una sonrisa, por
        ejemplo).

#         2. Change the pattern constructed by @c(corner-split) (for example, by
#            using only one copy of the @c(up-split) and @c(right-split) images
#            instead of two).
     2. Cambie el patrón construido por @c(corner-split)(por ejemplo, utilizando
        sólo una copia de las imágenes @c(up-split) y en @c(right-split) lugar
        de dos).

#         3. Modify the version of @c(square-limit) that uses @c(square-of-four) so
#            as to assemble the corners in a different pattern. (For example, you
#            might make the big Mr. Rogers look outward from each corner of the
#            square.)
     3. Modifique la versión de @c(square-limit) que utiliza @c(square-of-four)
        para ensamblar las esquinas en un patrón diferente. (Por ejemplo, puede
        hacer que el gran señor Rogers mire hacia fuera desde cada esquina de la
        plaza.)

# ** 2.3 <> Symbolic Data
** 2.3 <> Datos simbólicos

#    All the compound data objects we have used so far were constructed ultimately
#    from numbers. In this section we extend the representational capability of our
#    language by introducing the ability to work with arbitrary symbols as data.
   Todos los objetos de datos compuestos que hemos utilizado hasta ahora se
   construyeron finalmente a partir de números. En esta sección ampliamos la
   capacidad de representación de nuestro lenguaje introduciendo la capacidad de
   trabajar con símbolos arbitrarios como datos.

# *** 2.3.1 <> Quotation
*** 2.3.1 <> Cotización

#     If we can form compound data using symbols, we can have lists such as
    Si podemos formar datos compuestos usando símbolos, podemos tener listas
    como

#     ..src > scheme
#       (a b c d)
#       (23 45 17)
#       ((Norah 12)
#        (Molly 9)
#        (Anna 7)
#        (Lauren 6)
#        (Charlotte 4))
#     < src..
    ..src > scheme
      (a b c d)
      (23 45 17)
      ((Norah 12)
       (Molly 9)
       (Anna 7)
       (Lauren 6)
       (Charlotte 4))
    < src..

#     Lists containing symbols can look just like the expressions of our language:
    Las listas que contienen símbolos pueden ser parecidas a las expresiones de
    nuestro lenguaje:

#     ..src > scheme
#       (* (+ 23 45) (+ x 9))
#       (define (fact n)
#         (if (= n 1)
#             1
#             (* n (fact (- n 1)))))
#     < src..
    ..src > scheme
      (* (+ 23 45) (+ x 9))
      (define (fact n)
        (if (= n 1)
            1
            (* n (fact (- n 1)))))
    < src..

#     In order to manipulate symbols we need a new element in our language: the
#     ability to @e(quote) a data object. Suppose we want to construct the list
#     @c[(a b)]. We can't accomplish this with @c[(list a b)], because this
#     expression constructs a list of the @e(values) of @c(a) and @c(b) rather than
#     the symbols themselves. This issue is well known in the context of natural
#     languages, where words and sentences may be regarded either as semantic
#     entities or as character strings (syntactic entities). The common practice in
#     natural languages is to use quotation marks to indicate that a word or a
#     sentence is to be treated literally as a string of characters. For instance,
#     the first letter of @"(John) is clearly @"(J.)  If we tell somebody @"(say
#     your name aloud,) we expect to hear that person's name. However, if we tell
#     somebody @"(say `your name' aloud,) we expect to hear the words @"(your name.)
#     Note that we are forced to nest quotation marks to describe what somebody else
#     might say.@n(98)
    Para manipular símbolos necesitamos un nuevo elemento en nuestro lenguaje:
    la capacidad de @e(citar) un objeto de datos. Supongamos que queremos
    construir la lista @c[(a b)]. No podemos lograr esto con @c[(list a b)],
    porque esta expresión construye una lista de los @e(valores) de @c(a) y
    @c(b) más bien que los símbolos ellos mismos. Esta cuestión es bien conocida
    en el contexto de los lenguajes naturales, donde las palabras y oraciones
    pueden considerarse como entidades semánticas o como cadenas de caracteres
    (entidades sintácticas). La práctica común en los lenguajes naturales es
    usar comillas para indicar que una palabra o una oración debe tratarse
    literalmente como una cadena de caracteres. Por ejemplo, la primera letra de
    @"(Juan) es claramente @"(J. )  Si le decimos a alguien que @"(diga su
    nombre en voz alta,) esperamos escuchar el nombre de esa persona. Sin
    embargo, si le decimos a alguien que @"(diga 'su nombre' en voz alta,)
    esperamos escuchar las palabras de @"(su nombre. ) Tenga en cuenta que
    estamos obligados a anidar las comillas para describir lo que alguien más
    podría decir.@n(98)

#     We can follow this same practice to identify lists and symbols that are to be
#     treated as data objects rather than as expressions to be evaluated. However,
#     our format for quoting differs from that of natural languages in that we place
#     a quotation mark (traditionally, the single quote symbol @c(')) only at the
#     beginning of the object to be quoted. We can get away with this in Scheme
#     syntax because we rely on blanks and parentheses to delimit objects. Thus, the
#     meaning of the single quote character is to quote the next object.@n(99)
    Podemos seguir esta misma práctica para identificar listas y símbolos que
    deben ser tratados como objetos de datos en lugar de como expresiones a ser
    evaluadas. Sin embargo, nuestro formato de cotización difiere del de los
    lenguajes naturales en que colocamos una comilla (tradicionalmente, el
    símbolo de comillas @c(')) sólo al principio del objeto que se va a
    citar. Podemos salirse con esto en la sintaxis Scheme porque nos basamos en
    espacios en blanco y paréntesis para delimitar objetos. Por lo tanto, el
    significado del carácter de comilla simple es citar el siguiente
    objeto.@n(99)

#     Now we can distinguish between symbols and their values:
    Ahora podemos distinguir entre símbolos y sus valores:

#     ..srci > scheme
#       > (define a 1)
#       > (define b 2)
#       > (list a b)
#       (1 2)
#       > (list 'a 'b)
#       (a b)
#       > (list 'a b)
#       (a 2)
#     < srci..
    ..srci > scheme
      > (define a 1)
      > (define b 2)
      > (list a b)
      (1 2)
      > (list 'a 'b)
      (a b)
      > (list 'a b)
      (a 2)
    < srci..

#     Quotation also allows us to type in compound objects, using the conventional
#     printed representation for lists:@n(100)
    La cotización también nos permite escribir objetos compuestos, usando la
    representación impresa convencional para las listas:@n(100)

#     ..srci > scheme
#       > (car '(a b c))
#       a
#       > (cdr '(a b c))
#       (b c)
#     < srci..
    ..srci > scheme
      > (car '(a b c))
      a
      > (cdr '(a b c))
      (b c)
    < srci..

#     In keeping with this, we can obtain the empty list by evaluating @c['()], and
#     thus dispense with the variable @c(nil).
    De acuerdo con esto, podemos obtener la lista vacía evaluando @c('()), y así
    prescindir de la variable @c(nil).

#     One additional primitive used in manipulating symbols is @c(eq?), which takes
#     two symbols as arguments and tests whether they are the same.@n(101) Using
#     @c(eq?), we can implement a useful procedure called @c(memq). This takes two
#     arguments, a symbol and a list. If the symbol is not contained in the list
#     (i.e., is not @c(eq?) to any item in the list), then @c(memq) returns
#     false. Otherwise, it returns the sublist of the list beginning with the first
#     occurrence of the symbol:
    Una primitiva adicional utilizada en la manipulación de símbolos es @c(eq?),
    que toma dos símbolos como argumentos y prueba si son iguales.@n(101)
    El uso @c(eq?), podemos implementar un procedimiento útil llamada
    @c(memq). Esto toma dos argumentos, un símbolo y una lista. Si el símbolo no
    está contenido en la lista (es decir, no está @c(eq?) en ningún elemento de
    la lista), entonces @c(memq) devuelve false. De lo contrario, devuelve la
    sublista de la lista comenzando con la primera aparición del símbolo:

#     ..src > scheme
#       (define (memq item x)
#         (cond ((null? x) false)
#               ((eq? item (car x)) x)
#               (else (memq item (cdr x)))))
#     < src..
    ..src > scheme
      (define (memq item x)
        (cond ((null? x) false)
              ((eq? item (car x)) x)
              (else (memq item (cdr x)))))
    < src..

#     For example, the value of
    Por ejemplo, el valor de

#     ..src > scheme
#       (memq 'apple '(pear banana prune))
#     < src..
    ..src > scheme
      (memq 'apple '(pear banana prune))
    < src..

#     is false, whereas the value of
    Es falso, mientras que el valor de

#     ..src > scheme
#       (memq 'apple '(x (apple sauce) y apple pear))
#     < src..
    ..src > scheme
      (memq 'apple '(x (apple sauce) y apple pear))
    < src..

#     is @c[(apple pear)].
    es @c[(apple pear)].

#     :: @t(Exercise 2.53) :: What would the interpreter print in response to
#        evaluating each of the following expressions?
    :: @t(Ejercicio 2.53) :: ¿Qué imprimiría el intérprete en respuesta a la
       evaluación de cada una de las siguientes expresiones?

#        ..src > scheme
#          (list 'a 'b 'c)
#          (list (list 'george))
#          (cdr '((x1 x2) (y1 y2)))
#          (cadr '((x1 x2) (y1 y2)))
#          (pair? (car '(a short list)))
#          (memq 'red '((red shoes) (blue socks)))
#          (memq 'red '(red shoes blue socks))
#        < src..
       ..src > scheme
         (list 'a 'b 'c)
         (list (list 'george))
         (cdr '((x1 x2) (y1 y2)))
         (cadr '((x1 x2) (y1 y2)))
         (pair? (car '(a short list)))
         (memq 'red '((red shoes) (blue socks)))
         (memq 'red '(red shoes blue socks))
       < src..

#     :: @t(Exercise 2.54) :: Two lists are said to be @c(equal?) if they contain
#        equal elements arranged in the same order. For example,
    :: @t(Ejercicio 2.54) :: Se dice que dos listas son @c(equal?) si contienen
    elementos iguales dispuestos en el mismo orden. Por ejemplo,

#        ..src > scheme
#          (equal? '(this is a list)
#                  '(this is a list))
#        < src..
       ..src > scheme
         (equal? '(this is a list)
                 '(this is a list))
       < src..

#        is true, but
       Es cierto, pero

#        ..src > scheme
#          (equal? '(this is a list)
#                  '(this (is a) list))
#        < src..
       ..src > scheme
         (equal? '(this is a list)
                 '(this (is a) list))
       < src..

#        is false. To be more precise, we can define @c(equal?)  recursively in
#        terms of the basic @c(eq?) equality of symbols by saying that @c(a) and
#        @c(b) are @c(equal?) if they are both symbols and the symbols are @c(eq?),
#        or if they are both lists such that @c[(car a)] is @c(equal?)  to @c[(car
#        b)] and @c[(cdr a)] is @c(equal?) to @c[(cdr b)]. Using this idea,
#        implement @c(equal?) as a procedure.@n(102)
       Es falso. Para ser más precisos, podemos definir @c(equal?)  de forma
       recursiva en términos de la básica @c(eq?) igualdad de símbolos diciendo
       que @c(a) y @c(b) somos @c(equal?) si ambos son símbolos y los símbolos
       son @c(eq?), o si ambos son listas de tal manera que @c[(car a)] es
       @c(equal?)  a @c[(car b)], y @c[(cdr a)] es @c(equal?) a @c[(cdr
       b)]. Utilizando esta idea, implementar @c(equal?) como un
       procedimiento.@n(102)

#     :: @t(Exercise 2.55) :: Eva Lu Ator types to the interpreter the expression
    :: @t(Ejercicio 2.55) :: Eva Lu Ator escribe al intérprete la expresión

#        ..src > scheme
#          (car ''abracadabra)
#        < src..
       ..src > scheme
         (car ''abracadabra)
       < src..

#        To her surprise, the interpreter prints back @c(quote). Explain.
       Para su sorpresa, el intérprete hace una copia @c(quote). Explique.

# *** 2.3.2 <> Example: Symbolic Differentiation
*** 2.3.2 <> Ejemplo: Diferenciación simbólica

#     As an illustration of symbol manipulation and a further illustration of data
#     abstraction, consider the design of a procedure that performs symbolic
#     differentiation of algebraic expressions. We would like the procedure to take
#     as arguments an algebraic expression and a variable and to return the
#     derivative of the expression with respect to the variable. For example, if the
#     arguments to the procedure are @m(ax² + bx + c) and @m(x), the procedure
#     should return @m(2ax + b). Symbolic differentiation is of special historical
#     significance in Lisp. It was one of the motivating examples behind the
#     development of a computer language for symbol manipulation.  Furthermore, it
#     marked the beginning of the line of research that led to the development of
#     powerful systems for symbolic mathematical work, which are currently being
#     used by a growing number of applied mathematicians and physicists.
    Como ilustración de la manipulación de símbolos y una ilustración adicional
    de la abstracción de datos, considere el diseño de un procedimiento que
    realiza la diferenciación simbólica de las expresiones algebraicas. Queremos
    que el procedimiento tome como argumentos una expresión algebraica y una
    variable y devuelva la derivada de la expresión con respecto a la
    variable. Por ejemplo, si los argumentos en el procedimiento son @m(ax² +
    bx + c) y @m(x), el procedimiento debe volver @m(2ax + b). La diferenciación
    simbólica tiene un significado histórico especial en Lisp. Fue uno de los
    ejemplos motivadores detrás del desarrollo de un lenguaje informático para
    la manipulación de símbolos. Además, marcó el inicio de la línea de
    investigación que condujo al desarrollo de poderosos sistemas de trabajo
    matemático simbólico,

#     In developing the symbolic-differentiation program, we will follow the same
#     strategy of data abstraction that we followed in developing the
#     rational-number system of section @l(#2.1.1). That is, we will first define a
#     differentiation algorithm that operates on abstract objects such as @"(sums,)
#     @"(products,) and @"(variables) without worrying about how these are to be
#     represented. Only afterward will we address the representation problem.
    Al desarrollar el programa de diferenciación simbólica, seguiremos la misma
    estrategia de abstracción de datos que seguimos al desarrollar el sistema de
    números racionales de la seccion @l(#2.1.1). Es decir, primero definiremos un
    algoritmo de diferenciación que opera sobre objetos abstractos tales como
    @"(sumas, ) @"(productos) y @"(variables) sin preocuparse por cómo se
    representan. Sólo después abordaremos el problema de la representación.

# **** The differentiation program with abstract data
**** El programa de diferenciación con datos abstractos

#      In order to keep things simple, we will consider a very simple
#      symbolic-differentiation program that handles expressions that are built up
#      using only the operations of addition and multiplication with two arguments.
#      Differentiation of any such expression can be carried out by applying the
#      following reduction rules:
     Para simplificar las cosas, consideraremos un programa muy simple de
     diferenciación simbólica que maneja expresiones que se construyen
     utilizando sólo las operaciones de adición y multiplicación con dos
     argumentos. La diferenciación de cualquier expresión de este tipo puede
     llevarse a cabo aplicando las siguientes reglas de reducción:

#      ..example >
#        dc
#        -- = 0  for c a constant, or a variable different from x
#        dx
#
#              dx
#              -- = 1
#              dx
#
#        d(u + v)   du   dv
#        -------- = -- + --
#           dx      dx   dx
#
#           d(uv)    dv    du
#           ----- = u-- + v--
#            dx      dx    dx
#      < example..
     ..example >
       dc
       -- = 0  for c a constant, or a variable different from x
       dx

             dx
             -- = 1
             dx

       d(u + v)   du   dv
       -------- = -- + --
          dx      dx   dx

          d(uv)    dv    du
          ----- = u-- + v--
           dx      dx    dx
     < example..

#      Observe that the latter two rules are recursive in nature. That is, to obtain
#      the derivative of a sum we first find the derivatives of the terms and add
#      them. Each of the terms may in turn be an expression that needs to be
#      decomposed. Decomposing into smaller and smaller pieces will eventually
#      produce pieces that are either constants or variables, whose derivatives will
#      be either 0 or 1.
     Observe que las dos últimas reglas son de naturaleza recursiva. Es decir,
     para obtener la derivada de una suma primero encontraremos las derivadas de
     los términos y los sumaremos. Cada uno de los términos puede a su vez ser
     una expresión que necesita ser descompuesta. La descomposición en piezas
     cada vez más pequeñas producirá eventualmente piezas que son constantes o
     variables, cuyas derivadas serán 0 o 1.

#      To embody these rules in a procedure we indulge in a little wishful thinking,
#      as we did in designing the rational-number implementation. If we had a means
#      for representing algebraic expressions, we should be able to tell whether an
#      expression is a sum, a product, a constant, or a variable. We should be able
#      to extract the parts of an expression. For a sum, for example we want to be
#      able to extract the addend (first term) and the augend (second term). We
#      should also be able to construct expressions from parts. Let us assume that we
#      already have procedures to implement the following selectors, constructors,
#      and predicates:
     Para encarnar estas reglas en un procedimiento nos entregamos a un poco de
     ilusiones, como lo hicimos al diseñar la implementación del número
     racional. Si tuviéramos un medio para representar las expresiones
     algebraicas, deberíamos ser capaces de decir si una expresión es una suma,
     un producto, una constante o una variable. Debemos ser capaces de extraer
     las partes de una expresión. Para una suma, por ejemplo, queremos ser
     capaces de extraer el addend (primer término) y el augend (segundo
     término). También deberíamos ser capaces de construir expresiones de
     partes. Supongamos que ya tenemos procedimientos para implementar los
     siguientes selectores, constructores y predicados:

#      | @c[(variable? e)]          | Is @c(e) a variable?                        |
#      |----------------------------|---------------------------------------------|
#      | @c[(same-variable? v1 v2)] | Are @c(v1) and @c(v2) the same variable?    |
#      |----------------------------|---------------------------------------------|
#      | @c[(sum? e)]               | Is @c(e) a sum?                             |
#      |----------------------------|---------------------------------------------|
#      | @c[(addend e)]             | Addend of the sum @c(e).                    |
#      |----------------------------|---------------------------------------------|
#      | @c[(augend e)]             | Augend of the sum @c(e).                    |
#      |----------------------------|---------------------------------------------|
#      | @c[(make-sum a1 a2)]       | Construct the sum of @c(a1) and @c(a2).     |
#      |----------------------------|---------------------------------------------|
#      | @c[(product? e)]           | Is @c(e) a product?                         |
#      |----------------------------|---------------------------------------------|
#      | @c[(multiplier e)]         | Multiplier of the product @c(e).            |
#      |----------------------------|---------------------------------------------|
#      | @c[(multiplicand e)]       | Multiplicand of the product @c(e).          |
#      |----------------------------|---------------------------------------------|
#      | @c[(make-product m1 m2)]   | Construct the product of @c(m1) and @c(m2). |
     | @c[(variable? e)]          | ¿Es @c(e) una variable?                   |
     |----------------------------|-------------------------------------------|
     | @c[(same-variable? v1 v2)] | ¿Son @c(v1) y @c(v2) la misma variable?   |
     |----------------------------|-------------------------------------------|
     | @c[(sum? e)]               | ¿Es @c(e) una suma?                       |
     |----------------------------|-------------------------------------------|
     | @c[(addend e)]             | Adición de la suma @c(e).                 |
     |----------------------------|-------------------------------------------|
     | @c[(augend e)]             | Aumento de la suma @c(e).                 |
     |----------------------------|-------------------------------------------|
     | @c[(make-sum a1 a2)]       | Construir la suma de @c(a1) y @c(a2).     |
     |----------------------------|-------------------------------------------|
     | @c[(product? e)]           | ¿Es @c(e) un producto?                    |
     |----------------------------|-------------------------------------------|
     | @c[(multiplier e)]         | Multiplicador del producto @c(e).         |
     |----------------------------|-------------------------------------------|
     | @c[(multiplicand e)]       | Multiplicante del producto @c(e).         |
     |----------------------------|-------------------------------------------|
     | @c[(make-product m1 m2)]   | Construir el producto de @c(m1) y @c(m2). |


#      Using these, and the primitive predicate @c(number?), which identifies
#      numbers, we can express the differentiation rules as the following procedure:
     Utilizando estos, y el predicado primitivo @c(number?), que identifica los
     números, podemos expresar las reglas de diferenciación como el siguiente
     procedimiento:

#      ..src > scheme
#        (define (deriv exp var)
#          (cond ((number? exp) 0)
#                ((variable? exp)
#                 (if (same-variable? exp var) 1 0))
#                ((sum? exp)
#                 (make-sum (deriv (addend exp) var)
#                           (deriv (augend exp) var)))
#                ((product? exp)
#                 (make-sum
#                  (make-product
#                   (multiplier exp)
#                   (deriv (multiplicand exp) var))
#                  (make-product
#                   (deriv (multiplier exp) var)
#                   (multiplicand exp))))
#                (else (error "unknown expression
#                              type: DERIV" exp))))
#      < src..
     ..src > scheme
       (define (deriv exp var)
         (cond ((number? exp) 0)
               ((variable? exp)
                (if (same-variable? exp var) 1 0))
               ((sum? exp)
                (make-sum (deriv (addend exp) var)
                          (deriv (augend exp) var)))
               ((product? exp)
                (make-sum
                 (make-product
                  (multiplier exp)
                  (deriv (multiplicand exp) var))
                 (make-product
                  (deriv (multiplier exp) var)
                  (multiplicand exp))))
               (else (error "unknown expression
                             type: DERIV" exp))))
     < src..

#      This @c(deriv) procedure incorporates the complete differentiation
#      algorithm. Since it is expressed in terms of abstract data, it will work no
#      matter how we choose to represent algebraic expressions, as long as we design
#      a proper set of selectors and constructors. This is the issue we must address
#      next.
     Este procedimiento @c(deriv) incorpora el algoritmo completo de
     diferenciación. Dado que se expresa en términos de datos abstractos,
     funcionará no importa cómo elegimos representar expresiones algebraicas,
     siempre y cuando diseñemos un conjunto adecuado de selectores y
     constructores. Este es el tema que debemos abordar a continuación.

# **** Representing algebraic expressions
**** Representación de expresiones algebraicas

#      We can imagine many ways to use list structure to represent algebraic
#      expressions. For example, we could use lists of symbols that mirror the usual
#      algebraic notation, representing @m(ax + b) as the list @c[(a * x + b)].
#      However, one especially straightforward choice is to use the same
#      parenthesized prefix notation that Lisp uses for combinations; that is, to
#      represent @m(ax + b) as @c[(+ (* a x) b)]. Then our data representation for
#      the differentiation problem is as follows:
     Podemos imaginar muchas maneras de usar la estructura de lista para
     representar expresiones algebraicas. Por ejemplo, podríamos usar listas de
     símbolos que reflejen la notación algebraica habitual, representando
     @m(ax + b) como la lista @c[(a * x + b)]. Sin embargo, una opción
     especialmente directa es utilizar la misma notación de prefijo entre
     paréntesis que Lisp utiliza para combinaciones; Es decir, representar
     @m(ax + b) as @c[(+ (* a x) b)]. Entonces nuestra representación de datos
     para el problema de diferenciación es la siguiente:

#      - The variables are symbols. They are identified by the primitive predicate
#        @c(symbol?):
     - Las variables son símbolos. Son identificados por el predicado primitivo
       @c(symbol?):

#        ..src > scheme
#          (define (variable? x) (symbol? x))
#        < src..
       ..src > scheme
         (define (variable? x) (symbol? x))
       < src..

#      - Two variables are the same if the symbols representing them are @c(eq?):
     - Dos variables son iguales si los símbolos que las representan son
       @c(eq?):

#        ..src > scheme
#          (define (same-variable? v1 v2)
#            (and (variable? v1)
#                 (variable? v2)
#                 (eq? v1 v2)))
#        < src..
       ..src > scheme
         (define (same-variable? v1 v2)
           (and (variable? v1)
                (variable? v2)
                (eq? v1 v2)))
       < src..

#      - Sums and products are constructed as lists:
     - Las sumas y productos se construyen como listas:

#        ..src > scheme
#          (define (make-sum a1 a2) (list '+ a1 a2))
#          (define (make-product m1 m2) (list '* m1 m2))
#        < src..
       ..src > scheme
         (define (make-sum a1 a2) (list '+ a1 a2))
         (define (make-product m1 m2) (list '* m1 m2))
       < src..

#      - A sum is a list whose first element is the symbol @c(+):
     - Una suma es una lista cuyo primer elemento es el símbolo @c(+):

#        ..src > scheme
#          (define (sum? x)
#            (and (pair? x) (eq? (car x) '+)))
#        < src..
       ..src > scheme
         (define (sum? x)
           (and (pair? x) (eq? (car x) '+)))
       < src..

#      - The addend is the second item of the sum list:
     - El complemento es el segundo elemento de la lista de sumas:

#        ..src > scheme
#          (define (addend s) (cadr s))
#        < src..
       ..src > scheme
         (define (addend s) (cadr s))
       < src..

#      - The augend is the third item of the sum list:
     - El augend es el tercer punto de la lista de sumas:

#        ..src > scheme
#          (define (augend s) (caddr s))
#        < src..
       ..src > scheme
         (define (augend s) (caddr s))
       < src..

#      - A product is a list whose first element is the symbol @c(*):
     - Un producto es una lista cuyo primer elemento es el símbolo @c(*):

#        ..src > scheme
#          (define (product? x)
#            (and (pair? x) (eq? (car x) '*)))
#        < src..
       ..src > scheme
         (define (product? x)
           (and (pair? x) (eq? (car x) '*)))
       < src..

#      - The multiplier is the second item of the product list:
     - El multiplicador es el segundo elemento de la lista de productos:

#        ..src > scheme
#          (define (multiplier p) (cadr p))
#        < src..
       ..src > scheme
         (define (multiplier p) (cadr p))
       < src..

#      - The multiplicand is the third item of the product list:
     - El multiplicando es el tercer elemento de la lista de productos:

#        ..src > scheme
#          (define (multiplicand p) (caddr p))
#        < src..
       ..src > scheme
         (define (multiplicand p) (caddr p))
       < src..


#      Thus, we need only combine these with the algorithm as embodied by @c(deriv)
#      in order to have a working symbolic-differentiation program. Let us look at
#      some examples of its behavior:
     Por lo tanto, sólo necesitamos combinar estos con el algoritmo tal como se
     materializa @c(deriv) para tener un programa de simbología-diferenciación
     de trabajo. Veamos algunos ejemplos de su comportamiento:

#      ..srci > scheme
#        > (deriv '(+ x 3) 'x)
#        (+ 1 0)
#        > (deriv '(* x y) 'x)
#        (+ (* x 0) (* 1 y))
#        > (deriv '(* (* x y) (+ x 3)) 'x)
#        (+ (* (* x y) (+ 1 0))
#           (* (+ (* x 0) (* 1 y))
#              (+  x 3)))
#      < srci..
     ..srci > scheme
       > (deriv '(+ x 3) 'x)
       (+ 1 0)
       > (deriv '(* x y) 'x)
       (+ (* x 0) (* 1 y))
       > (deriv '(* (* x y) (+ x 3)) 'x)
       (+ (* (* x y) (+ 1 0))
          (* (+ (* x 0) (* 1 y))
             (+  x 3)))
     < srci..

#      The program produces answers that are correct; however, they are unsimplified.
#      It is true that
     El programa produce respuestas correctas; Sin embargo, no son
     simplificados. Es cierto que

#      ..example >
#        d(xy)
#        ----- = x ⋅ 0 + 1 ⋅ y
#         dx
#      < example..
     ..example >
       d(xy)
       ----- = x ⋅ 0 + 1 ⋅ y
        dx
     < example..

#      but we would like the program to know that @m(x ⋅ 0 = 0), @m(1 ⋅ y = y), and
#      @m(0 + y = y). The answer for the second example should have been simply
#      @c(y). As the third example shows, this becomes a serious issue when the
#      expressions are complex.
     Pero queremos que el programa sepa que @m(x ⋅ 0 = 0), @m(1 ⋅ y = y), y
     @m(0 + y = y). La respuesta para el segundo ejemplo debería haber sido
     simplemente @c(y). Como muestra el tercer ejemplo, esto se convierte en un
     problema serio cuando las expresiones son complejas.

#      Our difficulty is much like the one we encountered with the rational-number
#      implementation: we haven't reduced answers to simplest form. To accomplish the
#      rational-number reduction, we needed to change only the constructors and the
#      selectors of the implementation. We can adopt a similar strategy here. We
#      won't change @c(deriv) at all. Instead, we will change @c(make-sum) so that if
#      both summands are numbers, @c(make-sum) will add them and return their
#      sum. Also, if one of the summands is 0, then @c(make-sum) will return the
#      other summand:
     Nuestra dificultad es muy similar a la que encontramos con la
     implementación del número racional: no hemos reducido las respuestas a la
     forma más simple. Para lograr la reducción del número racional, sólo
     necesitábamos cambiar los constructores y los selectores de la
     implementación. Podemos adoptar una estrategia similar aquí. No vamos a
     cambiar @c(deriv) en absoluto. En su lugar, vamos a cambiar @c(make-sum)
     para que si ambos summands son números, @c(make-sum) se añaden y devolver
     su suma. Además, si uno de los summands es 0, entonces @c(make-sum)
     devolverá el otro summand:

#      ..src > scheme
#        (define (make-sum a1 a2)
#          (cond ((=number? a1 0) a2)
#                ((=number? a2 0) a1)
#                ((and (number? a1) (number? a2))
#                 (+ a1 a2))
#                (else (list '+ a1 a2))))
#      < src..
     ..src > scheme
       (define (make-sum a1 a2)
         (cond ((=number? a1 0) a2)
               ((=number? a2 0) a1)
               ((and (number? a1) (number? a2))
                (+ a1 a2))
               (else (list '+ a1 a2))))
     < src..

#      This uses the procedure @c(=number?), which checks whether an expression is
#      equal to a given number:
     Esto utiliza el procedimiento @c(=number?), que verifica si una expresión
     es igual a un número dado:

#      ..src > scheme
#        (define (=number? exp num)
#          (and (number? exp) (= exp num)))
#      < src..
     ..src > scheme
       (define (=number? exp num)
         (and (number? exp) (= exp num)))
     < src..

#      Similarly, we will change @c(make-product) to build in the rules that 0 times
#      anything is 0 and 1 times anything is the thing itself:
     Del mismo modo, vamos a cambiar @c(make-product) para construir en las
     reglas que 0 veces nada es 0 y 1 veces nada es la cosa en sí:

#      ..src > scheme
#        (define (make-product m1 m2)
#          (cond ((or (=number? m1 0)
#                     (=number? m2 0))
#                 0)
#                ((=number? m1 1) m2)
#                ((=number? m2 1) m1)
#                ((and (number? m1) (number? m2))
#                 (* m1 m2))
#                (else (list '* m1 m2))))
#      < src..
     ..src > scheme
       (define (make-product m1 m2)
         (cond ((or (=number? m1 0)
                    (=number? m2 0))
                0)
               ((=number? m1 1) m2)
               ((=number? m2 1) m1)
               ((and (number? m1) (number? m2))
                (* m1 m2))
               (else (list '* m1 m2))))
     < src..

#      Here is how this version works on our three examples:
     Así es como funciona esta versión en nuestros tres ejemplos:

#      ..srci > scheme
#        > (deriv '(+ x 3) 'x)
#        1
#        > (deriv '(* x y) 'x)
#        y
#        > (deriv '(* (* x y) (+ x 3)) 'x)
#        (+ (* x y) (* y (+ x 3)))
#      < srci..
     ..srci > scheme
       > (deriv '(+ x 3) 'x)
       1
       > (deriv '(* x y) 'x)
       y
       > (deriv '(* (* x y) (+ x 3)) 'x)
       (+ (* x y) (* y (+ x 3)))
     < srci..

#      Although this is quite an improvement, the third example shows that there is
#      still a long way to go before we get a program that puts expressions into a
#      form that we might agree is @"(simplest.)  The problem of algebraic
#      simplification is complex because, among other reasons, a form that may be
#      simplest for one purpose may not be for another.
     Aunque esto es bastante una mejora, el tercer ejemplo muestra que todavía
     hay un largo camino por recorrer antes de obtener un programa que pone las
     expresiones en una forma que podríamos estar de acuerdo es @"(más simple. )
     El problema de la simplificación algebraica es complejo porque, entre otras
     razones, una forma que puede ser más simple para un propósito no puede ser
     para otro.

#      :: @t(Exercise 2.56) :: Show how to extend the basic differentiator to handle
#         more kinds of expressions. For instance, implement the differentiation rule
     :: @t(Ejercicio 2.56) :: Mostrar cómo ampliar el diferenciador básico para
        manejar más tipos de expresiones. Por ejemplo, implementar la regla de
        diferenciación

#         ..example >
#           d(uⁿ)           du
#           ----- = nu⁽ⁿ⁻¹⁾ --
#             dx            dx
#         < example..
        ..example >
          d(uⁿ)           du
          ----- = nu⁽ⁿ⁻¹⁾ --
            dx            dx
        < example..

#         by adding a new clause to the @c(deriv) program and defining appropriate
#         procedures @c(exponentiation?), @c(base), @c(exponent), and
#         @c(make-exponentiation). (You may use the symbol @c(**) to denote
#         exponentiation.)  Build in the rules that anything raised to the power 0 is
#         1 and anything raised to the power 1 is the thing itself.
        mediante la adición de una nueva cláusula al @c(deriv) programa y la
        definición de los procedimientos adecuados @c(exponentiation?),
        @c(base), @c(exponent), y @c(make-exponentiation). (Puede usar el
        símbolo @c(**) para denotar exponenciación.) Construya en las reglas que
        cualquier cosa elevada a la potencia 0 es 1 y cualquier cosa elevada a
        la potencia 1 es la cosa misma.

#      :: @t(Exercise 2.57) :: Extend the differentiation program to handle sums and
#         products of arbitrary numbers of (two or more) terms. Then the last example
#         above could be expressed as
     :: @t(Ejercicio 2.57) :: Ampliar el programa de diferenciación para manejar
        sumas y productos de números arbitrarios de (dos o más)
        términos. Entonces el último ejemplo anterior podría expresarse como

#         ..src > scheme
#           (deriv '(* x y (+ x 3)) 'x)
#         < src..
        ..src > scheme
          (deriv '(* x y (+ x 3)) 'x)
        < src..

#         Try to do this by changing only the representation for sums and products,
#         without changing the @c(deriv) procedure at all. For example, the
#         @c(addend) of a sum would be the first term, and the @c(augend) would be
#         the sum of the rest of the terms.
        Trate de hacer esto cambiando sólo la representación de sumas y
        productos, sin cambiar el procedimiento @c(deriv) en absoluto. Por
        ejemplo, el @c(addend) de una suma sería el primer término, y el
        @c(augend) sería la suma del resto de los términos.

#      :: @t(Exercise 2.58) :: Suppose we want to modify the differentiation program
#         so that it works with ordinary mathematical notation, in which @c(+) and
#         @c(*) are infix rather than prefix operators. Since the differentiation
#         program is defined in terms of abstract data, we can modify it to work with
#         different representations of expressions solely by changing the predicates,
#         selectors, and constructors that define the representation of the algebraic
#         expressions on which the differentiator is to operate.
     :: @t(Ejercicio 2.58) :: Supongamos que queremos modificar el programa de
        diferenciación para que funcione con la notación matemática ordinaria,
        en la cual @c(+) y @c(*) son infijo en lugar de operadores de
        prefijo. Puesto que el programa de diferenciación se define en términos
        de datos abstractos, podemos modificarlo para trabajar con diferentes
        representaciones de expresiones únicamente cambiando los predicados,
        selectores y constructores que definen la representación de las
        expresiones algebraicas en las que el diferenciador debe operar.

#         - Show how to do this in order to differentiate algebraic expressions
#           presented in infix form, such as @c[(x + (3 * (x + (y + 2))))]. To
#           simplify the task, assume that @c(+) and @c(*) always take two arguments
#           and that expressions are fully parenthesized.
        - Mostrar cómo hacer esto para diferenciar las expresiones algebraicas
          presentadas en forma infix, como @c[(x + (3 * (x + (y + 2))))]. Para
          simplificar la tarea, asumir que @c(+) y @c(*) siempre tomar dos
          argumentos y que las expresiones están totalmente entre paréntesis.

#         - The problem becomes substantially harder if we allow standard algebraic
#           notation, such as @c[(x + 3 * (x + y + 2))], which drops unnecessary
#           parentheses and assumes that multiplication is done before addition. Can
#           you design appropriate predicates, selectors, and constructors for this
#           notation such that our derivative program still works?
        - El problema se vuelve sustancialmente más difícil si permitimos la
          notación algebraica estándar, tal como @c[(x + 3 * (x + y + 2))], que
          deja caer los paréntesis innecesarios y asume que la multiplicación se
          hace antes de la adición. ¿Puede diseñar predicados, selectores y
          constructores apropiados para esta notación de tal manera que nuestro
          programa derivado siga funcionando?

# *** 2.3.3 <> Example: Representing Sets
*** 2.3.3 <> Ejemplo: Representación de conjuntos

#     In the previous examples we built representations for two kinds of compound
#     data objects: rational numbers and algebraic expressions. In one of these
#     examples we had the choice of simplifying (reducing) the expressions at either
#     construction time or selection time, but other than that the choice of a
#     representation for these structures in terms of lists was
#     straightforward. When we turn to the representation of sets, the choice of a
#     representation is not so obvious. Indeed, there are a number of possible
#     representations, and they differ significantly from one another in several
#     ways.
    En los ejemplos anteriores construimos representaciones para dos tipos de
    objetos de datos compuestos: números racionales y expresiones
    algebraicas. En uno de estos ejemplos tuvimos la opción de simplificar
    (reducir) las expresiones en el tiempo de construcción o en el tiempo de
    selección, pero aparte de eso, la elección de una representación para estas
    estructuras en términos de listas fue sencilla. Cuando nos volvemos a la
    representación de conjuntos, la elección de una representación no es tan
    obvia. De hecho, hay un número de posibles representaciones, y difieren
    significativamente entre sí de varias maneras.

#     Informally, a set is simply a collection of distinct objects. To give a more
#     precise definition we can employ the method of data abstraction. That is, we
#     define @"(set) by specifying the operations that are to be used on sets. These
#     are @c(union-set), @c(intersection-set), @c(element-of-set?), and
#     @c(adjoin-set). @c(Element-of-set?) is a predicate that determines whether a
#     given element is a member of a set. @c(Adjoin-set) takes an object and a set
#     as arguments and returns a set that contains the elements of the original set
#     and also the adjoined element. @c(Union-set) computes the union of two sets,
#     which is the set containing each element that appears in either
#     argument. @c(Intersection-set) computes the intersection of two sets, which is
#     the set containing only elements that appear in both arguments.  From the
#     viewpoint of data abstraction, we are free to design any representation that
#     implements these operations in a way consistent with the interpretations given
#     above.@n(103)
    Informalmente, un conjunto es simplemente una colección de objetos
    distintos. Para dar una definición más precisa podemos emplear el método de
    abstracción de datos. Es decir, definimos @"(set) especificando las
    operaciones que se van a utilizar en conjuntos. Estos son @c(union-set),
    @c(intersection-set), @c(element-of-set?), y
    @c(adjoin-set). @c(Element-of-set?) Es un predicado que determina si un
    elemento dado es un miembro de un conjunto. @c(Adjoin-set) Toma un objeto y
    un conjunto como argumentos y devuelve un conjunto que contiene los
    elementos del conjunto original y también el elemento
    contiguo. @c(Union-set) Calcula la unión de dos conjuntos, que es el
    conjunto que contiene cada elemento que aparece en cualquier
    argumento. @c(Intersection-set) Calcula la intersección de dos conjuntos,
    que es el conjunto que contiene sólo los elementos que aparecen en ambos
    argumentos. Desde el punto de vista de la abstracción de datos, Somos libres
    de diseñar cualquier representación que implemente estas operaciones de una
    manera consistente con las interpretaciones dadas
    anteriormente.@n(103)

# **** Sets as unordered lists
**** Establece como listas no ordenadas

#      One way to represent a set is as a list of its elements in which no element
#      appears more than once. The empty set is represented by the empty list. In
#      this representation, @c(element-of-set?) is similar to the procedure @c(memq)
#      of section @l(#2.3.1). It uses @c(equal?)  instead of @c(eq?) so that the set elements
#      need not be symbols:
     Una forma de representar un conjunto es como una lista de sus elementos en
     la que ningún elemento aparece más de una vez. El conjunto vacío está
     representado por la lista vacía. En esta representación,
     @c(element-of-set?) es similar al procedimiento @c(memq) de
     @l(#2.3.1). Se utiliza en @c(equal?)  lugar de @c(eq?) para que los
     elementos de conjunto no necesitan ser símbolos:

#      ..src > scheme
#        (define (element-of-set? x set)
#          (cond ((null? set) false)
#                ((equal? x (car set)) true)
#                (else (element-of-set? x (cdr set)))))
#      < src..
     ..src > scheme
       (define (element-of-set? x set)
         (cond ((null? set) false)
               ((equal? x (car set)) true)
               (else (element-of-set? x (cdr set)))))
     < src..

#      Using this, we can write @c(adjoin-set). If the object to be adjoined is
#      already in the set, we just return the set. Otherwise, we use @c(cons) to add
#      the object to the list that represents the set:
     Usando esto, podemos escribir @c(adjoin-set). Si el objeto a ser conectado
     ya está en el conjunto, simplemente devolvemos el conjunto. De lo
     contrario, se utiliza @c(cons) para agregar el objeto a la lista que
     representa el conjunto:

#      ..src > scheme
#        (define (adjoin-set x set)
#          (if (element-of-set? x set)
#              set
#              (cons x set)))
#      < src..
     ..src > scheme
       (define (adjoin-set x set)
         (if (element-of-set? x set)
             set
             (cons x set)))
     < src..

#      For @c(intersection-set) we can use a recursive strategy. If we know how to
#      form the intersection of @c(set2) and the @c(cdr) of @c(set1), we only need to
#      decide whether to include the @c(car) of @c(set1) in this. But this depends on
#      whether @c[(car set1)] is also in @c(set2). Here is the resulting procedure:
     Porque @c(intersection-set) podemos usar una estrategia recursiva. Si
     sabemos cómo formar la intersección de @c(set2) y @c(cdr) de @c(set1), sólo
     tenemos que decidir si se debe incluir la @c(car) de @c(set1) este. Pero
     esto depende de si @c[(car set1)] también está en @c(set2). Aquí está el
     procedimiento resultante:

#      ..src > scheme
#        (define (intersection-set set1 set2)
#          (cond ((or (null? set1) (null? set2))
#                 '())
#                ((element-of-set? (car set1) set2)
#                 (cons (car set1)
#                       (intersection-set (cdr set1)
#                                         set2)))
#                (else (intersection-set (cdr set1)
#                                        set2))))
#      < src..
     ..src > scheme
       (define (intersection-set set1 set2)
         (cond ((or (null? set1) (null? set2))
                '())
               ((element-of-set? (car set1) set2)
                (cons (car set1)
                      (intersection-set (cdr set1)
                                        set2)))
               (else (intersection-set (cdr set1)
                                       set2))))
     < src..

#      In designing a representation, one of the issues we should be concerned with
#      is efficiency. Consider the number of steps required by our set operations.
#      Since they all use @c(element-of-set?), the speed of this operation has a
#      major impact on the efficiency of the set implementation as a whole. Now, in
#      order to check whether an object is a member of a set, @c(element-of-set?)
#      may have to scan the entire set. (In the worst case, the object turns out not
#      to be in the set.)  Hence, if the set has @m(n) elements, @c(element-of-set?)
#      might take up to @m(n) steps. Thus, the number of steps required grows as
#      @m[Θ(n)]. The number of steps required by @c(adjoin-set), which uses this
#      operation, also grows as @m[Θ(n)].  For @c(intersection-set), which does an
#      @c(element-of-set?) check for each element of @c(set1), the number of steps
#      required grows as the product of the sizes of the sets involved, or @m[Θ(n²)]
#      for two sets of size @m(n). The same will be true of @c(union-set).
     Al diseñar una representación, uno de los temas que debemos preocuparnos es
     la eficiencia. Considere el número de pasos requeridos por nuestras
     operaciones establecidas. Dado que todos ellos utilizan
     @c(element-of-set?), la velocidad de esta operación tiene un impacto
     importante en la eficiencia de la implementación del conjunto en su
     conjunto. Ahora, para comprobar si un objeto es un miembro de un conjunto,
     @c(element-of-set?) puede tener que explorar todo el conjunto. (En el peor
     de los casos, el objeto resulta no estar en el conjunto). Por lo tanto, si
     el conjunto tiene @m(n) elementos, @c(element-of-set?) puede tomar hasta
     @m(n) pasos. Así, el número de pasos requeridos crece como @m[Θ(n)]. El
     número de pasos requeridos por @c(adjoin-set), que utiliza esta operación,
     también crece como @m[Θ(n)]. Para @c(intersection-set), que hace un
     @c(element-of-set?) cheque para cada elemento de @c(set1), @m(El número de
     pasos necesarios crece como el producto de los tamaños de los conjuntos
     involucrados, o Θ (n²)) para dos conjuntos de tamaño @m(n). Lo mismo
     ocurrirá con @c(union-set).

#      :: @t(Exercise 2.59) :: Implement the @c(union-set) operation for the
#         unordered-list representation of sets.
     :: @t(Ejercicio 2.59) :: Implementar la @c(union-set) operación para la
        lista desordenada de representación de conjuntos.

#      :: @t(Exercise 2.60) :: We specified that a set would be represented as a list
#         with no duplicates. Now suppose we allow duplicates.  For instance, the set
#         @m({1, 2, 3}) could be represented as the list @c[(2 3 2 1 3 2 2)]. Design
#         procedures @c(element-of-set?), @c(adjoin-set), @c(union-set), and
#         @c(intersection-set) that operate on this representation. How does the
#         efficiency of each compare with the corresponding procedure for the
#         non-duplicate representation?  Are there applications for which you would
#         use this representation in preference to the non-duplicate one?
     :: @t(Ejercicio 2.60) :: Especificamos que un conjunto sería representado
        como una lista sin duplicados. Ahora supongamos que permitimos
        duplicados. Por ejemplo, el conjunto @m({1, 2, 3}) podría ser
        representado como la lista @c[(2 3 2 1 3 2 2)]. Procedimientos de diseño
        @c(element-of-set?), @c(adjoin-set), @c(union-set), y
        @c(intersection-set) que operan en esta representación. ¿Cómo se compara
        la eficiencia de cada uno con el procedimiento correspondiente para la
        representación no duplicada? ¿Existen aplicaciones para las cuales
        usaría esta representación de preferencia a la no duplicada?

# **** Sets as ordered lists
**** Configura como listas ordenadas

#      One way to speed up our set operations is to change the representation so that
#      the set elements are listed in increasing order. To do this, we need some way
#      to compare two objects so that we can say which is bigger. For example, we
#      could compare symbols lexicographically, or we could agree on some method for
#      assigning a unique number to an object and then compare the elements by
#      comparing the corresponding numbers. To keep our discussion simple, we will
#      consider only the case where the set elements are numbers, so that we can
#      compare elements using @c(>) and @c(<). We will represent a set of numbers by
#      listing its elements in increasing order. Whereas our first representation
#      above allowed us to represent the set @m({1, 3, 6, 10}) by listing the
#      elements in any order, our new representation allows only the list @c[(1 3 6
#      10)].
     Una forma de acelerar nuestras operaciones de conjunto es cambiar la
     representación para que los elementos de conjunto se enumeran en orden
     creciente. Para ello, necesitamos alguna manera de comparar dos objetos
     para que podamos decir cuál es más grande. Por ejemplo, podríamos comparar
     símbolos lexicográficamente, o podríamos acordar algún método para asignar
     un número único a un objeto y luego comparar los elementos comparando los
     números correspondientes. Para mantener nuestra discusión simple,
     consideraremos solamente el caso donde los elementos del sistema son
     números, de modo que podamos comparar elementos usando @c(>) y
     @c(<). Representaremos un conjunto de números enumerando sus elementos
     en orden creciente. Mientras que nuestra primera representación anterior
     permitió representar el conjunto @m({1, 3, 6, 10}) enumerando los elementos
     en cualquier orden,@c[(1 3 6 10)]

#      One advantage of ordering shows up in @c(element-of-set?): In checking for the
#      presence of an item, we no longer have to scan the entire set. If we reach a
#      set element that is larger than the item we are looking for, then we know that
#      the item is not in the set:
     Una ventaja de ordenar aparece en @c(element-of-set?): Al comprobar la
     presencia de un elemento, ya no tenemos que explorar todo el conjunto. Si
     alcanzamos un elemento de conjunto que es más grande que el elemento que
     estamos buscando, entonces sabemos que el elemento no está en el conjunto:

#      ..src > scheme
#        (define (element-of-set? x set)
#          (cond ((null? set) false)
#                ((= x (car set)) true)
#                ((< x (car set)) false)
#                (else (element-of-set? x (cdr set)))))
#      < src..
     ..src > scheme
       (define (element-of-set? x set)
         (cond ((null? set) false)
               ((= x (car set)) true)
               ((< x (car set)) false)
               (else (element-of-set? x (cdr set)))))
     < src..

#      How many steps does this save?  In the worst case, the item we are looking for
#      may be the largest one in the set, so the number of steps is the same as for
#      the unordered representation. On the other hand, if we search for items of
#      many different sizes we can expect that sometimes we will be able to stop
#      searching at a point near the beginning of the list and that other times we
#      will still need to examine most of the list. On the average we should expect
#      to have to examine about half of the items in the set. Thus, the average
#      number of steps required will be about @m(n / 2). This is still @m[Θ(n)]
#      growth, but it does save us, on the average, a factor of 2 in number of steps
#      over the previous implementation.
     ¿Cuántos pasos se guardan? En el peor de los casos, el elemento que
     buscamos puede ser el más grande del conjunto, por lo que el número de
     pasos es el mismo que para la representación no ordenada. Por otro lado, si
     buscamos artículos de muchos tamaños diferentes, podemos esperar que a
     veces podremos detener la búsqueda en un punto cerca del comienzo de la
     lista y que en otras ocasiones tendremos que examinar la mayor parte de la
     lista. En promedio, deberíamos tener que examinar aproximadamente la mitad
     de los elementos del conjunto. Por lo tanto, el número medio de pasos
     requeridos será alrededor de @m(n / 2). Esto sigue siendo @m[Θ(n)]
     crecimiento, pero sí nos ahorra, en promedio, un factor de 2 en número de
     pasos sobre la implementación anterior.

#      We obtain a more impressive speedup with @c(intersection-set). In the
#      unordered representation this operation required @m[Θ(n²)] steps, because we
#      performed a complete scan of @c(set2) for each element of @c(set1). But with
#      the ordered representation, we can use a more clever method. Begin by
#      comparing the initial elements, @c(x1) and @c(x2), of the two sets. If @c(x1)
#      equals @c(x2), then that gives an element of the intersection, and the rest of
#      the intersection is the intersection of the @c(cdr)-s of the two
#      sets. Suppose, however, that @c(x1) is less than @c(x2). Since @c(x2) is the
#      smallest element in @c(set2), we can immediately conclude that @c(x1) cannot
#      appear anywhere in @c(set2) and hence is not in the intersection. Hence, the
#      intersection is equal to the intersection of @c(set2) with the @c(cdr) of
#      @c(set1). Similarly, if @c(x2) is less than @c(x1), then the intersection is
#      given by the intersection of @c(set1) with the @c(cdr) of @c(set2). Here is
#      the procedure:
     Obtenemos una aceleración más impresionante con @c(intersection-set). En la
     representación no ordenada esta operación requirió @m(Θ (n²)) pasos, porque
     realizamos una exploración completa de @c(set2) para cada elemento de
     @c(set1). Pero con la representación ordenada, podemos usar un método más
     inteligente. Comience comparando los elementos iniciales, @c(x1) y @c(x2),
     de los dos conjuntos. Si @c(x1) es igual @c(x2), entonces eso da un
     elemento de la intersección, y el resto de la intersección es la
     intersección de los @c(cdr)-s de los dos conjuntos. Supongamos, sin
     embargo, que @c(x1) es menor que @c(x2). Puesto que @c(x2) es el elemento
     más pequeño en @c(set2), podemos concluir inmediatamente que @c(x1) no
     puede aparecer en ninguna parte @c(set2) y por lo tanto no está en la
     intersección. Por lo tanto, @c(set2) La intersección es igual a la
     intersección de con el @c(cdr) de @c(set1). Del mismo modo, si @c(x2) es
     menor que @c(x1), entonces la intersección se da por la intersección de
     @c(set1) con el @c(cdr) de @c(set2). Aquí está el procedimiento:

#      ..src > scheme
#        (define (intersection-set set1 set2)
#          (if (or (null? set1) (null? set2))
#              '()
#              (let ((x1 (car set1)) (x2 (car set2)))
#                (cond ((= x1 x2)
#                       (cons x1 (intersection-set
#                                 (cdr set1)
#                                 (cdr set2))))
#                      ((< x1 x2) (intersection-set
#                                  (cdr set1)
#                                  set2))
#                      ((< x2 x1) (intersection-set
#                                  set1
#                                  (cdr set2)))))))
#      < src..
     ..src > scheme
       (define (intersection-set set1 set2)
         (if (or (null? set1) (null? set2))
             '()
             (let ((x1 (car set1)) (x2 (car set2)))
               (cond ((= x1 x2)
                      (cons x1 (intersection-set
                                (cdr set1)
                                (cdr set2))))
                     ((< x1 x2) (intersection-set
                                 (cdr set1)
                                 set2))
                     ((< x2 x1) (intersection-set
                                 set1
                                 (cdr set2)))))))
     < src..

#      To estimate the number of steps required by this process, observe that at each
#      step we reduce the intersection problem to computing intersections of smaller
#      sets––removing the first element from @c(set1) or @c(set2) or both.  Thus, the
#      number of steps required is at most the sum of the sizes of @c(set1) and
#      @c(set2), rather than the product of the sizes as with the unordered
#      representation. This is @m[Θ(n)] growth rather than @m[Θ(n²)]––a considerable
#      speedup, even for sets of moderate size.
     Para estimar el número de pasos requeridos por este proceso, observe que en
     cada paso reducimos el problema de intersección a las intersecciones de
     cálculo de conjuntos más pequeños - eliminando el primer elemento de
     @c(set1) o @c(set2) o ambos. Por lo tanto, el número de pasos requeridos es
     como máximo la suma de los tamaños de @c(set1) y @c(set2), en lugar del
     producto de los tamaños como con la representación no ordenada. Esto es
     crecimiento @m(Θ (n) en) lugar de @m(Θ (n²)) --una aceleración
     considerable, incluso para conjuntos de tamaño moderado.

#      :: @t(Exercise 2.61) :: Give an implementation of @c(adjoin-set) using the
#         ordered representation. By analogy with @c(element-of-set?) show how to
#         take advantage of the ordering to produce a procedure that requires on the
#         average about half as many steps as with the unordered representation.
     :: @t(Ejercicio 2.61) :: Dar una implementación de @c(adjoin-set) usar la
        representación ordenada. Por analogía con @c(element-of-set?) mostrar
        cómo aprovechar el orden para producir un procedimiento que requiere en
        promedio alrededor de la mitad de los pasos que con la representación
        desordenada.

#      :: @t(Exercise 2.62) :: Give a @m[Θ(n)] implementation of @c(union-set) for
#         sets represented as ordered lists.
     :: @t(Ejercicio 2.62) :: Proporcione una implementación @m[Θ(n)] de
     @c(union-set) conjuntos representados como listas ordenadas.

# **** Sets as binary trees
**** Se configura como árboles binarios

#      We can do better than the ordered-list representation by arranging the set
#      elements in the form of a tree. Each node of the tree holds one element of the
#      set, called the @"(entry) at that node, and a link to each of two other
#      (possibly empty) nodes. The @"(left) link points to elements smaller than the
#      one at the node, and the @"(right) link to elements greater than the one at
#      the node. @l(#Figure 2.16) shows some trees that represent the set @m({1, 3,
#      5, 7, 9, 11}). The same set may be represented by a tree in a number of
#      different ways. The only thing we require for a valid representation is that
#      all elements in the left subtree be smaller than the node entry and that all
#      elements in the right subtree be larger.
     Podemos hacerlo mejor que la representación de lista ordenada organizando
     los elementos del conjunto en forma de árbol. Cada nodo del árbol contiene
     un elemento del conjunto, llamado @"(entrada) en ese nodo, y un enlace a
     cada uno de los otros dos nodos (posiblemente vacíos). El enlace
     @"(izquierdo) apunta a elementos más pequeños que el del nodo, y el enlace
     @"(derecho) a elementos mayores que el del nodo. @l(#Figura
     2.16) muestra algunos árboles que representan el conjunto @m({1, 3, 5, 7,
     9, 11}). El mismo conjunto puede ser representado por un árbol de
     diferentes maneras. Lo único que necesitamos para una representación válida
     es que todos los elementos del subárbol izquierdo sean más pequeños que la
     entrada del nodo y que todos los elementos del subárbol derecho sean más
     grandes.

#      ..figure > @t(Figure 2.16) Various binary trees that represent the set
#        @m({1, 3, 5, 7, 9, 11}).
     ..figure > @t(Figura 2.16) Varios árboles binarios que representan el
       conjunto @m({1, 3, 5, 7, 9, 11}).

#        ..art >
#             7          3             5
#             /\         /\            /\
#            3  9       1  7          3  9
#           /\   \         /\        /   /\
#          1  5  11       5  9      1   7  11
#                             \
#                             11
#        < art..
       ..art >
            7          3             5
            /\         /\            /\
           3  9       1  7          3  9
          /\   \         /\        /   /\
         1  5  11       5  9      1   7  11
                            \
                            11
       < art..

# @    ..img > img/chap2/Fig2.16c.std.svg
@    ..img > img/chap2/Fig2.16c.std.svg

#      The advantage of the tree representation is this: Suppose we want to check
#      whether a number @m(x) is contained in a set. We begin by comparing @m(x) with
#      the entry in the top node. If @m(x) is less than this, we know that we need
#      only search the left subtree; if @m(x) is greater, we need only search the
#      right subtree. Now, if the tree is @"(balanced,) each of these subtrees will
#      be about half the size of the original. Thus, in one step we have reduced the
#      problem of searching a tree of size @m(n) to searching a tree of size @m(n /
#      2).  Since the size of the tree is halved at each step, we should expect that
#      the number of steps needed to search a tree of size @m(n) grows as @m[Θ(log
#      n)].@n(104) For large sets, this will be a significant speedup over the
#      previous representations.
     La ventaja de la representación del árbol es la siguiente: Supongamos que
     queremos comprobar si un número @m(x) está contenido en un
     conjunto. Comenzamos comparando @m(x) con la entrada en el nodo
     superior. Si @m(x) es menor que esto, sabemos que solo necesitamos buscar
     el subárbol izquierdo; Si @m(x) es mayor, solo necesitamos buscar el
     subárbol correcto. Ahora bien, si el árbol está @"(equilibrado,) cada uno
     de estos subárboles será aproximadamente la mitad del tamaño del
     original. Por lo tanto, en un paso hemos reducido el problema de buscar un
     árbol de tamaño @m(n) a la búsqueda de un árbol de tamaño @m(n / 2). Dado
     que el tamaño del árbol se reduce a la mitad en cada paso, @m(Debemos
     esperar que el número de pasos necesarios para buscar un árbol de tamaño n)
     crezca como @m(Θ (log n)).@n(104) Para los conjuntos grandes, esto
     será una aceleración significativa sobre las representaciones anteriores.

#      We can represent trees by using lists. Each node will be a list of three
#      items: the entry at the node, the left subtree, and the right subtree. A left
#      or a right subtree of the empty list will indicate that there is no subtree
#      connected there. We can describe this representation by the following
#      procedures:@n(105)
     Podemos representar árboles usando listas. Cada nodo será una lista de tres
     elementos: la entrada en el nodo, el subárbol izquierdo y el subárbol
     derecho. Una subárbol izquierda o derecha de la lista vacía indicará que no
     hay ningún subárbol conectado allí. Podemos describir esta representación
     mediante los siguientes procedimientos:@n(105)

#      ..src > scheme
#        (define (entry tree) (car tree))
#        (define (left-branch tree) (cadr tree))
#        (define (right-branch tree) (caddr tree))
#        (define (make-tree entry left right)
#          (list entry left right))
#      < src..
     ..src > scheme
       (define (entry tree) (car tree))
       (define (left-branch tree) (cadr tree))
       (define (right-branch tree) (caddr tree))
       (define (make-tree entry left right)
         (list entry left right))
     < src..

#      Now we can write the @c(element-of-set?) procedure using the strategy
#      described above:
     Ahora podemos escribir el procedimiento @c(element-of-set?) usando la
     estrategia descrita arriba:

#      ..src > scheme
#        (define (element-of-set? x set)
#          (cond ((null? set) false)
#                ((= x (entry set)) true)
#                ((< x (entry set))
#                 (element-of-set?
#                  x
#                  (left-branch set)))
#                ((> x (entry set))
#                 (element-of-set?
#                  x
#                  (right-branch set)))))
#      < src..
     ..src > scheme
       (define (element-of-set? x set)
         (cond ((null? set) false)
               ((= x (entry set)) true)
               ((< x (entry set))
                (element-of-set?
                 x
                 (left-branch set)))
               ((> x (entry set))
                (element-of-set?
                 x
                 (right-branch set)))))
     < src..

#      Adjoining an item to a set is implemented similarly and also requires @m[Θ(log
#      n)] steps. To adjoin an item @c(x), we compare @c(x) with the node entry to
#      determine whether @c(x) should be added to the right or to the left branch,
#      and having adjoined @c(x) to the appropriate branch we piece this newly
#      constructed branch together with the original entry and the other branch. If
#      @c(x) is equal to the entry, we just return the node. If we are asked to
#      adjoin @c(x) to an empty tree, we generate a tree that has @c(x) as the entry
#      and empty right and left branches. Here is the procedure:
     Adjuntar un elemento a un conjunto se implementa de forma similar y también
     requiere pasos @m(Θ (log n)). Para unir un elemento @c(x), comparamos @c(x)
     con la entrada del nodo para determinar si @c(x) debe añadirse a la rama
     derecha o izquierda y, adyacente @c(x) a la rama apropiada, esta rama
     recién construida, junto con la entrada original y la otra rama. Si @c(x)
     es igual a la entrada, simplemente devolvemos el nodo. Si se nos pide que
     nos unamos @c(x) a un árbol vacío, generamos un árbol que tiene @c(x) como
     entrada y las ramas derecha e izquierda vacías. Aquí está el procedimiento:

#      ..src > scheme
#        (define (adjoin-set x set)
#          (cond ((null? set) (make-tree x '() '()))
#                ((= x (entry set)) set)
#                ((< x (entry set))
#                 (make-tree
#                  (entry set)
#                  (adjoin-set x (left-branch set))
#                  (right-branch set)))
#                ((> x (entry set))
#                 (make-tree
#                  (entry set)
#                  (left-branch set)
#                  (adjoin-set x (right-branch set))))))
#      < src..
     ..src > scheme
       (define (adjoin-set x set)
         (cond ((null? set) (make-tree x '() '()))
               ((= x (entry set)) set)
               ((< x (entry set))
                (make-tree
                 (entry set)
                 (adjoin-set x (left-branch set))
                 (right-branch set)))
               ((> x (entry set))
                (make-tree
                 (entry set)
                 (left-branch set)
                 (adjoin-set x (right-branch set))))))
     < src..

#      The above claim that searching the tree can be performed in a logarithmic
#      number of steps rests on the assumption that the tree is @"(balanced,) i.e.,
#      that the left and the right subtree of every tree have approximately the same
#      number of elements, so that each subtree contains about half the elements of
#      its parent. But how can we be certain that the trees we construct will be
#      balanced?  Even if we start with a balanced tree, adding elements with
#      @c(adjoin-set) may produce an unbalanced result. Since the position of a newly
#      adjoined element depends on how the element compares with the items already in
#      the set, we can expect that if we add elements @"(randomly) the tree will tend
#      to be balanced on the average. But this is not a guarantee. For example, if we
#      start with an empty set and adjoin the numbers 1 through 7 in sequence we end
#      up with the highly unbalanced tree shown in @l(#Figure 2.17).  In this tree
#      all the left subtrees are empty, so it has no advantage over a simple ordered
#      list. One way to solve this problem is to define an operation that transforms
#      an arbitrary tree into a balanced tree with the same elements.  Then we can
#      perform this transformation after every few @c(adjoin-set) operations to keep
#      our set in balance. There are also other ways to solve this problem, most of
#      which involve designing new data structures for which searching and insertion
#      both can be done in @m[Θ(log n)] steps.@n(106)
     La afirmación anterior de que la búsqueda del árbol puede realizarse en un
     número logarítmico de pasos se basa en la suposición de que el árbol está
     @"(equilibrado,) es decir, que el subárbol izquierdo y el derecho de cada
     árbol tienen aproximadamente el mismo número de elementos, de modo que cada
     subárbol Contiene aproximadamente la mitad de los elementos de su
     padre. Pero, ¿cómo podemos estar seguros de que los árboles que construimos
     serán equilibrados? Incluso si empezamos con un árbol equilibrado, la
     adición de elementos con @c(adjoin-set) puede producir un resultado
     desequilibrado. Dado que la posición de un elemento recién adjunto depende
     de cómo el elemento se compara con los elementos que ya están en el
     conjunto, podemos esperar que si añadimos elementos @"(al azar,) el árbol
     tiende a ser equilibrado en promedio. Pero esto no es una garantía. Por
     ejemplo, @l(#Figure-2.17<>Si empezamos con un conjunto vacío y seguimos los
     números de 1 a 7 en secuencia terminamos con el árbol altamente
     desequilibrado mostrado en la Figura 2.17). En este árbol todos los
     subárboles izquierdo están vacíos, por lo que no tiene ventaja sobre una
     simple lista ordenada. Una forma de resolver este problema es definir una
     operación que transforma un árbol arbitrario en un árbol equilibrado con
     los mismos elementos. Entonces podemos realizar esta transformación después
     de cada pocas @c(adjoin-set) operaciones para mantener nuestro conjunto en
     equilibrio. También hay otras formas de resolver este problema, la mayoría
     de las cuales implican el diseño de nuevas estructuras de datos para las
     cuales la búsqueda y la inserción se pueden realizar en pasos @m(Θ (log
     n)).@n(106) En este árbol todos los subárboles izquierdo están
     vacíos, por lo que no tiene ventaja sobre una simple lista ordenada. Una
     forma de resolver este problema es definir una operación que transforma un
     árbol arbitrario en un árbol equilibrado con los mismos elementos. Entonces
     podemos realizar esta transformación después de cada pocas operaciones para
     mantener nuestro conjunto en equilibrio. También hay otras formas de
     resolver este problema, la mayoría de las cuales implican el diseño de
     nuevas estructuras de datos para las cuales la búsqueda y la inserción se
     pueden realizar en pasos @m(Θ (log n)).@n(106) En este árbol todos
     los subárboles izquierdo están vacíos, por lo que no tiene ventaja sobre
     una simple lista ordenada. Una forma de resolver este problema es definir
     una operación que transforma un árbol arbitrario en un árbol equilibrado
     con los mismos elementos. Entonces podemos realizar esta transformación
     después de cada pocas operaciones para mantener nuestro conjunto en
     equilibrio. También hay otras formas de resolver este problema, la mayoría
     de las cuales implican el diseño de nuevas estructuras de datos para las
     cuales la búsqueda y la inserción se pueden realizar en pasos @m(Θ (log
     n)).@n(106) También hay otras formas de resolver este problema, la
     mayoría de las cuales implican el diseño de nuevas estructuras de datos
     para las cuales la búsqueda y la inserción se pueden realizar en pasos @m(Θ
     (log n)).@n(106) También hay otras formas de resolver este
     problema, la mayoría de las cuales implican el diseño de nuevas estructuras
     de datos para las cuales la búsqueda y la inserción se pueden realizar en
     pasos @m(Θ (log n)).@n(106)

#      ..figure > @t(Figure 2.17) Unbalanced tree produced by adjoining 1 through 7
#        in sequence.
     ..figure > @t(Figura 2.17) Árbol desequilibrado producido por secuencias
       adjuntas de 1 a 7.

#        ..art >
#          1
#           \
#            2
#             \
#              4
#               \
#                5
#                 \
#                  6
#                   \
#                    7
#        < art..
       ..art >
         1
          \
           2
            \
             4
              \
               5
                \
                 6
                  \
                   7
       < art..

# @    ..img > img/chap2/Fig2.17a.std.svg
@    ..img > img/chap2/Fig2.17a.std.svg

#      :: @t(Exercise 2.63) :: Each of the following two procedures converts a binary
#         tree to a list.
     :: @t(Ejercicio 2.63) :: Cada uno de los dos procedimientos siguientes
     convierte un árbol binario en una lista.

#         ..src > scheme
#           (define (tree->list-1 tree)
#             (if (null? tree)
#                 '()
#                 (append
#                  (tree->list-1
#                   (left-branch tree))
#                  (cons (entry tree)
#                        (tree->list-1
#                         (right-branch tree))))))
#
#           (define (tree->list-2 tree)
#             (define (copy-to-list tree result-list)
#               (if (null? tree)
#                   result-list
#                   (copy-to-list
#                    (left-branch tree)
#                    (cons (entry tree)
#                          (copy-to-list
#                           (right-branch tree)
#                           result-list)))))
#             (copy-to-list tree '()))
#         < src..
        ..src > scheme
          (define (tree->list-1 tree)
            (if (null? tree)
                '()
                (append
                 (tree->list-1
                  (left-branch tree))
                 (cons (entry tree)
                       (tree->list-1
                        (right-branch tree))))))

          (define (tree->list-2 tree)
            (define (copy-to-list tree result-list)
              (if (null? tree)
                  result-list
                  (copy-to-list
                   (left-branch tree)
                   (cons (entry tree)
                         (copy-to-list
                          (right-branch tree)
                          result-list)))))
            (copy-to-list tree '()))
        < src..

#         - Do the two procedures produce the same result for every tree?  If not,
#           how do the results differ?  What lists do the two procedures produce for
#           the trees in @l(#Figure 2.16)?
        - ¿Los dos procedimientos producen el mismo resultado para cada árbol?
          Si no, ¿cómo difieren los resultados? ¿Qué listas producen los dos
          procedimientos para los árboles de la @l(#Figura 2.16) ?

#         - Do the two procedures have the same order of growth in the number of
#           steps required to convert a balanced tree with @m(n) elements to a list?
#           If not, which one grows more slowly?
        - ¿Los dos procedimientos tienen el mismo orden de crecimiento en el
          número de pasos requeridos para convertir un árbol equilibrado con
          @m(n) elementos en una lista? Si no, ¿cuál crece más lentamente?

#      :: @t(Exercise 2.64) :: The following procedure @c(list->tree) converts an
#         ordered list to a balanced binary tree. The helper procedure
#         @c(partial-tree) takes as arguments an integer @m(n) and list of at least
#         @m(n) elements and constructs a balanced tree containing the first @m(n)
#         elements of the list. The result returned by @c(partial-tree) is a pair
#         (formed with @c(cons)) whose @c(car) is the constructed tree and whose
#         @c(cdr) is the list of elements not included in the tree.
     :: @t(Ejercicio 2.64) :: El siguiente procedimiento @c(list->tree)
        convierte una lista ordenada en un árbol binario equilibrado. El
        procedimiento auxiliar @c(partial-tree) toma como argumentos un entero
        @m(n) y una lista de al menos @m(n) elementos y construye un árbol
        equilibrado que contiene los primeros @m(n) elementos de la lista. El
        resultado devuelto por @c(partial-tree) es un par (formado con @c(cons))
        cuyo @c(car) es el árbol construido y cuya @c(cdr) es la lista de
        elementos no incluidos en el árbol.

#         ..src > scheme
#           (define (list->tree elements)
#             (car (partial-tree
#                   elements (length elements))))
#
#           (define (partial-tree elts n)
#             (if (= n 0)
#                 (cons '() elts)
#                 (let ((left-size
#                        (quotient (- n 1) 2)))
#                   (let ((left-result
#                          (partial-tree
#                           elts left-size)))
#                     (let ((left-tree
#                            (car left-result))
#                           (non-left-elts
#                            (cdr left-result))
#                           (right-size
#                            (- n (+ left-size 1))))
#                       (let ((this-entry
#                              (car non-left-elts))
#                             (right-result
#                              (partial-tree
#                               (cdr non-left-elts)
#                               right-size)))
#                         (let ((right-tree
#                                (car right-result))
#                               (remaining-elts
#                                (cdr right-result)))
#                           (cons (make-tree this-entry
#                                            left-tree
#                                            right-tree)
#                                 remaining-elts))))))))
#         < src..
        ..src > scheme
          (define (list->tree elements)
            (car (partial-tree
                  elements (length elements))))

          (define (partial-tree elts n)
            (if (= n 0)
                (cons '() elts)
                (let ((left-size
                       (quotient (- n 1) 2)))
                  (let ((left-result
                         (partial-tree
                          elts left-size)))
                    (let ((left-tree
                           (car left-result))
                          (non-left-elts
                           (cdr left-result))
                          (right-size
                           (- n (+ left-size 1))))
                      (let ((this-entry
                             (car non-left-elts))
                            (right-result
                             (partial-tree
                              (cdr non-left-elts)
                              right-size)))
                        (let ((right-tree
                               (car right-result))
                              (remaining-elts
                               (cdr right-result)))
                          (cons (make-tree this-entry
                                           left-tree
                                           right-tree)
                                remaining-elts))))))))
        < src..

#         - Write a short paragraph explaining as clearly as you can how
#           @c(partial-tree) works. Draw the tree produced by @c(list->tree) for the
#           list @c[(1 3 5 7 9 11)].
        - Escribe un párrafo corto explicando tan claramente como puedas cómo
          @c(partial-tree) funciona. Dibuja el árbol producido por
          @c(list->tree) para la lista @c[(1 3 5 7 9 11)].

#         - What is the order of growth in the number of steps required by
#           @c(list->tree) to convert a list of @m(n) elements?
        - ¿Cuál es el orden de crecimiento en el número de pasos requeridos
          @c(list->tree) para convertir una lista de @m(n) elementos?

#      :: @t(Exercise 2.65) :: Use the results of @l(#Exercise 2.63)
#         and @l(#Exercise 2.64) to give @m[Θ(n)] implementations of
#         @c(union-set) and @c(intersection-set) for sets implemented as (balanced)
#         binary trees.@n(107)
     :: @t(Ejercicio 2.65) :: Utilice los resultados del
        @l(#Ejercicio 2.63) y del @l(#Ejercicio
        2.64) para dar @m[Θ(n)] implementaciones de @c(union-set) y
        @c(intersection-set) para conjuntos implementados como árboles binarios
        (balanceados).@n(107)

# **** Sets and information retrieval
**** Conjuntos y recuperación de información

#      We have examined options for using lists to represent sets and have seen how
#      the choice of representation for a data object can have a large impact on the
#      performance of the programs that use the data. Another reason for
#      concentrating on sets is that the techniques discussed here appear again and
#      again in applications involving information retrieval.
     Hemos examinado las opciones para el uso de listas para representar
     conjuntos y hemos visto cómo la elección de la representación de un objeto
     de datos puede tener un gran impacto en el rendimiento de los programas que
     utilizan los datos. Otra razón para concentrarse en conjuntos es que las
     técnicas discutidas aquí aparecen una y otra vez en aplicaciones que
     implican recuperación de información.

#      Consider a data base containing a large number of individual records, such as
#      the personnel files for a company or the transactions in an accounting system.
#      A typical data-management system spends a large amount of time accessing or
#      modifying the data in the records and therefore requires an efficient method
#      for accessing records. This is done by identifying a part of each record to
#      serve as an identifying @e(key). A key can be anything that uniquely
#      identifies the record. For a personnel file, it might be an employee's ID
#      number. For an accounting system, it might be a transaction number. Whatever
#      the key is, when we define the record as a data structure we should include a
#      @c(key) selector procedure that retrieves the key associated with a given
#      record.
     Considere una base de datos que contenga un gran número de registros
     individuales, como los archivos de personal para una empresa o las
     transacciones en un sistema de contabilidad. Un sistema de gestión de datos
     típico invierte una gran cantidad de tiempo en acceder o modificar los
     datos de los registros y, por lo tanto, requiere un método eficiente para
     acceder a los registros. Esto se hace mediante la identificación de una
     parte de cada registro para servir como una @e(clave de)
     identificación. Una clave puede ser cualquier cosa que identifique de
     manera única el registro. Para un archivo de personal, puede ser el número
     de identificación de un empleado. Para un sistema contable, puede ser un
     número de transacción. Sea cual sea la clave, cuando definamos el registro
     como una estructura de datos debemos incluir un procedimiento @c(key)
     selector que recupera la clave asociada a un registro dado.

#      Now we represent the data base as a set of records. To locate the record with
#      a given key we use a procedure @c(lookup), which takes as arguments a key and
#      a data base and which returns the record that has that key, or false if there
#      is no such record. @c(Lookup) is implemented in almost the same way as
#      @c(element-of-set?). For example, if the set of records is implemented as an
#      unordered list, we could use
     Ahora representamos la base de datos como un conjunto de registros. Para
     localizar el registro con una clave dada usamos un procedimiento
     @c(lookup), que toma como argumentos una clave y una base de datos y que
     devuelve el registro que tiene esa clave, o false si no hay tal
     registro. @c(Lookup) Se implementa casi de la misma manera que
     @c(element-of-set?). Por ejemplo, si el conjunto de registros se implementa
     como una lista desordenada, podríamos usar

#      ..src > scheme
#        (define (lookup given-key set-of-records)
#          (cond ((null? set-of-records) false)
#                ((equal? given-key
#                         (key (car set-of-records)))
#                 (car set-of-records))
#                (else
#                 (lookup given-key
#                         (cdr set-of-records)))))
#      < src..
     ..src > scheme
       (define (lookup given-key set-of-records)
         (cond ((null? set-of-records) false)
               ((equal? given-key
                        (key (car set-of-records)))
                (car set-of-records))
               (else
                (lookup given-key
                        (cdr set-of-records)))))
     < src..

#      Of course, there are better ways to represent large sets than as unordered
#      lists. Information-retrieval systems in which records have to be @"(randomly
#      accessed) are typically implemented by a tree-based method, such as the
#      binary-tree representation discussed previously. In designing such a system
#      the methodology of data abstraction can be a great help. The designer can
#      create an initial implementation using a simple, straightforward
#      representation such as unordered lists. This will be unsuitable for the
#      eventual system, but it can be useful in providing a @"(quick and dirty) data
#      base with which to test the rest of the system. Later on, the data
#      representation can be modified to be more sophisticated. If the data base is
#      accessed in terms of abstract selectors and constructors, this change in
#      representation will not require any changes to the rest of the system.
     Por supuesto, hay mejores maneras de representar grandes conjuntos que como
     listas desordenadas. Los sistemas de recuperación de información en los que
     los registros tienen que ser @"(accedidos al azar) se implementan
     típicamente mediante un método basado en árboles, como la representación en
     árbol binario discutida anteriormente. Al diseñar un sistema de este tipo,
     la metodología de la abstracción de datos puede ser de gran ayuda. El
     diseñador puede crear una implementación inicial utilizando una
     representación simple y directa, como listas no ordenadas. Esto no será
     adecuado para el sistema eventual, pero puede ser útil para proporcionar
     una base de datos @"(rápida y sucia) con la que probar el resto del
     sistema. Posteriormente, la representación de datos puede modificarse para
     ser más sofisticada. Si se accede a la base de datos en términos de
     selectores abstractos y constructores,

#      :: @t(Exercise 2.66) :: Implement the @c(lookup) procedure for the case where
#         the set of records is structured as a binary tree, ordered by the numerical
#         values of the keys.
     :: @t(Ejercicio 2.66) :: Implementar el procedimiento @c(lookup) para el
        caso donde el conjunto de registros está estructurado como un árbol
        binario, ordenado por los valores numéricos de las claves.

# *** 2.3.4 <> Example: Huffman Encoding Trees
*** 2.3.4 <> Ejemplo: Huffman Encoding Trees

#     This section provides practice in the use of list structure and data
#     abstraction to manipulate sets and trees. The application is to methods for
#     representing data as sequences of ones and zeros (bits). For example, the
#     ASCII standard code used to represent text in computers encodes each character
#     as a sequence of seven bits. Using seven bits allows us to distinguish @m(2⁷),
#     or 128, possible different characters. In general, if we want to distinguish
#     @m(n) different symbols, we will need to use @m(log₂ₙ) bits per symbol. If all
#     our messages are made up of the eight symbols A, B, C, D, E, F, G, and H, we
#     can choose a code with three bits per character, for example
    Esta sección proporciona práctica en el uso de la estructura de la lista y
    la abstracción de datos para manipular conjuntos y árboles. La aplicación se
    refiere a métodos para representar datos como secuencias de unos y ceros
    (bits). Por ejemplo, el código ASCII estándar utilizado para representar
    texto en computadoras codifica cada carácter como una secuencia de siete
    bits. El uso de siete bits nos permite distinguir @m(2⁷), o 128, posibles
    caracteres diferentes. En general, si queremos distinguir @m(n) símbolos
    diferentes, necesitaremos usar @m(log2ₙ) bits por símbolo. Si todos nuestros
    mensajes están formados por los ocho símbolos A, B, C, D, E, F, G y H,
    podemos elegir un código con tres bits por carácter, por ejemplo

#     ..example >
#       A 000  C 010  E 100  G 110
#       B 001  D 011  F 101  H 111
#     < example..
    ..example >
      A 000  C 010  E 100  G 110
      B 001  D 011  F 101  H 111
    < example..

#     With this code, the message
    Con este código, el mensaje

#     ..example >
#       BACADAEAFABBAAAGAH
#     < example..
    ..example >
      BACADAEAFABBAAAGAH
    < example..

#     is encoded as the string of 54 bits
    Se codifica como la cadena de 54 bits

#     ..example >
#       001000010000011000100000101
#       000001001000000000110000111
#     < example..
    ..example >
      001000010000011000100000101
      000001001000000000110000111
    < example..

#     Codes such as ASCII and the A-through-H code above are known as
#     @e(fixed-length) codes, because they represent each symbol in the message with
#     the same number of bits. It is sometimes advantageous to use
#     @e(variable-length) codes, in which different symbols may be represented by
#     different numbers of bits. For example, Morse code does not use the same
#     number of dots and dashes for each letter of the alphabet. In particular, E,
#     the most frequent letter, is represented by a single dot. In general, if our
#     messages are such that some symbols appear very frequently and some very
#     rarely, we can encode data more efficiently (i.e., using fewer bits per
#     message) if we assign shorter codes to the frequent symbols. Consider the
#     following alternative code for the letters A through H:
    Códigos como ASCII y el código A-through-H anterior son conocidos como
    códigos de @e(longitud fija), ya que representan cada símbolo en el mensaje
    con el mismo número de bits. A veces es ventajoso utilizar códigos de
    @e(longitud variable), en los que diferentes símbolos pueden ser
    representados por diferentes números de bits. Por ejemplo, el código Morse
    no utiliza el mismo número de puntos y guiones para cada letra del
    alfabeto. En particular, E, la letra más frecuente, está representada por un
    solo punto. En general, si nuestros mensajes son tales que algunos símbolos
    aparecen con mucha frecuencia y algunos muy raramente, podemos codificar
    datos de manera más eficiente (es decir, usar menos bits por mensaje) si
    asignamos códigos más cortos a los símbolos frecuentes. Considere el
    siguiente código alternativo para las letras A a H:

#     ..example >
#       A 0    C 1010  E 1100  G 1110
#       B 100  D 1011  F 1101  H 1111
#     < example..
    ..example >
      A 0    C 1010  E 1100  G 1110
      B 100  D 1011  F 1101  H 1111
    < example..

#     With this code, the same message as above is encoded as the string
    Con este código, el mismo mensaje de arriba está codificado como la cadena

#     ..example >
#       100010100101101100011
#       010100100000111001111
#     < example..
    ..example >
      100010100101101100011
      010100100000111001111
    < example..

#     This string contains 42 bits, so it saves more than 20% in space in comparison
#     with the fixed-length code shown above.
    Esta cadena contiene 42 bits, por lo que ahorra más del 20% en el espacio en
    comparación con el código de longitud fija mostrado anteriormente.

#     One of the difficulties of using a variable-length code is knowing when you
#     have reached the end of a symbol in reading a sequence of zeros and ones.
#     Morse code solves this problem by using a special @e(separator code) (in this
#     case, a pause) after the sequence of dots and dashes for each letter.  Another
#     solution is to design the code in such a way that no complete code for any
#     symbol is the beginning (or @e(prefix)) of the code for another symbol. Such a
#     code is called a @e(prefix code). In the example above, A is encoded by 0 and
#     B is encoded by 100, so no other symbol can have a code that begins with 0 or
#     with 100.
    Una de las dificultades de usar un código de longitud variable es saber
    cuándo ha llegado al final de un símbolo al leer una secuencia de ceros y
    unos. El código Morse resuelve este problema usando un @e(código separador)
    especial (en este caso, una pausa) después de la secuencia de puntos y
    guiones para cada letra. Otra solución es diseñar el código de tal manera
    que ningún código completo para ningún símbolo sea el comienzo (o
    @e(prefijo) ) del código para otro símbolo. Este código se denomina
    @e(código de prefijo). En el ejemplo anterior, A está codificado por 0 y B
    está codificado por 100, por lo que ningún otro símbolo puede tener un
    código que comience con 0 o con 100.

#     In general, we can attain significant savings if we use variable-length prefix
#     codes that take advantage of the relative frequencies of the symbols in the
#     messages to be encoded. One particular scheme for doing this is called the
#     Huffman encoding method, after its discoverer, David Huffman. A Huffman code
#     can be represented as a binary tree whose leaves are the symbols that are
#     encoded. At each non-leaf node of the tree there is a set containing all the
#     symbols in the leaves that lie below the node. In addition, each symbol at a
#     leaf is assigned a weight (which is its relative frequency), and each non-leaf
#     node contains a weight that is the sum of all the weights of the leaves lying
#     below it. The weights are not used in the encoding or the decoding process.
#     We will see below how they are used to help construct the tree.
    En general, podemos obtener ahorros significativos si usamos códigos de
    prefijo de longitud variable que aprovechan las frecuencias relativas de los
    símbolos en los mensajes a codificar. Un esquema particular para hacer esto
    se llama el método de codificación de Huffman, después de su descubridor,
    David Huffman. Un código Huffman puede representarse como un árbol binario
    cuyas hojas son los símbolos que están codificados. En cada nodo no-hoja del
    árbol hay un conjunto que contiene todos los símbolos en las hojas que se
    encuentran debajo del nodo. Además, a cada símbolo de una hoja se le asigna
    un peso (que es su frecuencia relativa), y cada nodo no hoja contiene un
    peso que es la suma de todos los pesos de las hojas que se encuentran por
    debajo de ella. Los pesos no se utilizan en la codificación o el proceso de
    decodificación. Veremos a continuación cómo se utilizan para ayudar a
    construir el árbol.

#     @l(#Figure 2.18) shows the Huffman tree for the A-through-H code given above.
#     The weights at the leaves indicate that the tree was designed for messages in
#     which A appears with relative frequency 8, B with relative frequency 3, and
#     the other letters each with relative frequency 1.
    @l(#Figura 2.18) muestra el árbol de Huffman para el código
    A-through-H dado anteriormente. Los pesos en las hojas indican que el árbol
    fue diseñado para mensajes en los que A aparece con frecuencia relativa 8, B
    con frecuencia relativa 3 y las otras letras con frecuencia relativa 1.

#     ..figure > @t(Figure 2.18) A Huffman encoding tree.
    ..figure > @t(Figura 2.18) Un árbol de codificación Huffman.

#       ..art >
#                    {A B C D E F G H} 17
#                             *
#                            / \
#                           /   \
#                         A 8    *  {B C D E F G H} 9
#                     __________/ \_____________
#                    /                          \
#         {B C D} 5 *                            * {E F G H} 4
#                  / \                       ___/ \___
#                 /   \                     /         \
#               B 3    * {C D} 2   {E F} 2 *           * {G H} 2
#                     / \                 / \         / \
#                    /   \               /   \       /   \
#                  C 1   D 1           E 1   F 1   G 1   H 1
#       < art..
      ..art >
                   {A B C D E F G H} 17
                            *
                           / \
                          /   \
                        A 8    *  {B C D E F G H} 9
                    __________/ \_____________
                   /                          \
        {B C D} 5 *                            * {E F G H} 4
                 / \                       ___/ \___
                /   \                     /         \
              B 3    * {C D} 2   {E F} 2 *           * {G H} 2
                    / \                 / \         / \
                   /   \               /   \       /   \
                 C 1   D 1           E 1   F 1   G 1   H 1
      < art..

# @   ..img > img/chap2/Fig2.18a.std.svg
@   ..img > img/chap2/Fig2.18a.std.svg

#     Given a Huffman tree, we can find the encoding of any symbol by starting at
#     the root and moving down until we reach the leaf that holds the symbol. Each
#     time we move down a left branch we add a 0 to the code, and each time we move
#     down a right branch we add a 1. (We decide which branch to follow by testing
#     to see which branch either is the leaf node for the symbol or contains the
#     symbol in its set.)  For example, starting from the root of the tree in
#     @l(#Figure 2.18), we arrive at the leaf for D by following a right branch,
#     then a left branch, then a right branch, then a right branch; hence, the code
#     for D is 1011.
    Dado un árbol de Huffman, podemos encontrar la codificación de cualquier
    símbolo comenzando en la raíz y moviéndonos hacia abajo hasta llegar a la
    hoja que contiene el símbolo. Cada vez que nos movemos por una rama
    izquierda agregamos un 0 al código, y cada vez que nos movemos por una rama
    derecha añadimos un 1. (Decidimos qué rama seguir por probar para ver qué
    rama es el nodo de la hoja para el Por ejemplo, partiendo de la raíz del
    árbol de la @l(#Figura 2.18), llegamos a la hoja para D
    siguiendo una rama derecha, luego una rama izquierda, luego una rama
    derecha, luego una rama derecha rama; Por lo tanto, el código para D
    es 1011.

#     To decode a bit sequence using a Huffman tree, we begin at the root and use
#     the successive zeros and ones of the bit sequence to determine whether to move
#     down the left or the right branch. Each time we come to a leaf, we have
#     generated a new symbol in the message, at which point we start over from the
#     root of the tree to find the next symbol. For example, suppose we are given
#     the tree above and the sequence 10001010. Starting at the root, we move down
#     the right branch, (since the first bit of the string is 1), then down the left
#     branch (since the second bit is 0), then down the left branch (since the third
#     bit is also 0). This brings us to the leaf for B, so the first symbol of the
#     decoded message is B. Now we start again at the root, and we make a left move
#     because the next bit in the string is 0. This brings us to the leaf for
#     A. Then we start again at the root with the rest of the string 1010, so we
#     move right, left, right, left and reach C. Thus, the entire message is BAC.
    Para decodificar una secuencia de bits utilizando un árbol de Huffman,
    comenzamos en la raíz y usamos los ceros sucesivos y los de la secuencia de
    bits para determinar si nos movemos hacia abajo o hacia la izquierda. Cada
    vez que llegamos a una hoja, hemos generado un nuevo símbolo en el mensaje,
    momento en el que empezamos de nuevo desde la raíz del árbol para encontrar
    el siguiente símbolo. Por ejemplo, supongamos que se nos da el árbol arriba
    y la secuencia 10001010. Empezando por la raíz, nos movemos hacia abajo por
    la rama derecha, ya que el primer bit de la cadena es 1, luego por la rama
    izquierda (ya que el segundo bit es 0), luego hacia abajo la rama izquierda
    (ya que el tercer bit es también 0). Esto nos lleva a la hoja de B, por lo
    que el primer símbolo del mensaje descodificado es B. Ahora comenzamos de
    nuevo en la raíz, y hacemos un movimiento a la izquierda porque el siguiente
    bit en la cadena es 0. Esto nos lleva a la hoja para.

# **** Generating Huffman trees
**** Generando árboles Huffman

#      Given an @"(alphabet) of symbols and their relative frequencies, how do we
#      construct the @"(best) code?  (In other words, which tree will encode messages
#      with the fewest bits?)  Huffman gave an algorithm for doing this and showed
#      that the resulting code is indeed the best variable-length code for messages
#      where the relative frequency of the symbols matches the frequencies with which
#      the code was constructed. We will not prove this optimality of Huffman codes
#      here, but we will show how Huffman trees are constructed.@n(108)
     Dado un @"(alfabeto) de símbolos y sus frecuencias relativas, ¿cómo
     construimos el @"(mejor) código? (En otras palabras, ¿qué árbol codificará
     los mensajes con menos bits?) Huffman dio un algoritmo para hacer esto y
     mostró que el código resultante es de hecho el mejor código de longitud
     variable para los mensajes donde la frecuencia relativa de los símbolos
     coincide con las frecuencias con Que el código fue construido. No
     probaremos esta optimalidad de los códigos de Huffman aquí, pero
     mostraremos cómo se construyen los árboles Huffman.@n(108)

#      The algorithm for generating a Huffman tree is very simple. The idea is to
#      arrange the tree so that the symbols with the lowest frequency appear farthest
#      away from the root. Begin with the set of leaf nodes, containing symbols and
#      their frequencies, as determined by the initial data from which the code is to
#      be constructed. Now find two leaves with the lowest weights and merge them to
#      produce a node that has these two nodes as its left and right branches. The
#      weight of the new node is the sum of the two weights. Remove the two leaves
#      from the original set and replace them by this new node. Now continue this
#      process. At each step, merge two nodes with the smallest weights, removing
#      them from the set and replacing them with a node that has these two as its
#      left and right branches. The process stops when there is only one node left,
#      which is the root of the entire tree. Here is how the Huffman tree of
#      @l(#Figure 2.18) was generated:
     El algoritmo para generar un árbol Huffman es muy simple. La idea es
     organizar el árbol para que los símbolos con la frecuencia más baja
     aparezcan más alejados de la raíz. Comienza con el conjunto de nodos de
     hojas, que contienen símbolos y sus frecuencias, según lo determinado por
     los datos iniciales a partir de los cuales se va a construir el
     código. Ahora encuentre dos hojas con los pesos más bajos y fusionarlos
     para producir un nodo que tiene estos dos nodos como sus ramas izquierda y
     derecha. El peso del nuevo nodo es la suma de los dos pesos. Retire las dos
     hojas del conjunto original y sustitúyalas por este nuevo nodo. Ahora
     continúa este proceso. En cada paso, se fusionan dos nodos con los pesos
     más pequeños, quitándolos del conjunto y reemplazándolos con un nodo que
     tiene estos dos como sus ramas izquierda y derecha. El proceso se detiene
     cuando sólo queda un nodo, Que es la raíz de todo el árbol. He aquí cómo se
     generó el árbol Huffman de la @l(#Figura 2.18) :

#      ..example >
#        Initial {(A 8) (B 3) (C 1) (D 1)
#        leaves   (E 1) (F 1) (G 1) (H 1)}
#
#        Merge   {(A 8) (B 3) ({C D} 2)
#                 (E 1) (F 1) (G 1) (H 1)}
#
#        Merge   {(A 8) (B 3) ({C D} 2)
#                 ({E F} 2) (G 1) (H 1)}
#
#        Merge   {(A 8) (B 3) ({C D} 2)
#                 ({E F} 2) ({G H} 2)}
#
#        Merge   {(A 8) (B 3) ({C D} 2)
#                 ({E F G H} 4)}
#
#        Merge   {(A 8) ({B C D} 5)
#                 ({E F G H} 4)}
#
#        Merge   {(A 8) ({B C D E F G H} 9)}
#
#        Final   {({A B C D E F G H} 17)}
#        merge
#      < example..
     ..example >
       Initial {(A 8) (B 3) (C 1) (D 1)
       leaves   (E 1) (F 1) (G 1) (H 1)}

       Merge   {(A 8) (B 3) ({C D} 2)
                (E 1) (F 1) (G 1) (H 1)}

       Merge   {(A 8) (B 3) ({C D} 2)
                ({E F} 2) (G 1) (H 1)}

       Merge   {(A 8) (B 3) ({C D} 2)
                ({E F} 2) ({G H} 2)}

       Merge   {(A 8) (B 3) ({C D} 2)
                ({E F G H} 4)}

       Merge   {(A 8) ({B C D} 5)
                ({E F G H} 4)}

       Merge   {(A 8) ({B C D E F G H} 9)}

       Final   {({A B C D E F G H} 17)}
       merge
     < example..

#      The algorithm does not always specify a unique tree, because there may not be
#      unique smallest-weight nodes at each step. Also, the choice of the order in
#      which the two nodes are merged (i.e., which will be the right branch and which
#      will be the left branch) is arbitrary.
     El algoritmo no siempre especifica un árbol único, ya que puede no haber
     nodos únicos de menor peso en cada paso. Además, la elección del orden en
     el que se fusionan los dos nodos (es decir, que será la rama derecha y que
     será la rama izquierda) es arbitraria.

# **** Representing Huffman trees
**** Representando árboles de Huffman

#      In the exercises below we will work with a system that uses Huffman trees to
#      encode and decode messages and generates Huffman trees according to the
#      algorithm outlined above. We will begin by discussing how trees are
#      represented.
     En los ejercicios siguientes trabajaremos con un sistema que usa árboles
     Huffman para codificar y decodificar mensajes y genera árboles Huffman de
     acuerdo al algoritmo descrito anteriormente. Empezaremos por discutir cómo
     se representan los árboles.

#      Leaves of the tree are represented by a list consisting of the symbol
#      @c(leaf), the symbol at the leaf, and the weight:
     Las hojas del árbol están representadas por una lista que consiste en el
     símbolo @c(leaf), el símbolo en la hoja, y el peso:

#      ..src > scheme
#        (define (make-leaf symbol weight)
#          (list 'leaf symbol weight))
#        (define (leaf? object)
#          (eq? (car object) 'leaf))
#        (define (symbol-leaf x) (cadr x))
#        (define (weight-leaf x) (caddr x))
#      < src..
     ..src > scheme
       (define (make-leaf symbol weight)
         (list 'leaf symbol weight))
       (define (leaf? object)
         (eq? (car object) 'leaf))
       (define (symbol-leaf x) (cadr x))
       (define (weight-leaf x) (caddr x))
     < src..

#      A general tree will be a list of a left branch, a right branch, a set of
#      symbols, and a weight. The set of symbols will be simply a list of the
#      symbols, rather than some more sophisticated set representation. When we make
#      a tree by merging two nodes, we obtain the weight of the tree as the sum of
#      the weights of the nodes, and the set of symbols as the union of the sets of
#      symbols for the nodes. Since our symbol sets are represented as lists, we can
#      form the union by using the @c(append) procedure we defined in section @l(#2.2.1):
     Un árbol general será una lista de una rama izquierda, una rama derecha, un
     conjunto de símbolos y un peso. El conjunto de símbolos será simplemente
     una lista de los símbolos, en lugar de una representación de conjunto más
     sofisticada. Cuando hacemos un árbol mediante la fusión de dos nodos,
     obtenemos el peso del árbol como la suma de los pesos de los nodos, y el
     conjunto de símbolos como la unión de los conjuntos de símbolos para los
     nodos. Dado que nuestros conjuntos de símbolos están representados como
     listas, podemos formar la unión usando el procedimiento @c(append) que
     definimos en la seccion @l(#2.2.1) :

#      ..src > scheme
#        (define (make-code-tree left right)
#          (list left
#                right
#                (append (symbols left)
#                        (symbols right))
#                (+ (weight left) (weight right))))
#      < src..
     ..src > scheme
       (define (make-code-tree left right)
         (list left
               right
               (append (symbols left)
                       (symbols right))
               (+ (weight left) (weight right))))
     < src..

#      If we make a tree in this way, we have the following selectors:
     Si hacemos un árbol de esta manera, tenemos los siguientes selectores:

#      ..src > scheme
#        (define (left-branch tree) (car tree))
#        (define (right-branch tree) (cadr tree))
#
#        (define (symbols tree)
#          (if (leaf? tree)
#              (list (symbol-leaf tree))
#              (caddr tree)))
#
#        (define (weight tree)
#          (if (leaf? tree)
#              (weight-leaf tree)
#              (cadddr tree)))
#      < src..
     ..src > scheme
       (define (left-branch tree) (car tree))
       (define (right-branch tree) (cadr tree))

       (define (symbols tree)
         (if (leaf? tree)
             (list (symbol-leaf tree))
             (caddr tree)))

       (define (weight tree)
         (if (leaf? tree)
             (weight-leaf tree)
             (cadddr tree)))
     < src..

#      The procedures @c(symbols) and @c(weight) must do something slightly different
#      depending on whether they are called with a leaf or a general tree.  These are
#      simple examples of @e(generic procedures) (procedures that can handle more
#      than one kind of data), which we will have much more to say about in section @l(#2.4)
#      and @l(#2.5).
     Los procedimientos @c(symbols) y @c(weight) deben hacer algo ligeramente
     diferente dependiendo de si se llaman con una hoja o un árbol
     general. Estos son simples ejemplos de @e(procedimientos genéricos)
     (procedimientos que pueden manejar más de un tipo de datos), que tendremos
     mucho más que decir en la seccion @l(#2.4) y @l(#2.5).

# **** The decoding procedure
**** El procedimiento de decodificación

#      The following procedure implements the decoding algorithm. It takes as
#      arguments a list of zeros and ones, together with a Huffman tree.
     El siguiente procedimiento implementa el algoritmo de decodificación. Toma
     como argumentos una lista de ceros y unos, junto con un árbol Huffman.

#      ..src > scheme
#        (define (decode bits tree)
#          (define (decode-1 bits current-branch)
#            (if (null? bits)
#                '()
#                (let ((next-branch
#                       (choose-branch
#                        (car bits)
#                        current-branch)))
#                  (if (leaf? next-branch)
#                      (cons
#                       (symbol-leaf next-branch)
#                       (decode-1 (cdr bits) tree))
#                      (decode-1 (cdr bits)
#                                next-branch)))))
#          (decode-1 bits tree))
#
#        (define (choose-branch bit branch)
#          (cond ((= bit 0) (left-branch branch))
#                ((= bit 1) (right-branch branch))
#                (else (error "bad bit:
#                       CHOOSE-BRANCH" bit))))
#      < src..
     ..src > scheme
       (define (decode bits tree)
         (define (decode-1 bits current-branch)
           (if (null? bits)
               '()
               (let ((next-branch
                      (choose-branch
                       (car bits)
                       current-branch)))
                 (if (leaf? next-branch)
                     (cons
                      (symbol-leaf next-branch)
                      (decode-1 (cdr bits) tree))
                     (decode-1 (cdr bits)
                               next-branch)))))
         (decode-1 bits tree))

       (define (choose-branch bit branch)
         (cond ((= bit 0) (left-branch branch))
               ((= bit 1) (right-branch branch))
               (else (error "bad bit:
                      CHOOSE-BRANCH" bit))))
     < src..

#      The procedure @c(decode-1) takes two arguments: the list of remaining bits and
#      the current position in the tree. It keeps moving @"(down) the tree, choosing
#      a left or a right branch according to whether the next bit in the list is a
#      zero or a one. (This is done with the procedure @c(choose-branch).)  When it
#      reaches a leaf, it returns the symbol at that leaf as the next symbol in the
#      message by @c(cons)ing it onto the result of decoding the rest of the message,
#      starting at the root of the tree. Note the error check in the final clause of
#      @c(choose-branch), which complains if the procedure finds something other than
#      a zero or a one in the input data.
     El procedimiento @c(decode-1) toma dos argumentos: la lista de bits
     restantes y la posición actual en el árbol. Sigue moviéndose @"(por) el
     árbol, eligiendo una rama izquierda o una rama derecha según si el
     siguiente bit de la lista es cero o uno. (Esto se hace con el procedimiento
     @c(choose-branch).) Cuando alcanza una hoja, devuelve el símbolo en esa
     hoja como el siguiente símbolo en el mensaje por el @c(cons) ing en el
     resultado de descodificar el resto del mensaje, comenzando en la raíz del
     árbol. Observe la comprobación de error en la cláusula final de
     @c(choose-branch), que se queja si el procedimiento encuentra algo distinto
     de cero o uno en los datos de entrada.

# **** Sets of weighted elements
**** Conjuntos de elementos ponderados

#      In our representation of trees, each non-leaf node contains a set of symbols,
#      which we have represented as a simple list. However, the tree-generating
#      algorithm discussed above requires that we also work with sets of leaves and
#      trees, successively merging the two smallest items. Since we will be required
#      to repeatedly find the smallest item in a set, it is convenient to use an
#      ordered representation for this kind of set.
     En nuestra representación de árboles, cada nodo no-hoja contiene un
     conjunto de símbolos, que hemos representado como una simple lista. Sin
     embargo, el algoritmo de generación de árboles discutido anteriormente
     requiere que también trabajemos con conjuntos de hojas y árboles,
     fusionando sucesivamente los dos elementos más pequeños. Puesto que
     tendremos que encontrar repetidamente el elemento más pequeño en un
     conjunto, es conveniente usar una representación ordenada para este tipo de
     conjunto.

#      We will represent a set of leaves and trees as a list of elements, arranged in
#      increasing order of weight. The following @c(adjoin-set) procedure for
#      constructing sets is similar to the one described in @l(#Exercise 2.61);
#      however, items are compared by their weights, and the element being added to
#      the set is never already in it.
     Vamos a representar un conjunto de hojas y árboles como una lista de
     elementos, dispuestos en orden creciente de peso. El siguiente
     procedimiento @c(adjoin-set) para construir conjuntos es similar al
     descrito en el @l(#Ejercicio 2.61) ; Sin embargo, los
     elementos se comparan por sus pesos, y el elemento que se agrega al
     conjunto nunca está ya en él.

#      ..src > scheme
#        (define (adjoin-set x set)
#          (cond ((null? set) (list x))
#                ((< (weight x) (weight (car set)))
#                 (cons x set))
#                (else
#                 (cons (car set)
#                       (adjoin-set x (cdr set))))))
#      < src..
     ..src > scheme
       (define (adjoin-set x set)
         (cond ((null? set) (list x))
               ((< (weight x) (weight (car set)))
                (cons x set))
               (else
                (cons (car set)
                      (adjoin-set x (cdr set))))))
     < src..

#      The following procedure takes a list of symbol-frequency pairs such as
#      @c[((A 4) (B 2) (C 1) (D 1))] and constructs an initial ordered set of leaves,
#      ready to be merged according to the Huffman algorithm:
     El siguiente procedimiento toma una lista de pares de frecuencia de
     símbolos como @c[((A 4) (B 2) (C 1) (D 1))] y construye un conjunto
     ordenado inicial de hojas, listo para ser combinado de acuerdo con el
     algoritmo de Huffman:

#      ..src > scheme
#        (define (make-leaf-set pairs)
#          (if (null? pairs)
#              '()
#              (let ((pair (car pairs)))
#                (adjoin-set
#                 (make-leaf (car pair)    ; symbol
#                            (cadr pair))  ; frequency
#                 (make-leaf-set (cdr pairs))))))
#      < src..
     ..src > scheme
       (define (make-leaf-set pairs)
         (if (null? pairs)
             '()
             (let ((pair (car pairs)))
               (adjoin-set
                (make-leaf (car pair)    ; symbol
                           (cadr pair))  ; frequency
                (make-leaf-set (cdr pairs))))))
     < src..

#      :: @t(Exercise 2.67) :: Define an encoding tree and a sample message:
     :: @t(Ejercicio 2.67) :: Definir un árbol de codificación y un ejemplo de
     mensaje:

#         ..src > scheme
#           (define sample-tree
#             (make-code-tree
#              (make-leaf 'A 4)
#              (make-code-tree
#               (make-leaf 'B 2)
#               (make-code-tree
#                (make-leaf 'D 1)
#                (make-leaf 'C 1)))))
#
#           (define sample-message
#             '(0 1 1 0 0 1 0 1 0 1 1 1 0))
#         < src..
        ..src > scheme
          (define sample-tree
            (make-code-tree
             (make-leaf 'A 4)
             (make-code-tree
              (make-leaf 'B 2)
              (make-code-tree
               (make-leaf 'D 1)
               (make-leaf 'C 1)))))

          (define sample-message
            '(0 1 1 0 0 1 0 1 0 1 1 1 0))
        < src..

#         Use the @c(decode) procedure to decode the message, and give the result.
        Utilice el procedimiento @c(decode) para descodificar el mensaje y dé el
        resultado.

#      :: @t(Exercise 2.68) :: The @c(encode) procedure takes as arguments a message
#         and a tree and produces the list of bits that gives the encoded message.
     :: @t(Ejercicio 2.68) :: El procedimiento @c(encode) toma como argumentos
        un mensaje y un árbol y produce la lista de bits que da el mensaje
        codificado.

#         ..src > scheme
#           (define (encode message tree)
#             (if (null? message)
#                 '()
#                 (append
#                  (encode-symbol (car message)
#                                 tree)
#                  (encode (cdr message) tree))))
#         < src..
        ..src > scheme
          (define (encode message tree)
            (if (null? message)
                '()
                (append
                 (encode-symbol (car message)
                                tree)
                 (encode (cdr message) tree))))
        < src..

#         @c(Encode-symbol) is a procedure, which you must write, that returns the
#         list of bits that encodes a given symbol according to a given tree. You
#         should design @c(encode-symbol) so that it signals an error if the symbol
#         is not in the tree at all. Test your procedure by encoding the result you
#         obtained in @l(#Exercise 2.67) with the sample tree and seeing whether it
#         is the same as the original sample message.
        @c(Encode-symbol) Es un procedimiento, que debe escribir, que devuelve
        la lista de bits que codifica un símbolo dado según un árbol dado. Debe
        diseñar @c(encode-symbol) para que señale un error si el símbolo no está
        en el árbol en absoluto. Pruebe su procedimiento codificando el
        resultado obtenido en el @l(#Ejercicio 2.67) con el árbol
        de muestra y ver si es el mismo que el mensaje de ejemplo original.

#      :: @t(Exercise 2.69) :: The following procedure takes as its argument a list
#         of symbol-frequency pairs (where no symbol appears in more than one pair)
#         and generates a Huffman encoding tree according to the Huffman algorithm.
     :: @t(Ejercicio 2.69) :: El siguiente procedimiento toma como argumento una
        lista de pares de frecuencia de símbolos (donde ningún símbolo aparece
        en más de un par) y genera un árbol de codificación de Huffman de
        acuerdo con el algoritmo de Huffman.

#         ..src > scheme
#           (define (generate-huffman-tree pairs)
#             (successive-merge
#              (make-leaf-set pairs)))
#         < src..
        ..src > scheme
          (define (generate-huffman-tree pairs)
            (successive-merge
             (make-leaf-set pairs)))
        < src..

#         @c(Make-leaf-set) is the procedure given above that transforms the list of
#         pairs into an ordered set of leaves. @c(Successive-merge) is the procedure
#         you must write, using @c(make-code-tree) to successively merge the
#         smallest-weight elements of the set until there is only one element left,
#         which is the desired Huffman tree. (This procedure is slightly tricky, but
#         not really complicated. If you find yourself designing a complex procedure,
#         then you are almost certainly doing something wrong. You can take
#         significant advantage of the fact that we are using an ordered set
#         representation.)
        @c(Make-leaf-set) Es el procedimiento dado anteriormente que transforma
        la lista de pares en un conjunto ordenado de hojas. @c(Successive-merge)
        Es el procedimiento que debe escribir, utilizando @c(make-code-tree)
        para fusionar sucesivamente los elementos de menor peso del conjunto
        hasta que quede solo un elemento, que es el árbol Huffman deseado. (Este
        procedimiento es ligeramente complicado, pero no muy complicado, si te
        encuentras diseñando un procedimiento complejo, entonces casi seguro que
        estás haciendo algo malo. Puedes tomar una ventaja significativa del
        hecho de que estamos usando una representación de conjuntos ordenados).

#      :: @t(Exercise 2.70) :: The following eight-symbol alphabet with associated
#         relative frequencies was designed to efficiently encode the lyrics of 1950s
#         rock songs. (Note that the @"(symbols) of an @"(alphabet) need not be
#         individual letters.)
     :: @t(Ejercicio 2.70) :: El siguiente alfabeto de ocho símbolos con
        frecuencias relativas asociadas fue diseñado para codificar
        eficientemente las letras de canciones de rock de los años 50. (Observe
        que los @"(símbolos) de un @"(alfabeto) no necesitan ser letras
        individuales.)

#         ..example >
#
#           A    2    NA  16
#           BOOM 1    SHA  3
#           GET  2    YIP  9
#           JOB  2    WAH  1
#         < example..
        ..example >

          A    2    NA  16
          BOOM 1    SHA  3
          GET  2    YIP  9
          JOB  2    WAH  1
        < example..

#         Use @c(generate-huffman-tree) (@l(#Exercise 2.69)) to generate a
#         corresponding Huffman tree, and use @c(encode) (@l(#Exercise 2.68)) to
#         encode the following message:
        Utilice @c(generate-huffman-tree) (@l(#Ejercicio 2.69) )
        para generar un árbol Huffman correspondiente, y utilice @c(encode)(
        @l(#Ejercicio 2.68) ) para codificar el siguiente
        mensaje:

#         ..example >
#           Get a job
#           Sha na na na na na na na na
#
#           Get a job
#           Sha na na na na na na na na
#
#           Wah yip yip yip yip
#           yip yip yip yip yip
#           Sha boom
#         < example..
        ..example >
          Get a job
          Sha na na na na na na na na

          Get a job
          Sha na na na na na na na na

          Wah yip yip yip yip
          yip yip yip yip yip
          Sha boom
        < example..

#         How many bits are required for the encoding?  What is the smallest number
#         of bits that would be needed to encode this song if we used a fixed-length
#         code for the eight-symbol alphabet?
        ¿Cuántos bits son necesarios para la codificación? ¿Cuál es el número
        más pequeño de bits que sería necesario para codificar esta canción si
        usamos un código de longitud fija para el alfabeto de ocho símbolos?

#      :: @t(Exercise 2.71) :: Suppose we have a Huffman tree for an alphabet of
#         @m(n) symbols, and that the relative frequencies of the symbols are @m(1,
#         2, 4, …, 2ⁿ⁻¹). Sketch the tree for @m(n=5); for @m(n=10). In such a tree
#         (for general @m(n)) how many bits are required to encode the most frequent
#         symbol?  The least frequent symbol?
     :: @t(Ejercicio 2.71) :: Supongamos que tenemos un árbol de Huffman para un
        alfabeto de @m(n) símbolos y que las frecuencias relativas de los
        símbolos son @m(1, 2, 4, ..., 2ⁿ⁻¹). Dibuje el árbol para @m(n = 5) ;
        Para @m(n = 10). En un árbol de este tipo (para general @m(n) ) ¿cuántos
        bits se requieren para codificar el símbolo más frecuente? ¿El símbolo
        menos frecuente?

#      :: @t(Exercise 2.72) :: Consider the encoding procedure that you designed in
#         @l(#Exercise 2.68). What is the order of growth in the number of steps
#         needed to encode a symbol?  Be sure to include the number of steps needed
#         to search the symbol list at each node encountered. To answer this question
#         in general is difficult. Consider the special case where the relative
#         frequencies of the @m(n) symbols are as described in @l(#Exercise 2.71),
#         and give the order of growth (as a function of @m(n)) of the number of
#         steps needed to encode the most frequent and least frequent symbols in the
#         alphabet.
     :: @t(Ejercicio 2.72) :: Considere el procedimiento de codificación que
     diseñó en el @l(#Ejercicio 2.68). ¿Cuál es el orden de
     crecimiento en el número de pasos necesarios para codificar un símbolo?
     Asegúrese de incluir el número de pasos necesarios para buscar en la lista
     de símbolos en cada nodo encontrado. Responder a esta pregunta en general
     es difícil. Considere el caso especial en que las frecuencias relativas de
     los @m(n) símbolos son como se describe en el @l(#Ejercicio
     2.71) y dé el orden de crecimiento (en función de @m(n) ) del número de
     pasos necesarios para codificar los símbolos más frecuentes y menos
     frecuentes en el alfabeto.

# ** 2.4 <> Multiple Representations for Abstract Data
** 2.4 <> Representaciones Múltiples para Datos Abstractos

#    We have introduced data abstraction, a methodology for structuring systems in
#    such a way that much of a program can be specified independent of the choices
#    involved in implementing the data objects that the program manipulates. For
#    example, we saw in section @l(#2.1.1) how to separate the task of designing a program
#    that uses rational numbers from the task of implementing rational numbers in
#    terms of the computer language's primitive mechanisms for constructing
#    compound data. The key idea was to erect an abstraction barrier -- in this
#    case, the selectors and constructors for rational numbers (@c(make-rat),
#    @c(numer), @c(denom))––that isolates the way rational numbers are used from
#    their underlying representation in terms of list structure. A similar
#    abstraction barrier isolates the details of the procedures that perform
#    rational arithmetic (@c(add-rat), @c(sub-rat), @c(mul-rat), and @c(div-rat))
#    from the @"(higher-level) procedures that use rational numbers. The resulting
#    program has the structure shown in @l(#Figure 2.1).
   Hemos introducido la abstracción de datos, una metodología para estructurar
   sistemas de tal manera que gran parte de un programa puede especificarse
   independientemente de las opciones involucradas en la implementación de los
   objetos de datos que el programa manipula. Por ejemplo, vimos en
   @l(#2.1.1) cómo separar la tarea de diseñar un programa que utiliza
   números racionales de la tarea de implementar números racionales en términos
   de los mecanismos primitivos del lenguaje informático para construir datos
   compuestos. La idea clave era erigir una barrera de abstracción - en este
   caso, los selectores y constructores de números racionales (@c(make-rat),
   @c(numer), @c(denom)) - que aísla el camino números racionales se utilizan de
   su representación subyacente en términos de la estructura de la
   lista. @c(add-rat) Una barrera de abstracción similares aísla los detalles de
   los procedimientos que realizan la aritmética racional (, @c(sub-rat),
   @c(mul-rat), y @c(div-rat)) a partir de los @"(de más alto nivel)
   procedimientos que utilizan números racionales. El programa resultante tiene
   la estructura que se muestra en la @l(#Figura 2.1).

#    These data-abstraction barriers are powerful tools for controlling complexity.
#    By isolating the underlying representations of data objects, we can divide the
#    task of designing a large program into smaller tasks that can be performed
#    separately. But this kind of data abstraction is not yet powerful enough,
#    because it may not always make sense to speak of @"(the underlying
#    representation) for a data object.
   Estas barreras de abstracción de datos son herramientas poderosas para
   controlar la complejidad. Al aislar las representaciones subyacentes de los
   objetos de datos, podemos dividir la tarea de diseñar un programa grande en
   tareas más pequeñas que se pueden realizar por separado. Pero este tipo de
   abstracción de datos aún no es lo suficientemente potente, ya que no siempre
   tiene sentido hablar de @"(la representación subyacente) de un objeto de
   datos.

#    For one thing, there might be more than one useful representation for a data
#    object, and we might like to design systems that can deal with multiple
#    representations. To take a simple example, complex numbers may be represented
#    in two almost equivalent ways: in rectangular form (real and imaginary parts)
#    and in polar form (magnitude and angle). Sometimes rectangular form is more
#    appropriate and sometimes polar form is more appropriate. Indeed, it is
#    perfectly plausible to imagine a system in which complex numbers are
#    represented in both ways, and in which the procedures for manipulating complex
#    numbers work with either representation.
   Por un lado, podría haber más de una representación útil para un objeto de
   datos, y tal vez nos gustaría diseñar sistemas que puedan manejar múltiples
   representaciones. Para tomar un ejemplo simple, los números complejos pueden
   representarse en dos formas casi equivalentes: en forma rectangular (partes
   real e imaginaria) y en forma polar (magnitud y ángulo). A veces la forma
   rectangular es más apropiada ya veces la forma polar es más apropiada. De
   hecho, es perfectamente plausible imaginar un sistema en el que los números
   complejos estén representados en ambos sentidos y en los cuales los
   procedimientos para manipular números complejos funcionen con cualquiera de
   las dos representaciones.

#    More importantly, programming systems are often designed by many people
#    working over extended periods of time, subject to requirements that change
#    over time.  In such an environment, it is simply not possible for everyone to
#    agree in advance on choices of data representation. So in addition to the
#    data-abstraction barriers that isolate representation from use, we need
#    abstraction barriers that isolate different design choices from each other and
#    permit different choices to coexist in a single program. Furthermore, since
#    large programs are often created by combining pre-existing modules that were
#    designed in isolation, we need conventions that permit programmers to
#    incorporate modules into larger systems @e(additively), that is, without
#    having to redesign or reimplement these modules.
   Más importante aún, los sistemas de programación a menudo son diseñados por
   muchas personas que trabajan durante largos períodos de tiempo, sujeto a los
   requisitos que cambian con el tiempo. En tal ambiente, simplemente no es
   posible que todos estén de acuerdo por adelantado sobre las opciones de
   representación de los datos. Así, además de las barreras de abstracción de
   datos que aislan la representación del uso, necesitamos barreras de
   abstracción que aíslen diferentes opciones de diseño entre sí y permitan que
   coexistan diferentes opciones en un solo programa. Además, dado que los
   programas grandes a menudo se crean combinando módulos preexistentes
   diseñados aisladamente, necesitamos convenciones que permitan a los
   programadores incorporar módulos en sistemas más grandes de forma
   @e(aditiva), es decir, sin tener que rediseñar o reimplementar estos módulos.

#    In this section, we will learn how to cope with data that may be represented
#    in different ways by different parts of a program. This requires constructing
#    @e(generic procedures)––procedures that can operate on data that may be
#    represented in more than one way. Our main technique for building generic
#    procedures will be to work in terms of data objects that have @e(type tags),
#    that is, data objects that include explicit information about how they are to
#    be processed. We will also discuss @e(data-directed) programming, a powerful
#    and convenient implementation strategy for additively assembling systems with
#    generic operations.
   En esta sección, aprenderemos cómo hacer frente a los datos que pueden ser
   representados de diferentes maneras por diferentes partes de un
   programa. Esto requiere la construcción de @e(procedimientos genéricos)
   -procedimientos que pueden operar en datos que pueden ser representados en
   más de una forma. Nuestra principal técnica para construir procedimientos
   genéricos será trabajar en términos de objetos de datos que tengan
   @e(etiquetas de tipo), es decir, objetos de datos que incluyan información
   explícita sobre cómo se van a procesar. También discutiremos @e(la)
   programación @e(dirigida a datos), una estrategia de implementación poderosa
   y conveniente para sistemas de ensamblaje aditiva con operaciones genéricas.

#    We begin with the simple complex-number example. We will see how type tags and
#    data-directed style enable us to design separate rectangular and polar
#    representations for complex numbers while maintaining the notion of an
#    abstract @"(complex-number) data object. We will accomplish this by defining
#    arithmetic procedures for complex numbers (@c(add-complex), @c(sub-complex),
#    @c(mul-complex), and @c(div-complex)) in terms of generic selectors that
#    access parts of a complex number independent of how the number is represented.
#    The resulting complex-number system, as shown in @l(#Figure 2.19), contains
#    two different kinds of abstraction barriers. The @"(horizontal) abstraction
#    barriers play the same role as the ones in @l(#Figure 2.1). They isolate
#    @"(higher-level) operations from @"(lower-level) representations. In addition,
#    there is a @"(vertical) barrier that gives us the ability to separately design
#    and install alternative representations.
   Comenzamos con el ejemplo de un número complejo simple. Veremos cómo las
   etiquetas de tipo y el estilo dirigido a datos nos permiten diseñar
   representaciones rectangulares y polares separadas para números complejos
   mientras se mantiene la noción de un objeto de datos de @"(número complejo)
   abstracto. Vamos a lograr esto mediante la definición de los procedimientos
   de cálculo de números complejos (@c(add-complex), @c(sub-complex),
   @c(mul-complex), y @c(div-complex)) en términos de selectores genéricos que
   tienen acceso a partes de un número complejo independiente de cómo se
   representa el número. El sistema de números complejos resultante, como se
   muestra en la @l(#Figura 2.19), contiene dos tipos diferentes de
   barreras de abstracción. Las barreras @"(horizontales de) abstracción
   desempeñan el mismo papel que las de la @l(#Figura
   2.1). @"(Aíslan las) operaciones de @"(nivel superior de las)
   representaciones de @"(nivel inferior). Además, hay una barrera @"(vertical)
   que nos da la capacidad de diseñar e instalar separadamente representaciones
   alternativas.

#    ..figure > @t(Figure 2.19) Data-abstraction barriers in the complex-number system.
   ..figure > @t(Figura 2.19) Barreras de abstracción de datos en el sistema de
     números complejos.

#      ..art >
#                   Programs that use complex numbers
#          ╭─────────────────────────────────────────────────╮
#        ──┤ add-complex sub-complex mul-complex div-complex ├──
#          ╰─────────────────────────────────────────────────╯
#                      Complex arithmetic package
#        ───────────────────────────┬───────────────────────────
#                  Rectangular      │         Polar
#                representation     │     representation
#        ───────────────────────────┴───────────────────────────
#            List structure and primitive machine arithmetic
#      < art..
     ..art >
                  Programs that use complex numbers
         ╭─────────────────────────────────────────────────╮
       ──┤ add-complex sub-complex mul-complex div-complex ├──
         ╰─────────────────────────────────────────────────╯
                     Complex arithmetic package
       ───────────────────────────┬───────────────────────────
                 Rectangular      │         Polar
               representation     │     representation
       ───────────────────────────┴───────────────────────────
           List structure and primitive machine arithmetic
     < art..

# @  ..img > img/chap2/Fig2.19a.std.svg
@  ..img > img/chap2/Fig2.19a.std.svg

#    in section @l(#2.5) we will show how to use type tags and data-directed style to
#    develop a generic arithmetic package. This provides procedures (@c(add),
#    @c(mul), and so on) that can be used to manipulate all sorts of @"(numbers)
#    and can be easily extended when a new kind of number is needed. in section @l(#2.5.3),
#    we'll show how to use generic arithmetic in a system that performs symbolic
#    algebra.
   en la seccion @l(#2.5) mostraremos cómo usar las etiquetas de tipo y estilo
   dirigido a datos para desarrollar un paquete de aritmética genérica. Esto
   proporciona procedimientos (@c(add), @c(mul), etc.) que se pueden utilizar
   para manipular todo tipo de @"(números) y se puede ampliar fácilmente cuando
   se necesita un nuevo tipo de número. en la seccion @l(#2.5.3), mostraremos cómo
   usar la aritmética genérica en un sistema que realiza álgebra simbólica.

# *** 2.4.1 <> Representations for Complex Numbers
*** 2.4.1 <> Representaciones para números complejos

#     We will develop a system that performs arithmetic operations on complex
#     numbers as a simple but unrealistic example of a program that uses generic
#     operations.  We begin by discussing two plausible representations for complex
#     numbers as ordered pairs: rectangular form (real part and imaginary part) and
#     polar form (magnitude and angle).@n(109) Section @l(#2.4.2) will show how both
#     representations can be made to coexist in a single system through the use of
#     type tags and generic operations.
    Desarrollaremos un sistema que realiza operaciones aritméticas en números
    complejos como un ejemplo simple pero poco realista de un programa que usa
    operaciones genéricas. Comenzamos discutiendo dos representaciones
    plausibles para números complejos como pares ordenados: forma rectangular
    (parte real e parte imaginaria) y forma polar (magnitud y
    ángulo).@n(109) Sección @l(#2.4.2) mostrará cómo se puede hacer
    que ambas representaciones convivan en un solo sistema mediante el uso de
    etiquetas de tipo y operaciones genéricas.

#     Like rational numbers, complex numbers are naturally represented as ordered
#     pairs. The set of complex numbers can be thought of as a two-dimensional space
#     with two orthogonal axes, the @"(real) axis and the @"(imaginary) axis. (See
#     @l(#Figure 2.20).)  From this point of view, the complex number @m(z = x + iy)
#     (where @m(i² = −1)) can be thought of as the point in the plane whose real
#     coordinate is @m(x) and whose imaginary coordinate is @m(y).  Addition of
#     complex numbers reduces in this representation to addition of coordinates:
    Al igual que los números racionales, los números complejos se representan
    naturalmente como pares ordenados. El conjunto de números complejos puede
    considerarse como un espacio bidimensional con dos ejes ortogonales, el eje
    @"(real) y el eje @"(imaginario). (Véase @l(#Figura 2.20) .)
    Desde este punto de vista, el número complejo @m(z = x + iy) (donde @m(i² =
    -1) ) puede ser pensado como el punto en el plano cuyo verdadero coordenada
    es @m(x) y cuyo imaginario coordenada es @m(y). La adición de números
    complejos reduce en esta representación a la adición de coordenadas:

#     ..example >
#       Real-part(z₁ + z₂) = Real-part(z₁) + Real-part(z₂)
#
#       Imaginary-part(z₁ + z₂) = Imaginary-part(z₁) + Imaginary-part(z₂)
#     < example..
    ..example >
      Real-part(z₁ + z₂) = Real-part(z₁) + Real-part(z₂)

      Imaginary-part(z₁ + z₂) = Imaginary-part(z₁) + Imaginary-part(z₂)
    < example..

#     ..figure > @t(Figure 2.20) Complex numbers as points in the plane.
    ..figure > @t(Figura 2.20) Números complejos como puntos en el plano.

#       ..art >
#          Imaginary
#             ▲
#             │
#           y │.........................◆ z = x + iy = reⁱᴬ
#             │                    __-- .
#             │                __--     .
#             │          r __--         .
#             │        __--             .
#             │    __-- \               .
#             │__--    A |              .
#         ────┼──────────┴───────────────────▶ Real
#             │                         x
#       < art..
      ..art >
         Imaginary
            ▲
            │
          y │.........................◆ z = x + iy = reⁱᴬ
            │                    __-- .
            │                __--     .
            │          r __--         .
            │        __--             .
            │    __-- \               .
            │__--    A |              .
        ────┼──────────┴───────────────────▶ Real
            │                         x
      < art..

# @   ..img > img/chap2/Fig2.20.std.svg
@   ..img > img/chap2/Fig2.20.std.svg

#     When multiplying complex numbers, it is more natural to think in terms of
#     representing a complex number in polar form, as a magnitude and an angle
#     (@m(r) and @m(a) in @l(#Figure 2.20)). The product of two complex numbers is
#     the vector obtained by stretching one complex number by the length of the
#     other and then rotating it through the angle of the other:
    Cuando se multiplican números complejos, es más natural pensar en términos
    de representar un número complejo en forma polar, como una magnitud y un
    ángulo (@m(r) y @m(a) en la @l(#Figura 2.20) ). El producto de
    dos números complejos es el vector obtenido estirando un número complejo por
    la longitud del otro y luego girándolo a través del ángulo del otro:

#     ..example >
#       Magnitude(z₁ ⋅ z₂) = Magnitude(z₁) ⋅ Magnitude(z₂)
#
#           Angle(z₁ ⋅ z₂) = Angle(z₁) + Angle(z₂)
#     < example..
    ..example >
      Magnitude(z₁ ⋅ z₂) = Magnitude(z₁) ⋅ Magnitude(z₂)

          Angle(z₁ ⋅ z₂) = Angle(z₁) + Angle(z₂)
    < example..

#     Thus, there are two different representations for complex numbers, which are
#     appropriate for different operations. Yet, from the viewpoint of someone
#     writing a program that uses complex numbers, the principle of data abstraction
#     suggests that all the operations for manipulating complex numbers should be
#     available regardless of which representation is used by the computer. For
#     example, it is often useful to be able to find the magnitude of a complex
#     number that is specified by rectangular coordinates. Similarly, it is often
#     useful to be able to determine the real part of a complex number that is
#     specified by polar coordinates.
    Por lo tanto, hay dos representaciones diferentes para los números
    complejos, que son apropiados para diferentes operaciones. Sin embargo,
    desde el punto de vista de alguien que escribe un programa que utiliza
    números complejos, el principio de la abstracción de datos sugiere que todas
    las operaciones para manipular números complejos deben estar disponibles
    independientemente de qué representación sea utilizada por la
    computadora. Por ejemplo, a menudo es útil ser capaz de encontrar la
    magnitud de un número complejo que se especifica mediante coordenadas
    rectangulares. De manera similar, a menudo es útil ser capaz de determinar
    la parte real de un número complejo que se especifica mediante coordenadas
    polares.

#     To design such a system, we can follow the same data-abstraction strategy we
#     followed in designing the rational-number package in section @l(#2.1.1).  Assume that
#     the operations on complex numbers are implemented in terms of four selectors:
#     @c(real-part), @c(imag-part), @c(magnitude), and @c(angle). Also assume that
#     we have two procedures for constructing complex numbers:
#     @c(make-from-real-imag) returns a complex number with specified real and
#     imaginary parts, and @c(make-from-mag-ang) returns a complex number with
#     specified magnitude and angle. These procedures have the property that, for
#     any complex number @c(z), both
    Para diseñar un sistema de este tipo, podemos seguir la misma estrategia de
    abstracción de datos que seguimos al diseñar el paquete de números
    racionales en la seccion @l(#2.1.1). Supongamos que las operaciones con números
    complejos se implementan en términos de cuatro selectores: @c(real-part),
    @c(imag-part), @c(magnitude), y @c(angle). Supongamos también que tenemos
    dos procedimientos para construir números complejos: @c(make-from-real-imag)
    devuelve un número complejo con partes reales e imaginarias especificadas, y
    @c(make-from-mag-ang) devuelve un número complejo con magnitud y ángulo
    especificados. Estos procedimientos tienen la propiedad de que, para
    cualquier número complejo @c(z), ambos

#     ..src > scheme
#       (make-from-real-imag (real-part z)
#                            (imag-part z))
#     < src..
    ..src > scheme
      (make-from-real-imag (real-part z)
                           (imag-part z))
    < src..

#     and
    y
#     ..src > scheme
#       (make-from-mag-ang (magnitude z)
#                          (angle z))
#     < src..
    ..src > scheme
      (make-from-mag-ang (magnitude z)
                         (angle z))
    < src..

#     produce complex numbers that are equal to @c(z).
    Producir números complejos que son iguales a @c(z).

#     Using these constructors and selectors, we can implement arithmetic on complex
#     numbers using the @"(abstract data) specified by the constructors and
#     selectors, just as we did for rational numbers in section @l(#2.1.1). As shown in the
#     formulas above, we can add and subtract complex numbers in terms of real and
#     imaginary parts while multiplying and dividing complex numbers in terms of
#     magnitudes and angles:
    Usando estos constructores y selectores, podemos implementar la aritmética
    en números complejos utilizando los @"(datos abstractos) especificados por
    los constructores y selectores, tal como lo hicimos con los números
    racionales en la seccion @l(#2.1.1). Como se muestra en las fórmulas anteriores,
    podemos sumar y restar números complejos en términos de partes reales e
    imaginarias, multiplicando y dividiendo números complejos en términos de
    magnitudes y ángulos:

#     ..src > scheme
#       (define (add-complex z1 z2)
#         (make-from-real-imag
#          (+ (real-part z1) (real-part z2))
#          (+ (imag-part z1) (imag-part z2))))
#
#       (define (sub-complex z1 z2)
#         (make-from-real-imag
#          (- (real-part z1) (real-part z2))
#          (- (imag-part z1) (imag-part z2))))
#
#       (define (mul-complex z1 z2)
#         (make-from-mag-ang
#          (* (magnitude z1) (magnitude z2))
#          (+ (angle z1) (angle z2))))
#
#       (define (div-complex z1 z2)
#         (make-from-mag-ang
#          (/ (magnitude z1) (magnitude z2))
#          (- (angle z1) (angle z2))))
#     < src..
    ..src > scheme
      (define (add-complex z1 z2)
        (make-from-real-imag
         (+ (real-part z1) (real-part z2))
         (+ (imag-part z1) (imag-part z2))))

      (define (sub-complex z1 z2)
        (make-from-real-imag
         (- (real-part z1) (real-part z2))
         (- (imag-part z1) (imag-part z2))))

      (define (mul-complex z1 z2)
        (make-from-mag-ang
         (* (magnitude z1) (magnitude z2))
         (+ (angle z1) (angle z2))))

      (define (div-complex z1 z2)
        (make-from-mag-ang
         (/ (magnitude z1) (magnitude z2))
         (- (angle z1) (angle z2))))
    < src..

#     To complete the complex-number package, we must choose a representation and we
#     must implement the constructors and selectors in terms of primitive numbers
#     and primitive list structure. There are two obvious ways to do this: We can
#     represent a complex number in @"(rectangular form) as a pair (real part,
#     imaginary part) or in @"(polar form) as a pair (magnitude, angle). Which shall
#     we choose?
    Para completar el paquete de número complejo, debemos elegir una
    representación y debemos implementar los constructores y selectores en
    términos de números primitivos y estructura de lista primitiva. Hay dos
    maneras obvias de hacer esto: Podemos representar un número complejo en
    @"(forma rectangular) como un par (parte real, parte imaginaria) o en
    @"(forma polar) como un par (magnitud, ángulo). ¿Cuál elegiremos?

#     In order to make the different choices concrete, imagine that there are two
#     programmers, Ben Bitdiddle and Alyssa P. Hacker, who are independently
#     designing representations for the complex-number system. Ben chooses to
#     represent complex numbers in rectangular form. With this choice, selecting the
#     real and imaginary parts of a complex number is straightforward, as is
#     constructing a complex number with given real and imaginary parts. To find the
#     magnitude and the angle, or to construct a complex number with a given
#     magnitude and angle, he uses the trigonometric relations
    Con el fin de concretar las diferentes opciones, imagine que hay dos
    programadores, Ben Bitdiddle y Alyssa P. Hacker, que están diseñando
    independientemente representaciones para el sistema de números
    complejos. Ben elige representar números complejos en forma rectangular. Con
    esta elección, seleccionar las partes reales e imaginarias de un número
    complejo es sencillo, así como construir un número complejo con partes
    reales e imaginarias dadas. Para encontrar la magnitud y el ángulo, o para
    construir un número complejo con una determinada magnitud y ángulo, utiliza
    las relaciones trigonométricas

#     ..example >
#                             ________
#       x = r cos A     r = ./ x² + y²
#
#       y = r sin A     A = arctan(y,x)
#     < example..
    ..example >
                            ________
      x = r cos A     r = ./ x² + y²

      y = r sin A     A = arctan(y,x)
    < example..

#     which relate the real and imaginary parts @m[(x, y)] to the magnitude and the
#     angle @m[(r, A)].@n(110) Ben's representation is therefore given by the
#     following selectors and constructors:
    Que relacionan las partes real e imaginaria @m[(x, y)] con la magnitud y el
    ángulo @m[(r, A)].@n(110) Por lo tanto, la representación de Ben es
    dada por los siguientes selectores y constructores:

#     ..src > scheme
#       (define (real-part z) (car z))
#       (define (imag-part z) (cdr z))
#
#       (define (magnitude z)
#         (sqrt (+ (square (real-part z))
#                  (square (imag-part z)))))
#
#       (define (angle z)
#         (atan (imag-part z) (real-part z)))
#
#       (define (make-from-real-imag x y)
#         (cons x y))
#
#       (define (make-from-mag-ang r a)
#         (cons (* r (cos a)) (* r (sin a))))
#     < src..
    ..src > scheme
      (define (real-part z) (car z))
      (define (imag-part z) (cdr z))

      (define (magnitude z)
        (sqrt (+ (square (real-part z))
                 (square (imag-part z)))))

      (define (angle z)
        (atan (imag-part z) (real-part z)))

      (define (make-from-real-imag x y)
        (cons x y))

      (define (make-from-mag-ang r a)
        (cons (* r (cos a)) (* r (sin a))))
    < src..

#     Alyssa, in contrast, chooses to represent complex numbers in polar form. For
#     her, selecting the magnitude and angle is straightforward, but she has to use
#     the trigonometric relations to obtain the real and imaginary parts. Alyssa's
#     representation is:
    Alyssa, por el contrario, elige representar números complejos en forma
    polar. Para ella, seleccionar la magnitud y el ángulo es directo, pero tiene
    que usar las relaciones trigonométricas para obtener las partes real e
    imaginaria. La representación de Alyssa es:

#     ..src > scheme
#       (define (real-part z)
#         (* (magnitude z) (cos (angle z))))
#
#       (define (imag-part z)
#         (* (magnitude z) (sin (angle z))))
#
#       (define (magnitude z) (car z))
#       (define (angle z) (cdr z))
#
#       (define (make-from-real-imag x y)
#         (cons (sqrt (+ (square x) (square y)))
#               (atan y x)))
#
#       (define (make-from-mag-ang r a)
#         (cons r a))
#     < src..
    ..src > scheme
      (define (real-part z)
        (* (magnitude z) (cos (angle z))))

      (define (imag-part z)
        (* (magnitude z) (sin (angle z))))

      (define (magnitude z) (car z))
      (define (angle z) (cdr z))

      (define (make-from-real-imag x y)
        (cons (sqrt (+ (square x) (square y)))
              (atan y x)))

      (define (make-from-mag-ang r a)
        (cons r a))
    < src..

#     The discipline of data abstraction ensures that the same implementation of
#     @c(add-complex), @c(sub-complex), @c(mul-complex), and @c(div-complex) will
#     work with either Ben's representation or Alyssa's representation.
    La disciplina de la abstracción de datos garantiza que la misma aplicación
    de @c(add-complex), @c(sub-complex), @c(mul-complex), y @c(div-complex)
    trabajará con cualquiera de Ben representación o representación de Alyssa.

# *** 2.4.2 <> Tagged data
*** 2.4.2 <> Datos etiquetados

#     One way to view data abstraction is as an application of the @"(principle of
#     least commitment.)  In implementing the complex-number system in section @l(#2.4.1),
#     we can use either Ben's rectangular representation or Alyssa's polar
#     representation. The abstraction barrier formed by the selectors and
#     constructors permits us to defer to the last possible moment the choice of a
#     concrete representation for our data objects and thus retain maximum
#     flexibility in our system design.
    Una forma de ver la abstracción de datos es como una aplicación del
    @"(principio de menor compromiso. )  Al implementar el sistema de números
    complejos en la seccion @l(#2.4.1), podemos usar la representación rectangular
    de Ben o la representación polar de Alyssa. La barrera de abstracción
    formada por los selectores y constructores nos permite diferir al último
    momento posible la elección de una representación concreta para nuestros
    objetos de datos y así retener la máxima flexibilidad en el diseño de
    nuestro sistema.

#     The principle of least commitment can be carried to even further extremes. If
#     we desire, we can maintain the ambiguity of representation even @e(after) we
#     have designed the selectors and constructors, and elect to use both Ben's
#     representation @e(and) Alyssa's representation. If both representations are
#     included in a single system, however, we will need some way to distinguish
#     data in polar form from data in rectangular form. Otherwise, if we were asked,
#     for instance, to find the @c(magnitude) of the pair (3, 4), we wouldn't know
#     whether to answer 5 (interpreting the number in rectangular form) or 3
#     (interpreting the number in polar form). A straightforward way to accomplish
#     this distinction is to include a @e(type tag)––the symbol @c(rectangular) or
#     @c(polar)––as part of each complex number. Then when we need to manipulate a
#     complex number we can use the tag to decide which selector to apply.
    El principio de menor compromiso puede llevarse a otros extremos. Si
    deseamos, podemos mantener la ambigüedad de la representación, incluso
    @e(después de) que hemos diseñado los selectores y constructores, y optar
    por utilizar tanto la representación de Ben @e(y) la representación de
    Alyssa. Si ambas representaciones están incluidas en un solo sistema, sin
    embargo, necesitaremos alguna manera de distinguir datos en forma polar de
    datos en forma rectangular. De lo contrario, si se nos pidiera, por ejemplo,
    encontrar el @c(magnitude) de la pareja (3, 4), no sabríamos si responder a
    5 (interpretar el número en forma rectangular) o 3 (interpretar el número en
    forma polar). @e(Una forma sencilla de lograr esta distinción es incluir una
    etiqueta de tipo) - el símbolo @c(rectangular) o - @c(polar) como parte de
    cada número complejo. Entonces cuando necesitamos manipular un número
    complejo podemos usar la etiqueta para decidir qué selector aplicar.

#     In order to manipulate tagged data, we will assume that we have procedures
#     @c(type-tag) and @c(contents) that extract from a data object the tag and the
#     actual contents (the polar or rectangular coordinates, in the case of a
#     complex number). We will also postulate a procedure @c(attach-tag) that takes
#     a tag and contents and produces a tagged data object. A straightforward way to
#     implement this is to use ordinary list structure:
    Para manipular datos marcados, asumiremos que tenemos procedimientos
    @c(type-tag) y @c(contents) que extraemos de un objeto de datos la etiqueta
    y el contenido real (las coordenadas polares o rectangulares, en el caso de
    un número complejo). También postularemos un procedimiento @c(attach-tag)
    que tome una etiqueta y un contenido y produzca un objeto de datos
    etiquetado. Una forma sencilla de implementar esto es usar la estructura de
    lista ordinaria:

#     ..src > scheme
#       (define (attach-tag type-tag contents)
#         (cons type-tag contents))
#
#       (define (type-tag datum)
#         (if (pair? datum)
#             (car datum)
#             (error "Bad tagged datum:
#                     TYPE-TAG" datum)))
#
#       (define (contents datum)
#         (if (pair? datum)
#             (cdr datum)
#             (error "Bad tagged datum:
#                     CONTENTS" datum)))
#     < src..
    ..src > scheme
      (define (attach-tag type-tag contents)
        (cons type-tag contents))

      (define (type-tag datum)
        (if (pair? datum)
            (car datum)
            (error "Bad tagged datum:
                    TYPE-TAG" datum)))

      (define (contents datum)
        (if (pair? datum)
            (cdr datum)
            (error "Bad tagged datum:
                    CONTENTS" datum)))
    < src..

#     Using these procedures, we can define predicates @c(rectangular?)  and
#     @c(polar?), which recognize rectangular and polar numbers, respectively:
    Usando estos procedimientos, podemos definir predicados @c(rectangular?)  y
    @c(polar?), que reconocen números rectangulares y polares, respectivamente:

#     ..src > scheme
#       (define (rectangular? z)
#         (eq? (type-tag z) 'rectangular))
#
#       (define (polar? z)
#         (eq? (type-tag z) 'polar))
#     < src..
    ..src > scheme
      (define (rectangular? z)
        (eq? (type-tag z) 'rectangular))

      (define (polar? z)
        (eq? (type-tag z) 'polar))
    < src..

#     With type tags, Ben and Alyssa can now modify their code so that their two
#     different representations can coexist in the same system. Whenever Ben
#     constructs a complex number, he tags it as rectangular. Whenever Alyssa
#     constructs a complex number, she tags it as polar. In addition, Ben and Alyssa
#     must make sure that the names of their procedures do not conflict. One way to
#     do this is for Ben to append the suffix @c(rectangular) to the name of each of
#     his representation procedures and for Alyssa to append @c(polar) to the names
#     of hers. Here is Ben's revised rectangular representation from @l(#2.4.1):
    Con las etiquetas de tipo, Ben y Alyssa pueden ahora modificar su código
    para que sus dos representaciones diferentes puedan coexistir en el mismo
    sistema. Cada vez que Ben construye un número complejo, lo marca como
    rectangular. Cada vez que Alyssa construye un número complejo, lo marca como
    polar. Además, Ben y Alyssa deben asegurarse de que los nombres de sus
    procedimientos no entren en conflicto. Una forma de hacerlo es que Ben
    adjunte el sufijo @c(rectangular) al nombre de cada uno de sus
    procedimientos de representación y que Alyssa añada @c(polar) los nombres de
    ella. Aquí está la representación rectangular revisada de Ben de
    @l(#2.4.1) :

#     ..src > scheme
#       (define (real-part-rectangular z) (car z))
#       (define (imag-part-rectangular z) (cdr z))
#
#       (define (magnitude-rectangular z)
#         (sqrt (+ (square (real-part-rectangular z))
#                  (square (imag-part-rectangular z)))))
#
#       (define (angle-rectangular z)
#         (atan (imag-part-rectangular z)
#               (real-part-rectangular z)))
#
#       (define (make-from-real-imag-rectangular x y)
#         (attach-tag 'rectangular (cons x y)))
#
#       (define (make-from-mag-ang-rectangular r a)
#         (attach-tag
#          'rectangular
#          (cons (* r (cos a)) (* r (sin a)))))
#     < src..
    ..src > scheme
      (define (real-part-rectangular z) (car z))
      (define (imag-part-rectangular z) (cdr z))

      (define (magnitude-rectangular z)
        (sqrt (+ (square (real-part-rectangular z))
                 (square (imag-part-rectangular z)))))

      (define (angle-rectangular z)
        (atan (imag-part-rectangular z)
              (real-part-rectangular z)))

      (define (make-from-real-imag-rectangular x y)
        (attach-tag 'rectangular (cons x y)))

      (define (make-from-mag-ang-rectangular r a)
        (attach-tag
         'rectangular
         (cons (* r (cos a)) (* r (sin a)))))
    < src..

#     and here is Alyssa's revised polar representation:
    Y aquí está la representación polar revisada de Alyssa:

#     ..src > scheme
#       (define (real-part-polar z)
#         (* (magnitude-polar z)
#            (cos (angle-polar z))))
#
#       (define (imag-part-polar z)
#         (* (magnitude-polar z)
#            (sin (angle-polar z))))
#
#       (define (magnitude-polar z) (car z))
#       (define (angle-polar z) (cdr z))
#
#       (define (make-from-real-imag-polar x y)
#         (attach-tag
#          'polar
#          (cons (sqrt (+ (square x) (square y)))
#                (atan y x))))
#
#       (define (make-from-mag-ang-polar r a)
#         (attach-tag 'polar (cons r a)))
#     < src..
    ..src > scheme
      (define (real-part-polar z)
        (* (magnitude-polar z)
           (cos (angle-polar z))))

      (define (imag-part-polar z)
        (* (magnitude-polar z)
           (sin (angle-polar z))))

      (define (magnitude-polar z) (car z))
      (define (angle-polar z) (cdr z))

      (define (make-from-real-imag-polar x y)
        (attach-tag
         'polar
         (cons (sqrt (+ (square x) (square y)))
               (atan y x))))

      (define (make-from-mag-ang-polar r a)
        (attach-tag 'polar (cons r a)))
    < src..

#     Each generic selector is implemented as a procedure that checks the tag of its
#     argument and calls the appropriate procedure for handling data of that type.
#     For example, to obtain the real part of a complex number, @c(real-part)
#     examines the tag to determine whether to use Ben's @c(real-part-rectangular)
#     or Alyssa's @c(real-part-polar). In either case, we use @c(contents) to
#     extract the bare, untagged datum and send this to the rectangular or polar
#     procedure as required:
    Cada selector genérico se implementa como un procedimiento que comprueba la
    etiqueta de su argumento y llama al procedimiento apropiado para manejar
    datos de ese tipo. Por ejemplo, para obtener la parte real de un número
    complejo, @c(real-part) examina la etiqueta para determinar si se utiliza
    Ben @c(real-part-rectangular) o Alyssa @c(real-part-polar). En cualquier
    caso, utilizamos @c(contents) para extraer el dato desnudo y no etiquetado y
    enviarlo al procedimiento rectangular o polar según sea necesario:

#     ..src > scheme
#       (define (real-part z)
#         (cond ((rectangular? z)
#                (real-part-rectangular (contents z)))
#               ((polar? z)
#                (real-part-polar (contents z)))
#               (else (error "Unknown type:
#                      REAL-PART" z))))
#
#       (define (imag-part z)
#         (cond ((rectangular? z)
#                (imag-part-rectangular (contents z)))
#               ((polar? z)
#                (imag-part-polar (contents z)))
#               (else (error "Unknown type:
#                      IMAG-PART" z))))
#
#       (define (magnitude z)
#         (cond ((rectangular? z)
#                (magnitude-rectangular (contents z)))
#               ((polar? z)
#                (magnitude-polar (contents z)))
#               (else (error "Unknown type:
#                      MAGNITUDE" z))))
#
#       (define (angle z)
#         (cond ((rectangular? z)
#                (angle-rectangular (contents z)))
#               ((polar? z)
#                (angle-polar (contents z)))
#               (else (error "Unknown type:
#                      ANGLE" z))))
#     < src..
    ..src > scheme
      (define (real-part z)
        (cond ((rectangular? z)
               (real-part-rectangular (contents z)))
              ((polar? z)
               (real-part-polar (contents z)))
              (else (error "Unknown type:
                     REAL-PART" z))))

      (define (imag-part z)
        (cond ((rectangular? z)
               (imag-part-rectangular (contents z)))
              ((polar? z)
               (imag-part-polar (contents z)))
              (else (error "Unknown type:
                     IMAG-PART" z))))

      (define (magnitude z)
        (cond ((rectangular? z)
               (magnitude-rectangular (contents z)))
              ((polar? z)
               (magnitude-polar (contents z)))
              (else (error "Unknown type:
                     MAGNITUDE" z))))

      (define (angle z)
        (cond ((rectangular? z)
               (angle-rectangular (contents z)))
              ((polar? z)
               (angle-polar (contents z)))
              (else (error "Unknown type:
                     ANGLE" z))))
    < src..

#     To implement the complex-number arithmetic operations, we can use the same
#     procedures @c(add-complex), @c(sub-complex), @c(mul-complex), and
#     @c(div-complex) from @l(#2.4.1), because the selectors they call are generic,
#     and so will work with either representation. For example, the procedure
#     @c(add-complex) is still
    Para llevar a cabo las operaciones aritméticas de números complejos, podemos
    utilizar los mismos procedimientos @c(add-complex), @c(sub-complex),
    @c(mul-complex), y @c(div-complex) de la seccion @l(#2.4.1), debido a que los
    selectores que llaman son genéricos, y así va a funcionar, ya sea con la
    representación. Por ejemplo, el procedimiento @c(add-complex) sigue

#     ..src > scheme
#       (define (add-complex z1 z2)
#         (make-from-real-imag
#          (+ (real-part z1) (real-part z2))
#          (+ (imag-part z1) (imag-part z2))))
#     < src..
    ..src > scheme
      (define (add-complex z1 z2)
        (make-from-real-imag
         (+ (real-part z1) (real-part z2))
         (+ (imag-part z1) (imag-part z2))))
    < src..

#     Finally, we must choose whether to construct complex numbers using Ben's
#     representation or Alyssa's representation. One reasonable choice is to
#     construct rectangular numbers whenever we have real and imaginary parts and to
#     construct polar numbers whenever we have magnitudes and angles:
    Finalmente, debemos elegir si construir números complejos utilizando la
    representación de Ben o la representación de Alyssa. Una elección razonable
    es construir números rectangulares siempre que tengamos partes reales e
    imaginarias y construir números polares siempre que tengamos magnitudes y
    ángulos:

#     ..src > scheme
#       (define (make-from-real-imag x y)
#         (make-from-real-imag-rectangular x y))
#
#       (define (make-from-mag-ang r a)
#         (make-from-mag-ang-polar r a))
#     < src..
    ..src > scheme
      (define (make-from-real-imag x y)
        (make-from-real-imag-rectangular x y))

      (define (make-from-mag-ang r a)
        (make-from-mag-ang-polar r a))
    < src..

#     The resulting complex-number system has the structure shown in @l(#Figure
#     2.21).  The system has been decomposed into three relatively independent
#     parts: the complex-number-arithmetic operations, Alyssa's polar
#     implementation, and Ben's rectangular implementation. The polar and
#     rectangular implementations could have been written by Ben and Alyssa working
#     separately, and both of these can be used as underlying representations by a
#     third programmer implementing the complex-arithmetic procedures in terms of
#     the abstract constructor/selector interface.
    El sistema de números complejos resultante tiene la estructura que se
    muestra en la @l(#Figura 2.21). El sistema se ha descompuesto
    en tres partes relativamente independientes: las operaciones aritméticas
    numéricas complejas, la implementación polar de Alyssa y la implementación
    rectangular de Ben. Las implementaciones polares y rectangulares podrían
    haber sido escritas por Ben y Alyssa trabajando por separado, y ambas pueden
    ser utilizadas como representaciones subyacentes por un tercer programador
    que implementa los procedimientos aritméticos complejos en términos de la
    interfaz constructor / selector abstracto.

#     ..figure > @t(Figure 2.21) Structure of the generic complex-arithmetic system.
    ..figure > @t(Figura 2.21) Estructura del sistema complejo-aritmético
    genérico.

#       ..art >
#              ╭─────────────────────────────────────────────────╮
#         ─────┤ add-complex sub-complex mul-complex div-complex ├────
#              ╰─────────────────────────────────────────────────╯
#                         Complex arithmetic package
#                          ╭───────────────────────╮
#                          │ real-part   imag-part │
#         ─────────────────┤                       ├──────────────────
#                          │ magnitude   angle     │
#                          ╰───────────┬───────────╯
#                    Rectangular       │          Polar
#                   representation     │     representation
#         ─────────────────────────────┴──────────────────────────────
#                List structure and primitive machine arithmetic
#       < art..
      ..art >
             ╭─────────────────────────────────────────────────╮
        ─────┤ add-complex sub-complex mul-complex div-complex ├────
             ╰─────────────────────────────────────────────────╯
                        Complex arithmetic package
                         ╭───────────────────────╮
                         │ real-part   imag-part │
        ─────────────────┤                       ├──────────────────
                         │ magnitude   angle     │
                         ╰───────────┬───────────╯
                   Rectangular       │          Polar
                  representation     │     representation
        ─────────────────────────────┴──────────────────────────────
               List structure and primitive machine arithmetic
      < art..

# @   ..img > img/chap2/Fig2.21a.std.svg
@   ..img > img/chap2/Fig2.21a.std.svg

#     Since each data object is tagged with its type, the selectors operate on the
#     data in a generic manner. That is, each selector is defined to have a behavior
#     that depends upon the particular type of data it is applied to. Notice the
#     general mechanism for interfacing the separate representations: Within a given
#     representation implementation (say, Alyssa's polar package) a complex number
#     is an untyped pair (magnitude, angle). When a generic selector operates on a
#     number of @c(polar) type, it strips off the tag and passes the contents on to
#     Alyssa's code. Conversely, when Alyssa constructs a number for general use,
#     she tags it with a type so that it can be appropriately recognized by the
#     higher-level procedures. This discipline of stripping off and attaching tags
#     as data objects are passed from level to level can be an important
#     organizational strategy, as we shall see in section @l(#2.5).
    Dado que cada objeto de datos está etiquetado con su tipo, los selectores
    operan sobre los datos de una manera genérica. Es decir, cada selector se
    define para tener un comportamiento que depende del tipo particular de datos
    a los que se aplica. Observe el mecanismo general para interconectar las
    representaciones separadas: Dentro de una implementación de representación
    dada (digamos, paquete polar de Alyssa), un número complejo es un par no
    tipado (magnitud, ángulo). Cuando un selector genérico opera en un número de
    @c(polar) tipo, tira de la etiqueta y pasa el contenido al código de
    Alyssa. Por el contrario, cuando Alyssa construye un número para uso
    general, lo marca con un tipo para que pueda ser reconocido apropiadamente
    por los procedimientos de nivel superior.@l(#2.5)

# *** 2.4.3 <> Data-Directed Programming and Additivity
*** 2.4.3 <> Programación Dirigida por Datos y Aditividad

#     The general strategy of checking the type of a datum and calling an
#     appropriate procedure is called @e(dispatching on type). This is a powerful
#     strategy for obtaining modularity in system design. On the other hand,
#     implementing the dispatch as in section @l(#2.4.2) has two significant weaknesses. One
#     weakness is that the generic interface procedures (@c(real-part),
#     @c(imag-part), @c(magnitude), and @c(angle)) must know about all the different
#     representations. For instance, suppose we wanted to incorporate a new
#     representation for complex numbers into our complex-number system. We would
#     need to identify this new representation with a type, and then add a clause to
#     each of the generic interface procedures to check for the new type and apply
#     the appropriate selector for that representation.
    La estrategia general de comprobar el tipo de un dato y llamar a un
    procedimiento apropiado se llama @e(despachar en tipo). Esta es una
    estrategia poderosa para obtener modularidad en el diseño del sistema. Por
    otro lado, la implementación del despacho como en la seccion @l(#2.4.2) tiene
    dos debilidades significativas. Una debilidad es que los procedimientos de
    interfaz genérica (@c(real-part), @c(imag-part), @c(magnitude), y
    @c(angle)) deben saber acerca de todas las diferentes representaciones. Por
    ejemplo, supongamos que queremos incorporar una nueva representación de
    números complejos en nuestro sistema de números complejos. Necesitamos
    identificar esta nueva representación con un tipo y luego agregar una
    cláusula a cada uno de los procedimientos de la interfaz genérica para
    comprobar el nuevo tipo y aplicar el selector apropiado para esa
    representación.

#     Another weakness of the technique is that even though the individual
#     representations can be designed separately, we must guarantee that no two
#     procedures in the entire system have the same name. This is why Ben and Alyssa
#     had to change the names of their original procedures from @l(#2.4.1).
    Otra debilidad de la técnica es que a pesar de que las representaciones
    individuales pueden ser diseñadas por separado, debemos garantizar que no
    hay dos procedimientos en todo el sistema tienen el mismo nombre. Esta es la
    razón por la cual Ben y Alyssa tuvieron que cambiar los nombres de sus
    procedimientos originales de la seccion @l(#2.4.1).

#     The issue underlying both of these weaknesses is that the technique for
#     implementing generic interfaces is not @e(additive). The person implementing
#     the generic selector procedures must modify those procedures each time a new
#     representation is installed, and the people interfacing the individual
#     representations must modify their code to avoid name conflicts. In each of
#     these cases, the changes that must be made to the code are straightforward,
#     but they must be made nonetheless, and this is a source of inconvenience and
#     error. This is not much of a problem for the complex-number system as it
#     stands, but suppose there were not two but hundreds of different
#     representations for complex numbers. And suppose that there were many generic
#     selectors to be maintained in the abstract-data interface. Suppose, in fact,
#     that no one programmer knew all the interface procedures or all the
#     representations. The problem is real and must be addressed in such programs as
#     large-scale data-base-management systems.
    El problema subyacente a estas dos debilidades es que la técnica para
    implementar interfaces genéricas no es @e(aditiva). La persona que
    implementa los procedimientos selectores genéricos debe modificar dichos
    procedimientos cada vez que se instala una nueva representación y las
    personas que interconectan las representaciones individuales deben modificar
    su código para evitar conflictos de nombres. En cada uno de estos casos, los
    cambios que deben realizarse en el código son sencillos, pero deben hacerse
    sin embargo, y esto es una fuente de inconvenientes y errores. Esto no es un
    gran problema para el sistema de números complejos tal como está, pero
    supongamos que no había dos, sino cientos de representaciones diferentes
    para números complejos. Y supongamos que había muchos selectores genéricos
    que se mantendrían en la interfaz de datos abstractos. Supongamos, de hecho,
    Que ningún programador conocía todos los procedimientos de interfaz o todas
    las representaciones. El problema es real y debe abordarse en programas como
    los sistemas de gestión de bases de datos a gran escala.

#     What we need is a means for modularizing the system design even further. This
#     is provided by the programming technique known as @e(data-directed
#     programming).  To understand how data-directed programming works, begin with
#     the observation that whenever we deal with a set of generic operations that
#     are common to a set of different types we are, in effect, dealing with a
#     two-dimensional table that contains the possible operations on one axis and
#     the possible types on the other axis. The entries in the table are the
#     procedures that implement each operation for each type of argument
#     presented. In the complex-number system developed in the previous section, the
#     correspondence between operation name, data type, and actual procedure was
#     spread out among the various conditional clauses in the generic interface
#     procedures. But the same information could have been organized in a table, as
#     shown in @l(#Figure 2.22).
    Lo que necesitamos es un medio para modular el diseño del sistema aún
    más. Esto es proporcionado por la técnica de programación conocida como
    @e(programación dirigida a datos). Para entender cómo funciona la
    programación dirigida a datos, comience con la observación de que cuando
    tratamos un conjunto de operaciones genéricas que son comunes a un conjunto
    de tipos diferentes, estamos, de hecho, tratando con una tabla bidimensional
    que contiene las posibles operaciones En un eje y los tipos posibles en el
    otro eje. Las entradas en la tabla son los procedimientos que implementan
    cada operación para cada tipo de argumento presentado. En el sistema de
    números complejos desarrollado en la sección anterior, la correspondencia
    entre el nombre de la operación, el tipo de datos y el procedimiento real se
    distribuyó entre las diversas cláusulas condicionales en los procedimientos
    de la interfaz genérica. @l(#Figura 2.22)

#     ..figure > @t(Figure 2.22) Table of operations for the complex-number system.
    ..figure > @t(Figura 2.22) Tabla de operaciones para el sistema de números
      complejos.

#       ..art >
#                    |               Types
#         Operations | Polar           | Rectangular
#         ===========+=================+======================
#         real-part  | real-part-polar | real-part-rectangular
#         imag-part  | imag-part-polar | imag-part-rectangular
#         magnitude  | magnitude-polar | magnitude-rectangular
#         angle      | angle-polar     | angle-rectangular
#       < art..
      ..art >
                   |               Types
        Operations | Polar           | Rectangular
        ===========+=================+======================
        real-part  | real-part-polar | real-part-rectangular
        imag-part  | imag-part-polar | imag-part-rectangular
        magnitude  | magnitude-polar | magnitude-rectangular
        angle      | angle-polar     | angle-rectangular
      < art..

# @   ..img > img/chap2/Fig2.22.std.svg
@   ..img > img/chap2/Fig2.22.std.svg

#     Data-directed programming is the technique of designing programs to work with
#     such a table directly. Previously, we implemented the mechanism that
#     interfaces the complex-arithmetic code with the two representation packages as
#     a set of procedures that each perform an explicit dispatch on type. Here we
#     will implement the interface as a single procedure that looks up the
#     combination of the operation name and argument type in the table to find the
#     correct procedure to apply, and then applies it to the contents of the
#     argument. If we do this, then to add a new representation package to the
#     system we need not change any existing procedures; we need only add new
#     entries to the table.
    La programación dirigida a datos es la técnica de diseñar programas para
    trabajar directamente con dicha tabla. Anteriormente, implementamos el
    mecanismo que interconecta el código aritmético complejo con los dos
    paquetes de representación como un conjunto de procedimientos que realizan
    un envío explícito de tipo. Aquí vamos a implementar la interfaz como un
    procedimiento único que busca la combinación del nombre de la operación y el
    tipo de argumento en la tabla para encontrar el procedimiento correcto para
    aplicar y, a continuación, se aplica a los contenidos del argumento. Si
    hacemos esto, entonces para agregar un nuevo paquete de representación al
    sistema no necesitamos cambiar ningún procedimiento existente; Sólo
    necesitamos agregar nuevas entradas a la tabla.

#     To implement this plan, assume that we have two procedures, @c(put) and
#     @c(get), for manipulating the operation-and-type table:
    Para implementar este plan, supongamos que tenemos dos procedimientos
    @c(put) y @c(get), para manipular la tabla de operación y tipo:

#     - @c[(put ⟨op⟩ ⟨type⟩ ⟨item⟩)] installs the @c[(item)] in the table, indexed
#       by the @c[(op)] and the @c[(type)].
    - @c[(put ⟨op⟩ ⟨type⟩ ⟨item⟩)] Instala el @c[(item)] en la tabla, indexado
      por el @c[(op)] y el @c[(type)].

#     - @c[(get ⟨op⟩ ⟨type⟩)] looks up the @c[(op)], @c[(type)] entry in the table
#       and returns the item found there.  If no item is found, @c(get) returns
#       false.
    - @c[(get ⟨op⟩ ⟨type⟩)] Mira la entrada @c[(op)], @c[(type)] en la tabla y
      devuelve el elemento encontrado allí. Si no se encuentra ningún elemento,
      @c(get) devuelve false.

#     For now, we can assume that @c(put) and @c(get) are included in our
#     language. In @l(#Chapter 3) (section @l(#3.3.3)) we will see how to implement these
#     and other operations for manipulating tables.
    Por ahora, podemos asumir eso @c(put) y @c(get) estamos incluidos en nuestro
    lenguaje. En el @l(#Capitulo 3) (seccion @l(#3.3.3)) veremos
    cómo implementar estas y otras operaciones para manipular tablas.

#     Here is how data-directed programming can be used in the complex-number
#     system.  Ben, who developed the rectangular representation, implements his
#     code just as he did originally. He defines a collection of procedures, or a
#     @e(package), and interfaces these to the rest of the system by adding entries
#     to the table that tell the system how to operate on rectangular numbers. This
#     is accomplished by calling the following procedure:
    Aquí es cómo la programación dirigida a datos puede ser utilizada en el
    sistema de números complejos. Ben, que desarrolló la representación
    rectangular, implementa su código tal como lo hizo originalmente. Él define
    una colección de procedimientos, o un @e(paquete), e interfaces con el resto
    del sistema mediante la adición de entradas a la tabla que le dicen al
    sistema cómo operar en números rectangulares. Esto se logra llamando al
    siguiente procedimiento:

#     ..src > scheme
#       (define (install-rectangular-package)
#         ;; internal procedures
#         (define (real-part z) (car z))
#         (define (imag-part z) (cdr z))
#         (define (make-from-real-imag x y)
#           (cons x y))
#         (define (magnitude z)
#           (sqrt (+ (square (real-part z))
#                    (square (imag-part z)))))
#         (define (angle z)
#           (atan (imag-part z) (real-part z)))
#         (define (make-from-mag-ang r a)
#           (cons (* r (cos a)) (* r (sin a))))
#         ;; interface to the rest of the system
#         (define (tag x)
#           (attach-tag 'rectangular x))
#         (put 'real-part '(rectangular) real-part)
#         (put 'imag-part '(rectangular) imag-part)
#         (put 'magnitude '(rectangular) magnitude)
#         (put 'angle '(rectangular) angle)
#         (put 'make-from-real-imag 'rectangular
#              (lambda (x y)
#                (tag (make-from-real-imag x y))))
#         (put 'make-from-mag-ang 'rectangular
#              (lambda (r a)
#                (tag (make-from-mag-ang r a))))
#         'done)
#     < src..
    ..src > scheme
      (define (install-rectangular-package)
        ;; internal procedures
        (define (real-part z) (car z))
        (define (imag-part z) (cdr z))
        (define (make-from-real-imag x y)
          (cons x y))
        (define (magnitude z)
          (sqrt (+ (square (real-part z))
                   (square (imag-part z)))))
        (define (angle z)
          (atan (imag-part z) (real-part z)))
        (define (make-from-mag-ang r a)
          (cons (* r (cos a)) (* r (sin a))))
        ;; interface to the rest of the system
        (define (tag x)
          (attach-tag 'rectangular x))
        (put 'real-part '(rectangular) real-part)
        (put 'imag-part '(rectangular) imag-part)
        (put 'magnitude '(rectangular) magnitude)
        (put 'angle '(rectangular) angle)
        (put 'make-from-real-imag 'rectangular
             (lambda (x y)
               (tag (make-from-real-imag x y))))
        (put 'make-from-mag-ang 'rectangular
             (lambda (r a)
               (tag (make-from-mag-ang r a))))
        'done)
    < src..

#     Notice that the internal procedures here are the same procedures from
#     @l(#2.4.1) that Ben wrote when he was working in isolation. No changes are
#     necessary in order to interface them to the rest of the system. Moreover,
#     since these procedure definitions are internal to the installation procedure,
#     Ben needn't worry about name conflicts with other procedures outside the
#     rectangular package. To interface these to the rest of the system, Ben
#     installs his @c(real-part) procedure under the operation name @c(real-part)
#     and the type @c[(rectangular)], and similarly for the other selectors.@n(111)
#     The interface also defines the constructors to be used by the external
#     system.@n(112) These are identical to Ben's internally defined constructors,
#     except that they attach the tag.
    Observe que los procedimientos internos aquí son los mismos procedimientos
    de la seccion @l(#2.4.1) que Ben escribió cuando estaba trabajando en
    aislamiento. No es necesario realizar cambios para interconectarlos con el
    resto del sistema. Además, como estas definiciones de procedimientos son
    internas al procedimiento de instalación, Ben no necesita preocuparse por
    los conflictos de nombres con otros procedimientos fuera del paquete
    rectangular. Para interconectar estos con el resto del sistema, Ben instala
    su procedimiento @c(real-part) bajo el nombre de operación @c(real-part) y
    el tipo @c[(rectangular)], y de manera similar para los otros
    selectores.@n(111) La interfaz también define los constructores para
    ser utilizados por el sistema externo.@n(112) Estos son idénticos a
    los constructores definidos internamente de Ben, excepto que adjuntan la
    etiqueta.

#     Alyssa's polar package is analogous:
    El paquete polar de Alyssa es análogo:

#     ..src > scheme
#       (define (install-polar-package)
#         ;; internal procedures
#         (define (magnitude z) (car z))
#         (define (angle z) (cdr z))
#         (define (make-from-mag-ang r a) (cons r a))
#         (define (real-part z)
#           (* (magnitude z) (cos (angle z))))
#         (define (imag-part z)
#           (* (magnitude z) (sin (angle z))))
#         (define (make-from-real-imag x y)
#           (cons (sqrt (+ (square x) (square y)))
#                 (atan y x)))
#         ;; interface to the rest of the system
#         (define (tag x) (attach-tag 'polar x))
#         (put 'real-part '(polar) real-part)
#         (put 'imag-part '(polar) imag-part)
#         (put 'magnitude '(polar) magnitude)
#         (put 'angle '(polar) angle)
#         (put 'make-from-real-imag 'polar
#              (lambda (x y)
#                (tag (make-from-real-imag x y))))
#         (put 'make-from-mag-ang 'polar
#              (lambda (r a)
#                (tag (make-from-mag-ang r a))))
#         'done)
#     < src..
    ..src > scheme
      (define (install-polar-package)
        ;; internal procedures
        (define (magnitude z) (car z))
        (define (angle z) (cdr z))
        (define (make-from-mag-ang r a) (cons r a))
        (define (real-part z)
          (* (magnitude z) (cos (angle z))))
        (define (imag-part z)
          (* (magnitude z) (sin (angle z))))
        (define (make-from-real-imag x y)
          (cons (sqrt (+ (square x) (square y)))
                (atan y x)))
        ;; interface to the rest of the system
        (define (tag x) (attach-tag 'polar x))
        (put 'real-part '(polar) real-part)
        (put 'imag-part '(polar) imag-part)
        (put 'magnitude '(polar) magnitude)
        (put 'angle '(polar) angle)
        (put 'make-from-real-imag 'polar
             (lambda (x y)
               (tag (make-from-real-imag x y))))
        (put 'make-from-mag-ang 'polar
             (lambda (r a)
               (tag (make-from-mag-ang r a))))
        'done)
    < src..

#     Even though Ben and Alyssa both still use their original procedures defined
#     with the same names as each other's (e.g., @c(real-part)), these definitions
#     are now internal to different procedures (see @l(#1.1.8)), so there is no name
#     conflict.
    A pesar de que Ben y Alyssa todavía usan sus procedimientos originales
    definidos con los mismos nombres que otros (por ejemplo, @c(real-part)),
    estas definiciones ahora son internas a diferentes procedimientos (ver
    @l(#1.1.8)), por lo que no hay conflicto de nombres.

#     The complex-arithmetic selectors access the table by means of a general
#     @"(operation) procedure called @c(apply-generic), which applies a generic
#     operation to some arguments. @c(Apply-generic) looks in the table under the
#     name of the operation and the types of the arguments and applies the resulting
#     procedure if one is present:@n(113)
    Los selectores aritméticos complejos acceden a la tabla por medio de un
    procedimiento de @"(operación) general llamado @c(apply-generic), que aplica
    una operación genérica a algunos argumentos. @c(Apply-generic) Mira en la
    tabla bajo el nombre de la operación y los tipos de los argumentos y aplica
    el procedimiento resultante si uno está presente:@n(113)

#     ..src > scheme
#       (define (apply-generic op . args)
#         (let ((type-tags (map type-tag args)))
#           (let ((proc (get op type-tags)))
#             (if proc
#                 (apply proc (map contents args))
#                 (error
#                   "No method for these types:
#                    APPLY-GENERIC"
#                   (list op type-tags))))))
#     < src..
    ..src > scheme
      (define (apply-generic op . args)
        (let ((type-tags (map type-tag args)))
          (let ((proc (get op type-tags)))
            (if proc
                (apply proc (map contents args))
                (error
                  "No method for these types:
                   APPLY-GENERIC"
                  (list op type-tags))))))
    < src..

#     Using @c(apply-generic), we can define our generic selectors as follows:
    Usando @c(apply-generic), podemos definir nuestros selectores genéricos como
    sigue:

#     ..src > scheme
#       (define (real-part z)
#         (apply-generic 'real-part z))
#       (define (imag-part z)
#         (apply-generic 'imag-part z))
#       (define (magnitude z)
#         (apply-generic 'magnitude z))
#       (define (angle z)
#         (apply-generic 'angle z))
#     < src..
    ..src > scheme
      (define (real-part z)
        (apply-generic 'real-part z))
      (define (imag-part z)
        (apply-generic 'imag-part z))
      (define (magnitude z)
        (apply-generic 'magnitude z))
      (define (angle z)
        (apply-generic 'angle z))
    < src..

#     Observe that these do not change at all if a new representation is added to
#     the system.
    Observe que éstos no cambian en absoluto si una nueva representación se
    agrega al sistema.

#     We can also extract from the table the constructors to be used by the programs
#     external to the packages in making complex numbers from real and imaginary
#     parts and from magnitudes and angles. As in section @l(#2.4.2), we construct
#     rectangular numbers whenever we have real and imaginary parts, and polar
#     numbers whenever we have magnitudes and angles:
    También podemos extraer de la tabla los constructores que serán utilizados
    por los programas externos a los paquetes para hacer números complejos de
    partes reales e imaginarias y de magnitudes y ángulos. Como en
    @l(#2.4.2), construimos números rectangulares siempre que tengamos
    partes reales e imaginarias y números polares siempre que tengamos
    magnitudes y ángulos:

#     ..src > scheme
#       (define (make-from-real-imag x y)
#         ((get 'make-from-real-imag
#               'rectangular)
#          x y))
#
#       (define (make-from-mag-ang r a)
#         ((get 'make-from-mag-ang
#               'polar)
#          r a))
#     < src..
    ..src > scheme
      (define (make-from-real-imag x y)
        ((get 'make-from-real-imag
              'rectangular)
         x y))

      (define (make-from-mag-ang r a)
        ((get 'make-from-mag-ang
              'polar)
         r a))
    < src..

#     :: @t(Exercise 2.73) :: @l(#2.3.2) described a program that performs symbolic
#        differentiation:
    :: @t(Ejercicio 2.73) :: @l(#2.3.2) describe un programa que realiza
    la diferenciación simbólica:

#        ..src > scheme
#          (define (deriv exp var)
#            (cond ((number? exp) 0)
#                  ((variable? exp)
#                   (if (same-variable? exp var) 1 0))
#                  ((sum? exp)
#                   (make-sum (deriv (addend exp) var)
#                             (deriv (augend exp) var)))
#                  ((product? exp)
#                   (make-sum
#                     (make-product
#                      (multiplier exp)
#                      (deriv (multiplicand exp) var))
#                     (make-product
#                      (deriv (multiplier exp) var)
#                      (multiplicand exp))))
#                  ⟨more rules can be added here⟩
#                  (else (error "unknown expression type:
#                                DERIV" exp))))
#        < src..
       ..src > scheme
         (define (deriv exp var)
           (cond ((number? exp) 0)
                 ((variable? exp)
                  (if (same-variable? exp var) 1 0))
                 ((sum? exp)
                  (make-sum (deriv (addend exp) var)
                            (deriv (augend exp) var)))
                 ((product? exp)
                  (make-sum
                    (make-product
                     (multiplier exp)
                     (deriv (multiplicand exp) var))
                    (make-product
                     (deriv (multiplier exp) var)
                     (multiplicand exp))))
                 ⟨more rules can be added here⟩
                 (else (error "unknown expression type:
                               DERIV" exp))))
       < src..

#        We can regard this program as performing a dispatch on the type of the
#        expression to be differentiated. In this situation the @"(type tag) of the
#        datum is the algebraic operator symbol (such as @c(+)) and the operation
#        being performed is @c(deriv). We can transform this program into
#        data-directed style by rewriting the basic derivative procedure as
       Podemos considerar este programa como realizando un despacho sobre el
       tipo de la expresión a diferenciar. En esta situación la @"(etiqueta) de
       @"(tipo) del datum es el símbolo algebraico del operador (tal como @c(+))
       y la operación que se está realizando es @c(deriv). Podemos transformar
       este programa en estilo dirigido a datos reescribiendo el procedimiento
       derivativo básico como

#        ..src > scheme
#          (define (deriv exp var)
#             (cond ((number? exp) 0)
#                   ((variable? exp)
#                     (if (same-variable? exp var)
#                         1
#                         0))
#                   (else ((get 'deriv (operator exp))
#                          (operands exp)
#                          var))))
#
#          (define (operator exp) (car exp))
#          (define (operands exp) (cdr exp))
#        < src..
       ..src > scheme
         (define (deriv exp var)
            (cond ((number? exp) 0)
                  ((variable? exp)
                    (if (same-variable? exp var)
                        1
                        0))
                  (else ((get 'deriv (operator exp))
                         (operands exp)
                         var))))

         (define (operator exp) (car exp))
         (define (operands exp) (cdr exp))
       < src..

#        1. Explain what was done above. Why can't we assimilate the predicates
#           @c(number?) and @c(variable?) into the data-directed dispatch?
       1. Explique lo que se hizo arriba. ¿Por qué no podemos asimilar los
          predicados @c(number?) y @c(variable?) en el envío dirigido a datos?

#        2. Write the procedures for derivatives of sums and products, and the
#           auxiliary code required to install them in the table used by the program
#           above.
       2. Escribir los procedimientos para derivados de sumas y productos, y el
          código auxiliar necesario para instalarlos en la tabla utilizada por
          el programa anterior.

#        3. Choose any additional differentiation rule that you like, such as the
#           one for exponents (@l(#Exercise 2.56)), and install it in this
#           data-directed system.
       3. Elija cualquier regla de diferenciación que desee, como la de los
          exponentes (@l(#Ejercicio 2.56) ), e instálela en este
          sistema dirigido a datos.

#        4. In this simple algebraic manipulator the type of an expression is the
#           algebraic operator that binds it together. Suppose, however, we indexed
#           the procedures in the opposite way, so that the dispatch line in
#           @c(deriv) looked like
       4. En este simple manipulador algebraico el tipo de una expresión es el
          operador algebraico que lo une. Supongamos, sin embargo, que indexamos
          los procedimientos de manera opuesta, de modo que la línea de envío en
          @c(deriv) parecía

#           ..src > scheme
#             ((get (operator exp) 'deriv)
#              (operands exp) var)
#           < src..
          ..src > scheme
            ((get (operator exp) 'deriv)
             (operands exp) var)
          < src..

#           What corresponding changes to the derivative system are required?
          ¿Qué cambios correspondientes al sistema derivativo se requieren?

#     :: @t(Exercise 2.74) :: Insatiable Enterprises, Inc., is a highly
#        decentralized conglomerate company consisting of a large number of
#        independent divisions located all over the world. The company's computer
#        facilities have just been interconnected by means of a clever
#        network-interfacing scheme that makes the entire network appear to any user
#        to be a single computer. Insatiable's president, in her first attempt to
#        exploit the ability of the network to extract administrative information
#        from division files, is dismayed to discover that, although all the
#        division files have been implemented as data structures in Scheme, the
#        particular data structure used varies from division to division. A meeting
#        of division managers is hastily called to search for a strategy to
#        integrate the files that will satisfy headquarters' needs while preserving
#        the existing autonomy of the divisions.
    :: @t(Ejercicio 2.74) :: Insatiable Enterprises, Inc., es una empresa de
       conglomerados altamente descentralizada que consta de un gran número de
       divisiones independientes ubicadas en todo el mundo. Las instalaciones
       informáticas de la empresa han sido interconectadas por medio de un
       ingenioso esquema de interconexión de red que hace que toda la red
       aparezca a cualquier usuario como una sola computadora. El presidente de
       Insatiable, en su primer intento de explotar la capacidad de la red para
       extraer información administrativa de los archivos de división, está
       consternado al descubrir que, aunque todos los archivos de división se
       han implementado como estructuras de datos en Scheme, A la división. Una
       reunión de los gerentes de la división se llama a toda prisa para buscar
       una estrategia para integrar los archivos que satisfagan las necesidades
       de la sede,

#        Show how such a strategy can be implemented with data-directed
#        programming. As an example, suppose that each division's personnel records
#        consist of a single file, which contains a set of records keyed on
#        employees' names. The structure of the set varies from division to
#        division. Furthermore, each employee's record is itself a set (structured
#        differently from division to division) that contains information keyed
#        under identifiers such as @c(address) and @c(salary). In particular:
       Mostrar cómo se puede implementar una estrategia de este tipo con la
       programación dirigida a datos. Por ejemplo, supongamos que los registros
       de personal de cada división constan de un solo archivo, que contiene un
       conjunto de registros escritos en los nombres de los empleados. La
       estructura del conjunto varía de división a división. Además, el registro
       de cada empleado es en sí mismo un conjunto (estructurado de forma
       diferente de división a división) que contiene información codificada
       bajo identificadores como @c(address) y @c(salary). En particular:

#        1. Implement for headquarters a @c(get-record) procedure that retrieves a
#           specified employee's record from a specified personnel file. The
#           procedure should be applicable to any division's file. Explain how the
#           individual divisions' files should be structured. In particular, what
#           type information must be supplied?
       1. Implementar para la sede un procedimiento @c(get-record) que recupera
          el registro de un empleado especificado de un archivo de personal
          especificado. El procedimiento debe ser aplicable a cualquier archivo
          de la división. Explique cómo deben estructurarse los archivos de las
          divisiones individuales. En particular, ¿qué tipo de información debe
          suministrarse?

#        2. Implement for headquarters a @c(get-salary) procedure that returns the
#           salary information from a given employee's record from any division's
#           personnel file. How should the record be structured in order to make
#           this operation work?
       2. Implementar para la sede un procedimiento @c(get-salary) que devuelva
          la información de salario del registro de un empleado dado del archivo
          personal de cualquier división. ¿Cómo debe estructurarse el registro
          para que esta operación funcione?

#        3. Implement for headquarters a @c(find-employee-record) procedure. This
#           should search all the divisions' files for the record of a given
#           employee and return the record. Assume that this procedure takes as
#           arguments an employee's name and a list of all the divisions' files.
       3. Implementar para la sede un procedimiento @c(find-employee-record). Esto debe buscar todos los archivos de las divisiones
          para el registro de un empleado dado y devolver el
          registro. Supongamos que este procedimiento toma como argumentos el
          nombre de un empleado y una lista de todos los archivos de las
          divisiones.

#        4. When Insatiable takes over a new company, what changes must be made in
#           order to incorporate the new personnel information into the central
#           system?
       4. Cuando Insatiable se hace cargo de una nueva empresa, ¿qué cambios se
          deben hacer para incorporar la nueva información de personal al
          sistema central?

# **** Message passing
**** Paso de mensajes

#      The key idea of data-directed programming is to handle generic operations in
#      programs by dealing explicitly with operation-and-type tables, such as the
#      table in @l(#Figure 2.22). The style of programming we used in section @l(#2.4.2)
#      organized the required dispatching on type by having each operation take care
#      of its own dispatching. In effect, this decomposes the operation-and-type
#      table into rows, with each generic operation procedure representing a row of
#      the table.
     La idea clave de la programación dirigida a datos es manejar operaciones
     genéricas en programas al tratar explícitamente con tablas de operación y
     tipo, como la tabla de la @l(#Figura 2.22). El estilo de
     programación que usamos en la seccion @l(#2.4.2) organizó el despacho necesario
     en el tipo, haciendo que cada operación se encargara de su propio
     despacho. En efecto, esto descompone la tabla de operación y tipo en filas,
     con cada procedimiento de operación genérica representando una fila de la
     tabla.

#      An alternative implementation strategy is to decompose the table into columns
#      and, instead of using @"(intelligent operations) that dispatch on data types,
#      to work with @"(intelligent data objects) that dispatch on operation names. We
#      can do this by arranging things so that a data object, such as a rectangular
#      number, is represented as a procedure that takes as input the required
#      operation name and performs the operation indicated. In such a discipline,
#      @c(make-from-real-imag) could be written as
     Una estrategia de implementación alternativa es descomponer la tabla en
     columnas y, en lugar de utilizar @"(operaciones inteligentes) que
     distribuyen en tipos de datos, para trabajar con @"(objetos de datos
     inteligentes) que envían los nombres de operación. Podemos hacerlo
     organizando las cosas para que un objeto de datos, como un número
     rectangular, se represente como un procedimiento que toma como entrada el
     nombre de operación requerido y realiza la operación indicada. En tal
     disciplina,@c(make-from-real-imag) podría escribirse como

#      ..src > scheme
#        (define (make-from-real-imag x y)
#          (define (dispatch op)
#            (cond ((eq? op 'real-part) x)
#                  ((eq? op 'imag-part) y)
#                  ((eq? op 'magnitude)
#                   (sqrt (+ (square x) (square y))))
#                  ((eq? op 'angle) (atan y x))
#                  (else
#                   (error "Unknown op:
#                    MAKE-FROM-REAL-IMAG" op))))
#          dispatch)
#      < src..
     ..src > scheme
       (define (make-from-real-imag x y)
         (define (dispatch op)
           (cond ((eq? op 'real-part) x)
                 ((eq? op 'imag-part) y)
                 ((eq? op 'magnitude)
                  (sqrt (+ (square x) (square y))))
                 ((eq? op 'angle) (atan y x))
                 (else
                  (error "Unknown op:
                   MAKE-FROM-REAL-IMAG" op))))
         dispatch)
     < src..

#      The corresponding @c(apply-generic) procedure, which applies a generic
#      operation to an argument, now simply feeds the operation's name to the data
#      object and lets the object do the work:@n(114)
     El procedimiento @c(apply-generic) correspondiente, que aplica una
     operación genérica a un argumento, ahora simplemente alimenta el nombre de
     la operación al objeto de datos y permite al objeto realizar el trabajo:
    @n(114)

#      ..src > scheme
#        (define (apply-generic op arg) (arg op))
#      < src..
     ..src > scheme
       (define (apply-generic op arg) (arg op))
     < src..

#      Note that the value returned by @c(make-from-real-imag) is a procedure––the
#      internal @c(dispatch) procedure. This is the procedure that is invoked when
#      @c(apply-generic) requests an operation to be performed.
     Tenga en cuenta que el valor devuelto por @c(make-from-real-imag) es un
     procedimiento: el procedimiento @c(dispatch) interno. Este es el
     procedimiento que se invoca cuando se @c(apply-generic) solicita una
     operación a realizar.

#      This style of programming is called @e(message passing). The name comes from
#      the image that a data object is an entity that receives the requested
#      operation name as a @"(message.)  We have already seen an example of message
#      passing in section @l(#2.1.3), where we saw how @c(cons), @c(car), and @c(cdr) could
#      be defined with no data objects but only procedures. Here we see that message
#      passing is not a mathematical trick but a useful technique for organizing
#      systems with generic operations. In the remainder of this chapter we will
#      continue to use data-directed programming, rather than message passing, to
#      discuss generic arithmetic operations. In @l(#Chapter 3) we will return to
#      message passing, and we will see that it can be a powerful tool for
#      structuring simulation programs.
     Este estilo de programación se llama @e(pasaje de mensajes). El nombre
     proviene de la imagen de que un objeto de datos es una entidad que recibe
     el nombre de operación solicitado como un @"(mensaje. )  Ya hemos visto un
     ejemplo de paso de mensajes en la seccion @l(#2.1.3), donde vimos cómo
     @c(cons), @c(car) y @c(cdr) podría definirse sin objetos de datos, pero
     sólo los procedimientos. Aquí vemos que el paso del mensaje no es un truco
     matemático sino una técnica útil para organizar sistemas con operaciones
     genéricas. En lo que resta de este capítulo, continuaremos utilizando la
     programación dirigida a datos, en lugar del paso de mensajes, para discutir
     las operaciones aritméticas genéricas. En el @l(#Capitulo 3)
     volveremos al paso del mensaje,

#      :: @t(Exercise 2.75) :: Implement the constructor @c(make-from-mag-ang) in
#         message-passing style. This procedure should be analogous to the
#         @c(make-from-real-imag) procedure given above.
     :: @t(Ejercicio 2.75) :: Implementar el constructor @c(make-from-mag-ang)
        en el estilo de paso de mensajes. Este procedimiento debe ser análogo al
        procedimiento @c(make-from-real-imag) dado anteriormente.

#      :: @t(Exercise 2.76) :: As a large system with generic operations evolves, new
#         types of data objects or new operations may be needed.  For each of the
#         three strategies––generic operations with explicit dispatch, data-directed
#         style, and message-passing-style––describe the changes that must be made to
#         a system in order to add new types or new operations. Which organization
#         would be most appropriate for a system in which new types must often be
#         added?  Which would be most appropriate for a system in which new
#         operations must often be added?
     :: @t(Ejercicio 2.76) :: A medida que evoluciona un sistema grande con
        operaciones genéricas, pueden ser necesarios nuevos tipos de objetos de
        datos o nuevas operaciones. Para cada una de las tres estrategias:
        operaciones genéricas con despacho explícito, estilo dirigido a datos y
        estilo de paso de mensajes, describa los cambios que deben realizarse en
        un sistema para agregar nuevos tipos o nuevas operaciones. ¿Qué
        organización sería más apropiada para un sistema en el que a menudo se
        deban añadir nuevos tipos? ¿Cuál sería el más apropiado para un sistema
        en el cual las operaciones nuevas a menudo deben agregarse?

# ** 2.5 <> Systems with Generic Operations
** 2.5 <> Sistemas con operaciones genéricas

#   In the previous section, we saw how to design systems in which data objects
#   can be represented in more than one way. The key idea is to link the code that
#   specifies the data operations to the several representations by means of
#   generic interface procedures. Now we will see how to use this same idea not
#   only to define operations that are generic over different representations but
#   also to define operations that are generic over different kinds of arguments.
#   We have already seen several different packages of arithmetic operations: the
#   primitive arithmetic (@c(+), @c(-), @c(*), @c(/)) built into our language, the
#   rational-number arithmetic (@c(add-rat), @c(sub-rat), @c(mul-rat),
#   @c(div-rat)) of section @l(#2.1.1), and the complex-number arithmetic that we
#   implemented in section @l(#2.4.3). We will now use data-directed techniques to
#   construct a package of arithmetic operations that incorporates all the
#   arithmetic packages we have already constructed.
  En la sección anterior vimos cómo diseñar sistemas en los que los objetos de
  datos pueden representarse de más de una manera. La idea clave es vincular el
  código que especifica las operaciones de datos a las diversas representaciones
  mediante procedimientos de interfaz genéricos. Ahora veremos cómo usar esta
  misma idea no sólo para definir operaciones que son genéricas sobre diferentes
  representaciones sino también para definir operaciones que son genéricas sobre
  diferentes tipos de argumentos. Ya hemos visto varios paquetes diferentes de
  operaciones aritméticas: la aritmética primitiva (@c(+), @c(-), @c(*), @c(/))
  integrado en nuestro idioma, la aritmética de números racionales (
  @c(add-rat), @c(sub-rat), @c(mul-rat), @c(div-rat)) de la seccion @l(#2.1.1), y la
  aritmética de números complejos que hemos implementado en la seccion @l(#2.4.3<>2.4 .3).

#   @l(#Figure 2.23) shows the structure of the system we shall build. Notice the
#   abstraction barriers. From the perspective of someone using @"(numbers,) there
#   is a single procedure @c(add) that operates on whatever numbers are
#   supplied. @c(Add) is part of a generic interface that allows the separate
#   ordinary-arithmetic, rational-arithmetic, and complex-arithmetic packages to
#   be accessed uniformly by programs that use numbers. Any individual arithmetic
#   package (such as the complex package) may itself be accessed through generic
#   procedures (such as @c(add-complex)) that combine packages designed for
#   different representations (such as rectangular and polar). Moreover, the
#   structure of the system is additive, so that one can design the individual
#   arithmetic packages separately and combine them to produce a generic
#   arithmetic system.
  @l(#Figura 2.23) muestra la estructura del sistema que
  construiremos. Observe las barreras de abstracción. Desde la perspectiva de
  alguien que usa @"(números,) hay un procedimiento único @c(add) que funciona
  en cualquier número que se suministran. @c(Add) Es parte de una interfaz
  genérica que permite que los paquetes separados de aritmética ordinaria,
  aritmética racional y aritmética compleja sean accesibles uniformemente por
  programas que usan números. Cualquier paquete aritmético individual (tal como
  el paquete complejo) se puede acceder por medio de procedimientos genéricos
  (tales como @c(add-complex)) que combinan paquetes diseñados para diferentes
  representaciones (tales como rectangulares y polares). Además, la estructura
  del sistema es aditiva,

#   ..figure > @t(Figure 2.23) Generic arithmetic system.
  ..figure > @t(Figura 2.23) Sistema aritmético genérico.

#     ..art >
#                                Programs that use numbers
#                                   ╭─────────────────╮
#       ────────────────────────────┤ add sub mul div ├────────────────────
#                                   ╰─────────────────╯
#                                Generic arithmetic package
#         ╭─────────────────╮   ╭─────────────────────────╮
#         │ add-rat sub-rat │   │ add-complex sub-complex │   ╭─────────╮
#       ──┤                 ├─┬─┤                         ├─┬─┤ + - * / ├──
#         │ mul-rat div-rat │ │ │ mul-complex div-complex │ │ ╰─────────╯
#         ╰─────────────────╯ │ ╰─────────────────────────╯ │
#              Rational       │     Complex artithmetic     │   Ordinary
#             arithmetic      ├──────────────┬──────────────┤  arithmetic
#                             │ Rectangular  │     Polar    │
#       ──────────────────────┴──────────────┴──────────────┴──────────────
#                     List structure and primitive machine arithmetic
#     < art..
    ..art >
                               Programs that use numbers
                                  ╭─────────────────╮
      ────────────────────────────┤ add sub mul div ├────────────────────
                                  ╰─────────────────╯
                               Generic arithmetic package
        ╭─────────────────╮   ╭─────────────────────────╮
        │ add-rat sub-rat │   │ add-complex sub-complex │   ╭─────────╮
      ──┤                 ├─┬─┤                         ├─┬─┤ + - * / ├──
        │ mul-rat div-rat │ │ │ mul-complex div-complex │ │ ╰─────────╯
        ╰─────────────────╯ │ ╰─────────────────────────╯ │
             Rational       │     Complex artithmetic     │   Ordinary
            arithmetic      ├──────────────┬──────────────┤  arithmetic
                            │ Rectangular  │     Polar    │
      ──────────────────────┴──────────────┴──────────────┴──────────────
                    List structure and primitive machine arithmetic
    < art..

# @ ..img > img/chap2/Fig2.23b.std.svg
@ ..img > img/chap2/Fig2.23b.std.svg

# *** 2.5.1 <> Generic Arithmetic Operations
*** 2.5.1 <> Operaciones aritméticas genéricas

#     The task of designing generic arithmetic operations is analogous to that of
#     designing the generic complex-number operations. We would like, for instance,
#     to have a generic addition procedure @c(add) that acts like ordinary primitive
#     addition @c(+) on ordinary numbers, like @c(add-rat) on rational numbers, and
#     like @c(add-complex) on complex numbers. We can implement @c(add), and the
#     other generic arithmetic operations, by following the same strategy we used in
#     @l(#2.4.3) to implement the generic selectors for complex numbers. We will
#     attach a type tag to each kind of number and cause the generic procedure to
#     dispatch to an appropriate package according to the data type of its
#     arguments.
    La tarea de diseñar operaciones aritméticas genéricas es análoga a la de
    diseñar las operaciones genéricas de números complejos. Nos gustaría, por
    ejemplo, tener un procedimiento de adición genérica @c(add) que actúa como
    adición primitiva @c(+) ordinaria en números ordinarios, como @c(add-rat) en
    números racionales, y como @c(add-complex) en números complejos. Podemos
    implementar @c(add), y las otras operaciones aritméticas genéricas,
    siguiendo la misma estrategia que usamos en la seccion @l(#2.4.3) para
    implementar los selectores genéricos para números complejos. Adjuntaremos
    una etiqueta de tipo a cada tipo de número y haremos que el procedimiento
    genérico se envíe a un paquete apropiado según el tipo de datos de sus
    argumentos.

#     The generic arithmetic procedures are defined as follows:
    Los procedimientos aritméticos genéricos se definen de la siguiente manera:

#     ..src > scheme
#       (define (add x y) (apply-generic 'add x y))
#       (define (sub x y) (apply-generic 'sub x y))
#       (define (mul x y) (apply-generic 'mul x y))
#       (define (div x y) (apply-generic 'div x y))
#     < src..
    ..src > scheme
      (define (add x y) (apply-generic 'add x y))
      (define (sub x y) (apply-generic 'sub x y))
      (define (mul x y) (apply-generic 'mul x y))
      (define (div x y) (apply-generic 'div x y))
    < src..

#     We begin by installing a package for handling @e(ordinary) numbers, that is,
#     the primitive numbers of our language. We will tag these with the symbol
#     @c(scheme-number). The arithmetic operations in this package are the primitive
#     arithmetic procedures (so there is no need to define extra procedures to
#     handle the untagged numbers). Since these operations each take two arguments,
#     they are installed in the table keyed by the list @c[(scheme-number
#     scheme-number)]:
    Comenzamos por instalar un paquete para manejar números @e(ordinarios), es
    decir, los números primitivos de nuestro lenguaje. Los etiquetaremos con el
    símbolo @c(scheme-number). Las operaciones aritméticas en este paquete son
    los procedimientos aritméticos primitivos (por lo que no hay necesidad de
    definir procedimientos adicionales para manejar los números sin
    etiquetar). Dado que estas operaciones toman dos argumentos, se instalan en
    la tabla marcada por la lista @c[(scheme-number scheme-number)]:

#     ..src > scheme
#       (define (install-scheme-number-package)
#         (define (tag x)
#           (attach-tag 'scheme-number x))
#         (put 'add '(scheme-number scheme-number)
#              (lambda (x y) (tag (+ x y))))
#         (put 'sub '(scheme-number scheme-number)
#              (lambda (x y) (tag (- x y))))
#         (put 'mul '(scheme-number scheme-number)
#              (lambda (x y) (tag (* x y))))
#         (put 'div '(scheme-number scheme-number)
#              (lambda (x y) (tag (/ x y))))
#         (put 'make 'scheme-number
#              (lambda (x) (tag x)))
#         'done)
#     < src..
    ..src > scheme
      (define (install-scheme-number-package)
        (define (tag x)
          (attach-tag 'scheme-number x))
        (put 'add '(scheme-number scheme-number)
             (lambda (x y) (tag (+ x y))))
        (put 'sub '(scheme-number scheme-number)
             (lambda (x y) (tag (- x y))))
        (put 'mul '(scheme-number scheme-number)
             (lambda (x y) (tag (* x y))))
        (put 'div '(scheme-number scheme-number)
             (lambda (x y) (tag (/ x y))))
        (put 'make 'scheme-number
             (lambda (x) (tag x)))
        'done)
    < src..

#     Users of the Scheme-number package will create (tagged) ordinary numbers by
#     means of the procedure:
    Los usuarios del paquete Scheme-number crearán (etiquetados) números
    ordinarios mediante el procedimiento:

#     ..src > scheme
#       (define (make-scheme-number n)
#         ((get 'make 'scheme-number) n))
#     < src..
    ..src > scheme
      (define (make-scheme-number n)
        ((get 'make 'scheme-number) n))
    < src..

#     Now that the framework of the generic arithmetic system is in place, we can
#     readily include new kinds of numbers. Here is a package that performs rational
#     arithmetic. Notice that, as a benefit of additivity, we can use without
#     modification the rational-number code from @l(#2.1.1) as the internal
#     procedures in the package:
    Ahora que el marco del sistema aritmético genérico está en su lugar, podemos
    fácilmente incluir nuevos tipos de números. Aquí hay un paquete que realiza
    la aritmética racional. Tenga en cuenta que, como un beneficio de la
    aditividad, podemos utilizar sin modificación el código de números
    racionales de la seccion @l(#2.1.1) como los procedimientos internos en el
    paquete:

#     ..src > scheme
#       (define (install-rational-package)
#         ;; internal procedures
#         (define (numer x) (car x))
#         (define (denom x) (cdr x))
#         (define (make-rat n d)
#           (let ((g (gcd n d)))
#             (cons (/ n g) (/ d g))))
#         (define (add-rat x y)
#           (make-rat (+ (* (numer x) (denom y))
#                        (* (numer y) (denom x)))
#                     (* (denom x) (denom y))))
#         (define (sub-rat x y)
#           (make-rat (- (* (numer x) (denom y))
#                        (* (numer y) (denom x)))
#                     (* (denom x) (denom y))))
#         (define (mul-rat x y)
#           (make-rat (* (numer x) (numer y))
#                     (* (denom x) (denom y))))
#         (define (div-rat x y)
#           (make-rat (* (numer x) (denom y))
#                     (* (denom x) (numer y))))
#         ;; interface to rest of the system
#         (define (tag x) (attach-tag 'rational x))
#         (put 'add '(rational rational)
#              (lambda (x y) (tag (add-rat x y))))
#         (put 'sub '(rational rational)
#              (lambda (x y) (tag (sub-rat x y))))
#         (put 'mul '(rational rational)
#              (lambda (x y) (tag (mul-rat x y))))
#         (put 'div '(rational rational)
#              (lambda (x y) (tag (div-rat x y))))
#         (put 'make 'rational
#              (lambda (n d) (tag (make-rat n d))))
#         'done)
#
#       (define (make-rational n d)
#         ((get 'make 'rational) n d))
#     < src..
    ..src > scheme
      (define (install-rational-package)
        ;; internal procedures
        (define (numer x) (car x))
        (define (denom x) (cdr x))
        (define (make-rat n d)
          (let ((g (gcd n d)))
            (cons (/ n g) (/ d g))))
        (define (add-rat x y)
          (make-rat (+ (* (numer x) (denom y))
                       (* (numer y) (denom x)))
                    (* (denom x) (denom y))))
        (define (sub-rat x y)
          (make-rat (- (* (numer x) (denom y))
                       (* (numer y) (denom x)))
                    (* (denom x) (denom y))))
        (define (mul-rat x y)
          (make-rat (* (numer x) (numer y))
                    (* (denom x) (denom y))))
        (define (div-rat x y)
          (make-rat (* (numer x) (denom y))
                    (* (denom x) (numer y))))
        ;; interface to rest of the system
        (define (tag x) (attach-tag 'rational x))
        (put 'add '(rational rational)
             (lambda (x y) (tag (add-rat x y))))
        (put 'sub '(rational rational)
             (lambda (x y) (tag (sub-rat x y))))
        (put 'mul '(rational rational)
             (lambda (x y) (tag (mul-rat x y))))
        (put 'div '(rational rational)
             (lambda (x y) (tag (div-rat x y))))
        (put 'make 'rational
             (lambda (n d) (tag (make-rat n d))))
        'done)

      (define (make-rational n d)
        ((get 'make 'rational) n d))
    < src..

#     We can install a similar package to handle complex numbers, using the tag
#     @c(complex). In creating the package, we extract from the table the operations
#     @c(make-from-real-imag) and @c(make-from-mag-ang) that were defined by the
#     rectangular and polar packages. Additivity permits us to use, as the internal
#     operations, the same @c(add-complex), @c(sub-complex), @c(mul-complex), and
#     @c(div-complex) procedures from @l(#2.4.1).
    Podemos instalar un paquete similar para manejar números complejos, usando
    la etiqueta @c(complex). Al crear el paquete, extraemos de la tabla las
    operaciones @c(make-from-real-imag) y @c(make-from-mag-ang) que fueron
    definidas por los paquetes rectangulares y polares. Aditividad nos permite
    usar, ya que las operaciones internas, las mismas @c(add-complex),
    @c(sub-complex), @c(mul-complex), y @c(div-complex) los procedimientos de
    @l(#2.4.1).

#     ..src > scheme
#       (define (install-complex-package)
#         ;; imported procedures from rectangular
#         ;; and polar packages
#         (define (make-from-real-imag x y)
#           ((get 'make-from-real-imag
#                 'rectangular)
#            x y))
#         (define (make-from-mag-ang r a)
#           ((get 'make-from-mag-ang 'polar)
#            r a))
#         ;; internal procedures
#         (define (add-complex z1 z2)
#           (make-from-real-imag
#            (+ (real-part z1) (real-part z2))
#            (+ (imag-part z1) (imag-part z2))))
#         (define (sub-complex z1 z2)
#           (make-from-real-imag
#            (- (real-part z1) (real-part z2))
#            (- (imag-part z1) (imag-part z2))))
#         (define (mul-complex z1 z2)
#           (make-from-mag-ang
#            (* (magnitude z1) (magnitude z2))
#            (+ (angle z1) (angle z2))))
#         (define (div-complex z1 z2)
#           (make-from-mag-ang
#            (/ (magnitude z1) (magnitude z2))
#            (- (angle z1) (angle z2))))
#         ;; interface to rest of the system
#         (define (tag z) (attach-tag 'complex z))
#         (put 'add '(complex complex)
#              (lambda (z1 z2)
#                (tag (add-complex z1 z2))))
#         (put 'sub '(complex complex)
#              (lambda (z1 z2)
#                (tag (sub-complex z1 z2))))
#         (put 'mul '(complex complex)
#              (lambda (z1 z2)
#                (tag (mul-complex z1 z2))))
#         (put 'div '(complex complex)
#              (lambda (z1 z2)
#                (tag (div-complex z1 z2))))
#         (put 'make-from-real-imag 'complex
#              (lambda (x y)
#                (tag (make-from-real-imag x y))))
#         (put 'make-from-mag-ang 'complex
#              (lambda (r a)
#                (tag (make-from-mag-ang r a))))
#         'done)
#     < src..
    ..src > scheme
      (define (install-complex-package)
        ;; imported procedures from rectangular
        ;; and polar packages
        (define (make-from-real-imag x y)
          ((get 'make-from-real-imag
                'rectangular)
           x y))
        (define (make-from-mag-ang r a)
          ((get 'make-from-mag-ang 'polar)
           r a))
        ;; internal procedures
        (define (add-complex z1 z2)
          (make-from-real-imag
           (+ (real-part z1) (real-part z2))
           (+ (imag-part z1) (imag-part z2))))
        (define (sub-complex z1 z2)
          (make-from-real-imag
           (- (real-part z1) (real-part z2))
           (- (imag-part z1) (imag-part z2))))
        (define (mul-complex z1 z2)
          (make-from-mag-ang
           (* (magnitude z1) (magnitude z2))
           (+ (angle z1) (angle z2))))
        (define (div-complex z1 z2)
          (make-from-mag-ang
           (/ (magnitude z1) (magnitude z2))
           (- (angle z1) (angle z2))))
        ;; interface to rest of the system
        (define (tag z) (attach-tag 'complex z))
        (put 'add '(complex complex)
             (lambda (z1 z2)
               (tag (add-complex z1 z2))))
        (put 'sub '(complex complex)
             (lambda (z1 z2)
               (tag (sub-complex z1 z2))))
        (put 'mul '(complex complex)
             (lambda (z1 z2)
               (tag (mul-complex z1 z2))))
        (put 'div '(complex complex)
             (lambda (z1 z2)
               (tag (div-complex z1 z2))))
        (put 'make-from-real-imag 'complex
             (lambda (x y)
               (tag (make-from-real-imag x y))))
        (put 'make-from-mag-ang 'complex
             (lambda (r a)
               (tag (make-from-mag-ang r a))))
        'done)
    < src..

#     Programs outside the complex-number package can construct complex numbers
#     either from real and imaginary parts or from magnitudes and angles. Notice how
#     the underlying procedures, originally defined in the rectangular and polar
#     packages, are exported to the complex package, and exported from there to the
#     outside world.
    Los programas fuera del paquete de números complejos pueden construir
    números complejos ya sea de partes reales e imaginarias o de magnitudes y
    ángulos. Observe cómo los procedimientos subyacentes, originalmente
    definidos en los paquetes rectangulares y polares, se exportan al paquete
    complejo y se exportan desde allí al mundo exterior.

#     ..src > scheme
#       (define (make-complex-from-real-imag x y)
#         ((get 'make-from-real-imag 'complex) x y))
#       (define (make-complex-from-mag-ang r a)
#         ((get 'make-from-mag-ang 'complex) r a))
#     < src..
    ..src > scheme
      (define (make-complex-from-real-imag x y)
        ((get 'make-from-real-imag 'complex) x y))
      (define (make-complex-from-mag-ang r a)
        ((get 'make-from-mag-ang 'complex) r a))
    < src..

#     What we have here is a two-level tag system. A typical complex number, such as
#     @m(3 + 4i) in rectangular form, would be represented as shown in @l(#Figure
#     2.24).  The outer tag (@c(complex)) is used to direct the number to the
#     complex package. Once within the complex package, the next tag
#     (@c(rectangular)) is used to direct the number to the rectangular package.  In
#     a large and complicated system there might be many levels, each interfaced
#     with the next by means of generic operations. As a data object is passed
#     @"(downward,) the outer tag that is used to direct it to the appropriate
#     package is stripped off (by applying @c(contents)) and the next level of tag
#     (if any) becomes visible to be used for further dispatching.
    Lo que tenemos aquí es un sistema de etiquetas de dos niveles. Un número
    complejo típico, tal como @m(3 + 4i) en forma rectangular, sería
    representado como se muestra en la @l(#Figura 2.24). La
    etiqueta externa (@c(complex)) se utiliza para dirigir el número al paquete
    complejo. Una vez dentro del paquete complejo, la siguiente etiqueta (
    @c(rectangular)) se utiliza para dirigir el número al paquete
    rectangular. En un sistema grande y complicado puede haber muchos niveles,
    cada uno interconectado con el siguiente por medio de operaciones
    genéricas. A medida que se pasa un objeto de datos @"(hacia abajo,) la
    etiqueta externa que se usa para dirigirla al paquete apropiado se quita
    (aplicando @c(contents)) y el siguiente nivel de etiqueta (si lo hay) se
    vuelve visible para ser utilizado para el envío posterior.

#     ..figure > @t(Figure 2.24) Representation of @m(3 + 4i) in rectangular form.
    ..figure > @t(Figura 2.24) Representación de @m(3 + 4i) en forma
      rectangular.

#       ..art >
#              ╭───┬───╮     ╭───┬───╮     ╭───┬───╮
#         ────▶│ ◆ │ ◆ ┼────▶│ ◆ │ ◆ ┼────▶│ ◆ │ ◆ │
#              ╰─┼─┴───╯     ╰─┼─┴───╯     ╰─┼─┴─┼─╯
#                │             │             │   │
#                ▼             ▼             ▼   ▼
#             ╭─────────╮ ╭─────────────╮ ╭───╮ ╭───╮
#             │ complex │ │ rectangular │ │ 3 │ │ 4 │
#             ╰─────────╯ ╰─────────────╯ ╰───╯ ╰───╯
#       < art..
      ..art >
             ╭───┬───╮     ╭───┬───╮     ╭───┬───╮
        ────▶│ ◆ │ ◆ ┼────▶│ ◆ │ ◆ ┼────▶│ ◆ │ ◆ │
             ╰─┼─┴───╯     ╰─┼─┴───╯     ╰─┼─┴─┼─╯
               │             │             │   │
               ▼             ▼             ▼   ▼
            ╭─────────╮ ╭─────────────╮ ╭───╮ ╭───╮
            │ complex │ │ rectangular │ │ 3 │ │ 4 │
            ╰─────────╯ ╰─────────────╯ ╰───╯ ╰───╯
      < art..

# @     ..img > img/chap2/Fig2.24d.std.svg
@     ..img > img/chap2/Fig2.24d.std.svg

#     In the above packages, we used @c(add-rat), @c(add-complex), and the other
#     arithmetic procedures exactly as originally written. Once these definitions
#     are internal to different installation procedures, however, they no longer
#     need names that are distinct from each other: we could simply name them
#     @c(add), @c(sub), @c(mul), and @c(div) in both packages.
    En los paquetes anteriores, hemos utilizado @c(add-rat), @c(add-complex) y
    los demás procedimientos aritméticos exactamente como fue escrito
    originalmente. Una vez que estas definiciones son internos a diferentes
    procedimientos de instalación, sin embargo, que ya no necesitan nombres que
    son distintas unas de otras: simplemente les podríamos nombrar @c(add),
    @c(sub), @c(mul), y @c(div) en ambos paquetes.

#     :: @t(Exercise 2.77) :: Louis Reasoner tries to evaluate the expression
#        @c[(magnitude z)] where @c(z) is the object shown in @l(#Figure 2.24). To
#        his surprise, instead of the answer 5 he gets an error message from
#        @c(apply-generic), saying there is no method for the operation
#        @c(magnitude) on the types @c[(complex)]. He shows this interaction to
#        Alyssa P. Hacker, who says @"(The problem is that the complex-number
#        selectors were never defined for @c(complex) numbers, just for @c(polar)
#        and @c(rectangular) numbers. All you have to do to make this work is add
#        the following to the @c(complex) package:)
    :: @t(Ejercicio 2.77) :: Louis Reasoner trata de evaluar la expresión
       @c[(magnitude z)] donde @c(z) está el objeto mostrado en la
       @l(#Figura 2.24). Para su sorpresa, en lugar de la respuesta
       5 recibe un mensaje de error @c(apply-generic), diciendo que no hay
       ningún método para la operación @c(magnitude) en los tipos
       @c[(complex)]. Él muestra esta interacción con Alyssa P. Hacker, quien
       dice que @"(El problema es que los selectores de números complejos nunca
       fueron definidos para @c(complex) números, sólo para @c(polar) y
       @c(rectangular) números. Todo lo que tiene que hacer para realizar este
       trabajo es agregar lo siguiente al @c(complex) paquete:)

#        ..src > scheme
#          (put 'real-part '(complex) real-part)
#          (put 'imag-part '(complex) imag-part)
#          (put 'magnitude '(complex) magnitude)
#          (put 'angle '(complex) angle)
#        < src..
       ..src > scheme
         (put 'real-part '(complex) real-part)
         (put 'imag-part '(complex) imag-part)
         (put 'magnitude '(complex) magnitude)
         (put 'angle '(complex) angle)
       < src..

#        Describe in detail why this works. As an example, trace through all the
#        procedures called in evaluating the expression @c[(magnitude z)] where
#        @c(z) is the object shown in @l(#Figure 2.24). In particular, how many
#        times is @c(apply-generic) invoked?  What procedure is dispatched to in
#        each case?
       Describa en detalle por qué esto funciona. Como ejemplo, trace a través
       de todos los procedimientos llamados a evaluar la expresión @c[(magnitude
       z)] donde @c(z) está el objeto mostrado en la @l(#Figura
       2.24). En particular, ¿cuántas veces se @c(apply-generic) invoca? ¿Qué
       procedimiento se envía a cada caso?

#     :: @t(Exercise 2.78) :: The internal procedures in the @c(scheme-number)
#        package are essentially nothing more than calls to the primitive procedures
#        @c(+), @c(-), etc. It was not possible to use the primitives of the
#        language directly because our type-tag system requires that each data
#        object have a type attached to it. In fact, however, all Lisp
#        implementations do have a type system, which they use internally. Primitive
#        predicates such as @c(symbol?) and @c(number?)  determine whether data
#        objects have particular types. Modify the definitions of @c(type-tag),
#        @c(contents), and @c(attach-tag) from @l(#2.4.2) so that our generic system
#        takes advantage of Scheme's internal type system. That is to say, the
#        system should work as before except that ordinary numbers should be
#        represented simply as Scheme numbers rather than as pairs whose @c(car) is
#        the symbol @c(scheme-number).
    :: @t(Ejercicio 2.78) :: Los procedimientos internos en el @c(scheme-number)
       paquete son esencialmente nada más que las llamadas a los procedimientos
       primitivos @c(+), @c(-) etc. No fue posible usar las primitivas de la
       lengua directamente porque nuestro sistema de tipo de etiqueta requiere
       que los datos de cada objeto tiene un tipo que se le atribuye. De hecho,
       sin embargo, todas las implementaciones Lisp tienen un sistema de tipo,
       que utilizan internamente. Los predicados primitivos tales como
       @c(symbol?) y @c(number?)  determinar si los objetos de datos tienen
       tipos particulares. Modifique las definiciones de @c(type-tag),
       @c(contents) y @c(attach-tag) de la seccion @l(#2.4.2) para que nuestro
       sistema genérico se aproveche del sistema de tipo interno de Scheme. Es
       decir,@c(car)@c(scheme-number)

#     :: @t(Exercise 2.79) :: Define a generic equality predicate @c(equ?) that
#        tests the equality of two numbers, and install it in the generic arithmetic
#        package. This operation should work for ordinary numbers, rational numbers,
#        and complex numbers.
    :: @t(Ejercicio 2.79) :: Defina un predicado genérico de igualdad @c(equ?)
       que compruebe la igualdad de dos números e instálelo en el paquete
       aritmético genérico. Esta operación debería funcionar para números
       ordinarios, números racionales y números complejos.

#     :: @t(Exercise 2.80) :: Define a generic predicate @c(=zero?) that tests if
#        its argument is zero, and install it in the generic arithmetic
#        package. This operation should work for ordinary numbers, rational numbers,
#        and complex numbers.
    :: @t(Ejercicio 2.80) :: Defina un predicado genérico @c(=zero?) que
       comprueba si su argumento es cero e instálelo en el paquete aritmético
       genérico. Esta operación debería funcionar para números ordinarios,
       números racionales y números complejos.

# *** 2.5.2 <> Combining Data of Different Types
*** 2.5.2 <> Combinación de datos de diferentes tipos

#     We have seen how to define a unified arithmetic system that encompasses
#     ordinary numbers, complex numbers, rational numbers, and any other type of
#     number we might decide to invent, but we have ignored an important issue. The
#     operations we have defined so far treat the different data types as being
#     completely independent. Thus, there are separate packages for adding, say, two
#     ordinary numbers, or two complex numbers. What we have not yet considered is
#     the fact that it is meaningful to define operations that cross the type
#     boundaries, such as the addition of a complex number to an ordinary number. We
#     have gone to great pains to introduce barriers between parts of our programs
#     so that they can be developed and understood separately. We would like to
#     introduce the cross-type operations in some carefully controlled way, so that
#     we can support them without seriously violating our module boundaries.
    Hemos visto cómo definir un sistema aritmético unificado que abarque números
    ordinarios, números complejos, números racionales y cualquier otro tipo de
    número que podamos decidir inventar, pero hemos ignorado una cuestión
    importante. Las operaciones que hemos definido hasta ahora tratan a los
    diferentes tipos de datos como completamente independientes. Por lo tanto,
    hay paquetes separados para agregar, digamos, dos números ordinarios, o dos
    números complejos. Lo que aún no hemos considerado es el hecho de que es
    significativo definir las operaciones que cruzan los límites del tipo, como
    la adición de un número complejo a un número ordinario. Hemos hecho grandes
    esfuerzos para introducir barreras entre partes de nuestros programas para
    que puedan desarrollarse y comprenderse por separado. Nos gustaría
    introducir las operaciones cruzadas de alguna forma cuidadosamente
    controlada,

#     One way to handle cross-type operations is to design a different procedure for
#     each possible combination of types for which the operation is valid. For
#     example, we could extend the complex-number package so that it provides a
#     procedure for adding complex numbers to ordinary numbers and installs this in
#     the table using the tag @c[(complex scheme-number)]:@n(115)
    Una forma de manejar operaciones cruzadas es diseñar un procedimiento
    diferente para cada posible combinación de tipos para los que la operación
    es válida. Por ejemplo, podríamos extender el paquete de número complejo
    para que proporcione un procedimiento para agregar números complejos a
    números ordinarios e instalarlo en la tabla usando la etiqueta @c[(complex
    scheme-number)]:@n(115)

#     ..src > scheme
#       (define (add-complex-to-schemenum z x)
#         (make-from-real-imag (+ (real-part z) x)
#                              (imag-part z)))
#
#       (put 'add
#            '(complex scheme-number)
#            (lambda (z x)
#              (tag (add-complex-to-schemenum z x))))
#     < src..
    ..src > scheme
      (define (add-complex-to-schemenum z x)
        (make-from-real-imag (+ (real-part z) x)
                             (imag-part z)))

      (put 'add
           '(complex scheme-number)
           (lambda (z x)
             (tag (add-complex-to-schemenum z x))))
    < src..

#     This technique works, but it is cumbersome. With such a system, the cost of
#     introducing a new type is not just the construction of the package of
#     procedures for that type but also the construction and installation of the
#     procedures that implement the cross-type operations. This can easily be much
#     more code than is needed to define the operations on the type itself. The
#     method also undermines our ability to combine separate packages additively, or
#     at least to limit the extent to which the implementors of the individual
#     packages need to take account of other packages. For instance, in the example
#     above, it seems reasonable that handling mixed operations on complex numbers
#     and ordinary numbers should be the responsibility of the complex-number
#     package. Combining rational numbers and complex numbers, however, might be
#     done by the complex package, by the rational package, or by some third package
#     that uses operations extracted from these two packages. Formulating coherent
#     policies on the division of responsibility among packages can be an
#     overwhelming task in designing systems with many packages and many cross-type
#     operations.
    Esta técnica funciona, pero es engorroso. Con este sistema, el costo de
    introducir un nuevo tipo no es sólo la construcción del paquete de
    procedimientos para ese tipo sino también la construcción e instalación de
    los procedimientos que implementan las operaciones de tipo cruzado. Esto
    puede ser mucho más código de lo necesario para definir las operaciones en
    el propio tipo. El método también socava nuestra capacidad para combinar
    paquetes separados de forma aditiva, o al menos para limitar la medida en
    que los implementadores de los paquetes individuales necesitan tener en
    cuenta otros paquetes. Por ejemplo, en el ejemplo anterior, parece razonable
    que manipular operaciones mixtas en números complejos y números ordinarios
    debería ser responsabilidad del paquete de números complejos. La combinación
    de números racionales y números complejos, sin embargo, podría ser hecha por
    el paquete complejo, Por el paquete racional, o por un tercer paquete que
    utiliza operaciones extraídas de estos dos paquetes. La formulación de
    políticas coherentes sobre la división de responsabilidades entre paquetes
    puede ser una tarea abrumadora en el diseño de sistemas con muchos paquetes
    y muchas operaciones cruzadas.

# **** Coercion
**** Coerción

#      In the general situation of completely unrelated operations acting on
#      completely unrelated types, implementing explicit cross-type operations,
#      cumbersome though it may be, is the best that one can hope for. Fortunately,
#      we can usually do better by taking advantage of additional structure that may
#      be latent in our type system. Often the different data types are not
#      completely independent, and there may be ways by which objects of one type may
#      be viewed as being of another type. This process is called @e(coercion).  For
#      example, if we are asked to arithmetically combine an ordinary number with a
#      complex number, we can view the ordinary number as a complex number whose
#      imaginary part is zero. This transforms the problem to that of combining two
#      complex numbers, which can be handled in the ordinary way by the
#      complex-arithmetic package.
     En la situación general de operaciones completamente independientes que
     actúan sobre tipos completamente no relacionados, la ejecución de
     operaciones explícitas de tipo cruzado, aunque sea engorroso, puede ser lo
     mejor que uno puede esperar. Afortunadamente, normalmente podemos hacerlo
     mejor aprovechando la estructura adicional que puede estar latente en
     nuestro sistema de tipos. A menudo los diferentes tipos de datos no son
     completamente independientes, y puede haber formas por las cuales los
     objetos de un tipo pueden ser vistos como siendo de otro tipo. Este proceso
     se llama @e(coerción). Por ejemplo, si se nos pide combinar aritméticamente
     un número ordinario con un número complejo, podemos ver el número ordinario
     como un número complejo cuya parte imaginaria es cero. Esto transforma el
     problema en el de combinar dos números complejos,

#      In general, we can implement this idea by designing coercion procedures that
#      transform an object of one type into an equivalent object of another type.
#      Here is a typical coercion procedure, which transforms a given ordinary number
#      to a complex number with that real part and zero imaginary part:
     En general, podemos implementar esta idea diseñando procedimientos de
     coacción que transformen un objeto de un tipo en un objeto equivalente de
     otro tipo. He aquí un típico procedimiento de coerción, que transforma un
     número ordinario dado en un número complejo con esa parte real y cero parte
     imaginaria:

#      ..src > scheme
#        (define (scheme-number->complex n)
#          (make-complex-from-real-imag
#           (contents n) 0))
#      < src..
     ..src > scheme
       (define (scheme-number->complex n)
         (make-complex-from-real-imag
          (contents n) 0))
     < src..

#      We install these coercion procedures in a special coercion table, indexed
#      under the names of the two types:
     Instalamos estos procedimientos de coerción en una tabla de coerción
     especial, indexada bajo los nombres de los dos tipos:

#      ..src > scheme
#        (put-coercion 'scheme-number 'complex
#                      scheme-number->complex)
#      < src..
     ..src > scheme
       (put-coercion 'scheme-number 'complex
                     scheme-number->complex)
     < src..

#      (We assume that there are @c(put-coercion) and @c(get-coercion) procedures
#      available for manipulating this table.)  Generally some of the slots in the
#      table will be empty, because it is not generally possible to coerce an
#      arbitrary data object of each type into all other types. For example, there is
#      no way to coerce an arbitrary complex number to an ordinary number, so there
#      will be no general @c(complex->scheme-number) procedure included in the table.
     (Suponemos que existen @c(put-coercion) y procedimiento @c(get-coercion)s
     disponibles para la manipulación de esta tabla.) En general, algunas de las
     ranuras de la tabla estará vacía, porque no es posible en general para
     obligar a un objeto de datos arbitraria de cada tipo en todos los demás
     tipos. Por ejemplo, no hay manera de coaccionar un número complejo
     arbitrario a un número ordinario, por lo que no habrá ningún
     procedimiento @c(complex->scheme-number) general incluido en la tabla.

#      Once the coercion table has been set up, we can handle coercion in a uniform
#      manner by modifying the @c(apply-generic) procedure of section @l(#2.4.3).  When asked
#      to apply an operation, we first check whether the operation is defined for the
#      arguments' types, just as before. If so, we dispatch to the procedure found in
#      the operation-and-type table. Otherwise, we try coercion.  For simplicity, we
#      consider only the case where there are two arguments.@n(116) We check the
#      coercion table to see if objects of the first type can be coerced to the
#      second type. If so, we coerce the first argument and try the operation
#      again. If objects of the first type cannot in general be coerced to the second
#      type, we try the coercion the other way around to see if there is a way to
#      coerce the second argument to the type of the first argument. Finally, if
#      there is no known way to coerce either type to the other type, we give
#      up. Here is the procedure:
     Una vez establecida la tabla de coacción, podemos manejar la coerción de
     manera uniforme modificando el procedimiento @c(apply-generic) de
     @l(#2.4.3). Cuando se le pide que aplique una operación, primero
     verificamos si la operación está definida para los tipos de argumentos,
     como antes. Si es así, enviamos al procedimiento que se encuentra en la
     tabla de operación y tipo. De lo contrario, tratamos de coerción. Para
     simplificar, consideramos solamente el caso donde hay dos
     argumentos.@n(116) Comprobamos la tabla de coerción para ver si los
     objetos del primer tipo pueden ser coagidos al segundo tipo. Si es así,
     coaccionamos el primer argumento y probamos la operación nuevamente. Si los
     objetos del primer tipo no pueden coaccionar en general al segundo tipo,
     Intentamos la coacción al revés para ver si hay una manera de coaccionar el
     segundo argumento al tipo del primer argumento. Finalmente, si no hay una
     manera conocida de coaccionar a cualquiera de los tipos al otro tipo, nos
     damos por vencidos. Aquí está el procedimiento:

#      ..src > scheme
#        (define (apply-generic op . args)
#          (let ((type-tags (map type-tag args)))
#            (let ((proc (get op type-tags)))
#              (if proc
#                  (apply proc (map contents args))
#                  (if (= (length args) 2)
#                      (let ((type1 (car type-tags))
#                            (type2 (cadr type-tags))
#                            (a1 (car args))
#                            (a2 (cadr args)))
#                        (let ((t1->t2
#                               (get-coercion type1
#                                             type2))
#                              (t2->t1
#                               (get-coercion type2
#                                             type1)))
#                          (cond (t1->t2
#                                 (apply-generic
#                                  op (t1->t2 a1) a2))
#                                (t2->t1
#                                 (apply-generic
#                                  op a1 (t2->t1 a2)))
#                                (else
#                                 (error
#                                  "No method for
#                                   these types"
#                                  (list
#                                   op
#                                   type-tags))))))
#                      (error
#                       "No method for these types"
#                       (list op type-tags)))))))
#      < src..
     ..src > scheme
       (define (apply-generic op . args)
         (let ((type-tags (map type-tag args)))
           (let ((proc (get op type-tags)))
             (if proc
                 (apply proc (map contents args))
                 (if (= (length args) 2)
                     (let ((type1 (car type-tags))
                           (type2 (cadr type-tags))
                           (a1 (car args))
                           (a2 (cadr args)))
                       (let ((t1->t2
                              (get-coercion type1
                                            type2))
                             (t2->t1
                              (get-coercion type2
                                            type1)))
                         (cond (t1->t2
                                (apply-generic
                                 op (t1->t2 a1) a2))
                               (t2->t1
                                (apply-generic
                                 op a1 (t2->t1 a2)))
                               (else
                                (error
                                 "No method for
                                  these types"
                                 (list
                                  op
                                  type-tags))))))
                     (error
                      "No method for these types"
                      (list op type-tags)))))))
     < src..

#      This coercion scheme has many advantages over the method of defining explicit
#      cross-type operations, as outlined above. Although we still need to write
#      coercion procedures to relate the types (possibly @m(n²) procedures for a
#      system with @m(n) types), we need to write only one procedure for each pair of
#      types rather than a different procedure for each collection of types and each
#      generic operation.@n(117) What we are counting on here is the fact that the
#      appropriate transformation between types depends only on the types themselves,
#      not on the operation to be applied.
     Este esquema de coacción tiene muchas ventajas sobre el método de definir
     operaciones explícitas de tipo cruzado, como se señaló
     anteriormente. Aunque todavía necesitamos escribir procedimientos de
     coacción para relacionar los tipos (posiblemente @m(n²) procedimientos para
     un sistema con @m(n) tipos), necesitamos escribir sólo un procedimiento
     para cada par de tipos en lugar de un procedimiento diferente para cada
     colección de tipos y cada operación genérica.@n(117) Lo que contamos
     aquí es el hecho de que la transformación apropiada entre tipos depende
     solamente de los tipos mismos, no de la operación a ser aplicada.

#      On the other hand, there may be applications for which our coercion scheme is
#      not general enough. Even when neither of the objects to be combined can be
#      converted to the type of the other it may still be possible to perform the
#      operation by converting both objects to a third type. In order to deal with
#      such complexity and still preserve modularity in our programs, it is usually
#      necessary to build systems that take advantage of still further structure in
#      the relations among types, as we discuss next.
     Por otro lado, puede haber aplicaciones para las cuales nuestro esquema de
     coerción no es lo suficientemente general. Incluso cuando ninguno de los
     objetos a combinar puede convertirse en el tipo del otro, puede todavía ser
     posible realizar la operación convirtiendo ambos objetos en un tercer
     tipo. Para hacer frente a esta complejidad y preservar la modularidad en
     nuestros programas, es necesario construir sistemas que se aprovechen de
     una estructura aún mayor en las relaciones entre los tipos, como veremos a
     continuación.

# **** Hierarchies of types
**** Jerarquías de tipos

#      The coercion scheme presented above relied on the existence of natural
#      relations between pairs of types. Often there is more @"(global) structure in
#      how the different types relate to each other. For instance, suppose we are
#      building a generic arithmetic system to handle integers, rational numbers,
#      real numbers, and complex numbers. In such a system, it is quite natural to
#      regard an integer as a special kind of rational number, which is in turn a
#      special kind of real number, which is in turn a special kind of complex
#      number. What we actually have is a so-called @e(hierarchy of types), in which,
#      for example, integers are a @e(subtype) of rational numbers (i.e., any
#      operation that can be applied to a rational number can automatically be
#      applied to an integer). Conversely, we say that rational numbers form a
#      @e(supertype) of integers. The particular hierarchy we have here is of a very
#      simple kind, in which each type has at most one supertype and at most one
#      subtype. Such a structure, called a @e(tower), is illustrated in @l(#Figure
#      2.25).
     El esquema de coacción presentado anteriormente se basó en la existencia de
     relaciones naturales entre parejas de tipos. A menudo hay más estructura
     @"(global) en cómo los diferentes tipos se relacionan entre sí. Por
     ejemplo, supongamos que estamos construyendo un sistema aritmético genérico
     para manejar números enteros, números racionales, números reales y números
     complejos. En tal sistema, es bastante natural considerar un número entero
     como un tipo especial de número racional, que a su vez es un tipo especial
     de número real, que a su vez es un tipo especial de número complejo. Lo que
     realmente tenemos es una llamada @e(jerarquía de tipos), en la que, por
     ejemplo, los enteros son un @e(subtipo) de números racionales (es decir,
     cualquier operación que se puede aplicar a un número racional puede
     aplicarse automáticamente a un entero). A la inversa, @e(Decimos que los
     números racionales forman un supertipo) de números enteros. La jerarquía
     particular que tenemos aquí es de un tipo muy simple, en el que cada tipo
     tiene como máximo un supertipo y como mucho un subtipo. Dicha estructura,
     llamada @e(torre), se ilustra en la @l(#Figura 2.25).

#      ..figure > @t(Figure 2.25) A tower of types.
     ..figure > @t(Figura 2.25) Una torre de tipos.

#        ..art >
#           complex
#             ▲
#             │
#            real
#             ▲
#             │
#          rational
#             ▲
#             │
#          integer
#        < art..
       ..art >
          complex
            ▲
            │
           real
            ▲
            │
         rational
            ▲
            │
         integer
       < art..

# @    ..img > img/chap2/Fig2.25.std.svg
@    ..img > img/chap2/Fig2.25.std.svg

#      If we have a tower structure, then we can greatly simplify the problem of
#      adding a new type to the hierarchy, for we need only specify how the new type
#      is embedded in the next supertype above it and how it is the supertype of the
#      type below it. For example, if we want to add an integer to a complex number,
#      we need not explicitly define a special coercion procedure
#      @c(integer->complex). Instead, we define how an integer can be transformed
#      into a rational number, how a rational number is transformed into a real
#      number, and how a real number is transformed into a complex number. We then
#      allow the system to transform the integer into a complex number through these
#      steps and then add the two complex numbers.
     Si tenemos una estructura de torre, podemos simplificar en gran medida el
     problema de añadir un nuevo tipo a la jerarquía, ya que sólo necesitamos
     especificar cómo se incrusta el nuevo tipo en el supertipo siguiente sobre
     él y cómo es el supertipo del tipo de abajo eso. Por ejemplo, si queremos
     agregar un número entero a un número complejo, no necesitamos definir
     explícitamente un procedimiento de coerción especial
     @c(integer->complex). En su lugar, definimos cómo un número entero puede
     ser transformado en un número racional, cómo un número racional se
     transforma en un número real y cómo un número real se transforma en un
     número complejo. A continuación, permite que el sistema para transformar el
     número entero en un número complejo a través de estos pasos y luego añadir
     los dos números complejos.

#      We can redesign our @c(apply-generic) procedure in the following way: For each
#      type, we need to supply a @c(raise) procedure, which @"(raises) objects of
#      that type one level in the tower. Then when the system is required to operate
#      on objects of different types it can successively raise the lower types until
#      all the objects are at the same level in the tower. (@l(#Exercise 2.83) and
#      @l(#Exercise 2.84) concern the details of implementing such a strategy.)
     Podemos rediseñar nuestro procedimiento @c(apply-generic) de la siguiente
     manera: Para cada tipo, necesitamos suministrar un procedimiento @c(raise),
     que @"(plantee) objetos de ese tipo un nivel en la torre. Entonces, cuando
     se requiere que el sistema opere sobre objetos de diferentes tipos, puede
     elevar sucesivamente los tipos inferiores hasta que todos los objetos estén
     al mismo nivel en la torre. (El @l(#Ejercicio 2.83) y el
     @l(#Ejercicio 2.84 se) refieren a los detalles de la
     aplicación de dicha estrategia.)

#      Another advantage of a tower is that we can easily implement the notion that
#      every type @"(inherits) all operations defined on a supertype. For instance,
#      if we do not supply a special procedure for finding the real part of an
#      integer, we should nevertheless expect that @c(real-part) will be defined for
#      integers by virtue of the fact that integers are a subtype of complex
#      numbers. In a tower, we can arrange for this to happen in a uniform way by
#      modifying @c(apply-generic). If the required operation is not directly defined
#      for the type of the object given, we raise the object to its supertype and try
#      again. We thus crawl up the tower, transforming our argument as we go, until
#      we either find a level at which the desired operation can be performed or hit
#      the top (in which case we give up).
     Otra ventaja de una torre es que podemos implementar fácilmente la noción
     de que cada tipo @"(hereda) todas las operaciones definidas en un
     supertipo. Por ejemplo, si no proporcionamos un procedimiento especial para
     encontrar la parte real de un entero, debemos esperar que @c(real-part) se
     defina para enteros en virtud del hecho de que los enteros son un subtipo
     de números complejos. En una torre, podemos arreglar para que esto suceda
     de una manera uniforme modificando @c(apply-generic). Si la operación
     requerida no está definida directamente para el tipo de objeto dado,
     elevamos el objeto a su supertipo e intentamos de nuevo. De este modo, nos
     arrastramos hasta la torre, transformando nuestro argumento a medida que
     avanzamos, hasta encontrar un nivel en el que se pueda realizar la
     operación deseada o golpear la parte superior (en cuyo caso nos
     rendiremos).

#      Yet another advantage of a tower over a more general hierarchy is that it
#      gives us a simple way to @"(lower) a data object to the simplest
#      representation. For example, if we add @m(2 + 3i) to @m(4 - 3i), it would be
#      nice to obtain the answer as the integer 6 rather than as the complex number
#      @m(6 + 0i).  @l(#Exercise 2.85) discusses a way to implement such a lowering
#      operation.  (The trick is that we need a general way to distinguish those
#      objects that can be lowered, such as @m(6 + 0i), from those that cannot, such
#      as @m(6 + 2i).)
     Otra ventaja de una torre sobre una jerarquía más general es que nos da una
     manera sencilla de @"(bajar) un objeto de datos a la representación más
     simple. Por ejemplo, si añadimos @m(2 + 3i) a @m(4 - 3i), sería bueno
     obtener la respuesta como el número entero 6 en lugar de como el número
     complejo @m(6 + 0i).  @l(#Ejercicio 2.85) discute una
     manera de implementar tal operación de reducción. (El truco es que
     necesitamos una manera general de distinguir aquellos objetos que se pueden
     bajar, como @m(6 + 0i), de aquellos que no pueden, como @m(6 + 2i) .)

# **** Inadequacies of hierarchies
**** Insuficiencias de las jerarquías

#      If the data types in our system can be naturally arranged in a tower, this
#      greatly simplifies the problems of dealing with generic operations on
#      different types, as we have seen. Unfortunately, this is usually not the case.
#      @l(#Figure 2.26) illustrates a more complex arrangement of mixed types, this
#      one showing relations among different types of geometric figures. We see that,
#      in general, a type may have more than one subtype. Triangles and
#      quadrilaterals, for instance, are both subtypes of polygons. In addition, a
#      type may have more than one supertype. For example, an isosceles right
#      triangle may be regarded either as an isosceles triangle or as a right
#      triangle. This multiple-supertypes issue is particularly thorny, since it
#      means that there is no unique way to @"(raise) a type in the hierarchy.
#      Finding the @"(correct) supertype in which to apply an operation to an object
#      may involve considerable searching through the entire type network on the part
#      of a procedure such as @c(apply-generic). Since there generally are multiple
#      subtypes for a type, there is a similar problem in coercing a value @"(down)
#      the type hierarchy. Dealing with large numbers of interrelated types while
#      still preserving modularity in the design of large systems is very difficult,
#      and is an area of much current research.@n(118)
     Si los tipos de datos en nuestro sistema se pueden disponer naturalmente en
     una torre, esto simplifica grandemente los problemas de tratar operaciones
     genéricas en diferentes tipos, como hemos visto. Desafortunadamente, esto
     no suele ser el caso. @l(#Figura 2.26) ilustra una
     disposición más compleja de tipos mixtos, que muestra las relaciones entre
     diferentes tipos de figuras geométricas. Vemos que, en general, un tipo
     puede tener más de un subtipo. Triángulos y cuadriláteros, por ejemplo, son
     ambos subtipos de polígonos. Además, un tipo puede tener más de un
     supertipo. Por ejemplo, un triángulo rectángulo isósceles puede ser
     considerado como un triángulo isósceles o como un triángulo
     rectángulo. Esta cuestión de los supertypes múltiples es particularmente
     espinosa, ya que significa que no hay una forma única de @"(elevar) un tipo
     en la jerarquía. Encontrar el supertipo @"(correcto) en el que aplicar una
     operación a un objeto puede implicar una considerable búsqueda a través de
     toda la red de tipo por parte de un procedimiento como
     @c(apply-generic). Dado que generalmente hay varios subtipos para un tipo,
     existe un problema similar al forzar un valor @"(por) la jerarquía de
     tipos. Tratar con un gran número de tipos interrelacionados, sin dejar de
     preservar la modularidad en el diseño de grandes sistemas es muy difícil, y
     es un área de mucha investigación actual.@n(118)@"(Existe un
     problema similar al forzar un valor por) la jerarquía de tipos. Tratar con
     un gran número de tipos interrelacionados, sin dejar de preservar la
     modularidad en el diseño de grandes sistemas es muy difícil, y es un área
     de mucha investigación actual.@n(118)@"(Existe un problema similar
     al forzar un valor por) la jerarquía de tipos. Tratar con un gran número de
     tipos interrelacionados, sin dejar de preservar la modularidad en el diseño
     de grandes sistemas es muy difícil, y es un área de mucha investigación
     actual.@n(118)

#      ..figure > @t(Figure 2.26) Relations among types of geometric figures.
     ..figure > @t(Figura 2.26) Relaciones entre tipos de figuras geométricas.

#        ..art >
#                               polygon
#                              /       \
#                             /         \
#                      triangle         quadrilateral
#                      /     \              /     \
#                     /       \            /       \
#               isosceles   right      trapezoid   kite
#               triangle    triangle       |         |
#                |     \      |            |         |
#                |      \     |            |         |
#          equilateral   isosceles   parallelogram   |
#          triangle      right          |       \    |
#                        triangle       |        \   |
#                                    rectangle  rhombus
#                                          \    /
#                                           \  /
#                                          square
#        < art..
       ..art >
                              polygon
                             /       \
                            /         \
                     triangle         quadrilateral
                     /     \              /     \
                    /       \            /       \
              isosceles   right      trapezoid   kite
              triangle    triangle       |         |
               |     \      |            |         |
               |      \     |            |         |
         equilateral   isosceles   parallelogram   |
         triangle      right          |       \    |
                       triangle       |        \   |
                                   rectangle  rhombus
                                         \    /
                                          \  /
                                         square
       < art..

# @    ..img > img/chap2/Fig2.26f.std.svg
@    ..img > img/chap2/Fig2.26f.std.svg

#      :: @t(Exercise 2.81) :: Louis Reasoner has noticed that @c(apply-generic) may
#         try to coerce the arguments to each other's type even if they already have
#         the same type. Therefore, he reasons, we need to put procedures in the
#         coercion table to @e(coerce) arguments of each type to their own type. For
#         example, in addition to the @c(scheme-number->complex) coercion shown
#         above, he would do:
     :: @t(Ejercicio 2.81) :: Louis Reasoner ha notado que @c(apply-generic)
        puede tratar de coaccionar los argumentos para el tipo de cada uno,
        incluso si ya tienen el mismo tipo. Por lo tanto, razona, necesitamos
        poner procedimientos en la tabla de coerción para @e(coaccionar los)
        argumentos de cada tipo a su propio tipo. Por ejemplo, además de la
        @c(scheme-number->complex) coerción mostrada arriba, haría lo
        siguiente:

#         ..src > scheme
#           (define (scheme-number->scheme-number n) n)
#           (define (complex->complex z) z)
#
#           (put-coercion 'scheme-number 'scheme-number
#                         scheme-number->scheme-number)
#
#           (put-coercion 'complex 'complex
#                         complex->complex)
#         < src..
        ..src > scheme
          (define (scheme-number->scheme-number n) n)
          (define (complex->complex z) z)

          (put-coercion 'scheme-number 'scheme-number
                        scheme-number->scheme-number)

          (put-coercion 'complex 'complex
                        complex->complex)
        < src..

#         1. With Louis's coercion procedures installed, what happens if
#            @c(apply-generic) is called with two arguments of type @c(scheme-number)
#            or two arguments of type @c(complex) for an operation that is not found
#            in the table for those types?  For example, assume that we've defined a
#            generic exponentiation operation:
        1. Con los procedimientos de coerción de Louis instalados, ¿qué pasa si
           @c(apply-generic) se llama con dos argumentos de tipo
           @c(scheme-number) o dos argumentos de tipo @c(complex) para una
           operación que no se encuentra en la tabla para esos tipos? Por
           ejemplo, supongamos que hemos definido una operación genérica de
           exponenciación:

#            ..src > scheme
#              (define (exp x y)
#                (apply-generic 'exp x y))
#            < src..
           ..src > scheme
             (define (exp x y)
               (apply-generic 'exp x y))
           < src..

#            and have put a procedure for exponentiation in the Scheme-number package
#            but not in any other package:
           Y han puesto un procedimiento para la exponenciación en el paquete
           del número del esquema pero no en ningún otro paquete:

#            ..src > scheme
#              ;; following added to Scheme-number package
#              (put 'exp
#                   '(scheme-number scheme-number)
#                   (lambda (x y)
#                     (tag (expt x y))))
#                     ; using primitive @c(expt)
#            < src..
           ..src > scheme
             ;; following added to Scheme-number package
             (put 'exp
                  '(scheme-number scheme-number)
                  (lambda (x y)
                    (tag (expt x y))))
                    ; using primitive @c(expt)
           < src..

#            What happens if we call @c(exp) with two complex numbers as arguments?
           ¿Qué sucede si llamamos @c(exp) con dos números complejos como
           argumentos?

#         2. Is Louis correct that something had to be done about coercion with
#            arguments of the same type, or does @c(apply-generic) work correctly as
#            is?
        2. ¿Es correcto Louis que algo tiene que ser hecho sobre la coerción con
           argumentos del mismo tipo, o @c(apply-generic) funciona correctamente
           como es?

#         3. Modify @c(apply-generic) so that it doesn't try coercion if the two
#            arguments have the same type.
        3. Modifique @c(apply-generic) para que no intente coerción si los dos
           argumentos tienen el mismo tipo.

#      :: @t(Exercise 2.82) :: Show how to generalize @c(apply-generic) to handle
#         coercion in the general case of multiple arguments. One strategy is to
#         attempt to coerce all the arguments to the type of the first argument, then
#         to the type of the second argument, and so on.  Give an example of a
#         situation where this strategy (and likewise the two-argument version given
#         above) is not sufficiently general. (Hint: Consider the case where there
#         are some suitable mixed-type operations present in the table that will not
#         be tried.)
     :: @t(Ejercicio 2.82) :: Mostrar cómo generalizar @c(apply-generic) para
        manejar la coerción en el caso general de múltiples argumentos. Una
        estrategia es intentar coaccionar todos los argumentos al tipo del
        primer argumento, luego al tipo del segundo argumento, y así
        sucesivamente. Dé un ejemplo de una situación en la que esta estrategia
        (y también la versión de dos argumentos dada anteriormente) no es
        suficientemente general. (Sugerencia: Considere el caso donde hay
        algunas operaciones de tipo mixto adecuadas presentes en la tabla que no
        serán probadas.)

#      :: @t(Exercise 2.83) :: Suppose you are designing a generic arithmetic system
#         for dealing with the tower of types shown in @l(#Figure 2.25): integer,
#         rational, real, complex. For each type (except complex), design a procedure
#         that raises objects of that type one level in the tower. Show how to
#         install a generic @c(raise) operation that will work for each type (except
#         complex).
     :: @t(Ejercicio 2.83) :: Supongamos que está diseñando un sistema
        aritmético genérico para tratar con la torre de los tipos que se
        muestran en la @l(#Figura 2.25) : entero, racional, real,
        complejo. Para cada tipo (excepto complejo), diseñar un procedimiento
        que plantee objetos de ese tipo un nivel en la torre. Mostrar cómo
        instalar una @c(raise) operación genérica que funcione para cada tipo
        (excepto complejo).

#      :: @t(Exercise 2.84) :: Using the @c(raise) operation of @l(#Exercise 2.83),
#         modify the @c(apply-generic) procedure so that it coerces its arguments to
#         have the same type by the method of successive raising, as discussed in
#         this section. You will need to devise a way to test which of two types is
#         higher in the tower. Do this in a manner that is @"(compatible) with the
#         rest of the system and will not lead to problems in adding new levels to
#         the tower.
     :: @t(Ejercicio 2.84) :: Usando la @c(raise) operación del
        @l(#Ejercicio 2.83), modifique el procedimiento @c(apply-generic) para que coaccione sus argumentos para que tengan el mismo
        tipo por el método de elevación sucesiva, como se discute en esta
        sección. Usted necesitará idear una manera de probar cuál de dos tipos
        es más alto en la torre. Haga esto de una manera que sea @"(compatible)
        con el resto del sistema y no dará lugar a problemas en la adición de
        nuevos niveles a la torre.

#      :: @t(Exercise 2.85) :: This section mentioned a method for @"(simplifying) a
#         data object by lowering it in the tower of types as far as possible. Design
#         a procedure @c(drop) that accomplishes this for the tower described in
#         @l(#Exercise 2.83). The key is to decide, in some general way, whether an
#         object can be lowered. For example, the complex number @m(1.5 + 0i) can be
#         lowered as far as @c(real), the complex number @m(1 + 0i) can be lowered as
#         far as @c(integer), and the complex number @m(2 + 3i) cannot be lowered at
#         all. Here is a plan for determining whether an object can be lowered: Begin
#         by defining a generic operation @c(project) that @"(pushes) an object down
#         in the tower. For example, projecting a complex number would involve
#         throwing away the imaginary part. Then a number can be dropped if, when we
#         @c(project) it and @c(raise) the result back to the type we started with,
#         we end up with something equal to what we started with. Show how to
#         implement this idea in detail, by writing a @c(drop) procedure that drops
#         an object as far as possible. You will need to design the various
#         projection operations@n(119) and install @c(project) as a generic operation
#         in the system. You will also need to make use of a generic equality
#         predicate, such as described in @l(#Exercise 2.79). Finally, use @c(drop)
#         to rewrite @c(apply-generic) from @l(#Exercise 2.84) so that it
#         @"(simplifies) its answers.
     :: @t(Ejercicio 2.85) :: Esta sección menciona un método para
        @"(simplificar) un objeto de datos bajándolo en la torre de tipos en la
        medida de lo posible. Diseñe un procedimiento @c(drop) que lo haga para
        la torre descrita en el @l(#Ejercicio 2.83). La clave es
        decidir, de alguna manera general, si un objeto puede ser bajado. Por
        ejemplo, se puede bajar el número complejo @m(1.5 + 0i) hasta el punto
        de que @c(real) el número complejo @m(1 + 0i) se puede bajar hasta
        @c(integer), y el número complejo @m(2 + 3i) no se puede bajar en
        absoluto. Aquí hay un plan para determinar si un objeto puede ser
        bajado: Comience definiendo una operación genérica @c(project) que
        @"(empuja) un objeto hacia abajo en la torre. Por ejemplo, Proyectar un
        número complejo implicaría tirar la parte imaginaria. @c(project)
        Entonces un número se puede caer si, cuando nosotros y @c(raise) el
        resultado de nuevo al tipo que comenzamos con, terminamos con algo igual
        a lo que empezamos. Muestre cómo implementar esta idea en detalle,
        escribiendo un procedimiento @c(drop) que suelte un objeto en la medida
        de lo posible. Deberá diseñar las diversas operaciones de proyección
       @n(119) e instalarlas @c(project) como una operación genérica en
        el sistema. También necesitará hacer uso de un predicado genérico de
        igualdad, tal como se describe en el @l(#Ejercicio
        2.79). Finalmente, use @c(drop) para reescribir @c(apply-generic) desde
        el @l(#Ejercicio 2.84) para @"(simplificar) sus
        respuestas.

#      :: @t(Exercise 2.86) :: Suppose we want to handle complex numbers whose real
#         parts, imaginary parts, magnitudes, and angles can be either ordinary
#         numbers, rational numbers, or other numbers we might wish to add to the
#         system. Describe and implement the changes to the system needed to
#         accommodate this. You will have to define operations such as @c(sine) and
#         @c(cosine) that are generic over ordinary numbers and rational numbers.
     :: @t(Ejercicio 2.86) :: Supongamos que queremos manejar números complejos
        cuyas partes reales, partes imaginarias, magnitudes y ángulos pueden ser
        números ordinarios, números racionales u otros números que podríamos
        agregar al sistema. Describir e implementar los cambios en el sistema
        necesarios para acomodar esto. Tendrás que definir operaciones como
        @c(sine) y @c(cosine) que son genéricas sobre números ordinarios y
        números racionales.

# *** 2.5.3 <> Example: Symbolic Algebra
*** 2.5.3 <> Ejemplo: Álgebra simbólica

#     The manipulation of symbolic algebraic expressions is a complex process that
#     illustrates many of the hardest problems that occur in the design of
#     large-scale systems. An algebraic expression, in general, can be viewed as a
#     hierarchical structure, a tree of operators applied to operands. We can
#     construct algebraic expressions by starting with a set of primitive objects,
#     such as constants and variables, and combining these by means of algebraic
#     operators, such as addition and multiplication. As in other languages, we form
#     abstractions that enable us to refer to compound objects in simple terms.
#     Typical abstractions in symbolic algebra are ideas such as linear combination,
#     polynomial, rational function, or trigonometric function. We can regard these
#     as compound @"(types,) which are often useful for directing the processing of
#     expressions. For example, we could describe the expression
    La manipulación de expresiones algebraicas simbólicas es un proceso complejo
    que ilustra muchos de los problemas más difíciles que se presentan en el
    diseño de sistemas a gran escala. Una expresión algebraica, en general,
    puede ser vista como una estructura jerárquica, un árbol de operadores
    aplicados a los operandos. Podemos construir expresiones algebraicas
    comenzando con un conjunto de objetos primitivos, tales como constantes y
    variables, y combinándolos mediante operadores algebraicos, tales como
    adición y multiplicación. Como en otros idiomas, formamos abstracciones que
    nos permiten referirnos a los objetos compuestos en términos simples. Las
    abstracciones típicas en álgebra simbólica son ideas tales como combinación
    lineal, polinomio, función racional o función trigonométrica. Podemos
    considerarlos como @"(tipos) compuestos @"(, ) Que a menudo son útiles para
    dirigir el procesamiento de expresiones. Por ejemplo, podríamos describir la
    expresión

#     ..example >
#       x² sin (y² + 1) + x cos 2y + cos(y³ − 2y²)
#     < example..
    ..example >
      x² sin (y² + 1) + x cos 2y + cos(y³ − 2y²)
    < example..

#     as a polynomial in @m(x) with coefficients that are trigonometric functions of
#     polynomials in @m(y) whose coefficients are integers.
    Como polinomio en @m(x) con coeficientes que son funciones trigonométricas
    de polinomios en @m(y) cuyos coeficientes son enteros.

#     We will not attempt to develop a complete algebraic-manipulation system here.
#     Such systems are exceedingly complex programs, embodying deep algebraic
#     knowledge and elegant algorithms. What we will do is look at a simple but
#     important part of algebraic manipulation: the arithmetic of polynomials. We
#     will illustrate the kinds of decisions the designer of such a system faces,
#     and how to apply the ideas of abstract data and generic operations to help
#     organize this effort.
    No intentaremos desarrollar aquí un sistema completo de manipulación
    algebraica. Tales sistemas son programas extremadamente complejos,
    incorporando el conocimiento algebraic profundo y algoritmos elegantes. Lo
    que haremos es mirar una parte simple pero importante de la manipulación
    algebraica: la aritmética de los polinomios. Ilustramos los tipos de
    decisiones que el diseñador de un sistema de este tipo enfrenta y cómo
    aplicar las ideas de datos abstractos y operaciones genéricas para ayudar a
    organizar este esfuerzo.

# **** Arithmetic on polynomials
**** Aritmética en polinomios

#      Our first task in designing a system for performing arithmetic on polynomials
#      is to decide just what a polynomial is. Polynomials are normally defined
#      relative to certain variables (the @e(indeterminates) of the polynomial).  For
#      simplicity, we will restrict ourselves to polynomials having just one
#      indeterminate (@e(univariate polynomials)).@n(120) We will define a polynomial
#      to be a sum of terms, each of which is either a coefficient, a power of the
#      indeterminate, or a product of a coefficient and a power of the
#      indeterminate. A coefficient is defined as an algebraic expression that is not
#      dependent upon the indeterminate of the polynomial. For example,
     Nuestra primera tarea en el diseño de un sistema para realizar aritmética
     en polinomios es decidir lo que es un polinomio. Los polinomios se definen
     normalmente con respecto a ciertas variables (los @e(indeterminados) del
     polinomio). Por simplicidad, nos restringiremos a polinomios que tengan
     sólo un @e(polinomio) indeterminado (@e(univariante) ).@n(120)
     definiremos un polinomio ser una suma de términos, cada uno de los cuales
     es o bien un coeficiente, una potencia de la indeterminada, o un producto
     de un coeficiente y una potencia de la indeterminada. Un coeficiente se
     define como una expresión algebraica que no depende del indeterminado del
     polinomio. Por ejemplo,

#      ..example >
#        5x² + 3x + 7
#      < example..
     ..example >
       5x² + 3x + 7
     < example..

#      is a simple polynomial in @m(x), and
     Es un polinomio simple en @m(x), y

#      ..example >
#        (y² + 1)x³ + (2y)x + 1
#      < example..
     ..example >
       (y² + 1)x³ + (2y)x + 1
     < example..

#      is a polynomial in @m(x) whose coefficients are polynomials in @m(y).
     Es un polinomio en @m(x) cuyos coeficientes son polinomios en @m(y).

#      Already we are skirting some thorny issues. Is the first of these polynomials
#      the same as the polynomial @m(5y² + 3y + 7), or not?  A reasonable answer
#      might be @"(yes, if we are considering a polynomial purely as a mathematical
#      function, but no, if we are considering a polynomial to be a syntactic form.)
#      The second polynomial is algebraically equivalent to a polynomial in @m(y)
#      whose coefficients are polynomials in @m(x). Should our system recognize this,
#      or not?  Furthermore, there are other ways to represent a polynomial––for
#      example, as a product of factors, or (for a univariate polynomial) as the set
#      of roots, or as a listing of the values of the polynomial at a specified set
#      of points.@n(121) We can finesse these questions by deciding that in our
#      algebraic-manipulation system a @"(polynomial) will be a particular syntactic
#      form, not its underlying mathematical meaning.
     Ya estamos contorneando algunos problemas espinosos. ¿Es el primero de
     estos polinomios igual que el polinomio @m(5y² + 3y + 7), o no? Una
     respuesta razonable podría ser @"(sí, si estamos considerando un polinomio
     puramente como una función matemática, pero no, si estamos considerando un
     polinomio como una forma sintáctica. ) El segundo polinomio es
     algebraicamente equivalente a un polinomio en @m(y) cuyos coeficientes son
     polinomios en @m(x). ¿Debería nuestro sistema reconocer esto, o no? Además,
     hay otras maneras de representar un polinomio - por ejemplo, como un
     producto de factores, o (para un polinomio univariante) como el conjunto de
     raíces, o como una lista de los valores del polinomio en un conjunto de
     puntos especificados .@n(121)

#      Now we must consider how to go about doing arithmetic on polynomials. In this
#      simple system, we will consider only addition and multiplication. Moreover, we
#      will insist that two polynomials to be combined must have the same
#      indeterminate.
     Ahora debemos considerar cómo hacer aritmética en polinomios. En este
     sistema simple, consideraremos solamente la adición y la
     multiplicación. Además, insistiremos en que dos polinomios que se combinan
     deben tener el mismo indeterminado.

#      We will approach the design of our system by following the familiar discipline
#      of data abstraction. We will represent polynomials using a data structure
#      called a @e(poly), which consists of a variable and a collection of terms. We
#      assume that we have selectors @c(variable) and @c(term-list) that extract
#      those parts from a poly and a constructor @c(make-poly) that assembles a poly
#      from a given variable and a term list. A variable will be just a symbol, so we
#      can use the @c(same-variable?)  procedure of section @l(#2.3.2) to compare
#      variables. The following procedures define addition and multiplication of
#      polys:
     Nos acercaremos al diseño de nuestro sistema siguiendo la disciplina
     familiar de la abstracción de datos. Representaremos polinomios usando una
     estructura de datos llamada @e(poly), que consiste en una variable y una
     colección de términos. Suponemos que tenemos selectores @c(variable) y
     @c(term-list) que extraemos esas partes de un poli y un constructor
     @c(make-poly) que ensambla un poly de una variable dada y una lista de
     términos. Una variable será sólo un símbolo, por lo que podemos usar el
     procedimiento @c(same-variable?) de la seccion @l(#2.3.2) para comparar
     variables. Los siguientes procedimientos definen la adición y
     multiplicación de polys:

#      ..src > scheme
#        (define (add-poly p1 p2)
#          (if (same-variable? (variable p1)
#                              (variable p2))
#              (make-poly
#               (variable p1)
#               (add-terms (term-list p1)
#                          (term-list p2)))
#              (error "Polys not in same var:
#                      ADD-POLY"
#                     (list p1 p2))))
#
#        (define (mul-poly p1 p2)
#          (if (same-variable? (variable p1)
#                              (variable p2))
#              (make-poly
#               (variable p1)
#               (mul-terms (term-list p1)
#                          (term-list p2)))
#              (error "Polys not in same var:
#                      MUL-POLY"
#                     (list p1 p2))))
#      < src..
     ..src > scheme
       (define (add-poly p1 p2)
         (if (same-variable? (variable p1)
                             (variable p2))
             (make-poly
              (variable p1)
              (add-terms (term-list p1)
                         (term-list p2)))
             (error "Polys not in same var:
                     ADD-POLY"
                    (list p1 p2))))

       (define (mul-poly p1 p2)
         (if (same-variable? (variable p1)
                             (variable p2))
             (make-poly
              (variable p1)
              (mul-terms (term-list p1)
                         (term-list p2)))
             (error "Polys not in same var:
                     MUL-POLY"
                    (list p1 p2))))
     < src..

#      To incorporate polynomials into our generic arithmetic system, we need to
#      supply them with type tags. We'll use the tag @c(polynomial), and install
#      appropriate operations on tagged polynomials in the operation table. We'll
#      embed all our code in an installation procedure for the polynomial package,
#      similar to the ones in section @l(#2.5.1):
     Para incorporar polinomios en nuestro sistema aritmético genérico,
     necesitamos suministrarlos con etiquetas de tipo. Usaremos la etiqueta
     @c(polynomial) e instalaremos las operaciones apropiadas en polinomios
     etiquetados en la tabla de operaciones. Incorporaremos todo nuestro código
     en un procedimiento de instalación para el paquete polinomial, similar al
     de la seccion @l(#2.5.1) :

#      ..src > scheme
#        (define (install-polynomial-package)
#          ;; internal procedures
#          ;; representation of poly
#          (define (make-poly variable term-list)
#            (cons variable term-list))
#          (define (variable p) (car p))
#          (define (term-list p) (cdr p))
#          ⟨procedures same-variable?
#           and variable? from section 2.3.2)
#
#          ;; representation of terms and term lists
#          ⟨procedures adjoin-term) … coeff
#          from text below)⟩
#
#          (define (add-poly p1 p2) …)
#          ⟨procedures used by add-poly)
#          (define (mul-poly p1 p2) …)
#          ⟨procedures used by mul-poly)
#
#          ;; interface to rest of the system
#          (define (tag p) (attach-tag 'polynomial p))
#          (put 'add '(polynomial polynomial)
#               (lambda (p1 p2)
#                 (tag (add-poly p1 p2))))
#          (put 'mul '(polynomial polynomial)
#               (lambda (p1 p2)
#                 (tag (mul-poly p1 p2))))
#          (put 'make 'polynomial
#               (lambda (var terms)
#                 (tag (make-poly var terms))))
#          'done)
#      < src..
     ..src > scheme
       (define (install-polynomial-package)
         ;; internal procedures
         ;; representation of poly
         (define (make-poly variable term-list)
           (cons variable term-list))
         (define (variable p) (car p))
         (define (term-list p) (cdr p))
         ⟨procedures same-variable?
          and variable? from section 2.3.2)

         ;; representation of terms and term lists
         ⟨procedures adjoin-term) … coeff
         from text below)⟩

         (define (add-poly p1 p2) …)
         ⟨procedures used by add-poly)
         (define (mul-poly p1 p2) …)
         ⟨procedures used by mul-poly)

         ;; interface to rest of the system
         (define (tag p) (attach-tag 'polynomial p))
         (put 'add '(polynomial polynomial)
              (lambda (p1 p2)
                (tag (add-poly p1 p2))))
         (put 'mul '(polynomial polynomial)
              (lambda (p1 p2)
                (tag (mul-poly p1 p2))))
         (put 'make 'polynomial
              (lambda (var terms)
                (tag (make-poly var terms))))
         'done)
     < src..

#      Polynomial addition is performed termwise. Terms of the same order (i.e., with
#      the same power of the indeterminate) must be combined. This is done by forming
#      a new term of the same order whose coefficient is the sum of the coefficients
#      of the addends. Terms in one addend for which there are no terms of the same
#      order in the other addend are simply accumulated into the sum polynomial being
#      constructed.
     La adición de polinomios se realiza termwise. Los términos del mismo orden
     (es decir, con el mismo poder del indeterminado) deben ser combinados. Esto
     se hace formando un nuevo término del mismo orden cuyo coeficiente es la
     suma de los coeficientes de los sumandos. Los términos en un agregado para
     los cuales no hay términos del mismo orden en el otro sumando se acumulan
     simplemente en el polinomio suma que está siendo construido.

#      In order to manipulate term lists, we will assume that we have a constructor
#      @c(the-empty-termlist) that returns an empty term list and a constructor
#      @c(adjoin-term) that adjoins a new term to a term list. We will also assume
#      that we have a predicate @c(empty-termlist?) that tells if a given term list
#      is empty, a selector @c(first-term) that extracts the highest-order term from
#      a term list, and a selector @c(rest-terms) that returns all but the
#      highest-order term. To manipulate terms, we will suppose that we have a
#      constructor @c(make-term) that constructs a term with given order and
#      coefficient, and selectors @c(order) and @c(coeff) that return, respectively,
#      the order and the coefficient of the term. These operations allow us to
#      consider both terms and term lists as data abstractions, whose concrete
#      representations we can worry about separately.
     Para manipular listas de términos, asumiremos que tenemos un constructor
     @c(the-empty-termlist) que devuelve una lista de términos vacía y un
     constructor @c(adjoin-term) que se asocia a un nuevo término a una lista de
     términos. También asumiremos que tenemos un predicado @c(empty-termlist?)
     que dice si una lista de términos determinada está vacía, un selector
     @c(first-term) que extrae el término de orden más alto de una lista de
     términos y un selector @c(rest-terms) que devuelve todo menos el término de
     orden más alto. Para manipular términos, supongamos que tenemos un
     constructor @c(make-term) que construye un término con orden dado y
     coeficiente, y selectores @c(order) y @c(coeff) que devuelven,
     respectivamente, el orden y el coeficiente del término. Estas operaciones
     nos permiten considerar términos y listas de términos como abstracciones de
     datos, cuyas representaciones concretas podemos preocuparnos por separado.

#      Here is the procedure that constructs the term list for the sum of two
#      polynomials:@n(122)
     Aquí está el procedimiento que construye la lista de términos para la suma
     de dos polinomios:@n(122)

#      ..src > scheme
#        (define (add-terms L1 L2)
#          (cond ((empty-termlist? L1) L2)
#                ((empty-termlist? L2) L1)
#                (else
#                 (let ((t1 (first-term L1))
#                       (t2 (first-term L2)))
#                   (cond ((> (order t1) (order t2))
#                          (adjoin-term
#                           t1
#                           (add-terms (rest-terms L1)
#                                      L2)))
#                         ((< (order t1) (order t2))
#                          (adjoin-term
#                           t2
#                           (add-terms
#                            L1
#                            (rest-terms L2))))
#                         (else
#                          (adjoin-term
#                           (make-term
#                            (order t1)
#                            (add (coeff t1)
#                                 (coeff t2)))
#                           (add-terms
#                            (rest-terms L1)
#                            (rest-terms L2)))))))))
#      < src..
     ..src > scheme
       (define (add-terms L1 L2)
         (cond ((empty-termlist? L1) L2)
               ((empty-termlist? L2) L1)
               (else
                (let ((t1 (first-term L1))
                      (t2 (first-term L2)))
                  (cond ((> (order t1) (order t2))
                         (adjoin-term
                          t1
                          (add-terms (rest-terms L1)
                                     L2)))
                        ((< (order t1) (order t2))
                         (adjoin-term
                          t2
                          (add-terms
                           L1
                           (rest-terms L2))))
                        (else
                         (adjoin-term
                          (make-term
                           (order t1)
                           (add (coeff t1)
                                (coeff t2)))
                          (add-terms
                           (rest-terms L1)
                           (rest-terms L2)))))))))
     < src..

#      The most important point to note here is that we used the generic addition
#      procedure @c(add) to add together the coefficients of the terms being
#      combined. This has powerful consequences, as we will see below.
     El punto más importante a destacar aquí es que usamos el procedimiento de
     adición genérica @c(add) para sumar los coeficientes de los términos que se
     combinan. Esto tiene consecuencias poderosas, como veremos a continuación.

#      In order to multiply two term lists, we multiply each term of the first list
#      by all the terms of the other list, repeatedly using
#      @c(mul-term-by-all-terms), which multiplies a given term by all terms in a
#      given term list. The resulting term lists (one for each term of the first
#      list) are accumulated into a sum.  Multiplying two terms forms a term whose
#      order is the sum of the orders of the factors and whose coefficient is the
#      product of the coefficients of the factors:
     Para multiplicar dos listas de términos, multiplicamos cada término de la
     primera lista por todos los términos de la otra lista, utilizando
     repetidamente @c(mul-term-by-all-terms), lo que multiplica un término dado
     por todos los términos de una lista de términos dada. Las listas de
     términos resultantes (una para cada término de la primera lista) se
     acumulan en una suma. La multiplicación de dos términos forma un término
     cuyo orden es la suma de los órdenes de los factores y cuyo coeficiente es
     el producto de los coeficientes de los factores:

#      ..src > scheme
#        (define (mul-terms L1 L2)
#          (if (empty-termlist? L1)
#              (the-empty-termlist)
#              (add-terms
#               (mul-term-by-all-terms
#                (first-term L1) L2)
#               (mul-terms (rest-terms L1) L2))))
#
#        (define (mul-term-by-all-terms t1 L)
#          (if (empty-termlist? L)
#              (the-empty-termlist)
#              (let ((t2 (first-term L)))
#                (adjoin-term
#                 (make-term
#                  (+ (order t1) (order t2))
#                  (mul (coeff t1) (coeff t2)))
#                 (mul-term-by-all-terms
#                  t1
#                  (rest-terms L))))))
#      < src..
     ..src > scheme
       (define (mul-terms L1 L2)
         (if (empty-termlist? L1)
             (the-empty-termlist)
             (add-terms
              (mul-term-by-all-terms
               (first-term L1) L2)
              (mul-terms (rest-terms L1) L2))))

       (define (mul-term-by-all-terms t1 L)
         (if (empty-termlist? L)
             (the-empty-termlist)
             (let ((t2 (first-term L)))
               (adjoin-term
                (make-term
                 (+ (order t1) (order t2))
                 (mul (coeff t1) (coeff t2)))
                (mul-term-by-all-terms
                 t1
                 (rest-terms L))))))
     < src..

#      This is really all there is to polynomial addition and multiplication. Notice
#      that, since we operate on terms using the generic procedures @c(add) and
#      @c(mul), our polynomial package is automatically able to handle any type of
#      coefficient that is known about by the generic arithmetic package. If we
#      include a coercion mechanism such as one of those discussed in section @l(#2.5.2),
#      then we also are automatically able to handle operations on polynomials of
#      different coefficient types, such as
     Esto es realmente todo lo que hay a la adición polinómica y la
     multiplicación. Obsérvese que, puesto que operamos en términos que usan los
     procedimientos genéricos @c(add) y @c(mul), nuestro paquete polinómico es
     capaz de manejar automáticamente cualquier tipo de coeficiente que se
     conozca con el paquete aritmético genérico. Si incluimos un mecanismo de
     coerción como uno de los discutidos en la seccion @l(#2.5.2), entonces también
     podemos manejar automáticamente operaciones en polinomios de diferentes
     tipos de coeficientes, como

#      ..example >
#                                ┌      2              ┐
#        [3x² + (2 + 3i)x + 7] ⋅ │x⁴ + ---x² + (5 + 3i)│
#                                └      3              ┘
#      < example..
     ..example >
                               ┌      2              ┐
       [3x² + (2 + 3i)x + 7] ⋅ │x⁴ + ---x² + (5 + 3i)│
                               └      3              ┘
     < example..

#      Because we installed the polynomial addition and multiplication procedures
#      @c(add-poly) and @c(mul-poly) in the generic arithmetic system as the @c(add)
#      and @c(mul) operations for type @c(polynomial), our system is also
#      automatically able to handle polynomial operations such as
     Debido a que instalamos los procedimientos de adición y multiplicación de
     polinomios @c(add-poly) y @c(mul-poly) en el sistema aritmético genérico
     como operaciones @c(add) y @c(mul) para el tipo @c(polynomial), nuestro
     sistema también es capaz de manejar automáticamente operaciones
     polinomiales como

#      ..example >
#        [(y + 1)x² + (y² + 1)x + (y − 1)] ⋅ [(y − 2)x + (y³ + 7)]
#      < example..
     ..example >
       [(y + 1)x² + (y² + 1)x + (y − 1)] ⋅ [(y − 2)x + (y³ + 7)]
     < example..

#      The reason is that when the system tries to combine coefficients, it will
#      dispatch through @c(add) and @c(mul). Since the coefficients are themselves
#      polynomials (in @m(y)), these will be combined using @c(add-poly) and
#      @c(mul-poly). The result is a kind of @"(data-directed recursion) in which,
#      for example, a call to @c(mul-poly) will result in recursive calls to
#      @c(mul-poly) in order to multiply the coefficients. If the coefficients of the
#      coefficients were themselves polynomials (as might be used to represent
#      polynomials in three variables), the data direction would ensure that the
#      system would follow through another level of recursive calls, and so on
#      through as many levels as the structure of the data dictates.@n(123)
     La razón es que cuando el sistema intenta combinar coeficientes, enviará a
     través de @c(add) y @c(mul). Puesto que los coeficientes son ellos mismos
     polinomios (en @m(y) ), éstos se combinarán usando @c(add-poly) y
     @c(mul-poly). El resultado es un tipo de @"(recursión dirigida a datos) en
     la que, por ejemplo, una llamada a, @c(mul-poly) dará lugar a llamadas
     recursivas @c(mul-poly) para multiplicar los coeficientes. Si los
     coeficientes de los coeficientes fueran polinomios (como podría ser
     utilizado para representar polinomios en tres variables), la dirección de
     datos aseguraría que el sistema seguiría a través de otro nivel de llamadas
     recursivas, y así sucesivamente a través de tantos niveles como la
     estructura de Dicta la información.@n(123)

# **** Representing term lists
**** Representación de listas de términos

#      Finally, we must confront the job of implementing a good representation for
#      term lists. A term list is, in effect, a set of coefficients keyed by the
#      order of the term. Hence, any of the methods for representing sets, as
#      discussed in section @l(#2.3.3), can be applied to this task. On the other hand, our
#      procedures @c(add-terms) and @c(mul-terms) always access term lists
#      sequentially from highest to lowest order. Thus, we will use some kind of
#      ordered list representation.
     Finalmente, debemos enfrentar el trabajo de implementar una buena
     representación para las listas de términos. Una lista de términos es, en
     efecto, un conjunto de coeficientes codificados por el orden del
     término. Por lo tanto, cualquiera de los métodos para representar
     conjuntos, como se describe en la seccion @l(#2.3.3), se puede aplicar a esta
     tarea. Por otro lado, nuestros procedimientos @c(add-terms) y @c(mul-terms)
     siempre acceder a listas de términos secuencialmente de mayor a menor
     orden. Por lo tanto, usaremos algún tipo de representación de lista
     ordenada.

#      How should we structure the list that represents a term list?  One
#      consideration is the @"(density) of the polynomials we intend to manipulate. A
#      polynomial is said to be @e(dense) if it has nonzero coefficients in terms of
#      most orders. If it has many zero terms it is said to be @e(sparse). For
#      example,
     ¿Cómo debemos estructurar la lista que representa una lista de términos?
     Una consideración es la @"(densidad) de los polinomios que pretendemos
     manipular. Se dice que un polinomio es @e(denso) si tiene coeficientes no
     nulos en términos de la mayoría de los pedidos. Si tiene muchos términos
     cero se dice que es @e(escaso). Por ejemplo,

#      ..example >
#        A: x⁵ + 2x⁴ + 3x² − 2x − 5
#      < example..
     ..example >
       A: x⁵ + 2x⁴ + 3x² − 2x − 5
     < example..

#      is a dense polynomial, whereas
     Es un polinomio denso, mientras que

#      ..example >
#        B: x¹⁰⁰ + 2x² + 1
#      < example..
     ..example >
       B: x¹⁰⁰ + 2x² + 1
     < example..

#      is sparse.
     Es escaso.

#      The term lists of dense polynomials are most efficiently represented as lists
#      of the coefficients. For example, @m(a) above would be nicely represented as
#      @c[(1 2 0 3 -2 -5)]. The order of a term in this representation is the length
#      of the sublist beginning with that term's coefficient, decremented by
#      1.@n(124) This would be a terrible representation for a sparse polynomial such
#      as @m(B): There would be a giant list of zeros punctuated by a few lonely
#      nonzero terms. A more reasonable representation of the term list of a sparse
#      polynomial is as a list of the nonzero terms, where each term is a list
#      containing the order of the term and the coefficient for that order. In such a
#      scheme, polynomial @m(B) is efficiently represented as @c[((100 1) (2 2) (0
#      1))]. As most polynomial manipulations are performed on sparse polynomials, we
#      will use this method. We will assume that term lists are represented as lists
#      of terms, arranged from highest-order to lowest-order term. Once we have made
#      this decision, implementing the selectors and constructors for terms and term
#      lists is straightforward:@n(125)
     Las listas de términos de polinomios densos se representan más
     eficientemente como listas de los coeficientes. Por ejemplo, @m(a) arriba
     sería representado agradablemente como @c[(1 2 0 3 -2 -5)]. El orden de un
     término en esta representación es la longitud de la sublista que comienza
     con el coeficiente de dicho término, decrementado por 1.@n(124) Esta
     sería una representación terrible para un polinomio escaso tal como @m(B) :
     Habría una lista gigante de ceros puntuada por un Pocos términos solitarios
     no distintos de cero. Una representación más razonable del término lista de
     un polinomio escaso es como una lista de los términos distintos de cero,
     donde cada término es una lista que contiene el orden del término y el
     coeficiente para ese orden. En tal esquema, el polinomio @m(B) se
     representa eficientemente como @c[((100 1) (2 2) (0 1))]. Como la mayoría
     de las manipulaciones polinomiales se realizan en polinomios escasos, vamos
     a utilizar este método. Supondremos que las listas de términos se
     representan como listas de términos, ordenadas desde el orden más alto al
     término más bajo.@n(125)

#      ..src > scheme
#        (define (adjoin-term term term-list)
#          (if (=zero? (coeff term))
#              term-list
#              (cons term term-list)))
#        (define (the-empty-termlist) '())
#        (define (first-term term-list) (car term-list))
#        (define (rest-terms term-list) (cdr term-list))
#        (define (empty-termlist? term-list)
#          (null? term-list))
#        (define (make-term order coeff)
#          (list order coeff))
#        (define (order term) (car term))
#        (define (coeff term) (cadr term))
#      < src..
     ..src > scheme
       (define (adjoin-term term term-list)
         (if (=zero? (coeff term))
             term-list
             (cons term term-list)))
       (define (the-empty-termlist) '())
       (define (first-term term-list) (car term-list))
       (define (rest-terms term-list) (cdr term-list))
       (define (empty-termlist? term-list)
         (null? term-list))
       (define (make-term order coeff)
         (list order coeff))
       (define (order term) (car term))
       (define (coeff term) (cadr term))
     < src..

#      where @c(=zero?) is as defined in @l(#Exercise 2.80). (See also @l(#Exercise
#      2.87) below.)
     Donde @c(=zero?) es como se define en el @l(#Ejercicio
     2.80). (Véase también el @l(#Ejercicio 2.87 más) abajo.)

#      Users of the polynomial package will create (tagged) polynomials by means of
#      the procedure:
     Los usuarios del paquete polinomial crearán polinomios (marcados) mediante
     el procedimiento:

#      ..src > scheme
#        (define (make-polynomial var terms)
#          ((get 'make 'polynomial) var terms))
#      < src..
     ..src > scheme
       (define (make-polynomial var terms)
         ((get 'make 'polynomial) var terms))
     < src..

#      :: @t(Exercise 2.87) :: Install @c(=zero?) for polynomials in the generic
#         arithmetic package. This will allow @c(adjoin-term) to work for polynomials
#         with coefficients that are themselves polynomials.
     :: @t(Ejercicio 2.87) :: Instalar @c(=zero?) para polinomios en el paquete
        aritmético genérico. Esto permitirá @c(adjoin-term) trabajar para
        polinomios con coeficientes que son ellos mismos polinomios.

#      :: @t(Exercise 2.88) :: Extend the polynomial system to include subtraction of
#         polynomials. (Hint: You may find it helpful to define a generic negation
#         operation.)
     :: @t(Ejercicio 2.88) :: Extender el sistema polinomial para incluir la
        sustracción de polinomios. (Sugerencia: puede resultar útil definir una
        operación de negación genérica.)

#      :: @t(Exercise 2.89) :: Define procedures that implement the term-list
#         representation described above as appropriate for dense polynomials.
     :: @t(Ejercicio 2.89) :: Definir procedimientos que implementan la
        representación de lista de términos descrita anteriormente como
        apropiada para polinomios densos.

#      :: @t(Exercise 2.90) :: Suppose we want to have a polynomial system that is
#         efficient for both sparse and dense polynomials. One way to do this is to
#         allow both kinds of term-list representations in our system. The situation
#         is analogous to the complex-number example of section @l(#2.4), where we allowed
#         both rectangular and polar representations. To do this we must distinguish
#         different types of term lists and make the operations on term lists
#         generic. Redesign the polynomial system to implement this
#         generalization. This is a major effort, not a local change.
     :: @t(Ejercicio 2.90) :: Supongamos que queremos tener un sistema
        polinomial que sea eficiente tanto para polinomios escasos como
        densos. Una forma de hacerlo es permitir que ambos tipos de
        representaciones de lista de términos en nuestro sistema. La situación
        es análoga al ejemplo del número complejo de la seccion @l(#2.4), donde
        permitimos representaciones tanto rectangulares como polares. Para hacer
        esto debemos distinguir diferentes tipos de listas de términos y hacer
        que las operaciones en listas de términos sean genéricas. Rediseñar el
        sistema polinomial para implementar esta generalización. Este es un
        esfuerzo importante, no un cambio local.

#      :: @t(Exercise 2.91) :: A univariate polynomial can be divided by another one
#         to produce a polynomial quotient and a polynomial remainder. For example,
     :: @t(Ejercicio 2.91) :: Un polinomio univariante puede ser dividido por
        otro para producir un cociente polinomial y un resto polinomial. Por
        ejemplo,

#         ..example >
#           x⁵ − 1
#           ------ = x³ + x, remainder x − 1
#           x² − 1
#         < example..
        ..example >
          x⁵ − 1
          ------ = x³ + x, remainder x − 1
          x² − 1
        < example..

#         Division can be performed via long division. That is, divide the
#         highest-order term of the dividend by the highest-order term of the
#         divisor. The result is the first term of the quotient. Next, multiply the
#         result by the divisor, subtract that from the dividend, and produce the
#         rest of the answer by recursively dividing the difference by the
#         divisor. Stop when the order of the divisor exceeds the order of the
#         dividend and declare the dividend to be the remainder. Also, if the
#         dividend ever becomes zero, return zero as both quotient and remainder.
        La división se puede realizar a través de la división larga. Es decir,
        divida el término de orden más alto del dividendo por el término de
        orden más alto del divisor. El resultado es el primer término del
        cociente. A continuación, multiplique el resultado por el divisor,
        restarlo del dividendo y producir el resto de la respuesta dividiendo
        recursivamente la diferencia por el divisor. Detener cuando el orden del
        divisor excede el orden del dividendo y declarar el dividendo como el
        resto. Además, si el dividendo se vuelve cero, devuelve cero como
        cociente y resto.

#         We can design a @c(div-poly) procedure on the model of @c(add-poly) and
#         @c(mul-poly). The procedure checks to see if the two polys have the same
#         variable. If so, @c(div-poly) strips off the variable and passes the
#         problem to @c(div-terms), which performs the division operation on term
#         lists. @c(Div-poly) finally reattaches the variable to the result supplied
#         by @c(div-terms). It is convenient to design @c(div-terms) to compute both
#         the quotient and the remainder of a division. @c(Div-terms) can take two
#         term lists as arguments and return a list of the quotient term list and the
#         remainder term list.
        Podemos diseñar un procedimiento @c(div-poly) sobre el modelo de
        @c(add-poly) y @c(mul-poly). El procedimiento comprueba si los dos polys
        tienen la misma variable. Si es así, @c(div-poly) quita la variable y
        pasa el problema a @c(div-terms), que realiza la operación de división
        en las listas de términos. @c(Div-poly) Finalmente vuelve a conectar la
        variable al resultado suministrado por @c(div-terms). Es conveniente
        diseñar @c(div-terms) para calcular tanto el cociente como el resto de
        una división. @c(Div-terms) Puede tomar dos listas de términos como
        argumentos y devolver una lista de la lista de términos de cociente y la
        lista de términos restantes.

#         Complete the following definition of @c(div-terms) by filling in the
#         missing expressions. Use this to implement @c(div-poly), which takes two
#         polys as arguments and returns a list of the quotient and remainder polys.
        Complete la siguiente definición de @c(div-terms) rellenando las
        expresiones que faltan. Utilice esto para implementar @c(div-poly), que
        toma dos polys como argumentos y devuelve una lista del cociente y del
        resto polys.

#         ..src > scheme
#           (define (div-terms L1 L2)
#             (if (empty-termlist? L1)
#                 (list (the-empty-termlist)
#                       (the-empty-termlist))
#                 (let ((t1 (first-term L1))
#                       (t2 (first-term L2)))
#                   (if (> (order t2) (order t1))
#                       (list (the-empty-termlist) L1)
#                       (let ((new-c (div (coeff t1)
#                                         (coeff t2)))
#                             (new-o (- (order t1)
#                                       (order t2))))
#                         (let ((rest-of-result
#                                ⟨compute rest of result
#                                recursively⟩ ))
#                           ⟨form complete result⟩ ))))))
#         < src..
        ..src > scheme
          (define (div-terms L1 L2)
            (if (empty-termlist? L1)
                (list (the-empty-termlist)
                      (the-empty-termlist))
                (let ((t1 (first-term L1))
                      (t2 (first-term L2)))
                  (if (> (order t2) (order t1))
                      (list (the-empty-termlist) L1)
                      (let ((new-c (div (coeff t1)
                                        (coeff t2)))
                            (new-o (- (order t1)
                                      (order t2))))
                        (let ((rest-of-result
                               ⟨compute rest of result
                               recursively⟩ ))
                          ⟨form complete result⟩ ))))))
        < src..

# **** Hierarchies of types in symbolic algebra
**** Jerarquías de tipos en álgebra simbólica

#      Our polynomial system illustrates how objects of one type (polynomials) may in
#      fact be complex objects that have objects of many different types as parts.
#      This poses no real difficulty in defining generic operations. We need only
#      install appropriate generic operations for performing the necessary
#      manipulations of the parts of the compound types. In fact, we saw that
#      polynomials form a kind of @"(recursive data abstraction,) in that parts of a
#      polynomial may themselves be polynomials. Our generic operations and our
#      data-directed programming style can handle this complication without much
#      trouble.
     Nuestro sistema polinomial ilustra cómo los objetos de un tipo (polinomios)
     pueden de hecho ser objetos complejos que tienen objetos de muchos tipos
     diferentes como partes. Esto no plantea ninguna dificultad real en la
     definición de operaciones genéricas. Sólo necesitamos instalar operaciones
     genéricas apropiadas para realizar las manipulaciones necesarias de las
     partes de los tipos compuestos. De hecho, vimos que los polinomios forman
     una especie de @"(abstracción recursiva de datos,) en que partes de un
     polinomio pueden ser polinomios. Nuestras operaciones genéricas y nuestro
     estilo de programación dirigida a datos pueden manejar esta complicación
     sin mucho problema.

#      On the other hand, polynomial algebra is a system for which the data types
#      cannot be naturally arranged in a tower. For instance, it is possible to have
#      polynomials in @m(x) whose coefficients are polynomials in @m(y). It is also
#      possible to have polynomials in @m(y) whose coefficients are polynomials in
#      @m(x). Neither of these types is @"(above) the other in any natural way, yet
#      it is often necessary to add together elements from each set. There are
#      several ways to do this. One possibility is to convert one polynomial to the
#      type of the other by expanding and rearranging terms so that both polynomials
#      have the same principal variable. One can impose a towerlike structure on this
#      by ordering the variables and thus always converting any polynomial to a
#      @"(canonical form) with the highest-priority variable dominant and the
#      lower-priority variables buried in the coefficients. This strategy works
#      fairly well, except that the conversion may expand a polynomial unnecessarily,
#      making it hard to read and perhaps less efficient to work with. The tower
#      strategy is certainly not natural for this domain or for any domain where the
#      user can invent new types dynamically using old types in various combining
#      forms, such as trigonometric functions, power series, and integrals.
     Por otro lado, el álgebra polinomial es un sistema para el cual los tipos
     de datos no pueden estar dispuestos naturalmente en una torre. Por ejemplo,
     es posible tener polinomios en @m(x) cuyos coeficientes son polinomios en
     @m(y). También es posible tener polinomios en @m(y) cuyos coeficientes son
     polinomios en @m(x). Ninguno de estos tipos está por @"(encima) del otro de
     manera natural, sin embargo a menudo es necesario agregar elementos de cada
     conjunto. Hay varias formas de hacer esto. Una posibilidad es convertir un
     polinomio en el tipo del otro expandiendo y reordenando términos de modo
     que ambos polinomios tengan la misma variable principal. @"(Se puede
     imponer una estructura en forma de torre, ordenando las variables y
     convirtiendo siempre cualquier polinomio en una forma canónica) con la
     variable de prioridad más alta dominante y las variables de menor prioridad
     enterradas en los coeficientes. Esta estrategia funciona bastante bien,
     excepto que la conversión puede expandir un polinomio innecesariamente, lo
     que hace que sea difícil de leer y quizás menos eficiente para trabajar. La
     estrategia de la torre ciertamente no es natural para este dominio o para
     cualquier dominio donde el usuario pueda inventar nuevos tipos de forma
     dinámica utilizando tipos antiguos en varias formas combinadas, como
     funciones trigonométricas, series de potencias e integrales. Excepto que la
     conversión puede expandir un polinomio innecesariamente, lo que hace que
     sea difícil de leer y tal vez menos eficiente para trabajar. La estrategia
     de la torre ciertamente no es natural para este dominio o para cualquier
     dominio donde el usuario pueda inventar nuevos tipos de forma dinámica
     utilizando tipos antiguos en varias formas combinadas, como funciones
     trigonométricas, series de potencias e integrales. Excepto que la
     conversión puede expandir un polinomio innecesariamente, haciéndolo difícil
     de leer y quizás menos eficiente trabajar con él. La estrategia de la torre
     ciertamente no es natural para este dominio o para cualquier dominio donde
     el usuario pueda inventar nuevos tipos de forma dinámica utilizando tipos
     antiguos en varias formas combinadas, como funciones trigonométricas,
     series de potencias e integrales.

#      It should not be surprising that controlling coercion is a serious problem in
#      the design of large-scale algebraic-manipulation systems. Much of the
#      complexity of such systems is concerned with relationships among diverse
#      types.  Indeed, it is fair to say that we do not yet completely understand
#      coercion.  In fact, we do not yet completely understand the concept of a data
#      type.  Nevertheless, what we know provides us with powerful structuring and
#      modularity principles to support the design of large systems.
     No debería sorprender que el control de la coerción sea un serio problema
     en el diseño de sistemas de manipulación algebraica a gran escala. Gran
     parte de la complejidad de tales sistemas se refiere a las relaciones entre
     los diversos tipos. De hecho, es justo decir que todavía no entendemos
     completamente la coerción. De hecho, todavía no entendemos completamente el
     concepto de tipo de datos. Sin embargo, lo que sabemos nos proporciona
     poderosos principios de estructuración y modularidad para apoyar el diseño
     de grandes sistemas.

#      :: @t(Exercise 2.92) :: By imposing an ordering on variables, extend the
#         polynomial package so that addition and multiplication of polynomials works
#         for polynomials in different variables. (This is not easy!)
     :: @t(Ejercicio 2.92) :: Al imponer un orden sobre variables, extender el
        paquete polinomial para que la adición y multiplicación de polinomios
        funcione para polinomios en diferentes variables. (¡Esto no es facil!)

# **** Extended exercise: Rational functions
**** Ejercicio extendido: Funciones racionales

#      We can extend our generic arithmetic system to include @e(rational functions).
#      These are @"(fractions) whose numerator and denominator are polynomials, such
#      as
     Podemos extender nuestro sistema aritmético genérico para incluir
     @e(funciones racionales). Estas son @"(fracciones) cuyo numerador y
     denominador son polinomios, tales como

#      ..example >
#         x + 1
#        -------
#        x³ − 1
#      < example..
     ..example >
        x + 1
       -------
       x³ − 1
     < example..

#      The system should be able to add, subtract, multiply, and divide rational
#      functions, and to perform such computations as
     El sistema debe ser capaz de sumar, restar, multiplicar y dividir funciones
     racionales, y realizar cálculos tales como

#      ..example >
#         x + 1       x      x³ + 2x² + 3x + 1
#        ------- + ------ = ------------------
#        x³ − 1    x² − 1    x⁴ + x³ − x − 1
#      < example..
     ..example >
        x + 1       x      x³ + 2x² + 3x + 1
       ------- + ------ = ------------------
       x³ − 1    x² − 1    x⁴ + x³ − x − 1
     < example..

#      (Here the sum has been simplified by removing common factors. Ordinary
#      @"(cross multiplication) would have produced a fourth-degree polynomial over a
#      fifth-degree polynomial.)
     (Aquí la suma se ha simplificado eliminando factores comunes: @"(la
     multiplicación cruzada) ordinaria habría producido un polinomio de cuarto
     grado sobre un polinomio de quinto grado).

#      If we modify our rational-arithmetic package so that it uses generic
#      operations, then it will do what we want, except for the problem of reducing
#      fractions to lowest terms.
     Si modificamos nuestro paquete de aritmética racional para que utilice
     operaciones genéricas, entonces hará lo que queremos, excepto el problema
     de reducir las fracciones a los términos más bajos.

#      :: @t(Exercise 2.93) :: Modify the rational-arithmetic package to use generic
#         operations, but change @c(make-rat) so that it does not attempt to reduce
#         fractions to lowest terms. Test your system by calling @c(make-rational) on
#         two polynomials to produce a rational function:
     :: @t(Ejercicio 2.93) :: Modifique el paquete de aritmética racional para
        usar operaciones genéricas, pero cambie @c(make-rat) para que no intente
        reducir las fracciones a los términos más bajos. Pruebe su sistema
        llamando @c(make-rational) a dos polinomios para producir una función
        racional:

#         ..src > scheme
#           (define p1 (make-polynomial 'x '((2 1) (0 1))))
#           (define p2 (make-polynomial 'x '((3 1) (0 1))))
#           (define rf (make-rational p2 p1))
#         < src..
        ..src > scheme
          (define p1 (make-polynomial 'x '((2 1) (0 1))))
          (define p2 (make-polynomial 'x '((3 1) (0 1))))
          (define rf (make-rational p2 p1))
        < src..

#         Now add @c(rf) to itself, using @c(add). You will observe that this
#         addition procedure does not reduce fractions to lowest terms.
        Ahora agregue @c(rf) a sí mismo, usando @c(add). Observará que este
        procedimiento de suma no reduce las fracciones a los términos más bajos.

#      We can reduce polynomial fractions to lowest terms using the same idea we used
#      with integers: modifying @c(make-rat) to divide both the numerator and the
#      denominator by their greatest common divisor. The notion of @"(greatest common
#      divisor) makes sense for polynomials. In fact, we can compute the @A(GCD) of
#      two polynomials using essentially the same Euclid's Algorithm that works for
#      integers.@n(126) The integer version is
     Podemos reducir las fracciones polinomiales a los términos más bajos usando
     la misma idea que usamos con números enteros: modificando @c(make-rat) para
     dividir tanto el numerador como el denominador por su máximo divisor
     común. La noción de @"(mayor divisor común) tiene sentido para los
     polinomios. De hecho, podemos calcular el @A(GCD) de dos polinomios usando
     esencialmente el mismo Algoritmo de Euclides que funciona para
     enteros.@n(126) La versión entera es

#      ..src > scheme
#        (define (gcd a b)
#          (if (= b 0)
#              a
#              (gcd b (remainder a b))))
#      < src..
     ..src > scheme
       (define (gcd a b)
         (if (= b 0)
             a
             (gcd b (remainder a b))))
     < src..

#      Using this, we could make the obvious modification to define a @A(GCD)
#      operation that works on term lists:
     Usando esto, podríamos hacer la modificación obvia para definir una
     operación @A(GCD) que funciona en listas de términos:

#      ..src > scheme
#        (define (gcd-terms a b)
#          (if (empty-termlist? b)
#              a
#              (gcd-terms b (remainder-terms a b))))
#      < src..
     ..src > scheme
       (define (gcd-terms a b)
         (if (empty-termlist? b)
             a
             (gcd-terms b (remainder-terms a b))))
     < src..

#      where @c(remainder-terms) picks out the remainder component of the list
#      returned by the term-list division operation @c(div-terms) that was
#      implemented in @l(#Exercise 2.91).
     Donde @c(remainder-terms) elige el componente restante de la lista devuelta
     por la operación de división de lista de términos @c(div-terms) que se
     implementó en el @l(#Ejercicio 2.91).

#      :: @t(Exercise 2.94) :: Using @c(div-terms), implement the procedure
#         @c(remainder-terms) and use this to define @c(gcd-terms) as above. Now
#         write a procedure @c(gcd-poly) that computes the polynomial @A(GCD) of two
#         polys. (The procedure should signal an error if the two polys are not in
#         the same variable.)  Install in the system a generic operation
#         @c(greatest-common-divisor) that reduces to @c(gcd-poly) for polynomials
#         and to ordinary @c(gcd) for ordinary numbers. As a test, try
     :: @t(Ejercicio 2.94) :: Utilizar @c(div-terms), implementar el
        procedimiento @c(remainder-terms) y utilizarlo para definirlo
        @c(gcd-terms) como se indica más arriba. Ahora escribe un procedimiento
        @c(gcd-poly) que calcula el polinomio @A(GCD) de dos polys. (El
        procedimiento debe indicar un error si los dos polys no están en la
        misma variable.) Instale en el sistema una operación genérica
        @c(greatest-common-divisor) que se reduce a @c(gcd-poly) para polinomios
        ya ordinario @c(gcd) para números ordinarios. Como prueba, prueba

#         ..src > scheme
#           (define p1
#             (make-polynomial
#              'x '((4 1) (3 -1) (2 -2) (1 2))))
#
#           (define p2
#             (make-polynomial
#              'x '((3 1) (1 -1))))
#
#           (greatest-common-divisor p1 p2)
#         < src..
        ..src > scheme
          (define p1
            (make-polynomial
             'x '((4 1) (3 -1) (2 -2) (1 2))))

          (define p2
            (make-polynomial
             'x '((3 1) (1 -1))))

          (greatest-common-divisor p1 p2)
        < src..

#         and check your result by hand.
        Y compruebe su resultado a mano.

#      :: @t(Exercise 2.95) :: Define @m(P₁), @m(P₂), and @m(P₃) to be the
#         polynomials
     :: @t(Ejercicio 2.95) :: Defina @m(P )@m($ )@m(₁ )@m($), @m(P )@m($ )@m(₂
        $) y @m(P )@m($ )@m(₃ )@m($) como los polinomios

#         ..example >
#           P₁: x² − 2x + 1
#
#           P₂: 11x² + 7
#
#           P₃: 13x + 5
#         < example..
        ..example >
          P₁: x² − 2x + 1

          P₂: 11x² + 7

          P₃: 13x + 5
        < example..

#         Now define @m(Q₁) to be the product of @m(P₁) and @m(P₂), and @m(Q₂) to be
#         the product of @m(P₁) and @m(P₃), and use @c(greatest-common-divisor)
#         (@l(#Exercise 2.94)) to compute the @A(GCD) of @m(Q₁) and @m(Q₂).  Note
#         that the answer is not the same as @m(P₁). This example introduces
#         noninteger operations into the computation, causing difficulties with the
#         @A(GCD) algorithm.@n(127) To understand what is happening, try tracing
#         @c(gcd-terms) while computing the @A(GCD) or try performing the division by
#         hand.
        Ahora definir @m(Q $ ₁ $) a ser el producto de @m(P $ ₁ $) y @m(P $ ₂
        $), y @m(Q $ ₂ $) a ser el producto de @m(P $ ₁ $) y @m(P $ ₃ $), y el
        uso @c(greatest-common-divisor) (@l(#Ejercicio 2.94) )
        para calcular el @A(GCD) de @m(Q $ ₁ $) y @m(Q $ ₂ $). Observe que la
        respuesta no es la misma que @m(P₁). Este ejemplo introduce operaciones
        no integradas en el cálculo, causando dificultades con el algoritmo
        @A(GCD).@n(127) Para entender lo que está sucediendo, trate de
        rastreo @c(gcd-terms) mientras que el cálculo de la @A(GCD) o intente
        llevar a cabo la división con la mano.

#      We can solve the problem exhibited in @l(#Exercise 2.95) if we use the
#      following modification of the @A(GCD) algorithm (which really works only in
#      the case of polynomials with integer coefficients). Before performing any
#      polynomial division in the @A(GCD) computation, we multiply the dividend by an
#      integer constant factor, chosen to guarantee that no fractions will arise
#      during the division process. Our answer will thus differ from the actual
#      @A(GCD) by an integer constant factor, but this does not matter in the case of
#      reducing rational functions to lowest terms; the @A(GCD) will be used to
#      divide both the numerator and denominator, so the integer constant factor will
#      cancel out.
     Podemos resolver el problema expuesto en el @l(#Ejercicio
     2.95) si usamos la siguiente modificación del algoritmo @A(GCD) (que
     realmente funciona sólo en el caso de polinomios con coeficientes
     enteros). Antes de realizar cualquier división polinómica en el cálculo
     @A(GCD), multiplicamos el dividendo por un factor constante entero, elegido
     para garantizar que no surgirán fracciones durante el proceso de
     división. Nuestra respuesta, por lo tanto, difiere de la @A(GCD) real por
     un factor constante entero, pero esto no importa en el caso de reducir las
     funciones racionales a los términos más bajos; El @A(GCD) se utilizará para
     dividir el numerador y el denominador, de modo que el factor constante
     entero se cancelará.

#      More precisely, if @m(P) and @m(Q) are polynomials, let @m(O₁) be the order of
#      @m(P) (i.e., the order of the largest term of @m(P)) and let @m(O₂) be the
#      order of @m(Q). Let @m(c) be the leading coefficient of @m(Q). Then it can be
#      shown that, if we multiply @m(P) by the @e(integerizing factor) @M[c^{1 + O₁ -
#      O₂}], the resulting polynomial can be divided by @m(Q) by using the
#      @c(div-terms) algorithm without introducing any fractions. The operation of
#      multiplying the dividend by this constant and then dividing is sometimes
#      called the @e(pseudodivision) of @m(P) by @m(Q). The remainder of the division
#      is called the @e(pseudoremainder).
     Más precisamente, si @m(P) y @m(Q) son polinomios, permiten @m(O₁) ser el
     orden de @m(P) (es decir, el orden de la más grande plazo de @m(P) ) y
     dejar que @m(O $ ₂ $) sea del orden de @m(Q). Dejar que @m(c) es el
     coeficiente principal de @m(Q). Entonces se puede demostrar que, si
     multiplicamos @m(P) por el @e(factor integerizante) \ (c ^ {1 + O₁ - O₂}
     \), el polinomio resultante puede ser dividido por @m(Q) usando el
     @c(div-terms) algoritmo sin introducir fracciones. @e(La operación de
     multiplicar el dividendo por esta constante y luego dividiendo a veces se
     llama la pseudodivision) de @m(P) por @m(Q). El resto de la división se
     llama el @e(pseudorimínder).

#      :: @t(Exercise 2.96) ::
     :: @t(Ejercicio 2.96) ::

#         1. Implement the procedure @c(pseudoremainder-terms), which is just like
#            @c(remainder-terms) except that it multiplies the dividend by the
#            integerizing factor described above before calling @c(div-terms). Modify
#            @c(gcd-terms) to use @c(pseudoremainder-terms), and verify that
#            @c(greatest-common-divisor) now produces an answer with integer
#            coefficients on the example in @l(#Exercise 2.95).
        1. Implemente el procedimiento @c(pseudoremainder-terms), que es como
           @c(remainder-terms) si fuera que multiplica el dividendo por el
           factor de integración antes descrito antes de llamar
           @c(div-terms). Modifique @c(gcd-terms) para usar
           @c(pseudoremainder-terms) y verifique que @c(greatest-common-divisor)
           ahora produce una respuesta con coeficientes enteros en el ejemplo
           del @l(#Ejercicio 2.95).

#         2. The @A(GCD) now has integer coefficients, but they are larger than those
#            of @m(P₁). Modify @c(gcd-terms) so that it removes common factors from
#            the coefficients of the answer by dividing all the coefficients by their
#            (integer) greatest common divisor.
        2. El @A(GCD) tiene ahora coeficientes enteros, pero son mayores que los
           de @m(P $ ₁ $). Modifique @c(gcd-terms) para que elimine factores
           comunes de los coeficientes de la respuesta dividiendo todos los
           coeficientes por su divisor común (entero).


#      Thus, here is how to reduce a rational function to lowest terms:
     Así, aquí es cómo reducir una función racional a los términos más bajos:

#      - Compute the @A(GCD) of the numerator and denominator, using the version of
#        @c(gcd-terms) from @l(#Exercise 2.96).
     - Calcular el @A(MCD) del numerador y el denominador, utilizando la versión
       de @c(gcd-terms) de @l(#Ejercicio 2.96).

#      - When you obtain the @A(GCD), multiply both numerator and denominator by the
#        same integerizing factor before dividing through by the @A(GCD), so that
#        division by the @A(GCD) will not introduce any noninteger coefficients. As
#        the factor you can use the leading coefficient of the @A(GCD) raised to the
#        power @m(1 + O₁ - O₂), where @m(O₂) is the order of the @A(GCD) and @m(O₁)
#        is the maximum of the orders of the numerator and denominator. This will
#        ensure that dividing the numerator and denominator by the @A(GCD) will not
#        introduce any fractions.
     - Cuando obtenga el @A(GCD), multiplique el numerador y el denominador por
       el mismo factor de integerización antes de dividir por el @A(GCD), de
       modo que la división por el @A(GCD) no introducirá ningún coeficiente de
       no integer. Como factor se puede utilizar el coeficiente de @A(avance)
       del @A(GCD) elevado a la potencia @m(1 + O₁-O₂), donde @m(O₂) es el orden
       del @A(GCD) y @m(O₁) es el máximo de los órdenes del numerador y
       denominador. Esto asegurará que dividir el numerador y el denominador por
       el @A(GCD) no introducirá ninguna fracción.

#      - The result of this operation will be a numerator and denominator with
#        integer coefficients. The coefficients will normally be very large because
#        of all of the integerizing factors, so the last step is to remove the
#        redundant factors by computing the (integer) greatest common divisor of all
#        the coefficients of the numerator and the denominator and dividing through
#        by this factor.
     - El resultado de esta operación será un numerador y denominador con
       coeficientes enteros. Los coeficientes serán normalmente muy grandes
       debido a todos los factores integerizantes, de modo que el último paso es
       eliminar los factores redundantes calculando el divisor común más grande
       (entero) de todos los coeficientes del numerador y del denominador y
       dividiéndolo por este factor.

#      :: @t(Exercise 2.97) ::
     :: @t(Ejercicio 2.97) ::

#         1. Implement this algorithm as a procedure @c(reduce-terms) that takes two
#            term lists @c(n) and @c(d) as arguments and returns a list @c(nn),
#            @c(dd), which are @c(n) and @c(d) reduced to lowest terms via the
#            algorithm given above. Also write a procedure @c(reduce-poly), analogous
#            to @c(add-poly), that checks to see if the two polys have the same
#            variable.  If so, @c(reduce-poly) strips off the variable and passes the
#            problem to @c(reduce-terms), then reattaches the variable to the two
#            term lists supplied by @c(reduce-terms).
        1. Implementar este algoritmo como un procedimiento @c(reduce-terms) que
           toma dos listas de términos @c(n) y @c(d) como argumentos y devuelve
           una lista @c(nn), @c(dd) que son @c(n) y @c(d) reduce a términos más
           bajos a través de la algoritmo dado anteriormente. También escribe un
           procedimiento @c(reduce-poly), análogo a @c(add-poly), que comprueba
           si los dos polys tienen la misma variable. Si es así, @c(reduce-poly)
           quita la variable y pasa el problema a @c(reduce-terms), a
           continuación, vuelve a conectar la variable a las listas de dos
           términos proporcionados por @c(reduce-terms).

#         2. Define a procedure analogous to @c(reduce-terms) that does what the
#            original @c(make-rat) did for integers:
        2. Definir un procedimiento análogo al @c(reduce-terms) que hace lo que
           hizo el original @c(make-rat) para enteros:

#            ..src > scheme
#              (define (reduce-integers n d)
#                (let ((g (gcd n d)))
#                  (list (/ n g) (/ d g))))
#            < src..
           ..src > scheme
             (define (reduce-integers n d)
               (let ((g (gcd n d)))
                 (list (/ n g) (/ d g))))
           < src..

#            and define @c(reduce) as a generic operation that calls
#            @c(apply-generic) to dispatch to either @c(reduce-poly) (for
#            @c(polynomial) arguments) or @c(reduce-integers) (for @c(scheme-number)
#            arguments). You can now easily make the rational-arithmetic package
#            reduce fractions to lowest terms by having @c(make-rat) call @c(reduce)
#            before combining the given numerator and denominator to form a rational
#            number. The system now handles rational expressions in either integers
#            or polynomials. To test your program, try the example at the beginning
#            of this extended exercise:
           Y definir @c(reduce) como una operación genérica que llama
           @c(apply-generic) a enviar a cualquiera @c(reduce-poly)(para los
           @c(polynomial) argumentos) o @c(reduce-integers)(para los
           @c(scheme-number) argumentos). Ahora puede hacer fácilmente que el
           paquete de aritmética racional reduzca las fracciones a los términos
           más bajos al tener @c(make-rat) llamada @c(reduce) antes de combinar
           el numerador y el denominador para formar un número racional. El
           sistema ahora maneja expresiones racionales en enteros o
           polinomios. Para probar su programa, pruebe el ejemplo al principio
           de este ejercicio extendido:

#            ..src > scheme
#              (define p1
#                (make-polynomial 'x '((1 1) (0 1))))
#              (define p2
#                (make-polynomial 'x '((3 1) (0 -1))))
#              (define p3
#                (make-polynomial 'x '((1 1))))
#              (define p4
#                (make-polynomial 'x '((2 1) (0 -1))))
#              (define rf1 (make-rational p1 p2))
#              (define rf2 (make-rational p3 p4))
#              (add rf1 rf2)
#            < src..
           ..src > scheme
             (define p1
               (make-polynomial 'x '((1 1) (0 1))))
             (define p2
               (make-polynomial 'x '((3 1) (0 -1))))
             (define p3
               (make-polynomial 'x '((1 1))))
             (define p4
               (make-polynomial 'x '((2 1) (0 -1))))
             (define rf1 (make-rational p1 p2))
             (define rf2 (make-rational p3 p4))
             (add rf1 rf2)
           < src..

#            See if you get the correct answer, correctly reduced to lowest terms.
           Vea si obtiene la respuesta correcta, correctamente reducida a los
           términos más bajos.


#      The @A(GCD) computation is at the heart of any system that does operations on
#      rational functions. The algorithm used above, although mathematically
#      straightforward, is extremely slow. The slowness is due partly to the large
#      number of division operations and partly to the enormous size of the
#      intermediate coefficients generated by the pseudodivisions. One of the active
#      areas in the development of algebraic-manipulation systems is the design of
#      better algorithms for computing polynomial @A(GCD)s.@n(128)
     La computación @A(GCD) está en el corazón de cualquier sistema que hace
     operaciones en funciones racionales. El algoritmo utilizado anteriormente,
     aunque matemáticamente directo, es extremadamente lento. La lentitud se
     debe en parte al gran número de operaciones de división y en parte al
     enorme tamaño de los coeficientes intermedios generados por las
     seudodivisiones. Una de las áreas activas en el desarrollo de sistemas de
     manipulación algebraica es el diseño de mejores algoritmos para el cálculo
     de polinomios @A(GCD) s.@n(128)

# * Chapter 3 <> Modularity, Objects, and State
* Capitulo 3 <> Modularidad, Objetos y Estado

#   ..quote >
  ..quote >
#     Mεταβάλλον ὰναπαύεται
#     (Even while it changes, it stands still.)
    Mεταβάλλον ὰναπαύεται (Incluso mientras cambia, se queda quieto.)

#     --Heraclitus
    --Heráclito

#     Plus ça change, plus c'est la même chose.
    Plus ça change, plus c'est la même eligió.

#     --Alphonse Karr
    --Alphonse Karr
#   < quote..
  < quote..

#   The preceding chapters introduced the basic elements from which programs are
#   made. We saw how primitive procedures and primitive data are combined to
#   construct compound entities, and we learned that abstraction is vital in
#   helping us to cope with the complexity of large systems. But these tools are
#   not sufficient for designing programs. Effective program synthesis also
#   requires organizational principles that can guide us in formulating the
#   overall design of a program. In particular, we need strategies to help us
#   structure large systems so that they will be @e(modular), that is, so that
#   they can be divided @"(naturally) into coherent parts that can be separately
#   developed and maintained.
  En los capítulos precedentes se presentaron los elementos básicos de los
  programas. Vimos cómo los procedimientos primitivos y los datos primitivos se
  combinan para construir entidades compuestas, y aprendimos que la abstracción
  es vital para ayudarnos a lidiar con la complejidad de los grandes
  sistemas. Pero estas herramientas no son suficientes para diseñar
  programas. La síntesis efectiva del programa también requiere principios
  organizativos que nos puedan guiar en la formulación del diseño general de un
  programa. En particular, necesitamos estrategias que nos ayuden a estructurar
  grandes sistemas de modo que sean @e(modulares), es decir, que puedan ser
  divididos @"(naturalmente) en partes coherentes que se pueden desarrollar y
  mantener por separado.

#   One powerful design strategy, which is particularly appropriate to the
#   construction of programs for modeling physical systems, is to base the
#   structure of our programs on the structure of the system being modeled. For
#   each object in the system, we construct a corresponding computational object.
#   For each system action, we define a symbolic operation in our computational
#   model. Our hope in using this strategy is that extending the model to
#   accommodate new objects or new actions will require no strategic changes to
#   the program, only the addition of the new symbolic analogs of those objects or
#   actions. If we have been successful in our system organization, then to add a
#   new feature or debug an old one we will have to work on only a localized part
#   of the system.
  Una potente estrategia de diseño, que es particularmente apropiada para la
  construcción de programas de modelado de sistemas físicos, es basar la
  estructura de nuestros programas en la estructura del sistema que está siendo
  modelado. Para cada objeto en el sistema, construimos un objeto computacional
  correspondiente. Para cada acción del sistema, definimos una operación
  simbólica en nuestro modelo computacional. Nuestra esperanza en el uso de esta
  estrategia es que extender el modelo para acomodar nuevos objetos o nuevas
  acciones no requerirá cambios estratégicos en el programa, sino la adición de
  los nuevos análogos simbólicos de esos objetos o acciones. Si hemos tenido
  éxito en nuestra organización del sistema, a continuación, para agregar una
  nueva característica o depurar una antigua, tendremos que trabajar en sólo una
  parte localizada del sistema.

#   To a large extent, then, the way we organize a large program is dictated by
#   our perception of the system to be modeled. In this chapter we will
#   investigate two prominent organizational strategies arising from two rather
#   different @"(world views) of the structure of systems. The first
#   organizational strategy concentrates on @e(objects), viewing a large system as
#   a collection of distinct objects whose behaviors may change over time. An
#   alternative organizational strategy concentrates on the @e(streams) of
#   information that flow in the system, much as an electrical engineer views a
#   signal-processing system.
  En gran medida, entonces, la manera en que organizamos un programa grande es
  dictada por nuestra percepción del sistema a ser modelado. En este capítulo
  vamos a investigar dos prominentes estrategias organizacionales que surgen de
  dos @"(concepciones) de @"(mundo) bastante diferentes de la estructura de los
  sistemas. La primera estrategia organizacional se concentra en @e(objetos),
  viendo un sistema grande como una colección de objetos distintos cuyos
  comportamientos pueden cambiar con el tiempo. Una estrategia organizativa
  alternativa se concentra en los @e(flujos) de información que fluyen en el
  sistema, de la misma manera que un ingeniero eléctrico ve un sistema de
  procesamiento de señales.

#   Both the object-based approach and the stream-processing approach raise
#   significant linguistic issues in programming. With objects, we must be
#   concerned with how a computational object can change and yet maintain its
#   identity. This will force us to abandon our old substitution model of
#   computation (section @l(#1.1.5)) in favor of a more mechanistic but less theoretically
#   tractable @e(environment model) of computation. The difficulties of dealing
#   with objects, change, and identity are a fundamental consequence of the need
#   to grapple with time in our computational models.  These difficulties become
#   even greater when we allow the possibility of concurrent execution of
#   programs. The stream approach can be most fully exploited when we decouple
#   simulated time in our model from the order of the events that take place in
#   the computer during evaluation. We will accomplish this using a technique
#   known as @e(delayed evaluation).
  Tanto el enfoque basado en objetos como el enfoque de procesamiento de flujos
  plantean importantes problemas lingüísticos en la programación. Con los
  objetos, debemos preocuparnos de cómo un objeto computacional puede cambiar y
  mantener su identidad. Esto nos obligará a abandonar nuestro antiguo modelo de
  sustitución de cálculo (seccion @l(#1.1.5)) a favor de un @e(modelo) de
  cálculo más mecanicista pero menos teóricamente manejable. Las dificultades de
  lidiar con los objetos, el cambio y la identidad son una consecuencia
  fundamental de la necesidad de lidiar con el tiempo en nuestros modelos
  computacionales. Estas dificultades se hacen aún mayores cuando se permite la
  posibilidad de ejecución concurrente de programas. El enfoque de la corriente
  se puede aprovechar al máximo cuando desacoplamos el tiempo simulado en
  nuestro modelo a partir del orden de los eventos que tienen lugar en la
  computadora durante la evaluación. @e(Lo lograremos usando una técnica
  conocida como evaluación retardada).

# ** 3.1 <> Assignment and Local State
** 3.1 <> Asignación y Estado Local

#    We ordinarily view the world as populated by independent objects, each of
#    which has a state that changes over time. An object is said to @"(have state)
#    if its behavior is influenced by its history. A bank account, for example, has
#    state in that the answer to the question @"(Can I withdraw $100?)  depends
#    upon the history of deposit and withdrawal transactions. We can characterize
#    an object's state by one or more @e(state variables), which among them
#    maintain enough information about history to determine the object's current
#    behavior. In a simple banking system, we could characterize the state of an
#    account by a current balance rather than by remembering the entire history of
#    account transactions.
   Normalmente vemos el mundo como poblado por objetos independientes, cada uno
   de los cuales tiene un estado que cambia con el tiempo. Se dice que un objeto
   @"(tiene estado) si su comportamiento está influenciado por su historia. Una
   cuenta bancaria, por ejemplo, tiene estado en que la respuesta a la pregunta
   @"(¿Puedo retirar $ 100? )  Depende de la historia de las transacciones de
   depósito y retiro. Podemos caracterizar el estado de un objeto por una o más
   @e(variables de estado), que entre ellas mantienen suficiente información
   sobre la historia para determinar el comportamiento actual del objeto. En un
   sistema bancario simple, podríamos caracterizar el estado de una cuenta por
   un saldo actual en lugar de recordar todo el historial de transacciones de
   cuentas.

#    In a system composed of many objects, the objects are rarely completely
#    independent. Each may influence the states of others through interactions,
#    which serve to couple the state variables of one object to those of other
#    objects. Indeed, the view that a system is composed of separate objects is
#    most useful when the state variables of the system can be grouped into closely
#    coupled subsystems that are only loosely coupled to other subsystems.
   En un sistema compuesto de muchos objetos, los objetos raramente son
   completamente independientes. Cada uno puede influir en los estados de otros
   a través de interacciones, que sirven para acoplar las variables de estado de
   un objeto a las de otros objetos. De hecho, la visión de que un sistema está
   compuesto de objetos separados es más útil cuando las variables de estado del
   sistema pueden agruparse en subsistemas estrechamente acoplados que sólo
   están ligeramente acoplados a otros subsistemas.

#    This view of a system can be a powerful framework for organizing computational
#    models of the system. For such a model to be modular, it should be decomposed
#    into computational objects that model the actual objects in the system. Each
#    computational object must have its own @e(local state variables) describing
#    the actual object's state. Since the states of objects in the system being
#    modeled change over time, the state variables of the corresponding
#    computational objects must also change. If we choose to model the flow of time
#    in the system by the elapsed time in the computer, then we must have a way to
#    construct computational objects whose behaviors change as our programs run. In
#    particular, if we wish to model state variables by ordinary symbolic names in
#    the programming language, then the language must provide an @e(assignment
#    operator) to enable us to change the value associated with a name.
   Esta visión de un sistema puede ser un marco poderoso para organizar modelos
   computacionales del sistema. Para que dicho modelo sea modular, debe ser
   descompuesto en objetos computacionales que modelen los objetos reales en el
   sistema. Cada objeto computacional debe tener sus propias @e(variables de
   estado locales que) describen el estado del objeto real. Puesto que los
   estados de objetos en el sistema que se está modelando cambian con el tiempo,
   las variables de estado de los objetos computacionales correspondientes
   también deben cambiar. Si elegimos modelar el flujo de tiempo en el sistema
   por el tiempo transcurrido en la computadora, entonces debemos tener una
   manera de construir objetos computacionales cuyos comportamientos cambian a
   medida que nuestros programas se ejecutan. En particular, si deseamos modelar
   variables de estado mediante nombres simbólicos ordinarios en el lenguaje de
   programación,@e()

# *** 3.1.1 <> Local State Variables
*** 3.1.1 <> Variables estatales locales

#     To illustrate what we mean by having a computational object with time-varying
#     state, let us model the situation of withdrawing money from a bank account. We
#     will do this using a procedure @c(withdraw), which takes as argument an
#     @c(amount) to be withdrawn. If there is enough money in the account to
#     accommodate the withdrawal, then @c(withdraw) should return the balance
#     remaining after the withdrawal. Otherwise, @c(withdraw) should return the
#     message @e(Insufficient funds). For example, if we begin with $100 in the
#     account, we should obtain the following sequence of responses using
#     @c(withdraw):
    Para ilustrar lo que entendemos por tener un objeto computacional con un
    estado variable en el tiempo, modelemos la situación de retirar dinero de
    una cuenta bancaria. Lo haremos usando un procedimiento @c(withdraw), que
    toma como argumento un @c(amount) ser retirado. Si hay suficiente dinero en
    la cuenta para acomodar la retirada, entonces @c(withdraw) debe devolver el
    saldo restante después de la retirada. De lo contrario, @c(withdraw) debe
    devolver el mensaje @e(Fondos insuficientes). Por ejemplo, si comenzamos con
    $ 100 en la cuenta, debemos obtener la siguiente secuencia de respuestas
    usando @c(withdraw):

#     ..srci > scheme
#       > (withdraw 25)
#       75
#       > (withdraw 25)
#       50
#       > (withdraw 60)
#       "Insufficient funds"
#       > (withdraw 15)
#       35
#     < srci..
    ..srci > scheme
      > (withdraw 25)
      75
      > (withdraw 25)
      50
      > (withdraw 60)
      "Insufficient funds"
      > (withdraw 15)
      35
    < srci..

#     Observe that the expression @c[(withdraw 25)], evaluated twice, yields
#     different values. This is a new kind of behavior for a procedure. Until now,
#     all our procedures could be viewed as specifications for computing
#     mathematical functions. A call to a procedure computed the value of the
#     function applied to the given arguments, and two calls to the same procedure
#     with the same arguments always produced the same result.@n(129)
    Observe que la expresión @c[(withdraw 25)], evaluada dos veces, produce
    diferentes valores. Este es un nuevo tipo de comportamiento para un
    procedimiento. Hasta ahora, todos nuestros procedimientos podían ser vistos
    como especificaciones para el cálculo de funciones matemáticas. Una llamada
    a un procedimiento calculó el valor de la función aplicada a los argumentos
    dados, y dos llamadas al mismo procedimiento con los mismos argumentos
    siempre produjeron el mismo resultado.@n(129)

#     To implement @c(withdraw), we can use a variable @c(balance) to indicate the
#     balance of money in the account and define @c(withdraw) as a procedure that
#     accesses @c(balance). The @c(withdraw) procedure checks to see if @c(balance)
#     is at least as large as the requested @c(amount). If so, @c(withdraw)
#     decrements @c(balance) by @c(amount) and returns the new value of
#     @c(balance). Otherwise, @c(withdraw) returns the @e(Insufficient funds)
#     message. Here are the definitions of @c(balance) and @c(withdraw):
    Para implementar @c(withdraw), podemos utilizar una variable @c(balance)
    para indicar el saldo de dinero en la cuenta y definir @c(withdraw) como un
    procedimiento que accede @c(balance). El procedimiento @c(withdraw)
    comprueba si @c(balance) es al menos tan grande como el solicitado
    @c(amount). Si es así, @c(withdraw) decrementos @c(balance) por @c(amount) y
    devuelve el nuevo valor de @c(balance). De lo contrario, @c(withdraw)
    devuelve el mensaje de @e(fondos insuficientes). Aquí están las definiciones
    de @c(balance) y @c(withdraw):

#     ..src > scheme
#       (define balance 100)
#
#       (define (withdraw amount)
#         (if (>= balance amount)
#             (begin (set! balance (- balance amount))
#                    balance)
#             "Insufficient funds"))
#     < src..
    ..src > scheme
      (define balance 100)

      (define (withdraw amount)
        (if (>= balance amount)
            (begin (set! balance (- balance amount))
                   balance)
            "Insufficient funds"))
    < src..

#     Decrementing @c(balance) is accomplished by the expression
    El decremento @c(balance) se logra mediante la expresión

#     ..src > scheme
#       (set! balance (- balance amount))
#     < src..
    ..src > scheme
      (set! balance (- balance amount))
    < src..

#     This uses the @c(set!) special form, whose syntax is
    Esto utiliza el @c(set!) formulario especial, cuya sintaxis es

#     ..src > scheme
#       (set! ⟨name⟩ ⟨new-value⟩)
#     < src..
    ..src > scheme
      (set! ⟨name⟩ ⟨new-value⟩)
    < src..

#     Here @c[(name)] is a symbol and @c[(new-value)] is any expression.  @c(Set!)
#     changes @c[(name)] so that its value is the result obtained by evaluating
#     @c[(new-value)]. In the case at hand, we are changing @c(balance) so that its
#     new value will be the result of subtracting @c(amount) from the previous value
#     of @c(balance).@n(130)
    Aquí @c[(name)] hay un símbolo y @c[(new-value)] es cualquier expresión.
    @c(Set!) Cambia @c[(name)] para que su valor sea el resultado obtenido
    evaluando @c[(new-value)]. En el caso que nos ocupa, estamos cambiando
    @c(balance) para que su nuevo valor sea el resultado de sustraer @c(amount)
    del valor anterior de @c(balance).@n(130)

#     @c(Withdraw) also uses the @c(begin) special form to cause two expressions to
#     be evaluated in the case where the @c(if) test is true: first decrementing
#     @c(balance) and then returning the value of @c(balance). In general,
#     evaluating the expression
    @c(Withdraw) También utiliza la @c(begin) forma especial para hacer que dos
    expresiones sean evaluadas en el caso donde la @c(if) prueba es verdadera:
    primero decrementando @c(balance) y luego devolviendo el valor de
    @c(balance). En general, evaluar la expresión

#     ..src > scheme
#       (begin ⟨exp₁⟩ ⟨exp₂⟩ … ⟨expₖ⟩)
#     < src..
    ..src > scheme
      (begin ⟨exp₁⟩ ⟨exp₂⟩ … ⟨expₖ⟩)
    < src..

#     causes the expressions @m[⟨exp₁⟩] through @m[⟨expₙ⟩] to be evaluated in
#     sequence and the value of the final expression @m[⟨expₙ⟩] to be returned as
#     the value of the entire @c(begin) form.@n(131)
    Hace que las expresiones @m(⟨exp₁⟩) a @m(⟨expₙ⟩) sean evaluadas en secuencia
    y el valor de la expresión final @m(⟨expₙ⟩) sea devuelto como el valor de
    todo el @c(begin) formulario.@n(131)

#     Although @c(withdraw) works as desired, the variable @c(balance) presents a
#     problem. As specified above, @c(balance) is a name defined in the global
#     environment and is freely accessible to be examined or modified by any
#     procedure. It would be much better if we could somehow make @c(balance)
#     internal to @c(withdraw), so that @c(withdraw) would be the only procedure
#     that could access @c(balance) directly and any other procedure could access
#     @c(balance) only indirectly (through calls to @c(withdraw)).  This would more
#     accurately model the notion that @c(balance) is a local state variable used by
#     @c(withdraw) to keep track of the state of the account.
    Aunque @c(withdraw) funciona como se desee, la variable @c(balance) presenta
    un problema. Como se ha especificado anteriormente, @c(balance) es un nombre
    definido en el entorno global y de libre acceso para ser examinado o
    modificado por cualquier procedimiento. Sería mucho mejor si pudiéramos
    hacer de alguna manera @c(balance) interno @c(withdraw), por lo que
    @c(withdraw) sería el único procedimiento que podría acceder @c(balance)
    directamente y cualquier otro procedimiento podría acceder @c(balance) sólo
    indirectamente (a través de llamadas a @c(withdraw)). Esto modelaría con
    mayor precisión la noción de que @c(balance) es una variable de estado local
    utilizada por @c(withdraw) para realizar un seguimiento del estado de la
    cuenta.

#     We can make @c(balance) internal to @c(withdraw) by rewriting the definition
#     as follows:
    Podemos hacerlo @c(balance) interno @c(withdraw) reescribiendo la definición
    como sigue:

#     ..src > scheme
#       (define new-withdraw
#         (let ((balance 100))
#           (lambda (amount)
#             (if (>= balance amount)
#                 (begin (set! balance
#                              (- balance amount))
#                        balance)
#                 "Insufficient funds"))))
#     < src..
    ..src > scheme
      (define new-withdraw
        (let ((balance 100))
          (lambda (amount)
            (if (>= balance amount)
                (begin (set! balance
                             (- balance amount))
                       balance)
                "Insufficient funds"))))
    < src..

#     What we have done here is use @c(let) to establish an environment with a local
#     variable @c(balance), bound to the initial value 100. Within this local
#     environment, we use @c(lambda) to create a procedure that takes @c(amount) as
#     an argument and behaves like our previous @c(withdraw) procedure. This
#     procedure––returned as the result of evaluating the @c(let) expression––is
#     @c(new-withdraw), which behaves in precisely the same way as @c(withdraw) but
#     whose variable @c(balance) is not accessible by any other procedure.@n(132)
    Lo que hemos hecho aquí es usar @c(let) para establecer un entorno con una
    variable local @c(balance), unido al valor inicial 100. En este entorno
    local, usamos @c(lambda) para crear un procedimiento que toma @c(amount)
    como argumento y se comporta como nuestro procedimiento @c(withdraw)
    anterior. Este procedimiento - devuelto como resultado de la evaluación de
    la expresión @c(let) - es @c(new-withdraw), que se comporta exactamente de
    la misma manera que @c(withdraw) pero cuya variable @c(balance) no es
    accesible por ningún otro procedimiento.@n(132)

#     Combining @c(set!) with local variables is the general programming technique
#     we will use for constructing computational objects with local state.
#     Unfortunately, using this technique raises a serious problem: When we first
#     introduced procedures, we also introduced the substitution model of evaluation
#     (section @l(#1.1.5)) to provide an interpretation of what procedure application
#     means. We said that applying a procedure should be interpreted as evaluating
#     the body of the procedure with the formal parameters replaced by their
#     values. The trouble is that, as soon as we introduce assignment into our
#     language, substitution is no longer an adequate model of procedure
#     application.  (We will see why this is so in section @l(#3.1.3).)  As a consequence,
#     we technically have at this point no way to understand why the
#     @c(new-withdraw) procedure behaves as claimed above. In order to really
#     understand a procedure such as @c(new-withdraw), we will need to develop a new
#     model of procedure application. in section @l(#3.2) we will introduce such a model,
#     together with an explanation of @c(set!) and local variables. First, however,
#     we examine some variations on the theme established by @c(new-withdraw).
    La combinación @c(set!) con variables locales es la técnica de programación
    general que utilizaremos para construir objetos computacionales con estado
    local. Desafortunadamente, el uso de esta técnica plantea un serio problema:
    cuando introdujimos procedimientos, también introdujimos el modelo de
    sustitución de evaluación (seccion @l(#1.1.5)) para proporcionar una
    interpretación de lo que significa aplicación de procedimiento. Dijimos que
    la aplicación de un procedimiento debe interpretarse como una evaluación del
    cuerpo del procedimiento con los parámetros formales reemplazados por sus
    valores. El problema es que, tan pronto como introducimos la asignación en
    nuestro lenguaje, la sustitución ya no es un modelo adecuado de aplicación
    de procedimiento. (Veremos por qué esto es así en la seccion @l(#3.1.3) .) Como
    consecuencia, @c(new-withdraw) Técnicamente no tenemos en este momento
    ninguna manera de entender por qué el procedimiento se comporta como se dijo
    anteriormente. Con el fin de entender realmente un procedimiento como
    @c(new-withdraw), tendremos que desarrollar un nuevo modelo de aplicación de
    procedimiento. en la seccion @l(#3.2) introduciremos este modelo, junto con una
    explicación de @c(set!) las variables locales. En primer lugar, sin embargo,
    examinamos algunas variaciones sobre el tema establecido por
    @c(new-withdraw).

#     The following procedure, @c(make-withdraw), creates @"(withdrawal processors.)
#     The formal parameter @c(balance) in @c(make-withdraw) specifies the initial
#     amount of money in the account.@n(133)
    El siguiente procedimiento @c(make-withdraw), crea @"(procesadores de
    retiro. ) El parámetro formal @c(balance) en @c(make-withdraw) especifica la
    cantidad inicial de dinero en la cuenta.@n(133)

#     ..src > scheme
#       (define (make-withdraw balance)
#         (lambda (amount)
#           (if (>= balance amount)
#               (begin (set! balance
#                            (- balance amount))
#                      balance)
#               "Insufficient funds")))
#     < src..
    ..src > scheme
      (define (make-withdraw balance)
        (lambda (amount)
          (if (>= balance amount)
              (begin (set! balance
                           (- balance amount))
                     balance)
              "Insufficient funds")))
    < src..

#     @c(Make-withdraw) can be used as follows to create two objects @c(W1) and
#     @c(W2):
    @c(Make-withdraw) Se puede utilizar de la siguiente manera para crear dos
    objetos @c(W1) y @c(W2):

#     ..srci > scheme
#       > (define W1 (make-withdraw 100))
#       > (define W2 (make-withdraw 100))
#       > (W1 50)
#       50
#       > (W2 70)
#       30
#       > (W2 40)
#       "Insufficient funds"
#       > (W1 40)
#       10
#     < srci..
    ..srci > scheme
      > (define W1 (make-withdraw 100))
      > (define W2 (make-withdraw 100))
      > (W1 50)
      50
      > (W2 70)
      30
      > (W2 40)
      "Insufficient funds"
      > (W1 40)
      10
    < srci..

#     Observe that @c(W1) and @c(W2) are completely independent objects, each with
#     its own local state variable @c(balance). Withdrawals from one do not affect
#     the other.
    Observe eso @c(W1) y @c(W2) son objetos completamente independientes, cada
    uno con su propia variable de estado local @c(balance). Los retiros de uno
    no afectan al otro.

#     We can also create objects that handle deposits as well as withdrawals, and
#     thus we can represent simple bank accounts. Here is a procedure that returns a
#     @"(bank-account object) with a specified initial balance:
    También podemos crear objetos que manejen depósitos y retiros, por lo que
    podemos representar cuentas bancarias simples. Este es un procedimiento que
    devuelve un @"(objeto de cuenta bancaria) con un saldo inicial especificado:

#     ..src > scheme
#       (define (make-account balance)
#         (define (withdraw amount)
#           (if (>= balance amount)
#               (begin (set! balance
#                            (- balance amount))
#                      balance)
#               "Insufficient funds"))
#         (define (deposit amount)
#           (set! balance (+ balance amount))
#           balance)
#         (define (dispatch m)
#           (cond ((eq? m 'withdraw) withdraw)
#                 ((eq? m 'deposit) deposit)
#                 (else (error "Unknown request:
#                        MAKE-ACCOUNT" m))))
#         dispatch)
#     < src..
    ..src > scheme
      (define (make-account balance)
        (define (withdraw amount)
          (if (>= balance amount)
              (begin (set! balance
                           (- balance amount))
                     balance)
              "Insufficient funds"))
        (define (deposit amount)
          (set! balance (+ balance amount))
          balance)
        (define (dispatch m)
          (cond ((eq? m 'withdraw) withdraw)
                ((eq? m 'deposit) deposit)
                (else (error "Unknown request:
                       MAKE-ACCOUNT" m))))
        dispatch)
    < src..

#     Each call to @c(make-account) sets up an environment with a local state
#     variable @c(balance). Within this environment, @c(make-account) defines
#     procedures @c(deposit) and @c(withdraw) that access @c(balance) and an
#     additional procedure @c(dispatch) that takes a @"(message) as input and
#     returns one of the two local procedures. The @c(dispatch) procedure itself is
#     returned as the value that represents the bank-account object. This is
#     precisely the @e(message-passing) style of programming that we saw in
#     @l(#2.4.3), although here we are using it in conjunction with the ability to
#     modify local variables.
    Cada llamada @c(make-account) establece un entorno con una variable de
    estado local @c(balance). Dentro de este entorno, @c(make-account) define
    los procedimientos @c(deposit) y @c(withdraw) ese acceso @c(balance) y un
    procedimiento adicional @c(dispatch) que toma un @"(mensaje) como entrada y
    devuelve uno de los dos procedimientos locales. El procedimiento @c(dispatch) en sí se devuelve como el valor que representa el objeto de
    cuenta bancaria. Este es precisamente el estilo de programación de
    @e(mensajes) que vimos en la seccion @l(#2.4.3), aunque aquí lo estamos
    utilizando junto con la capacidad de modificar variables locales.

#     @c(Make-account) can be used as follows:
    @c(Make-account) Puede usarse de la siguiente manera:

#     ..srci > scheme
#       > (define acc (make-account 100))
#       > ((acc 'withdraw) 50)
#       50
#       > ((acc 'withdraw) 60)
#       "Insufficient funds"
#       > ((acc 'deposit) 40)
#       90
#       > ((acc 'withdraw) 60)
#       30
#     < srci..
    ..srci > scheme
      > (define acc (make-account 100))
      > ((acc 'withdraw) 50)
      50
      > ((acc 'withdraw) 60)
      "Insufficient funds"
      > ((acc 'deposit) 40)
      90
      > ((acc 'withdraw) 60)
      30
    < srci..

#     Each call to @c(acc) returns the locally defined @c(deposit) or @c(withdraw)
#     procedure, which is then applied to the specified @c(amount). As was the case
#     with @c(make-withdraw), another call to @c(make-account)
    Cada llamada @c(acc) devuelve el procedimiento @c(deposit) o procedimiento @c(withdraw) definido localmente, que se aplica a lo especificado
    @c(amount). Como fue el caso con @c(make-withdraw), otra llamada
    a@c(make-account)

#     ..src > scheme
#       (define acc2 (make-account 100))
#     < src..
    ..src > scheme
      (define acc2 (make-account 100))
    < src..

#     will produce a completely separate account object, which maintains its own
#     local @c(balance).
    Producirá un objeto de cuenta completamente separado, que mantiene su propio
    local @c(balance).

#     :: @t(Exercise 3.1) :: An @e(accumulator) is a procedure that is called
#        repeatedly with a single numeric argument and accumulates its arguments
#        into a sum. Each time it is called, it returns the currently accumulated
#        sum. Write a procedure @c(make-accumulator) that generates accumulators,
#        each maintaining an independent sum. The input to @c(make-accumulator)
#        should specify the initial value of the sum; for example
    :: @t(Ejercicio 3.1) :: Un @e(acumulador) es un procedimiento que se llama
       repetidamente con un solo argumento numérico y acumula sus argumentos en
       una suma. Cada vez que se llama, devuelve la suma acumulada
       actualmente. Escriba un procedimiento @c(make-accumulator) que genere
       acumuladores, cada uno manteniendo una suma independiente. La entrada a
       @c(make-accumulator) debe especificar el valor inicial de la suma; por
       ejemplo

#        ..srci > scheme
#          > (define A (make-accumulator 5))
#          > (A 10)
#          15
#          > (A 10)
#          25
#        < srci..
       ..srci > scheme
         > (define A (make-accumulator 5))
         > (A 10)
         15
         > (A 10)
         25
       < srci..

#     :: @t(Exercise 3.2) :: In software-testing applications, it is useful to be
#        able to count the number of times a given procedure is called during the
#        course of a computation. Write a procedure @c(make-monitored) that takes as
#        input a procedure, @c(f), that itself takes one input. The result returned
#        by @c(make-monitored) is a third procedure, say @c(mf), that keeps track of
#        the number of times it has been called by maintaining an internal
#        counter. If the input to @c(mf) is the special symbol @c(how-many-calls?),
#        then @c(mf) returns the value of the counter. If the input is the special
#        symbol @c(reset-count), then @c(mf) resets the counter to zero. For any
#        other input, @c(mf) returns the result of calling @c(f) on that input and
#        increments the counter. For instance, we could make a monitored version of
#        the @c(sqrt) procedure:
    :: @t(Ejercicio 3.2) :: En las aplicaciones de prueba de software, es útil
       poder contar el número de veces que se llama un procedimiento dado
       durante el curso de un cálculo. Escriba un procedimiento
       @c(make-monitored) que toma como entrada un procedimiento @c(f),, que por
       sí mismo toma una entrada. El resultado devuelto por @c(make-monitored)
       es un tercer procedimiento, digamos @c(mf), que mantiene un registro del
       número de veces que se ha llamado manteniendo un contador interno. Si la
       entrada a @c(mf) es el símbolo especial @c(how-many-calls?), entonces
       @c(mf) devuelve el valor del contador. Si la entrada es el símbolo
       especial @c(reset-count), entonces @c(mf) restablece el contador a
       cero. Para cualquier otra entrada, @c(mf) devuelve el resultado de
       invocar @c(f) esa entrada e incrementa el contador. Por ejemplo,
       podríamos hacer una versión supervisada del procedimiento @c(sqrt):

#        ..srci > scheme
#          > (define s (make-monitored sqrt))
#          > (s 100)
#          10
#          > (s 'how-many-calls?)
#          1
#        < srci..
       ..srci > scheme
         > (define s (make-monitored sqrt))
         > (s 100)
         10
         > (s 'how-many-calls?)
         1
       < srci..

#     :: @t(Exercise 3.3) :: Modify the @c(make-account) procedure so that it
#        creates password-protected accounts. That is, @c(make-account) should take
#        a symbol as an additional argument, as in
    :: @t(Ejercicio 3.3) :: Modifique el procedimiento @c(make-account) para que
       cree cuentas protegidas por contraseña. Es decir, @c(make-account) debe
       tomar un símbolo como un argumento adicional, como en

#        ..src > scheme
#          (define acc
#            (make-account 100 'secret-password))
#        < src..
       ..src > scheme
         (define acc
           (make-account 100 'secret-password))
       < src..

#        The resulting account object should process a request only if it is
#        accompanied by the password with which the account was created, and should
#        otherwise return a complaint:
       El objeto de cuenta resultante debe procesar una solicitud sólo si está
       acompañada por la contraseña con la que se creó la cuenta y, de lo
       contrario, devolver una queja:

#        ..srci > scheme
#          > ((acc 'secret-password 'withdraw) 40)
#          60
#          > ((acc 'some-other-password 'deposit) 50)
#          "Incorrect password"
#        < srci..
       ..srci > scheme
         > ((acc 'secret-password 'withdraw) 40)
         60
         > ((acc 'some-other-password 'deposit) 50)
         "Incorrect password"
       < srci..

#     :: @t(Exercise 3.4) :: Modify the @c(make-account) procedure of @l(#Exercise
#        3.3) by adding another local state variable so that, if an account is
#        accessed more than seven consecutive times with an incorrect password, it
#        invokes the procedure @c(call-the-cops).
    :: @t(Ejercicio 3.4) :: Modifique el procedimiento @c(make-account) del
       @l(#Ejercicio 3.3) agregando otra variable de estado local
       para que, si se accede a una cuenta más de siete veces consecutivas con
       una contraseña incorrecta, invoca el procedimiento @c(call-the-cops).

# *** 3.1.2 <> The Benefits of Introducing Assignment
*** 3.1.2 <> Los beneficios de presentar la asignación

#     As we shall see, introducing assignment into our programming language leads us
#     into a thicket of difficult conceptual issues. Nevertheless, viewing systems
#     as collections of objects with local state is a powerful technique for
#     maintaining a modular design. As a simple example, consider the design of a
#     procedure @c(rand) that, whenever it is called, returns an integer chosen at
#     random.
    Como veremos, la introducción de la asignación en nuestro lenguaje de
    programación nos lleva a una maraña de problemas conceptuales difíciles. Sin
    embargo, los sistemas de visualización como colecciones de objetos con
    estado local es una técnica poderosa para mantener un diseño modular. Como
    un ejemplo simple, considere el diseño de un procedimiento @c(rand) que,
    cuando se llama, devuelve un entero elegido al azar.

#     It is not at all clear what is meant by @"(chosen at random.)  What we
#     presumably want is for successive calls to @c(rand) to produce a sequence of
#     numbers that has statistical properties of uniform distribution. We will not
#     discuss methods for generating suitable sequences here. Rather, let us assume
#     that we have a procedure @c(rand-update) that has the property that if we
#     start with a given number @m(x₁) and form
    No está del todo claro qué se entiende por @"(elegido al azar. )  Lo que
    presumiblemente queremos es que las llamadas sucesivas @c(rand) produzcan
    una secuencia de números que tenga propiedades estadísticas de distribución
    uniforme. No discutiremos los métodos para generar secuencias adecuadas
    aquí. Más bien, supongamos que tenemos un procedimiento @c(rand-update) que
    tiene la propiedad de que si comenzamos con un número dado @m(x₁) y formamos

#     ..src > scheme
#       x₂ = (rand-update x₁)
#       x₃ = (rand-update x₂)
#     < src..
    ..src > scheme
      x₂ = (rand-update x₁)
      x₃ = (rand-update x₂)
    < src..

#     then the sequence of values @m(x₁), @m(x₂), @m(x₃), … will have the desired
#     statistical properties.@n(134)
    Entonces la secuencia de valores @m(x₁), @m(x₂), @m(x₃), ... tendrá las
    propiedades estadísticas deseadas.@n(134)

#     We can implement @c(rand) as a procedure with a local state variable @c(x)
#     that is initialized to some fixed value @c(random-init). Each call to @c(rand)
#     computes @c(rand-update) of the current value of @c(x), returns this as the
#     random number, and also stores this as the new value of @c(x).
    Podemos implementar @c(rand) como un procedimiento con una variable de
    estado local @c(x) que se inicializa a un valor fijo @c(random-init). Cada
    llamada a los @c(rand) cálculos @c(rand-update) del valor actual de @c(x),
    devuelve esto como el número aleatorio, y también almacena esto como el
    nuevo valor de @c(x).

#     ..src > scheme
#       (define rand
#         (let ((x random-init))
#           (lambda () (set! x (rand-update x)) x)))
#     < src..
    ..src > scheme
      (define rand
        (let ((x random-init))
          (lambda () (set! x (rand-update x)) x)))
    < src..

#     Of course, we could generate the same sequence of random numbers without using
#     assignment by simply calling @c(rand-update) directly. However, this would
#     mean that any part of our program that used random numbers would have to
#     explicitly remember the current value of @c(x) to be passed as an argument to
#     @c(rand-update). To realize what an annoyance this would be, consider using
#     random numbers to implement a technique called @e(Monte Carlo simulation).
    Por supuesto, podríamos generar la misma secuencia de números aleatorios sin
    usar la asignación simplemente llamando @c(rand-update) directamente. Sin
    embargo, esto significaría que cualquier parte de nuestro programa que usó
    números aleatorios tendría que recordar explícitamente el valor actual de
    @c(x) ser pasado como un argumento a @c(rand-update). Para darse cuenta de
    lo que sería una molestia, considere utilizar números aleatorios para
    implementar una técnica llamada @e(simulación de Monte Carlo).

#     The Monte Carlo method consists of choosing sample experiments at random from
#     a large set and then making deductions on the basis of the probabilities
#     estimated from tabulating the results of those experiments. For example, we
#     can approximate @m(π) using the fact that @m(6/π²) is the probability that two
#     integers chosen at random will have no factors in common; that is, that their
#     greatest common divisor will be 1.@n(135) To obtain the approximation to
#     @m(π), we perform a large number of experiments.  In each experiment we choose
#     two integers at random and perform a test to see if their @A(GCD) is 1. The
#     fraction of times that the test is passed gives us our estimate of @m(6/π²),
#     and from this we obtain our approximation to @m(π).
    El método de Monte Carlo consiste en elegir los experimentos de la muestra
    aleatoriamente de un conjunto grande y después hacer deducciones sobre la
    base de las probabilidades estimadas de tabular los resultados de esos
    experimentos. Por ejemplo, podemos aproximar @m(π) usando el hecho de que
    @m(6 / π²) es la probabilidad de que dos enteros elegidos al azar no tengan
    factores en común; Es decir, que su mayor divisor común
    será 1.@n(135) Para obtener la aproximación a @m(π), realizamos un
    gran número de experimentos. En cada experimento elegimos dos enteros al
    azar y realizamos una prueba para ver si su @A(GCD) es 1. La fracción de
    veces que pasa la prueba nos da nuestra estimación de @m(6 / π²) ,@m()

#     The heart of our program is a procedure @c(monte-carlo), which takes as
#     arguments the number of times to try an experiment, together with the
#     experiment, represented as a no-argument procedure that will return either
#     true or false each time it is run. @c(Monte-carlo) runs the experiment for the
#     designated number of trials and returns a number telling the fraction of the
#     trials in which the experiment was found to be true.
    El corazón de nuestro programa es un procedimiento @c(monte-carlo) que toma
    como argumentos el número de veces que se intenta un experimento, junto con
    el experimento, representado como un procedimiento sin argumento que
    devolverá true o false cada vez que se ejecute. @c(Monte-carlo) Ejecuta el
    experimento para el número designado de ensayos y devuelve un número que
    indica la fracción de los ensayos en los que se comprobó que el experimento
    era verdadero.

#     ..src > scheme
#       (define (estimate-pi trials)
#         (sqrt (/ 6 (monte-carlo trials
#                                 cesaro-test))))
#       (define (cesaro-test)
#          (= (gcd (rand) (rand)) 1))
#
#       (define (monte-carlo trials experiment)
#         (define (iter trials-remaining trials-passed)
#           (cond ((= trials-remaining 0)
#                  (/ trials-passed trials))
#                 ((experiment)
#                  (iter (- trials-remaining 1)
#                        (+ trials-passed 1)))
#                 (else
#                  (iter (- trials-remaining 1)
#                        trials-passed))))
#         (iter trials 0))
#     < src..
    ..src > scheme
      (define (estimate-pi trials)
        (sqrt (/ 6 (monte-carlo trials
                                cesaro-test))))
      (define (cesaro-test)
         (= (gcd (rand) (rand)) 1))

      (define (monte-carlo trials experiment)
        (define (iter trials-remaining trials-passed)
          (cond ((= trials-remaining 0)
                 (/ trials-passed trials))
                ((experiment)
                 (iter (- trials-remaining 1)
                       (+ trials-passed 1)))
                (else
                 (iter (- trials-remaining 1)
                       trials-passed))))
        (iter trials 0))
    < src..

#     Now let us try the same computation using @c(rand-update) directly rather than
#     @c(rand), the way we would be forced to proceed if we did not use assignment
#     to model local state:
    Ahora vamos a intentar el mismo cálculo utilizando @c(rand-update)
    directamente en lugar de @c(rand), la forma en que se vería obligado a
    proceder si no se utiliza la asignación de modelo de estado local:

#     ..src > scheme
#       (define (estimate-pi trials)
#         (sqrt (/ 6 (random-gcd-test trials
#                                     random-init))))
#
#       (define (random-gcd-test trials initial-x)
#         (define (iter trials-remaining
#                       trials-passed
#                       x)
#           (let ((x1 (rand-update x)))
#             (let ((x2 (rand-update x1)))
#               (cond ((= trials-remaining 0)
#                      (/ trials-passed trials))
#                     ((= (gcd x1 x2) 1)
#                      (iter (- trials-remaining 1)
#                            (+ trials-passed 1)
#                            x2))
#                     (else
#                      (iter (- trials-remaining 1)
#                            trials-passed
#                            x2))))))
#         (iter trials 0 initial-x))
#     < src..
    ..src > scheme
      (define (estimate-pi trials)
        (sqrt (/ 6 (random-gcd-test trials
                                    random-init))))

      (define (random-gcd-test trials initial-x)
        (define (iter trials-remaining
                      trials-passed
                      x)
          (let ((x1 (rand-update x)))
            (let ((x2 (rand-update x1)))
              (cond ((= trials-remaining 0)
                     (/ trials-passed trials))
                    ((= (gcd x1 x2) 1)
                     (iter (- trials-remaining 1)
                           (+ trials-passed 1)
                           x2))
                    (else
                     (iter (- trials-remaining 1)
                           trials-passed
                           x2))))))
        (iter trials 0 initial-x))
    < src..

#     While the program is still simple, it betrays some painful breaches of
#     modularity. In our first version of the program, using @c(rand), we can
#     express the Monte Carlo method directly as a general @c(monte-carlo) procedure
#     that takes as an argument an arbitrary @c(experiment) procedure.  In our
#     second version of the program, with no local state for the random-number
#     generator, @c(random-gcd-test) must explicitly manipulate the random numbers
#     @c(x1) and @c(x2) and recycle @c(x2) through the iterative loop as the new
#     input to @c(rand-update). This explicit handling of the random numbers
#     intertwines the structure of accumulating test results with the fact that our
#     particular experiment uses two random numbers, whereas other Monte Carlo
#     experiments might use one random number or three. Even the top-level procedure
#     @c(estimate-pi) has to be concerned with supplying an initial random number.
#     The fact that the random-number generator's insides are leaking out into other
#     parts of the program makes it difficult for us to isolate the Monte Carlo idea
#     so that it can be applied to other tasks. In the first version of the program,
#     assignment encapsulates the state of the random-number generator within the
#     @c(rand) procedure, so that the details of random-number generation remain
#     independent of the rest of the program.
    Mientras que el programa sigue siendo simple, traiciona algunas brechas
    dolorosas de la modularidad. En nuestra primera versión del programa,
    utilizando @c(rand), podemos expresar el método de Monte Carlo directamente
    como un procedimiento @c(monte-carlo) general que toma como argumento un
    procedimiento @c(experiment) arbitrario. En la segunda versión del programa,
    sin un estado local para el generador de números aleatorios,
    @c(random-gcd-test) debe manipular explícitamente los números aleatorios
    @c(x1) y @c(x2) y reciclar @c(x2) a través del bucle iterativo como la nueva
    entrada a @c(rand-update). Este manejo explícito de los números aleatorios
    entrelaza la estructura de los resultados acumulados de la prueba con el
    hecho de que nuestro experimento particular utiliza dos números aleatorios,
    mientras que otros experimentos de Monte Carlo podrían utilizar un número
    aleatorio o tres. @c(estimate-pi) Incluso el procedimiento de nivel superior
    tiene que estar relacionado con el suministro de un número aleatorio
    inicial. El hecho de que los interiores del generador de números aleatorios
    se filtren en otras partes del programa nos dificulta aislar la idea de
    Monte Carlo para que pueda aplicarse a otras tareas. En la primera versión
    del programa, la asignación encapsula el estado del generador de números
    aleatorios dentro del procedimiento @c(rand), de modo que los detalles de la
    generación de números aleatorios permanecen independientes del resto del
    programa.

#     The general phenomenon illustrated by the Monte Carlo example is this: From
#     the point of view of one part of a complex process, the other parts appear to
#     change with time. They have hidden time-varying local state. If we wish to
#     write computer programs whose structure reflects this decomposition, we make
#     computational objects (such as bank accounts and random-number generators)
#     whose behavior changes with time. We model state with local state variables,
#     and we model the changes of state with assignments to those variables.
    El fenómeno general ilustrado por el ejemplo de Monte Carlo es éste: Desde
    el punto de vista de una parte de un proceso complejo, las otras partes
    parecen cambiar con el tiempo. Ellos han ocultado el estado local que varía
    en el tiempo. Si deseamos escribir programas informáticos cuya estructura
    refleja esta descomposición, hacemos objetos computacionales (como cuentas
    bancarias y generadores de números aleatorios) cuyo comportamiento cambia
    con el tiempo. Modelamos el estado con variables de estado locales, y
    modelamos los cambios de estado con asignaciones a esas variables.

#     It is tempting to conclude this discussion by saying that, by introducing
#     assignment and the technique of hiding state in local variables, we are able
#     to structure systems in a more modular fashion than if all state had to be
#     manipulated explicitly, by passing additional parameters. Unfortunately, as we
#     shall see, the story is not so simple.
    Es tentador concluir esta discusión diciendo que, al introducir la
    asignación y la técnica de ocultar el estado en las variables locales,
    podemos estructurar los sistemas de una manera más modular que si todo el
    estado tuviera que manipularse explícitamente, pasando parámetros
    adicionales. Lamentablemente, como veremos, la historia no es tan simple.

#     :: @t(Exercise 3.5) :: @e(Monte Carlo integration) is a method of estimating
#        definite integrals by means of Monte Carlo simulation. Consider computing
#        the area of a region of space described by a predicate @m[P(x, y)] that is
#        true for points @m[(x, y)] in the region and false for points not in the
#        region. For example, the region contained within a circle of radius 3
#        centered at (5, 7) is described by the predicate that tests whether @m[(x -
#        5)² + (y - 7)² ≤ 3²]. To estimate the area of the region described by such
#        a predicate, begin by choosing a rectangle that contains the region. For
#        example, a rectangle with diagonally opposite corners at (2, 4) and (8, 10)
#        contains the circle above. The desired integral is the area of that portion
#        of the rectangle that lies in the region.  We can estimate the integral by
#        picking, at random, points @m[(x, y)] that lie in the rectangle, and
#        testing @m[P(x, y)] for each point to determine whether the point lies in
#        the region. If we try this with many points, then the fraction of points
#        that fall in the region should give an estimate of the proportion of the
#        rectangle that lies in the region. Hence, multiplying this fraction by the
#        area of the entire rectangle should produce an estimate of the integral.
    :: @t(Ejercicio 3.5) :: @e(La integración de Monte Carlo) es un método para
       estimar integrales definidas mediante la simulación de Monte
       Carlo. Considere calcular el área de una región del espacio descrita por
       un predicado @m(P (x, y)) que es verdadero para los puntos @m[(x, y)] en
       la región y falso para los puntos que no están en la región. Por ejemplo,
       la región contenida dentro de un círculo de radio 3 centrado en (5, 7) es
       descrita por el predicado que prueba si @m[(x - 5)² + (y - 7) ² ≤
       3²]. Para estimar el área de la región descrita por tal predicado,
       comience eligiendo un rectángulo que contenga la región. Por ejemplo, un
       rectángulo con esquinas diagonalmente opuestas en (2, 4) y (8, 10)
       contiene el círculo anterior. La integral deseada es el área de la
       porción del rectángulo que se encuentra en la región. @m(Podemos estimar
       la integral recolectando al azar los puntos (x, y)) que se encuentran en
       el rectángulo, y probando @m(P (x, y)) para cada punto para determinar si
       el punto está en la región. Si intentamos esto con muchos puntos,
       entonces la fracción de puntos que caen en la región debe dar una
       estimación de la proporción del rectángulo que se encuentra en la
       región. Por lo tanto, multiplicar esta fracción por el área de todo el
       rectángulo debe producir una estimación de la integral. @e(Entonces la
       fracción de puntos que caen en la región debe dar una estimación de la
       proporción del rectángulo que se encuentra en la región. )@e(Por lo
       tanto, multiplicar esta fracción por el área de todo el rectángulo debe
       producir una estimación de la integral. )@e(Entonces la fracción de
       puntos que caen en la región debe dar una estimación de la proporción del
       rectángulo que se encuentra en la región. )@e(Por lo tanto, multiplicar
       esta fracción por el área de todo el rectángulo debe producir una
       estimación de la integral.)

#        Implement Monte Carlo integration as a procedure @c(estimate-integral) that
#        takes as arguments a predicate @c(P), upper and lower bounds @c(x1),
#        @c(x2), @c(y1), and @c(y2) for the rectangle, and the number of trials to
#        perform in order to produce the estimate. Your procedure should use the
#        same @c(monte-carlo) procedure that was used above to estimate @m(π).  Use
#        your @c(estimate-integral) to produce an estimate of @m(π) by measuring the
#        area of a unit circle.
       Implementar la integración Monte Carlo como un procedimiento
       @c(estimate-integral) que toma como argumentos un predicado @c(P),
       límites superior e inferior @c(x1), @c(x2), @c(y1), y @c(y2) para el
       rectángulo, y el número de ensayos para llevar a cabo con el fin de
       producir la estimación. Su procedimiento debe utilizar el mismo
       procedimiento @c(monte-carlo) que se utilizó anteriormente para estimar
       @m(π). Utilice su @c(estimate-integral) para producir una estimación de
       @m(π) midiendo el área de un círculo unitario.

#        You will find it useful to have a procedure that returns a number chosen at
#        random from a given range. The following @c(random-in-range) procedure
#        implements this in terms of the @c(random) procedure used in section @l(#1.2.6),
#        which returns a nonnegative number less than its input.@n(136)
       Encontrará útil tener un procedimiento que devuelva un número elegido al
       azar de un rango dado. El procedimiento @c(random-in-range) siguiente
       implementa esto en términos del procedimiento @c(random) utilizado en
       @l(#1.2.6), que devuelve un número no negativo menor que su
       entrada.@n(136)

#        ..src > scheme
#          (define (random-in-range low high)
#            (let ((range (- high low)))
#              (+ low (random range))))
#        < src..
       ..src > scheme
         (define (random-in-range low high)
           (let ((range (- high low)))
             (+ low (random range))))
       < src..

#     :: @t(Exercise 3.6) :: It is useful to be able to reset a random-number
#        generator to produce a sequence starting from a given value.  Design a new
#        @c(rand) procedure that is called with an argument that is either the
#        symbol @c(generate) or the symbol @c(reset) and behaves as follows:
#        @c[(rand 'generate)] produces a new random number; @c[((rand 'reset)
#        ⟨new-value⟩)] resets the internal state variable to the designated
#        @c[(new-value)]. Thus, by resetting the state, one can generate repeatable
#        sequences. These are very handy to have when testing and debugging programs
#        that use random numbers.
    :: @t(Ejercicio 3.6) :: Es útil poder restablecer un generador de números
       aleatorios para producir una secuencia a partir de un valor dado. Diseñar
       un nuevo procedimiento @c(rand) que se llama con un argumento que es el
       símbolo @c(generate) o el símbolo @c(reset) y se comporta de la siguiente
       manera: @c[(rand 'generate)] produce un nuevo número aleatorio; @c[((rand
       'reset) ⟨new-value⟩)] Restablece la variable de estado interna a la
       designada @c[(new-value)]. Así, mediante el restablecimiento del estado,
       se pueden generar secuencias repetibles. Estos son muy útiles para tener
       al probar y depurar programas que utilizan números aleatorios.

# *** 3.1.3 <> The Costs of Introducing Assignment
*** 3.1.3 <> Los costos de presentar la asignación

#     As we have seen, the @c(set!) operation enables us to model objects that have
#     local state. However, this advantage comes at a price. Our programming
#     language can no longer be interpreted in terms of the substitution model of
#     procedure application that we introduced in section @l(#1.1.5). Moreover, no simple
#     model with @"(nice) mathematical properties can be an adequate framework for
#     dealing with objects and assignment in programming languages.
    Como hemos visto, la @c(set!) operación nos permite modelar objetos que
    tienen estado local. Sin embargo, esta ventaja tiene un precio. Nuestro
    lenguaje de programación ya no puede interpretarse en términos del modelo de
    sustitución de la aplicación de procedimiento que introdujimos en
    @l(#1.1.5). Además, ningún modelo simple con @"(buenas) propiedades
    matemáticas puede ser un marco adecuado para tratar con objetos y asignación
    en lenguajes de programación.

#     So long as we do not use assignments, two evaluations of the same procedure
#     with the same arguments will produce the same result, so that procedures can
#     be viewed as computing mathematical functions. Programming without any use of
#     assignments, as we did throughout the first two chapters of this book, is
#     accordingly known as @e(functional programming).
    Mientras no utilicemos asignaciones, dos evaluaciones del mismo
    procedimiento con los mismos argumentos producirán el mismo resultado, de
    modo que los procedimientos pueden ser vistos como funciones matemáticas
    computacionales. La programación sin ningún uso de asignaciones, como lo
    hicimos a lo largo de los dos primeros capítulos de este libro, se conoce
    como @e(programación funcional).

#     To understand how assignment complicates matters, consider a simplified
#     version of the @c(make-withdraw) procedure of section @l(#3.1.1) that does not bother
#     to check for an insufficient amount:
    Para entender cómo la asignación complica las cosas, considere una versión
    simplificada del procedimiento @c(make-withdraw) de la seccion @l(#3.1.1) que no
    se moleste en chequear una cantidad insuficiente:

#     ..srci > scheme
#       > (define (make-simplified-withdraw balance)
#       ^   (lambda (amount)
#       ^     (set! balance (- balance amount))
#       ^     balance))
#       > (define W (make-simplified-withdraw 25))
#       > (W 20)
#       5
#       > (W 10)
#       -5
#     < srci..
    ..srci > scheme
      > (define (make-simplified-withdraw balance)
      ^   (lambda (amount)
      ^     (set! balance (- balance amount))
      ^     balance))
      > (define W (make-simplified-withdraw 25))
      > (W 20)
      5
      > (W 10)
      -5
    < srci..

#     Compare this procedure with the following @c(make-decrementer) procedure,
#     which does not use @c(set!):
    Compare este procedimiento con el siguiente procedimiento @c(make-decrementer), que no utiliza @c(set!):

#     ..src > scheme
#       (define (make-decrementer balance)
#         (lambda (amount)
#           (- balance amount)))
#     < src..
    ..src > scheme
      (define (make-decrementer balance)
        (lambda (amount)
          (- balance amount)))
    < src..

#     @c(Make-decrementer) returns a procedure that subtracts its input from a
#     designated amount @c(balance), but there is no accumulated effect over
#     successive calls, as with @c(make-simplified-withdraw):
    @c(Make-decrementer) Devuelve un procedimiento que resta su entrada de una
    cantidad designada @c(balance), pero no hay efecto acumulado sobre llamadas
    sucesivas, como con @c(make-simplified-withdraw):

#     ..srci > scheme
#       > (define D (make-decrementer 25))
#       > (D 20)
#       5
#       > (D 10)
#       15
#     < srci..
    ..srci > scheme
      > (define D (make-decrementer 25))
      > (D 20)
      5
      > (D 10)
      15
    < srci..

#     We can use the substitution model to explain how @c(make-decrementer) works.
#     For instance, let us analyze the evaluation of the expression
    Podemos usar el modelo de sustitución para explicar cómo
    @c(make-decrementer) funciona. Por ejemplo, analicemos la evaluación de la
    expresión

#     ..src > scheme
#       ((make-decrementer 25) 20)
#     < src..
    ..src > scheme
      ((make-decrementer 25) 20)
    < src..

#     We first simplify the operator of the combination by substituting 25 for
#     @c(balance) in the body of @c(make-decrementer). This reduces the expression
#     to
    Primero simplificamos el operador de la combinación sustituyendo 25
    @c(balance) en el cuerpo de @c(make-decrementer). Esto reduce la expresión a

#     ..src > scheme
#       ((lambda (amount) (- 25 amount)) 20)
#     < src..
    ..src > scheme
      ((lambda (amount) (- 25 amount)) 20)
    < src..

#     Now we apply the operator by substituting 20 for @c(amount) in the body of the
#     @c(lambda) expression:
    Ahora aplicamos al operador sustituyendo 20 @c(amount) en el cuerpo de la
    expresión @c(lambda):

#     ..src > scheme
#       (- 25 20)
#     < src..
    ..src > scheme
      (- 25 20)
    < src..

#     The final answer is 5.
    La respuesta final es 5.

#     Observe, however, what happens if we attempt a similar substitution analysis
#     with @c(make-simplified-withdraw):
    Observe, sin embargo, lo que sucede si intentamos un análisis de sustitución
    similar con @c(make-simplified-withdraw):

#     ..src > scheme
#       ((make-simplified-withdraw 25) 20)
#     < src..
    ..src > scheme
      ((make-simplified-withdraw 25) 20)
    < src..

#     We first simplify the operator by substituting 25 for @c(balance) in the body
#     of @c(make-simplified-withdraw). This reduces the expression to@n(137)
    En primer lugar, simplificar el operador mediante la sustitución de 25
    @c(balance) en el cuerpo de @c(make-simplified-withdraw). Esto reduce la
    expresión a@n(137)

#     ..src > scheme
#       ((lambda (amount)
#          (set! balance (- 25 amount)) 25)
#        20)
#     < src..
    ..src > scheme
      ((lambda (amount)
         (set! balance (- 25 amount)) 25)
       20)
    < src..

#     Now we apply the operator by substituting 20 for @c(amount) in the body of the
#     @c(lambda) expression:
    Ahora aplicamos al operador sustituyendo 20 @c(amount) en el cuerpo de la
    expresión @c(lambda):

#     ..src > scheme
#       (set! balance (- 25 20)) 25
#     < src..
    ..src > scheme
      (set! balance (- 25 20)) 25
    < src..

#     If we adhered to the substitution model, we would have to say that the meaning
#     of the procedure application is to first set @c(balance) to 5 and then return
#     25 as the value of the expression. This gets the wrong answer. In order to get
#     the correct answer, we would have to somehow distinguish the first occurrence
#     of @c(balance) (before the effect of the @c(set!))  from the second occurrence
#     of @c(balance) (after the effect of the @c(set!)), and the substitution model
#     cannot do this.
    Si nos adherimos al modelo de sustitución, tendríamos que decir que el
    significado de la aplicación de procedimiento es primero establecer
    @c(balance) a 5 y luego devolver 25 como el valor de la expresión. Esto
    obtiene la respuesta equivocada. Para obtener la respuesta correcta,
    tendríamos que distinguir de alguna manera la primera aparición de
    @c(balance)(antes del efecto de @c(set!)) de la segunda aparición de
    @c(balance)(después del efecto de @c(set!)), y el modelo de sustitución no
    puede hacer esto.

#     The trouble here is that substitution is based ultimately on the notion that
#     the symbols in our language are essentially names for values. But as soon as
#     we introduce @c(set!) and the idea that the value of a variable can change, a
#     variable can no longer be simply a name. Now a variable somehow refers to a
#     place where a value can be stored, and the value stored at this place can
#     change. in section @l(#3.2) we will see how environments play this role of @"(place)
#     in our computational model.
    El problema aquí es que la sustitución se basa en última instancia en la
    noción de que los símbolos en nuestro lenguaje son esencialmente nombres de
    valores. Pero tan pronto como introducimos @c(set!) y la idea de que el
    valor de una variable puede cambiar, una variable ya no puede ser
    simplemente un nombre. Ahora una variable de alguna manera se refiere a un
    lugar donde un valor puede ser almacenado, y el valor almacenado en este
    lugar puede cambiar. en la seccion @l(#3.2) veremos cómo los ambientes desempeñan
    este papel de @"(lugar) en nuestro modelo computacional.

# **** Sameness and change
**** La semejanza y el cambio

#      The issue surfacing here is more profound than the mere breakdown of a
#      particular model of computation. As soon as we introduce change into our
#      computational models, many notions that were previously straightforward become
#      problematical. Consider the concept of two things being @"(the same.)
     El problema que surge aquí es más profundo que la simple ruptura de un
     modelo particular de cálculo. Tan pronto como introducimos el cambio en
     nuestros modelos computacionales, muchas nociones que antes eran sencillas
     se volvieron problemáticas. Considere el concepto de que dos cosas son
     @"(las mismas.)

#      Suppose we call @c(make-decrementer) twice with the same argument to create
#      two procedures:
     Supongamos que llamamos @c(make-decrementer) dos veces con el mismo
     argumento para crear dos procedimientos:

#      ..src > scheme
#        (define D1 (make-decrementer 25))
#        (define D2 (make-decrementer 25))
#      < src..
     ..src > scheme
       (define D1 (make-decrementer 25))
       (define D2 (make-decrementer 25))
     < src..

#      Are @c(D1) and @c(D2) the same?  An acceptable answer is yes, because @c(D1)
#      and @c(D2) have the same computational behavior––each is a procedure that
#      subtracts its input from 25. In fact, @c(D1) could be substituted for @c(D2)
#      in any computation without changing the result.
     Son @c(D1) y @c(D2) lo mismo? Una respuesta aceptable es sí, porque @c(D1)
     y @c(D2) tienen el mismo comportamiento computacional - cada uno es un
     procedimiento que resta su entrada de 25. De hecho, @c(D1) podría ser
     sustituido @c(D2) en cualquier cálculo sin cambiar el resultado.

#      Contrast this with making two calls to @c(make-simplified-withdraw):
     Contraste esto con hacer dos llamadas a @c(make-simplified-withdraw):

#      ..src > scheme
#        (define W1 (make-simplified-withdraw 25))
#        (define W2 (make-simplified-withdraw 25))
#      < src..
     ..src > scheme
       (define W1 (make-simplified-withdraw 25))
       (define W2 (make-simplified-withdraw 25))
     < src..

#      Are @c(W1) and @c(W2) the same?  Surely not, because calls to @c(W1) and
#      @c(W2) have distinct effects, as shown by the following sequence of
#      interactions:
     Son @c(W1) y @c(W2) lo mismo? Seguramente no, porque llama @c(W1) y @c(W2)
     tiene efectos distintos, como lo demuestra la siguiente secuencia de
     interacciones:

#      ..srci > scheme
#        > (W1 20)
#        5
#        > (W1 20)
#        -15
#        > (W2 20)
#        5
#      < srci..
     ..srci > scheme
       > (W1 20)
       5
       > (W1 20)
       -15
       > (W2 20)
       5
     < srci..

#      Even though @c(W1) and @c(W2) are @"(equal) in the sense that they are both
#      created by evaluating the same expression, @c[(make-simplified-withdraw 25)],
#      it is not true that @c(W1) could be substituted for @c(W2) in any expression
#      without changing the result of evaluating the expression.
     A pesar de que @c(W1) y @c(W2) son @"(iguales) en el sentido de que ambos
     están creados mediante la evaluación de la misma expresión,
     @c[(make-simplified-withdraw 25)], no es cierto que @c(W1) podría ser
     sustituido por @c(W2) cualquier expresión sin cambiar el resultado de
     evaluar la expresión.

#      A language that supports the concept that @"(equals can be substituted for
#      equals) in an expression without changing the value of the expression is said
#      to be @e(referentially transparent). Referential transparency is violated when
#      we include @c(set!) in our computer language. This makes it tricky to
#      determine when we can simplify expressions by substituting equivalent
#      expressions. Consequently, reasoning about programs that use assignment
#      becomes drastically more difficult.
     Se dice que un lenguaje que soporta el concepto que @"(iguala puede ser
     sustituido por igual) en una expresión sin cambiar el valor de la expresión
     es @e(referencialmente transparente). La transparencia referencial es
     violada cuando incluimos @c(set!) en nuestro lenguaje informático. Esto
     hace que sea difícil determinar cuándo podemos simplificar expresiones
     sustituyendo expresiones equivalentes. En consecuencia, el razonamiento
     sobre los programas que utilizan la asignación se hace drásticamente más
     difícil.

#      Once we forgo referential transparency, the notion of what it means for
#      computational objects to be @"(the same) becomes difficult to capture in a
#      formal way. Indeed, the meaning of @"(same) in the real world that our
#      programs model is hardly clear in itself. In general, we can determine that
#      two apparently identical objects are indeed @"(the same one) only by modifying
#      one object and then observing whether the other object has changed in the same
#      way. But how can we tell if an object has @"(changed) other than by observing
#      the @"(same) object twice and seeing whether some property of the object
#      differs from one observation to the next?  Thus, we cannot determine
#      @"(change) without some @e(a priori) notion of @"(sameness,) and we cannot
#      determine sameness without observing the effects of change.
     Una vez que renunciamos a la transparencia referencial, la noción de lo que
     significa que los objetos computacionales sean @"(iguales se) vuelve
     difícil de capturar de una manera formal. De hecho, el significado de lo
     @"(mismo) en el mundo real que nuestro modelo de programas es difícilmente
     claro en sí mismo. En general, podemos determinar que dos objetos
     aparentemente idénticos son realmente @"(los mismos) sólo modificando un
     objeto y luego observando si el otro objeto ha cambiado de la misma
     manera. Pero ¿cómo podemos saber si un objeto ha @"(cambiado,) aparte de
     observar el @"(mismo) objeto dos veces y ver si alguna propiedad del objeto
     difiere de una observación a la siguiente? Así,@"()@e()@"()

#      As an example of how this issue arises in programming, consider the situation
#      where Peter and Paul have a bank account with $100 in it. There is a
#      substantial difference between modeling this as
     Como ejemplo de cómo surge este problema en la programación, considere la
     situación en la que Peter y Paul tienen una cuenta bancaria con $ 100 en
     ella. Hay una diferencia sustancial entre modelar esto como

#      ..src > scheme
#        (define peter-acc (make-account 100))
#        (define paul-acc (make-account 100))
#      < src..
     ..src > scheme
       (define peter-acc (make-account 100))
       (define paul-acc (make-account 100))
     < src..

#      and modeling it as
     Y modelándolo como

#      ..src > scheme
#        (define peter-acc (make-account 100))
#        (define paul-acc peter-acc)
#      < src..
     ..src > scheme
       (define peter-acc (make-account 100))
       (define paul-acc peter-acc)
     < src..

#      In the first situation, the two bank accounts are distinct. Transactions made
#      by Peter will not affect Paul's account, and vice versa. In the second
#      situation, however, we have defined @c(paul-acc) to be @e(the same thing) as
#      @c(peter-acc). In effect, Peter and Paul now have a joint bank account, and if
#      Peter makes a withdrawal from @c(peter-acc) Paul will observe less money in
#      @c(paul-acc). These two similar but distinct situations can cause confusion in
#      building computational models. With the shared account, in particular, it can
#      be especially confusing that there is one object (the bank account) that has
#      two different names (@c(peter-acc) and @c(paul-acc)); if we are searching for
#      all the places in our program where @c(paul-acc) can be changed, we must
#      remember to look also at things that change @c(peter-acc).@n(138)
     En la primera situación, las dos cuentas bancarias son distintas. Las
     transacciones hechas por Pedro no afectarán la cuenta de Pablo, y
     viceversa. En la segunda situación, sin embargo, hemos definido
     @c(paul-acc) a ser @e(lo mismo) como @c(peter-acc). En efecto, Pedro y
     Pablo ahora tienen una cuenta bancaria conjunta, y si Pedro hace una
     retirada de @c(peter-acc) Pablo observará menos dinero en
     @c(paul-acc). Estas dos situaciones similares pero distintas pueden causar
     confusión en la construcción de modelos computacionales. Con la cuenta
     compartida, en particular, puede ser especialmente confuso que hay un
     objeto (la cuenta bancaria) que tiene dos nombres diferentes (
     @c(peter-acc) y @c(paul-acc)); Si estamos buscando todos los lugares en
     nuestro programa donde @c(paul-acc) se puede cambiar, debemos recordar
     mirar también las cosas que cambian @c(peter-acc).@n(138)

#      With reference to the above remarks on @"(sameness) and @"(change,) observe
#      that if Peter and Paul could only examine their bank balances, and could not
#      perform operations that changed the balance, then the issue of whether the two
#      accounts are distinct would be moot. In general, so long as we never modify
#      data objects, we can regard a compound data object to be precisely the
#      totality of its pieces. For example, a rational number is determined by giving
#      its numerator and its denominator. But this view is no longer valid in the
#      presence of change, where a compound data object has an @"(identity) that is
#      something different from the pieces of which it is composed. A bank account is
#      still @"(the same) bank account even if we change the balance by making a
#      withdrawal; conversely, we could have two different bank accounts with the
#      same state information. This complication is a consequence, not of our
#      programming language, but of our perception of a bank account as an object. We
#      do not, for example, ordinarily regard a rational number as a changeable
#      object with identity, such that we could change the numerator and still have
#      @"(the same) rational number.
     Con referencia a las observaciones anteriores sobre @"(igualdad) y
     @"(cambio,) observe que si Pedro y Pablo sólo pudieran examinar sus saldos
     bancarios y no pudieran realizar operaciones que cambiaran el saldo,
     entonces la cuestión de si las dos cuentas son distintas sería
     discutible. En general, siempre que nunca modifiquemos objetos de datos,
     podemos considerar un objeto de datos compuesto como la totalidad de sus
     piezas. Por ejemplo, un número racional se determina dando su numerador y
     su denominador. Pero este punto de vista ya no es válido en presencia de un
     cambio, en el que un objeto de datos compuesto tiene una @"(identidad) que
     es algo diferente de las piezas de las que está compuesta. Una cuenta
     bancaria sigue siendo @"(la misma) cuenta bancaria, incluso si cambiamos el
     saldo haciendo una retirada; Por el contrario, podríamos tener dos cuentas
     bancarias diferentes con la misma información de estado. Esta complicación
     es una consecuencia, no de nuestro lenguaje de programación, sino de
     nuestra percepción de una cuenta bancaria como un objeto. @"(Por ejemplo,
     no consideramos ordinariamente un número racional como un objeto cambiante
     con identidad, de modo que podríamos cambiar el numerador y todavía tener
     el mismo) número racional.

# **** Pitfalls of imperative programming
**** Trampas de la programación imperativa

#      In contrast to functional programming, programming that makes extensive use of
#      assignment is known as @e(imperative programming). In addition to raising
#      complications about computational models, programs written in imperative style
#      are susceptible to bugs that cannot occur in functional programs. For example,
#      recall the iterative factorial program from @l(#1.2.1):
     En contraste con la programación funcional, la programación que hace uso
     extensivo de la asignación se conoce como @e(programación
     imperativa). Además de plantear complicaciones sobre modelos
     computacionales, los programas escritos en estilo imperativo son
     susceptibles a errores que no pueden ocurrir en programas funcionales. Por
     ejemplo, recuerde el programa factorial iterativo de la seccion @l(#1.2.1) :

#      ..src > scheme
#        (define (factorial n)
#          (define (iter product counter)
#            (if (> counter n)
#                product
#                (iter (* counter product)
#                      (+ counter 1))))
#          (iter 1 1))
#      < src..
     ..src > scheme
       (define (factorial n)
         (define (iter product counter)
           (if (> counter n)
               product
               (iter (* counter product)
                     (+ counter 1))))
         (iter 1 1))
     < src..

#      Instead of passing arguments in the internal iterative loop, we could adopt a
#      more imperative style by using explicit assignment to update the values of the
#      variables @c(product) and @c(counter):
     En lugar de pasar argumentos en el bucle iterativo interno, podríamos
     adoptar un estilo más imperativo mediante la asignación explícita para
     actualizar los valores de las variables @c(product) y @c(counter):

#      ..src > scheme
#        (define (factorial n)
#          (let ((product 1)
#                (counter 1))
#            (define (iter)
#              (if (> counter n)
#                  product
#                  (begin (set! product (* counter
#                                          product))
#                         (set! counter (+ counter 1))
#                         (iter))))
#            (iter)))
#      < src..
     ..src > scheme
       (define (factorial n)
         (let ((product 1)
               (counter 1))
           (define (iter)
             (if (> counter n)
                 product
                 (begin (set! product (* counter
                                         product))
                        (set! counter (+ counter 1))
                        (iter))))
           (iter)))
     < src..

#      This does not change the results produced by the program, but it does
#      introduce a subtle trap. How do we decide the order of the assignments?  As it
#      happens, the program is correct as written. But writing the assignments in the
#      opposite order
     Esto no cambia los resultados producidos por el programa, pero introduce
     una trampa sutil. ¿Cómo decidimos el orden de las asignaciones? Como
     sucede, el programa es correcto como está escrito. Pero escribir las
     asignaciones en el orden opuesto

#      ..src > scheme
#        (set! counter (+ counter 1))
#        (set! product (* counter product))
#      < src..
     ..src > scheme
       (set! counter (+ counter 1))
       (set! product (* counter product))
     < src..

#      would have produced a different, incorrect result. In general, programming
#      with assignment forces us to carefully consider the relative orders of the
#      assignments to make sure that each statement is using the correct version of
#      the variables that have been changed. This issue simply does not arise in
#      functional programs.@n(139)
     Hubiera producido un resultado diferente e incorrecto. En general, la
     programación con asignación obliga a considerar cuidadosamente los órdenes
     relativos de las asignaciones para asegurarse de que cada instrucción está
     utilizando la versión correcta de las variables que se han cambiado. Esta
     cuestión simplemente no surge en los programas funcionales.@n(139)

#      The complexity of imperative programs becomes even worse if we consider
#      applications in which several processes execute concurrently. We will return
#      to this in section @l(#3.4). First, however, we will address the issue of providing a
#      computational model for expressions that involve assignment, and explore the
#      uses of objects with local state in designing simulations.
     La complejidad de los programas imperativos se vuelve aún peor si
     consideramos aplicaciones en las que varios procesos se ejecutan
     simultáneamente. Volveremos a esto en la seccion @l(#3.4). En primer lugar, sin
     embargo, abordaremos la cuestión de proporcionar un modelo computacional
     para expresiones que impliquen asignación y explorar los usos de objetos
     con estado local en el diseño de simulaciones.

#      :: @t(Exercise 3.7) :: Consider the bank account objects created by
#         @c(make-account), with the password modification described in @l(#Exercise
#         3.3). Suppose that our banking system requires the ability to make joint
#         accounts. Define a procedure @c(make-joint) that accomplishes
#         this. @c(Make-joint) should take three arguments. The first is a
#         password-protected account. The second argument must match the password
#         with which the account was defined in order for the @c(make-joint)
#         operation to proceed. The third argument is a new password. @c(Make-joint)
#         is to create an additional access to the original account using the new
#         password. For example, if @c(peter-acc) is a bank account with password
#         @c(open-sesame), then
     :: @t(Ejercicio 3.7) :: Considere los objetos de cuenta bancaria creados
        por @c(make-account), con la modificación de contraseña descrita en el
        @l(#Ejercicio 3.3). Supongamos que nuestro sistema
        bancario requiere la capacidad de hacer cuentas conjuntas. Defina un
        procedimiento @c(make-joint) que logre esto. @c(Make-joint) Debe tomar
        tres argumentos. La primera es una cuenta protegida por contraseña. El
        segundo argumento debe coincidir con la contraseña con la que se definió
        la cuenta para que la @c(make-joint) operación continúe. El tercer
        argumento es una nueva contraseña. @c(Make-joint) Es crear un acceso
        adicional a la cuenta original utilizando la nueva contraseña. Por
        ejemplo, si @c(peter-acc) es una cuenta bancaria con contraseña
        @c(open-sesame),

#         ..src > scheme
#           (define paul-acc
#             (make-joint peter-acc
#                         'open-sesame
#                         'rosebud))
#         < src..
        ..src > scheme
          (define paul-acc
            (make-joint peter-acc
                        'open-sesame
                        'rosebud))
        < src..

#         will allow one to make transactions on @c(peter-acc) using the name
#         @c(paul-acc) and the password @c(rosebud). You may wish to modify your
#         solution to @l(#Exercise 3.3) to accommodate this new feature.
        Permitirá realizar transacciones sobre el @c(peter-acc) uso del nombre
        @c(paul-acc) y la contraseña @c(rosebud). Es posible que desee modificar
        su solución al @l(#Ejercicio 3.3) para acomodar esta nueva
        característica.

#      :: @t(Exercise 3.8) :: When we defined the evaluation model in section @l(#1.1.3), we
#         said that the first step in evaluating an expression is to evaluate its
#         subexpressions. But we never specified the order in which the
#         subexpressions should be evaluated (e.g., left to right or right to
#         left). When we introduce assignment, the order in which the arguments to a
#         procedure are evaluated can make a difference to the result. Define a
#         simple procedure @c(f) such that evaluating
     :: @t(Ejercicio 3.8) :: Cuando definimos el modelo de evaluación en
        @l(#1.1.3), dijimos que el primer paso en la evaluación de una
        expresión es evaluar sus subexpresiones. Pero nunca especificamos el
        orden en el que deben evaluarse las subexpresiones (por ejemplo, de
        izquierda a derecha o de derecha a izquierda). Cuando introducimos la
        asignación, el orden en el que se evalúan los argumentos a un
        procedimiento puede hacer una diferencia en el resultado. Definir un
        procedimiento simple @c(f) tal que evaluar

#         ..src > scheme
#           (+ (f 0) (f 1))
#         < src..
        ..src > scheme
          (+ (f 0) (f 1))
        < src..

#         will return 0 if the arguments to @c(+) are evaluated from left to right
#         but will return 1 if the arguments are evaluated from right to left.
        Devolverá 0 si los argumentos a @c(+) se evalúan de izquierda a derecha
        pero devolverá 1 si los argumentos se evalúan de derecha a izquierda.

# ** 3.2 <> The Environment Model of Evaluation
** 3.2 <> El Modelo Ambiental de Evaluación

#    When we introduced compound procedures in @l(#Chapter 1), we used the
#    substitution model of evaluation (section @l(#1.1.5)) to define what is meant by
#    applying a procedure to arguments:
   Cuando introdujimos los procedimientos compuestos en el
   @l(#Capitulo 1), utilizamos el modelo de sustitución de evaluación
   (seccion @l(#1.1.5)) para definir lo que se quiere decir aplicando un
   procedimiento a los argumentos:

#    - To apply a compound procedure to arguments, evaluate the body of the
#      procedure with each formal parameter replaced by the corresponding argument.
   - Para aplicar un procedimiento compuesto a los argumentos, evalúe el cuerpo
     del procedimiento con cada parámetro formal reemplazado por el argumento
     correspondiente.

#    Once we admit assignment into our programming language, such a definition is
#    no longer adequate. In particular, @l(#3.1.3) argued that, in the presence of
#    assignment, a variable can no longer be considered to be merely a name for a
#    value. Rather, a variable must somehow designate a @"(place) in which values
#    can be stored. In our new model of evaluation, these places will be maintained
#    in structures called @e(environments).
   Una vez que admitamos la asignación en nuestro lenguaje de programación, tal
   definición ya no es adecuada. En particular, @l(#3.1.3) argumentó que,
   en presencia de una asignación, una variable ya no puede considerarse
   simplemente un nombre para un valor. Más bien, una variable debe designar de
   alguna manera un @"(lugar) en el cual los valores pueden ser almacenados. En
   nuestro nuevo modelo de evaluación, estos lugares se mantendrán en
   estructuras denominadas @e(ambientes).

#    An environment is a sequence of @e(frames). Each frame is a table (possibly
#    empty) of @e(bindings), which associate variable names with their
#    corresponding values. (A single frame may contain at most one binding for any
#    variable.)  Each frame also has a pointer to its @e(enclosing environment),
#    unless, for the purposes of discussion, the frame is considered to be
#    @e(global). The @e(value of a variable) with respect to an environment is the
#    value given by the binding of the variable in the first frame in the
#    environment that contains a binding for that variable. If no frame in the
#    sequence specifies a binding for the variable, then the variable is said to be
#    @e(unbound) in the environment.
   Un entorno es una secuencia de @e(marcos). Cada trama es una tabla
   (posiblemente vacía) de @e(enlaces), que asocian los nombres de las variables
   con sus valores correspondientes. Cada trama también tiene un puntero a su
   @e(entorno adjunto), a menos que, a los efectos de la discusión, el marco se
   considere @e(global). El @e(valor de una variable) con respecto a un entorno
   es el valor dado por el enlace de la variable en el primer fotograma del
   entorno que contiene un enlace para esa variable. Si ninguna trama en la
   secuencia especifica un enlace para la variable, entonces se dice que la
   variable está @e(desvinculada) en el entorno.

#    @l(#Figure 3.1) shows a simple environment structure consisting of three
#    frames, labeled I, II, and III. In the diagram, A, B, C, and D are pointers to
#    environments. C and D point to the same environment. The variables @c(z) and
#    @c(x) are bound in frame II, while @c(y) and @c(x) are bound in frame I. The
#    value of @c(x) in environment D is 3. The value of @c(x) with respect to
#    environment B is also 3. This is determined as follows: We examine the first
#    frame in the sequence (frame III) and do not find a binding for @c(x), so we
#    proceed to the enclosing environment D and find the binding in frame I. On the
#    other hand, the value of @c(x) in environment A is 7, because the first frame
#    in the sequence (frame II) contains a binding of @c(x) to 7. With respect to
#    environment A, the binding of @c(x) to 7 in frame II is said to @e(shadow) the
#    binding of @c(x) to 3 in frame I.
   @l(#Figura 3.1) muestra una estructura de entorno simple que
   consta de tres marcos, etiquetados como I, II y III. En el diagrama, A, B, C
   y D son indicadores de entornos. C y D apuntan al mismo entorno. Las
   variables @c(z) y @c(x) están enlazadas en el marco II, mientras que @c(y) y
   @c(x) están unidas en el marco I. El valor de @c(x) en el entorno D es 3. El
   valor de @c(x) con respecto al entorno B es también 3. Esto se determina como
   sigue: Examinamos el primer cuadro en La secuencia (cuadro III) y no
   encuentran una unión para @c(x), así que procedemos al entorno envolvente D y
   encontramos la unión en el fotograma I. Por otro lado, el valor de @c(x) en
   el entorno A es 7, porque el primer fotograma en el Secuencia (cuadro II)
   contiene una unión de @c(x)7. Con respecto al entorno A,@c(x)@e()@c(x)

#    ..figure > @t(Figure 3.1) A simple environment structure.
   ..figure > @t(Figura 3.1) Una estructura de entorno simple.

#      ..art >
#                   ╭────────╮
#                   │      I │
#                   │ x: 3   │
#                   │ y: 5   │
#                   ╰────────╯
#                      ▲  ▲
#                      │  │
#                    C │  │ D
#        ╭─────────╮   │  │   ╭─────────╮
#        │      II │   │  │   │     III │
#        │ z: 6    ├───╯  ╰───┤ m: 1    │
#        │ x: 7    │          │ y: 2    │
#        ╰─────────╯          ╰─────────╯
#      < art..
     ..art >
                  ╭────────╮
                  │      I │
                  │ x: 3   │
                  │ y: 5   │
                  ╰────────╯
                     ▲  ▲
                     │  │
                   C │  │ D
       ╭─────────╮   │  │   ╭─────────╮
       │      II │   │  │   │     III │
       │ z: 6    ├───╯  ╰───┤ m: 1    │
       │ x: 7    │          │ y: 2    │
       ╰─────────╯          ╰─────────╯
     < art..

# @  ..img > img/chap3/Fig3.1b.std.svg
@  ..img > img/chap3/Fig3.1b.std.svg

#    The environment is crucial to the evaluation process, because it determines
#    the context in which an expression should be evaluated. Indeed, one could say
#    that expressions in a programming language do not, in themselves, have any
#    meaning.  Rather, an expression acquires a meaning only with respect to some
#    environment in which it is evaluated. Even the interpretation of an expression
#    as straightforward as @c[(+ 1 1)] depends on an understanding that one is
#    operating in a context in which @c(+) is the symbol for addition. Thus, in our
#    model of evaluation we will always speak of evaluating an expression with
#    respect to some environment. To describe interactions with the interpreter, we
#    will suppose that there is a global environment, consisting of a single frame
#    (with no enclosing environment) that includes values for the symbols
#    associated with the primitive procedures. For example, the idea that @c(+) is
#    the symbol for addition is captured by saying that the symbol @c(+) is bound
#    in the global environment to the primitive addition procedure.
   El entorno es crucial para el proceso de evaluación, ya que determina el
   contexto en el que debe evaluarse una expresión. De hecho, se podría decir
   que las expresiones en un lenguaje de programación no tienen, por sí mismas,
   ningún significado. Más bien, una expresión adquiere un significado sólo con
   respecto a algún entorno en el que se evalúa. Incluso la interpretación de
   una expresión tan directa como @c[(+ 1 1)] depende de la comprensión de que
   uno está operando en un contexto en el que @c(+) es el símbolo de la
   adición. Así, en nuestro modelo de evaluación siempre hablaremos de evaluar
   una expresión con respecto a algún entorno. Para describir las interacciones
   con el intérprete, se supondrá que existe un entorno global, Que consta de
   una sola trama (sin entorno de inclusión) que incluye valores para los
   símbolos asociados con los procedimientos primitivos. @c(+) Por ejemplo, la
   idea que es el símbolo de la adición se captura diciendo que el símbolo @c(+)
   está ligado en el entorno global al procedimiento de adición primitiva.

# *** 3.2.1 <> The Rules for Evaluation
*** 3.2.1 <> Las reglas para la evaluación

#     The overall specification of how the interpreter evaluates a combination
#     remains the same as when we first introduced it in section @l(#1.1.3):
    La especificación general de cómo el intérprete evalúa una combinación sigue
    siendo la misma que cuando la presentamos por primera vez en
    @l(#1.1.3) :

#     - To evaluate a combination:
    - Para evaluar una combinación:

#       1. Evaluate the subexpressions of the combination.@n(140)
      1. Evaluar las subexpresiones de la combinación.@n(140)

#       2. Apply the value of the operator subexpression to the values of the operand
#          subexpressions.
      2. Aplique el valor de la subexpresión de operador a los valores de las
         subexpresiones de operando.

#     The environment model of evaluation replaces the substitution model in
#     specifying what it means to apply a compound procedure to arguments.
    El modelo de evaluación ambiental reemplaza al modelo de sustitución al
    especificar lo que significa aplicar un procedimiento compuesto a los
    argumentos.

#     In the environment model of evaluation, a procedure is always a pair
#     consisting of some code and a pointer to an environment. Procedures are
#     created in one way only: by evaluating a λ-expression. This produces a
#     procedure whose code is obtained from the text of the λ-expression and whose
#     environment is the environment in which the λ-expression was evaluated to
#     produce the procedure. For example, consider the procedure definition
    En el modelo de evaluación ambiental, un procedimiento es siempre un par que
    consiste en algún código y un puntero a un entorno. Los procedimientos se
    crean de una sola manera: mediante la evaluación de una λ-expresión. Esto
    produce un procedimiento cuyo código se obtiene a partir del texto de la
    expresión λ y cuyo entorno es el entorno en el que se evaluó la expresión λ
    para producir el procedimiento. Por ejemplo, considere la definición del
    procedimiento

#     ..src > scheme
#       (define (square x)
#         (* x x))
#     < src..
    ..src > scheme
      (define (square x)
        (* x x))
    < src..

#     evaluated in the global environment. The procedure definition syntax is just
#     syntactic sugar for an underlying implicit λ-expression. It would have been
#     equivalent to have used
    Evaluados en el entorno global. La sintaxis de definición de procedimiento
    es simplemente azúcar sintáctico para una expresión λ implícita
    subyacente. Habría sido equivalente a haber utilizado

#     ..src > scheme
#       (define square
#         (lambda (x) (* x x)))
#     < src..
    ..src > scheme
      (define square
        (lambda (x) (* x x)))
    < src..

#     which evaluates @c[(lambda (x) (* x x))] and binds @c(square) to the resulting
#     value, all in the global environment.
    Que evalúa @c[(lambda (x) (* x x))] y enlaza @c(square) con el valor
    resultante, todo en el entorno global.

#     @l(#Figure 3.2) shows the result of evaluating this @c(define) expression.
#     The procedure object is a pair whose code specifies that the procedure has one
#     formal parameter, namely @c(x), and a procedure body @c[(* x x)]. The
#     environment part of the procedure is a pointer to the global environment,
#     since that is the environment in which the λ-expression was evaluated to
#     produce the procedure. A new binding, which associates the procedure object
#     with the symbol @c(square), has been added to the global frame. In general,
#     @c(define) creates definitions by adding bindings to frames.
    @l(#Figura 3.2) muestra el resultado de la evaluación de esta
    @c(define) expresión. El objeto de procedimiento es un par cuyo código
    especifica que el procedimiento tiene un parámetro formal, a saber @c(x), y
    un cuerpo de procedimiento @c[(* x x)]. La parte medioambiental del
    procedimiento es un indicador del entorno global, ya que es el entorno en el
    que se evaluó la expresión λ para producir el procedimiento. Se @c(square)
    ha agregado un nuevo enlace, que asocia el objeto de procedimiento con el
    símbolo, al marco global. En general, @c(define) crea definiciones agregando
    enlaces a marcos.

#     ..figure > @t(Figure 3.2) Environment structure produced by evaluating
#       @c[(define (square x) (* x x))] in the global environment.
    ..figure > @t(Figura 3.2) Estructura ambiental producida por la evaluación
      @c[(define (square x) (* x x))] en el entorno global.

#       ..art >
#                    ╭──────────────────────╮
#                    │ other variables      │
#         global ───▶│                      │
#         env        │ square: ──╮          │
#                    ╰───────────┼──────────╯
#                                │       ▲
#         (define (square x)     │       │
#           (* x x))             ▼       │
#                            .───.───.   │
#                            │ ◆ │ ◆ ┼───╯
#                            `─┼─^───'
#                              │
#                              ▼
#                            parameters: x
#                            body: (* x x)
#       < art..
      ..art >
                   ╭──────────────────────╮
                   │ other variables      │
        global ───▶│                      │
        env        │ square: ──╮          │
                   ╰───────────┼──────────╯
                               │       ▲
        (define (square x)     │       │
          (* x x))             ▼       │
                           .───.───.   │
                           │ ◆ │ ◆ ┼───╯
                           `─┼─^───'
                             │
                             ▼
                           parameters: x
                           body: (* x x)
      < art..

# @   ..img > img/chap3/Fig3.2b.std.svg
@   ..img > img/chap3/Fig3.2b.std.svg

#     Now that we have seen how procedures are created, we can describe how
#     procedures are applied. The environment model specifies: To apply a procedure
#     to arguments, create a new environment containing a frame that binds the
#     parameters to the values of the arguments. The enclosing environment of this
#     frame is the environment specified by the procedure. Now, within this new
#     environment, evaluate the procedure body.
    Ahora que hemos visto cómo se crean los procedimientos, podemos describir
    cómo se aplican los procedimientos. El modelo de entorno especifica: Para
    aplicar un procedimiento a argumentos, cree un nuevo entorno que contenga un
    marco que vincule los parámetros a los valores de los argumentos. El entorno
    de inclusión de este marco es el entorno especificado por el
    procedimiento. Ahora, dentro de este nuevo entorno, evalúe el cuerpo del
    procedimiento.

#     To show how this rule is followed, @l(#Figure 3.3) illustrates the environment
#     structure created by evaluating the expression @c[(square 5)] in the global
#     environment, where @c(square) is the procedure generated in @l(#Figure 3.2).
#     Applying the procedure results in the creation of a new environment, labeled
#     E1 in the figure, that begins with a frame in which @c(x), the formal
#     parameter for the procedure, is bound to the argument 5. The pointer leading
#     upward from this frame shows that the frame's enclosing environment is the
#     global environment. The global environment is chosen here, because this is the
#     environment that is indicated as part of the @c(square) procedure
#     object. Within E1, we evaluate the body of the procedure, @c[(* x x)].  Since
#     the value of @c(x) in E1 is 5, the result is @c[(* 5 5)], or 25.
    Para mostrar cómo se sigue esta regla, la @l(#Figura 3.3)
    ilustra la estructura del entorno creada al evaluar la expresión @c[(square
    5)] en el entorno global, donde @c(square) está el procedimiento generado en
    la @l(#Figura 3.2). La aplicación del procedimiento resulta en
    la creación de un nuevo entorno, etiquetado E1 en la figura, que comienza
    con un marco en el que @c(x), el parámetro formal para el procedimiento,
    está enlazado al argumento 5. El puntero que conduce hacia arriba desde este
    marco muestra que el El entorno que lo rodea es el entorno global. El
    entorno global se elige aquí, porque este es el entorno que se indica como
    parte del @c(square) objeto de procedimiento. Dentro de E1, evaluamos el
    cuerpo del procedimiento, @c[(* x x)]. Puesto que el valor de @c(x) en E1 es
    5,@c[(* 5 5)]

#     ..figure > @t(Figure 3.3) Environment created by evaluating @c[(square 5)]
#       in the global environment.
    ..figure > @t(Figura 3.3) Entorno creado por la evaluación @c[(square 5)] en
      el entorno global.

#       ..art >
#                    ╭─────────────────────────────────────────╮
#                    │ other variables                         │
#         global ───▶│                                         │
#         env        │ square: ──╮                             │
#                    ╰───────────┼─────────────────────────────╯
#                                │       ▲              ▲
#         (square 5)             │       │              │
#                                ▼       │              │
#                            .───.───.   │           ╭──┴────╮
#                            │ ◆ │ ◆ ┼───╯   E1 ────▶│ x: 5  │
#                            `─┼─^───'               ╰───────╯
#                              │
#                              ▼
#                           parameters: x
#                           body: (* x x)
#       < art..
      ..art >
                   ╭─────────────────────────────────────────╮
                   │ other variables                         │
        global ───▶│                                         │
        env        │ square: ──╮                             │
                   ╰───────────┼─────────────────────────────╯
                               │       ▲              ▲
        (square 5)             │       │              │
                               ▼       │              │
                           .───.───.   │           ╭──┴────╮
                           │ ◆ │ ◆ ┼───╯   E1 ────▶│ x: 5  │
                           `─┼─^───'               ╰───────╯
                             │
                             ▼
                          parameters: x
                          body: (* x x)
      < art..

# @   ..img > img/chap3/Fig3.3b.std.svg
@   ..img > img/chap3/Fig3.3b.std.svg

#     The environment model of procedure application can be summarized by two rules:
    El modelo de ambiente de aplicación de procedimiento se puede resumir por
    dos reglas:

#     - A procedure object is applied to a set of arguments by constructing a frame,
#       binding the formal parameters of the procedure to the arguments of the call,
#       and then evaluating the body of the procedure in the context of the new
#       environment constructed. The new frame has as its enclosing environment the
#       environment part of the procedure object being applied.
    - Un objeto de procedimiento se aplica a un conjunto de argumentos mediante
      la construcción de un marco, vinculando los parámetros formales del
      procedimiento a los argumentos de la llamada, y luego evaluar el cuerpo
      del procedimiento en el contexto del nuevo entorno construido. La nueva
      trama tiene como entorno envolvente la parte de entorno del objeto de
      procedimiento que se está aplicando.

#     - A procedure is created by evaluating a λ-expression relative to a given
#       environment. The resulting procedure object is a pair consisting of the text
#       of the λ-expression and a pointer to the environment in which the procedure
#       was created.
    - Se crea un procedimiento evaluando una expresión λ relativa a un entorno
      dado. El objeto de procedimiento resultante es un par que consiste en el
      texto de la expresión λ y un puntero al entorno en el que se creó el
      procedimiento.


#     We also specify that defining a symbol using @c(define) creates a binding in
#     the current environment frame and assigns to the symbol the indicated
#     value.@n(141) Finally, we specify the behavior of @c(set!), the operation that
#     forced us to introduce the environment model in the first place. Evaluating
#     the expression @c[(set! ⟨variable⟩ ⟨value⟩)] in some environment locates the
#     binding of the variable in the environment and changes that binding to
#     indicate the new value. That is, one finds the first frame in the environment
#     that contains a binding for the variable and modifies that frame. If the
#     variable is unbound in the environment, then @c(set!) signals an error.
    También especificamos que la definición de un símbolo usando @c(define) crea
    un enlace en el marco de entorno actual y asigna al símbolo el valor
    indicado.@n(141) Finalmente, especificamos el comportamiento de
    @c(set!), la operación que nos obligó a introducir el modelo de entorno en
    primer lugar. La evaluación de la expresión @c[(set! ⟨variable⟩ ⟨value⟩)] en
    algún entorno localiza el enlace de la variable en el entorno y cambia la
    vinculación para indicar el nuevo valor. Es decir, uno encuentra la primera
    trama en el entorno que contiene un enlace para la variable y modifica ese
    marco. Si la variable está desvinculada en el entorno, entonces @c(set!)
    señala un error.

#     These evaluation rules, though considerably more complex than the substitution
#     model, are still reasonably straightforward. Moreover, the evaluation model,
#     though abstract, provides a correct description of how the interpreter
#     evaluates expressions. In @l(#Chapter 4) we shall see how this model can serve
#     as a blueprint for implementing a working interpreter. The following sections
#     elaborate the details of the model by analyzing some illustrative programs.
    Estas reglas de evaluación, aunque considerablemente más complejas que el
    modelo de sustitución, siguen siendo razonablemente sencillas. Además, el
    modelo de evaluación, aunque abstracto, proporciona una descripción correcta
    de cómo el intérprete evalúa las expresiones. En el
    @l(Capitulo 4) veremos cómo este modelo puede servir como plan
    para implementar un intérprete de trabajo. Las siguientes secciones elaboran
    los detalles del modelo analizando algunos programas ilustrativos.

# *** 3.2.2 <> Applying Simple Procedures
*** 3.2.2 <> Aplicación de procedimientos simples

#     When we introduced the substitution model in section @l(#1.1.5) we showed how the
#     combination @c[(f 5)] evaluates to 136, given the following procedure
#     definitions:
    Cuando introdujimos el modelo de sustitución en la seccion @l(#1.1.5) mostramos
    cómo la combinación se @c[(f 5)] evalúa a 136, dadas las siguientes
    definiciones de procedimiento:

#     ..src > scheme
#       (define (square x)
#         (* x x))
#       (define (sum-of-squares x y)
#         (+ (square x) (square y)))
#       (define (f a)
#         (sum-of-squares (+ a 1) (* a 2)))
#     < src..
    ..src > scheme
      (define (square x)
        (* x x))
      (define (sum-of-squares x y)
        (+ (square x) (square y)))
      (define (f a)
        (sum-of-squares (+ a 1) (* a 2)))
    < src..

#     We can analyze the same example using the environment model. @l(#Figure 3.4)
#     shows the three procedure objects created by evaluating the definitions of
#     @c(f), @c(square), and @c(sum-of-squares) in the global environment.  Each
#     procedure object consists of some code, together with a pointer to the global
#     environment.
    Podemos analizar el mismo ejemplo usando el modelo de
    entorno. @l(#Figura 3.4) muestra los tres objetos procedimiento
    creados mediante la evaluación de las definiciones de @c(f), @c(square) y
    @c(sum-of-squares) en el medio ambiente global. Cada objeto de procedimiento
    consta de algún código, junto con un puntero al entorno global.

#     ..figure > @t(Figure 3.4) Procedure objects in the global frame.
    ..figure > @t(Figura 3.4) Objetos de procedimiento en el marco global.

#       ..art >
#                ╭───────────────────────────────────────────────╮
#         global │ sum-of-squares: ──────────────────────╮       │
#         env    │ square: ───────────────╮              │       │
#            ───▶│ f: ─────╮              │              │       │
#                ╰─────────┼──────────────┼──────────────┼───────╯
#                          │     ▲        │     ▲        │     ▲
#                          │     │        │     │        │     │
#                          ▼     │        ▼     │        ▼     │
#                      .───.───. │    .───.───. │    .───.───. │
#                      │ ◆ │ ◆ ┼─╯    │ ◆ │ ◆ ┼─╯    │ ◆ │ ◆ ┼─╯
#                      `─┼─^───'      `─┼─^───'      `─┼─^───'
#                        │              │              │
#                        ▼              ▼              ▼
#          parameters: a            parameters: x    parameters: x, y
#          body: (sum-of-squares    body: (* x x)    body: (+ (square x)
#                  (+ a 1)                                    (square y))
#                  (* a 2))
#       < art..
      ..art >
               ╭───────────────────────────────────────────────╮
        global │ sum-of-squares: ──────────────────────╮       │
        env    │ square: ───────────────╮              │       │
           ───▶│ f: ─────╮              │              │       │
               ╰─────────┼──────────────┼──────────────┼───────╯
                         │     ▲        │     ▲        │     ▲
                         │     │        │     │        │     │
                         ▼     │        ▼     │        ▼     │
                     .───.───. │    .───.───. │    .───.───. │
                     │ ◆ │ ◆ ┼─╯    │ ◆ │ ◆ ┼─╯    │ ◆ │ ◆ ┼─╯
                     `─┼─^───'      `─┼─^───'      `─┼─^───'
                       │              │              │
                       ▼              ▼              ▼
         parameters: a            parameters: x    parameters: x, y
         body: (sum-of-squares    body: (* x x)    body: (+ (square x)
                 (+ a 1)                                    (square y))
                 (* a 2))
      < art..

# @     ..img > img/chap3/Fig3.4b.std.svg
@     ..img > img/chap3/Fig3.4b.std.svg

#     In @l(#Figure 3.5) we see the environment structure created by evaluating the
#     expression @c[(f 5)]. The call to @c(f) creates a new environment E1 beginning
#     with a frame in which @c(a), the formal parameter of @c(f), is bound to the
#     argument 5. In E1, we evaluate the body of @c(f):
    En la @l(#Figura 3.5) vemos la estructura del entorno creada al
    evaluar la expresión @c[(f 5)]. La llamada a @c(f) crea un nuevo entorno E1
    comenzando con un marco en el cual @c(a), el parámetro formal de @c(f), está
    enlazado al argumento 5. En E1, evaluamos el cuerpo de @c(f):

#     ..src > scheme
#       (sum-of-squares (+ a 1) (* a 2))
#     < src..
    ..src > scheme
      (sum-of-squares (+ a 1) (* a 2))
    < src..

#     ..figure > @t(Figure 3.5) Environments created by evaluating @c[(f 5)] using
#       the procedures in @l(#Figure 3.4).
    ..figure > @t(Figura 3.5) Ambientes creados mediante la evaluación @c[(f 5)]
      utilizando los procedimientos de la @l(#Figura 3.4).

#       ..art >
#                   ╭─────────────────────────────────────────────────────╮
#         global ──▶│                                                     │
#         env       ╰─────────────────────────────────────────────────────╯
#                     ▲              ▲                ▲               ▲
#         (f 5)       |              |                |               |
#                 ╭──────╮       ╭───────╮        ╭──────╮        ╭───────╮
#           E1 ──▶│ a: 5 │  E2 ─▶│ x: 6  │  E3 ──▶│ x: 6 │  E4 ──▶│ x: 10 │
#                 │      │       │ y: 10 │        │      │        │       │
#                 ╰──────╯       ╰───────╯        ╰──────╯        ╰───────╯
#            (sum-of-squares   (+ (square x)       (* x x)         (* x x)
#              (+ a 1)            (square u))
#              (+ a 2))
#       < art..
      ..art >
                  ╭─────────────────────────────────────────────────────╮
        global ──▶│                                                     │
        env       ╰─────────────────────────────────────────────────────╯
                    ▲              ▲                ▲               ▲
        (f 5)       |              |                |               |
                ╭──────╮       ╭───────╮        ╭──────╮        ╭───────╮
          E1 ──▶│ a: 5 │  E2 ─▶│ x: 6  │  E3 ──▶│ x: 6 │  E4 ──▶│ x: 10 │
                │      │       │ y: 10 │        │      │        │       │
                ╰──────╯       ╰───────╯        ╰──────╯        ╰───────╯
           (sum-of-squares   (+ (square x)       (* x x)         (* x x)
             (+ a 1)            (square u))
             (+ a 2))
      < art..

# @     ..img > img/chap3/Fig3.5b.std.svg
@     ..img > img/chap3/Fig3.5b.std.svg

#     To evaluate this combination, we first evaluate the subexpressions. The first
#     subexpression, @c(sum-of-squares), has a value that is a procedure object.
#     (Notice how this value is found: We first look in the first frame of E1, which
#     contains no binding for @c(sum-of-squares). Then we proceed to the enclosing
#     environment, i.e. the global environment, and find the binding shown in
#     @l(#Figure 3.4).)  The other two subexpressions are evaluated by applying the
#     primitive operations @c(+) and @c(*) to evaluate the two combinations @c[(+ a
#     1)] and @c[(* a 2)] to obtain 6 and 10, respectively.
    Para evaluar esta combinación, primero evaluar las subexpresiones. La
    primera subexpresión,, @c(sum-of-squares) tiene un valor que es un objeto de
    procedimiento. (Observe cómo se encuentra este valor: Primero miramos en el
    primer fotograma de E1, que no contiene ninguna vinculación para
    @c(sum-of-squares) Entonces procedemos al entorno que lo rodea, es decir, al
    entorno global, y encontramos el enlace mostrado en la
    @l(#Figura 3.4) .) Los otros dos Las subexpresiones se evalúan
    aplicando las operaciones primitivas @c(+) y @c(*) para evaluar las dos
    combinaciones @c[(+ a 1)] y @c[(* a 2)] obtener 6 y 10, respectivamente.

#     Now we apply the procedure object @c(sum-of-squares) to the arguments 6 and
#     10. This results in a new environment E2 in which the formal parameters
#     @c(x) and @c(y) are bound to the arguments. Within E2 we evaluate the
#     combination @c[(+ (square x) (square y))]. This leads us to evaluate
#     @c[(square x)], where @c(square) is found in the global frame and @c(x)
#     is 6. Once again, we set up a new environment, E3, in which @c(x) is bound to
#     6, and within this we evaluate the body of @c(square), which is @c[(* x
#     x)]. Also as part of applying @c(sum-of-squares), we must evaluate the
#     subexpression @c[(square y)], where @c(y) is 10. This second call to
#     @c(square) creates another environment, E4, in which @c(x), the formal
#     parameter of @c(square), is bound to 10. And within E4 we must evaluate @c[(*
#     x x)].
    Ahora aplicamos el objeto de procedimiento @c(sum-of-squares) a los
    argumentos 6 y 10. Esto resulta en un nuevo entorno E2 en el que los
    parámetros formales @c(x) y @c(y) están vinculados a los argumentos. Dentro
    de E2 evaluamos la combinación @c[(+ (square x) (square y))]. Esto nos lleva
    a evaluar @c[(square x)], donde @c(square) se encuentra en el marco global y
    @c(x) es 6. Una vez más, establecemos un nuevo entorno, E3, en el que @c(x)
    está vinculado a 6, y dentro de esto evaluamos el cuerpo de @c(square), que
    es @c[(* x x)]. También como parte de la aplicación @c(sum-of-squares),
    debemos evaluar la subexpresión @c[(square y)], donde @c(y) es 10. Esta
    segunda llamada a @c(square) crea otro entorno, E4, en el que @c(x), el
    parámetro formal de @c(square), está enlazado a 10. Y dentro de E4 debemos
    evaluar @c[(* x x)].

#     The important point to observe is that each call to @c(square) creates a new
#     environment containing a binding for @c(x). We can see here how the different
#     frames serve to keep separate the different local variables all named
#     @c(x). Notice that each frame created by @c(square) points to the global
#     environment, since this is the environment indicated by the @c(square)
#     procedure object.
    El punto importante a observar es que cada llamada a @c(square) crea un
    nuevo ambiente que contiene un enlace para @c(x). Podemos ver aquí cómo los
    distintos marcos sirven para mantener separadas las diferentes variables
    locales nombradas @c(x). Observe que cada trama creada por @c(square) puntos
    al entorno global, ya que este es el entorno indicado por el @c(square)
    objeto de procedimiento.

#     After the subexpressions are evaluated, the results are returned. The values
#     generated by the two calls to @c(square) are added by @c(sum-of-squares), and
#     this result is returned by @c(f). Since our focus here is on the environment
#     structures, we will not dwell on how these returned values are passed from
#     call to call; however, this is also an important aspect of the evaluation
#     process, and we will return to it in detail in @l(#Chapter 5).
    Después de evaluar las subexpresiones, se devuelven los resultados. Los
    valores generados por las dos llamadas a @c(square) son agregados por
    @c(sum-of-squares), y este resultado es devuelto por @c(f). Dado que nuestro
    enfoque aquí es sobre las estructuras de medio ambiente, no vamos a
    detenernos en cómo estos valores devueltos se pasan de llamada a llamada;
    Sin embargo, éste es también un aspecto importante del proceso de
    evaluación, y volveremos a detallarlo en el @l(Capitulo 5).

#     :: @t(Exercise 3.9) :: in section @l(#1.2.1) we used the substitution model to analyze
#        two procedures for computing factorials, a recursive version
    :: @t(Ejercicio 3.9) :: en la seccion @l(#1.2.1) se utilizó el modelo de
       sustitución para analizar dos procedimientos para calcular factorials,
       una versión recursiva

#        ..src > scheme
#          (define (factorial n)
#            (if (= n 1)
#                1
#                (* n (factorial (- n 1)))))
#        < src..
       ..src > scheme
         (define (factorial n)
           (if (= n 1)
               1
               (* n (factorial (- n 1)))))
       < src..

#        and an iterative version
       Y una versión iterativa

#        ..src > scheme
#          (define (factorial n)
#            (fact-iter 1 1 n))
#
#          (define (fact-iter product
#                             counter
#                             max-count)
#            (if (> counter max-count)
#                product
#                (fact-iter (* counter product)
#                           (+ counter 1)
#                           max-count)))
#        < src..
       ..src > scheme
         (define (factorial n)
           (fact-iter 1 1 n))

         (define (fact-iter product
                            counter
                            max-count)
           (if (> counter max-count)
               product
               (fact-iter (* counter product)
                          (+ counter 1)
                          max-count)))
       < src..

#        Show the environment structures created by evaluating @c[(factorial 6)]
#        using each version of the @c(factorial) procedure.@n(142)
       Muestre las estructuras de entorno creadas al evaluar @c[(factorial 6)]
       cada versión del procedimiento @c(factorial).@n(142)

# *** 3.2.3 <> Frames as the Repository of Local State
*** 3.2.3 <> Marcos como el Repositorio del Estado Local

#     We can turn to the environment model to see how procedures and assignment can
#     be used to represent objects with local state. As an example, consider the
#     @"(withdrawal processor) from @l(#3.1.1) created by calling the procedure
    Podemos recurrir al modelo de entorno para ver cómo se pueden utilizar
    procedimientos y asignaciones para representar objetos con estado local. A
    modo de ejemplo, considere el @"(procesador de retiro) de la seccion @l(#3.1.1)
    creado al llamar al procedimiento

#     ..src > scheme
#       (define (make-withdraw balance)
#         (lambda (amount)
#           (if (>= balance amount)
#               (begin (set! balance
#                            (- balance amount))
#                      balance)
#               "Insufficient funds")))
#     < src..
    ..src > scheme
      (define (make-withdraw balance)
        (lambda (amount)
          (if (>= balance amount)
              (begin (set! balance
                           (- balance amount))
                     balance)
              "Insufficient funds")))
    < src..

#     Let us describe the evaluation of
    Describamos la evaluación de

#     ..src > scheme
#       (define W1 (make-withdraw 100))
#     < src..
    ..src > scheme
      (define W1 (make-withdraw 100))
    < src..

#     followed by
    seguido por

#     ..srci > scheme
#       > (W1 50)
#       50
#     < srci..
    ..srci > scheme
      > (W1 50)
      50
    < srci..

#     @l(#Figure 3.6) shows the result of defining the @c(make-withdraw) procedure
#     in the global environment. This produces a procedure object that contains a
#     pointer to the global environment. So far, this is no different from the
#     examples we have already seen, except that the body of the procedure is itself
#     a λ-expression.
    @l(#Figura 3.6) muestra el resultado de la definición del
    procedimiento @c(make-withdraw) en el entorno global. Esto produce un objeto
    de procedimiento que contiene un puntero al entorno global. Hasta ahora,
    esto no es diferente de los ejemplos que ya hemos visto, excepto que el
    cuerpo del procedimiento es en sí una expresión λ.

#     ..figure > @t(Figure 3.6) Result of defining @c(make-withdraw) in the global
#       environment.
    ..figure > @t(Figura 3.6) Resultado de la definición @c(make-withdraw) en el
      entorno global.

#       ..art >
#                    ╭─────────────────────────────╮
#         global ───▶│ make-withdraw:   ──╮        │
#         env        ╰────────────────────┼────────╯
#                                         │     ▲
#                                         │     │
#                                         ▼     │
#                                     .───.───. │
#                                     │ ◆ │ ◆ ┼─╯
#                                     `─┼─^───'
#                                       │
#             parameters: balance       ▼
#             body: (lambda (amount)
#                     (if (>= balance amount)
#                         (begin (set! balance
#                                      (- balance amount))
#                                balance)
#                         "Insufficient funds"))
#       < art..
      ..art >
                   ╭─────────────────────────────╮
        global ───▶│ make-withdraw:   ──╮        │
        env        ╰────────────────────┼────────╯
                                        │     ▲
                                        │     │
                                        ▼     │
                                    .───.───. │
                                    │ ◆ │ ◆ ┼─╯
                                    `─┼─^───'
                                      │
            parameters: balance       ▼
            body: (lambda (amount)
                    (if (>= balance amount)
                        (begin (set! balance
                                     (- balance amount))
                               balance)
                        "Insufficient funds"))
      < art..

# @   ..img > img/chap3/Fig3.6c.std.svg
@   ..img > img/chap3/Fig3.6c.std.svg

#     The interesting part of the computation happens when we apply the procedure
#     @c(make-withdraw) to an argument:
    La parte interesante del cálculo ocurre cuando aplicamos el procedimiento
    @c(make-withdraw) a un argumento:

#     ..src > scheme
#       (define W1 (make-withdraw 100))
#     < src..
    ..src > scheme
      (define W1 (make-withdraw 100))
    < src..

#     We begin, as usual, by setting up an environment E1 in which the formal
#     parameter @c(balance) is bound to the argument 100. Within this environment,
#     we evaluate the body of @c(make-withdraw), namely the λ-expression. This
#     constructs a new procedure object, whose code is as specified by the
#     @c(lambda) and whose environment is E1, the environment in which the
#     @c(lambda) was evaluated to produce the procedure.  The resulting procedure
#     object is the value returned by the call to @c(make-withdraw). This is bound
#     to @c(W1) in the global environment, since the @c(define) itself is being
#     evaluated in the global environment.  @l(#Figure 3.7) shows the resulting
#     environment structure.
    Comenzamos, como de costumbre, mediante la creación de un entorno E1 en el
    que el parámetro formal @c(balance) está vinculado al argumento 100. En este
    entorno, evaluamos el cuerpo de @c(make-withdraw), es decir, la expresión
    λ. Esto construye un nuevo objeto de procedimiento, cuyo código es el
    especificado por el @c(lambda) entorno E1, cuyo entorno es el que @c(lambda)
    se evaluó para producir el procedimiento. El objeto de procedimiento
    resultante es el valor devuelto por la llamada a @c(make-withdraw). Esto
    está vinculado @c(W1) en el entorno global, ya que el @c(define) mismo está
    siendo evaluado en el entorno global.  @l(#Figura 3.7)
    muestra la estructura del entorno resultante.

#     ..figure > @t(Figure 3.7) Result of evaluating @c[(define W1 (make-withdraw 100))].
    ..figure > @t(Figura 3.7) Resultado de la evaluación @c[(define W1
      (make-withdraw 100))].

#       ..art >
#                ╭────────────────────────────────────────────────╮
#         global │ make-withdraw: ─────────────────────────────╮  │
#         env    │                                             │  │
#            ───▶│ W1: ─╮                                      │  │
#                ╰──────┼──────────────────────────────────────┼──╯
#                       │                 ▲                    │
#                       │                 |                    │
#                       │          ╭──────────────╮  .───.───. │
#                       │    E1 ──▶│ balance: 100 │  │ ◆ │ ◆ ┼─╯
#                       │          ╰──────────────╯  `─┼─^───'
#                       ▼                 │            │
#                   .───.───.             │            ▼
#                   │ ◆ │ ◆ ┼─────────────╯     parameters: balance
#                   `─┼─^───'                   body: ...
#                     │
#                     ▼
#             parameters: amount
#             body: (if (>= balance amount)
#                       (begin (set! balance (- balance amount))
#                              balance)
#                       "Insufficient funds")
#       < art..
      ..art >
               ╭────────────────────────────────────────────────╮
        global │ make-withdraw: ─────────────────────────────╮  │
        env    │                                             │  │
           ───▶│ W1: ─╮                                      │  │
               ╰──────┼──────────────────────────────────────┼──╯
                      │                 ▲                    │
                      │                 |                    │
                      │          ╭──────────────╮  .───.───. │
                      │    E1 ──▶│ balance: 100 │  │ ◆ │ ◆ ┼─╯
                      │          ╰──────────────╯  `─┼─^───'
                      ▼                 │            │
                  .───.───.             │            ▼
                  │ ◆ │ ◆ ┼─────────────╯     parameters: balance
                  `─┼─^───'                   body: ...
                    │
                    ▼
            parameters: amount
            body: (if (>= balance amount)
                      (begin (set! balance (- balance amount))
                             balance)
                      "Insufficient funds")
      < art..

# @     ..img > img/chap3/Fig3.7b.std.svg
@     ..img > img/chap3/Fig3.7b.std.svg

#     Now we can analyze what happens when @c(W1) is applied to an argument:
    Ahora podemos analizar lo que sucede cuando @c(W1) se aplica a un argumento:

#     ..srci > scheme
#       > (W1 50)
#       50
#     < srci..
    ..srci > scheme
      > (W1 50)
      50
    < srci..

#     We begin by constructing a frame in which @c(amount), the formal parameter of
#     @c(W1), is bound to the argument 50. The crucial point to observe is that this
#     frame has as its enclosing environment not the global environment, but rather
#     the environment E1, because this is the environment that is specified by the
#     @c(W1) procedure object. Within this new environment, we evaluate the body of
#     the procedure:
    Comenzamos construyendo un marco en el que @c(amount) el parámetro formal de
    @c(W1), está ligado al argumento 50. El punto crucial a observar es que este
    marco tiene como entorno no el entorno global, sino el entorno E1, porque
    éste es el Entorno especificado por el @c(W1) objeto de
    procedimiento. Dentro de este nuevo entorno, evaluamos el cuerpo del
    procedimiento:

#     ..src > scheme
#       (if (>= balance amount)
#           (begin (set! balance (- balance amount))
#                  balance)
#           "Insufficient funds")
#     < src..
    ..src > scheme
      (if (>= balance amount)
          (begin (set! balance (- balance amount))
                 balance)
          "Insufficient funds")
    < src..

#     The resulting environment structure is shown in @l(#Figure 3.8). The
#     expression being evaluated references both @c(amount) and @c(balance).
#     @c(Amount) will be found in the first frame in the environment, while
#     @c(balance) will be found by following the enclosing-environment pointer to
#     E1.
    La estructura del entorno resultante se muestra en la @l(#Figura
    3.8). La expresión se evalúa referencias tanto @c(amount) y
    @c(balance). @c(Amount) Se encontrarán en el primer fotograma del entorno,
    mientras @c(balance) que se encontrarán siguiendo el puntero del entorno
    circundante a E1.

#     ..figure > @t(Figure 3.8) Environments created by applying the procedure object @c(W1).
    ..figure > @t(Figura 3.8) Ambientes creados mediante la aplicación del
      objeto de procedimiento @c(W1).

#       ..art >
#                ╭──────────────────────────────────────╮
#         global │ make-withdraw: ...                   │
#         env    │                                      │
#            ───▶│ W1: ─╮                               │
#                ╰──────┼───────────────────────────────╯
#                       │                 ▲
#                       │                 |
#                       │          ╭──────────────╮ Here is the balance
#                       │    E1 ──▶│ balance: 100 │ that will be changed
#                       │          ╰──────────────╯ by the set!.
#                       ▼             │       ▲
#                   .───.───.         │       |
#                   │ ◆ │ ◆ ┼─────────╯    ╭────────────╮
#                   `─┼─^───'              │ amount: 50 │
#                     │                    ╰────────────╯
#                     ▼
#               parameters: amount   (if (>= balance amount)
#               body: ...                (begin (set! balance
#                                                     (- balance amount))
#                                               balance)
#                                        "Insufficient funds")
#       < art..
      ..art >
               ╭──────────────────────────────────────╮
        global │ make-withdraw: ...                   │
        env    │                                      │
           ───▶│ W1: ─╮                               │
               ╰──────┼───────────────────────────────╯
                      │                 ▲
                      │                 |
                      │          ╭──────────────╮ Here is the balance
                      │    E1 ──▶│ balance: 100 │ that will be changed
                      │          ╰──────────────╯ by the set!.
                      ▼             │       ▲
                  .───.───.         │       |
                  │ ◆ │ ◆ ┼─────────╯    ╭────────────╮
                  `─┼─^───'              │ amount: 50 │
                    │                    ╰────────────╯
                    ▼
              parameters: amount   (if (>= balance amount)
              body: ...                (begin (set! balance
                                                    (- balance amount))
                                              balance)
                                       "Insufficient funds")
      < art..

# @     ..img > img/chap3/Fig3.8c.std.svg
@     ..img > img/chap3/Fig3.8c.std.svg

#     When the @c(set!) is executed, the binding of @c(balance) in E1 is changed. At
#     the completion of the call to @c(W1), @c(balance) is 50, and the frame that
#     contains @c(balance) is still pointed to by the procedure object @c(W1). The
#     frame that binds @c(amount) (in which we executed the code that changed
#     @c(balance)) is no longer relevant, since the procedure call that constructed
#     it has terminated, and there are no pointers to that frame from other parts of
#     the environment. The next time @c(W1) is called, this will build a new frame
#     that binds @c(amount) and whose enclosing environment is E1. We see that E1
#     serves as the @"(place) that holds the local state variable for the procedure
#     object @c(W1). @l(#Figure 3.9) shows the situation after the call to @c(W1).
    Cuando @c(set!) se ejecuta, @c(balance) se cambia la unión de en E1. Al
    finalizar la llamada a @c(W1), @c(balance) es 50, y el marco que contiene
    @c(balance) sigue siendo señalado por el objeto de procedimiento @c(W1). El
    marco que enlaza @c(amount)(en el que ejecutamos el código que ha cambiado
    @c(balance)) ya no es relevante, ya que la llamada de procedimiento que lo
    construyó ha terminado, y no hay punteros a ese marco de otras partes del
    entorno. La próxima vez que @c(W1) se llame, esto construirá un nuevo marco
    que se une @c(amount) y cuyo entorno que lo rodea es E1. Vemos que E1 sirve
    como el @"(lugar) que contiene la variable de estado local para el objeto de
    procedimiento @c(W1). @l(#Figura 3.9) muestra la situación
    después de la llamada a @c(W1).

#     ..figure > @t(Figure 3.9) Environments after the call to @c(W1).
    ..figure > @t(Figura 3.9) Entornos después de la llamada a @c(W1).

#       ..art >
#                ╭──────────────────────────────────────╮
#         global │ make-withdraw: ...                   │
#         env    │                                      │
#            ───▶│ W1: ─────╮                           │
#                ╰──────────┼───────────────────────────╯
#                           │                 ▲
#                           │                 |
#                           │          ╭─────────────╮
#                           │    E1 ──▶│ balance: 50 │
#                           │          ╰─────────────╯
#                           ▼                 │
#                       .───.───.             │
#                       │ ◆ │ ◆ ┼─────────────╯
#                       `─┼─^───'
#                         │
#                         ▼
#                   parameters: amount
#                   body: ...
#       < art..
      ..art >
               ╭──────────────────────────────────────╮
        global │ make-withdraw: ...                   │
        env    │                                      │
           ───▶│ W1: ─────╮                           │
               ╰──────────┼───────────────────────────╯
                          │                 ▲
                          │                 |
                          │          ╭─────────────╮
                          │    E1 ──▶│ balance: 50 │
                          │          ╰─────────────╯
                          ▼                 │
                      .───.───.             │
                      │ ◆ │ ◆ ┼─────────────╯
                      `─┼─^───'
                        │
                        ▼
                  parameters: amount
                  body: ...
      < art..

# @     ..img > img/chap3/Fig3.9b.std.svg
@     ..img > img/chap3/Fig3.9b.std.svg

#     Observe what happens when we create a second @"(withdraw) object by making
#     another call to @c(make-withdraw):
    Observe lo que sucede cuando creamos un segundo objeto de @"(retirada)
    haciendo otra llamada a @c(make-withdraw):

#     ..src > scheme
#       (define W2 (make-withdraw 100))
#     < src..
    ..src > scheme
      (define W2 (make-withdraw 100))
    < src..

#     This produces the environment structure of @l(#Figure 3.10), which shows that
#     @c(W2) is a procedure object, that is, a pair with some code and an
#     environment. The environment E2 for @c(W2) was created by the call to
#     @c(make-withdraw). It contains a frame with its own local binding for
#     @c(balance). On the other hand, @c(W1) and @c(W2) have the same code: the code
#     specified by the λ-expression in the body of @c(make-withdraw).@n(143) We see
#     here why @c(W1) and @c(W2) behave as independent objects. Calls to @c(W1)
#     reference the state variable @c(balance) stored in E1, whereas calls to @c(W2)
#     reference the @c(balance) stored in E2. Thus, changes to the local state of
#     one object do not affect the other object.
    Esto produce la estructura de entorno de la @l(#Figura 3.10),
    que muestra que @c(W2) es un objeto de procedimiento, es decir, un par con
    algún código y un entorno. El entorno E2 para @c(W2) fue creado por la
    llamada a @c(make-withdraw). Contiene un marco con su propia vinculación
    local para @c(balance). Por otro lado, @c(W1) y @c(W2) tienen el mismo
    código: el código especificado por la λ-expresión en el cuerpo de
    @c(make-withdraw).@n(143) Vemos aquí por qué @c(W1) y se @c(W2)
    comportan como objetos independientes. Llamadas para @c(W1) referenciar la
    variable de estado @c(balance) almacenada en E1, mientras que las llamadas
    para @c(W2) referenciar la @c(balance) almacenada en E2. Por lo tanto, los
    cambios en el estado local de un objeto no afectan al otro objeto.

#     ..figure > @t(Figure 3.10) Using @c[(define W2 (make-withdraw 100))] to create
#       a second object.
    ..figure > @t(Figura 3.10) Utilización @c[(define W2 (make-withdraw 100))]
      para crear un segundo objeto.

#       ..art >
#                  ╭─────────────────────────────────────────────────╮
#                  │ make-withdraw: ...                              │
#         global ─▶│ W2: ───────────────────────────╮                │
#         env      │ W1:  ─╮                        │                │
#                  ╰───────┼────────────────────────┼────────────────╯
#                          │              ▲         │              ▲
#                          │              |         │              |
#                          │       ╭─────────────╮  │       ╭──────────────╮
#                          │  E1 ─▶│ balance: 50 │  │  E2 ─▶│ balance: 100 │
#                          │       ╰─────────────╯  │       ╰──────────────╯
#                          ▼              ▲         ▼              ▲
#                      .───.───.          │     .───.───.          │
#                      │ ◆ │ ◆ ┼──────────╯     │ ◆ │ ◆ ┼──────────╯
#                      `─┼─^───'                `─┼─^───'
#                        │ ╭──────────────────────╯
#                        ▼ ▼
#                 parameters: amount
#                 body: ...
#       < art..
      ..art >
                 ╭─────────────────────────────────────────────────╮
                 │ make-withdraw: ...                              │
        global ─▶│ W2: ───────────────────────────╮                │
        env      │ W1:  ─╮                        │                │
                 ╰───────┼────────────────────────┼────────────────╯
                         │              ▲         │              ▲
                         │              |         │              |
                         │       ╭─────────────╮  │       ╭──────────────╮
                         │  E1 ─▶│ balance: 50 │  │  E2 ─▶│ balance: 100 │
                         │       ╰─────────────╯  │       ╰──────────────╯
                         ▼              ▲         ▼              ▲
                     .───.───.          │     .───.───.          │
                     │ ◆ │ ◆ ┼──────────╯     │ ◆ │ ◆ ┼──────────╯
                     `─┼─^───'                `─┼─^───'
                       │ ╭──────────────────────╯
                       ▼ ▼
                parameters: amount
                body: ...
      < art..

# @     ..img > img/chap3/Fig3.10b.std.svg
@     ..img > img/chap3/Fig3.10b.std.svg

#     :: @t(Exercise 3.10) :: In the @c(make-withdraw) procedure, the local variable
#        @c(balance) is created as a parameter of @c(make-withdraw). We could also
#        create the local state variable explicitly, using @c(let), as follows:
    :: @t(Ejercicio 3.10) :: En el procedimiento @c(make-withdraw), la variable
       local @c(balance) se crea como un parámetro de @c(make-withdraw). También
       podríamos crear la variable de estado local explícitamente, usando
       @c(let), como sigue:

#        ..src > scheme
#          (define (make-withdraw initial-amount)
#            (let ((balance initial-amount))
#              (lambda (amount)
#                (if (>= balance amount)
#                    (begin (set! balance
#                                 (- balance amount))
#                           balance)
#                    "Insufficient funds"))))
#        < src..
       ..src > scheme
         (define (make-withdraw initial-amount)
           (let ((balance initial-amount))
             (lambda (amount)
               (if (>= balance amount)
                   (begin (set! balance
                                (- balance amount))
                          balance)
                   "Insufficient funds"))))
       < src..

#        Recall from @l(#1.3.2) that @c(let) is simply syntactic sugar for a
#        procedure call:
       Recordemos de la seccion @l(#1.3.2) que @c(let) es simplemente azúcar
       sintáctico para una llamada de procedimiento:

#        ..src > scheme
#          (let ((⟨var⟩ ⟨exp⟩)) ⟨body⟩)
#        < src..
       ..src > scheme
         (let ((⟨var⟩ ⟨exp⟩)) ⟨body⟩)
       < src..

#        is interpreted as an alternate syntax for
       Se interpreta como una sintaxis alternativa para

#        ..src > scheme
#          ((lambda (⟨var⟩) ⟨body⟩) ⟨exp⟩)
#        < src..
       ..src > scheme
         ((lambda (⟨var⟩) ⟨body⟩) ⟨exp⟩)
       < src..

#        Use the environment model to analyze this alternate version of
#        @c(make-withdraw), drawing figures like the ones above to illustrate the
#        interactions
       Utilice el modelo de entorno para analizar esta versión alternativa de
       @c(make-withdraw), dibujando figuras como las anteriores para ilustrar
       las interacciones

#        ..src > scheme
#          (define W1 (make-withdraw 100))
#          (W1 50)
#          (define W2 (make-withdraw 100))
#        < src..
       ..src > scheme
         (define W1 (make-withdraw 100))
         (W1 50)
         (define W2 (make-withdraw 100))
       < src..

#        Show that the two versions of @c(make-withdraw) create objects with the
#        same behavior. How do the environment structures differ for the two
#        versions?
       Mostrar que las dos versiones de @c(make-withdraw) crear objetos con el
       mismo comportamiento. ¿Cómo difieren las estructuras de entorno para las
       dos versiones?

# *** 3.2.4 <> Internal Definitions
*** 3.2.4 <> Definiciones internas

#     Section @l(#1.1.8) introduced the idea that procedures can have internal
#     definitions, thus leading to a block structure as in the following procedure
#     to compute square roots:
    La sección @l(#1.1.8) introdujo la idea de que los procedimientos
    pueden tener definiciones internas, lo que conduce a una estructura de
    bloques como en el siguiente procedimiento para calcular raíces cuadradas:

#     ..src > scheme
#       (define (sqrt x)
#         (define (good-enough? guess)
#           (< (abs (- (square guess) x)) 0.001))
#         (define (improve guess)
#           (average guess (/ x guess)))
#         (define (sqrt-iter guess)
#           (if (good-enough? guess)
#               guess
#               (sqrt-iter (improve guess))))
#         (sqrt-iter 1.0))
#     < src..
    ..src > scheme
      (define (sqrt x)
        (define (good-enough? guess)
          (< (abs (- (square guess) x)) 0.001))
        (define (improve guess)
          (average guess (/ x guess)))
        (define (sqrt-iter guess)
          (if (good-enough? guess)
              guess
              (sqrt-iter (improve guess))))
        (sqrt-iter 1.0))
    < src..

#     Now we can use the environment model to see why these internal definitions
#     behave as desired. @l(#Figure 3.11) shows the point in the evaluation of the
#     expression @c[(sqrt 2)] where the internal procedure @c(good-enough?) has been
#     called for the first time with @c(guess) equal to 1.
    Ahora podemos usar el modelo de entorno para ver por qué estas definiciones
    internas se comportan como se desea. @l(#Figura 3.11)
    muestra el punto en la evaluación de la expresión @c[(sqrt 2)] donde el
    procedimiento interno @c(good-enough?) ha sido llamado por primera vez con
    @c(guess) igual a 1.

#     ..figure > @t(Figure 3.11) @c(Sqrt) procedure with internal definitions.
    ..figure > @t(Figura 3.11) procedimiento @c(Sqrt) con definiciones internas.

#       ..art >
#                   ╭──────────────────────────────────────────────────╮
#         global ──▶│ sqrt: ──╮                                        │
#         env       │         │                                        │
#                   ╰─────────┼────────────────────────────────────────╯
#                             ▼       ▲                   ▲
#                         .───.───.   │                   │
#              ╭──────────│ ◆ │ ◆ ┼───╯        ╭──────────┴────────────╮
#              │          `───^───'            │ x: 2                  │
#              ▼                         E1 ──▶│ good-enough?: ─╮      │
#         parameters: x                        │ improve: ...   │      │
#         body: (define good-enough? ...)      │ sqrt-iter: ... │      │
#               (define improve ...)           ╰────────────────┼──────╯
#               (define sqrt-iter ...)          ▲  ▲            │     ▲
#               (sqrt-iter 1.0)                 │  │            ▼     │
#                                     ╭─────────┴╮ │        .───.───. │
#                               E2 ──▶│ guess: 1 │ │        │ ◆ │ ◆ ┼─╯
#                                     ╰──────────╯ │        `─┼─^───'
#                               call to sqrt─iter  │          │
#                                                  │          ▼
#                                        ╭─────────┴╮    parameters: guess
#                                  E3 ──▶│ guess: 1 │    body: (< (abs ...)
#                                        ╰──────────╯             ...)
#                                  call to good-enough?
#       < art..
      ..art >
                  ╭──────────────────────────────────────────────────╮
        global ──▶│ sqrt: ──╮                                        │
        env       │         │                                        │
                  ╰─────────┼────────────────────────────────────────╯
                            ▼       ▲                   ▲
                        .───.───.   │                   │
             ╭──────────│ ◆ │ ◆ ┼───╯        ╭──────────┴────────────╮
             │          `───^───'            │ x: 2                  │
             ▼                         E1 ──▶│ good-enough?: ─╮      │
        parameters: x                        │ improve: ...   │      │
        body: (define good-enough? ...)      │ sqrt-iter: ... │      │
              (define improve ...)           ╰────────────────┼──────╯
              (define sqrt-iter ...)          ▲  ▲            │     ▲
              (sqrt-iter 1.0)                 │  │            ▼     │
                                    ╭─────────┴╮ │        .───.───. │
                              E2 ──▶│ guess: 1 │ │        │ ◆ │ ◆ ┼─╯
                                    ╰──────────╯ │        `─┼─^───'
                              call to sqrt─iter  │          │
                                                 │          ▼
                                       ╭─────────┴╮    parameters: guess
                                 E3 ──▶│ guess: 1 │    body: (< (abs ...)
                                       ╰──────────╯             ...)
                                 call to good-enough?
      < art..

# @     ..img > img/chap3/Fig3.11b.std.svg
@     ..img > img/chap3/Fig3.11b.std.svg

#     Observe the structure of the environment. @c(Sqrt) is a symbol in the global
#     environment that is bound to a procedure object whose associated environment
#     is the global environment. When @c(sqrt) was called, a new environment E1 was
#     formed, subordinate to the global environment, in which the parameter @c(x) is
#     bound to 2. The body of @c(sqrt) was then evaluated in E1. Since the first
#     expression in the body of @c(sqrt) is
    Observe la estructura del ambiente. @c(Sqrt) Es un símbolo en el entorno
    global que está enlazado a un objeto de procedimiento cuyo entorno asociado
    es el entorno global. Cuando @c(sqrt) se llamó, se formó un nuevo entorno
    E1, subordinado al entorno global, en el que el parámetro @c(x) está
    vinculado a 2. El cuerpo de @c(sqrt) fue entonces evaluado en E1. Dado que
    la primera expresión en el cuerpo de @c(sqrt) es

#     ..src > scheme
#       (define (good-enough? guess)
#         (< (abs (- (square guess) x)) 0.001))
#     < src..
    ..src > scheme
      (define (good-enough? guess)
        (< (abs (- (square guess) x)) 0.001))
    < src..

#     evaluating this expression defined the procedure @c(good-enough?)  in the
#     environment E1. To be more precise, the symbol @c(good-enough?) was added to
#     the first frame of E1, bound to a procedure object whose associated
#     environment is E1. Similarly, @c(improve) and @c(sqrt-iter) were defined as
#     procedures in E1. For conciseness, @l(#Figure 3.11) shows only the procedure
#     object for @c(good-enough?).
    La evaluación de esta expresión definió el procedimiento @c(good-enough?)
    en el entorno E1. Para ser más precisos, el símbolo @c(good-enough?) se
    añadió a la primera trama de E1, enlazada a un objeto de procedimiento cuyo
    entorno asociado es E1. Del mismo modo, @c(improve) y @c(sqrt-iter) se
    definieron como procedimientos en E1. Para la concisión, la
    @l(#Figura 3.11) muestra sólo el objeto de procedimiento para
    @c(good-enough?).

#     After the local procedures were defined, the expression @c[(sqrt-iter 1.0)]
#     was evaluated, still in environment E1. So the procedure object bound to
#     @c(sqrt-iter) in E1 was called with 1 as an argument. This created an
#     environment E2 in which @c(guess), the parameter of @c(sqrt-iter), is bound
#     to 1. @c(Sqrt-iter) in turn called @c(good-enough?) with the value of
#     @c(guess) (from E2) as the argument for @c(good-enough?). This set up another
#     environment, E3, in which @c(guess) (the parameter of @c(good-enough?)) is
#     bound to 1. Although @c(sqrt-iter) and @c(good-enough?) both have a parameter
#     named @c(guess), these are two distinct local variables located in different
#     frames. Also, E2 and E3 both have E1 as their enclosing environment, because
#     the @c(sqrt-iter) and @c(good-enough?) procedures both have E1 as their
#     environment part. One consequence of this is that the symbol @c(x) that
#     appears in the body of @c(good-enough?) will reference the binding of @c(x)
#     that appears in E1, namely the value of @c(x) with which the original @c(sqrt)
#     procedure was called.
    Después de definir los procedimientos locales, @c[(sqrt-iter 1.0)] se evaluó
    la expresión, aún en el medio E1. Así que el objeto de procedimiento
    enlazado @c(sqrt-iter) en E1 fue llamado con 1 como argumento. Esto creó un
    entorno E2 en el que @c(guess), el parámetro de @c(sqrt-iter), está ligado
    a 1. @c(Sqrt-iter) a su vez llamado @c(good-enough?) con el valor de
    @c(guess)(de E2) como argumento para @c(good-enough?). Esto creó otro
    entorno, E3, en el que @c(guess)(el parámetro de @c(good-enough?)) está
    obligado a 1. Si bien @c(sqrt-iter) y @c(good-enough?) ambos tienen un
    parámetro llamado @c(guess), se trata de dos variables locales
    individualizados que se encuentren en diferentes marcos. Además, E2 y E3
    tienen ambos E1 como su entorno envolvente, porque los procedimientos
    @c(sqrt-iter) y @c(good-enough?) ambos tienen E1 como su parte de
    entorno.@c(x)@c(good-enough?)@c(x)@c(x)@c(sqrt)

#     The environment model thus explains the two key properties that make local
#     procedure definitions a useful technique for modularizing programs:
    El modelo de entorno explica así las dos propiedades clave que hacen que las
    definiciones de procedimientos locales sean una técnica útil para
    modularizar los programas:

#     - The names of the local procedures do not interfere with names external to
#       the enclosing procedure, because the local procedure names will be bound in
#       the frame that the procedure creates when it is run, rather than being bound
#       in the global environment.
    - Los nombres de los procedimientos locales no interfieren con nombres
      externos al procedimiento de inclusión, ya que los nombres de
      procedimientos locales se enlazarán en el marco que el procedimiento crea
      cuando se ejecuta, en lugar de estar enlazado en el entorno global.

#     - The local procedures can access the arguments of the enclosing procedure,
#       simply by using parameter names as free variables. This is because the body
#       of the local procedure is evaluated in an environment that is subordinate to
#       the evaluation environment for the enclosing procedure.
    - Los procedimientos locales pueden acceder a los argumentos del
      procedimiento de inclusión, simplemente usando nombres de parámetros como
      variables libres. Esto se debe a que el cuerpo del procedimiento local se
      evalúa en un entorno que está subordinado al entorno de evaluación para el
      procedimiento de inclusión.


#     :: @t(Exercise 3.11) :: in section @l(#3.2.3) we saw how the environment model
#        described the behavior of procedures with local state.  Now we have seen
#        how internal definitions work. A typical message-passing procedure contains
#        both of these aspects. Consider the bank account procedure of section @l(#3.1.1):
    :: @t(Ejercicio 3.11) :: en la seccion @l(#3.2.3) vimos cómo el modelo de
       entorno describía el comportamiento de los procedimientos con el estado
       local. Ahora hemos visto cómo funcionan las definiciones internas. Un
       procedimiento típico de paso de mensajes contiene ambos
       aspectos. Considere el procedimiento de cuenta bancaria de
       @l(#3.1.1) :

#        ..src > scheme
#          (define (make-account balance)
#            (define (withdraw amount)
#              (if (>= balance amount)
#                  (begin (set! balance
#                               (- balance
#                                  amount))
#                         balance)
#                  "Insufficient funds"))
#            (define (deposit amount)
#              (set! balance (+ balance amount))
#              balance)
#            (define (dispatch m)
#              (cond ((eq? m 'withdraw) withdraw)
#                    ((eq? m 'deposit) deposit)
#                    (else (error "Unknown request:
#                                  MAKE-ACCOUNT"
#                                 m))))
#            dispatch)
#        < src..
       ..src > scheme
         (define (make-account balance)
           (define (withdraw amount)
             (if (>= balance amount)
                 (begin (set! balance
                              (- balance
                                 amount))
                        balance)
                 "Insufficient funds"))
           (define (deposit amount)
             (set! balance (+ balance amount))
             balance)
           (define (dispatch m)
             (cond ((eq? m 'withdraw) withdraw)
                   ((eq? m 'deposit) deposit)
                   (else (error "Unknown request:
                                 MAKE-ACCOUNT"
                                m))))
           dispatch)
       < src..

#        Show the environment structure generated by the sequence of interactions
       Muestra la estructura del entorno generada por la secuencia de
       interacciones

#        ..srci > scheme
#          > (define acc (make-account 50))
#          > ((acc 'deposit) 40)
#          90
#          > ((acc 'withdraw) 60)
#          30
#        < srci..
       ..srci > scheme
         > (define acc (make-account 50))
         > ((acc 'deposit) 40)
         90
         > ((acc 'withdraw) 60)
         30
       < srci..

#        Where is the local state for @c(acc) kept?  Suppose we define another
#        account
       ¿Dónde se @c(acc) guarda el estado local ? Supongamos que definimos otra
       cuenta

#        ..src > scheme
#          (define acc2 (make-account 100))
#        < src..
       ..src > scheme
         (define acc2 (make-account 100))
       < src..

#        How are the local states for the two accounts kept distinct?  Which parts
#        of the environment structure are shared between @c(acc) and @c(acc2)?
       ¿Cómo se mantienen distintos los estados locales para las dos cuentas?
       ¿Qué partes de la estructura entorno se comparten entre @c(acc) y
       @c(acc2)?

# ** 3.3 <> Modeling with Mutable Data
** 3.3 <> Modelado con datos mutables

#    @l(#Chapter 2) dealt with compound data as a means for constructing
#    computational objects that have several parts, in order to model real-world
#    objects that have several aspects. In that chapter we introduced the
#    discipline of data abstraction, according to which data structures are
#    specified in terms of constructors, which create data objects, and selectors,
#    which access the parts of compound data objects. But we now know that there is
#    another aspect of data that chapter 2 did not address. The desire to model
#    systems composed of objects that have changing state leads us to the need to
#    modify compound data objects, as well as to construct and select from them. In
#    order to model compound objects with changing state, we will design data
#    abstractions to include, in addition to selectors and constructors, operations
#    called @e(mutators), which modify data objects. For instance, modeling a
#    banking system requires us to change account balances. Thus, a data structure
#    for representing bank accounts might admit an operation
   El @l(#Capitulo 2) trata de los datos compuestos como un medio
   para construir objetos computacionales que tienen varias partes, con el fin
   de modelar objetos del mundo real que tienen varios aspectos. En ese capítulo
   introducimos la disciplina de la abstracción de datos, según la cual las
   estructuras de datos se especifican en términos de constructores, que crean
   objetos de datos y selectores que acceden a las partes de los objetos de
   datos compuestos. Pero ahora sabemos que hay otro aspecto de los datos que el
   capítulo 2 no abordó. El deseo de modelar sistemas compuestos de objetos que
   tienen un estado cambiante nos lleva a la necesidad de modificar objetos de
   datos compuestos, así como de construir y seleccionar de ellos. Para modelar
   objetos compuestos con estado cambiante, diseñaremos abstracciones de datos
   para incluir, además de selectores y constructores, @e(Operaciones llamadas
   mutators), que modifican objetos de datos. Por ejemplo, el modelado de un
   sistema bancario requiere que cambiemos los saldos de las cuentas. Así, una
   estructura de datos para representar cuentas bancarias podría admitir una
   operación

#    ..src > scheme
#      (set-balance! ⟨account⟩ ⟨new-value⟩)
#    < src..
   ..src > scheme
     (set-balance! ⟨account⟩ ⟨new-value⟩)
   < src..

#    that changes the balance of the designated account to the designated new
#    value.  Data objects for which mutators are defined are known as @e(mutable
#    data objects).
   Que cambia el saldo de la cuenta designada al nuevo valor designado. Los
   objetos de datos para los que se definen mutadores se conocen como @e(objetos
   de datos mutables).

#    Chapter 2 introduced pairs as a general-purpose @"(glue) for synthesizing
#    compound data. We begin this section by defining basic mutators for pairs, so
#    that pairs can serve as building blocks for constructing mutable data objects.
#    These mutators greatly enhance the representational power of pairs, enabling
#    us to build data structures other than the sequences and trees that we worked
#    with in section @l(#2.2). We also present some examples of simulations in which
#    complex systems are modeled as collections of objects with local state.
   El capítulo 2 introdujo los pares como un @"(pegamento de) uso general para
   sintetizar los datos compuestos. Comenzamos esta sección definiendo mutadores
   básicos para pares, de modo que los pares pueden servir como bloques de
   construcción para construir objetos de datos mutables. Estos mutadores
   mejoran en gran medida el poder de representación de los pares, lo que nos
   permite construir estructuras de datos distintas de las secuencias y los
   árboles con los que trabajamos en la seccion @l(#2.2). También presentamos algunos
   ejemplos de simulaciones en las que los sistemas complejos son modelados como
   colecciones de objetos con estado local.

# *** 3.3.1 <> Mutable List Structure
*** 3.3.1 <> Estructura de lista mutable

#     The basic operations on pairs––@c(cons), @c(car), and @c(cdr)––can be used to
#     construct list structure and to select parts from list structure, but they are
#     incapable of modifying list structure. The same is true of the list operations
#     we have used so far, such as @c(append) and @c(list), since these can be
#     defined in terms of @c(cons), @c(car), and @c(cdr).  To modify list structures
#     we need new operations.
    Las operaciones básicas en pares @c(cons)- ,, @c(car) y @c(cdr)- se pueden
    utilizar para construir la estructura de la lista y para seleccionar partes
    de la estructura de la lista, pero son incapaces de modificar la estructura
    de la lista. Lo mismo puede decirse de las operaciones de lista que hemos
    utilizado hasta el momento, como @c(append) y @c(list), ya que estos pueden
    ser definidas en términos de @c(cons), @c(car) y @c(cdr). Para modificar
    estructuras de lista necesitamos nuevas operaciones.

#     The primitive mutators for pairs are @c(set-car!) and
#     @c(set-cdr!). @c(Set-car!) takes two arguments, the first of which must be a
#     pair. It modifies this pair, replacing the @c(car) pointer by a pointer to the
#     second argument of @c(set-car!).@n(144)
    Los mutadores primitivos para pares son @c(set-car!) y
    @c(set-cdr!). @c(Set-car!) Toma dos argumentos, el primero de los cuales
    debe ser un par. Modifica este par, sustituyendo el @c(car) puntero por un
    puntero al segundo argumento de @c(set-car!).@n(144)

#     As an example, suppose that @c(x) is bound to the list @c[((a b) c d)] and
#     @c(y) to the list @c[(e f)] as illustrated in @l(#Figure 3.12).  Evaluating
#     the expression @c[(set-car!  x y)] modifies the pair to which @c(x) is bound,
#     replacing its @c(car) by the value of @c(y). The result of the operation is
#     shown in @l(#Figure 3.13). The structure @c(x) has been modified and would now
#     be printed as @c[((e f) c d)]. The pairs representing the list @c[(a b)],
#     identified by the pointer that was replaced, are now detached from the
#     original structure.@n(145)
    Por ejemplo, supongamos que @c(x) está unido a la lista @c[((a b) c d)] ya
    @c(y) la lista @c[(e f)] como se ilustra en la @l(#Figura
    3.12). La evaluación de la expresión @c[(set-car!  x y)] modifica el par al
    cual @c(x) está enlazado, reemplazando su @c(car) por el valor de @c(y). El
    resultado de la operación se muestra en la @l(#Figura 3.13). La
    estructura @c(x) se ha modificado y ahora se imprimirá como @c[((e f) c
    d)]. Los pares que representan la lista @c[(a b)], identificados por el
    puntero que fue reemplazado, ahora están separados de la estructura
    original.@n(145)

#     ..figure > @t(Figure 3.12) Lists @c(x): @c[((a b) c d)] and @c(y): @c[(e f)].
    ..figure > @t(Figura 3.12) Listas @c(x): @c[((a b) c d)] y @c(y): @c[(e f)].

#       ..art >
#              ╭───┬───╮     ╭───┬───╮     ╭───┬───╮
#         x ──▶│ ◆ │ ◆ ┼────▶│ ◆ │ ◆ ┼────▶│ ◆ │ ╱ │
#              ╰─┼─┴───╯     ╰─┼─┴───╯     ╰─┼─┴───╯
#                │             ▼             ▼
#                │           ╭───╮         ╭───╮
#                │           │ c │         │ d │
#                │           ╰───╯         ╰───╯
#                │           ╭───┬───╮     ╭───┬───╮
#                ╰──────────▶│ ◆ │ ◆ ┼────▶│ ◆ │ ╱ │
#                            ╰─┼─┴───╯     ╰─┼─┴───╯
#                              ▼             ▼
#                            ╭───╮         ╭───╮
#                            │ a │         │ b │
#                            ╰───╯         ╰───╯
#                            ╭───┬───╮     ╭───┬───╮
#                       y ──▶│ ◆ │ ◆ ┼────▶│ ◆ │ ╱ │
#                            ╰─┼─┴───╯     ╰─┼─┴───╯
#                              ▼             ▼
#                            ╭───╮         ╭───╮
#                            │ e │         │ f │
#                            ╰───╯         ╰───╯
#       < art..
      ..art >
             ╭───┬───╮     ╭───┬───╮     ╭───┬───╮
        x ──▶│ ◆ │ ◆ ┼────▶│ ◆ │ ◆ ┼────▶│ ◆ │ ╱ │
             ╰─┼─┴───╯     ╰─┼─┴───╯     ╰─┼─┴───╯
               │             ▼             ▼
               │           ╭───╮         ╭───╮
               │           │ c │         │ d │
               │           ╰───╯         ╰───╯
               │           ╭───┬───╮     ╭───┬───╮
               ╰──────────▶│ ◆ │ ◆ ┼────▶│ ◆ │ ╱ │
                           ╰─┼─┴───╯     ╰─┼─┴───╯
                             ▼             ▼
                           ╭───╮         ╭───╮
                           │ a │         │ b │
                           ╰───╯         ╰───╯
                           ╭───┬───╮     ╭───┬───╮
                      y ──▶│ ◆ │ ◆ ┼────▶│ ◆ │ ╱ │
                           ╰─┼─┴───╯     ╰─┼─┴───╯
                             ▼             ▼
                           ╭───╮         ╭───╮
                           │ e │         │ f │
                           ╰───╯         ╰───╯
      < art..

# @   ..img > img/chap3/Fig3.12b.std.svg
@   ..img > img/chap3/Fig3.12b.std.svg

#     ..figure > @t(Figure 3.13) Effect of @c[(set-car! x y)] on the lists in
#       @l(#Figure 3.12).
    ..figure > @t(Figura 3.13) Efecto de @c[(set-car! x y)] en las listas de la
      @l(#Figura 3.12).

#       ..art >
#              ╭───┬───╮     ╭───┬───╮     ╭───┬───╮
#         x ──▶│ ◆ │ ◆ ┼────▶│ ◆ │ ◆ ┼────▶│ ◆ │ ╱ │
#              ╰─┼─┴───╯     ╰─┼─┴───╯     ╰─┼─┴───╯
#                │             ▼             ▼
#                │           ╭───╮         ╭───╮
#                │           │ c │         │ d │
#                │           ╰───╯         ╰───╯
#                │           ╭───┬───╮     ╭───┬───╮
#                │           │ ◆ │ ◆ ┼────▶│ ◆ │ ╱ │
#                │           ╰─┼─┴───╯     ╰─┼─┴───╯
#                │             ▼             ▼
#                │           ╭───╮         ╭───╮
#                │           │ a │         │ b │
#                │           ╰───╯         ╰───╯
#                ╰──────────▶╭───┬───╮     ╭───┬───╮
#                       y ──▶│ ◆ │ ◆ ┼────▶│ ◆ │ ╱ │
#                            ╰─┼─┴───╯     ╰─┼─┴───╯
#                              ▼             ▼
#                            ╭───╮         ╭───╮
#                            │ e │         │ f │
#                            ╰───╯         ╰───╯
#       < art..
      ..art >
             ╭───┬───╮     ╭───┬───╮     ╭───┬───╮
        x ──▶│ ◆ │ ◆ ┼────▶│ ◆ │ ◆ ┼────▶│ ◆ │ ╱ │
             ╰─┼─┴───╯     ╰─┼─┴───╯     ╰─┼─┴───╯
               │             ▼             ▼
               │           ╭───╮         ╭───╮
               │           │ c │         │ d │
               │           ╰───╯         ╰───╯
               │           ╭───┬───╮     ╭───┬───╮
               │           │ ◆ │ ◆ ┼────▶│ ◆ │ ╱ │
               │           ╰─┼─┴───╯     ╰─┼─┴───╯
               │             ▼             ▼
               │           ╭───╮         ╭───╮
               │           │ a │         │ b │
               │           ╰───╯         ╰───╯
               ╰──────────▶╭───┬───╮     ╭───┬───╮
                      y ──▶│ ◆ │ ◆ ┼────▶│ ◆ │ ╱ │
                           ╰─┼─┴───╯     ╰─┼─┴───╯
                             ▼             ▼
                           ╭───╮         ╭───╮
                           │ e │         │ f │
                           ╰───╯         ╰───╯
      < art..

# @   ..img > img/chap3/Fig3.13b.std.svg
@   ..img > img/chap3/Fig3.13b.std.svg

#     Compare @l(#Figure 3.13) with @l(#Figure 3.14), which illustrates the result
#     of executing @c[(define z (cons y (cdr x)))] with @c(x) and @c(y) bound to the
#     original lists of @l(#Figure 3.12). The variable @c(z) is now bound to a new
#     pair created by the @c(cons) operation; the list to which @c(x) is bound is
#     unchanged.
    Compare la @l(#Figura 3.13) con la @l(#Figura
    3.14), que ilustra el resultado de la ejecución @c[(define z (cons y (cdr
    x)))] con @c(x) y @c(y) enlazado a las listas originales de la
    @l(#Figura 3.12). La variable @c(z) está ahora enlazada a un
    nuevo par creado por la @c(cons) operación; La lista a la que @c(x) está
    vinculado no ha cambiado.

#     ..figure > @t(Figure 3.14) Effect of @c[(define z (cons y (cdr x)))] on the
#       lists in @l(#Figure 3.12).
    ..figure > @t(Figura 3.14) Efecto de @c[(define z (cons y (cdr x)))] en las
      listas en la @l(#Figura 3.12).

#       ..art >
#              ╭───┬───╮     ╭───┬───╮     ╭───┬───╮
#         x ──▶│ ◆ │ ◆ ┼────▶│ ◆ │ ◆ ┼────▶│ ◆ │ ╱ │
#              ╰─┼─┴───╯ ╭──▶╰─┼─┴───╯     ╰─┼─┴───╯
#                │       │     ▼             ▼
#                │       │   ╭───╮         ╭───╮
#                │       │   │ c │         │ d │
#                │       │   ╰───╯         ╰───╯
#                │       │   ╭───┬───╮     ╭───┬───╮
#                ╰───────┼──▶│ ◆ │ ◆ ┼────▶│ ◆ │ ╱ │
#                        │   ╰─┼─┴───╯     ╰─┼─┴───╯
#                        │     ▼             ▼
#              ╭───┬───╮ │   ╭───╮         ╭───╮
#         z ──▶│ ◆ │ ◆ ┼─╯   │ a │         │ b │
#              ╰─┼─┴───╯     ╰───╯         ╰───╯
#                ╰──────────▶╭───┬───╮     ╭───┬───╮
#                       y ──▶│ ◆ │ ◆ ┼────▶│ ◆ │ ╱ │
#                            ╰─┼─┴───╯     ╰─┼─┴───╯
#                              ▼             ▼
#                            ╭───╮         ╭───╮
#                            │ e │         │ f │
#                            ╰───╯         ╰───╯
#       < art..
      ..art >
             ╭───┬───╮     ╭───┬───╮     ╭───┬───╮
        x ──▶│ ◆ │ ◆ ┼────▶│ ◆ │ ◆ ┼────▶│ ◆ │ ╱ │
             ╰─┼─┴───╯ ╭──▶╰─┼─┴───╯     ╰─┼─┴───╯
               │       │     ▼             ▼
               │       │   ╭───╮         ╭───╮
               │       │   │ c │         │ d │
               │       │   ╰───╯         ╰───╯
               │       │   ╭───┬───╮     ╭───┬───╮
               ╰───────┼──▶│ ◆ │ ◆ ┼────▶│ ◆ │ ╱ │
                       │   ╰─┼─┴───╯     ╰─┼─┴───╯
                       │     ▼             ▼
             ╭───┬───╮ │   ╭───╮         ╭───╮
        z ──▶│ ◆ │ ◆ ┼─╯   │ a │         │ b │
             ╰─┼─┴───╯     ╰───╯         ╰───╯
               ╰──────────▶╭───┬───╮     ╭───┬───╮
                      y ──▶│ ◆ │ ◆ ┼────▶│ ◆ │ ╱ │
                           ╰─┼─┴───╯     ╰─┼─┴───╯
                             ▼             ▼
                           ╭───╮         ╭───╮
                           │ e │         │ f │
                           ╰───╯         ╰───╯
      < art..

# @   ..img > img/chap3/Fig3.14b.std.svg
@   ..img > img/chap3/Fig3.14b.std.svg

#     The @c(set-cdr!) operation is similar to @c(set-car!). The only difference is
#     that the @c(cdr) pointer of the pair, rather than the @c(car) pointer, is
#     replaced. The effect of executing @c[(set-cdr! x y)] on the lists of
#     @l(#Figure 3.12) is shown in @l(#Figure 3.15). Here the @c(cdr) pointer of
#     @c(x) has been replaced by the pointer to @c[(e f)]. Also, the list @c[(c d)],
#     which used to be the @c(cdr) of @c(x), is now detached from the structure.
    La @c(set-cdr!) operación es similar a @c(set-car!). La única diferencia es
    que el @c(cdr) puntero del par, en lugar del @c(car) puntero, se
    reemplaza. El efecto de ejecutar @c[(set-cdr! x y)] en las listas de la
    @l(#Figura 3.12) se muestra en la @l(#Figura
    3.15). Aquí el @c(cdr) puntero de @c(x) ha sido reemplazado por el puntero a
    @c[(e f)]. Además, la lista @c[(c d)], que solía ser el @c(cdr) de @c(x),
    ahora se separa de la estructura.

#     ..figure > @t(Figure 3.15) Effect of @c[(set-cdr! x y)] on the lists in
#       @l(#Figure 3.12).
    ..figure > @t(Figura 3.15) Efecto de @c[(set-cdr! x y)] en las listas de la
      @l(#Figura 3.12).

#       ..art >
#              ╭───┬───╮     ╭───┬───╮     ╭───┬───╮
#         x ──▶│ ◆ │ ◆ │     │ ◆ │ ◆ ┼────▶│ ◆ │ ╱ │
#              ╰─┼─┴─┼─╯     ╰─┼─┴───╯     ╰─┼─┴───╯
#                │   │         ▼             ▼
#                │   │       ╭───╮         ╭───╮
#                │   │       │ c │         │ d │
#                │   │       ╰───╯         ╰───╯
#                │   │       ╭───┬───╮     ╭───┬───╮
#                ╰───┼──────▶│ ◆ │ ◆ ┼────▶│ ◆ │ ╱ │
#                    │       ╰─┼─┴───╯     ╰─┼─┴───╯
#                    │         ▼             ▼
#                    │       ╭───╮         ╭───╮
#                    │       │ a │         │ b │
#                    │       ╰───╯         ╰───╯
#                    ╰──────▶╭───┬───╮     ╭───┬───╮
#                       y ──▶│ ◆ │ ◆ ┼────▶│ ◆ │ ╱ │
#                            ╰─┼─┴───╯     ╰─┼─┴───╯
#                              ▼             ▼
#                            ╭───╮         ╭───╮
#                            │ e │         │ f │
#                            ╰───╯         ╰───╯
#       < art..
      ..art >
             ╭───┬───╮     ╭───┬───╮     ╭───┬───╮
        x ──▶│ ◆ │ ◆ │     │ ◆ │ ◆ ┼────▶│ ◆ │ ╱ │
             ╰─┼─┴─┼─╯     ╰─┼─┴───╯     ╰─┼─┴───╯
               │   │         ▼             ▼
               │   │       ╭───╮         ╭───╮
               │   │       │ c │         │ d │
               │   │       ╰───╯         ╰───╯
               │   │       ╭───┬───╮     ╭───┬───╮
               ╰───┼──────▶│ ◆ │ ◆ ┼────▶│ ◆ │ ╱ │
                   │       ╰─┼─┴───╯     ╰─┼─┴───╯
                   │         ▼             ▼
                   │       ╭───╮         ╭───╮
                   │       │ a │         │ b │
                   │       ╰───╯         ╰───╯
                   ╰──────▶╭───┬───╮     ╭───┬───╮
                      y ──▶│ ◆ │ ◆ ┼────▶│ ◆ │ ╱ │
                           ╰─┼─┴───╯     ╰─┼─┴───╯
                             ▼             ▼
                           ╭───╮         ╭───╮
                           │ e │         │ f │
                           ╰───╯         ╰───╯
      < art..

# @   ..img > img/chap3/Fig3.15b.std.svg
@   ..img > img/chap3/Fig3.15b.std.svg

#     @c(Cons) builds new list structure by creating new pairs, while @c(set-car!)
#     and @c(set-cdr!) modify existing pairs. Indeed, we could implement @c(cons) in
#     terms of the two mutators, together with a procedure @c(get-new-pair), which
#     returns a new pair that is not part of any existing list structure. We obtain
#     the new pair, set its @c(car) and @c(cdr) pointers to the designated objects,
#     and return the new pair as the result of the @c(cons).@n(146)
    @c(Cons) Construye una nueva estructura de lista mediante la creación de
    nuevos pares, mientras que @c(set-car!) y @c(set-cdr!) modificar los pares
    existentes. De hecho, podríamos implementar @c(cons) en términos de los dos
    mutadores, junto con un procedimiento @c(get-new-pair), que devuelve un
    nuevo par que no forma parte de ninguna estructura de lista
    existente. Obtenemos el nuevo par, establece sus @c(car) y @c(cdr) punteros
    a los objetos designados, y devolver el nuevo par como resultado de la
    @c(cons).@n(146)

#     ..src > scheme
#       (define (cons x y)
#         (let ((new (get-new-pair)))
#           (set-car! new x)
#           (set-cdr! new y)
#           new))
#     < src..
    ..src > scheme
      (define (cons x y)
        (let ((new (get-new-pair)))
          (set-car! new x)
          (set-cdr! new y)
          new))
    < src..

#     :: @t(Exercise 3.12) :: The following procedure for appending lists was
#        introduced in section @l(#2.2.1):
    :: @t(Ejercicio 3.12) :: El siguiente procedimiento para añadir listas se
       introdujo en la seccion @l(#2.2.1) :

#        ..src > scheme
#          (define (append x y)
#            (if (null? x)
#                y
#                (cons (car x) (append (cdr x) y))))
#        < src..
       ..src > scheme
         (define (append x y)
           (if (null? x)
               y
               (cons (car x) (append (cdr x) y))))
       < src..

#        @c(Append) forms a new list by successively @c(cons)ing the elements of
#        @c(x) onto @c(y). The procedure @c(append!) is similar to @c(append), but
#        it is a mutator rather than a constructor. It appends the lists by splicing
#        them together, modifying the final pair of @c(x) so that its @c(cdr) is now
#        @c(y). (It is an error to call @c(append!) with an empty @c(x).)
       @c(Append) Forma una nueva lista sucesivamente @c(cons) ing de los
       elementos de @c(x) sobre @c(y). El procedimiento @c(append!) es similar a
       @c(append), pero es un mutador en lugar de un constructor. Añade las
       listas uniéndolas, modificando el par final de @c(x) modo que su @c(cdr)
       es ahora @c(y). (Es un error llamar @c(append!) con un vacío @c(x).)

#        ..src > scheme
#          (define (append! x y)
#            (set-cdr! (last-pair x) y)
#            x)
#        < src..
       ..src > scheme
         (define (append! x y)
           (set-cdr! (last-pair x) y)
           x)
       < src..

#        Here @c(last-pair) is a procedure that returns the last pair in its
#        argument:
       Este @c(last-pair) es un procedimiento que devuelve el último par en su
       argumento:

#        ..src > scheme
#          (define (last-pair x)
#            (if (null? (cdr x))
#                x
#                (last-pair (cdr x))))
#        < src..
       ..src > scheme
         (define (last-pair x)
           (if (null? (cdr x))
               x
               (last-pair (cdr x))))
       < src..

#        Consider the interaction
       Considere la interacción

#        ..srci > scheme
#          > (define x (list 'a 'b))
#          > (define y (list 'c 'd))
#          > (define z (append x y))
#          > z
#          (a b c d)
#          > (cdr x)
#          > ⟨response⟩
#          > (define w (append! x y))
#          > w
#          (a b c d)
#          > (cdr x)
#          > ⟨response⟩
#        < srci..
       ..srci > scheme
         > (define x (list 'a 'b))
         > (define y (list 'c 'd))
         > (define z (append x y))
         > z
         (a b c d)
         > (cdr x)
         > ⟨response⟩
         > (define w (append! x y))
         > w
         (a b c d)
         > (cdr x)
         > ⟨response⟩
       < srci..

#        What are the missing @c[(response)]s?  Draw box-and-pointer diagrams to
#        explain your answer.
       ¿Cuáles son los @c[(response)] s faltantes ? Dibuje diagramas de cuadro y
       puntero para explicar su respuesta.

#     :: @t(Exercise 3.13) :: Consider the following @c(make-cycle) procedure, which
#        uses the @c(last-pair) procedure defined in @l(#Exercise 3.12):
    :: @t(Ejercicio 3.13) :: Considere el procedimiento @c(make-cycle)
       siguiente, que utiliza el procedimiento @c(last-pair) definido en el
       @l(#Ejercicio 3.12) :

#        ..src > scheme
#          (define (make-cycle x)
#            (set-cdr! (last-pair x) x)
#            x)
#        < src..
       ..src > scheme
         (define (make-cycle x)
           (set-cdr! (last-pair x) x)
           x)
       < src..

#        Draw a box-and-pointer diagram that shows the structure @c(z) created by
       Dibuja un diagrama de cuadro y puntero que muestra la estructura @c(z)
       creada por

#        ..src > scheme
#          (define z (make-cycle (list 'a 'b 'c)))
#        < src..
       ..src > scheme
         (define z (make-cycle (list 'a 'b 'c)))
       < src..

#        What happens if we try to compute @c[(last-pair z)]?
       ¿Qué pasa si tratamos de calcular @c[(last-pair z)]?

#     :: @t(Exercise 3.14) :: The following procedure is quite useful, although
#        obscure:
    :: @t(Ejercicio 3.14) :: El siguiente procedimiento es bastante útil, aunque
       oscuro:

#        ..src > scheme
#          (define (mystery x)
#            (define (loop x y)
#              (if (null? x)
#                  y
#                  (let ((temp (cdr x)))
#                    (set-cdr! x y)
#                    (loop temp x))))
#            (loop x '()))
#        < src..
       ..src > scheme
         (define (mystery x)
           (define (loop x y)
             (if (null? x)
                 y
                 (let ((temp (cdr x)))
                   (set-cdr! x y)
                   (loop temp x))))
           (loop x '()))
       < src..

#        @c(Loop) uses the @"(temporary) variable @c(temp) to hold the old value of
#        the @c(cdr) of @c(x), since the @c(set-cdr!)  on the next line destroys the
#        @c(cdr). Explain what @c(mystery) does in general. Suppose @c(v) is defined
#        by @c[(define v (list 'a 'b 'c 'd))]. Draw the box-and-pointer diagram that
#        represents the list to which @c(v) is bound.  Suppose that we now evaluate
#        @c[(define w (mystery v))]. Draw box-and-pointer diagrams that show the
#        structures @c(v) and @c(w) after evaluating this expression. What would be
#        printed as the values of @c(v) and @c(w)?
       @c(Loop) Utiliza la variable @"(temporal)@c(temp) para contener el valor
       antiguo de la @c(cdr) de @c(x), ya que @c(set-cdr!)  en la siguiente
       línea destruye la @c(cdr). Explique lo que @c(mystery) hace en
       general. Supongamos que @c(v) está definido por @c[(define v (list 'a 'b
       'c 'd))]. Dibuja el diagrama de cuadro y puntero que representa la lista
       a la que @c(v) está enlazado. Supongamos que ahora evaluamos @c[(define w
       (mystery v))]. Dibujar diagramas de cuadro y puntero que muestren las
       estructuras @c(v) y @c(w) después de evaluar esta expresión. ¿Qué sería
       impreso como los valores de @c(v) y @c(w)?

# **** Sharing and identity
**** Compartir e identidad

#      We mentioned in section @l(#3.1.3) the theoretical issues of @"(sameness) and
#      @"(change) raised by the introduction of assignment. These issues arise in
#      practice when individual pairs are @e(shared) among different data
#      objects. For example, consider the structure formed by
     Hemos mencionado en la seccion @l(#3.1.3) las cuestiones teóricas de
     @"(igualdad) y @"(cambio) planteadas por la introducción de la
     asignación. Estos problemas surgen en la práctica cuando pares individuales
     se @e(comparten) entre diferentes objetos de datos. Por ejemplo, considere
     la estructura

#      ..src > scheme
#        (define x (list 'a 'b))
#        (define z1 (cons x x))
#      < src..
     ..src > scheme
       (define x (list 'a 'b))
       (define z1 (cons x x))
     < src..

#      As shown in @l(#Figure 3.16), @c(z1) is a pair whose @c(car) and @c(cdr) both
#      point to the same pair @c(x). This sharing of @c(x) by the @c(car) and @c(cdr)
#      of @c(z1) is a consequence of the straightforward way in which @c(cons) is
#      implemented. In general, using @c(cons) to construct lists will result in an
#      interlinked structure of pairs in which many individual pairs are shared by
#      many different structures.
     Como se muestra en la @l(#Figura 3.16), @c(z1) es un par cuyo
     @c(car) y @c(cdr) ambos apuntan al mismo par @c(x). Este compartir de @c(x)
     por @c(car) y @c(cdr) de @c(z1) es una consecuencia de la manera sencilla
     en que @c(cons) se implementa. En general, usar @c(cons) para construir
     listas dará lugar a una estructura interconectada de pares en la que muchos
     pares individuales son compartidos por muchas estructuras diferentes.

#      ..figure > @t(Figure 3.16) The list @c(z1) formed by @c[(cons x x)].
     ..figure > @t(Figura 3.16) La lista @c(z1) formada por @c[(cons x x)].

#        ..art >
#                ╭───┬───╮
#          z1 ──▶│ ◆ │ ◆ │
#                ╰─┼─┴─┼─╯
#                  │   │
#                  ▼   ▼
#                ╭───┬───╮     ╭───┬───╮
#           x ──▶│ ◆ │ ◆ ┼────▶│ ◆ │ ╱ │
#                ╰─┼─┴───╯     ╰─┼─┴───╯
#                  ▼             ▼
#                ╭───╮         ╭───╮
#                │ a │         │ b │
#                ╰───╯         ╰───╯
#        < art..
       ..art >
               ╭───┬───╮
         z1 ──▶│ ◆ │ ◆ │
               ╰─┼─┴─┼─╯
                 │   │
                 ▼   ▼
               ╭───┬───╮     ╭───┬───╮
          x ──▶│ ◆ │ ◆ ┼────▶│ ◆ │ ╱ │
               ╰─┼─┴───╯     ╰─┼─┴───╯
                 ▼             ▼
               ╭───╮         ╭───╮
               │ a │         │ b │
               ╰───╯         ╰───╯
       < art..

# @    ..img > img/chap3/Fig3.16b.std.svg
@    ..img > img/chap3/Fig3.16b.std.svg

#      In contrast to @l(#Figure 3.16), @l(#Figure 3.17) shows the structure created
#      by
     En contraste con la @l(#Figura 3.16), la
     @l(#Figura 3.17) muestra la estructura creada por

#      ..src > scheme
#        (define z2
#          (cons (list 'a 'b) (list 'a 'b)))
#      < src..
     ..src > scheme
       (define z2
         (cons (list 'a 'b) (list 'a 'b)))
     < src..

#      ..figure > @t(Figure 3.17) The list @c(z2) formed by
#        @c[(cons (list 'a 'b) (list 'a 'b))].
     ..figure > @t(Figura 3.17) La lista @c(z2) formada por @c[(cons (list 'a
       'b) (list 'a 'b))].

#        ..art >
#                ╭───┬───╮     ╭───┬───╮     ╭───┬───╮
#          z2 ──▶│ ◆ │ ◆ ┼────▶│ ◆ │ ◆ ┼────▶│ ◆ │ ╱ │
#                ╰─┼─┴───╯     ╰─┼─┴───╯     ╰─┼─┴───╯
#                  │             ▼             ▼
#                  │           ╭───╮         ╭───╮
#                  │           │ a │         │ b │
#                  │           ╰───╯         ╰───╯
#                  │             ▲             ▲
#                  │           ╭─┼─┬───╮     ╭─┼─┬───╮
#                  ╰──────────▶│ ◆ │ ◆ ┼────▶│ ◆ │ ╱ │
#                              ╰───┴───╯     ╰───┴───╯
#        < art..
       ..art >
               ╭───┬───╮     ╭───┬───╮     ╭───┬───╮
         z2 ──▶│ ◆ │ ◆ ┼────▶│ ◆ │ ◆ ┼────▶│ ◆ │ ╱ │
               ╰─┼─┴───╯     ╰─┼─┴───╯     ╰─┼─┴───╯
                 │             ▼             ▼
                 │           ╭───╮         ╭───╮
                 │           │ a │         │ b │
                 │           ╰───╯         ╰───╯
                 │             ▲             ▲
                 │           ╭─┼─┬───╮     ╭─┼─┬───╮
                 ╰──────────▶│ ◆ │ ◆ ┼────▶│ ◆ │ ╱ │
                             ╰───┴───╯     ╰───┴───╯
       < art..

# @    ..img > img/chap3/Fig3.17b.std.svg
@    ..img > img/chap3/Fig3.17b.std.svg

#      In this structure, the pairs in the two @c[(a b)] lists are distinct, although
#      the actual symbols are shared.@n(147)
     En esta estructura, los pares en las dos @c[(a b)] listas son distintos,
     aunque los símbolos reales son compartidos.@n(147)

#      When thought of as a list, @c(z1) and @c(z2) both represent @"(the same) list,
#      @c[((a b) a b)]. In general, sharing is completely undetectable if we operate
#      on lists using only @c(cons), @c(car), and @c(cdr). However, if we allow
#      mutators on list structure, sharing becomes significant. As an example of the
#      difference that sharing can make, consider the following procedure, which
#      modifies the @c(car) of the structure to which it is applied:
     Cuando se piensa en una lista, @c(z1) y @c(z2) ambos representan @"(la
     misma) lista @c[((a b) a b)],. En general, el intercambio es completamente
     indetectable si operamos en las listas utilizando únicamente @c(cons),
     @c(car) y @c(cdr). Sin embargo, si permitimos mutadores en la estructura de
     la lista, el compartir se hace significativo. Como ejemplo de la diferencia
     que puede tener el compartir, considere el siguiente procedimiento, que
     modifica el @c(car) de la estructura a la que se aplica:

#      ..src > scheme
#        (define (set-to-wow! x)
#          (set-car! (car x) 'wow)
#          x)
#      < src..
     ..src > scheme
       (define (set-to-wow! x)
         (set-car! (car x) 'wow)
         x)
     < src..

#      Even though @c(z1) and @c(z2) are @"(the same) structure, applying
#      @c(set-to-wow!) to them yields different results. With @c(z1), altering the
#      @c(car) also changes the @c(cdr), because in @c(z1) the @c(car) and the
#      @c(cdr) are the same pair. With @c(z2), the @c(car) and @c(cdr) are distinct,
#      so @c(set-to-wow!) modifies only the @c(car):
     A pesar de que @c(z1) y @c(z2) son @"(la misma) estructura, la aplicación
     @c(set-to-wow!) de ellos produce diferentes resultados. Con @c(z1),
     alterando el @c(car) también cambia el @c(cdr), porque en @c(z1) el @c(car)
     y el @c(cdr) son el mismo par. Con @c(z2), el @c(car) y @c(cdr) son
     distintos, por lo que @c(set-to-wow!) modifica sólo el @c(car):

#      ..srci > scheme
#        > z1
#        ((a b) a b)
#        > (set-to-wow! z1)
#        ((wow b) wow b)
#        > z2
#        ((a b) a b)
#        > (set-to-wow! z2)
#        ((wow b) a b)
#      < srci..
     ..srci > scheme
       > z1
       ((a b) a b)
       > (set-to-wow! z1)
       ((wow b) wow b)
       > z2
       ((a b) a b)
       > (set-to-wow! z2)
       ((wow b) a b)
     < srci..

#      One way to detect sharing in list structures is to use the predicate @c(eq?),
#      which we introduced in section @l(#2.3.1) as a way to test whether two symbols are
#      equal. More generally, @c[(eq?  x y)] tests whether @c(x) and @c(y) are the
#      same object (that is, whether @c(x) and @c(y) are equal as pointers). Thus,
#      with @c(z1) and @c(z2) as defined in @l(#Figure 3.16) and @l(#Figure 3.17),
#      @c[(eq?  (car z1) (cdr z1))] is true and @c[(eq? (car z2) (cdr z2))] is false.
     Una forma de detectar el uso compartido en estructuras de lista es usar el
     predicado @c(eq?), que introdujimos en la seccion @l(#2.3.1) como una manera de
     probar si dos símbolos son iguales. De manera más general, @c[(eq?  x y)]
     prueba si @c(x) y @c(y) son el mismo objeto (es decir, si @c(x) y @c(y) son
     iguales como punteros). Por lo tanto, con @c(z1) y @c(z2) como se define en
     la @l(#Figura 3.16) y la @l(#Figura 3.17),
     @c[(eq?  (car z1) (cdr z1))] es verdadera y @c[(eq? (car z2) (cdr z2))] es
     falsa.

#      As will be seen in the following sections, we can exploit sharing to greatly
#      extend the repertoire of data structures that can be represented by pairs. On
#      the other hand, sharing can also be dangerous, since modifications made to
#      structures will also affect other structures that happen to share the modified
#      parts. The mutation operations @c(set-car!) and @c(set-cdr!) should be used
#      with care; unless we have a good understanding of how our data objects are
#      shared, mutation can have unanticipated results.@n(148)
     Como se verá en las siguientes secciones, podemos explotar el uso
     compartido para ampliar en gran medida el repertorio de estructuras de
     datos que pueden representarse por parejas. Por otro lado, compartir
     también puede ser peligroso, ya que las modificaciones hechas a las
     estructuras también afectarán a otras estructuras que pasan a compartir las
     partes modificadas. Las operaciones de mutación @c(set-car!) y se
     @c(set-cdr!) deben utilizar con cuidado; A menos que tengamos una buena
     comprensión de cómo nuestros objetos de datos son compartidos, la mutación
     puede tener resultados imprevistos.@n(148)

#      :: @t(Exercise 3.15) :: Draw box-and-pointer diagrams to explain the effect of
#         @c(set-to-wow!) on the structures @c(z1) and @c(z2) above.
     :: @t(Ejercicio 3.15) :: Dibujar diagramas de caja y puntero para explicar
        el efecto de @c(set-to-wow!) en las estructuras @c(z1) y @c(z2) arriba.

#      :: @t(Exercise 3.16) :: Ben Bitdiddle decides to write a procedure to count
#         the number of pairs in any list structure. @"(It's easy,) he
#         reasons. @"(The number of pairs in any structure is the number in the
#         @c(car) plus the number in the @c(cdr) plus one more to count the current
#         pair.)  So Ben writes the following procedure:
     :: @t(Ejercicio 3.16) :: Ben Bitdiddle decide escribir un procedimiento
        para contar el número de pares en cualquier estructura de lista. @"(Es
        fácil,) razona. @"(El número de pares en cualquier estructura es el
        número en el @c(car) más el número en el @c(cdr) más uno más para contar
        el par actual. )  Así que Ben escribe el siguiente procedimiento:

#         ..src > scheme
#           (define (count-pairs x)
#             (if (not (pair? x))
#                 0
#                 (+ (count-pairs (car x))
#                    (count-pairs (cdr x))
#                    1)))
#         < src..
        ..src > scheme
          (define (count-pairs x)
            (if (not (pair? x))
                0
                (+ (count-pairs (car x))
                   (count-pairs (cdr x))
                   1)))
        < src..

#         Show that this procedure is not correct. In particular, draw
#         box-and-pointer diagrams representing list structures made up of exactly
#         three pairs for which Ben's procedure would return 3; return 4; return 7;
#         never return at all.
        Mostrar que este procedimiento no es correcto. En particular, dibujar
        diagramas de caja y puntero que representan estructuras de lista
        compuestas por exactamente tres pares para los que el procedimiento de
        Ben devolvería 3; Return 4; Regreso 7; Nunca volver en absoluto.

#      :: @t(Exercise 3.17) :: Devise a correct version of the @c(count-pairs)
#         procedure of @l(#Exercise 3.16) that returns the number of distinct pairs
#         in any structure. (Hint: Traverse the structure, maintaining an auxiliary
#         data structure that is used to keep track of which pairs have already been
#         counted.)
     :: @t(Ejercicio 3.17) :: Desarrolle una versión correcta del
        procedimiento @c(count-pairs) del @l(#Ejercicio 3.16) que
        devuelve el número de pares distintos en cualquier
        estructura. (Sugerencia: recorrer la estructura, manteniendo una
        estructura de datos auxiliares que se utiliza para realizar un
        seguimiento de qué pares ya se han contado.)

#      :: @t(Exercise 3.18) :: Write a procedure that examines a list and determines
#         whether it contains a cycle, that is, whether a program that tried to find
#         the end of the list by taking successive @c(cdr)s would go into an infinite
#         loop. @l(#Exercise 3.13) constructed such lists.
     :: @t(Ejercicio 3.18) :: Escriba un procedimiento que examina una lista y
        determina si contiene un ciclo, es decir, si un programa que intentó
        encontrar el final de la lista tomando sucesivas @c(cdr) s entraría en
        un bucle infinito. @l(#Ejercicio 3.13) construyó
        dichas listas.

#      :: @t(Exercise 3.19) :: Redo @l(#Exercise 3.18) using an algorithm that takes
#         only a constant amount of space. (This requires a very clever idea.)
     :: @t(Ejercicio 3.19) :: Repita el @l(#Ejercicio 3.18)
        utilizando un algoritmo que sólo toma una cantidad constante de
        espacio. (Esto requiere una idea muy inteligente.)

# **** Mutation is just assignment
**** Mutación es sólo asignación

#      When we introduced compound data, we observed in section @l(#2.1.3) that pairs can be
#      represented purely in terms of procedures:
     Cuando introdujimos datos compuestos, observamos en la seccion @l(#2.1.3) que
     los pares pueden ser representados puramente en términos de procedimientos:

#      ..src > scheme
#        (define (cons x y)
#          (define (dispatch m)
#            (cond ((eq? m 'car) x)
#                  ((eq? m 'cdr) y)
#                  (else (error "Undefined
#                         operation: CONS" m))))
#          dispatch)
#
#        (define (car z) (z 'car))
#        (define (cdr z) (z 'cdr))
#      < src..
     ..src > scheme
       (define (cons x y)
         (define (dispatch m)
           (cond ((eq? m 'car) x)
                 ((eq? m 'cdr) y)
                 (else (error "Undefined
                        operation: CONS" m))))
         dispatch)

       (define (car z) (z 'car))
       (define (cdr z) (z 'cdr))
     < src..

#      The same observation is true for mutable data. We can implement mutable data
#      objects as procedures using assignment and local state. For instance, we can
#      extend the above pair implementation to handle @c(set-car!) and @c(set-cdr!)
#      in a manner analogous to the way we implemented bank accounts using
#      @c(make-account) in section @l(#3.1.1):
     La misma observación es verdadera para los datos mutables. Podemos
     implementar objetos de datos mutables como procedimientos usando asignación
     y estado local. Por ejemplo, podemos extender la implementación de pares
     anterior para manejar @c(set-car!) y @c(set-cdr!) de una manera análoga a
     la forma en que implementamos las cuentas bancarias usando @c(make-account)
     en la seccion @l(#3.1.1) :

#      ..src > scheme
#        (define (cons x y)
#          (define (set-x! v) (set! x v))
#          (define (set-y! v) (set! y v))
#          (define (dispatch m)
#            (cond ((eq? m 'car) x)
#                  ((eq? m 'cdr) y)
#                  ((eq? m 'set-car!) set-x!)
#                  ((eq? m 'set-cdr!) set-y!)
#                  (else (error "Undefined
#                         operation: CONS" m))))
#          dispatch)
#
#        (define (car z) (z 'car))
#        (define (cdr z) (z 'cdr))
#
#        (define (set-car! z new-value)
#          ((z 'set-car!) new-value)
#          z)
#
#        (define (set-cdr! z new-value)
#          ((z 'set-cdr!) new-value)
#          z)
#      < src..
     ..src > scheme
       (define (cons x y)
         (define (set-x! v) (set! x v))
         (define (set-y! v) (set! y v))
         (define (dispatch m)
           (cond ((eq? m 'car) x)
                 ((eq? m 'cdr) y)
                 ((eq? m 'set-car!) set-x!)
                 ((eq? m 'set-cdr!) set-y!)
                 (else (error "Undefined
                        operation: CONS" m))))
         dispatch)

       (define (car z) (z 'car))
       (define (cdr z) (z 'cdr))

       (define (set-car! z new-value)
         ((z 'set-car!) new-value)
         z)

       (define (set-cdr! z new-value)
         ((z 'set-cdr!) new-value)
         z)
     < src..

#      Assignment is all that is needed, theoretically, to account for the behavior
#      of mutable data. As soon as we admit @c(set!) to our language, we raise all
#      the issues, not only of assignment, but of mutable data in general.@n(149)
     La asignación es todo lo que se necesita, teóricamente, para explicar el
     comportamiento de los datos mutables. Tan pronto como admitimos @c(set!) a
     nuestro lenguaje, planteamos todos los temas, no sólo de asignación, sino
     de datos mutables en general.@n(149)

#      :: @t(Exercise 3.20) :: Draw environment diagrams to illustrate the evaluation
#         of the sequence of expressions
     :: @t(Ejercicio 3.20) :: Dibuje diagramas de entorno para ilustrar la
        evaluación de la secuencia de expresiones

#         ..srci > scheme
#           > (define x (cons 1 2))
#           > (define z (cons x x))
#           > (set-car! (cdr z) 17)
#           > (car x)
#           17
#         < srci..
        ..srci > scheme
          > (define x (cons 1 2))
          > (define z (cons x x))
          > (set-car! (cdr z) 17)
          > (car x)
          17
        < srci..

#         using the procedural implementation of pairs given above. (Compare
#         @l(#Exercise 3.11).)
        Utilizando la implementación procedural de pares dada
        anteriormente. (Compare el @l(#Ejercicio 3.11) .)

# *** 3.3.2 <> Representing Queues
*** 3.3.2 <> Representando colas

#     The mutators @c(set-car!) and @c(set-cdr!) enable us to use pairs to construct
#     data structures that cannot be built with @c(cons), @c(car), and @c(cdr)
#     alone. This section shows how to use pairs to represent a data structure
#     called a queue. Section @l(#3.3.3) will show how to represent data structures
#     called tables.
    Los mutators @c(set-car!) y @c(set-cdr!) permitirnos usar pares para
    construir estructuras de datos que no se pueden construir con @c(cons),
    @c(car) y @c(cdr) solo. Esta sección muestra cómo usar pares para
    representar una estructura de datos llamada cola. La sección
    @l(#3.3.3) mostrará cómo representar estructuras de datos llamadas
    tablas.

#     A @e(queue) is a sequence in which items are inserted at one end (called the
#     @e(rear) of the queue) and deleted from the other end (the
#     @e(front)). @l(#Figure 3.18) shows an initially empty queue in which the items
#     @c(a) and @c(b) are inserted. Then @c(a) is removed, @c(c) and @c(d) are
#     inserted, and @c(b) is removed. Because items are always removed in the order
#     in which they are inserted, a queue is sometimes called a @e(FIFO) (first in,
#     first out) buffer.
    Una @e(cola) es una secuencia en la que los elementos se insertan en un
    extremo (llamado la @e(parte posterior) de la cola) y se eliminan del otro
    extremo (el @e(frente) ). @l(#Figura 3.18) muestra una cola
    vacía inicialmente en la que los artículos @c(a) y @c(b) se
    insertan. Entonces @c(a) se retira, @c(c) y @c(d) se insertan, y @c(b) se
    retira. Debido a que los elementos siempre se quitan en el orden en que se
    insertan, a veces se llama una cola @e(FIFO) (primero en, primero sale).

#     ..figure > @t(Figure 3.18) Queue operations.
    ..figure > @t(Figura 3.18) Operaciones de cola.

#       ..art >
#         Operation                Resulting Queue
#         (define q (make-queue))
#         (insert-queue! q 'a)     a
#         (insert-queue! q 'b)     a b
#         (delete-queue! q)        b
#         (insert-queue! q 'c)     b c
#         (insert-queue! q 'd)     b c d
#         (delete-queue! q)        c d
    #       < art..
      ..art >
        Operation                Resulting Queue
        (define q (make-queue))
        (insert-queue! q 'a)     a
        (insert-queue! q 'b)     a b
        (delete-queue! q)        b
        (insert-queue! q 'c)     b c
        (insert-queue! q 'd)     b c d
        (delete-queue! q)        c d
      < art..

# @   ..img > img/chap3/Fig3.18.std.svg
@   ..img > img/chap3/Fig3.18.std.svg

#     In terms of data abstraction, we can regard a queue as defined by the
#     following set of operations:
    En términos de abstracción de datos, podemos considerar una cola definida
    por el siguiente conjunto de operaciones:

#     - a constructor: @c[(make-queue)] returns an empty queue (a queue containing
#       no items).
    - Un constructor: @c[(make-queue)] devuelve una cola vacía (una cola que no
      contiene ningún elemento).

#     - two selectors:
    - Dos selectores:

#       ..src > scheme
#         (empty-queue? ⟨queue⟩)
#       < src..
      ..src > scheme
        (empty-queue? ⟨queue⟩)
      < src..

#       tests if the queue is empty.
      Prueba si la cola está vacía.

#       ..src > scheme
#         (front-queue ⟨queue⟩)
#       < src..
      ..src > scheme
        (front-queue ⟨queue⟩)
      < src..

#       returns the object at the front of the queue, signaling an error if the
#       queue is empty; it does not modify the queue.
      Devuelve el objeto al frente de la cola, señalando un error si la cola
      está vacía; No modifica la cola.

#     - two mutators:
    - Dos mutadores:

#       ..src > scheme
#         (insert-queue! ⟨queue⟩ ⟨item⟩)
#       < src..
      ..src > scheme
        (insert-queue! ⟨queue⟩ ⟨item⟩)
      < src..

#       inserts the item at the rear of the queue and returns the modified queue as
#       its value.
      Inserta el elemento en la parte posterior de la cola y devuelve la cola
      modificada como su valor.

#       ..src > scheme
#         (delete-queue! ⟨queue⟩)
#       < src..
      ..src > scheme
        (delete-queue! ⟨queue⟩)
      < src..

#       removes the item at the front of the queue and returns the modified queue as
#       its value, signaling an error if the queue is empty before the deletion.
      Elimina el elemento en la parte delantera de la cola y devuelve la cola
      modificada como su valor, señalando un error si la cola está vacía antes
      de la eliminación.


#     Because a queue is a sequence of items, we could certainly represent it as an
#     ordinary list; the front of the queue would be the @c(car) of the list,
#     inserting an item in the queue would amount to appending a new element at the
#     end of the list, and deleting an item from the queue would just be taking the
#     @c(cdr) of the list. However, this representation is inefficient, because in
#     order to insert an item we must scan the list until we reach the end. Since
#     the only method we have for scanning a list is by successive @c(cdr)
#     operations, this scanning requires @m[Θ(n)] steps for a list of @m(n) items. A
#     simple modification to the list representation overcomes this disadvantage by
#     allowing the queue operations to be implemented so that they require @m[Θ(1)]
#     steps; that is, so that the number of steps needed is independent of the
#     length of the queue.
    Debido a que una cola es una secuencia de elementos, ciertamente podríamos
    representarlo como una lista ordinaria; El frente de la cola sería el
    @c(car) de la lista, la inserción de un elemento en la cola equivaldría a
    añadir un nuevo elemento al final de la lista, y la eliminación de un
    elemento de la cola sólo estaría tomando el @c(cdr) de la lista. Sin
    embargo, esta representación es ineficaz, porque para insertar un ítem
    debemos escanear la lista hasta llegar al final. Dado que el único método
    que tenemos para escanear una lista es mediante @c(cdr) operaciones
    sucesivas, esta exploración requiere @m[Θ(n)] pasos para una lista de @m(n)
    elementos. Una modificación simple de la representación de lista supera esta
    desventaja al permitir que las operaciones de cola se implementen de manera
    que requieran @m(Θ (1)) pasos; es decir,

#     The difficulty with the list representation arises from the need to scan to
#     find the end of the list. The reason we need to scan is that, although the
#     standard way of representing a list as a chain of pairs readily provides us
#     with a pointer to the beginning of the list, it gives us no easily accessible
#     pointer to the end. The modification that avoids the drawback is to represent
#     the queue as a list, together with an additional pointer that indicates the
#     final pair in the list. That way, when we go to insert an item, we can consult
#     the rear pointer and so avoid scanning the list.
    La dificultad con la representación de la lista surge de la necesidad de
    explorar para encontrar el final de la lista. La razón por la que
    necesitamos escanear es que, aunque la forma estándar de representar una
    lista como una cadena de pares nos proporciona fácilmente un puntero al
    comienzo de la lista, no nos da un puntero fácilmente accesible al final. La
    modificación que evita el inconveniente es representar la cola como una
    lista, junto con un puntero adicional que indica el par final en la
    lista. De esta manera, cuando vamos a insertar un elemento, podemos
    consultar el puntero trasero y así evitar escanear la lista.

#     A queue is represented, then, as a pair of pointers, @c(front-ptr) and
#     @c(rear-ptr), which indicate, respectively, the first and last pairs in an
#     ordinary list. Since we would like the queue to be an identifiable object, we
#     can use @c(cons) to combine the two pointers. Thus, the queue itself will be
#     the @c(cons) of the two pointers. @l(#Figure 3.19) illustrates this
#     representation.
    Una cola se representa, entonces, como un par de punteros, @c(front-ptr) y
    @c(rear-ptr), que indican, respectivamente, el primer y último pares en una
    lista ordinaria. Puesto que queremos que la cola sea un objeto
    identificable, podemos usar @c(cons) para combinar los dos punteros. Por lo
    tanto, la cola en sí será el @c(cons) de los dos
    punteros. @l(#Figura 3.19) ilustra esta representación.

#     ..figure > @t(Figure 3.19) Implementation of a queue as a list with front and
#       rear pointers.
    ..figure > @t(Figura 3.19) Implementación de una cola como una lista con
      punteros delanteros y traseros.

#       ..art >
#              ╭───┬───╮
#         q ──▶│ ◆ │ ◆ ┼─────────────────────╮
#              ╰─┼─┴───╯                     │
#                │                           │
#                │ front-ptr                 │ rear-ptr
#                │                           │
#                ▼                           ▼
#              ╭───┬───╮     ╭───┬───╮     ╭───┬───╮
#              │ ◆ │ ◆ ┼────▶│ ◆ │ ◆ ┼────▶│ ◆ │ ╱ │
#              ╰─┼─┴───╯     ╰─┼─┴───╯     ╰─┼─┴───╯
#                │             │             │
#                ▼             ▼             ▼
#              ╭───╮         ╭───╮         ╭───╮
#              │ a │         │ b │         │ c │
#              ╰───╯         ╰───╯         ╰───╯
#       < art..
      ..art >
             ╭───┬───╮
        q ──▶│ ◆ │ ◆ ┼─────────────────────╮
             ╰─┼─┴───╯                     │
               │                           │
               │ front-ptr                 │ rear-ptr
               │                           │
               ▼                           ▼
             ╭───┬───╮     ╭───┬───╮     ╭───┬───╮
             │ ◆ │ ◆ ┼────▶│ ◆ │ ◆ ┼────▶│ ◆ │ ╱ │
             ╰─┼─┴───╯     ╰─┼─┴───╯     ╰─┼─┴───╯
               │             │             │
               ▼             ▼             ▼
             ╭───╮         ╭───╮         ╭───╮
             │ a │         │ b │         │ c │
             ╰───╯         ╰───╯         ╰───╯
      < art..

# @   ..img > img/chap3/Fig3.19b.std.svg
@   ..img > img/chap3/Fig3.19b.std.svg

#     To define the queue operations we use the following procedures, which enable
#     us to select and to modify the front and rear pointers of a queue:
    Para definir las operaciones de cola utilizamos los siguientes
    procedimientos, que nos permiten seleccionar y modificar los punteros
    delantero y trasero de una cola:

#     ..src > scheme
#       (define (front-ptr queue) (car queue))
#       (define (rear-ptr queue) (cdr queue))
#       (define (set-front-ptr! queue item)
#         (set-car! queue item))
#       (define (set-rear-ptr! queue item)
#         (set-cdr! queue item))
#     < src..
    ..src > scheme
      (define (front-ptr queue) (car queue))
      (define (rear-ptr queue) (cdr queue))
      (define (set-front-ptr! queue item)
        (set-car! queue item))
      (define (set-rear-ptr! queue item)
        (set-cdr! queue item))
    < src..

#     Now we can implement the actual queue operations. We will consider a queue to
#     be empty if its front pointer is the empty list:
    Ahora podemos implementar las operaciones de cola reales. Consideraremos que
    una cola está vacía si su puntero es la lista vacía:

#     ..src > scheme
#       (define (empty-queue? queue)
#         (null? (front-ptr queue)))
#     < src..
    ..src > scheme
      (define (empty-queue? queue)
        (null? (front-ptr queue)))
    < src..

#     The @c(make-queue) constructor returns, as an initially empty queue, a pair
#     whose @c(car) and @c(cdr) are both the empty list:
    Los @c(make-queue) rendimientos constructor, como una cola inicialmente
    vacío, un par cuyo @c(car) y @c(cdr) son a la vez la lista vacía:

#     ..src > scheme
#       (define (make-queue) (cons '() '()))
#     < src..
    ..src > scheme
      (define (make-queue) (cons '() '()))
    < src..

#     To select the item at the front of the queue, we return the @c(car) of the
#     pair indicated by the front pointer:
    Para seleccionar el elemento en la parte delantera de la cola, devolvemos el
    @c(car) del par indicado por el puntero frontal:

#     ..src > scheme
#       (define (front-queue queue)
#         (if (empty-queue? queue)
#             (error "FRONT called with an
#                     empty queue" queue)
#             (car (front-ptr queue))))
#     < src..
    ..src > scheme
      (define (front-queue queue)
        (if (empty-queue? queue)
            (error "FRONT called with an
                    empty queue" queue)
            (car (front-ptr queue))))
    < src..

#     To insert an item in a queue, we follow the method whose result is indicated
#     in @l(#Figure 3.20). We first create a new pair whose @c(car) is the item to
#     be inserted and whose @c(cdr) is the empty list. If the queue was initially
#     empty, we set the front and rear pointers of the queue to this new pair.
#     Otherwise, we modify the final pair in the queue to point to the new pair, and
#     also set the rear pointer to the new pair.
    Para insertar un elemento en una cola, seguimos el método cuyo resultado se
    indica en la @l(#Figura 3.20). Primero creamos un nuevo par
    cuyo @c(car) es el elemento a insertar y cuál @c(cdr) es la lista vacía. Si
    la cola estaba inicialmente vacía, ponemos los punteros delantero y trasero
    de la cola a este nuevo par. De lo contrario, modificamos el par final en la
    cola para que apunte al nuevo par y también establezcamos el puntero
    posterior al nuevo par.

#     ..figure > @t(Figure 3.20) Result of using @c[(insert-queue! q 'd)] on the
#       queue of @l(#Figure 3.19).
    ..figure > @t(Figura 3.20) Resultado del uso @c[(insert-queue! q 'd)] en la
      cola de la @l(#Figura 3.19).

#       ..art >
#              ╭───┬───╮
#         q ──▶│ ◆ │ ◆ ┼─────────────────────────────────╮
#              ╰─┼─┴───╯                                 │
#                │                                       │
#                │ front-ptr                             │ rear-ptr
#                │                                       │
#                ▼                                       ▼
#            ╭───┬───╮     ╭───┬───╮     ╭───┬───╮     ╭───┬───╮
#            │ ◆ │ ◆ ┼────▶│ ◆ │ ◆ ┼────▶│ ◆ │ ◆ ┼────▶│ ◆ │ ╱ │
#            ╰─┼─┴───╯     ╰─┼─┴───╯     ╰─┼─┴───╯     ╰─┼─┴───╯
#              │             │             │             │
#              ▼             ▼             ▼             ▼
#            ╭───╮         ╭───╮         ╭───╮         ╭───╮
#            │ a │         │ b │         │ c │         │ d │
#            ╰───╯         ╰───╯         ╰───╯         ╰───╯
#       < art..
      ..art >
             ╭───┬───╮
        q ──▶│ ◆ │ ◆ ┼─────────────────────────────────╮
             ╰─┼─┴───╯                                 │
               │                                       │
               │ front-ptr                             │ rear-ptr
               │                                       │
               ▼                                       ▼
           ╭───┬───╮     ╭───┬───╮     ╭───┬───╮     ╭───┬───╮
           │ ◆ │ ◆ ┼────▶│ ◆ │ ◆ ┼────▶│ ◆ │ ◆ ┼────▶│ ◆ │ ╱ │
           ╰─┼─┴───╯     ╰─┼─┴───╯     ╰─┼─┴───╯     ╰─┼─┴───╯
             │             │             │             │
             ▼             ▼             ▼             ▼
           ╭───╮         ╭───╮         ╭───╮         ╭───╮
           │ a │         │ b │         │ c │         │ d │
           ╰───╯         ╰───╯         ╰───╯         ╰───╯
      < art..

# @   ..img > img/chap3/Fig3.20c.std.svg
@   ..img > img/chap3/Fig3.20c.std.svg

#     ..src > scheme
#       (define (insert-queue! queue item)
#         (let ((new-pair (cons item '())))
#           (cond ((empty-queue? queue)
#                  (set-front-ptr! queue new-pair)
#                  (set-rear-ptr! queue new-pair)
#                  queue)
#                 (else (set-cdr! (rear-ptr queue)
#                                 new-pair)
#                       (set-rear-ptr! queue new-pair)
#                       queue))))
#     < src..
    ..src > scheme
      (define (insert-queue! queue item)
        (let ((new-pair (cons item '())))
          (cond ((empty-queue? queue)
                 (set-front-ptr! queue new-pair)
                 (set-rear-ptr! queue new-pair)
                 queue)
                (else (set-cdr! (rear-ptr queue)
                                new-pair)
                      (set-rear-ptr! queue new-pair)
                      queue))))
    < src..

#     To delete the item at the front of the queue, we merely modify the front
#     pointer so that it now points at the second item in the queue, which can be
#     found by following the @c(cdr) pointer of the first item (see @l(#Figure
#     3.21)):@n(150)
    Para borrar el elemento en la parte delantera de la cola, simplemente
    modificamos el puntero frontal para que ahora apunte al segundo elemento de
    la cola, que se puede encontrar siguiendo el @c(cdr) puntero del primer
    elemento (véase la @l(#Figura 3.21) ):@n(150)

#     ..src > scheme
#       (define (delete-queue! queue)
#         (cond ((empty-queue? queue)
#                (error "DELETE! called with
#                        an empty queue" queue))
#               (else (set-front-ptr!
#                      queue
#                      (cdr (front-ptr queue)))
#                     queue)))
#     < src..
    ..src > scheme
      (define (delete-queue! queue)
        (cond ((empty-queue? queue)
               (error "DELETE! called with
                       an empty queue" queue))
              (else (set-front-ptr!
                     queue
                     (cdr (front-ptr queue)))
                    queue)))
    < src..

#     ..figure > @t(Figure 3.21) Result of using @c[(delete-queue!  q)] on the queue
#       of @l(#Figure 3.20).
    ..figure > @t(Figura 3.21) Resultado del uso @c[(delete-queue! q)] en la
      cola de la @l(#Figura 3.20).

#       ..art >
#              ╭───┬───╮
#         q ──▶│ ◆ │ ◆ ┼───────────────────────────────────╮
#              ╰─┼─┴───╯                                   │
#                │                                         │
#                │ front-ptr                               │ rear-ptr
#                ╰─────────────╮                           │
#                              ▼                           ▼
#              ╭───┬───╮     ╭───┬───╮     ╭───┬───╮     ╭───┬───╮
#              │ ◆ │ ◆ ┼────▶│ ◆ │ ◆ ┼────▶│ ◆ │ ◆ ┼────▶│ ◆ │ ╱ │
#              ╰─┼─┴───╯     ╰─┼─┴───╯     ╰─┼─┴───╯     ╰─┼─┴───╯
#                │             │             │             │
#                ▼             ▼             ▼             ▼
#              ╭───╮         ╭───╮         ╭───╮         ╭───╮
#              │ a │         │ b │         │ c │         │ d │
#              ╰───╯         ╰───╯         ╰───╯         ╰───╯
#       < art..
      ..art >
             ╭───┬───╮
        q ──▶│ ◆ │ ◆ ┼───────────────────────────────────╮
             ╰─┼─┴───╯                                   │
               │                                         │
               │ front-ptr                               │ rear-ptr
               ╰─────────────╮                           │
                             ▼                           ▼
             ╭───┬───╮     ╭───┬───╮     ╭───┬───╮     ╭───┬───╮
             │ ◆ │ ◆ ┼────▶│ ◆ │ ◆ ┼────▶│ ◆ │ ◆ ┼────▶│ ◆ │ ╱ │
             ╰─┼─┴───╯     ╰─┼─┴───╯     ╰─┼─┴───╯     ╰─┼─┴───╯
               │             │             │             │
               ▼             ▼             ▼             ▼
             ╭───╮         ╭───╮         ╭───╮         ╭───╮
             │ a │         │ b │         │ c │         │ d │
             ╰───╯         ╰───╯         ╰───╯         ╰───╯
      < art..

# @   ..img > img/chap3/Fig3.21c.std.svg
@   ..img > img/chap3/Fig3.21c.std.svg

#     :: @t(Exercise 3.21) :: Ben Bitdiddle decides to test the queue implementation
#        described above. He types in the procedures to the Lisp interpreter and
#        proceeds to try them out:
    :: @t(Ejercicio 3.21) :: Ben Bitdiddle decide probar la implementación de
       cola descrita anteriormente. Escribe los procedimientos al intérprete
       Lisp y procede a probarlos:

#        ..srci > scheme
#          > (define q1 (make-queue))
#          > (insert-queue! q1 'a)
#          ((a) a)
#          > (insert-queue! q1 'b)
#          ((a b) b)
#          > (delete-queue! q1)
#          ((b) b)
#          > (delete-queue! q1)
#          (() b)
#        < srci..
       ..srci > scheme
         > (define q1 (make-queue))
         > (insert-queue! q1 'a)
         ((a) a)
         > (insert-queue! q1 'b)
         ((a b) b)
         > (delete-queue! q1)
         ((b) b)
         > (delete-queue! q1)
         (() b)
       < srci..

#        @"(It's all wrong!) he complains. @"(The interpreter's response shows that
#        the last item is inserted into the queue twice. And when I delete both
#        items, the second @c(b) is still there, so the queue isn't empty, even
#        though it's supposed to be.)  Eva Lu Ator suggests that Ben has
#        misunderstood what is happening. @"(It's not that the items are going into
#        the queue twice,) she explains. @"(It's just that the standard Lisp printer
#        doesn't know how to make sense of the queue representation. If you want to
#        see the queue printed correctly, you'll have to define your own print
#        procedure for queues.) Explain what Eva Lu is talking about. In particular,
#        show why Ben's examples produce the printed results that they do. Define a
#        procedure @c(print-queue) that takes a queue as input and prints the
#        sequence of items in the queue.
       @"(¡Está todo mal! )él se queja. @"(La respuesta del intérprete muestra
       que el último elemento se inserta en la cola dos veces. Y cuando elimino
       ambos elementos, el segundo @c(b) sigue ahí, por lo que la cola no está
       vacía, aunque se supone que es. )  Eva Lu Ator sugiere que Ben ha
       entendido mal lo que está sucediendo. @"(No es que los artículos van a la
       cola dos veces,) explica. @"(Es sólo que la impresora Lisp estándar no
       sabe cómo dar sentido a la representación de la cola. Si desea ver la
       cola impresa correctamente, tendrá que definir su propio procedimiento de
       impresión para las colas. ) Explique de qué está hablando Eva Lu. En
       particular, muestre por qué los ejemplos de Ben producen los resultados
       impresos que hacen.@c(print-queue)

#     :: @t(Exercise 3.22) :: Instead of representing a queue as a pair of pointers,
#        we can build a queue as a procedure with local state.  The local state will
#        consist of pointers to the beginning and the end of an ordinary list. Thus,
#        the @c(make-queue) procedure will have the form
    :: @t(Ejercicio 3.22) :: En lugar de representar una cola como un par de
       punteros, podemos construir una cola como un procedimiento con estado
       local. El estado local consistirá en punteros al principio y al final de
       una lista ordinaria. Así, el procedimiento @c(make-queue) tendrá la forma

#        ..src > scheme
#          (define (make-queue)
#            (let ((front-ptr … )
#                  (rear-ptr … ))
#              ⟨definitions of internal procedures⟩
#              (define (dispatch m) …)
#              dispatch))
#        < src..
       ..src > scheme
         (define (make-queue)
           (let ((front-ptr … )
                 (rear-ptr … ))
             ⟨definitions of internal procedures⟩
             (define (dispatch m) …)
             dispatch))
       < src..

#        Complete the definition of @c(make-queue) and provide implementations of
#        the queue operations using this representation.
       Completar la definición de @c(make-queue) y proporcionar implementaciones
       de las operaciones de cola utilizando esta representación.

#     :: @t(Exercise 3.23) :: A @e(deque) (@"(double-ended queue)) is a sequence in
#        which items can be inserted and deleted at either the front or the
#        rear. Operations on deques are the constructor @c(make-deque), the
#        predicate @c(empty-deque?), selectors @c(front-deque) and @c(rear-deque),
#        and mutators @c(front-insert-deque!), @c(rear-insert-deque!),
#        @c(front-delete-deque!), @c(rear-delete-deque!). Show how to represent
#        deques using pairs, and give implementations of the operations.@n(151) All
#        operations should be accomplished in @m[Θ(1)] steps.
    :: @t(Ejercicio 3.23) :: Un @e(deque) (@"(cola de doble fila) ) es una
       secuencia en la que los elementos se pueden insertar y eliminar en la
       parte delantera o trasera. Operaciones en deques son el constructor
       @c(make-deque), el predicado @c(empty-deque?), selectores @c(front-deque)
       y @c(rear-deque), y mutadores @c(front-insert-deque!),
       @c(rear-insert-deque!), @c(front-delete-deque!),
       @c(rear-delete-deque!). Muestre cómo representar deques utilizando pares,
       y dar implementaciones de las operaciones.@n(151) Todas las
       operaciones deben realizarse en @m(Θ (1)) pasos.

# *** 3.3.3 <> Representing Tables
*** 3.3.3 <> Representación de tablas

#     When we studied various ways of representing sets in @l(#Chapter 2), we
#     mentioned in section @l(#2.3.3) the task of maintaining a table of records indexed by
#     identifying keys. In the implementation of data-directed programming in
#     @l(#2.4.3), we made extensive use of two-dimensional tables, in which
#     information is stored and retrieved using two keys. Here we see how to build
#     tables as mutable list structures.
    Cuando estudiamos varias maneras de representar los conjuntos en el
    @l(#Capitulo 2), mencionamos en la seccion @l(#2.3.3) la tarea de
    mantener una tabla de registros indexados mediante claves de
    identificación. En la implementación de la programación orientada a datos en
    @l(#2.4.3), hicimos un uso extensivo de tablas bidimensionales, en
    las cuales la información es almacenada y recuperada usando dos llaves. Aquí
    vemos cómo construir tablas como estructuras de lista mutable.

#     We first consider a one-dimensional table, in which each value is stored under
#     a single key. We implement the table as a list of records, each of which is
#     implemented as a pair consisting of a key and the associated value. The
#     records are glued together to form a list by pairs whose @c(car)s point to
#     successive records. These gluing pairs are called the @e(backbone) of the
#     table. In order to have a place that we can change when we add a new record to
#     the table, we build the table as a @e(headed list). A headed list has a
#     special backbone pair at the beginning, which holds a dummy @"(record)––in
#     this case the arbitrarily chosen symbol @c(*table*).  @l(#Figure 3.22) shows
#     the box-and-pointer diagram for the table
    Consideremos primero una tabla unidimensional, en la que cada valor se
    almacena bajo una sola clave. Implementamos la tabla como una lista de
    registros, cada uno de los cuales se implementa como un par que consiste en
    una clave y el valor asociado. Los registros se pegan juntos para formar una
    lista por pares cuyo @c(car) punto s a sucesivos registros. Estos pares de
    encolado se llaman la @e(espina dorsal) de la tabla. Con el fin de tener un
    lugar que podemos cambiar cuando agregamos un nuevo registro a la tabla,
    construimos la tabla como una @e(lista encabezada). Una lista de cabezas
    tiene un par de espinas especiales al principio, que contiene un
    @"(registro) ficticio - en este caso el símbolo arbitrariamente elegido
    @c(*table*).  @l(#Figura 3.22) muestra el diagrama de cuadro
    y puntero de la tabla

#     ..src > scheme
#       a:  1
#       b:  2
#       c:  3
#     < src..
    ..src > scheme
      a:  1
      b:  2
      c:  3
    < src..

#     ..figure > @t(Figure 3.22) A table represented as a headed list.
    ..figure > @t(Figura 3.22) Una tabla representada como una lista encabezada.

#       ..art >
#           table
#             ╷
#             │
#             ▼
#         ╭───┬───╮     ╭───┬───╮     ╭───┬───╮     ╭───┬───╮
#         │ ◆ │ ◆ ┼────▶│ ◆ │ ◆ ┼────▶│ ◆ │ ◆ ┼────▶│ ◆ │ ╱ │
#         ╰─┼─┴───╯     ╰─┼─┴───╯     ╰─┼─┴───╯     ╰─┼─┴───╯
#           │             │             │             │
#           ▼             ▼             ▼             ▼
#         ┌─────────┐   ╭───┬───╮     ╭───┬───╮     ╭───┬───╮
#         │ *table* │   │ ◆ │ ◆ ┼────▶│ ◆ │ ◆ ┼────▶│ ◆ │ ◆ │
#         └─────────┘   ╰─┼─┴─┼─╯     ╰─┼─┴─┼─╯     ╰─┼─┴─┼─╯
#                         │   │         │   │         │   │
#                         ▼   ▼         ▼   ▼         ▼   ▼
#                      ╭───╮ ╭───╮   ╭───╮ ╭───╮   ╭───╮ ╭───╮
#                      │ a │ │ 1 │   │ b │ │ 2 │   │ c │ │ 3 │
#                      ╰───╯ ╰───╯   ╰───╯ ╰───╯   ╰───╯ ╰───╯
#       < art..
      ..art >
          table
            ╷
            │
            ▼
        ╭───┬───╮     ╭───┬───╮     ╭───┬───╮     ╭───┬───╮
        │ ◆ │ ◆ ┼────▶│ ◆ │ ◆ ┼────▶│ ◆ │ ◆ ┼────▶│ ◆ │ ╱ │
        ╰─┼─┴───╯     ╰─┼─┴───╯     ╰─┼─┴───╯     ╰─┼─┴───╯
          │             │             │             │
          ▼             ▼             ▼             ▼
        ┌─────────┐   ╭───┬───╮     ╭───┬───╮     ╭───┬───╮
        │ *table* │   │ ◆ │ ◆ ┼────▶│ ◆ │ ◆ ┼────▶│ ◆ │ ◆ │
        └─────────┘   ╰─┼─┴─┼─╯     ╰─┼─┴─┼─╯     ╰─┼─┴─┼─╯
                        │   │         │   │         │   │
                        ▼   ▼         ▼   ▼         ▼   ▼
                     ╭───╮ ╭───╮   ╭───╮ ╭───╮   ╭───╮ ╭───╮
                     │ a │ │ 1 │   │ b │ │ 2 │   │ c │ │ 3 │
                     ╰───╯ ╰───╯   ╰───╯ ╰───╯   ╰───╯ ╰───╯
      < art..

# @   ..img > img/chap3/Fig3.22c.std.svg
@   ..img > img/chap3/Fig3.22c.std.svg

#     To extract information from a table we use the @c(lookup) procedure, which
#     takes a key as argument and returns the associated value (or false if there is
#     no value stored under that key). @c(Lookup) is defined in terms of the
#     @c(assoc) operation, which expects a key and a list of records as arguments.
#     Note that @c(assoc) never sees the dummy record. @c(Assoc) returns the record
#     that has the given key as its @c(car).@n(152) @c(Lookup) then checks to see
#     that the resulting record returned by @c(assoc) is not false, and returns the
#     value (the @c(cdr)) of the record.
    Para extraer información de una tabla usamos el procedimiento @c(lookup),
    que toma una clave como argumento y devuelve el valor asociado (o false si
    no hay ningún valor almacenado bajo esa clave). @c(Lookup) Se define en
    términos de la @c(assoc) operación, que espera una clave y una lista de
    registros como argumentos. Tenga en cuenta que @c(assoc) nunca ve el
    registro ficticio. @c(Assoc) Devuelve el registro que tiene la clave dada
    como su @c(car).@n(152) @c(Lookup) entonces comprueba para ver que el
    registro resultante devuelto por @c(assoc) no es falso, y devuelve el valor
    (el @c(cdr)) del registro.

#     ..src > scheme
#       (define (lookup key table)
#         (let ((record (assoc key (cdr table))))
#           (if record
#               (cdr record)
#               false)))
#
#       (define (assoc key records)
#         (cond ((null? records) false)
#               ((equal? key (caar records))
#                (car records))
#               (else (assoc key (cdr records)))))
#     < src..
    ..src > scheme
      (define (lookup key table)
        (let ((record (assoc key (cdr table))))
          (if record
              (cdr record)
              false)))

      (define (assoc key records)
        (cond ((null? records) false)
              ((equal? key (caar records))
               (car records))
              (else (assoc key (cdr records)))))
    < src..

#     To insert a value in a table under a specified key, we first use @c(assoc) to
#     see if there is already a record in the table with this key. If not, we form a
#     new record by @c(cons)ing the key with the value, and insert this at the head
#     of the table's list of records, after the dummy record. If there already is a
#     record with this key, we set the @c(cdr) of this record to the designated new
#     value. The header of the table provides us with a fixed location to modify in
#     order to insert the new record.@n(153)
    Para insertar un valor en una tabla bajo una clave especificada, primero
    usamos @c(assoc) para ver si ya hay un registro en la tabla con esta
    clave. Si no es así, formamos un nuevo registro @c(cons) introduciendo la
    clave con el valor e insertándolo en la cabecera de la lista de registros de
    la tabla, después del registro ficticio. Si ya hay un registro con esta
    clave, ajustamos el @c(cdr) registro de este registro al nuevo valor
    designado. El encabezado de la tabla nos proporciona una ubicación fija a
    modificar para insertar el nuevo registro.@n(153)

#     ..src > scheme
#       (define (insert! key value table)
#         (let ((record (assoc key (cdr table))))
#           (if record
#               (set-cdr! record value)
#               (set-cdr! table
#                         (cons (cons key value)
#                               (cdr table)))))
#         'ok)
#     < src..
    ..src > scheme
      (define (insert! key value table)
        (let ((record (assoc key (cdr table))))
          (if record
              (set-cdr! record value)
              (set-cdr! table
                        (cons (cons key value)
                              (cdr table)))))
        'ok)
    < src..

#     To construct a new table, we simply create a list containing the symbol
#     @c(*table*):
    Para construir una nueva tabla, simplemente creamos una lista que contiene
    el símbolo @c(*table*):

#     ..src > scheme
#       (define (make-table)
#         (list '*table*))
#     < src..
    ..src > scheme
      (define (make-table)
        (list '*table*))
    < src..

# **** Two-dimensional tables
**** Tablas bidimensionales

#      In a two-dimensional table, each value is indexed by two keys. We can
#      construct such a table as a one-dimensional table in which each key identifies
#      a subtable. @l(#Figure 3.23) shows the box-and-pointer diagram for the table
     En una tabla bidimensional, cada valor se indexa mediante dos
     claves. Podemos construir una tabla como una tabla unidimensional en la que
     cada clave identifica una subtabla. @l(#Figura 3.23)
     muestra el diagrama de cuadro y puntero de la tabla

#      ..example >
#        math:  +: 43    letters:  a: 97
#               -: 45              b: 98
#               *: 42
#      < example..
     ..example >
       math:  +: 43    letters:  a: 97
              -: 45              b: 98
              *: 42
     < example..

#      which has two subtables. (The subtables don't need a special header symbol,
#      since the key that identifies the subtable serves this purpose.)
     Que tiene dos subtablas. (Las subtablas no necesitan un símbolo de
     encabezado especial, ya que la clave que identifica la subtabla sirve para
     este propósito.)

#      ..figure > @t(Figure 3.23) A two-dimensional table.
     ..figure > @t(Figura 3.23) Una tabla bidimensional.

#        ..art >
#          table
#            ╷
#            │
#            ▼
#          ╭───┬───╮     ╭───┬───╮     ╭───┬───╮
#          │ ◆ │ ◆ ┼────▶│ ◆ │ ◆ ┼────▶│ ◆ │ ╱ │
#          ╰─┼─┴───╯     ╰─┼─┴───╯     ╰─┼─┴───╯
#            ▼             │             ▼
#          ┌─────────┐     │           ╭───┬───╮     ╭───┬───╮     ╭───┬───╮
#          │ *table* │     │           │ ◆ │ ◆ ┼────▶│ ◆ │ ◆ ┼────▶│ ◆ │ ╱ │
#          └─────────┘     │           ╰─┼─┴───╯     ╰─┼─┴───╯     ╰─┼─┴───╯
#                          │             ▼             ▼             ▼
#                          │           ┌───────────┐ ╭───┬───╮     ╭───┬───╮
#                          │           │ *letters* │ │ ◆ │ ◆ │     │ ◆ │ ◆ │
#                          │           └───────────┘ ╰─┼─┴─┼─╯     ╰─┼─┴─┼─╯
#                          │                           ▼   ▼         ▼   ▼
#                          │                        ╭───╮╭────╮   ╭───╮╭────╮
#                          │                        │ a ││ 97 │   │ b ││ 99 │
#                          ▼                        ╰───╯╰────╯   ╰───╯╰────╯
#                        ╭───┬───╮     ╭───┬───╮     ╭───┬───╮     ╭───┬───╮
#                        │ ◆ │ ◆ ┼────▶│ ◆ │ ◆ ┼────▶│ ◆ │ ◆ ┼────▶│ ◆ │ ╱ │
#                        ╰─┼─┴───╯     ╰─┼─┴───╯     ╰─┼─┴───╯     ╰─┼─┴───╯
#                          ▼             ▼             ▼             ▼
#                        ┌────────┐    ╭───┬───╮     ╭───┬───╮     ╭───┬───╮
#                        │ *math* │    │ ◆ │ ◆ │     │ ◆ │ ◆ │     │ ◆ │ ◆ │
#                        └────────┘    ╰─┼─┴─┼─╯     ╰─┼─┴─┼─╯     ╰─┼─┴─┼─╯
#                                        ▼   ▼         ▼   ▼         ▼   ▼
#                                     ╭───╮╭────╮   ╭───╮╭────╮   ╭───╮╭────╮
#                                     │ + ││ 43 │   │ - ││ 45 │   │ * ││ 42 │
#                                     ╰───╯╰────╯   ╰───╯╰────╯   ╰───╯╰────╯
#        < art..
       ..art >
         table
           ╷
           │
           ▼
         ╭───┬───╮     ╭───┬───╮     ╭───┬───╮
         │ ◆ │ ◆ ┼────▶│ ◆ │ ◆ ┼────▶│ ◆ │ ╱ │
         ╰─┼─┴───╯     ╰─┼─┴───╯     ╰─┼─┴───╯
           ▼             │             ▼
         ┌─────────┐     │           ╭───┬───╮     ╭───┬───╮     ╭───┬───╮
         │ *table* │     │           │ ◆ │ ◆ ┼────▶│ ◆ │ ◆ ┼────▶│ ◆ │ ╱ │
         └─────────┘     │           ╰─┼─┴───╯     ╰─┼─┴───╯     ╰─┼─┴───╯
                         │             ▼             ▼             ▼
                         │           ┌───────────┐ ╭───┬───╮     ╭───┬───╮
                         │           │ *letters* │ │ ◆ │ ◆ │     │ ◆ │ ◆ │
                         │           └───────────┘ ╰─┼─┴─┼─╯     ╰─┼─┴─┼─╯
                         │                           ▼   ▼         ▼   ▼
                         │                        ╭───╮╭────╮   ╭───╮╭────╮
                         │                        │ a ││ 97 │   │ b ││ 99 │
                         ▼                        ╰───╯╰────╯   ╰───╯╰────╯
                       ╭───┬───╮     ╭───┬───╮     ╭───┬───╮     ╭───┬───╮
                       │ ◆ │ ◆ ┼────▶│ ◆ │ ◆ ┼────▶│ ◆ │ ◆ ┼────▶│ ◆ │ ╱ │
                       ╰─┼─┴───╯     ╰─┼─┴───╯     ╰─┼─┴───╯     ╰─┼─┴───╯
                         ▼             ▼             ▼             ▼
                       ┌────────┐    ╭───┬───╮     ╭───┬───╮     ╭───┬───╮
                       │ *math* │    │ ◆ │ ◆ │     │ ◆ │ ◆ │     │ ◆ │ ◆ │
                       └────────┘    ╰─┼─┴─┼─╯     ╰─┼─┴─┼─╯     ╰─┼─┴─┼─╯
                                       ▼   ▼         ▼   ▼         ▼   ▼
                                    ╭───╮╭────╮   ╭───╮╭────╮   ╭───╮╭────╮
                                    │ + ││ 43 │   │ - ││ 45 │   │ * ││ 42 │
                                    ╰───╯╰────╯   ╰───╯╰────╯   ╰───╯╰────╯
       < art..

# @    ..img > img/chap3/Fig3.23b.std.svg
@    ..img > img/chap3/Fig3.23b.std.svg

#      When we look up an item, we use the first key to identify the correct
#      subtable.  Then we use the second key to identify the record within the
#      subtable.
     Cuando buscamos un elemento, utilizamos la primera clave para identificar
     la subtabla correcta. Luego usamos la segunda clave para identificar el
     registro dentro de la subtabla.

#      ..src > scheme
#        (define (lookup key-1 key-2 table)
#          (let ((subtable (assoc key-1 (cdr table))))
#            (if subtable
#                (let ((record
#                       (assoc key-2 (cdr subtable))))
#                  (if record (cdr record) false))
#                false)))
#      < src..
     ..src > scheme
       (define (lookup key-1 key-2 table)
         (let ((subtable (assoc key-1 (cdr table))))
           (if subtable
               (let ((record
                      (assoc key-2 (cdr subtable))))
                 (if record (cdr record) false))
               false)))
     < src..

#      To insert a new item under a pair of keys, we use @c(assoc) to see if there is
#      a subtable stored under the first key. If not, we build a new subtable
#      containing the single record (@c(key-2), @c(value)) and insert it into the
#      table under the first key. If a subtable already exists for the first key, we
#      insert the new record into this subtable, using the insertion method for
#      one-dimensional tables described above:
     Para insertar un nuevo elemento bajo un par de teclas, usamos @c(assoc)
     para ver si hay una subtabla almacenada bajo la primera clave. Si no,
     construimos una nueva subtabla que contiene el registro único (@c(key-2),
     @c(value)) y lo insertamos en la tabla debajo de la primera clave. Si ya
     existe una subtabla para la primera clave, insertamos el nuevo registro en
     esta subtabla, utilizando el método de inserción para las tablas
     unidimensionales descritas anteriormente:

#      ..src > scheme
#        (define (insert! key-1 key-2 value table)
#          (let ((subtable (assoc key-1 (cdr table))))
#            (if subtable
#                (let ((record
#                       (assoc key-2 (cdr subtable))))
#                  (if record
#                      (set-cdr! record value)
#                      (set-cdr!
#                       subtable
#                       (cons (cons key-2 value)
#                             (cdr subtable)))))
#                (set-cdr!
#                 table
#                 (cons (list key-1 (cons key-2 value))
#                       (cdr table)))))
#          'ok)
#      < src..
     ..src > scheme
       (define (insert! key-1 key-2 value table)
         (let ((subtable (assoc key-1 (cdr table))))
           (if subtable
               (let ((record
                      (assoc key-2 (cdr subtable))))
                 (if record
                     (set-cdr! record value)
                     (set-cdr!
                      subtable
                      (cons (cons key-2 value)
                            (cdr subtable)))))
               (set-cdr!
                table
                (cons (list key-1 (cons key-2 value))
                      (cdr table)))))
         'ok)
     < src..

# **** Creating local tables
**** Creación de tablas locales

#      The @c(lookup) and @c(insert!) operations defined above take the table as an
#      argument. This enables us to use programs that access more than one table.
#      Another way to deal with multiple tables is to have separate @c(lookup) and
#      @c(insert!) procedures for each table. We can do this by representing a table
#      procedurally, as an object that maintains an internal table as part of its
#      local state. When sent an appropriate message, this @"(table object) supplies
#      the procedure with which to operate on the internal table. Here is a generator
#      for two-dimensional tables represented in this fashion:
     Los @c(lookup) y @c(insert!) las operaciones definidas anteriormente toman
     la tabla como argumento. Esto nos permite usar programas que acceden a más
     de una tabla. Otra manera de tratar con varias tablas es tener separada
     @c(lookup) y @c(insert!) procedimientos para cada tabla. Podemos hacerlo
     representando una tabla proceduralmente, como un objeto que mantiene una
     tabla interna como parte de su estado local. Cuando se envía un mensaje
     apropiado, este @"(objeto de tabla) suministra el procedimiento con el cual
     operar en la tabla interna. Aquí está un generador para las tablas
     bidimensionales representadas de esta manera:

#      ..src > scheme
#        (define (make-table)
#          (let ((local-table (list '*table*)))
#            (define (lookup key-1 key-2)
#              (let ((subtable
#                     (assoc key-1 (cdr local-table))))
#                (if subtable
#                    (let ((record
#                           (assoc key-2
#                                  (cdr subtable))))
#                      (if record (cdr record) false))
#                    false)))
#            (define (insert! key-1 key-2 value)
#              (let ((subtable
#                     (assoc key-1 (cdr local-table))))
#                (if subtable
#                    (let ((record
#                           (assoc key-2
#                                  (cdr subtable))))
#                      (if record
#                          (set-cdr! record value)
#                          (set-cdr!
#                           subtable
#                           (cons (cons key-2 value)
#                                 (cdr subtable)))))
#                    (set-cdr!
#                     local-table
#                     (cons (list key-1
#                                 (cons key-2 value))
#                           (cdr local-table)))))
#              'ok)
#            (define (dispatch m)
#              (cond ((eq? m 'lookup-proc) lookup)
#                    ((eq? m 'insert-proc!) insert!)
#                    (else (error "Unknown operation:
#                                  TABLE" m))))
#            dispatch))
#      < src..
     ..src > scheme
       (define (make-table)
         (let ((local-table (list '*table*)))
           (define (lookup key-1 key-2)
             (let ((subtable
                    (assoc key-1 (cdr local-table))))
               (if subtable
                   (let ((record
                          (assoc key-2
                                 (cdr subtable))))
                     (if record (cdr record) false))
                   false)))
           (define (insert! key-1 key-2 value)
             (let ((subtable
                    (assoc key-1 (cdr local-table))))
               (if subtable
                   (let ((record
                          (assoc key-2
                                 (cdr subtable))))
                     (if record
                         (set-cdr! record value)
                         (set-cdr!
                          subtable
                          (cons (cons key-2 value)
                                (cdr subtable)))))
                   (set-cdr!
                    local-table
                    (cons (list key-1
                                (cons key-2 value))
                          (cdr local-table)))))
             'ok)
           (define (dispatch m)
             (cond ((eq? m 'lookup-proc) lookup)
                   ((eq? m 'insert-proc!) insert!)
                   (else (error "Unknown operation:
                                 TABLE" m))))
           dispatch))
     < src..

#      Using @c(make-table), we could implement the @c(get) and @c(put) operations
#      used in section @l(#2.4.3) for data-directed programming, as follows:
     Utilizando @c(make-table), podríamos implementar las operaciones @c(get) y
     @c(put) las utilizadas en la seccion @l(#2.4.3) para la programación dirigida a
     datos, de la siguiente manera:

#      ..src > scheme
#        (define operation-table (make-table))
#        (define get (operation-table 'lookup-proc))
#        (define put (operation-table 'insert-proc!))
#      < src..
     ..src > scheme
       (define operation-table (make-table))
       (define get (operation-table 'lookup-proc))
       (define put (operation-table 'insert-proc!))
     < src..

#      @c(Get) takes as arguments two keys, and @c(put) takes as arguments two keys
#      and a value. Both operations access the same local table, which is
#      encapsulated within the object created by the call to @c(make-table).
     @c(Get) Toma como argumentos dos claves, y @c(put) toma como argumentos dos
     claves y un valor. Ambas operaciones acceden a la misma tabla local, que
     está encapsulada dentro del objeto creado por la llamada a @c(make-table).

#      :: @t(Exercise 3.24) :: In the table implementations above, the keys are
#         tested for equality using @c(equal?) (called by @c(assoc)). This is not
#         always the appropriate test. For instance, we might have a table with
#         numeric keys in which we don't need an exact match to the number we're
#         looking up, but only a number within some tolerance of it.  Design a table
#         constructor @c(make-table) that takes as an argument a @c(same-key?)
#         procedure that will be used to test @"(equality) of keys.  @c(Make-table)
#         should return a @c(dispatch) procedure that can be used to access
#         appropriate @c(lookup) and @c(insert!) procedures for a local table.
     :: @t(Ejercicio 3.24) :: En las implementaciones de tabla anteriores, las
        claves se prueban para la igualdad usando @c(equal?)(llamado por
        @c(assoc)). Esto no siempre es la prueba apropiada. Por ejemplo,
        podríamos tener una tabla con teclas numéricas en las que no necesitamos
        una coincidencia exacta con el número que buscamos, sino sólo un número
        dentro de alguna tolerancia. Diseñe un constructor de tablas
        @c(make-table) que tome como argumento un procedimiento @c(same-key?)
        que se utilizará para probar la @"(igualdad) de claves.  @c(Make-table)
        Debe devolver un procedimiento @c(dispatch) que se puede utilizar para
        acceder a procedimientos apropiados @c(lookup) y @c(insert!) para una
        tabla local.

#      :: @t(Exercise 3.25) :: Generalizing one- and two-dimensional tables, show how
#         to implement a table in which values are stored under an arbitrary number
#         of keys and different values may be stored under different numbers of
#         keys. The @c(lookup) and @c(insert!)  procedures should take as input a
#         list of keys used to access the table.
     :: @t(Ejercicio 3.25) :: Generalizando tablas unidimensionales y
        bidimensionales, se muestra cómo implementar una tabla en la que los
        valores se almacenan bajo un número arbitrario de claves y se pueden
        almacenar diferentes valores bajo diferentes números de claves. Los
        procedimientos @c(lookup) y @c(insert!) deben tomar como entrada una
        lista de teclas utilizadas para acceder a la tabla.

#      :: @t(Exercise 3.26) :: To search a table as implemented above, one needs to
#         scan through the list of records. This is basically the unordered list
#         representation of section @l(#2.3.3). For large tables, it may be more efficient to
#         structure the table in a different manner. Describe a table implementation
#         where the (key, value) records are organized using a binary tree, assuming
#         that keys can be ordered in some way (e.g., numerically or
#         alphabetically). (Compare @l(#Exercise 2.66) of @l(#Chapter 2).)
     :: @t(Ejercicio 3.26) :: Para buscar en una tabla como se implementó
        anteriormente, es necesario explorar la lista de registros. Esta es
        básicamente la representación de la lista desordenada de
        @l(#2.3.3). Para las tablas grandes, puede ser más eficiente
        estructurar la tabla de una manera diferente. Describa una
        implementación de tabla donde los registros (clave, valor) se organizan
        utilizando un árbol binario, suponiendo que las claves se pueden ordenar
        de alguna manera (por ejemplo, numéricamente o
        alfabéticamente). (Compare el @l(#Ejercicio 2.66) del
        @l(#Capitulo 2) ).

#      :: @t(Exercise 3.27) :: @e(Memoization) (also called @e(tabulation)) is a
#         technique that enables a procedure to record, in a local table, values that
#         have previously been computed. This technique can make a vast difference in
#         the performance of a program. A memoized procedure maintains a table in
#         which values of previous calls are stored using as keys the arguments that
#         produced the values. When the memoized procedure is asked to compute a
#         value, it first checks the table to see if the value is already there and,
#         if so, just returns that value. Otherwise, it computes the new value in the
#         ordinary way and stores this in the table. As an example of memoization,
#         recall from @l(#1.2.2) the exponential process for computing Fibonacci
#         numbers:
     :: @t(Ejercicio 3.27) :: @e(Memoization) (también llamada @e(tabulación) )
        es una técnica que permite a un procedimiento registrar, en una tabla
        local, los valores que se han calculado previamente. Esta técnica puede
        hacer una gran diferencia en el rendimiento de un programa. Un
        procedimiento memorizado mantiene una tabla en la que los valores de las
        llamadas anteriores se almacenan utilizando como teclas los argumentos
        que produjeron los valores. Cuando se solicita al procedimiento memoized
        para calcular un valor, primero verifica la tabla para ver si el valor
        ya está allí y, si es así, simplemente devuelve ese valor. De lo
        contrario, calcula el nuevo valor de la manera ordinaria y lo almacena
        en la tabla. Como un ejemplo de memoization, recuerda de
        @l(#1.2.2) el proceso exponencial para calcular números de
        Fibonacci:

#         ..src > scheme
#           (define (fib n)
#             (cond ((= n 0) 0)
#                   ((= n 1) 1)
#                   (else (+ (fib (- n 1))
#                            (fib (- n 2))))))
#         < src..
        ..src > scheme
          (define (fib n)
            (cond ((= n 0) 0)
                  ((= n 1) 1)
                  (else (+ (fib (- n 1))
                           (fib (- n 2))))))
        < src..

#         The memoized version of the same procedure is
        La versión memorizada del mismo procedimiento es

#         ..src > scheme
#           (define memo-fib
#             (memoize
#              (lambda (n)
#                (cond ((= n 0) 0)
#                      ((= n 1) 1)
#                      (else
#                       (+ (memo-fib (- n 1))
#                          (memo-fib (- n 2))))))))
#         < src..
        ..src > scheme
          (define memo-fib
            (memoize
             (lambda (n)
               (cond ((= n 0) 0)
                     ((= n 1) 1)
                     (else
                      (+ (memo-fib (- n 1))
                         (memo-fib (- n 2))))))))
        < src..

#         where the memoizer is defined as
        Donde el memoizer se define como

#         ..src > scheme
#           (define (memoize f)
#             (let ((table (make-table)))
#               (lambda (x)
#                 (let ((previously-computed-result
#                        (lookup x table)))
#                   (or previously-computed-result
#                       (let ((result (f x)))
#                         (insert! x result table)
#                         result))))))
#         < src..
        ..src > scheme
          (define (memoize f)
            (let ((table (make-table)))
              (lambda (x)
                (let ((previously-computed-result
                       (lookup x table)))
                  (or previously-computed-result
                      (let ((result (f x)))
                        (insert! x result table)
                        result))))))
        < src..

#         Draw an environment diagram to analyze the computation of @c[(memo-fib 3)].
#         Explain why @c(memo-fib) computes the @m(nᵗʰ) Fibonacci number in a number
#         of steps proportional to @m(n). Would the scheme still work if we had
#         simply defined @c(memo-fib) to be @c[(memoize fib)]?
        Dibuja un diagrama de entorno para analizar el cálculo de @c[(memo-fib
        3)]. Explique por qué @c(memo-fib) calcula el número @m(nᵗʰ) Fibonacci
        en un número de pasos proporcionales a @m(n). Sería el régimen sigue
        funcionará si simplemente habíamos definido @c(memo-fib) para ser
        @c[(memoize fib)]?

# *** 3.3.4 <> A Simulator for Digital Circuits
*** 3.3.4 <> Un simulador para circuitos digitales

#     Designing complex digital systems, such as computers, is an important
#     engineering activity. Digital systems are constructed by interconnecting
#     simple elements. Although the behavior of these individual elements is simple,
#     networks of them can have very complex behavior. Computer simulation of
#     proposed circuit designs is an important tool used by digital systems
#     engineers. In this section we design a system for performing digital logic
#     simulations. This system typifies a kind of program called an @e(event-driven
#     simulation), in which actions (@"(events)) trigger further events that happen
#     at a later time, which in turn trigger more events, and so on.
    El diseño de sistemas digitales complejos, como las computadoras, es una
    actividad de ingeniería importante. Los sistemas digitales se construyen
    interconectando elementos simples. Aunque el comportamiento de estos
    elementos individuales es simple, las redes de ellos pueden tener un
    comportamiento muy complejo. La simulación por ordenador de los diseños de
    circuitos propuestos es una herramienta importante utilizada por los
    ingenieros de sistemas digitales. En esta sección diseñamos un sistema para
    realizar simulaciones de lógica digital. Este sistema tipifica un tipo de
    programa llamado @e(simulación dirigida por eventos), en la cual las
    acciones (@"(eventos) ) activan eventos adicionales que suceden en un
    momento posterior, que a su vez activan más eventos, y así sucesivamente.

#     Our computational model of a circuit will be composed of objects that
#     correspond to the elementary components from which the circuit is constructed.
#     There are @e(wires), which carry @e(digital signals). A digital signal may at
#     any moment have only one of two possible values, 0 and 1. There are also
#     various types of digital @e(function boxes), which connect wires carrying
#     input signals to other output wires. Such boxes produce output signals
#     computed from their input signals. The output signal is delayed by a time that
#     depends on the type of the function box. For example, an @e(inverter) is a
#     primitive function box that inverts its input. If the input signal to an
#     inverter changes to 0, then one inverter-delay later the inverter will change
#     its output signal to 1. If the input signal to an inverter changes to 1, then
#     one inverter-delay later the inverter will change its output signal to 0. We
#     draw an inverter symbolically as in @l(#Figure 3.24).  An @e(and-gate), also
#     shown in figure 3.24, is a primitive function box with two inputs and one
#     output. It drives its output signal to a value that is the @e(logical and) of
#     the inputs. That is, if both of its input signals become 1, then one
#     and-gate-delay time later the and-gate will force its output signal to be 1;
#     otherwise the output will be 0. An @e(or-gate) is a similar two-input
#     primitive function box that drives its output signal to a value that is the
#     @e(logical or) of the inputs. That is, the output will become 1 if at least
#     one of the input signals is 1; otherwise the output will become 0.
    Nuestro modelo computacional de un circuito estará compuesto de objetos que
    corresponden a los componentes elementales a partir de los cuales se
    construye el circuito. Hay @e(cables), que llevan @e(señales digitales). Una
    señal digital puede tener en cualquier momento sólo uno de dos valores
    posibles, 0 y 1. También hay varios tipos de @e(cajas de funciones)
    digitales, que conectan cables que transportan señales de entrada a otros
    cables de salida. Dichas cajas producen señales de salida calculadas a
    partir de sus señales de entrada. La señal de salida se retrasa en un tiempo
    que depende del tipo de la caja de funciones. Por ejemplo, un @e(inversor)
    es una caja de función primitiva que invierte su entrada. Si la señal de
    entrada a un inversor cambia a 0, entonces un inversor-retrasa más adelante
    el inversor cambiará su señal de salida a 1. @l(#Figure-3.24<>Si la señal de
    entrada a un inversor cambia a 1, entonces un inversor-retardo más tarde el
    inversor cambiará su señal de salida a 0. Dibujamos un inversor
    simbólicamente como en la figura 3.24). Una @e(y-puerta), también mostrada
    en la figura 3.24, es una caja de función primitiva con dos entradas y una
    salida. Conduce su señal de salida a un valor que es el @e(lógico y) de las
    entradas. Es decir, si ambas de sus señales de entrada llegan a ser 1,
    entonces un tiempo de retardo de puerta y puerta más tarde la puerta-y-
    forzará su señal de salida a ser 1; De lo contrario la salida será 0. Una
    @e(o-puerta) es una caja de función primitiva de dos entradas similar que
    impulsa su señal de salida a un valor que es el @e(lógico o) de las
    entradas. Es decir, la salida se convertirá en 1 si al menos una de las
    señales de entrada es 1;

#     ..figure > @t(Figure 3.24) Primitive functions in the digital logic simulator.
    ..figure > @t(Figura 3.24) Funciones primitivas en el simulador de lógica
      digital.

#       ..art >
#
#           ╭-._           ╭───-.          ─────.
#           │   `\       ──┤     \       ──\     \
#         ──┤     >○──     │      )──       )     >--
#           │ __./       ──┤     /       ──/     /
#           ╰-'            ╰────`          ─────'
#
#         Inverter       And-gate        Or-gate
#       < art..
      ..art >

          ╭-._           ╭───-.          ─────.
          │   `\       ──┤     \       ──\     \
        ──┤     >○──     │      )──       )     >--
          │ __./       ──┤     /       ──/     /
          ╰-'            ╰────`          ─────'

        Inverter       And-gate        Or-gate
      < art..

# @   ..img > img/chap3/Fig3.24a.std.svg
@   ..img > img/chap3/Fig3.24a.std.svg

#     We can connect primitive functions together to construct more complex
#     functions. To accomplish this we wire the outputs of some function boxes to
#     the inputs of other function boxes. For example, the @e(half-adder) circuit
#     shown in @l(#Figure 3.25) consists of an or-gate, two and-gates, and an
#     inverter. It takes two input signals, A and B, and has two output signals, S
#     and C. S will become 1 whenever precisely one of A and B is 1, and C will
#     become 1 whenever A and B are both 1. We can see from the figure that, because
#     of the delays involved, the outputs may be generated at different times. Many
#     of the difficulties in the design of digital circuits arise from this fact.
    Podemos conectar funciones primitivas para construir funciones más
    complejas. Para lograr esto, cableamos las salidas de algunos cuadros de
    función a las entradas de otras cajas de funciones. Por ejemplo, el circuito
    de @e(medio-sumador) mostrado en la @l(#Figura 3.25) consta de
    una o-puerta, dos y-puertas, y un inversor. Se toman dos señales de entrada,
    A y B, y tiene dos señales de salida, S y C. S se convertirá en 1 cuando
    cada uno de A y B sea 1, y C se convertirá en 1 cuando A y B son
    ambos 1. Podemos ver De la figura que, debido a los retrasos implicados, las
    salidas pueden ser generadas en momentos diferentes. Muchas de las
    dificultades en el diseño de circuitos digitales surgen de este hecho.

#     ..figure > @t(Figure 3.25) A half-adder circuit.
    ..figure > @t(Figura 3.25) Un circuito de medio sumidero.

#       ..art >
#             ╭───────────────────────────────────────╮
#             │         ____                          │
#         A ──┼─────●───\   \ D                ___    │
#             │     │    >   >────────────────│   \   │
#             │  ╭──│───/___/                 │    )──┼── S
#             │  │  │              │\.  E  ╭──│___/   │
#             │  │  │           ╭──│  >○───╯          │
#             │  │  │    ___    │  │/`                │
#             │  │  ╰───│   \   │                     │
#             │  │      │    )──●─────────────────────┼── C
#         B ──┼──●──────│___/                         │
#             │                                       │
#             ╰───────────────────────────────────────╯
#       < art..
      ..art >
            ╭───────────────────────────────────────╮
            │         ____                          │
        A ──┼─────●───\   \ D                ___    │
            │     │    >   >────────────────│   \   │
            │  ╭──│───/___/                 │    )──┼── S
            │  │  │              │\.  E  ╭──│___/   │
            │  │  │           ╭──│  >○───╯          │
            │  │  │    ___    │  │/`                │
            │  │  ╰───│   \   │                     │
            │  │      │    )──●─────────────────────┼── C
        B ──┼──●──────│___/                         │
            │                                       │
            ╰───────────────────────────────────────╯
      < art..

# @   ..img > img/chap3/Fig3.25c.std.svg
@   ..img > img/chap3/Fig3.25c.std.svg

#     We will now build a program for modeling the digital logic circuits we wish to
#     study. The program will construct computational objects modeling the wires,
#     which will @"(hold) the signals. Function boxes will be modeled by procedures
#     that enforce the correct relationships among the signals.
    Ahora vamos a construir un programa para modelar los circuitos lógicos
    digitales que deseamos estudiar. El programa construirá objetos
    computacionales modelando los alambres, que @"(mantendrán) las señales. Los
    cuadros de funciones se modelarán mediante procedimientos que impongan las
    relaciones correctas entre las señales.

#     One basic element of our simulation will be a procedure @c(make-wire), which
#     constructs wires. For example, we can construct six wires as follows:
    Un elemento básico de nuestra simulación será un procedimiento
    @c(make-wire), el cual construye cables. Por ejemplo, podemos construir seis
    cables como sigue:

#     ..src > scheme
#       (define a (make-wire))
#       (define b (make-wire))
#       (define c (make-wire))
#       (define d (make-wire))
#       (define e (make-wire))
#       (define s (make-wire))
#     < src..
    ..src > scheme
      (define a (make-wire))
      (define b (make-wire))
      (define c (make-wire))
      (define d (make-wire))
      (define e (make-wire))
      (define s (make-wire))
    < src..

#     We attach a function box to a set of wires by calling a procedure that
#     constructs that kind of box. The arguments to the constructor procedure are
#     the wires to be attached to the box. For example, given that we can construct
#     and-gates, or-gates, and inverters, we can wire together the half-adder shown
#     in @l(#Figure 3.25):
    Adjuntamos un cuadro de función a un conjunto de cables llamando a un
    procedimiento que construye ese tipo de cuadro. Los argumentos para el
    procedimiento del constructor son los cables que se van a adjuntar a la
    caja. Por ejemplo, dado que podemos construir y-puertas, o-puertas, e
    inversores, podemos cablear juntos el medio-sumador mostrado en la
    @l(#Figura 3.25) :

#     ..srci > scheme
#       > (or-gate a b d)
#       ok
#       > (and-gate a b c)
#       ok
#       > (inverter c e)
#       ok
#       > (and-gate d e s)
#       ok
#     < srci..
    ..srci > scheme
      > (or-gate a b d)
      ok
      > (and-gate a b c)
      ok
      > (inverter c e)
      ok
      > (and-gate d e s)
      ok
    < srci..

#     Better yet, we can explicitly name this operation by defining a procedure
#     @c(half-adder) that constructs this circuit, given the four external wires to
#     be attached to the half-adder:
    Mejor aún, podemos nombrar explícitamente esta operación definiendo un
    procedimiento @c(half-adder) que construye este circuito, dados los cuatro
    cables externos que se van a conectar al semidulador:

#     ..src > scheme
#       (define (half-adder a b s c)
#         (let ((d (make-wire)) (e (make-wire)))
#           (or-gate a b d)
#           (and-gate a b c)
#           (inverter c e)
#           (and-gate d e s)
#           'ok))
#     < src..
    ..src > scheme
      (define (half-adder a b s c)
        (let ((d (make-wire)) (e (make-wire)))
          (or-gate a b d)
          (and-gate a b c)
          (inverter c e)
          (and-gate d e s)
          'ok))
    < src..

#     The advantage of making this definition is that we can use @c(half-adder)
#     itself as a building block in creating more complex circuits. @l(#Figure
#     3.26), for example, shows a @e(full-adder) composed of two half-adders and an
#     or-gate.@n(154) We can construct a full-adder as follows:
    La ventaja de hacer esta definición es que podemos @c(half-adder) usarnos
    como un bloque de construcción para crear circuitos más
    complejos. @l(#Figura 3.26), por ejemplo, muestra un
    @e(sumador completo) compuesto por dos medios sumadores y un
    or-gate.@n(154) Podemos construir un sumador completo como sigue:

#     ..src > scheme
#       (define (full-adder a b c-in sum c-out)
#         (let ((c1 (make-wire))
#               (c2 (make-wire))
#               (s  (make-wire)))
#           (half-adder b c-in s c1)
#           (half-adder a s sum c2)
#           (or-gate c1 c2 c-out)
#           'ok))
#     < src..
    ..src > scheme
      (define (full-adder a b c-in sum c-out)
        (let ((c1 (make-wire))
              (c2 (make-wire))
              (s  (make-wire)))
          (half-adder b c-in s c1)
          (half-adder a s sum c2)
          (or-gate c1 c2 c-out)
          'ok))
    < src..

#     ..figure > @t(Figure 3.26) A full-adder circuit.
    ..figure > @t(Figura 3.26) Un circuito de sumador completo.

#       ..art >
#               ╭──────────────────────────────────╮
#               │              ╭───────╮           │
#          A  ──┼──────────────┤ half- ├───────────┼── SUM
#               │  ╭───────╮   │ adder │   ____    │
#          B  ──┼──┤ half- ├───┤       ├───\   \   │
#               │  │ adder │   ╰───────╯    >or >──┼── Cₒᵤₜ
#         Cᵢₙ ──┼──┤       ├───────────────/___/   │
#               │  ╰───────╯                       │
#               ╰──────────────────────────────────╯
#       < art..
      ..art >
              ╭──────────────────────────────────╮
              │              ╭───────╮           │
         A  ──┼──────────────┤ half- ├───────────┼── SUM
              │  ╭───────╮   │ adder │   ____    │
         B  ──┼──┤ half- ├───┤       ├───\   \   │
              │  │ adder │   ╰───────╯    >or >──┼── Cₒᵤₜ
        Cᵢₙ ──┼──┤       ├───────────────/___/   │
              │  ╰───────╯                       │
              ╰──────────────────────────────────╯
      < art..

# @   ..img > img/chap3/Fig3.26.std.svg
@   ..img > img/chap3/Fig3.26.std.svg

#     Having defined @c(full-adder) as a procedure, we can now use it as a building
#     block for creating still more complex circuits. (For example, see @l(#Exercise
#     3.30).)
    Definido @c(full-adder) como un procedimiento, ahora podemos usarlo como un
    bloque de construcción para crear circuitos aún más complejos. (Por ejemplo,
    véase el @l(#Ejercicio 3.30) .)

#     In essence, our simulator provides us with the tools to construct a language
#     of circuits. If we adopt the general perspective on languages with which we
#     approached the study of Lisp in section @l(#1.1), we can say that the primitive
#     function boxes form the primitive elements of the language, that wiring boxes
#     together provides a means of combination, and that specifying wiring patterns
#     as procedures serves as a means of abstraction.
    En esencia, nuestro simulador nos proporciona las herramientas para
    construir un lenguaje de circuitos. Si adoptamos la perspectiva general de
    los lenguajes con los que abordamos el estudio de Lisp en la seccion @l(#1.1),
    podemos decir que las cajas de funciones primitivas forman los elementos
    primitivos del lenguaje, que las cajas de cableado proporcionan un medio de
    combinación y que se especifican los patrones de cableado Ya que los
    procedimientos sirven como un medio de abstracción.

# **** Primitive function boxes
**** Cajas de funciones primitivas

#      The primitive function boxes implement the @"(forces) by which a change in the
#      signal on one wire influences the signals on other wires. To build function
#      boxes, we use the following operations on wires:
     Las cajas de funciones primitivas implementan las @"(fuerzas) por las
     cuales un cambio en la señal en un hilo influye en las señales en otros
     hilos. Para crear cuadros de funciones, usamos las siguientes operaciones
     en los cables:

#      - @c[(get-signal ⟨wire⟩)]
     - @c[(get-signal ⟨wire⟩)]

#        returns the current value of the signal on the wire.
       Devuelve el valor actual de la señal en el cable.

#      - @c[(set-signal! ⟨wire⟩ ⟨new value⟩)]
     - @c[(set-signal! ⟨wire⟩ ⟨new value⟩)]

#        changes the value of the signal on the wire to the new value.
       Cambia el valor de la señal en el cable al nuevo valor.

#      - @c[(add-action! ⟨wire⟩ ⟨procedure of no arguments⟩)]
     - @c[(add-action! ⟨wire⟩ ⟨procedure of no arguments⟩)]

#        asserts that the designated procedure should be run whenever the signal on the
#        wire changes value. Such procedures are the vehicles by which changes in the
#        signal value on the wire are communicated to other wires.
       Afirma que el procedimiento designado debe ejecutarse siempre que la
       señal en el cable cambie de valor. Tales procedimientos son los vehículos
       por los cuales los cambios en el valor de señal en el alambre se
       comunican a otros alambres.


#      In addition, we will make use of a procedure @c(after-delay) that takes a time
#      delay and a procedure to be run and executes the given procedure after the
#      given delay.
     Además, haremos uso de un procedimiento @c(after-delay) que toma un tiempo
     de demora y un procedimiento para ser ejecutado y ejecuta el procedimiento
     dado después de la demora dada.

#      Using these procedures, we can define the primitive digital logic functions.
#      To connect an input to an output through an inverter, we use @c(add-action!)
#      to associate with the input wire a procedure that will be run whenever the
#      signal on the input wire changes value. The procedure computes the
#      @c(logical-not) of the input signal, and then, after one @c(inverter-delay),
#      sets the output signal to be this new value:
     Usando estos procedimientos, podemos definir las primitivas funciones de la
     lógica digital. Para conectar una entrada a una salida a través de un
     inversor, usamos @c(add-action!) para asociar con el cable de entrada un
     procedimiento que se ejecutará cada vez que la señal en el cable de entrada
     cambie de valor. El procedimiento calcula el @c(logical-not) de la señal de
     entrada, y luego, después de uno @c(inverter-delay), ajusta la señal de
     salida para ser este nuevo valor:

#      ..src > scheme
#        (define (inverter input output)
#          (define (invert-input)
#            (let ((new-value
#                   (logical-not (get-signal input))))
#              (after-delay
#               inverter-delay
#               (lambda ()
#                 (set-signal! output new-value)))))
#          (add-action! input invert-input)
#          'ok)
#
#        (define (logical-not s)
#          (cond ((= s 0) 1)
#                ((= s 1) 0)
#                (else (error "Invalid signal" s))))
#      < src..
     ..src > scheme
       (define (inverter input output)
         (define (invert-input)
           (let ((new-value
                  (logical-not (get-signal input))))
             (after-delay
              inverter-delay
              (lambda ()
                (set-signal! output new-value)))))
         (add-action! input invert-input)
         'ok)

       (define (logical-not s)
         (cond ((= s 0) 1)
               ((= s 1) 0)
               (else (error "Invalid signal" s))))
     < src..

#      An and-gate is a little more complex. The action procedure must be run if
#      either of the inputs to the gate changes. It computes the @c(logical-and)
#      (using a procedure analogous to @c(logical-not)) of the values of the signals
#      on the input wires and sets up a change to the new value to occur on the
#      output wire after one @c(and-gate-delay).
     Un and-gate es un poco más complejo. El procedimiento de acción debe
     ejecutarse si cambia cualquiera de las entradas a la puerta. Calcula el
     @c(logical-and)(utilizando un procedimiento análogo a @c(logical-not)) de
     los valores de las señales en los cables de entrada y establece un cambio
     al nuevo valor que se produce en el cable de salida después de uno
     @c(and-gate-delay).

#      ..src > scheme
#        (define (and-gate a1 a2 output)
#          (define (and-action-procedure)
#            (let ((new-value
#                   (logical-and (get-signal a1)
#                                (get-signal a2))))
#              (after-delay
#               and-gate-delay
#               (lambda ()
#                 (set-signal! output new-value)))))
#          (add-action! a1 and-action-procedure)
#          (add-action! a2 and-action-procedure)
#          'ok)
#      < src..
     ..src > scheme
       (define (and-gate a1 a2 output)
         (define (and-action-procedure)
           (let ((new-value
                  (logical-and (get-signal a1)
                               (get-signal a2))))
             (after-delay
              and-gate-delay
              (lambda ()
                (set-signal! output new-value)))))
         (add-action! a1 and-action-procedure)
         (add-action! a2 and-action-procedure)
         'ok)
     < src..

#      :: @t(Exercise 3.28) :: Define an or-gate as a primitive function box. Your
#         @c(or-gate) constructor should be similar to @c(and-gate).
     :: @t(Ejercicio 3.28) :: Defina un or-gate como una caja de función
        primitiva. Su @c(or-gate) constructor debe ser similar a @c(and-gate).

#      :: @t(Exercise 3.29) :: Another way to construct an or-gate is as a compound
#         digital logic device, built from and-gates and inverters. Define a
#         procedure @c(or-gate) that accomplishes this. What is the delay time of the
#         or-gate in terms of @c(and-gate-delay) and @c(inverter-delay)?
     :: @t(Ejercicio 3.29) :: Otra forma de construir una o-puerta es como un
        dispositivo compuesto de lógica digital, construido a partir de
        y-puertas e inversores. Defina un procedimiento @c(or-gate) que logre
        esto. ¿Cuál es el tiempo de retardo de la puerta o en términos de
        @c(and-gate-delay) y @c(inverter-delay)?

#      :: @t(Exercise 3.30) :: @l(#Figure 3.27) shows a @e(ripple-carry adder) formed
#         by stringing together @m(n) full-adders.  This is the simplest form of
#         parallel adder for adding two @m(n)-bit binary numbers. The inputs @m(A₁),
#         @m(A₂), @m(A₃), …, @m(Aₙ) and @m(B₁), @m(B₂), @m(B₃), …, @m(Bₙ) are the two
#         binary numbers to be added (each @m(Aₙ) and @m(Bₙ) is a 0 or a 1). The
#         circuit generates @m(S₁), @m(S₂), @m(S₃), …, @m(Sₙ), the @m(n) bits of the
#         sum, and @m(C), the carry from the addition. Write a procedure
#         @c(ripple-carry-adder) that generates this circuit. The procedure should
#         take as arguments three lists of @m(n) wires each––the @m(Aₙ), the @m(Bₙ),
#         and the @m(Sₙ)––and also another wire @m(C). The major drawback of the
#         ripple-carry adder is the need to wait for the carry signals to propagate.
#         What is the delay needed to obtain the complete output from an @m(n)-bit
#         ripple-carry adder, expressed in terms of the delays for and-gates,
#         or-gates, and inverters?
     :: @t(Ejercicio 3.30) :: @l(#Figura 3.27) muestra un
        @e(sumador de ondulación-transporte) formado por encordar juntos @m(n)
        sumadores completos. Esta es la forma más simple de sumador paralelo
        para agregar dos números binarios de @m(n) bits. Las entradas @m(A₁),
        @m(A₂), @m(A₃), ..., @m(Aₙ) y @m(B₁), @m(B₂), @m(B₃), ..., @m(Bₙ) son
        los dos números binarios que se han de añadir (cada @m(Aₙ) y @m(Bₙ) es
        un 0 o un 1). El circuito genera @m(S₁), @m(S₂), @m(S₃), ..., @m(Sₙ),
        los @m(n) bits de la suma, y @m(C), el carry de la adición.
        @c(ripple-carry-adder) Escriba un procedimiento que genere este
        circuito. El procedimiento debe tener como argumentos tres listas de
        @m(n) alambres cada uno - la @m(Aₙ), la @m(Bₙ), y la @m(Sₙ) -y también
        otro alambre @m(C). El principal inconveniente del sumador de ondulación
        es la necesidad de esperar a que las señales de transporte se
        propaguen. ¿Cuál es el retraso necesario para obtener la salida completa
        de un sumador de ripple-carry de @m(n) -bits, expresado en términos de
        los retrasos para y-puertas, o-puertas, e inversores? @m(y la Sₙ) --y
        también otro alambre @m(C). El principal inconveniente del sumador de
        ondulación es la necesidad de esperar a que las señales de transporte se
        propaguen. ¿Cuál es el retraso necesario para obtener la salida completa
        de un sumador de ripple-carry de @m(n) -bits, expresado en términos de
        los retrasos para y-puertas, o-puertas, e inversores? @m(y la Sₙ) --y
        también otro alambre @m(C). El principal inconveniente del sumador de
        ondulación es la necesidad de esperar a que las señales de transporte se
        propaguen. ¿Cuál es el retraso necesario para obtener la salida completa
        de un sumador de ripple-carry de @m(n) -bits, expresado en términos de
        los retrasos para y-puertas, o-puertas, e inversores?

#      ..figure > @t(Figure 3.27) A ripple-carry adder for @m(n)-bit numbers.
     ..figure > @t(Figura 3.27) Un sumador de ripple-carry para números de
     @m(n-) bits.

#        ..art >
#             |                                              |   |
#             |  A₁  B₁    C₁    A₂  B₂    C₂    A₃  B₃   C₃ |   |  Aₙ  Bₙ Cₙ=0
#             |  │   │   ╭───╮   │   │   ╭───╮   │   │   ╭───|─  |  │   │   ╭─
#             |  │   │   │   │   │   │   │   │   │   │   │   |   |  │   │   │
#             | ╭┴───┴───┴╮  │  ╭┴───┴───┴╮  │  ╭┴───┴───┴╮  |   | ╭┴───┴───┴╮
#             | │   FA    │  │  │   FA    │  │  │   FA    │  |   | │   FA    │
#             | ╰──┬───┬──╯  │  ╰──┬───┬──╯  │  ╰──┬───┬──╯  |   | ╰──┬───┬──╯
#             |    │   │     │     │   │     │     │   │     |   |    │   │
#          C ─|────╯   │     ╰─────╯   │     ╰─────╯   │     |  ─|────╯   │
#             |        │        C₁     │        C₂     │     |   |C₍ₙ₋₁₎  │
#             |        │               │               │     |   |        │
#                      S₁              S₂              S₃                 Sₙ
#        < art..
       ..art >
            |                                              |   |
            |  A₁  B₁    C₁    A₂  B₂    C₂    A₃  B₃   C₃ |   |  Aₙ  Bₙ Cₙ=0
            |  │   │   ╭───╮   │   │   ╭───╮   │   │   ╭───|─  |  │   │   ╭─
            |  │   │   │   │   │   │   │   │   │   │   │   |   |  │   │   │
            | ╭┴───┴───┴╮  │  ╭┴───┴───┴╮  │  ╭┴───┴───┴╮  |   | ╭┴───┴───┴╮
            | │   FA    │  │  │   FA    │  │  │   FA    │  |   | │   FA    │
            | ╰──┬───┬──╯  │  ╰──┬───┬──╯  │  ╰──┬───┬──╯  |   | ╰──┬───┬──╯
            |    │   │     │     │   │     │     │   │     |   |    │   │
         C ─|────╯   │     ╰─────╯   │     ╰─────╯   │     |  ─|────╯   │
            |        │        C₁     │        C₂     │     |   |C₍ₙ₋₁₎  │
            |        │               │               │     |   |        │
                     S₁              S₂              S₃                 Sₙ
       < art..

# @    ..img > img/chap3/Fig3.27b.std.svg
@    ..img > img/chap3/Fig3.27b.std.svg

# **** Representing wires
**** Representación de cables

#      A wire in our simulation will be a computational object with two local state
#      variables: a @c(signal-value) (initially taken to be 0) and a collection of
#      @c(action-procedures) to be run when the signal changes value. We implement
#      the wire, using message-passing style, as a collection of local procedures
#      together with a @c(dispatch) procedure that selects the appropriate local
#      operation, just as we did with the simple bank-account object in section @l(#3.1.1):
     Un cable en nuestra simulación será un objeto computacional con dos
     variables de estado locales: a @c(signal-value)(inicialmente tomada como 0)
     y una colección de @c(action-procedures) para ser ejecutada cuando la señal
     cambia de valor. Implementamos el cable, usando estilo de paso de mensajes,
     como una colección de procedimientos locales junto con un procedimiento @c(dispatch) que selecciona la operación local apropiada, tal como lo
     hicimos con el objeto de cuenta bancaria simple en la seccion @l(#3.1.1) :

#      ..src > scheme
#        (define (make-wire)
#          (let ((signal-value 0)
#                (action-procedures '()))
#            (define (set-my-signal! new-value)
#              (if (not (= signal-value new-value))
#                  (begin (set! signal-value new-value)
#                         (call-each
#                          action-procedures))
#                  'done))
#            (define (accept-action-procedure! proc)
#              (set! action-procedures
#                    (cons proc action-procedures))
#              (proc))
#            (define (dispatch m)
#              (cond ((eq? m 'get-signal)
#                     signal-value)
#                    ((eq? m 'set-signal!)
#                     set-my-signal!)
#                    ((eq? m 'add-action!)
#                     accept-action-procedure!)
#                    (else (error "Unknown operation:
#                                  WIRE" m))))
#            dispatch))
#      < src..
     ..src > scheme
       (define (make-wire)
         (let ((signal-value 0)
               (action-procedures '()))
           (define (set-my-signal! new-value)
             (if (not (= signal-value new-value))
                 (begin (set! signal-value new-value)
                        (call-each
                         action-procedures))
                 'done))
           (define (accept-action-procedure! proc)
             (set! action-procedures
                   (cons proc action-procedures))
             (proc))
           (define (dispatch m)
             (cond ((eq? m 'get-signal)
                    signal-value)
                   ((eq? m 'set-signal!)
                    set-my-signal!)
                   ((eq? m 'add-action!)
                    accept-action-procedure!)
                   (else (error "Unknown operation:
                                 WIRE" m))))
           dispatch))
     < src..

#      The local procedure @c(set-my-signal!) tests whether the new signal value
#      changes the signal on the wire. If so, it runs each of the action procedures,
#      using the following procedure @c(call-each), which calls each of the items in
#      a list of no-argument procedures:
     El procedimiento local @c(set-my-signal!) comprueba si el nuevo valor de
     señal cambia la señal en el cable. Si es así, ejecuta cada uno de los
     procedimientos de acción, utilizando el siguiente procedimiento
     @c(call-each), que llama a cada uno de los elementos de una lista de
     procedimientos sin argumentos:

#      ..src > scheme
#        (define (call-each procedures)
#          (if (null? procedures)
#              'done
#              (begin ((car procedures))
#                     (call-each (cdr procedures)))))
#      < src..
     ..src > scheme
       (define (call-each procedures)
         (if (null? procedures)
             'done
             (begin ((car procedures))
                    (call-each (cdr procedures)))))
     < src..

#      The local procedure @c(accept-action-procedure!) adds the given procedure to
#      the list of procedures to be run, and then runs the new procedure once. (See
#      @l(#Exercise 3.31).)
     El procedimiento local @c(accept-action-procedure!) agrega el procedimiento
     dado a la lista de procedimientos que se van a ejecutar y, a continuación,
     ejecuta el nuevo procedimiento una vez. (Véase el
     @l(#Ejercicio 3.31) .)

#      With the local @c(dispatch) procedure set up as specified, we can provide the
#      following procedures to access the local operations on wires:@n(155)
     Con el procedimiento @c(dispatch) local configurado como se especifica,
     podemos proporcionar los siguientes procedimientos para acceder a las
     operaciones locales en los cables:@n(155)

#      ..src > scheme
#        (define (get-signal wire)
#          (wire 'get-signal))
#        (define (set-signal! wire new-value)
#          ((wire 'set-signal!) new-value))
#        (define (add-action! wire action-procedure)
#          ((wire 'add-action!) action-procedure))
#      < src..
     ..src > scheme
       (define (get-signal wire)
         (wire 'get-signal))
       (define (set-signal! wire new-value)
         ((wire 'set-signal!) new-value))
       (define (add-action! wire action-procedure)
         ((wire 'add-action!) action-procedure))
     < src..

#      Wires, which have time-varying signals and may be incrementally attached to
#      devices, are typical of mutable objects. We have modeled them as procedures
#      with local state variables that are modified by assignment. When a new wire is
#      created, a new set of state variables is allocated (by the @c(let) expression
#      in @c(make-wire)) and a new @c(dispatch) procedure is constructed and
#      returned, capturing the environment with the new state variables.
     Los cables, que tienen señales que varían en el tiempo y que pueden
     acoplarse incrementalmente a los dispositivos, son típicos de los objetos
     mutables. Los hemos modelado como procedimientos con variables de estado
     locales que son modificadas por asignación. Cuando se crea un nuevo cable,
     se asigna un nuevo conjunto de variables de estado (por la @c(let)
     expresión en @c(make-wire)) y @c(dispatch) se construye y devuelve un nuevo
     procedimiento, capturando el entorno con las nuevas variables de estado.

#      The wires are shared among the various devices that have been connected to
#      them. Thus, a change made by an interaction with one device will affect all
#      the other devices attached to the wire. The wire communicates the change to
#      its neighbors by calling the action procedures provided to it when the
#      connections were established.
     Los cables se comparten entre los diversos dispositivos que se han
     conectado a ellos. Así, un cambio realizado por una interacción con un
     dispositivo afectará a todos los otros dispositivos conectados al cable. El
     cable comunica el cambio a sus vecinos llamando a los procedimientos de
     acción que se le proporcionan cuando se establecen las conexiones.

# **** The agenda
**** La agenda

#      The only thing needed to complete the simulator is @c(after-delay). The idea
#      here is that we maintain a data structure, called an @e(agenda), that contains
#      a schedule of things to do. The following operations are defined for agendas:
     Lo único necesario para completar el simulador es @c(after-delay). La idea
     aquí es que mantenemos una estructura de datos, llamada @e(agenda), que
     contiene un calendario de cosas que hacer. Para las agendas se definen las
     siguientes operaciones:

#      - @c[(make-agenda)] returns a new empty agenda.
     - @c[(make-agenda)] Devuelve una nueva agenda vacía.

#      - @c[(empty-agenda? ⟨agenda⟩)] is true if the specified agenda is empty.
     - @c[(empty-agenda? ⟨agenda⟩)] Es verdadera si la agenda especificada está
       vacía.

#      - @c[(first-agenda-item ⟨agenda⟩)] returns the first item on the agenda.
     - @c[(first-agenda-item ⟨agenda⟩)] Devuelve el primer punto del orden del
       día.

#      - @c[(remove-first-agenda-item! ⟨agenda⟩)] modifies the agenda by removing the
#        first item.
     - @c[(remove-first-agenda-item! ⟨agenda⟩)] Modifica la agenda eliminando el
       primer elemento.

#      - @c[(add-to-agenda! ⟨time⟩ ⟨action⟩ ⟨agenda⟩)] modifies the agenda by adding
#        the given action procedure to be run at the specified time.
     - @c[(add-to-agenda! ⟨time⟩ ⟨action⟩ ⟨agenda⟩)] Modifica la agenda
       agregando el procedimiento de acción dado para ser ejecutado en la hora
       especificada.

#      - @c[(current-time ⟨agenda⟩)] returns the current simulation time.
     - @c[(current-time ⟨agenda⟩)] Devuelve el tiempo de simulación actual.

#      The particular agenda that we use is denoted by @c(the-agenda). The procedure
#      @c(after-delay) adds new elements to @c(the-agenda):
     La agenda particular que usamos es denotada por @c(the-agenda). El
     procedimiento @c(after-delay) agrega nuevos elementos a @c(the-agenda):

#      ..src > scheme
#        (define (after-delay delay action)
#          (add-to-agenda!
#           (+ delay (current-time the-agenda))
#           action
#           the-agenda))
#      < src..
     ..src > scheme
       (define (after-delay delay action)
         (add-to-agenda!
          (+ delay (current-time the-agenda))
          action
          the-agenda))
     < src..

#      The simulation is driven by the procedure @c(propagate), which operates on
#      @c(the-agenda), executing each procedure on the agenda in sequence. In
#      general, as the simulation runs, new items will be added to the agenda, and
#      @c(propagate) will continue the simulation as long as there are items on the
#      agenda:
     La simulación es impulsada por el procedimiento @c(propagate), el cual
     opera @c(the-agenda), ejecutando cada procedimiento en la agenda en
     secuencia. En general, a medida que la simulación se ejecuta, se agregarán
     nuevos ítems a la agenda, y @c(propagate) continuará la simulación mientras
     haya temas en la agenda:

#      ..src > scheme
#        (define (propagate)
#          (if (empty-agenda? the-agenda)
#              'done
#              (let ((first-item
#                     (first-agenda-item the-agenda)))
#                (first-item)
#                (remove-first-agenda-item! the-agenda)
#                (propagate))))
#      < src..
     ..src > scheme
       (define (propagate)
         (if (empty-agenda? the-agenda)
             'done
             (let ((first-item
                    (first-agenda-item the-agenda)))
               (first-item)
               (remove-first-agenda-item! the-agenda)
               (propagate))))
     < src..

# **** A sample simulation
**** Una simulación de ejemplo

#      The following procedure, which places a @"(probe) on a wire, shows the
#      simulator in action. The probe tells the wire that, whenever its signal
#      changes value, it should print the new signal value, together with the current
#      time and a name that identifies the wire:
     El siguiente procedimiento, que coloca una @"(sonda) en un cable, muestra
     el simulador en acción. La sonda le dice al cable que, cada vez que su
     señal cambia de valor, debe imprimir el nuevo valor de señal, junto con la
     hora actual y un nombre que identifica el cable:

#      ..src > scheme
#        (define (probe name wire)
#          (add-action!
#           wire
#           (lambda ()
#             (newline)
#             (display name)
#             (display " ")
#             (display (current-time the-agenda))
#             (display "  New-value = ")
#             (display (get-signal wire)))))
#      < src..
     ..src > scheme
       (define (probe name wire)
         (add-action!
          wire
          (lambda ()
            (newline)
            (display name)
            (display " ")
            (display (current-time the-agenda))
            (display "  New-value = ")
            (display (get-signal wire)))))
     < src..

#      We begin by initializing the agenda and specifying delays for the primitive
#      function boxes:
     Comenzamos por inicializar la agenda y especificar los retrasos para las
     cajas de funciones primitivas:

#      ..src > scheme
#        (define the-agenda (make-agenda))
#        (define inverter-delay 2)
#        (define and-gate-delay 3)
#        (define or-gate-delay 5)
#      < src..
     ..src > scheme
       (define the-agenda (make-agenda))
       (define inverter-delay 2)
       (define and-gate-delay 3)
       (define or-gate-delay 5)
     < src..

#      Now we define four wires, placing probes on two of them:
     Ahora definimos cuatro hilos, colocando sondas en dos de ellos:

#      ..srci > scheme
#        > (define input-1 (make-wire))
#        > (define input-2 (make-wire))
#        > (define sum (make-wire))
#        > (define carry (make-wire))
#        > (probe 'sum sum)
#        sum 0  New-value = 0
#        > (probe 'carry carry)
#        carry 0  New-value = 0
#      < srci..
     ..srci > scheme
       > (define input-1 (make-wire))
       > (define input-2 (make-wire))
       > (define sum (make-wire))
       > (define carry (make-wire))
       > (probe 'sum sum)
       sum 0  New-value = 0
       > (probe 'carry carry)
       carry 0  New-value = 0
     < srci..

#      Next we connect the wires in a half-adder circuit (as in @l(#Figure 3.25)),
#      set the signal on @c(input-1) to 1, and run the simulation:
     A continuación, conectamos los cables en un circuito de medio-sumador (como
     en la @l(#Figura 3.25) ), ponemos la señal en @c(input-1)1 y
     ejecutamos la simulación:

#      ..srci > scheme
#        > (half-adder input-1 input-2 sum carry)
#        ok
#        > (set-signal! input-1 1)
#        done
#        > (propagate)
#        sum 8  New-value = 1
#        done
#      < srci..
     ..srci > scheme
       > (half-adder input-1 input-2 sum carry)
       ok
       > (set-signal! input-1 1)
       done
       > (propagate)
       sum 8  New-value = 1
       done
     < srci..

#      The @c(sum) signal changes to 1 at time 8. We are now eight time units from
#      the beginning of the simulation. At this point, we can set the signal on
#      @c(input-2) to 1 and allow the values to propagate:
     La @c(sum) señal cambia a 1 en el momento 8. Ahora somos ocho unidades de
     tiempo desde el comienzo de la simulación. En este punto, podemos poner la
     señal en @c(input-2)1 y permitir que los valores se propaguen:

#      ..srci > scheme
#        > (set-signal! input-2 1)
#        done
#        > (propagate)
#        carry 11  New-value = 1
#        sum 16  New-value = 0
#        done
#      < srci..
     ..srci > scheme
       > (set-signal! input-2 1)
       done
       > (propagate)
       carry 11  New-value = 1
       sum 16  New-value = 0
       done
     < srci..

#      The @c(carry) changes to 1 at time 11 and the @c(sum) changes to 0 at time 16.
     Los @c(carry) cambios en 1 en el tiempo 11 y los @c(sum) cambios en 0 en el
     tiempo 16.

#      :: @t(Exercise 3.31) :: The internal procedure @c(accept-action-procedure!)
#         defined in @c(make-wire) specifies that when a new action procedure is
#         added to a wire, the procedure is immediately run.  Explain why this
#         initialization is necessary. In particular, trace through the half-adder
#         example in the paragraphs above and say how the system's response would
#         differ if we had defined @c(accept-action-procedure!) as
     :: @t(Ejercicio 3.31) :: El procedimiento interno
        @c(accept-action-procedure!) definido en @c(make-wire) especifica que
        cuando se agrega un nuevo procedimiento de acción a un cable, el
        procedimiento se ejecuta inmediatamente. Explique por qué es necesaria
        esta inicialización. En particular, rastree el ejemplo de medio-sumador
        en los párrafos anteriores y diga cómo la respuesta del sistema sería
        diferente si hubiéramos definido @c(accept-action-procedure!) como

#         ..src > scheme
#           (define (accept-action-procedure! proc)
#             (set! action-procedures
#                   (cons proc action-procedures)))
#         < src..
        ..src > scheme
          (define (accept-action-procedure! proc)
            (set! action-procedures
                  (cons proc action-procedures)))
        < src..

# **** Implementing the agenda
**** Aplicación de la agenda

#      Finally, we give details of the agenda data structure, which holds the
#      procedures that are scheduled for future execution.
     Por último, detallamos la estructura de datos de la agenda, que contiene
     los procedimientos programados para su ejecución futura.

#      The agenda is made up of @e(time segments). Each time segment is a pair
#      consisting of a number (the time) and a queue (see @l(#Exercise 3.32)) that
#      holds the procedures that are scheduled to be run during that time segment.
     La agenda se compone de @e(segmentos) de @e(tiempo). Cada segmento de
     tiempo es un par que consiste en un número (el tiempo) y una cola (vea el
     @l(#Ejercicio 3.32) ) que contiene los procedimientos que
     están programados para ser ejecutados durante ese segmento de tiempo.

#      ..src > scheme
#        (define (make-time-segment time queue)
#          (cons time queue))
#        (define (segment-time s) (car s))
#        (define (segment-queue s) (cdr s))
#      < src..
     ..src > scheme
       (define (make-time-segment time queue)
         (cons time queue))
       (define (segment-time s) (car s))
       (define (segment-queue s) (cdr s))
     < src..

#      We will operate on the time-segment queues using the queue operations
#      described in section @l(#3.3.2).
     Operaremos en las colas de segmentos de tiempo usando las operaciones de
     cola descritas en la seccion @l(#3.3.2).

#      The agenda itself is a one-dimensional table of time segments. It differs from
#      the tables described in section @l(#3.3.3) in that the segments will be sorted in
#      order of increasing time. In addition, we store the @e(current time) (i.e.,
#      the time of the last action that was processed) at the head of the agenda. A
#      newly constructed agenda has no time segments and has a current time of
#      0:@n(156)
     La agenda en sí es una tabla unidimensional de segmentos de tiempo. Se
     diferencia de las tablas descritas en la seccion @l(#3.3.3) en que los
     segmentos se clasificarán en orden creciente de tiempo. Además, almacenamos
     el @e(tiempo actual) (es decir, el tiempo de la última acción que se
     procesó) en la cabeza de la agenda. Una agenda recién construida no tiene
     segmentos de tiempo y tiene un tiempo actual de 0:@n(156)

#      ..src > scheme
#        (define (make-agenda) (list 0))
#        (define (current-time agenda) (car agenda))
#        (define (set-current-time! agenda time)
#          (set-car! agenda time))
#        (define (segments agenda) (cdr agenda))
#        (define (set-segments! agenda segments)
#          (set-cdr! agenda segments))
#        (define (first-segment agenda)
#          (car (segments agenda)))
#        (define (rest-segments agenda)
#          (cdr (segments agenda)))
#      < src..
     ..src > scheme
       (define (make-agenda) (list 0))
       (define (current-time agenda) (car agenda))
       (define (set-current-time! agenda time)
         (set-car! agenda time))
       (define (segments agenda) (cdr agenda))
       (define (set-segments! agenda segments)
         (set-cdr! agenda segments))
       (define (first-segment agenda)
         (car (segments agenda)))
       (define (rest-segments agenda)
         (cdr (segments agenda)))
     < src..

#      An agenda is empty if it has no time segments:
     Una agenda está vacía si no tiene segmentos de tiempo:

#      ..src > scheme
#        (define (empty-agenda? agenda)
#          (null? (segments agenda)))
#      < src..
     ..src > scheme
       (define (empty-agenda? agenda)
         (null? (segments agenda)))
     < src..

#      To add an action to an agenda, we first check if the agenda is empty. If so,
#      we create a time segment for the action and install this in the agenda.
#      Otherwise, we scan the agenda, examining the time of each segment. If we find
#      a segment for our appointed time, we add the action to the associated queue.
#      If we reach a time later than the one to which we are appointed, we insert a
#      new time segment into the agenda just before it. If we reach the end of the
#      agenda, we must create a new time segment at the end.
     Para añadir una acción a una agenda, primero verificamos si la agenda está
     vacía. Si es así, creamos un segmento de tiempo para la acción e instalamos
     esto en la agenda. De lo contrario, exploramos la agenda, examinando el
     tiempo de cada segmento. Si encontramos un segmento para nuestro tiempo
     asignado, agregamos la acción a la cola asociada. Si llegamos a un momento
     posterior al que se nos ha asignado, insertamos un nuevo segmento de tiempo
     en la agenda justo antes de él. Si llegamos al final de la agenda, debemos
     crear un nuevo segmento de tiempo al final.

#      ..src > scheme
#        (define (add-to-agenda! time action agenda)
#          (define (belongs-before? segments)
#            (or (null? segments)
#                (< time
#                   (segment-time (car segments)))))
#          (define (make-new-time-segment time action)
#            (let ((q (make-queue)))
#              (insert-queue! q action)
#              (make-time-segment time q)))
#          (define (add-to-segments! segments)
#            (if (= (segment-time (car segments)) time)
#                (insert-queue!
#                 (segment-queue (car segments))
#                 action)
#                (let ((rest (cdr segments)))
#                  (if (belongs-before? rest)
#                      (set-cdr!
#                       segments
#                       (cons (make-new-time-segment
#                              time
#                              action)
#                             (cdr segments)))
#                      (add-to-segments! rest)))))
#          (let ((segments (segments agenda)))
#            (if (belongs-before? segments)
#                (set-segments!
#                 agenda
#                 (cons (make-new-time-segment
#                        time
#                        action)
#                       segments))
#                (add-to-segments! segments))))
#      < src..
     ..src > scheme
       (define (add-to-agenda! time action agenda)
         (define (belongs-before? segments)
           (or (null? segments)
               (< time
                  (segment-time (car segments)))))
         (define (make-new-time-segment time action)
           (let ((q (make-queue)))
             (insert-queue! q action)
             (make-time-segment time q)))
         (define (add-to-segments! segments)
           (if (= (segment-time (car segments)) time)
               (insert-queue!
                (segment-queue (car segments))
                action)
               (let ((rest (cdr segments)))
                 (if (belongs-before? rest)
                     (set-cdr!
                      segments
                      (cons (make-new-time-segment
                             time
                             action)
                            (cdr segments)))
                     (add-to-segments! rest)))))
         (let ((segments (segments agenda)))
           (if (belongs-before? segments)
               (set-segments!
                agenda
                (cons (make-new-time-segment
                       time
                       action)
                      segments))
               (add-to-segments! segments))))
     < src..

#      The procedure that removes the first item from the agenda deletes the item at
#      the front of the queue in the first time segment. If this deletion makes the
#      time segment empty, we remove it from the list of segments:@n(157)
     El procedimiento que elimina el primer elemento de la agenda elimina el
     elemento al principio de la cola en el primer segmento de tiempo. Si esta
     supresión hace que el segmento de tiempo esté vacío, lo eliminamos de la
     lista de segmentos:@n(157)

#      ..src > scheme
#        (define (remove-first-agenda-item! agenda)
#          (let ((q (segment-queue
#                    (first-segment agenda))))
#            (delete-queue! q)
#            (if (empty-queue? q)
#                (set-segments!
#                 agenda
#                 (rest-segments agenda)))))
#      < src..
     ..src > scheme
       (define (remove-first-agenda-item! agenda)
         (let ((q (segment-queue
                   (first-segment agenda))))
           (delete-queue! q)
           (if (empty-queue? q)
               (set-segments!
                agenda
                (rest-segments agenda)))))
     < src..

#      The first agenda item is found at the head of the queue in the first time
#      segment. Whenever we extract an item, we also update the current time:@n(158)
     El primer punto del orden del día se encuentra al principio de la cola en
     el primer segmento de tiempo. Siempre que extraemos un elemento, también
     actualizamos la hora actual:@n(158)

#      ..src > scheme
#        (define (first-agenda-item agenda)
#          (if (empty-agenda? agenda)
#              (error "Agenda is empty:
#                      FIRST-AGENDA-ITEM")
#              (let ((first-seg
#                     (first-segment agenda)))
#                (set-current-time!
#                 agenda
#                 (segment-time first-seg))
#                (front-queue
#                 (segment-queue first-seg)))))
#      < src..
     ..src > scheme
       (define (first-agenda-item agenda)
         (if (empty-agenda? agenda)
             (error "Agenda is empty:
                     FIRST-AGENDA-ITEM")
             (let ((first-seg
                    (first-segment agenda)))
               (set-current-time!
                agenda
                (segment-time first-seg))
               (front-queue
                (segment-queue first-seg)))))
     < src..

#      :: @t(Exercise 3.32) :: The procedures to be run during each time segment of
#         the agenda are kept in a queue. Thus, the procedures for each segment are
#         called in the order in which they were added to the agenda (first in, first
#         out). Explain why this order must be used. In particular, trace the
#         behavior of an and-gate whose inputs change from 0, 1 to 1, 0 in the same
#         segment and say how the behavior would differ if we stored a segment's
#         procedures in an ordinary list, adding and removing procedures only at the
#         front (last in, first out).
     :: @t(Ejercicio 3.32) :: Los procedimientos a ejecutar durante cada
        segmento de tiempo de la agenda se mantienen en una cola. Por lo tanto,
        los procedimientos para cada segmento se llaman en el orden en el que
        fueron agregados a la agenda (primero en entrar, primero en
        salir). Explique por qué debe utilizarse este pedido. En particular,
        rastree el comportamiento de una puerta y cuyas entradas cambien de 0, 1
        a 1, 0 en el mismo segmento y diga cómo el comportamiento sería
        diferente si almacenamos los procedimientos de un segmento en una lista
        ordinaria, añadiendo y eliminando procedimientos sólo en La parte
        delantera (última entrada, primera salida).

# *** 3.3.5 <> Propagation of Constraints
*** 3.3.5 <> Propagación de restricciones

#     Computer programs are traditionally organized as one-directional computations,
#     which perform operations on prespecified arguments to produce desired outputs.
#     On the other hand, we often model systems in terms of relations among
#     quantities. For example, a mathematical model of a mechanical structure might
#     include the information that the deflection @m(d) of a metal rod is related to
#     the force @m(ƒ) on the rod, the length @m(L) of the rod, the cross-sectional
#     area @m(a), and the elastic modulus @m(E) via the equation
    Los programas informáticos se organizan tradicionalmente como cálculos
    unidireccionales, que realizan operaciones sobre argumentos preespecificados
    para producir las salidas deseadas. Por otra parte, solemos modelar sistemas
    en términos de relaciones entre cantidades. Por ejemplo, un modelo
    matemático de una estructura mecánica podría incluir la información de que
    la deflexión @m(d) de un vástago metálico está relacionada con la fuerza
    @m(ƒ) de la varilla, la longitud @m(L) de la varilla, el área de la sección
    transversal @m(a) y el módulo elástico @m(E a) través de la ecuación

#     ..example >
#       dAE = FL
#     < example..
    ..example >
      dAE = FL
    < example..

#     Such an equation is not one-directional. Given any four of the quantities, we
#     can use it to compute the fifth. Yet translating the equation into a
#     traditional computer language would force us to choose one of the quantities
#     to be computed in terms of the other four. Thus, a procedure for computing the
#     area @m(a) could not be used to compute the deflection @m(d), even though the
#     computations of @m(a) and @m(d) arise from the same equation.@n(159)
    Tal ecuación no es unidireccional. Dado cualquiera de las cuatro cantidades,
    podemos usarla para calcular la quinta. Sin embargo, traducir la ecuación en
    un lenguaje informático tradicional nos obligaría a elegir una de las
    cantidades a calcular en términos de las otras cuatro. Por lo tanto, un
    procedimiento para calcular el área de @m(a) no podría ser utilizado para
    calcular la desviación @m(d), a pesar de que los cálculos de @m(a) y @m(d)
    se derivan de la misma ecuación.@n(159)

#     In this section, we sketch the design of a language that enables us to work in
#     terms of relations themselves. The primitive elements of the language are
#     @e(primitive constraints), which state that certain relations hold between
#     quantities. For example, @c[(adder a b c)] specifies that the quantities
#     @m(a), @m(b), and @m(c) must be related by the equation @m(a + b = c),
#     @c[(multiplier x y z)] expresses the constraint @m(xy = z), and @c[(constant
#     3.14 x)] says that the value of @m(x) must be 3.14.
    En esta sección, esbozaremos el diseño de un lenguaje que nos permita
    trabajar en términos de relaciones mismas. Los elementos primitivos del
    lenguaje son @e(restricciones primitivas), que indican que ciertas
    relaciones mantienen entre las cantidades. Por ejemplo, se @c[(adder a b c)]
    especifica que las cantidades @m(a), @m(b) y @m(c) deben estar relacionadas
    por la ecuación @m(a + b = c), @c[(multiplier x y z)] expresa la restricción
    @m(xy = z), y @c[(constant 3.14 x)] dice que el valor de @m(x) debe ser
    3.14.

#     Our language provides a means of combining primitive constraints in order to
#     express more complex relations. We combine constraints by constructing
#     @e(constraint networks), in which constraints are joined by @e(connectors). A
#     connector is an object that @"(holds) a value that may participate in one or
#     more constraints. For example, we know that the relationship between
#     Fahrenheit and Celsius temperatures is
    Nuestro lenguaje proporciona un medio de combinar las restricciones
    primitivas para expresar relaciones más complejas. Combinamos las
    restricciones mediante la construcción de @e(redes de restricción), en las
    que las restricciones se unen mediante @e(conectores). Un conector es un
    objeto que @"(contiene) un valor que puede participar en una o más
    restricciones. Por ejemplo, sabemos que la relación entre las temperaturas
    Fahrenheit y Celsius es

#     ..example >
#       9C = 5(F − 32)
#     < example..
    ..example >
      9C = 5(F − 32)
    < example..

#     Such a constraint can be thought of as a network consisting of primitive
#     adder, multiplier, and constant constraints (@l(#Figure 3.28)). In the figure,
#     we see on the left a multiplier box with three terminals, labeled @m(m1),
#     @m(m2), and @m(p). These connect the multiplier to the rest of the network as
#     follows: The @m(m1) terminal is linked to a connector @m(C), which will hold
#     the Celsius temperature. The @m(m2) terminal is linked to a connector @m(w),
#     which is also linked to a constant box that holds 9. The @m(p) terminal, which
#     the multiplier box constrains to be the product of @m(m1) and @m(m2), is
#     linked to the @m(p) terminal of another multiplier box, whose @m(m2) is
#     connected to a constant 5 and whose @m(m1) is connected to one of the terms in
#     a sum.
    Dicha restricción puede considerarse como una red consistente en sumador
    primitivo, multiplicador y restricciones constantes (
    @l(#Figura 3.28) ). En la figura, vemos a la izquierda una caja
    multiplicadora con tres terminales, etiquetados como @m(m1), @m(m2) y
    @m(p). Estos conectan el multiplicador al resto de la red de la siguiente
    manera: El terminal @m(m1) está conectado a un conector @m(C), que mantendrá
    la temperatura Celsius. El terminal @m(m2) está vinculado a un conector
    @m(w), que también está conectado a una caja constante que tiene 9. El @m(p)
    terminal, que la caja multiplicadora obliga a ser el producto de @m(m1) y
    @m(m2) ,@m()@m()@m()

#     ..figure > @t(Figure 3.28) The relation @m[9C = 5(F - 32)] expressed as a
#       constraint network.
    ..figure > @t(Figura 3.28) La relación @m(9C = 5 (F - 32)) expresada como
      una red de restricciones.

#       ..art >
#                ╭─────────╮     ╭─────────╮   v   ╭─────────╮
#         C ─────┤ m1      │  u  │      m1 ├───────┤ a1      │
#                │    *  p ├─────┤ p  *    │       │    *  s ├──── F
#             ╭──┤ m2      │     │      m2 ├──╮ ╭──┤ a2      │
#             │  ╰─────────╯     ╰─────────╯  │ │  ╰─────────╯
#           w │                              x│ │y
#             │    ╭─────╮        ╭─────╮     │ │     ╭─────╮
#             ╰────┤  9  │        │  5  ├─────╯ ╰─────┤  32 │
#                  ╰─────╯        ╰─────╯             ╰─────╯
#       < art..
      ..art >
               ╭─────────╮     ╭─────────╮   v   ╭─────────╮
        C ─────┤ m1      │  u  │      m1 ├───────┤ a1      │
               │    *  p ├─────┤ p  *    │       │    *  s ├──── F
            ╭──┤ m2      │     │      m2 ├──╮ ╭──┤ a2      │
            │  ╰─────────╯     ╰─────────╯  │ │  ╰─────────╯
          w │                              x│ │y
            │    ╭─────╮        ╭─────╮     │ │     ╭─────╮
            ╰────┤  9  │        │  5  ├─────╯ ╰─────┤  32 │
                 ╰─────╯        ╰─────╯             ╰─────╯
      < art..

# @   ..img > img/chap3/Fig3.28.std.svg
@   ..img > img/chap3/Fig3.28.std.svg

#     Computation by such a network proceeds as follows: When a connector is given a
#     value (by the user or by a constraint box to which it is linked), it awakens
#     all of its associated constraints (except for the constraint that just
#     awakened it) to inform them that it has a value. Each awakened constraint box
#     then polls its connectors to see if there is enough information to determine a
#     value for a connector. If so, the box sets that connector, which then awakens
#     all of its associated constraints, and so on. For instance, in conversion
#     between Celsius and Fahrenheit, @m(w), @m(x), and @m(y) are immediately set by
#     the constant boxes to 9, 5, and 32, respectively. The connectors awaken the
#     multipliers and the adder, which determine that there is not enough
#     information to proceed. If the user (or some other part of the network) sets
#     @m(C) to a value (say 25), the leftmost multiplier will be awakened, and it
#     will set @m(u) to @m(25 ⋅ 9 = 225). Then @m(u) awakens the second multiplier,
#     which sets @m(v) to 45, and @m(v) awakens the adder, which sets @m(ƒ) to 77.
    El cálculo por una red de este tipo procede de la siguiente manera: Cuando
    se da un valor a un conector (por el usuario o por un cuadro de
    restricciones al cual está enlazado), despierta todas sus restricciones
    asociadas (excepto la restricción que acaba de despertarlo) a Informarles
    que tiene un valor. Cada cuadro de restricción despertada hace sondeos de
    sus conectores para ver si hay suficiente información para determinar un
    valor para un conector. Si es así, la caja establece ese conector, que luego
    despierta todas sus restricciones asociadas, y así sucesivamente. Por
    ejemplo, en la conversión entre Celsius y Fahrenheit, @m(w), @m(x), y @m(y)
    se establecen inmediatamente por las cajas constantes a 9, 5, y 32,
    respectivamente. Los conectores despiertan los multiplicadores y el sumador,
    que determinan que no hay suficiente información para proceder. @m(Si el
    usuario (o alguna otra parte de la red) establece C) en un valor (digamos
    25), el multiplicador más a la izquierda se despertará y fijará @m(u) a
    @m(25 ⋅ 9 = 225). Entonces @m(u) despierta el segundo multiplicador, que
    pone @m(v) a 45, @m(yv) despierta el sumador, que fija @m(ƒ) a 77.

# **** Using the constraint system
**** Uso del sistema de restricciones

#      To use the constraint system to carry out the temperature computation outlined
#      above, we first create two connectors, @c(C) and @c(F), by calling the
#      constructor @c(make-connector), and link @c(C) and @c(F) in an appropriate
#      network:
     Para utilizar el sistema de restricciones para llevar a cabo el cálculo de
     temperatura descrito anteriormente, primero crearemos dos conectores @c(C)
     y @c(F), llamando al constructor @c(make-connector), y enlace @c(C) y @c(F)
     en una red apropiada:

#      ..srci > scheme
#        > (define C (make-connector))
#        > (define F (make-connector))
#        > (celsius-fahrenheit-converter C F)
#        ok
#      < srci..
     ..srci > scheme
       > (define C (make-connector))
       > (define F (make-connector))
       > (celsius-fahrenheit-converter C F)
       ok
     < srci..

#      The procedure that creates the network is defined as follows:
     El procedimiento que crea la red se define de la siguiente manera:

#      ..src > scheme
#        (define (celsius-fahrenheit-converter c f)
#          (let ((u (make-connector))
#                (v (make-connector))
#                (w (make-connector))
#                (x (make-connector))
#                (y (make-connector)))
#            (multiplier c w u)
#            (multiplier v x u)
#            (adder v y f)
#            (constant 9 w)
#            (constant 5 x)
#            (constant 32 y)
#            'ok))
#      < src..
     ..src > scheme
       (define (celsius-fahrenheit-converter c f)
         (let ((u (make-connector))
               (v (make-connector))
               (w (make-connector))
               (x (make-connector))
               (y (make-connector)))
           (multiplier c w u)
           (multiplier v x u)
           (adder v y f)
           (constant 9 w)
           (constant 5 x)
           (constant 32 y)
           'ok))
     < src..

#      This procedure creates the internal connectors @c(u), @c(v), @c(w), @c(x), and
#      @c(y), and links them as shown in @l(#Figure 3.28) using the primitive
#      constraint constructors @c(adder), @c(multiplier), and @c(constant). Just as
#      with the digital-circuit simulator of section @l(#3.3.4), expressing these
#      combinations of primitive elements in terms of procedures automatically
#      provides our language with a means of abstraction for compound objects.
     Este procedimiento crea los conectores internos @c(u), @c(v), @c(w), @c(x),
     y @c(y), y los une como se muestra en @l(#Figura 3.28)
     utilizando los constructores de restricción primitivos @c(adder),
     @c(multiplier) y @c(constant). Al igual que con el simulador de circuito
     digital de la seccion @l(#3.3.4), expresar estas combinaciones de elementos
     primitivos en términos de procedimientos proporciona automáticamente a
     nuestro lenguaje un medio de abstracción para objetos compuestos.

#      To watch the network in action, we can place probes on the connectors @c(C)
#      and @c(F), using a @c(probe) procedure similar to the one we used to monitor
#      wires in section @l(#3.3.4). Placing a probe on a connector will cause a message to be
#      printed whenever the connector is given a value:
     Para ver la red en acción, podemos colocar sondas en los conectores @c(C) y
     @c(F), usando un procedimiento @c(probe) similar al que usamos para
     supervisar los cables en la seccion @l(#3.3.4). Colocar una sonda en un
     conector hará que se imprima un mensaje cada vez que se le da un valor al
     conector:

#      ..src > scheme
#        (probe "Celsius temp" C)
#        (probe "Fahrenheit temp" F)
#      < src..
     ..src > scheme
       (probe "Celsius temp" C)
       (probe "Fahrenheit temp" F)
     < src..

#      Next we set the value of @c(C) to 25. (The third argument to @c(set-value!)
#      tells @c(C) that this directive comes from the @c(user).)
     A continuación nos fijamos el valor de @c(C) a 25. (El tercer argumento que
     @c(set-value!) dice @c(C) que esta directiva viene del @c(user).)

#      ..srci > scheme
#        > (set-value! C 25 'user)
#        Probe: Celsius temp = 25
#        Probe: Fahrenheit temp = 77
#        done
#      < srci..
     ..srci > scheme
       > (set-value! C 25 'user)
       Probe: Celsius temp = 25
       Probe: Fahrenheit temp = 77
       done
     < srci..

#      The probe on @c(C) awakens and reports the value. @c(C) also propagates its
#      value through the network as described above. This sets @c(F) to 77, which is
#      reported by the probe on @c(F).
     La sonda en se @c(C) despierta y reporta el valor. @c(C) También propaga su
     valor a través de la red como se ha descrito anteriormente. Esto fija @c(F)
     a 77, que se divulga por la sonda encendido @c(F).

#      Now we can try to set @c(F) to a new value, say 212:
     Ahora podemos intentar establecer @c(F) un nuevo valor, digamos 212:

#      ..srci > scheme
#        > (set-value! F 212 'user)
#        Error! Contradiction (77 212)
#      < srci..
     ..srci > scheme
       > (set-value! F 212 'user)
       Error! Contradiction (77 212)
     < srci..

#      The connector complains that it has sensed a contradiction: Its value is 77,
#      and someone is trying to set it to 212. If we really want to reuse the network
#      with new values, we can tell @c(C) to forget its old value:
     El conector se queja de que ha detectado una contradicción: su valor es 77,
     y alguien está tratando de ponerlo a 212. Si realmente queremos reutilizar
     la red con nuevos valores, podemos decir @c(C) a olvidar su valor antiguo:

#      ..srci > scheme
#        > (forget-value! C 'user)
#        Probe: Celsius temp = ?
#        Probe: Fahrenheit temp = ?
#        done
#      < srci..
     ..srci > scheme
       > (forget-value! C 'user)
       Probe: Celsius temp = ?
       Probe: Fahrenheit temp = ?
       done
     < srci..

#      @c(C) finds that the @c(user), who set its value originally, is now retracting
#      that value, so @c(C) agrees to lose its value, as shown by the probe, and
#      informs the rest of the network of this fact. This information eventually
#      propagates to @c(F), which now finds that it has no reason for continuing to
#      believe that its own value is 77. Thus, @c(F) also gives up its value, as
#      shown by the probe.
     @c(C) Encuentra que el @c(user) que estableció su valor originalmente,
     ahora está retractando ese valor, así que @c(C) acuerda perder su valor,
     como lo muestra la sonda, e informa al resto de la red de este hecho. Esta
     información finalmente se propaga a @c(F), que ahora encuentra que no tiene
     razón para seguir creyendo que su propio valor es 77. Así, @c(F) también
     renuncia a su valor, como lo muestra la sonda.

#      Now that @c(F) has no value, we are free to set it to 212:
     Ahora que @c(F) no tiene valor, somos libres de ponerlo a 212:

#      ..srci > scheme
#        > (set-value! F 212 'user)
#        Probe: Fahrenheit temp = 212
#        Probe: Celsius temp = 100
#        done
#      < srci..
     ..srci > scheme
       > (set-value! F 212 'user)
       Probe: Fahrenheit temp = 212
       Probe: Celsius temp = 100
       done
     < srci..

#      This new value, when propagated through the network, forces @c(C) to have a
#      value of 100, and this is registered by the probe on @c(C). Notice that the
#      very same network is being used to compute @c(C) given @c(F) and to compute
#      @c(F) given @c(C). This nondirectionality of computation is the distinguishing
#      feature of constraint-based systems.
     Este nuevo valor, cuando se propaga a través de la red, obliga @c(C) a
     tener un valor de 100, y esto es registrado por la sonda @c(C). Observe que
     la misma red se está utilizando para calcular @c(C) dado @c(F) y calcular
     @c(F) dado @c(C). Esta no-dirección de la computación es la característica
     distintiva de los sistemas basados en restricciones.

# **** Implementing the constraint system
**** Implementación del sistema de restricciones

#      The constraint system is implemented via procedural objects with local state,
#      in a manner very similar to the digital-circuit simulator of
#      @l(#3.3.4). Although the primitive objects of the constraint system are
#      somewhat more complex, the overall system is simpler, since there is no
#      concern about agendas and logic delays.
     El sistema de restricción se implementa a través de objetos procedurales
     con estado local, de una manera muy similar al simulador de circuito
     digital de la seccion @l(#3.3.4). Aunque los objetos primitivos del sistema de
     restricción son algo más complejos, el sistema general es más simple, ya
     que no hay preocupación por las agendas y los retrasos lógicos.

#      The basic operations on connectors are the following:
     Las operaciones básicas de los conectores son las siguientes:

#      - @c[(has-value? ⟨connector⟩)] tells whether the connector has a value.
     - @c[(has-value? ⟨connector⟩)] Indica si el conector tiene un valor.

#      - @c[(get-value ⟨connector⟩)] returns the connector's current value.
     - @c[(get-value ⟨connector⟩)] Devuelve el valor actual del conector.

#      - @c[(set-value! ⟨connector⟩ ⟨new-value⟩ ⟨informant⟩)] indicates that the
#        informant is requesting the connector to set its value to the new value.
     - @c[(set-value! ⟨connector⟩ ⟨new-value⟩ ⟨informant⟩)] Indica que el
       informante está solicitando al conector que establezca su valor en el
       nuevo valor.

#      - @c[(forget-value! ⟨connector⟩ ⟨retractor⟩)] tells the connector that the
#        retractor is requesting it to forget its value.
     - @c[(forget-value! ⟨connector⟩ ⟨retractor⟩)] Le dice al conector que el
       retractor le está pidiendo que olvide su valor.

#      - @c[(connect ⟨connector⟩ ⟨new-constraint⟩)] tells the connector to
#        participate in the new constraint.
     - @c[(connect ⟨connector⟩ ⟨new-constraint⟩)] Le dice al conector que
       participe en la nueva restricción.


#      The connectors communicate with the constraints by means of the procedures
#      @c(inform-about-value), which tells the given constraint that the connector
#      has a value, and @c(inform-about-no-value), which tells the constraint that
#      the connector has lost its value.
     Los conectores se comunican con las restricciones por medio de los
     procedimientos @c(inform-about-value), lo que indica a la restricción dada
     que el conector tiene un valor y @c(inform-about-no-value), que indica a la
     restricción que el conector ha perdido su valor.

#      @c(Adder) constructs an adder constraint among summand connectors @c(a1) and
#      @c(a2) and a @c(sum) connector. An adder is implemented as a procedure with
#      local state (the procedure @c(me) below):
     @c(Adder) construye una restricción sumador entre conectores sumando @c(a1)
     y @c(a2) y un @c(sum) conector. Un sumador se implementa como un
     procedimiento con estado local (el procedimiento @c(me) siguiente):

#      ..src > scheme
#        (define (adder a1 a2 sum)
#          (define (process-new-value)
#            (cond ((and (has-value? a1)
#                        (has-value? a2))
#                   (set-value! sum
#                               (+ (get-value a1)
#                                  (get-value a2))
#                               me))
#                  ((and (has-value? a1)
#                        (has-value? sum))
#                   (set-value! a2
#                               (- (get-value sum)
#                                  (get-value a1))
#                               me))
#                  ((and (has-value? a2)
#                        (has-value? sum))
#                   (set-value! a1
#                               (- (get-value sum)
#                                  (get-value a2))
#                               me))))
#          (define (process-forget-value)
#            (forget-value! sum me)
#            (forget-value! a1 me)
#            (forget-value! a2 me)
#            (process-new-value))
#          (define (me request)
#            (cond ((eq? request 'I-have-a-value)
#                   (process-new-value))
#                  ((eq? request 'I-lost-my-value)
#                   (process-forget-value))
#                  (else (error "Unknown request:
#                                ADDER" request))))
#          (connect a1 me)
#          (connect a2 me)
#          (connect sum me)
#          me)
#      < src..
     ..src > scheme
       (define (adder a1 a2 sum)
         (define (process-new-value)
           (cond ((and (has-value? a1)
                       (has-value? a2))
                  (set-value! sum
                              (+ (get-value a1)
                                 (get-value a2))
                              me))
                 ((and (has-value? a1)
                       (has-value? sum))
                  (set-value! a2
                              (- (get-value sum)
                                 (get-value a1))
                              me))
                 ((and (has-value? a2)
                       (has-value? sum))
                  (set-value! a1
                              (- (get-value sum)
                                 (get-value a2))
                              me))))
         (define (process-forget-value)
           (forget-value! sum me)
           (forget-value! a1 me)
           (forget-value! a2 me)
           (process-new-value))
         (define (me request)
           (cond ((eq? request 'I-have-a-value)
                  (process-new-value))
                 ((eq? request 'I-lost-my-value)
                  (process-forget-value))
                 (else (error "Unknown request:
                               ADDER" request))))
         (connect a1 me)
         (connect a2 me)
         (connect sum me)
         me)
     < src..

#      @c(Adder) connects the new adder to the designated connectors and returns it
#      as its value. The procedure @c(me), which represents the adder, acts as a
#      dispatch to the local procedures. The following @"(syntax interfaces) (see
#     @n(155<>Footnote 155) in section @l(#3.3.4)) are used in conjunction with the
#      dispatch:
     @c(Adder) Conecta el nuevo sumador a los conectores designados y lo
     devuelve como su valor. El procedimiento @c(me), que representa el sumador,
     actúa como un despacho a los procedimientos locales. Las siguientes
     @"(interfaces de sintaxis) (véase la@n(155<>Nota 155) en
     @l(#3.3.4)) se utilizan conjuntamente con el envío:

#      ..src > scheme
#        (define (inform-about-value constraint)
#          (constraint 'I-have-a-value))
#        (define (inform-about-no-value constraint)
#          (constraint 'I-lost-my-value))
#      < src..
     ..src > scheme
       (define (inform-about-value constraint)
         (constraint 'I-have-a-value))
       (define (inform-about-no-value constraint)
         (constraint 'I-lost-my-value))
     < src..

#      The adder's local procedure @c(process-new-value) is called when the adder is
#      informed that one of its connectors has a value. The adder first checks to see
#      if both @c(a1) and @c(a2) have values. If so, it tells @c(sum) to set its
#      value to the sum of the two addends. The @c(informant) argument to
#      @c(set-value!) is @c(me), which is the adder object itself. If @c(a1) and
#      @c(a2) do not both have values, then the adder checks to see if perhaps @c(a1)
#      and @c(sum) have values. If so, it sets @c(a2) to the difference of these
#      two. Finally, if @c(a2) and @c(sum) have values, this gives the adder enough
#      information to set @c(a1). If the adder is told that one of its connectors has
#      lost a value, it requests that all of its connectors now lose their
#      values. (Only those values that were set by this adder are actually lost.)
#      Then it runs @c(process-new-value). The reason for this last step is that one
#      or more connectors may still have a value (that is, a connector may have had a
#      value that was not originally set by the adder), and these values may need to
#      be propagated back through the adder.
     El procedimiento local del suplidor @c(process-new-value) se llama cuando
     se informa al sumador que uno de sus conectores tiene un valor. Los
     primeros cheques sumadores para ver si ambos @c(a1) y @c(a2) tienen
     valores. Si es así, le dice @c(sum) que establezca su valor en la suma de
     los dos sumandos. El @c(informant) argumento to @c(set-value!) es @c(me),
     que es el propio objeto sumador. Si @c(a1) y @c(a2) no tienen ambos
     valores, entonces el sumador comprueba para ver si tal vez @c(a1) y @c(sum)
     tiene valores. Si es así, establece @c(a2) la diferencia de estos dos. Por
     último, si @c(a2) y @c(sum) tienen valores, esto le da al sumador
     suficiente información para establecer @c(a1). Si se le dice al sumador que
     uno de sus conectores ha perdido un valor, solicita que todos sus
     conectores pierdan sus valores. @c(process-new-value)(Sólo los valores que
     fueron establecidos por este sumador se pierden en realidad.) Luego se
     ejecuta. La razón de este último paso es que uno o más conectores todavía
     pueden tener un valor (es decir, un conector puede haber tenido un valor
     que no se estableció originalmente por el sumador) y estos valores pueden
     necesitar propagarse a través del suplidor.

#      A multiplier is very similar to an adder. It will set its @c(product) to 0 if
#      either of the factors is 0, even if the other factor is not known.
     Un multiplicador es muy similar a un sumador. Se pondrá @c(product) a 0 si
     cualquiera de los factores es 0, incluso si el otro factor no se conoce.

#      ..src > scheme
#        (define (multiplier m1 m2 product)
#          (define (process-new-value)
#            (cond ((or (and (has-value? m1)
#                            (= (get-value m1) 0))
#                       (and (has-value? m2)
#                            (= (get-value m2) 0)))
#                   (set-value! product 0 me))
#                  ((and (has-value? m1)
#                        (has-value? m2))
#                   (set-value! product
#                               (* (get-value m1)
#                                  (get-value m2))
#                               me))
#                  ((and (has-value? product)
#                        (has-value? m1))
#                   (set-value! m2
#                               (/ (get-value product)
#                                  (get-value m1))
#                               me))
#                  ((and (has-value? product)
#                        (has-value? m2))
#                   (set-value! m1
#                               (/ (get-value product)
#                                  (get-value m2))
#                               me))))
#          (define (process-forget-value)
#            (forget-value! product me)
#            (forget-value! m1 me)
#            (forget-value! m2 me)
#            (process-new-value))
#          (define (me request)
#            (cond ((eq? request 'I-have-a-value)
#                   (process-new-value))
#                  ((eq? request 'I-lost-my-value)
#                   (process-forget-value))
#                  (else
#                   (error "Unknown request:
#                           MULTIPLIER"
#                          request))))
#          (connect m1 me)
#          (connect m2 me)
#          (connect product me)
#          me)
#      < src..
     ..src > scheme
       (define (multiplier m1 m2 product)
         (define (process-new-value)
           (cond ((or (and (has-value? m1)
                           (= (get-value m1) 0))
                      (and (has-value? m2)
                           (= (get-value m2) 0)))
                  (set-value! product 0 me))
                 ((and (has-value? m1)
                       (has-value? m2))
                  (set-value! product
                              (* (get-value m1)
                                 (get-value m2))
                              me))
                 ((and (has-value? product)
                       (has-value? m1))
                  (set-value! m2
                              (/ (get-value product)
                                 (get-value m1))
                              me))
                 ((and (has-value? product)
                       (has-value? m2))
                  (set-value! m1
                              (/ (get-value product)
                                 (get-value m2))
                              me))))
         (define (process-forget-value)
           (forget-value! product me)
           (forget-value! m1 me)
           (forget-value! m2 me)
           (process-new-value))
         (define (me request)
           (cond ((eq? request 'I-have-a-value)
                  (process-new-value))
                 ((eq? request 'I-lost-my-value)
                  (process-forget-value))
                 (else
                  (error "Unknown request:
                          MULTIPLIER"
                         request))))
         (connect m1 me)
         (connect m2 me)
         (connect product me)
         me)
     < src..

#      A @c(constant) constructor simply sets the value of the designated
#      connector. Any @c(I-have-a-value) or @c(I-lost-my-value) message sent to the
#      constant box will produce an error.
     Un @c(constant) constructor simplemente establece el valor del conector
     designado. Cualquier mensaje @c(I-have-a-value) o @c(I-lost-my-value)
     mensaje enviado a la caja constante producirá un error.

#      ..src > scheme
#        (define (constant value connector)
#          (define (me request)
#            (error "Unknown request: CONSTANT"
#                   request))
#          (connect connector me)
#          (set-value! connector value me)
#          me)
#      < src..
     ..src > scheme
       (define (constant value connector)
         (define (me request)
           (error "Unknown request: CONSTANT"
                  request))
         (connect connector me)
         (set-value! connector value me)
         me)
     < src..

#      Finally, a probe prints a message about the setting or unsetting of the
#      designated connector:
     Finalmente, una sonda imprime un mensaje acerca del ajuste o desarmado del
     conector designado:

#      ..src > scheme
#        (define (probe name connector)
#          (define (print-probe value)
#            (newline) (display "Probe: ")
#            (display name) (display " = ")
#            (display value))
#          (define (process-new-value)
#            (print-probe (get-value connector)))
#          (define (process-forget-value)
#            (print-probe "?"))
#          (define (me request)
#            (cond ((eq? request 'I-have-a-value)
#                   (process-new-value))
#                  ((eq? request 'I-lost-my-value)
#                   (process-forget-value))
#                  (else (error "Unknown request:
#                                PROBE" request))))
#          (connect connector me)
#          me)
#      < src..
     ..src > scheme
       (define (probe name connector)
         (define (print-probe value)
           (newline) (display "Probe: ")
           (display name) (display " = ")
           (display value))
         (define (process-new-value)
           (print-probe (get-value connector)))
         (define (process-forget-value)
           (print-probe "?"))
         (define (me request)
           (cond ((eq? request 'I-have-a-value)
                  (process-new-value))
                 ((eq? request 'I-lost-my-value)
                  (process-forget-value))
                 (else (error "Unknown request:
                               PROBE" request))))
         (connect connector me)
         me)
     < src..

# **** Representing connectors
**** Representación de conectores

#      A connector is represented as a procedural object with local state variables
#      @c(value), the current value of the connector; @c(informant), the object that
#      set the connector's value; and @c(constraints), a list of the constraints in
#      which the connector participates.
     Un conector se representa como un objeto procedural con variables de estado
     locales @c(value), el valor actual del conector; @c(informant), El objeto
     que establece el valor del conector; Y @c(constraints) una lista de las
     restricciones en las que participa el conector.

#      ..src > scheme
#        (define (make-connector)
#          (let ((value false)
#                (informant false)
#                (constraints '()))
#            (define (set-my-value newval setter)
#              (cond ((not (has-value? me))
#                     (set! value newval)
#                     (set! informant setter)
#                     (for-each-except
#                      setter
#                      inform-about-value
#                      constraints))
#                    ((not (= value newval))
#                     (error "Contradiction"
#                            (list value newval)))
#                    (else 'ignored)))
#            (define (forget-my-value retractor)
#              (if (eq? retractor informant)
#                  (begin (set! informant false)
#                         (for-each-except
#                          retractor
#                          inform-about-no-value
#                          constraints))
#                  'ignored))
#            (define (connect new-constraint)
#              (if (not (memq new-constraint
#                             constraints))
#                  (set! constraints
#                        (cons new-constraint
#                              constraints)))
#              (if (has-value? me)
#                  (inform-about-value new-constraint))
#              'done)
#            (define (me request)
#              (cond ((eq? request 'has-value?)
#                     (if informant true false))
#                    ((eq? request 'value) value)
#                    ((eq? request 'set-value!)
#                     set-my-value)
#                    ((eq? request 'forget)
#                     forget-my-value)
#                    ((eq? request 'connect) connect)
#                    (else (error "Unknown operation:
#                                  CONNECTOR"
#                                 request))))
#            me))
#      < src..
     ..src > scheme
       (define (make-connector)
         (let ((value false)
               (informant false)
               (constraints '()))
           (define (set-my-value newval setter)
             (cond ((not (has-value? me))
                    (set! value newval)
                    (set! informant setter)
                    (for-each-except
                     setter
                     inform-about-value
                     constraints))
                   ((not (= value newval))
                    (error "Contradiction"
                           (list value newval)))
                   (else 'ignored)))
           (define (forget-my-value retractor)
             (if (eq? retractor informant)
                 (begin (set! informant false)
                        (for-each-except
                         retractor
                         inform-about-no-value
                         constraints))
                 'ignored))
           (define (connect new-constraint)
             (if (not (memq new-constraint
                            constraints))
                 (set! constraints
                       (cons new-constraint
                             constraints)))
             (if (has-value? me)
                 (inform-about-value new-constraint))
             'done)
           (define (me request)
             (cond ((eq? request 'has-value?)
                    (if informant true false))
                   ((eq? request 'value) value)
                   ((eq? request 'set-value!)
                    set-my-value)
                   ((eq? request 'forget)
                    forget-my-value)
                   ((eq? request 'connect) connect)
                   (else (error "Unknown operation:
                                 CONNECTOR"
                                request))))
           me))
     < src..

#      The connector's local procedure @c(set-my-value) is called when there is a
#      request to set the connector's value. If the connector does not currently have
#      a value, it will set its value and remember as @c(informant) the constraint
#      that requested the value to be set.@n(160) Then the connector will notify all
#      of its participating constraints except the constraint that requested the
#      value to be set. This is accomplished using the following iterator, which
#      applies a designated procedure to all items in a list except a given one:
     El procedimiento local del conector @c(set-my-value) se llama cuando hay
     una petición para establecer el valor del conector. Si el conector no tiene
     actualmente un valor, establecerá su valor y recordará como @c(informant)
     la restricción que solicitó el valor que se va a establecer.@n(160)
     A continuación, el conector notificará todas sus restricciones
     participantes, excepto la restricción que solicitó el valor que se va a
     establecer. Esto se logra utilizando el siguiente iterador, que aplica un
     procedimiento designado a todos los elementos de una lista excepto uno
     dado:

#      ..src > scheme
#        (define (for-each-except exception
#                                 procedure
#                                 list)
#          (define (loop items)
#            (cond ((null? items) 'done)
#                  ((eq? (car items) exception)
#                   (loop (cdr items)))
#                  (else (procedure (car items))
#                        (loop (cdr items)))))
#          (loop list))
#      < src..
     ..src > scheme
       (define (for-each-except exception
                                procedure
                                list)
         (define (loop items)
           (cond ((null? items) 'done)
                 ((eq? (car items) exception)
                  (loop (cdr items)))
                 (else (procedure (car items))
                       (loop (cdr items)))))
         (loop list))
     < src..

#      If a connector is asked to forget its value, it runs the local procedure
#      @c(forget-my-value), which first checks to make sure that the request is
#      coming from the same object that set the value originally. If so, the
#      connector informs its associated constraints about the loss of the value.
     Si se le pide a un conector que olvide su valor, ejecuta el procedimiento
     local @c(forget-my-value), que comprueba primero para asegurarse de que la
     solicitud proviene del mismo objeto que estableció el valor
     originalmente. Si es así, el conector informa sus limitaciones asociadas
     sobre la pérdida del valor.

#      The local procedure @c(connect) adds the designated new constraint to the list
#      of constraints if it is not already in that list. Then, if the connector has a
#      value, it informs the new constraint of this fact.
     El procedimiento local @c(connect) agrega la nueva restricción designada a
     la lista de restricciones si aún no está en esa lista. Entonces, si el
     conector tiene un valor, informa a la nueva restricción de este hecho.

#      The connector's procedure @c(me) serves as a dispatch to the other internal
#      procedures and also represents the connector as an object. The following
#      procedures provide a syntax interface for the dispatch:
     El procedimiento del conector @c(me) sirve como un despacho a los otros
     procedimientos internos y también representa el conector como un
     objeto. Los procedimientos siguientes proporcionan una interfaz de sintaxis
     para el envío:

#      ..src > scheme
#        (define (has-value? connector)
#          (connector 'has-value?))
#        (define (get-value connector)
#          (connector 'value))
#        (define (set-value! connector
#                            new-value
#                            informant)
#          ((connector 'set-value!)
#           new-value
#           informant))
#        (define (forget-value! connector retractor)
#          ((connector 'forget) retractor))
#        (define (connect connector new-constraint)
#          ((connector 'connect) new-constraint))
#      < src..
     ..src > scheme
       (define (has-value? connector)
         (connector 'has-value?))
       (define (get-value connector)
         (connector 'value))
       (define (set-value! connector
                           new-value
                           informant)
         ((connector 'set-value!)
          new-value
          informant))
       (define (forget-value! connector retractor)
         ((connector 'forget) retractor))
       (define (connect connector new-constraint)
         ((connector 'connect) new-constraint))
     < src..

#      :: @t(Exercise 3.33) :: Using primitive multiplier, adder, and constant
#         constraints, define a procedure @c(averager) that takes three connectors
#         @c(a), @c(b), and @c(c) as inputs and establishes the constraint that the
#         value of @c(c) is the average of the values of @c(a) and @c(b).
     :: @t(Ejercicio 3.33) :: Usando multiplicador primitivo, sumador, y las
        limitaciones constantes, definir un procedimiento @c(averager) que se
        lleva tres conectores @c(a), @c(b) y @c(c) como entradas y establece la
        restricción de que el valor de @c(c) es el promedio de los valores de
        @c(a) y @c(b).

#      :: @t(Exercise 3.34) :: Louis Reasoner wants to build a squarer, a constraint
#         device with two terminals such that the value of connector @c(b) on the
#         second terminal will always be the square of the value @c(a) on the first
#         terminal. He proposes the following simple device made from a multiplier:
     :: @t(Ejercicio 3.34) :: Louis Reasoner quiere construir un cuadrado, un
        dispositivo de restricción con dos terminales, de modo que el valor del
        conector @c(b) en el segundo terminal será siempre el cuadrado del valor
        @c(a) en el primer terminal. Propone el siguiente dispositivo simple
        hecho a partir de un multiplicador:

#         ..src > scheme
#           (define (squarer a b) (multiplier a a b))
#         < src..
        ..src > scheme
          (define (squarer a b) (multiplier a a b))
        < src..

#         There is a serious flaw in this idea. Explain.
        Hay una falla seria en esta idea. Explique.

#      :: @t(Exercise 3.35) :: Ben Bitdiddle tells Louis that one way to avoid the
#         trouble in @l(#Exercise 3.34) is to define a squarer as a new primitive
#         constraint. Fill in the missing portions in Ben's outline for a procedure
#         to implement such a constraint:
     :: @t(Ejercicio 3.35) :: Ben Bitdiddle le dice a Louis que una forma de
        evitar el problema en el @l(#Ejercicio 3.34) es definir
        un cuadrado como una nueva restricción primitiva. Rellene las partes que
        faltan en el esquema de Ben para un procedimiento para implementar tal
        restricción:

#         ..src > scheme
#           (define (squarer a b)
#             (define (process-new-value)
#               (if (has-value? b)
#                   (if (< (get-value b) 0)
#                       (error "square less than 0:
#                               SQUARER"
#                              (get-value b))
#                       ⟨alternative1⟩)
#                   ⟨alternative2⟩))
#             (define (process-forget-value) ⟨body1⟩)
#             (define (me request) ⟨body2⟩)
#             ⟨rest of definition⟩
#             me)
#         < src..
        ..src > scheme
          (define (squarer a b)
            (define (process-new-value)
              (if (has-value? b)
                  (if (< (get-value b) 0)
                      (error "square less than 0:
                              SQUARER"
                             (get-value b))
                      ⟨alternative1⟩)
                  ⟨alternative2⟩))
            (define (process-forget-value) ⟨body1⟩)
            (define (me request) ⟨body2⟩)
            ⟨rest of definition⟩
            me)
        < src..

#      :: @t(Exercise 3.36) :: Suppose we evaluate the following sequence of
#         expressions in the global environment:
     :: @t(Ejercicio 3.36) :: Supongamos que evaluamos la siguiente secuencia de
        expresiones en el entorno global:

#         ..src > scheme
#           (define a (make-connector))
#           (define b (make-connector))
#           (set-value! a 10 'user)
#         < src..
        ..src > scheme
          (define a (make-connector))
          (define b (make-connector))
          (set-value! a 10 'user)
        < src..

#         At some time during evaluation of the @c(set-value!), the following
#         expression from the connector's local procedure is evaluated:
        En algún momento durante la evaluación de la @c(set-value!), se evalúa
        la siguiente expresión del procedimiento local del conector:

#         ..src > scheme
#           (for-each-except
#             setter inform-about-value constraints)
#         < src..
        ..src > scheme
          (for-each-except
            setter inform-about-value constraints)
        < src..

#         Draw an environment diagram showing the environment in which the above
#         expression is evaluated.
        Dibuje un diagrama de entorno que muestre el entorno en el que se evalúa
        la expresión anterior.

#      :: @t(Exercise 3.37) :: The @c(celsius-fahrenheit-converter) procedure is
#         cumbersome when compared with a more expression-oriented style of
#         definition, such as
     :: @t(Ejercicio 3.37) :: El procedimiento @c(celsius-fahrenheit-converter)
        es engorroso cuando se compara con un estilo de definición más orientado
        a la expresión, como

#         ..src > scheme
#           (define (celsius-fahrenheit-converter x)
#             (c+ (c* (c/ (cv 9) (cv 5))
#                     x)
#                 (cv 32)))
#
#           (define C (make-connector))
#           (define F (celsius-fahrenheit-converter C))
#         < src..
        ..src > scheme
          (define (celsius-fahrenheit-converter x)
            (c+ (c* (c/ (cv 9) (cv 5))
                    x)
                (cv 32)))

          (define C (make-connector))
          (define F (celsius-fahrenheit-converter C))
        < src..

#         Here @c(c+), @c(c*), etc. are the @"(constraint) versions of the arithmetic
#         operations. For example, @c(c+) takes two connectors as arguments and
#         returns a connector that is related to these by an adder constraint:
        Aquí @c(c+), @c(c*) etc. son las @"(restricciones) versiones de las
        operaciones aritméticas. Por ejemplo, @c(c+) toma dos conectores como
        argumentos y devuelve un conector que está relacionado con estos por una
        restricción de sumador:

#         ..src > scheme
#           (define (c+ x y)
#             (let ((z (make-connector)))
#               (adder x y z)
#               z))
#         < src..
        ..src > scheme
          (define (c+ x y)
            (let ((z (make-connector)))
              (adder x y z)
              z))
        < src..

#         Define analogous procedures @c(c-), @c(c*), @c(c/), and @c(cv) (constant
#         value) that enable us to define compound constraints as in the converter
#         example above.@n(161)
        Definir procedimientos análogos @c(c-), @c(c*), @c(c/), y @c(cv)(valor
        constante) que nos permiten definir restricciones compuesto como en el
        ejemplo convertidor anteriormente.@n(161)

# ** 3.4 <> Concurrency: Time Is of the Essence
** 3.4 <> Concurrencia: El tiempo es de la esencia

#    We've seen the power of computational objects with local state as tools for
#    modeling. Yet, as @l(#3.1.3) warned, this power extracts a price: the loss of
#    referential transparency, giving rise to a thicket of questions about sameness
#    and change, and the need to abandon the substitution model of evaluation in
#    favor of the more intricate environment model.
   Hemos visto el poder de los objetos computacionales con el estado local como
   herramientas para el modelado. Sin embargo, tal como se @l(#3.1.3<>señala en
   el) apartado @l(#3.1.3), este poder extrae un precio: la pérdida de
   transparencia referencial, dando lugar a una gran cantidad de preguntas sobre
   igualdad y cambio, y la necesidad de abandonar el modelo de sustitución de
   evaluación en favor del modelo ambiental más complejo.

#    The central issue lurking beneath the complexity of state, sameness, and
#    change is that by introducing assignment we are forced to admit @e(time) into
#    our computational models. Before we introduced assignment, all our programs
#    were timeless, in the sense that any expression that has a value always has
#    the same value. In contrast, recall the example of modeling withdrawals from a
#    bank account and returning the resulting balance, introduced at the beginning
#    of section @l(#3.1.1):
   La cuestión central que se esconde bajo la complejidad del estado, igualdad y
   cambio es que al introducir la asignación nos vemos obligados a admitir el
   @e(tiempo) en nuestros modelos computacionales. Antes de presentar la
   asignación, todos nuestros programas eran atemporales, en el sentido de que
   cualquier expresión que tiene un valor siempre tiene el mismo valor. Por el
   contrario, recordemos el ejemplo de modelar los retiros de una cuenta
   bancaria y devolver el saldo resultante, introducido al principio de
   @l(#3.1.1) :

#    ..srci > scheme
#      > (withdraw 25)
#      75
#      > (withdraw 25)
#      50
#    < srci..
   ..srci > scheme
     > (withdraw 25)
     75
     > (withdraw 25)
     50
   < srci..

#    Here successive evaluations of the same expression yield different values.
#    This behavior arises from the fact that the execution of assignment statements
#    (in this case, assignments to the variable @c(balance)) delineates @e(moments
#    in time) when values change. The result of evaluating an expression depends
#    not only on the expression itself, but also on whether the evaluation occurs
#    before or after these moments. Building models in terms of computational
#    objects with local state forces us to confront time as an essential concept in
#    programming.
   Aquí las evaluaciones sucesivas de la misma expresión dan diferentes
   valores. Este comportamiento surge del hecho de que la ejecución de
   sentencias de asignación (en este caso, asignaciones a la variable
   @c(balance)) delinea @e(momentos en el tiempo) cuando los valores cambian. El
   resultado de la evaluación de una expresión depende no sólo de la expresión
   misma, sino también de si la evaluación ocurre antes o después de estos
   momentos. Construir modelos en términos de objetos computacionales con el
   estado local nos obliga a confrontar el tiempo como un concepto esencial en
   la programación.

#    We can go further in structuring computational models to match our perception
#    of the physical world. Objects in the world do not change one at a time in
#    sequence. Rather we perceive them as acting @e(concurrently)––all at once. So
#    it is often natural to model systems as collections of computational processes
#    that execute concurrently. Just as we can make our programs modular by
#    organizing models in terms of objects with separate local state, it is often
#    appropriate to divide computational models into parts that evolve separately
#    and concurrently. Even if the programs are to be executed on a sequential
#    computer, the practice of writing programs as if they were to be executed
#    concurrently forces the programmer to avoid inessential timing constraints and
#    thus makes programs more modular.
   Podemos ir más lejos en la estructuración de modelos computacionales para que
   coincida con nuestra percepción del mundo físico. Los objetos del mundo no
   cambian uno a la vez en secuencia. Más bien los percibimos como actuando
   @e(simultáneamente, todos) a la vez. Por lo tanto, a menudo es natural
   modelar sistemas como colecciones de procesos computacionales que se ejecutan
   simultáneamente. Así como podemos hacer nuestros programas modulares
   organizando modelos en términos de objetos con estado local separado, a
   menudo es apropiado dividir los modelos computacionales en partes que
   evolucionan por separado y simultáneamente. Incluso si los programas se van a
   ejecutar en un ordenador secuencial, la práctica de escribir programas como
   si fueran a ejecutarse simultáneamente obliga al programador a evitar
   restricciones de temporización no necesarias y, por lo tanto, hace que los
   programas sean más modulares.

#    In addition to making programs more modular, concurrent computation can
#    provide a speed advantage over sequential computation. Sequential computers
#    execute only one operation at a time, so the amount of time it takes to
#    perform a task is proportional to the total number of operations
#    performed.@n(162) However, if it is possible to decompose a problem into
#    pieces that are relatively independent and need to communicate only rarely, it
#    may be possible to allocate pieces to separate computing processors, producing
#    a speed advantage proportional to the number of processors available.
   Además de hacer los programas más modulares, la computación concurrente puede
   proporcionar una ventaja de la velocidad sobre la computación secuencial. Los
   equipos secuenciales ejecutan sólo una operación a la vez, por lo que la
   cantidad de tiempo que se tarda en realizar una tarea es proporcional al
   número total de operaciones realizadas.@n(162) Sin embargo, si es
   posible descomponer un problema en piezas que son relativamente
   independientes y necesitan comunicarse sólo en raras ocasiones, puede ser
   posible asignar piezas para separar los procesadores de cálculo, que produce
   una ventaja de velocidad proporcional al número de procesadores disponibles.

#    Unfortunately, the complexities introduced by assignment become even more
#    problematic in the presence of concurrency. The fact of concurrent execution,
#    either because the world operates in parallel or because our computers do,
#    entails additional complexity in our understanding of time.
   Desafortunadamente, las complejidades introducidas por la asignación se
   vuelven aún más problemáticas en presencia de concurrencia. El hecho de la
   ejecución concurrente, ya sea porque el mundo funciona en paralelo o porque
   nuestros ordenadores lo hacen, implica complejidad adicional en nuestra
   comprensión del tiempo.

# *** 3.4.1 <> The Nature of Time in Concurrent Systems
*** 3.4.1 <> La naturaleza del tiempo en sistemas concurrentes

#     On the surface, time seems straightforward. It is an ordering imposed on
#     events.@n(163) For any events @m(a) and @m(B), either @m(a) occurs before
#     @m(B), @m(a) and @m(B) are simultaneous, or @m(a) occurs after @m(B). For
#     instance, returning to the bank account example, suppose that Peter withdraws
#     $10 and Paul withdraws $25 from a joint account that initially contains $100,
#     leaving $65 in the account. Depending on the order of the two withdrawals, the
#     sequence of balances in the account is either $100 → $90 → $65 or $100 → $75 →
#     $65. In a computer implementation of the banking system, this changing
#     sequence of balances could be modeled by successive assignments to a variable
#     @c(balance).
    En la superficie, el tiempo parece sencillo. Es un orden impuesto a los
    acontecimientos.@n(163) Para cualquier eventos @m(a) y @m(B), ya
    sea @m(a) ocurre antes de @m(B), @m(a) y @m(B) son simultáneos, o @m(a)
    ocurre después @m(B). Por ejemplo, al regresar al ejemplo de la cuenta
    bancaria, supongamos que Peter retira $ 10 y Paul retira $ 25 de una cuenta
    conjunta que inicialmente contiene $ 100, dejando $ 65 en la
    cuenta. Dependiendo del orden de los dos retiros, la secuencia de saldos en
    la cuenta es $ 100 → $ 90 → $ 65 o $ 100 → $ 75 → $ 65. En una
    implementación informática del sistema bancario,@c(balance)

#     In complex situations, however, such a view can be problematic. Suppose that
#     Peter and Paul, and other people besides, are accessing the same bank account
#     through a network of banking machines distributed all over the world. The
#     actual sequence of balances in the account will depend critically on the
#     detailed timing of the accesses and the details of the communication among the
#     machines.
    En situaciones complejas, sin embargo, tal visión puede ser
    problemática. Supongamos que Pedro y Pablo, y otras personas además, acceden
    a la misma cuenta bancaria a través de una red de máquinas bancarias
    distribuidas por todo el mundo. La secuencia real de saldos en la cuenta
    dependerá de manera crítica de la sincronización detallada de los accesos y
    de los detalles de la comunicación entre las máquinas.

#     This indeterminacy in the order of events can pose serious problems in the
#     design of concurrent systems. For instance, suppose that the withdrawals made
#     by Peter and Paul are implemented as two separate processes sharing a common
#     variable @c(balance), each process specified by the procedure given in
#     @l(#3.1.1):
    Esta indeterminación en el orden de los acontecimientos puede plantear
    serios problemas en el diseño de sistemas concurrentes. Por ejemplo,
    supongamos que las retiradas hechas por Peter y Paul se implementan como dos
    procesos separados que comparten una variable común @c(balance), cada
    proceso especificado por el procedimiento dado en la seccion @l(#3.1.1) :

#     ..src > scheme
#       (define (withdraw amount)
#         (if (>= balance amount)
#             (begin
#               (set! balance
#                     (- balance amount))
#               balance)
#             "Insufficient funds"))
#     < src..
    ..src > scheme
      (define (withdraw amount)
        (if (>= balance amount)
            (begin
              (set! balance
                    (- balance amount))
              balance)
            "Insufficient funds"))
    < src..

#     If the two processes operate independently, then Peter might test the balance
#     and attempt to withdraw a legitimate amount. However, Paul might withdraw some
#     funds in between the time that Peter checks the balance and the time Peter
#     completes the withdrawal, thus invalidating Peter's test.
    Si los dos procesos funcionan de manera independiente, entonces Pedro podría
    probar el equilibrio y tratar de retirar una cantidad legítima. Sin embargo,
    Pablo podría retirar algunos fondos entre el momento en que Pedro comprueba
    el equilibrio y el tiempo en que Pedro completa la retirada, invalidando así
    la prueba de Pedro.

#     Things can be worse still. Consider the expression
    Las cosas pueden ser aún peores. Considere la expresión

#     ..src > scheme
#       (set! balance (- balance amount))
#     < src..
    ..src > scheme
      (set! balance (- balance amount))
    < src..

#     executed as part of each withdrawal process. This consists of three steps: (1)
#     accessing the value of the @c(balance) variable; (2) computing the new
#     balance; (3) setting @c(balance) to this new value. If Peter and Paul's
#     withdrawals execute this statement concurrently, then the two withdrawals
#     might interleave the order in which they access @c(balance) and set it to the
#     new value.
    Ejecutado como parte de cada proceso de retiro. Consiste en tres pasos: (1)
    acceder al valor de la @c(balance) variable; (2) calcular el nuevo saldo;
    (3) @c(balance) a este nuevo valor. Si los retiros de Pedro y Pablo ejecutan
    esta declaración simultáneamente, entonces los dos retiros podrían
    intercalar el orden en el que acceden @c(balance) y establecerlo en el nuevo
    valor.

#     The timing diagram in @l(#Figure 3.29) depicts an order of events where
#     @c(balance) starts at 100, Peter withdraws 10, Paul withdraws 25, and yet the
#     final value of @c(balance) is 75. As shown in the diagram, the reason for this
#     anomaly is that Paul's assignment of 75 to @c(balance) is made under the
#     assumption that the value of @c(balance) to be decremented is 100.  That
#     assumption, however, became invalid when Peter changed @c(balance) to 90.
#     This is a catastrophic failure for the banking system, because the total
#     amount of money in the system is not conserved. Before the transactions, the
#     total amount of money was $100. Afterwards, Peter has $10, Paul has $25, and
#     the bank has $75.@n(164)
    El diagrama de tiempo de la @l(#Figura 3.29) representa un
    orden de eventos en el que @c(balance) comienza en 100, Peter retira 10,
    Paul retira 25 y, sin embargo, el valor final de @c(balance) es 75. Como se
    muestra en el diagrama, la razón de esta anomalía es que la asignación de
    Paul de 75 A @c(balance) se hace bajo el supuesto de que el valor de
    @c(balance) ser decrementado es 100. Esa suposición, sin embargo, se
    convirtió en inválido cuando Peter cambió @c(balance) a 90. Esto es un
    fracaso catastrófico para el sistema bancario, porque la cantidad total de
    dinero en el sistema no es conservado. Antes de las transacciones, la
    cantidad total de dinero era de $ 100. Después, Peter tiene $ 10, Paul tiene
    $ 25, y el banco tiene $ 75.@n(164)

#     ..figure > @t(Figure 3.29) Timing diagram showing how interleaving the order
#       of events in two banking withdrawals can lead to an incorrect final balance.
    ..figure > @t(Figura 3.29) Diagrama de sincronización que muestra cómo el
      entrelazado del orden de los eventos en dos retiros bancarios puede
      conducir a un saldo final incorrecto.

#       ..art >
#          │           Peter              Bank              Paul
#          │                              ____
#          │                             ╱    ╲
#          │             ╭──────────────( $100 )─────────────╮
#          │             │               ╲____╱              │
#          │             ▼                                   ▼
#          │  ╭──────────────────────╮            ╭──────────────────────╮
#          │  │ Access balance: $100 │            │ Access balance: $100 │
#          │  ╰──────────┬───────────╯            ╰──────────┬───────────╯
#          │             ▼                                   ▼
#          │  ╭──────────────────────╮            ╭──────────────────────╮
#          │  │ new value: 100─10=90 │            │ new value: 100─25=75 │
#          │  ╰──────────┬───────────╯            ╰──────────┬───────────╯
#          │             ▼                                   │
#          │  ╭──────────────────────╮                       │
#          │  │ set! balance to $90  │                       │
#          │  ╰──────────┬───────────╯    ____               │
#          │             │               ╱    ╲              │
#          │             ╰─────────────>( $ 90 )             ▼
#          │                             ╲____╱   ╭──────────────────────╮
#          │                                      │ new value: 100─25=75 │
#          │                              ____    ╰──────────┬───────────╯
#          │                             ╱    ╲              │
#          │                            ( $ 90 )<────────────╯
#          ▼                             ╲____╱
#         time
#       < art..
      ..art >
         │           Peter              Bank              Paul
         │                              ____
         │                             ╱    ╲
         │             ╭──────────────( $100 )─────────────╮
         │             │               ╲____╱              │
         │             ▼                                   ▼
         │  ╭──────────────────────╮            ╭──────────────────────╮
         │  │ Access balance: $100 │            │ Access balance: $100 │
         │  ╰──────────┬───────────╯            ╰──────────┬───────────╯
         │             ▼                                   ▼
         │  ╭──────────────────────╮            ╭──────────────────────╮
         │  │ new value: 100─10=90 │            │ new value: 100─25=75 │
         │  ╰──────────┬───────────╯            ╰──────────┬───────────╯
         │             ▼                                   │
         │  ╭──────────────────────╮                       │
         │  │ set! balance to $90  │                       │
         │  ╰──────────┬───────────╯    ____               │
         │             │               ╱    ╲              │
         │             ╰─────────────>( $ 90 )             ▼
         │                             ╲____╱   ╭──────────────────────╮
         │                                      │ new value: 100─25=75 │
         │                              ____    ╰──────────┬───────────╯
         │                             ╱    ╲              │
         │                            ( $ 90 )<────────────╯
         ▼                             ╲____╱
        time
      < art..

# @   ..img > img/chap3/Fig3.29b.std.svg
@   ..img > img/chap3/Fig3.29b.std.svg

#     The general phenomenon illustrated here is that several processes may share a
#     common state variable. What makes this complicated is that more than one
#     process may be trying to manipulate the shared state at the same time. For the
#     bank account example, during each transaction, each customer should be able to
#     act as if the other customers did not exist. When a customer changes the
#     balance in a way that depends on the balance, he must be able to assume that,
#     just before the moment of change, the balance is still what he thought it was.
    El fenómeno general aquí ilustrado es que varios procesos pueden compartir
    una variable de estado común. Lo que hace esto complicado es que más de un
    proceso puede estar tratando de manipular el estado compartido al mismo
    tiempo. Para el ejemplo de la cuenta bancaria, durante cada transacción,
    cada cliente debe poder actuar como si los otros clientes no
    existieran. Cuando un cliente cambia el equilibrio de una manera que depende
    de la balanza, debe ser capaz de asumir que, justo antes del momento del
    cambio, el equilibrio sigue siendo lo que él pensaba que era.

# **** Correct behavior of concurrent programs
**** Comportamiento correcto de los programas concurrentes

#      The above example typifies the subtle bugs that can creep into concurrent
#      programs. The root of this complexity lies in the assignments to variables
#      that are shared among the different processes. We already know that we must be
#      careful in writing programs that use @c(set!), because the results of a
#      computation depend on the order in which the assignments occur.@n(165) With
#      concurrent processes we must be especially careful about assignments, because
#      we may not be able to control the order of the assignments made by the
#      different processes. If several such changes might be made concurrently (as
#      with two depositors accessing a joint account) we need some way to ensure that
#      our system behaves correctly. For example, in the case of withdrawals from a
#      joint bank account, we must ensure that money is conserved. To make concurrent
#      programs behave correctly, we may have to place some restrictions on
#      concurrent execution.
     El ejemplo anterior tipifica los errores sutiles que pueden fluir en
     programas concurrentes. La raíz de esta complejidad radica en las
     asignaciones a variables que se comparten entre los diferentes procesos. Ya
     sabemos que debemos ser cuidadosos en la escritura de programas que usamos
     @c(set!), porque los resultados de un cálculo dependen del orden en el que
     ocurren las asignaciones.@n(165) Con procesos concurrentes tenemos
     que ser especialmente cuidadoso acerca de las asignaciones, porque es
     posible que no sea capaz de controlar el orden de las asignaciones hechas
     por los diferentes procesos. Si varios de estos cambios pueden realizarse
     simultáneamente (como con dos depositantes accediendo a una cuenta
     conjunta) necesitamos alguna manera de asegurar que nuestro sistema se
     comporte correctamente. Por ejemplo, en el caso de retiros de una cuenta
     bancaria conjunta, debemos asegurarnos de que el dinero se conserva.

#      One possible restriction on concurrency would stipulate that no two operations
#      that change any shared state variables can occur at the same time. This is an
#      extremely stringent requirement. For distributed banking, it would require the
#      system designer to ensure that only one transaction could proceed at a time.
#      This would be both inefficient and overly conservative. @l(#Figure 3.30) shows
#      Peter and Paul sharing a bank account, where Paul has a private account as
#      well. The diagram illustrates two withdrawals from the shared account (one by
#      Peter and one by Paul) and a deposit to Paul's private account.@n(166) The two
#      withdrawals from the shared account must not be concurrent (since both access
#      and update the same account), and Paul's deposit and withdrawal must not be
#      concurrent (since both access and update the amount in Paul's wallet). But
#      there should be no problem permitting Paul's deposit to his private account to
#      proceed concurrently with Peter's withdrawal from the shared account.
     Una posible restricción de la simultaneidad estipularía que no pueden
     ocurrir dos operaciones que cambien las variables de estado compartidas al
     mismo tiempo. Este es un requisito extremadamente estricto. Para la banca
     distribuida, requeriría que el diseñador del sistema garantizara que sólo
     una transacción podría proceder a la vez. Esto sería a la vez ineficiente y
     demasiado conservador. @l(#Figura 3.30) muestra a Peter y
     Paul compartiendo una cuenta bancaria, donde Paul también tiene una cuenta
     privada. El diagrama ilustra dos retiros de la cuenta compartida (uno por
     Pedro y uno por Pablo) y un depósito a la cuenta privada de
     Pablo.@n(166) Los dos retiros de la cuenta compartida no deben ser
     concurrentes (ya que tanto el acceso como la actualización de la misma
     cuenta), y Paul ' El depósito y la retirada de la cuenta no deben ser
     simultáneos (ya que tanto el acceso como la actualización de la cantidad en
     la cartera de Paul). Pero no debería haber ningún problema para permitir
     que el depósito de Pablo en su cuenta privada procediera simultáneamente
     con la retirada de Pedro de la cuenta compartida.

#      ..figure > @t(Figure 3.30) Concurrent deposits and withdrawals from a joint
#        account in Bank1 and a private account in Bank2.
     ..figure > @t(Figura 3.30) Depósitos y retiros concurrentes de una cuenta
       conjunta en el Banco1 y una cuenta privada en el Banco2.

#        ..art >
#           │    Peter          Bank1          Paul           Bank2
#           │    ____           ____           ____           ____
#           │   ╱    ╲         ╱    ╲         ╱    ╲         ╱    ╲
#           │  (  $7  )──╮ ╭──( $100 )       (  $5  )──╮ ╭──( $300 )
#           │   ╲____╱   ▼ ▼   ╲____╱         ╲____╱   ▼ ▼   ╲____╱
#           │           ╭───╮                         ╭───╮
#           │           │ W │                         │ D │
#           │    ____   ╰┬─┬╯   ____           ____   ╰┬─┬╯   ____
#           │   ╱    ╲   │ │   ╱    ╲         ╱    ╲   │ │   ╱    ╲
#           │  ( $17  )◀─╯ ╰─▶( $90  )──╮ ╭──(  $0  )◀─╯ ╰─▶( $305 )
#           │   ╲____╱         ╲____╱   ▼ ▼   ╲____╱         ╲____╱
#           │                          ╭───╮
#           │                          │ W │
#           │    ____           ____   ╰┬─┬╯   ____           ____
#           │   ╱    ╲         ╱    ╲   │ │   ╱    ╲         ╱    ╲
#           │  ( $17  )       ( $65  )◀─╯ ╰─▶( $25  )       ( $305 )
#           │   ╲____╱         ╲____╱         ╲____╱         ╲____╱
#           ▼
#          time
#        < art..
       ..art >
          │    Peter          Bank1          Paul           Bank2
          │    ____           ____           ____           ____
          │   ╱    ╲         ╱    ╲         ╱    ╲         ╱    ╲
          │  (  $7  )──╮ ╭──( $100 )       (  $5  )──╮ ╭──( $300 )
          │   ╲____╱   ▼ ▼   ╲____╱         ╲____╱   ▼ ▼   ╲____╱
          │           ╭───╮                         ╭───╮
          │           │ W │                         │ D │
          │    ____   ╰┬─┬╯   ____           ____   ╰┬─┬╯   ____
          │   ╱    ╲   │ │   ╱    ╲         ╱    ╲   │ │   ╱    ╲
          │  ( $17  )◀─╯ ╰─▶( $90  )──╮ ╭──(  $0  )◀─╯ ╰─▶( $305 )
          │   ╲____╱         ╲____╱   ▼ ▼   ╲____╱         ╲____╱
          │                          ╭───╮
          │                          │ W │
          │    ____           ____   ╰┬─┬╯   ____           ____
          │   ╱    ╲         ╱    ╲   │ │   ╱    ╲         ╱    ╲
          │  ( $17  )       ( $65  )◀─╯ ╰─▶( $25  )       ( $305 )
          │   ╲____╱         ╲____╱         ╲____╱         ╲____╱
          ▼
         time
       < art..

# @    ..img > img/chap3/Fig3.30c.std.svg
@    ..img > img/chap3/Fig3.30c.std.svg

#      A less stringent restriction on concurrency would ensure that a concurrent
#      system produces the same result as if the processes had run sequentially in
#      some order. There are two important aspects to this requirement. First, it
#      does not require the processes to actually run sequentially, but only to
#      produce results that are the same @e(as if) they had run sequentially. For the
#      example in @l(#Figure 3.30), the designer of the bank account system can
#      safely allow Paul's deposit and Peter's withdrawal to happen concurrently,
#      because the net result will be the same as if the two operations had happened
#      sequentially. Second, there may be more than one possible @"(correct) result
#      produced by a concurrent program, because we require only that the result be
#      the same as for @e(some) sequential order. For example, suppose that Peter and
#      Paul's joint account starts out with $100, and Peter deposits $40 while Paul
#      concurrently withdraws half the money in the account. Then sequential
#      execution could result in the account balance being either $70 or $90 (see
#      @l(#Exercise 3.38)).@n(167)
     Una restricción menos estricta en la concurrencia aseguraría que un sistema
     concurrente produzca el mismo resultado como si los procesos se hubieran
     ejecutado secuencialmente en algún orden. Hay dos aspectos importantes a
     este requisito. En primer lugar, no requiere que los procesos se ejecuten
     realmente secuencialmente, sino sólo para producir resultados que son los
     mismos @e(que si) se hubieran ejecutado secuencialmente. Para el ejemplo de
     la @l(#Figura 3.30), el diseñador del sistema de cuentas
     bancarias puede permitir que el depósito de Paul y el retiro de Peter
     ocurran simultáneamente, porque el resultado neto será el mismo que si las
     dos operaciones hubieran sucedido secuencialmente. En segundo lugar, puede
     haber más de un resultado @"(correcto) posible producido por un programa
     concurrente, @e(Porque sólo necesitamos que el resultado sea el mismo que
     para algún) orden secuencial. Por ejemplo, supongamos que la cuenta
     conjunta de Peter y Paul comienza con $ 100, y Peter deposita $ 40 mientras
     que Paul al mismo tiempo retira la mitad del dinero en la cuenta. Entonces
     la ejecución secuencial podría resultar en el saldo de la cuenta sea $ 70 o
     $ 90 (véase el @l(#Ejercicio 3.38) ).@n(167)

#      There are still weaker requirements for correct execution of concurrent
#      programs. A program for simulating diffusion (say, the flow of heat in an
#      object) might consist of a large number of processes, each one representing a
#      small volume of space, that update their values concurrently. Each process
#      repeatedly changes its value to the average of its own value and its
#      neighbors' values. This algorithm converges to the right answer independent of
#      the order in which the operations are done; there is no need for any
#      restrictions on concurrent use of the shared values.
     Todavía hay requisitos más débiles para la correcta ejecución de los
     programas concurrentes. Un programa para simular la difusión (por ejemplo,
     el flujo de calor en un objeto) puede consistir en un gran número de
     procesos, cada uno representando un pequeño volumen de espacio, que
     actualiza sus valores simultáneamente. Cada proceso cambia repetidamente su
     valor a la media de su propio valor y los valores de sus vecinos. Este
     algoritmo converge a la respuesta correcta independientemente del orden en
     que se realizan las operaciones; No hay necesidad de ninguna restricción
     sobre el uso concurrente de los valores compartidos.

#      :: @t(Exercise 3.38) :: Suppose that Peter, Paul, and Mary share a joint bank
#         account that initially contains $100. Concurrently, Peter deposits $10,
#         Paul withdraws $20, and Mary withdraws half the money in the account, by
#         executing the following commands:
     :: @t(Ejercicio 3.38) :: Supongamos que Pedro, Pablo y María comparten una
        cuenta bancaria conjunta que inicialmente contiene $ 100. Al mismo
        tiempo, Peter deposita $ 10, Paul retira $ 20, y Mary retira la mitad
        del dinero en la cuenta, ejecutando los siguientes comandos:

#         ..example >
#           Peter: (set! balance (+ balance 10))
#           Paul:  (set! balance (- balance 20))
#           Mary:  (set! balance (- balance
#                                   (/ balance 2)))
#         < example..
        ..example >
          Peter: (set! balance (+ balance 10))
          Paul:  (set! balance (- balance 20))
          Mary:  (set! balance (- balance
                                  (/ balance 2)))
        < example..

#         1. List all the different possible values for @c(balance) after these three
#            transactions have been completed, assuming that the banking system
#            forces the three processes to run sequentially in some order.
        1. Liste todos los diferentes valores posibles @c(balance) después de
           que estas tres transacciones se han completado, suponiendo que el
           sistema bancario obliga a los tres procesos a ejecutar
           secuencialmente en algún orden.

#         2. What are some other values that could be produced if the system allows
#            the processes to be interleaved?  Draw timing diagrams like the one in
#            @l(#Figure 3.29) to explain how these values can occur.
        2. ¿Cuáles son algunos otros valores que podrían producirse si el
           sistema permite que los procesos sean entrelazados? Dibuje diagramas
           de temporización como el de la @l(#Figura 3.29) para
           explicar cómo pueden ocurrir estos valores.

# *** 3.4.2 <> Mechanisms for Controlling Concurrency
*** 3.4.2 <> Mecanismos para controlar la concurrencia

#     We've seen that the difficulty in dealing with concurrent processes is rooted
#     in the need to consider the interleaving of the order of events in the
#     different processes. For example, suppose we have two processes, one with
#     three ordered events @m[(a, b, c)] and one with three ordered events @m[(x, y,
#     z)]. If the two processes run concurrently, with no constraints on how their
#     execution is interleaved, then there are 20 different possible orderings for
#     the events that are consistent with the individual orderings for the two
#     processes:
    Hemos visto que la dificultad de tratar con procesos concurrentes está
    enraizada en la necesidad de considerar el entrelazado del orden de sucesos
    en los diferentes procesos. Por ejemplo, supongamos que tenemos dos
    procesos, uno con tres eventos ordenados @m[(a, b, c)] y uno con tres
    eventos ordenados @m[(x, y, z)]. Si los dos procesos se ejecutan
    simultáneamente, sin restricciones sobre la forma en que su ejecución se
    entrelaza, entonces hay 20 órdenes diferentes posibles para los eventos que
    son consistentes con los pedidos individuales para los dos procesos:

#     ..example >
#       (a,b,c,x,y,z)  (a,x,b,y,c,z)  (x,a,b,c,y,z)
#       (x,a,y,z,b,c)  (a,b,x,c,y,z)  (a,x,b,y,z,c)
#       (x,a,b,y,c,z)  (x,y,a,b,c,z)  (a,b,x,y,c,z)
#       (a,x,y,b,c,z)  (x,a,b,y,z,c)  (x,y,a,b,z,c)
#       (a,b,x,y,z,c)  (a,x,y,b,z,c)  (x,a,y,b,c,z)
#       (x,y,a,z,b,c)  (a,x,b,c,y,z)  (a,x,y,z,b,c)
#       (x,a,y,b,z,c)  (x,y,z,a,b,c)
#     < example..
    ..example >
      (a,b,c,x,y,z)  (a,x,b,y,c,z)  (x,a,b,c,y,z)
      (x,a,y,z,b,c)  (a,b,x,c,y,z)  (a,x,b,y,z,c)
      (x,a,b,y,c,z)  (x,y,a,b,c,z)  (a,b,x,y,c,z)
      (a,x,y,b,c,z)  (x,a,b,y,z,c)  (x,y,a,b,z,c)
      (a,b,x,y,z,c)  (a,x,y,b,z,c)  (x,a,y,b,c,z)
      (x,y,a,z,b,c)  (a,x,b,c,y,z)  (a,x,y,z,b,c)
      (x,a,y,b,z,c)  (x,y,z,a,b,c)
    < example..

#     As programmers designing this system, we would have to consider the effects of
#     each of these 20 orderings and check that each behavior is acceptable. Such an
#     approach rapidly becomes unwieldy as the numbers of processes and events
#     increase.
    Como programadores que diseñan este sistema, tendríamos que considerar los
    efectos de cada uno de estos 20 pedidos y comprobar que cada comportamiento
    es aceptable. Este enfoque se vuelve rápidamente difícil de manejar a medida
    que aumenta el número de procesos y eventos.

#     A more practical approach to the design of concurrent systems is to devise
#     general mechanisms that allow us to constrain the interleaving of concurrent
#     processes so that we can be sure that the program behavior is correct. Many
#     mechanisms have been developed for this purpose. In this section, we describe
#     one of them, the @e(serializer).
    Un enfoque más práctico para el diseño de sistemas concurrentes es idear
    mecanismos generales que nos permitan restringir el entrelazado de procesos
    concurrentes para que podamos estar seguros de que el comportamiento del
    programa es correcto. Se han desarrollado muchos mecanismos para este
    propósito. En esta sección, describimos uno de ellos, el @e(serializador).

# **** Serializing access to shared state
**** Serializar el acceso al estado compartido

#      Serialization implements the following idea: Processes will execute
#      concurrently, but there will be certain collections of procedures that cannot
#      be executed concurrently. More precisely, serialization creates distinguished
#      sets of procedures such that only one execution of a procedure in each
#      serialized set is permitted to happen at a time. If some procedure in the set
#      is being executed, then a process that attempts to execute any procedure in
#      the set will be forced to wait until the first execution has finished.
     La serialización implementa la siguiente idea: Los procesos se ejecutarán
     simultáneamente, pero habrá ciertas colecciones de procedimientos que no se
     pueden ejecutar simultáneamente. Más precisamente, la serialización crea
     conjuntos distinguidos de procedimientos de tal manera que sólo una
     ejecución de un procedimiento en cada conjunto serializado se permite que
     suceda a la vez. Si se está ejecutando algún procedimiento en el conjunto,
     entonces un proceso que intenta ejecutar cualquier procedimiento en el
     conjunto se verá obligado a esperar hasta que la primera ejecución haya
     terminado.

#      We can use serialization to control access to shared variables. For example,
#      if we want to update a shared variable based on the previous value of that
#      variable, we put the access to the previous value of the variable and the
#      assignment of the new value to the variable in the same procedure. We then
#      ensure that no other procedure that assigns to the variable can run
#      concurrently with this procedure by serializing all of these procedures with
#      the same serializer. This guarantees that the value of the variable cannot be
#      changed between an access and the corresponding assignment.
     Podemos usar serialización para controlar el acceso a variables
     compartidas. Por ejemplo, si queremos actualizar una variable compartida
     basada en el valor anterior de esa variable, ponemos el acceso al valor
     anterior de la variable y la asignación del nuevo valor a la variable en el
     mismo procedimiento. A continuación, garantizamos que ningún otro
     procedimiento que asigna a la variable puede ejecutarse simultáneamente con
     este procedimiento serializando todos estos procedimientos con el mismo
     serializador. Esto garantiza que el valor de la variable no se puede
     cambiar entre un acceso y la asignación correspondiente.

# **** Serializers in Scheme
**** Serializadores en esquema

#      To make the above mechanism more concrete, suppose that we have extended
#      Scheme to include a procedure called @c(parallel-execute):
     Para hacer más concreto el mecanismo anterior, supongamos que hemos
     extendido el esquema para incluir un procedimiento llamado
     @c(parallel-execute):

#      ..src > scheme
#        (parallel-execute ⟨p₁⟩
#                          ⟨p₂⟩
#                          …
#                          ⟨pₖ⟩)
#      < src..
     ..src > scheme
       (parallel-execute ⟨p₁⟩
                         ⟨p₂⟩
                         …
                         ⟨pₖ⟩)
     < src..

#      Each @c(⟨p⟩) must be a procedure of no arguments. @c(Parallel-execute) creates
#      a separate process for each @c(⟨p⟩), which applies @c(⟨p⟩) (to no
#      arguments). These processes all run concurrently.@n(168)
     Cada uno @c(⟨p⟩) debe ser un procedimiento sin
     argumentos. @c(Parallel-execute) Crea un proceso separado para cada uno
     @c(⟨p⟩), que se aplica @c(⟨p⟩)(sin argumentos). Todos estos procesos se
     ejecutan simultáneamente.@n(168)

#      As an example of how this is used, consider
     Como ejemplo de cómo se usa esto, considere

#      ..src > scheme
#        (define x 10)
#        (parallel-execute (lambda () (set! x (* x x)))
#                          (lambda () (set! x (+ x 1))))
#      < src..
     ..src > scheme
       (define x 10)
       (parallel-execute (lambda () (set! x (* x x)))
                         (lambda () (set! x (+ x 1))))
     < src..

#      This creates two concurrent processes––@m(P₁), which sets @c(x) to @c(x) times
#      @c(x), and @m(P₂), which increments @c(x). After execution is complete, @c(x)
#      will be left with one of five possible values, depending on the interleaving
#      of the events of @m(P₁) and @m(P₂):
     Esto crea dos procesos simultáneos - @m(P₁), que fija @c(x) a @c(x) tiempos
     @c(x), y @m(P₂), que incrementa @c(x). Una vez completada la ejecución,
     @c(x) se dejará con uno de los cinco valores posibles, dependiendo de la
     intercalación de los eventos de @m(P )@m($ )@m(₁ )@m($) y @m(P )@m($ )@m(₂
     $) :

#      - 101: @m(P₁) sets @c(x) to 100 and then @m(P₂) increments
#             @c(x) to 101.
     - 101: @m(P₁) fija @c(x) a 100 y después @m(P₂) aumenta @c(x) a 101.

#      - 121: @m(P₂) increments @c(x) to 11 and then @m(P₁) sets
#             @c(x) to @c(x) times @c(x).
     - 121: @m(P₂) incrementos @c(x) a 11 y luego @m(P₁) establece @c(x) a @c(x)
       veces @c(x).

#      - 110: @m(P₂) changes @c(x) from 10 to 11 between the
#             two times that @m(P₁) accesses the value of
#             @c(x) during the evaluation of @c[(* x x)].
     - 110: @m(P₂) cambia @c(x) de 10 a 11 entre las dos veces que @m(P₁) accede
       al valor de @c(x) durante la evaluación de @c[(* x x)].

#      - 11: @m(P₂) accesses @c(x), then @m(P₁) sets @c(x) to 100,
#             then @m(P₂) sets @c(x).
     - 11: @m(P $ ₂ $) accede @c(x), entonces @m(P $ ₁ $) establece @c(x) a 100,
       luego @m(P $ ₂ $) establece @c(x).

#      - 100: @m(P₁) accesses @c(x) (twice), then @m(P₂) sets
#             @c(x) to 11, then @m(P₁) sets @c(x).
     - 100: @m(P $ ₁ $) accede @c(x)(dos veces), después @m(P $ ₂ $) establece
       @c(x) a 11, entonces @m(P $ ₁ $) establece @c(x).

#      We can constrain the concurrency by using serialized procedures, which are
#      created by @e(serializers). Serializers are constructed by
#      @c(make-serializer), whose implementation is given below. A serializer takes a
#      procedure as argument and returns a serialized procedure that behaves like the
#      original procedure. All calls to a given serializer return serialized
#      procedures in the same set.
     Podemos restringir la concurrencia mediante el uso de procedimientos
     serializados, que son creados por los @e(serializadores). Los
     serializadores son construidos por @c(make-serializer), cuya implementación
     se da a continuación. Un serializador toma un procedimiento como argumento
     y devuelve un procedimiento serializado que se comporta como el
     procedimiento original. Todas las llamadas a un serializador determinado
     devuelven procedimientos serializados en el mismo conjunto.

#      Thus, in contrast to the example above, executing
     Así, en contraste con el ejemplo anterior, la ejecución

#      ..src > scheme
#        (define x 10)
#        (define s (make-serializer))
#        (parallel-execute
#         (s (lambda () (set! x (* x x))))
#         (s (lambda () (set! x (+ x 1)))))
#      < src..
     ..src > scheme
       (define x 10)
       (define s (make-serializer))
       (parallel-execute
        (s (lambda () (set! x (* x x))))
        (s (lambda () (set! x (+ x 1)))))
     < src..

#      can produce only two possible values for @c(x), 101 or 121. The other
#      possibilities are eliminated, because the execution of @m(P₁) and @m(P₂)
#      cannot be interleaved.
     Puede producir solamente dos valores posibles para @c(x), 101 o 121. Las
     otras posibilidades se eliminan, porque la ejecución de @m(P )@m($ )@m(₁
     )@m($) y @m(P )@m($ )@m(₂ $) no puede ser intercalada.

#      Here is a version of the @c(make-account) procedure from @l(#3.1.1), where the
#      deposits and withdrawals have been serialized:
     He aquí una versión del procedimiento @c(make-account) de
     @l(#3.1.1), donde los depósitos y retiros han sido serializados:

#      ..src > scheme
#        (define (make-account balance)
#          (define (withdraw amount)
#            (if (>= balance amount)
#                (begin (set! balance
#                             (- balance amount))
#                       balance)
#                "Insufficient funds"))
#          (define (deposit amount)
#            (set! balance (+ balance amount))
#            balance)
#          (let ((protected (make-serializer)))
#            (define (dispatch m)
#              (cond ((eq? m 'withdraw)
#                     (protected withdraw))
#                    ((eq? m 'deposit)
#                     (protected deposit))
#                    ((eq? m 'balance)
#                     balance)
#                    (else (error "Unknown request:
#                                  MAKE-ACCOUNT"
#                                 m))))
#            dispatch))
#      < src..
     ..src > scheme
       (define (make-account balance)
         (define (withdraw amount)
           (if (>= balance amount)
               (begin (set! balance
                            (- balance amount))
                      balance)
               "Insufficient funds"))
         (define (deposit amount)
           (set! balance (+ balance amount))
           balance)
         (let ((protected (make-serializer)))
           (define (dispatch m)
             (cond ((eq? m 'withdraw)
                    (protected withdraw))
                   ((eq? m 'deposit)
                    (protected deposit))
                   ((eq? m 'balance)
                    balance)
                   (else (error "Unknown request:
                                 MAKE-ACCOUNT"
                                m))))
           dispatch))
     < src..

#      With this implementation, two processes cannot be withdrawing from or
#      depositing into a single account concurrently. This eliminates the source of
#      the error illustrated in @l(#Figure 3.29), where Peter changes the account
#      balance between the times when Paul accesses the balance to compute the new
#      value and when Paul actually performs the assignment. On the other hand, each
#      account has its own serializer, so that deposits and withdrawals for different
#      accounts can proceed concurrently.
     Con esta implementación, dos procesos no pueden retirarse o depositarse en
     una sola cuenta de forma concurrente. Esto elimina la fuente del error
     ilustrado en la @l(#Figura 3.29), donde Peter cambia el
     balance de la cuenta entre los momentos en que Pablo accede al saldo para
     calcular el nuevo valor y cuando Pablo realmente realiza la asignación. Por
     otra parte, cada cuenta tiene su propio serializador, por lo que los
     depósitos y retiros para diferentes cuentas pueden proceder
     simultáneamente.

#      :: @t(Exercise 3.39) :: Which of the five possibilities in the parallel
#         execution shown above remain if we instead serialize execution as follows:
     :: @t(Ejercicio 3.39) :: ¿Cuál de las cinco posibilidades en la ejecución
        paralela mostrada arriba permanece si en lugar de ello serializamos la
        ejecución como sigue:

#         ..src > scheme
#           (define x 10)
#           (define s (make-serializer))
#           (parallel-execute
#             (lambda ()
#               (set! x ((s (lambda () (* x x))))))
#             (s (lambda () (set! x (+ x 1)))))
#         < src..
        ..src > scheme
          (define x 10)
          (define s (make-serializer))
          (parallel-execute
            (lambda ()
              (set! x ((s (lambda () (* x x))))))
            (s (lambda () (set! x (+ x 1)))))
        < src..

#      :: @t(Exercise 3.40) :: Give all possible values of @c(x) that can result from
#         executing
     :: @t(Ejercicio 3.40) :: Dar todos los valores posibles de @c(x) que puede
        resultar de la ejecución

#         ..src > scheme
#           (define x 10)
#           (parallel-execute
#            (lambda () (set! x (* x x)))
#            (lambda () (set! x (* x x x))))
#         < src..
        ..src > scheme
          (define x 10)
          (parallel-execute
           (lambda () (set! x (* x x)))
           (lambda () (set! x (* x x x))))
        < src..

#         Which of these possibilities remain if we instead use serialized
#         procedures:
        ¿Cuáles de estas posibilidades quedan si usamos procedimientos
        serializados?

#         ..src > scheme
#           (define x 10)
#           (define s (make-serializer))
#           (parallel-execute
#            (s (lambda () (set! x (* x x))))
#            (s (lambda () (set! x (* x x x)))))
#         < src..
        ..src > scheme
          (define x 10)
          (define s (make-serializer))
          (parallel-execute
           (s (lambda () (set! x (* x x))))
           (s (lambda () (set! x (* x x x)))))
        < src..

#      :: @t(Exercise 3.41) :: Ben Bitdiddle worries that it would be better to
#         implement the bank account as follows (where the commented line has been
#         changed):
     :: @t(Ejercicio 3.41) :: Ben Bitdiddle se preocupa de que sería mejor
        implementar la cuenta bancaria de la siguiente manera (donde se ha
        cambiado la línea comentada):

#         ..src > scheme
#           (define (make-account balance)
#             (define (withdraw amount)
#               (if (>= balance amount)
#                   (begin
#                     (set! balance
#                           (- balance amount))
#                     balance)
#                   "Insufficient funds"))
#             (define (deposit amount)
#               (set! balance (+ balance amount))
#               balance)
#             (let ((protected (make-serializer)))
#               (define (dispatch m)
#                 (cond ((eq? m 'withdraw)
#                        (protected withdraw))
#                       ((eq? m 'deposit)
#                        (protected deposit))
#                       ((eq? m 'balance)
#                        ((protected
#                           (lambda ()
#                             balance)))) ; serialized
#                       (else
#                        (error
#                         "Unknown request:
#                          MAKE-ACCOUNT"
#                         m))))
#               dispatch))
#         < src..
        ..src > scheme
          (define (make-account balance)
            (define (withdraw amount)
              (if (>= balance amount)
                  (begin
                    (set! balance
                          (- balance amount))
                    balance)
                  "Insufficient funds"))
            (define (deposit amount)
              (set! balance (+ balance amount))
              balance)
            (let ((protected (make-serializer)))
              (define (dispatch m)
                (cond ((eq? m 'withdraw)
                       (protected withdraw))
                      ((eq? m 'deposit)
                       (protected deposit))
                      ((eq? m 'balance)
                       ((protected
                          (lambda ()
                            balance)))) ; serialized
                      (else
                       (error
                        "Unknown request:
                         MAKE-ACCOUNT"
                        m))))
              dispatch))
        < src..

#         because allowing unserialized access to the bank balance can result in
#         anomalous behavior. Do you agree?  Is there any scenario that demonstrates
#         Ben's concern?
        Porque permitir el acceso sin serializado al saldo bancario puede
        resultar en un comportamiento anómalo. ¿Estás de acuerdo? ¿Hay algún
        escenario que demuestre la preocupación de Ben?

#      :: @t(Exercise 3.42) :: Ben Bitdiddle suggests that it's a waste of time to
#         create a new serialized procedure in response to every @c(withdraw) and
#         @c(deposit) message. He says that @c(make-account) could be changed so that
#         the calls to @c(protected) are done outside the @c(dispatch)
#         procedure. That is, an account would return the same serialized procedure
#         (which was created at the same time as the account) each time it is asked
#         for a withdrawal procedure.
     :: @t(Ejercicio 3.42) :: Ben Bitdiddle sugiere que es una pérdida de tiempo
        para crear un nuevo procedimiento serializado en respuesta a todas
        @c(withdraw) y @c(deposit) mensaje. Dice que se @c(make-account) podría
        cambiar para que las llamadas a @c(protected) se realicen fuera del
        procedimiento @c(dispatch). Es decir, una cuenta devolvería el mismo
        procedimiento serializado (que se creó al mismo tiempo que la cuenta)
        cada vez que se solicita un procedimiento de retiro.

#         ..src > scheme
#           (define (make-account balance)
#             (define (withdraw amount)
#               (if (>= balance amount)
#                   (begin (set! balance
#                                (- balance amount))
#                          balance)
#                   "Insufficient funds"))
#             (define (deposit amount)
#               (set! balance (+ balance amount))
#               balance)
#             (let ((protected (make-serializer)))
#               (let ((protected-withdraw
#                      (protected withdraw))
#                     (protected-deposit
#                      (protected deposit)))
#                 (define (dispatch m)
#                   (cond ((eq? m 'withdraw)
#                          protected-withdraw)
#                         ((eq? m 'deposit)
#                          protected-deposit)
#                         ((eq? m 'balance)
#                          balance)
#                         (else
#                          (error "Unknown request:
#                                  MAKE-ACCOUNT"
#                                 m))))
#                 dispatch)))
#         < src..
        ..src > scheme
          (define (make-account balance)
            (define (withdraw amount)
              (if (>= balance amount)
                  (begin (set! balance
                               (- balance amount))
                         balance)
                  "Insufficient funds"))
            (define (deposit amount)
              (set! balance (+ balance amount))
              balance)
            (let ((protected (make-serializer)))
              (let ((protected-withdraw
                     (protected withdraw))
                    (protected-deposit
                     (protected deposit)))
                (define (dispatch m)
                  (cond ((eq? m 'withdraw)
                         protected-withdraw)
                        ((eq? m 'deposit)
                         protected-deposit)
                        ((eq? m 'balance)
                         balance)
                        (else
                         (error "Unknown request:
                                 MAKE-ACCOUNT"
                                m))))
                dispatch)))
        < src..

#         Is this a safe change to make?  In particular, is there any difference in
#         what concurrency is allowed by these two versions of @c(make-account)?
        ¿Es un cambio seguro? En particular, ¿hay alguna diferencia en lo que la
        simultaneidad es permitida por estas dos versiones de @c(make-account)?

# **** Complexity of using multiple shared resources
**** Complejidad del uso de múltiples recursos compartidos

#      Serializers provide a powerful abstraction that helps isolate the complexities
#      of concurrent programs so that they can be dealt with carefully and
#      (hopefully) correctly. However, while using serializers is relatively
#      straightforward when there is only a single shared resource (such as a single
#      bank account), concurrent programming can be treacherously difficult when
#      there are multiple shared resources.
     Los serializadores proporcionan una poderosa abstracción que ayuda a aislar
     las complejidades de los programas concurrentes para que puedan ser
     tratados con cuidado y (espero) correctamente. Sin embargo, si bien el uso
     de serializadores es relativamente sencillo cuando sólo hay un único
     recurso compartido (como una cuenta bancaria única), la programación
     concurrente puede ser difícilmente traicionera cuando hay varios recursos
     compartidos.

#      To illustrate one of the difficulties that can arise, suppose we wish to swap
#      the balances in two bank accounts. We access each account to find the balance,
#      compute the difference between the balances, withdraw this difference from one
#      account, and deposit it in the other account. We could implement this as
#      follows:@n(169)
     Para ilustrar una de las dificultades que pueden surgir, supongamos que
     deseamos intercambiar los saldos en dos cuentas bancarias. Accedemos a cada
     cuenta para encontrar el saldo, calcular la diferencia entre los saldos,
     retirar esta diferencia de una cuenta y depositarla en la otra
     cuenta. Podríamos implementar esto como sigue:@n(169)

#      ..src > scheme
#        (define (exchange account1 account2)
#          (let ((difference (- (account1 'balance)
#                               (account2 'balance))))
#            ((account1 'withdraw) difference)
#            ((account2 'deposit) difference)))
#      < src..
     ..src > scheme
       (define (exchange account1 account2)
         (let ((difference (- (account1 'balance)
                              (account2 'balance))))
           ((account1 'withdraw) difference)
           ((account2 'deposit) difference)))
     < src..

#      This procedure works well when only a single process is trying to do the
#      exchange. Suppose, however, that Peter and Paul both have access to accounts
#      @m(a1), @m(a2), and @m(a3), and that Peter exchanges @m(a1) and @m(a2) while
#      Paul concurrently exchanges @m(a1) and @m(a3). Even with account deposits and
#      withdrawals serialized for individual accounts (as in the @c(make-account)
#      procedure shown above in this section), @c(exchange) can still produce
#      incorrect results. For example, Peter might compute the difference in the
#      balances for @m(a1) and @m(a2), but then Paul might change the balance in
#      @m(a1) before Peter is able to complete the exchange.@n(170) For correct
#      behavior, we must arrange for the @c(exchange) procedure to lock out any other
#      concurrent accesses to the accounts during the entire time of the exchange.
     Este procedimiento funciona bien cuando sólo un único proceso está
     intentando hacer el intercambio. Supongamos, sin embargo, que Pedro y Pablo
     tienen acceso a las cuentas @m(a1), @m(a2) y @m(a3), y que Peter
     intercambia @m(a1) y @m(a2) mientras que Pablo comparte simultáneamente
     @m(a1) y @m(a3). Incluso con los depósitos en cuenta y los retiros
     serializados para cuentas individuales (como en el procedimiento @c(make-account) mostrado arriba en esta sección), @c(exchange) todavía pueden
     producir resultados incorrectos. Por ejemplo, Pedro podría calcular la
     diferencia en los saldos de @m(a1) y @m(a2), pero entonces Paul podría
     cambiar el equilibrio en @m(a1) antes de que Pedro sea capaz de completar
     el intercambio.@n(170)

#      One way we can accomplish this is by using both accounts' serializers to
#      serialize the entire @c(exchange) procedure. To do this, we will arrange for
#      access to an account's serializer. Note that we are deliberately breaking the
#      modularity of the bank-account object by exposing the serializer. The
#      following version of @c(make-account) is identical to the original version
#      given in section @l(#3.1.1), except that a serializer is provided to protect the
#      balance variable, and the serializer is exported via message passing:
     Una manera de lograr esto es utilizando los serializadores de ambas cuentas
     para serializar todo el procedimiento @c(exchange). Para ello, haremos
     arreglos para acceder al serializador de una cuenta. Tenga en cuenta que
     estamos deliberadamente romper la modularidad del objeto de cuenta bancaria
     exponiendo el serializador. La siguiente versión de @c(make-account) es
     idéntica a la versión original dada en la seccion @l(#3.1.1), excepto que se
     proporciona un serializador para proteger la variable de balance y el
     serializador se exporta a través del paso de mensajes:

#      ..src > scheme
#        (define (make-account-and-serializer balance)
#          (define (withdraw amount)
#            (if (>= balance amount)
#                (begin
#                  (set! balance (- balance amount))
#                  balance)
#                "Insufficient funds"))
#          (define (deposit amount)
#            (set! balance (+ balance amount))
#            balance)
#          (let ((balance-serializer
#                 (make-serializer)))
#            (define (dispatch m)
#              (cond ((eq? m 'withdraw) withdraw)
#                    ((eq? m 'deposit) deposit)
#                    ((eq? m 'balance) balance)
#                    ((eq? m 'serializer)
#                     balance-serializer)
#                    (else (error "Unknown request:
#                                  MAKE-ACCOUNT"
#                                 m))))
#            dispatch))
#      < src..
     ..src > scheme
       (define (make-account-and-serializer balance)
         (define (withdraw amount)
           (if (>= balance amount)
               (begin
                 (set! balance (- balance amount))
                 balance)
               "Insufficient funds"))
         (define (deposit amount)
           (set! balance (+ balance amount))
           balance)
         (let ((balance-serializer
                (make-serializer)))
           (define (dispatch m)
             (cond ((eq? m 'withdraw) withdraw)
                   ((eq? m 'deposit) deposit)
                   ((eq? m 'balance) balance)
                   ((eq? m 'serializer)
                    balance-serializer)
                   (else (error "Unknown request:
                                 MAKE-ACCOUNT"
                                m))))
           dispatch))
     < src..

#      We can use this to do serialized deposits and withdrawals. However, unlike our
#      earlier serialized account, it is now the responsibility of each user of
#      bank-account objects to explicitly manage the serialization, for example as
#      follows:@n(171)
     Podemos usar esto para hacer depósitos y retiros serializados. Sin embargo,
     a diferencia de nuestra cuenta serializada anterior, ahora es
     responsabilidad de cada usuario de objetos de cuenta bancaria administrar
     explícitamente la serialización, por ejemplo de la siguiente manera:
    @n(171)

#      ..src > scheme
#        (define (deposit account amount)
#          (let ((s (account 'serializer))
#                (d (account 'deposit)))
#            ((s d) amount)))
#      < src..
     ..src > scheme
       (define (deposit account amount)
         (let ((s (account 'serializer))
               (d (account 'deposit)))
           ((s d) amount)))
     < src..

#      Exporting the serializer in this way gives us enough flexibility to implement
#      a serialized exchange program. We simply serialize the original @c(exchange)
#      procedure with the serializers for both accounts:
     Exportar el serializador de esta manera nos da suficiente flexibilidad para
     implementar un programa de intercambio serializado. Simplemente
     serializamos el procedimiento @c(exchange) original con los serializadores
     para ambas cuentas:

#      ..src > scheme
#        (define (serialized-exchange account1 account2)
#          (let ((serializer1 (account1 'serializer))
#                (serializer2 (account2 'serializer)))
#            ((serializer1 (serializer2 exchange))
#             account1
#             account2)))
#      < src..
     ..src > scheme
       (define (serialized-exchange account1 account2)
         (let ((serializer1 (account1 'serializer))
               (serializer2 (account2 'serializer)))
           ((serializer1 (serializer2 exchange))
            account1
            account2)))
     < src..

#      :: @t(Exercise 3.43) :: Suppose that the balances in three accounts start out
#         as $10, $20, and $30, and that multiple processes run, exchanging the
#         balances in the accounts. Argue that if the processes are run sequentially,
#         after any number of concurrent exchanges, the account balances should be
#         $10, $20, and $30 in some order. Draw a timing diagram like the one in
#         @l(#Figure 3.29) to show how this condition can be violated if the
#         exchanges are implemented using the first version of the account-exchange
#         program in this section. On the other hand, argue that even with this
#         @c(exchange) program, the sum of the balances in the accounts will be
#         preserved. Draw a timing diagram to show how even this condition would be
#         violated if we did not serialize the transactions on individual accounts.
     :: @t(Ejercicio 3.43) :: Suponga que los saldos en tres cuentas comienzan
        como $ 10, $ 20 y $ 30, y que se ejecutan múltiples procesos,
        intercambiando los saldos en las cuentas. Sostenga que si los procesos
        se ejecutan secuencialmente, después de cualquier número de intercambios
        concurrentes, los saldos de la cuenta deben ser $ 10, $ 20 y $ 30 en
        algún orden. Dibuje un diagrama de tiempos como el de la
        @l(#Figura 3.29) para mostrar cómo se puede violar esta
        condición si los intercambios se implementan utilizando la primera
        versión del programa de intercambio de cuentas de esta sección. Por otra
        parte, sostienen que incluso con este @c(exchange) programa, la suma de
        los saldos en las cuentas se conservarán. Dibuje un diagrama de tiempos
        para mostrar cómo incluso esta condición sería violada si no
        serializamos las transacciones en cuentas individuales.

#      :: @t(Exercise 3.44) :: Consider the problem of transferring an amount from
#         one account to another. Ben Bitdiddle claims that this can be accomplished
#         with the following procedure, even if there are multiple people
#         concurrently transferring money among multiple accounts, using any account
#         mechanism that serializes deposit and withdrawal transactions, for example,
#         the version of @c(make-account) in the text above.
     :: @t(Ejercicio 3.44) :: Considere el problema de transferir una cantidad
        de una cuenta a otra. Ben Bitdiddle afirma que esto puede lograrse con
        el siguiente procedimiento, incluso si hay varias personas que
        simultáneamente transfiere dinero entre varias cuentas, utilizando
        cualquier mecanismo de cuenta que serialice las transacciones de
        depósito y retiro, por ejemplo, la versión de @c(make-account) en el
        texto anterior.

#         ..src > scheme
#           (define
#             (transfer from-account to-account amount)
#             ((from-account 'withdraw) amount)
#             ((to-account 'deposit) amount))
#         < src..
        ..src > scheme
          (define
            (transfer from-account to-account amount)
            ((from-account 'withdraw) amount)
            ((to-account 'deposit) amount))
        < src..

#         Louis Reasoner claims that there is a problem here, and that we need to use
#         a more sophisticated method, such as the one required for dealing with the
#         exchange problem. Is Louis right?  If not, what is the essential difference
#         between the transfer problem and the exchange problem?  (You should assume
#         that the balance in @c(from-account) is at least @c(amount).)
        Louis Reasoner afirma que hay un problema aquí, y que necesitamos usar
        un método más sofisticado, como el requerido para tratar con el problema
        del intercambio. Louis tiene razón? De no ser así, ¿cuál es la
        diferencia esencial entre el problema de la transferencia y el problema
        del intercambio? (Debería asumir que el saldo @c(from-account) es por lo
        menos @c(amount).)

#      :: @t(Exercise 3.45) :: Louis Reasoner thinks our bank-account system is
#         unnecessarily complex and error-prone now that deposits and withdrawals
#         aren't automatically serialized. He suggests that
#         @c(make-account-and-serializer) should have exported the serializer (for
#         use by such procedures as @c(serialized-exchange)) in addition to (rather
#         than instead of) using it to serialize accounts and deposits as
#         @c(make-account) did. He proposes to redefine accounts as follows:
     :: @t(Ejercicio 3.45) :: Louis Reasoner piensa que nuestro sistema de
        cuentas bancarias es innecesariamente complejo y propenso a errores
        ahora que los depósitos y los retiros no se serializan
        automáticamente. Sugiere que @c(make-account-and-serializer) debería
        haber exportado el serializador (para el uso de tales procedimientos
        como @c(serialized-exchange)) además de (en lugar de en lugar de)
        utilizarlo para serializar cuentas y depósitos como lo @c(make-account)
        hizo. Propone redefinir las cuentas de la siguiente manera:

#         ..src > scheme
#           (define
#             (make-account-and-serializer balance)
#             (define (withdraw amount)
#               (if (>= balance amount)
#                   (begin (set! balance
#                                (- balance amount))
#                          balance)
#                   "Insufficient funds"))
#             (define (deposit amount)
#               (set! balance (+ balance amount))
#               balance)
#             (let ((balance-serializer
#                    (make-serializer)))
#               (define (dispatch m)
#                 (cond ((eq? m 'withdraw)
#                        (balance-serializer withdraw))
#                       ((eq? m 'deposit)
#                        (balance-serializer deposit))
#                       ((eq? m 'balance)
#                        balance)
#                       ((eq? m 'serializer)
#                        balance-serializer)
#                       (else (error "Unknown request:
#                                     MAKE-ACCOUNT"
#                                    m))))
#               dispatch))
#         < src..
        ..src > scheme
          (define
            (make-account-and-serializer balance)
            (define (withdraw amount)
              (if (>= balance amount)
                  (begin (set! balance
                               (- balance amount))
                         balance)
                  "Insufficient funds"))
            (define (deposit amount)
              (set! balance (+ balance amount))
              balance)
            (let ((balance-serializer
                   (make-serializer)))
              (define (dispatch m)
                (cond ((eq? m 'withdraw)
                       (balance-serializer withdraw))
                      ((eq? m 'deposit)
                       (balance-serializer deposit))
                      ((eq? m 'balance)
                       balance)
                      ((eq? m 'serializer)
                       balance-serializer)
                      (else (error "Unknown request:
                                    MAKE-ACCOUNT"
                                   m))))
              dispatch))
        < src..

#         Then deposits are handled as with the original @c(make-account):
        Entonces los depósitos se manejan como con el original @c(make-account):

#         ..src > scheme
#           (define (deposit account amount)
#             ((account 'deposit) amount))
#         < src..
        ..src > scheme
          (define (deposit account amount)
            ((account 'deposit) amount))
        < src..

#         Explain what is wrong with Louis's reasoning. In particular, consider what
#         happens when @c(serialized-exchange) is called.
        Explica lo que está mal con el razonamiento de Louis. En particular,
        considere lo que sucede cuando @c(serialized-exchange) se llama.

# **** Implementing serializers
**** Implementación de serializadores

#      We implement serializers in terms of a more primitive synchronization
#      mechanism called a @e(mutex). A mutex is an object that supports two
#      operations––the mutex can be @e(acquired), and the mutex can be
#      @e(released). Once a mutex has been acquired, no other acquire operations on
#      that mutex may proceed until the mutex is released.@n(172) In our
#      implementation, each serializer has an associated mutex. Given a procedure
#      @c(p), the serializer returns a procedure that acquires the mutex, runs @c(p),
#      and then releases the mutex. This ensures that only one of the procedures
#      produced by the serializer can be running at once, which is precisely the
#      serialization property that we need to guarantee.
     Implementamos serializadores en términos de un mecanismo de sincronización
     más primitivo llamado @e(mutex). Un mutex es un objeto que soporta dos
     operaciones - el mutex puede ser @e(adquirido), y el mutex puede ser
     @e(liberado). Una vez que se ha adquirido un mutex, ninguna otra operación
     de adquisición en ese mutex puede continuar hasta que se muestre el
     mutex.@n(172) En nuestra implementación, cada serializador tiene un
     mutex asociado. Dado un procedimiento @c(p), el serializador devuelve un
     procedimiento que adquiere el mutex, se ejecuta @c(p) y, a continuación,
     libera el mutex. Esto garantiza que sólo uno de los procedimientos
     producidos por el serializador puede ejecutarse a la vez, que es
     precisamente la propiedad de serialización que necesitamos garantizar.

#      ..src > scheme
#        (define (make-serializer)
#          (let ((mutex (make-mutex)))
#            (lambda (p)
#              (define (serialized-p . args)
#                (mutex 'acquire)
#                (let ((val (apply p args)))
#                  (mutex 'release)
#                  val))
#              serialized-p)))
#      < src..
     ..src > scheme
       (define (make-serializer)
         (let ((mutex (make-mutex)))
           (lambda (p)
             (define (serialized-p . args)
               (mutex 'acquire)
               (let ((val (apply p args)))
                 (mutex 'release)
                 val))
             serialized-p)))
     < src..

#      The mutex is a mutable object (here we'll use a one-element list, which we'll
#      refer to as a @e(cell)) that can hold the value true or false. When the value
#      is false, the mutex is available to be acquired. When the value is true, the
#      mutex is unavailable, and any process that attempts to acquire the mutex must
#      wait.
     El mutex es un objeto mutable (aquí vamos a usar una lista de un solo
     elemento, a la que nos referiremos como una @e(celda) ) que puede contener
     el valor verdadero o falso. Cuando el valor es falso, el mutex está
     disponible para ser adquirido. Cuando el valor es true, el mutex no está
     disponible, y cualquier proceso que intente adquirir el mutex debe esperar.

#      Our mutex constructor @c(make-mutex) begins by initializing the cell contents
#      to false. To acquire the mutex, we test the cell. If the mutex is available,
#      we set the cell contents to true and proceed. Otherwise, we wait in a loop,
#      attempting to acquire over and over again, until we find that the mutex is
#      available.@n(173) To release the mutex, we set the cell contents to false.
     Nuestro constructor mutex @c(make-mutex) comienza inicializando el
     contenido de la celda a false. Para adquirir el mutex, probamos la
     célula. Si el mutex está disponible, ponemos el contenido de la celda a
     true y procedemos. De lo contrario, esperamos en un bucle, tratando de
     adquirir una y otra vez, hasta que encontremos que el mutex está
     disponible.@n(173) Para liberar el mutex, fijamos los contenidos de
     las celdas en false.

#      ..src > scheme
#        (define (make-mutex)
#          (let ((cell (list false)))
#            (define (the-mutex m)
#              (cond ((eq? m 'acquire)
#                     (if (test-and-set! cell)
#                         (the-mutex 'acquire))) ; retry
#                    ((eq? m 'release) (clear! cell))))
#            the-mutex))
#        (define (clear! cell) (set-car! cell false))
#      < src..
     ..src > scheme
       (define (make-mutex)
         (let ((cell (list false)))
           (define (the-mutex m)
             (cond ((eq? m 'acquire)
                    (if (test-and-set! cell)
                        (the-mutex 'acquire))) ; retry
                   ((eq? m 'release) (clear! cell))))
           the-mutex))
       (define (clear! cell) (set-car! cell false))
     < src..

#      @c(Test-and-set!) tests the cell and returns the result of the test. In
#      addition, if the test was false, @c(test-and-set!) sets the cell contents to
#      true before returning false. We can express this behavior as the following
#      procedure:
     @c(Test-and-set!) Prueba la célula y devuelve el resultado de la
     prueba. Además, si la prueba era falsa, @c(test-and-set!) establece el
     contenido de la celda en true antes de devolver false. Podemos expresar
     este comportamiento como el siguiente procedimiento:

#      ..src > scheme
#        (define (test-and-set! cell)
#          (if (car cell)
#              true
#              (begin (set-car! cell true)
#                     false)))
#      < src..
     ..src > scheme
       (define (test-and-set! cell)
         (if (car cell)
             true
             (begin (set-car! cell true)
                    false)))
     < src..

#      However, this implementation of @c(test-and-set!) does not suffice as it
#      stands. There is a crucial subtlety here, which is the essential place where
#      concurrency control enters the system: The @c(test-and-set!) operation must be
#      performed @e(atomically). That is, we must guarantee that, once a process has
#      tested the cell and found it to be false, the cell contents will actually be
#      set to true before any other process can test the cell. If we do not make this
#      guarantee, then the mutex can fail in a way similar to the bank-account
#      failure in @l(#Figure 3.29). (See @l(#Exercise 3.46).)
     Sin embargo, esta implementación de @c(test-and-set!) no es suficiente como
     está. Aquí hay una sutileza crucial, que es el lugar esencial donde el
     control de concurrencia entra en el sistema: La @c(test-and-set!) operación
     debe realizarse @e(atómicamente). Es decir, debemos garantizar que, una vez
     que un proceso ha probado la celda y la ha encontrado falsa, el contenido
     de la celda se pondrá realmente en true antes de que cualquier otro proceso
     pueda probar la celda. Si no hacemos esta garantía, el mutex puede fallar
     de manera similar a la cuenta bancaria de la @l(#Figura
     3.29). (Véase el @l(#Ejercicio 3.46) .)

#      The actual implementation of @c(test-and-set!) depends on the details of how
#      our system runs concurrent processes. For example, we might be executing
#      concurrent processes on a sequential processor using a time-slicing mechanism
#      that cycles through the processes, permitting each process to run for a short
#      time before interrupting it and moving on to the next process. In that case,
#      @c(test-and-set!)  can work by disabling time slicing during the testing and
#      setting.@n(174) Alternatively, multiprocessing computers provide instructions
#      that support atomic operations directly in hardware.@n(175)
     La implementación real de @c(test-and-set!) depende de los detalles de cómo
     nuestro sistema ejecuta procesos simultáneos. Por ejemplo, podríamos estar
     ejecutando procesos concurrentes en un procesador secuencial usando un
     mecanismo de corte de tiempo que cicla a través de los procesos,
     permitiendo que cada proceso se ejecute por un corto tiempo antes de
     interrumpirlo y pasar al siguiente proceso. En ese caso, @c(test-and-set!)
     puede funcionar desactivando el corte de tiempo durante la prueba y la
     configuración.@n(174) Como alternativa, los equipos de
     multiprocesamiento proporcionan instrucciones que admiten operaciones
     atómicas directamente en hardware.@n(175)

#      :: @t(Exercise 3.46) :: Suppose that we implement @c(test-and-set!)  using an
#         ordinary procedure as shown in the text, without attempting to make the
#         operation atomic. Draw a timing diagram like the one in @l(#Figure 3.29) to
#         demonstrate how the mutex implementation can fail by allowing two processes
#         to acquire the mutex at the same time.
     :: @t(Ejercicio 3.46) :: Supongamos que implementamos @c(test-and-set!)
        usando un procedimiento ordinario como se muestra en el texto, sin
        intentar hacer la operación atómica. Dibuje un diagrama de tiempo como
        el de la @l(#Figura 3.29) para demostrar cómo puede fallar
        la implementación de mutex permitiendo que dos procesos adquieran el
        mutex al mismo tiempo.

#      :: @t(Exercise 3.47) :: A semaphore (of size @m(n)) is a generalization of a
#         mutex. Like a mutex, a semaphore supports acquire and release operations,
#         but it is more general in that up to @m(n) processes can acquire it
#         concurrently. Additional processes that attempt to acquire the semaphore
#         must wait for release operations. Give implementations of semaphores
     :: @t(Ejercicio 3.47) :: Un semáforo (de tamaño @m(n) ) es una
        generalización de un mutex. Como un mutex, un semáforo soporta
        operaciones de adquisición y liberación, pero es más general en que
        hasta @m(n) procesos pueden adquirirlo simultáneamente. Procesos
        adicionales que intentan adquirir el semáforo deben esperar para las
        operaciones de liberación. Dar implementaciones de semáforos

#         1. in terms of mutexes
     1. En términos de mutexes

#         2. in terms of atomic @c(test-and-set!) operations.
     2. En términos de @c(test-and-set!) operaciones atómicas.

# **** Deadlock
**** Punto muerto

#      Now that we have seen how to implement serializers, we can see that account
#      exchanging still has a problem, even with the @c(serialized-exchange)
#      procedure above. Imagine that Peter attempts to exchange @m(a1) with @m(a2)
#      while Paul concurrently attempts to exchange @m(a2) with @m(a1). Suppose that
#      Peter's process reaches the point where it has entered a serialized procedure
#      protecting @m(a1) and, just after that, Paul's process enters a serialized
#      procedure protecting @m(a2). Now Peter cannot proceed (to enter a serialized
#      procedure protecting @m(a2)) until Paul exits the serialized procedure
#      protecting @m(a2). Similarly, Paul cannot proceed until Peter exits the
#      serialized procedure protecting @m(a1). Each process is stalled forever,
#      waiting for the other. This situation is called a @e(deadlock).  Deadlock is
#      always a danger in systems that provide concurrent access to multiple shared
#      resources.
     Ahora que hemos visto cómo implementar serializadores, podemos ver que el
     intercambio de cuentas todavía tiene un problema, incluso con el
     procedimiento @c(serialized-exchange) anterior. Imagínese que Peter intenta
     intercambiar @m(a1) con @m(a2) mientras que Paul simultáneamente intenta
     intercambiar @m(a2) con @m(a1). Supongamos que el proceso de Peter llega al
     punto en que ha entrado en un procedimiento serializado que protege @m(a1)
     y, justo después de eso, el proceso de Paul entra en un procedimiento
     serializado que protege @m(a2). Ahora Peter no puede proceder (para entrar
     en un procedimiento serializado que protege @m(a2) ) hasta que Paul salga
     del procedimiento serializado que protege @m(a2). Similar, @m(Paul no puede
     continuar hasta que Peter salga del procedimiento serializado que protege
     a1). Cada proceso está estancado para siempre, esperando al otro. Esta
     situación se llama un @e(punto muerto). El bloqueo es siempre un peligro en
     sistemas que proporcionan acceso concurrente a múltiples recursos
     compartidos.

#      One way to avoid the deadlock in this situation is to give each account a
#      unique identification number and rewrite @c(serialized-exchange) so that a
#      process will always attempt to enter a procedure protecting the
#      lowest-numbered account first. Although this method works well for the
#      exchange problem, there are other situations that require more sophisticated
#      deadlock-avoidance techniques, or where deadlock cannot be avoided at
#      all. (See @l(#Exercise 3.48) and @l(#Exercise 3.49).)@n(176)
     Una forma de evitar el estancamiento en esta situación es dar a cada cuenta
     un número de identificación único y reescribir @c(serialized-exchange) para
     que un proceso siempre intente entrar en un procedimiento que proteja la
     cuenta de número más bajo primero. Aunque este método funciona bien para el
     problema de intercambio, hay otras situaciones que requieren técnicas de
     evasión de bloqueo más sofisticadas, o en las que no se puede evitar el
     bloqueo absoluto. (Véase el @l(#Ejercicio 3.48) y el
     @l(#Ejercicio 3.49) .)@n(176)

#      :: @t(Exercise 3.48) :: Explain in detail why the deadlock-avoidance method
#         described above, (i.e., the accounts are numbered, and each process
#         attempts to acquire the smaller-numbered account first) avoids deadlock in
#         the exchange problem. Rewrite @c(serialized-exchange) to incorporate this
#         idea. (You will also need to modify @c(make-account) so that each account
#         is created with a number, which can be accessed by sending an appropriate
#         message.)
     :: @t(Ejercicio 3.48) :: Explicar en detalle por qué el método de evitación
        de bloqueo descrito anteriormente (es decir, las cuentas están numeradas
        y cada proceso intenta adquirir la cuenta de menor número primero) evita
        el bloqueo en el problema de intercambio. Reescribir
        @c(serialized-exchange) para incorporar esta idea. (También tendrá que
        modificar @c(make-account) para que cada cuenta se cree con un número,
        al que se puede acceder enviando un mensaje apropiado.)

#      :: @t(Exercise 3.49) :: Give a scenario where the deadlock-avoidance mechanism
#         described above does not work. (Hint: In the exchange problem, each process
#         knows in advance which accounts it will need to get access to. Consider a
#         situation where a process must get access to some shared resources before
#         it can know which additional shared resources it will require.)
     :: @t(Ejercicio 3.49) :: Proporcione un escenario en el que el mecanismo de
        prevención de bloqueo descrito anteriormente no funciona. (Sugerencia:
        En el problema de intercambio, cada proceso sabe de antemano qué cuentas
        tendrá que tener acceso.) Considere una situación en la que un proceso
        debe tener acceso a algunos recursos compartidos antes de que pueda
        saber qué recursos compartidos adicionales requerirá.

# **** Concurrency, time, and communication
**** Concurrencia, tiempo y comunicación

#      We've seen how programming concurrent systems requires controlling the
#      ordering of events when different processes access shared state, and we've
#      seen how to achieve this control through judicious use of serializers. But the
#      problems of concurrency lie deeper than this, because, from a fundamental
#      point of view, it's not always clear what is meant by @"(shared state.)
     Hemos visto cómo la programación de sistemas concurrentes requiere
     controlar el orden de los eventos cuando diferentes procesos acceden al
     estado compartido, y hemos visto cómo lograr este control mediante el uso
     juicioso de los serializadores. Pero los problemas de la concurrencia son
     más profundos que esto, porque, desde un punto de vista fundamental, no
     siempre está claro qué se entiende por @"(estado compartido.)

#      Mechanisms such as @c(test-and-set!) require processes to examine a global
#      shared flag at arbitrary times. This is problematic and inefficient to
#      implement in modern high-speed processors, where due to optimization
#      techniques such as pipelining and cached memory, the contents of memory may
#      not be in a consistent state at every instant. In contemporary multiprocessing
#      systems, therefore, the serializer paradigm is being supplanted by new
#      approaches to concurrency control.@n(177)
     Mecanismos tales como @c(test-and-set!) requerir procesos para examinar un
     indicador global compartido en tiempos arbitrarios. Esto es problemático e
     ineficiente para implementar en los procesadores de alta velocidad
     modernos, donde debido a técnicas de optimización tales como pipelining y
     memoria en caché, el contenido de memoria puede no estar en un estado
     consistente en cada instante. En los sistemas contemporáneos de
     multiprocesamiento, por lo tanto, el paradigma del serializador está siendo
     suplantado por nuevos enfoques para el control de la
     concurrencia.@n(177)

#      The problematic aspects of shared state also arise in large, distributed
#      systems. For instance, imagine a distributed banking system where individual
#      branch banks maintain local values for bank balances and periodically compare
#      these with values maintained by other branches. In such a system the value of
#      @"(the account balance) would be undetermined, except right after
#      synchronization. If Peter deposits money in an account he holds jointly with
#      Paul, when should we say that the account balance has changed––when the
#      balance in the local branch changes, or not until after the synchronization?
#      And if Paul accesses the account from a different branch, what are the
#      reasonable constraints to place on the banking system such that the behavior
#      is @"(correct)?  The only thing that might matter for correctness is the
#      behavior observed by Peter and Paul individually and the @"(state) of the
#      account immediately after synchronization. Questions about the @"(real)
#      account balance or the order of events between synchronizations may be
#      irrelevant or meaningless.@n(178)
     Los aspectos problemáticos del estado compartido también surgen en grandes
     sistemas distribuidos. Por ejemplo, imagine un sistema bancario distribuido
     en el que los bancos de sucursales individuales mantengan los valores
     locales de los saldos bancarios y los comparen periódicamente con los
     valores mantenidos por otras ramas. En tal sistema el valor del @"(balance)
     de @"(la cuenta) sería indeterminado, excepto después de la
     sincronización. Si Peter deposita dinero en una cuenta que mantiene
     conjuntamente con Paul, ¿cuándo debemos decir que el saldo de la cuenta ha
     cambiado - cuando el saldo en la rama local cambia, o no hasta después de
     la sincronización? Y si Pablo accede a la cuenta de una rama diferente,
     @"(¿Cuáles son las restricciones razonables para colocar en el sistema
     bancario de tal manera que el comportamiento es correcto) ? Lo único que
     podría importar para la corrección es el comportamiento observado por Pedro
     y Pablo individualmente y el @"(estado) de la cuenta inmediatamente después
     de la sincronización. Las preguntas sobre el saldo @"(real de la) cuenta o
     el orden de sucesos entre las sincronizaciones pueden ser irrelevantes o
     carentes de significado.@n(178)

#      The basic phenomenon here is that synchronizing different processes,
#      establishing shared state, or imposing an order on events requires
#      communication among the processes. In essence, any notion of time in
#      concurrency control must be intimately tied to communication.@n(179) It is
#      intriguing that a similar connection between time and communication also
#      arises in the Theory of Relativity, where the speed of light (the fastest
#      signal that can be used to synchronize events) is a fundamental constant
#      relating time and space. The complexities we encounter in dealing with time
#      and state in our computational models may in fact mirror a fundamental
#      complexity of the physical universe.
     El fenómeno básico aquí es que sincronizar diferentes procesos, establecer
     un estado compartido o imponer un orden sobre los eventos requiere
     comunicación entre los procesos. En esencia, cualquier noción de tiempo en
     el control de la concurrencia debe estar íntimamente ligada a la
     comunicación.@n(179) Es intrigante que una conexión similar entre el
     tiempo y la comunicación también se plantea en la teoría de la relatividad,
     donde la velocidad de la luz (la señal más rápida que se puede utilizar
     para sincronizar eventos) es una constante fundamental tiempo y el espacio
     relativo. Las complejidades que encontramos al tratar con el tiempo y el
     estado en nuestros modelos computacionales pueden de hecho reflejar una
     complejidad fundamental del universo físico.

# ** 3.5 <> Streams
** 3.5 <> Arroyos

#    We've gained a good understanding of assignment as a tool in modeling, as well
#    as an appreciation of the complex problems that assignment raises. It is time
#    to ask whether we could have gone about things in a different way, so as to
#    avoid some of these problems. In this section, we explore an alternative
#    approach to modeling state, based on data structures called @e(streams).  As
#    we shall see, streams can mitigate some of the complexity of modeling state.
   Hemos adquirido una buena comprensión de la asignación como una herramienta
   en el modelado, así como una apreciación de los complejos problemas que la
   asignación plantea. Es hora de preguntarnos si podríamos haber hecho las
   cosas de una manera diferente, para evitar algunos de estos problemas. En
   esta sección, exploramos un enfoque alternativo para modelar el estado,
   basado en estructuras de datos llamadas @e(flujos). Como veremos, los flujos
   pueden mitigar parte de la complejidad del estado de modelado.

#    Let's step back and review where this complexity comes from. In an attempt to
#    model real-world phenomena, we made some apparently reasonable decisions: We
#    modeled real-world objects with local state by computational objects with
#    local variables. We identified time variation in the real world with time
#    variation in the computer. We implemented the time variation of the states of
#    the model objects in the computer with assignments to the local variables of
#    the model objects.
   Vamos a dar un paso atrás y revisar de dónde viene esta complejidad. En un
   intento de modelar los fenómenos del mundo real, tomamos algunas decisiones
   aparentemente razonables: modelamos los objetos del mundo real con el estado
   local mediante objetos computacionales con variables locales. Hemos
   identificado la variación del tiempo en el mundo real con la variación de
   tiempo en el ordenador. Implementamos la variación de tiempo de los estados
   de los objetos del modelo en el ordenador con asignaciones a las variables
   locales de los objetos del modelo.

#    Is there another approach?  Can we avoid identifying time in the computer with
#    time in the modeled world?  Must we make the model change with time in order
#    to model phenomena in a changing world?  Think about the issue in terms of
#    mathematical functions. We can describe the time-varying behavior of a
#    quantity @m(x) as a function of time @m[x(t)]. If we concentrate on @m(x)
#    instant by instant, we think of it as a changing quantity. Yet if we
#    concentrate on the entire time history of values, we do not emphasize
#    change––the function itself does not change.@n(180)
   ¿Hay otro enfoque? ¿Podemos evitar identificar el tiempo en la computadora
   con el tiempo en el mundo modelado? ¿Debemos hacer que el modelo cambie con
   el tiempo para modelar fenómenos en un mundo cambiante? Piense en el tema en
   términos de funciones matemáticas. Podemos describir el comportamiento
   variable en el tiempo de una cantidad @m(x) en función del tiempo @m(x
   (t)). Si nos concentramos en @m(x) instante a instante, pensamos en ella como
   una cantidad variable. Sin embargo, si nos concentramos en toda la historia
   de los valores, no hacemos hincapié en el cambio, la función en sí no
   cambia.@n(180)

#    If time is measured in discrete steps, then we can model a time function as a
#    (possibly infinite) sequence. In this section, we will see how to model change
#    in terms of sequences that represent the time histories of the systems being
#    modeled. To accomplish this, we introduce new data structures called
#    @e(streams). From an abstract point of view, a stream is simply a
#    sequence. However, we will find that the straightforward implementation of
#    streams as lists (as in section @l(#2.2.1)) doesn't fully reveal the power of stream
#    processing. As an alternative, we introduce the technique of @e(delayed
#    evaluation), which enables us to represent very large (even infinite)
#    sequences as streams.
   Si el tiempo se mide en pasos discretos, entonces podemos modelar una función
   de tiempo como una secuencia (posiblemente infinita). En esta sección,
   veremos cómo modelar el cambio en términos de secuencias que representan las
   historias de tiempo de los sistemas que están siendo modelados. Para lograr
   esto, introducimos nuevas estructuras de datos llamadas @e(flujos). Desde un
   punto de vista abstracto, un flujo es simplemente una secuencia. Sin embargo,
   veremos que la implementación sencilla de flujos como listas (como en
   @l(#2.2.1)) no revela completamente la potencia del procesamiento de
   flujo. Como alternativa, se introduce la técnica de @e(evaluación retardada),
   que nos permite representar secuencias muy grandes (incluso infinitas) como
   corrientes.

#    Stream processing lets us model systems that have state without ever using
#    assignment or mutable data. This has important implications, both theoretical
#    and practical, because we can build models that avoid the drawbacks inherent
#    in introducing assignment. On the other hand, the stream framework raises
#    difficulties of its own, and the question of which modeling technique leads to
#    more modular and more easily maintained systems remains open.
   El procesamiento de secuencias nos permite modelar sistemas que tienen estado
   sin usar nunca asignación o datos mutables. Esto tiene implicaciones
   importantes, tanto teóricas como prácticas, porque podemos construir modelos
   que eviten los inconvenientes inherentes a la introducción de la
   asignación. Por otra parte, el marco de la corriente plantea dificultades
   propias y la cuestión de qué técnica de modelado conduce a sistemas más
   modulares y más fácilmente mantenidos permanece abierta.

# *** 3.5.1 <> Streams Are Delayed Lists
*** 3.5.1 <> Las corrientes son listas retrasadas

#     As we saw in section @l(#2.2.3), sequences can serve as standard interfaces for
#     combining program modules. We formulated powerful abstractions for
#     manipulating sequences, such as @c(map), @c(filter), and @c(accumulate), that
#     capture a wide variety of operations in a manner that is both succinct and
#     elegant.
    Como vimos en la seccion @l(#2.2.3), las secuencias pueden servir como
    interfaces estándar para combinar módulos de programa. Formulamos
    abstracciones de gran alcance para las secuencias de manipulación, tales
    como @c(map), @c(filter) y @c(accumulate), que la captura de una amplia
    variedad de operaciones de una manera que es a la vez sucinta y elegante.

#     Unfortunately, if we represent sequences as lists, this elegance is bought at
#     the price of severe inefficiency with respect to both the time and space
#     required by our computations. When we represent manipulations on sequences as
#     transformations of lists, our programs must construct and copy data structures
#     (which may be huge) at every step of a process.
    Desafortunadamente, si representamos secuencias como listas, esta elegancia
    se compra al precio de una ineficiencia severa con respecto al tiempo y el
    espacio requeridos por nuestros cálculos. Cuando representamos
    manipulaciones sobre secuencias como transformaciones de listas, nuestros
    programas deben construir y copiar estructuras de datos (que pueden ser
    enormes) en cada paso de un proceso.

#     To see why this is true, let us compare two programs for computing the sum of
#     all the prime numbers in an interval. The first program is written in standard
#     iterative style:@n(181)
    Para ver por qué esto es cierto, vamos a comparar dos programas para
    calcular la suma de todos los números primos en un intervalo. El primer
    programa está escrito en un estilo iterativo estándar:@n(181)

#     ..src > scheme
#       (define (sum-primes a b)
#         (define (iter count accum)
#           (cond ((> count b) accum)
#                 ((prime? count)
#                  (iter (+ count 1)
#                        (+ count accum)))
#                 (else (iter (+ count 1) accum))))
#         (iter a 0))
#     < src..
    ..src > scheme
      (define (sum-primes a b)
        (define (iter count accum)
          (cond ((> count b) accum)
                ((prime? count)
                 (iter (+ count 1)
                       (+ count accum)))
                (else (iter (+ count 1) accum))))
        (iter a 0))
    < src..

#     The second program performs the same computation using the sequence operations
#     of section @l(#2.2.3):
    El segundo programa realiza el mismo cálculo utilizando las operaciones de
    secuencia de la seccion @l(#2.2.3) :

#     ..src > scheme
#       (define (sum-primes a b)
#         (accumulate
#          +
#          0
#          (filter prime? (enumerate-interval a b))))
#     < src..
    ..src > scheme
      (define (sum-primes a b)
        (accumulate
         +
         0
         (filter prime? (enumerate-interval a b))))
    < src..

#     In carrying out the computation, the first program needs to store only the sum
#     being accumulated. In contrast, the filter in the second program cannot do any
#     testing until @c(enumerate-interval) has constructed a complete list of the
#     numbers in the interval. The filter generates another list, which in turn is
#     passed to @c(accumulate) before being collapsed to form a sum. Such large
#     intermediate storage is not needed by the first program, which we can think of
#     as enumerating the interval incrementally, adding each prime to the sum as it
#     is generated.
    Al llevar a cabo el cálculo, el primer programa necesita almacenar sólo la
    suma acumulada. En contraste, el filtro en el segundo programa no puede
    hacer ninguna prueba hasta que @c(enumerate-interval) haya construido una
    lista completa de los números en el intervalo. El filtro genera otra lista,
    que a su vez se pasa a @c(accumulate) antes de ser colapsada para formar una
    suma. Este gran almacenamiento intermedio no es necesario por el primer
    programa, que podemos pensar en enumerar el intervalo de forma incremental,
    agregando cada primo a la suma a medida que se genera.

#     The inefficiency in using lists becomes painfully apparent if we use the
#     sequence paradigm to compute the second prime in the interval from 10,000 to
#     1,000,000 by evaluating the expression
    La ineficiencia en el uso de listas se vuelve dolorosamente aparente si
    usamos el paradigma de secuencia para calcular el segundo primo en el
    intervalo de 10.000 a 1.000.000 evaluando la expresión

#     ..src > scheme
#       (car (cdr
#             (filter
#              prime?
#              (enumerate-interval 10000 1000000))))
#     < src..
    ..src > scheme
      (car (cdr
            (filter
             prime?
             (enumerate-interval 10000 1000000))))
    < src..

#     This expression does find the second prime, but the computational overhead is
#     outrageous. We construct a list of almost a million integers, filter this list
#     by testing each element for primality, and then ignore almost all of the
#     result. In a more traditional programming style, we would interleave the
#     enumeration and the filtering, and stop when we reached the second prime.
    Esta expresión encuentra el segundo primo, pero la sobrecarga computacional
    es escandalosa. Construimos una lista de casi un millón de enteros,
    filtramos esta lista probando cada elemento para primality, y luego
    ignoramos casi todo el resultado. En un estilo de programación más
    tradicional, intercalaríamos la enumeración y el filtrado, y pararíamos
    cuando alcanzáramos el segundo primo.

#     Streams are a clever idea that allows one to use sequence manipulations
#     without incurring the costs of manipulating sequences as lists. With streams
#     we can achieve the best of both worlds: We can formulate programs elegantly as
#     sequence manipulations, while attaining the efficiency of incremental
#     computation. The basic idea is to arrange to construct a stream only
#     partially, and to pass the partial construction to the program that consumes
#     the stream. If the consumer attempts to access a part of the stream that has
#     not yet been constructed, the stream will automatically construct just enough
#     more of itself to produce the required part, thus preserving the illusion that
#     the entire stream exists. In other words, although we will write programs as
#     if we were processing complete sequences, we design our stream implementation
#     to automatically and transparently interleave the construction of the stream
#     with its use.
    Las corrientes son una idea inteligente que permite utilizar manipulaciones
    de secuencia sin incurrir en los costos de manipular secuencias como
    listas. Con los flujos podemos lograr lo mejor de ambos mundos: Podemos
    formular programas elegantemente como manipulaciones de secuencias, al
    tiempo que obtenemos la eficiencia de la computación incremental. La idea
    básica es arreglar para construir un flujo sólo parcialmente, y pasar la
    construcción parcial al programa que consume el flujo. Si el consumidor
    intenta acceder a una parte del flujo que todavía no se ha construido, el
    flujo construirá automáticamente lo suficiente más de sí mismo para producir
    la parte requerida, preservando así la ilusión de que todo el flujo
    existe. En otras palabras, aunque vamos a escribir programas como si
    estuviéramos procesando secuencias completas,

#     On the surface, streams are just lists with different names for the procedures
#     that manipulate them. There is a constructor, @c(cons-stream), and two
#     selectors, @c(stream-car) and @c(stream-cdr), which satisfy the constraints
    En la superficie, los arroyos son sólo listas con nombres diferentes para
    los procedimientos que los manipulan. Hay un constructor @c(cons-stream),, y
    dos selectores, @c(stream-car) y @c(stream-cdr), que satisfacen las
    restricciones

#     ..example >
#       (stream-car (cons-stream x y)) = x
#       (stream-cdr (cons-stream x y)) = y
#     < example..
    ..example >
      (stream-car (cons-stream x y)) = x
      (stream-cdr (cons-stream x y)) = y
    < example..

#     There is a distinguishable object, @c(the-empty-stream), which cannot be the
#     result of any @c(cons-stream) operation, and which can be identified with the
#     predicate @c(stream-null?).@n(182) Thus we can make and use streams, in just
#     the same way as we can make and use lists, to represent aggregate data
#     arranged in a sequence. In particular, we can build stream analogs of the list
#     operations from @l(#Chapter 2), such as @c(list-ref), @c(map), and
#     @c(for-each):@n(183)
    Hay un objeto distinguible,, @c(the-empty-stream) que no puede ser el
    resultado de ninguna @c(cons-stream) operación, y que se puede identificar
    con el predicado @c(stream-null?).@n(182) De este modo podemos hacer
    y usar corrientes, exactamente de la misma manera que podemos hacer y usar
    listas, para representar los datos agregados dispuestos en una secuencia. En
    particular, podemos construir análogos corriente de las operaciones de lista
    de @l(#Capitulo 2), como @c(list-ref), @c(map) y @c(for-each):
   @n(183)

#     ..src > scheme
#       (define (stream-ref s n)
#         (if (= n 0)
#             (stream-car s)
#             (stream-ref (stream-cdr s) (- n 1))))
#
#       (define (stream-map proc s)
#         (if (stream-null? s)
#             the-empty-stream
#             (cons-stream
#              (proc (stream-car s))
#              (stream-map proc (stream-cdr s)))))
#
#       (define (stream-for-each proc s)
#         (if (stream-null? s)
#             'done
#             (begin
#               (proc (stream-car s))
#               (stream-for-each proc
#                                (stream-cdr s)))))
#     < src..
    ..src > scheme
      (define (stream-ref s n)
        (if (= n 0)
            (stream-car s)
            (stream-ref (stream-cdr s) (- n 1))))

      (define (stream-map proc s)
        (if (stream-null? s)
            the-empty-stream
            (cons-stream
             (proc (stream-car s))
             (stream-map proc (stream-cdr s)))))

      (define (stream-for-each proc s)
        (if (stream-null? s)
            'done
            (begin
              (proc (stream-car s))
              (stream-for-each proc
                               (stream-cdr s)))))
    < src..

#     @c(Stream-for-each) is useful for viewing streams:
    @c(Stream-for-each) Es útil para ver secuencias:

#     ..src > scheme
#       (define (display-stream s)
#         (stream-for-each display-line s))
#
#       (define (display-line x)
#         (newline)
#         (display x))
#     < src..
    ..src > scheme
      (define (display-stream s)
        (stream-for-each display-line s))

      (define (display-line x)
        (newline)
        (display x))
    < src..

#     To make the stream implementation automatically and transparently interleave
#     the construction of a stream with its use, we will arrange for the @c(cdr) of
#     a stream to be evaluated when it is accessed by the @c(stream-cdr) procedure
#     rather than when the stream is constructed by @c(cons-stream).  This
#     implementation choice is reminiscent of our discussion of rational numbers in
#     @l(#2.1.2), where we saw that we can choose to implement rational numbers so
#     that the reduction of numerator and denominator to lowest terms is performed
#     either at construction time or at selection time. The two rational-number
#     implementations produce the same data abstraction, but the choice has an
#     effect on efficiency. There is a similar relationship between streams and
#     ordinary lists. As a data abstraction, streams are the same as lists. The
#     difference is the time at which the elements are evaluated. With ordinary
#     lists, both the @c(car) and the @c(cdr) are evaluated at construction
#     time. With streams, the @c(cdr) is evaluated at selection time.
    Para hacer que la implementación de flujo implemente de manera automática y
    transparente la construcción de un flujo con su uso, organizaremos el
    @c(cdr) flujo de un flujo para ser evaluado cuando se accede por el
    procedimiento @c(stream-cdr) en lugar de cuando se construye el flujo
    @c(cons-stream). Esta opción de implementación es una reminiscencia de
    nuestra discusión de los números racionales en la seccion @l(#2.1.2), donde
    vimos que podemos optar por implementar números racionales para que la
    reducción del numerador y el denominador a los términos más bajos se realice
    en el tiempo de construcción o en el tiempo de selección. Las dos
    implementaciones de números racionales producen la misma abstracción de
    datos, pero la elección tiene un efecto sobre la eficiencia. Hay una
    relación similar entre las corrientes y las listas ordinarias. Como
    abstracción de datos, los flujos son los mismos que las listas. La
    diferencia es el momento en que se evalúan los elementos. @c(car) Con las
    listas ordinarias, tanto el y el @c(cdr) se evalúan en el tiempo de
    construcción. Con los arroyos, @c(cdr) se evalúa en el momento de la
    selección.

#     Our implementation of streams will be based on a special form called
#     @c(delay). Evaluating @c[(delay ⟨exp⟩)] does not evaluate the expression
#     @c[(exp)], but rather returns a so-called @e(delayed object), which we can
#     think of as a @"(promise) to evaluate @c[(exp)] at some future time. As a
#     companion to @c(delay), there is a procedure called @c(force) that takes a
#     delayed object as argument and performs the evaluation––in effect, forcing the
#     @c(delay) to fulfill its promise. We will see below how @c(delay) and
#     @c(force) can be implemented, but first let us use these to construct streams.
    Nuestra implementación de los arroyos se basará en un formulario especial
    llamado @c(delay). La evaluación @c[(delay ⟨exp⟩)] no evalúa la expresión
    @c[(exp)], sino que devuelve un llamado @e(objeto retrasado), que podemos
    considerar como una @"(promesa) para evaluar @c[(exp)] en algún momento
    futuro. Como compañero de @c(delay), hay un procedimiento llamado @c(force)
    que toma un objeto retrasado como argumento y realiza la evaluación - en
    efecto, obligando @c(delay) a cumplir su promesa. Veremos a continuación
    cómo @c(delay) y @c(force) puede implementarse, pero primero vamos a usarlos
    para construir corrientes.

#     @c(Cons-stream) is a special form defined so that
    @c(Cons-stream) Es una forma especial definida para que

#     ..src > scheme
#       (cons-stream ⟨a⟩ ⟨b⟩)
#     < src..
    ..src > scheme
      (cons-stream ⟨a⟩ ⟨b⟩)
    < src..

#     is equivalent to
    es equivalente a

#     ..src > scheme
#       (cons ⟨a⟩ (delay ⟨b⟩))
#     < src..
    ..src > scheme
      (cons ⟨a⟩ (delay ⟨b⟩))
    < src..

#     What this means is that we will construct streams using pairs. However, rather
#     than placing the value of the rest of the stream into the @c(cdr) of the pair
#     we will put there a promise to compute the rest if it is ever requested.
#     @c(Stream-car) and @c(stream-cdr) can now be defined as procedures:
    Lo que esto significa es que vamos a construir corrientes utilizando
    pares. Sin embargo, en lugar de colocar el valor del resto del flujo en el
    @c(cdr) del par, pondremos allí una promesa de calcular el resto si se
    solicita alguna vez. @c(Stream-car) Y @c(stream-cdr) ahora se pueden definir
    como procedimientos:

#     ..src > scheme
#       (define (stream-car stream)
#         (car stream))
#
#       (define (stream-cdr stream)
#         (force (cdr stream)))
#     < src..
    ..src > scheme
      (define (stream-car stream)
        (car stream))

      (define (stream-cdr stream)
        (force (cdr stream)))
    < src..

#     @c(Stream-car) selects the @c(car) of the pair; @c(stream-cdr) selects the
#     @c(cdr) of the pair and evaluates the delayed expression found there to obtain
#     the rest of the stream.@n(184)
    @c(Stream-car) Selecciona el @c(car) del par; @c(stream-cdr) Selecciona el
    @c(cdr) del par y evalúa la expresión retrasada encontrada allí para obtener
    el resto del flujo.@n(184)

# **** The stream implementation in action
**** La implementación del flujo en acción

#      To see how this implementation behaves, let us analyze the @"(outrageous)
#      prime computation we saw above, reformulated in terms of streams:
     Para ver cómo se comporta esta implementación, analicemos el
     @"(escandaloso) cálculo primo que vimos anteriormente, reformulado en
     términos de corrientes:

#      ..src > scheme
#        (stream-car
#         (stream-cdr
#          (stream-filter
#           prime? (stream-enumerate-interval
#                   10000 1000000))))
#      < src..
     ..src > scheme
       (stream-car
        (stream-cdr
         (stream-filter
          prime? (stream-enumerate-interval
                  10000 1000000))))
     < src..

#      We will see that it does indeed work efficiently.
     Veremos que realmente funciona de manera eficiente.

#      We begin by calling @c(stream-enumerate-interval) with the arguments 10,000
#      and 1,000,000. @c(Stream-enumerate-interval) is the stream analog of
#      @c(enumerate-interval) (section @l(#2.2.3)):
     Comenzamos llamando @c(stream-enumerate-interval) con los argumentos 10.000
     y 1.000.000. @c(Stream-enumerate-interval) Es el análogo del flujo de
     @c(enumerate-interval) (seccion @l(#2.2.3)):

#      ..src > scheme
#        (define (stream-enumerate-interval low high)
#          (if (> low high)
#              the-empty-stream
#              (cons-stream
#               low
#               (stream-enumerate-interval (+ low 1)
#                                          high))))
#      < src..
     ..src > scheme
       (define (stream-enumerate-interval low high)
         (if (> low high)
             the-empty-stream
             (cons-stream
              low
              (stream-enumerate-interval (+ low 1)
                                         high))))
     < src..

#      and thus the result returned by @c(stream-enumerate-interval), formed by the
#      @c(cons-stream), is@n(185)
     Y así el resultado devuelto por @c(stream-enumerate-interval), formado por
     el @c(cons-stream), es@n(185)

#      ..src > scheme
#        (cons 10000
#              (delay
#                (stream-enumerate-interval
#                 10001
#                 1000000)))
#      < src..
     ..src > scheme
       (cons 10000
             (delay
               (stream-enumerate-interval
                10001
                1000000)))
     < src..

#      That is, @c(stream-enumerate-interval) returns a stream represented as a pair
#      whose @c(car) is 10,000 and whose @c(cdr) is a promise to enumerate more of
#      the interval if so requested. This stream is now filtered for primes, using
#      the stream analog of the @c(filter) procedure (section @l(#2.2.3)):
     Es decir, @c(stream-enumerate-interval) devuelve un flujo representado como
     un par cuyo @c(car)10.000 y cuya @c(cdr) es una promesa de enumerar más del
     intervalo si así se solicita. Esta corriente se filtra ahora para primos,
     utilizando el análogo de flujo del procedimiento @c(filter) (
     @l(#2.2.3)):

#      ..src > scheme
#        (define (stream-filter pred stream)
#          (cond ((stream-null? stream)
#                 the-empty-stream)
#                ((pred (stream-car stream))
#                 (cons-stream
#                  (stream-car stream)
#                  (stream-filter
#                   pred
#                   (stream-cdr stream))))
#                (else (stream-filter
#                       pred
#                       (stream-cdr stream)))))
#      < src..
     ..src > scheme
       (define (stream-filter pred stream)
         (cond ((stream-null? stream)
                the-empty-stream)
               ((pred (stream-car stream))
                (cons-stream
                 (stream-car stream)
                 (stream-filter
                  pred
                  (stream-cdr stream))))
               (else (stream-filter
                      pred
                      (stream-cdr stream)))))
     < src..

#      @c(Stream-filter) tests the @c(stream-car) of the stream (the @c(car) of the
#      pair, which is 10,000). Since this is not prime, @c(stream-filter) examines
#      the @c(stream-cdr) of its input stream. The call to @c(stream-cdr) forces
#      evaluation of the delayed @c(stream-enumerate-interval), which now returns
     @c(Stream-filter) Prueba el @c(stream-car) de la corriente (el @c(car) del
     par, que es 10.000). Puesto que esto no es primo, @c(stream-filter) examina
     el @c(stream-cdr) de su flujo de entrada. La llamada a la @c(stream-cdr)
     evaluación de las fuerzas del retraso @c(stream-enumerate-interval), que
     ahora devuelve

#      ..src > scheme
#        (cons 10001
#              (delay
#                (stream-enumerate-interval
#                 10002
#                 1000000)))
#      < src..
     ..src > scheme
       (cons 10001
             (delay
               (stream-enumerate-interval
                10002
                1000000)))
     < src..

#      @c(Stream-filter) now looks at the @c(stream-car) of this stream, 10,001, sees
#      that this is not prime either, forces another @c(stream-cdr), and so on, until
#      @c(stream-enumerate-interval) yields the prime 10,007, whereupon
#      @c(stream-filter), according to its definition, returns
     @c(Stream-filter) Mira ahora a la @c(stream-car) de esta corriente, 10.001,
     ve que esto no es primo tampoco, fuerza a otro @c(stream-cdr), y así
     sucesivamente, hasta que @c(stream-enumerate-interval) rinde el primo
     10.007, con lo cual @c(stream-filter), según su definición, devuelve

#      ..src > scheme
#        (cons-stream
#         (stream-car stream)
#         (stream-filter pred (stream-cdr stream)))
#      < src..
     ..src > scheme
       (cons-stream
        (stream-car stream)
        (stream-filter pred (stream-cdr stream)))
     < src..

#      which in this case is
     Que en este caso es

#      ..src > scheme
#        (cons 10007
#              (delay
#                (stream-filter
#                 prime?
#                 (cons 10008
#                       (delay
#                         (stream-enumerate-interval
#                          10009 1000000))))))
#      < src..
     ..src > scheme
       (cons 10007
             (delay
               (stream-filter
                prime?
                (cons 10008
                      (delay
                        (stream-enumerate-interval
                         10009 1000000))))))
     < src..

#      This result is now passed to @c(stream-cdr) in our original expression.  This
#      forces the delayed @c(stream-filter), which in turn keeps forcing the delayed
#      @c(stream-enumerate-interval) until it finds the next prime, which is
#      10,009. Finally, the result passed to @c(stream-car) in our original
#      expression is
     Este resultado se pasa ahora a @c(stream-cdr) nuestra expresión
     original. Esto fuerza al retraso @c(stream-filter), que a su vez mantiene
     forzando el retraso @c(stream-enumerate-interval) hasta que encuentre la
     siguiente prima, que es 10.009. Finalmente, el resultado pasado a
     @c(stream-car) en nuestra expresión original es

#      ..src > scheme
#        (cons 10009
#              (delay
#                (stream-filter
#                 prime?
#                 (cons 10010
#                       (delay
#                         (stream-enumerate-interval
#                          10011 1000000))))))
#      < src..
     ..src > scheme
       (cons 10009
             (delay
               (stream-filter
                prime?
                (cons 10010
                      (delay
                        (stream-enumerate-interval
                         10011 1000000))))))
     < src..

#      @c(Stream-car) returns 10,009, and the computation is complete. Only as many
#      integers were tested for primality as were necessary to find the second prime,
#      and the interval was enumerated only as far as was necessary to feed the prime
#      filter.
     @c(Stream-car) Devuelve 10.009, y el cálculo es completo. Sólo se probaron
     tantos enteros como primalidad como fueron necesarios para encontrar el
     segundo primo, y el intervalo se enumeró sólo en la medida en que era
     necesario para alimentar el filtro primo.

#      In general, we can think of delayed evaluation as @"(demand-driven)
#      programming, whereby each stage in the stream process is activated only enough
#      to satisfy the next stage. What we have done is to decouple the actual order
#      of events in the computation from the apparent structure of our procedures. We
#      write procedures as if the streams existed @"(all at once) when, in reality,
#      the computation is performed incrementally, as in traditional programming
#      styles.
     En general, podemos pensar en una evaluación retardada como programación
     @"(basada en la demanda), en la que cada etapa del proceso de flujo se
     activa sólo lo suficiente para satisfacer la siguiente etapa. Lo que hemos
     hecho es desacoplar el orden real de los acontecimientos en el cálculo de
     la estructura aparente de nuestros procedimientos. Escribimos los
     procedimientos como si las corrientes existieran @"(de una vez) cuando, en
     realidad, la computación se realiza de forma incremental, como en los
     estilos de programación tradicionales.

# **** Implementing @c(delay) and @c(force)
**** Implementación @c(delay) y@c(force)

#      Although @c(delay) and @c(force) may seem like mysterious operations, their
#      implementation is really quite straightforward. @c(Delay) must package an
#      expression so that it can be evaluated later on demand, and we can accomplish
#      this simply by treating the expression as the body of a procedure.  @c(Delay)
#      can be a special form such that
     Aunque @c(delay), y @c(force) puede parecer operaciones misteriosas, su
     aplicación es realmente muy sencillo. @c(Delay) Debe empaquetar una
     expresión para que pueda ser evaluada más adelante en la demanda, y podemos
     lograr esto simplemente tratando la expresión como el cuerpo de un
     procedimiento.  @c(Delay) Puede ser una forma especial tal que

#      ..src > scheme
#        (delay ⟨exp⟩)
#      < src..
     ..src > scheme
       (delay ⟨exp⟩)
     < src..

#      is syntactic sugar for
     Es azúcar sintáctico para

#      ..src > scheme
#        (lambda () ⟨exp⟩)
#      < src..
     ..src > scheme
       (lambda () ⟨exp⟩)
     < src..

#      @c(Force) simply calls the procedure (of no arguments) produced by @c(delay),
#      so we can implement @c(force) as a procedure:
     @c(Force) Simplemente llama al procedimiento (de no argumentos) producido
     por @c(delay), por lo que podemos implementar @c(force) como un
     procedimiento:

#      ..src > scheme
#        (define (force delayed-object)
#          (delayed-object))
#      < src..
     ..src > scheme
       (define (force delayed-object)
         (delayed-object))
     < src..

#      This implementation suffices for @c(delay) and @c(force) to work as
#      advertised, but there is an important optimization that we can include. In
#      many applications, we end up forcing the same delayed object many times. This
#      can lead to serious inefficiency in recursive programs involving streams. (See
#      @l(#Exercise 3.57).)  The solution is to build delayed objects so that the
#      first time they are forced, they store the value that is computed. Subsequent
#      forcings will simply return the stored value without repeating the computation.
#      In other words, we implement @c(delay) as a special-purpose memoized procedure
#      similar to the one described in @l(#Exercise 3.27). One way to accomplish this
#      is to use the following procedure, which takes as argument a procedure (of no
#      arguments) and returns a memoized version of the procedure.  The first time
#      the memoized procedure is run, it saves the computed result. On subsequent
#      evaluations, it simply returns the result.
     Esta implementación es suficiente @c(delay) y @c(force) funciona como se
     anuncia, pero hay una optimización importante que podemos incluir. En
     muchas aplicaciones, terminamos forzando el mismo objeto retrasado muchas
     veces. Esto puede conducir a una seria ineficiencia en los programas
     recursivos que involucran corrientes. (Ver el @l(#Ejercicio
     3.57) .) La solución es construir objetos retardados de manera que la
     primera vez que son forzados, almacenan el valor que se calcula. Los
     forzamientos posteriores simplemente devolverán el valor almacenado sin
     repetir el cálculo. En otras palabras, implementamos @c(delay) como un
     procedimiento memorizado de propósito especial similar al descrito en el
     @l(#Ejercicio 3.27). Una forma de lograr esto es usar el
     siguiente procedimiento, Que toma como argumento un procedimiento (sin
     argumentos) y devuelve una versión memorizada del procedimiento. La primera
     vez que se ejecuta el procedimiento memoized, guarda el resultado
     calculado. En las evaluaciones posteriores, simplemente devuelve el
     resultado.

#      ..src > scheme
#        (define (memo-proc proc)
#          (let ((already-run? false) (result false))
#            (lambda ()
#              (if (not already-run?)
#                  (begin (set! result (proc))
#                         (set! already-run? true)
#                         result)
#                  result))))
#      < src..
     ..src > scheme
       (define (memo-proc proc)
         (let ((already-run? false) (result false))
           (lambda ()
             (if (not already-run?)
                 (begin (set! result (proc))
                        (set! already-run? true)
                        result)
                 result))))
     < src..

#      @c(Delay) is then defined so that @c[(delay ⟨exp⟩)] is equivalent to
     @c(Delay) Se define entonces para que @c[(delay ⟨exp⟩)] sea equivalente a

#      ..src > scheme
#        (memo-proc (lambda () ⟨exp⟩))
#      < src..
     ..src > scheme
       (memo-proc (lambda () ⟨exp⟩))
     < src..

#      and @c(force) is as defined previously.@n(186)
     Y @c(force) es tal como se ha definido anteriormente.@n(186)

#      :: @t(Exercise 3.50) :: Complete the following definition, which generalizes
#         @c(stream-map) to allow procedures that take multiple arguments, analogous
#         to @c(map) in section @l(#2.2.1),@n(78<>Footnote 78).
     :: @t(Ejercicio 3.50) :: Complete la siguiente definición, que se
        generaliza @c(stream-map) para permitir procedimientos que toman
        múltiples argumentos, análogo a @c(map) en la seccion @l(#2.2.1),
       @n(78<>Nota 78).

#         ..src > scheme
#           (define (stream-map proc . argstreams)
#             (if (⟨??⟩ (car argstreams))
#                 the-empty-stream
#                 (⟨??⟩
#                  (apply proc (map ⟨??⟩ argstreams))
#                  (apply stream-map
#                         (cons proc
#                               (map ⟨??⟩
#                                    argstreams))))))
#         < src..
        ..src > scheme
          (define (stream-map proc . argstreams)
            (if (⟨??⟩ (car argstreams))
                the-empty-stream
                (⟨??⟩
                 (apply proc (map ⟨??⟩ argstreams))
                 (apply stream-map
                        (cons proc
                              (map ⟨??⟩
                                   argstreams))))))
        < src..

#      :: @t(Exercise 3.51) :: In order to take a closer look at delayed evaluation,
#         we will use the following procedure, which simply returns its argument
#         after printing it:
     :: @t(Ejercicio 3.51) :: Para examinar más de cerca la evaluación tardía,
        utilizaremos el siguiente procedimiento, que simplemente devuelve su
        argumento después de imprimirlo:

#         ..src > scheme
#           (define (show x)
#             (display-line x)
#             x)
#         < src..
        ..src > scheme
          (define (show x)
            (display-line x)
            x)
        < src..

#         What does the interpreter print in response to evaluating each expression
#         in the following sequence?@n(187)
        ¿Qué imprime el intérprete en respuesta a la evaluación de cada
        expresión en la siguiente secuencia?@n(187)

#         ..src > scheme
#           (define x
#             (stream-map
#              show
#              (stream-enumerate-interval 0 10)))
#
#           (stream-ref x 5)
#           (stream-ref x 7)
#         < src..
        ..src > scheme
          (define x
            (stream-map
             show
             (stream-enumerate-interval 0 10)))

          (stream-ref x 5)
          (stream-ref x 7)
        < src..

#      :: @t(Exercise 3.52) :: Consider the sequence of expressions
     :: @t(Ejercicio 3.52) :: Considere la secuencia de expresiones

#         ..src > scheme
#           (define sum 0)
#
#           (define (accum x)
#             (set! sum (+ x sum))
#             sum)
#
#           (define seq
#             (stream-map
#              accum
#              (stream-enumerate-interval 1 20)))
#
#           (define y (stream-filter even? seq))
#
#           (define z
#             (stream-filter
#              (lambda (x)
#                (= (remainder x 5) 0)) seq))
#
#           (stream-ref y 7)
#           (display-stream z)
#         < src..
        ..src > scheme
          (define sum 0)

          (define (accum x)
            (set! sum (+ x sum))
            sum)

          (define seq
            (stream-map
             accum
             (stream-enumerate-interval 1 20)))

          (define y (stream-filter even? seq))

          (define z
            (stream-filter
             (lambda (x)
               (= (remainder x 5) 0)) seq))

          (stream-ref y 7)
          (display-stream z)
        < src..

#         What is the value of @c(sum) after each of the above expressions is
#         evaluated?  What is the printed response to evaluating the @c(stream-ref)
#         and @c(display-stream) expressions?  Would these responses differ if we had
#         implemented @c[(delay ⟨exp⟩)] simply as @c[(lambda () ⟨exp⟩)] without using
#         the optimization provided by @c(memo-proc)?  Explain.
        ¿Cuál es el valor de @c(sum) después de cada una de las expresiones
        anteriores se evalúa? ¿Cuál es la respuesta impresa para evaluar las
        expresiones @c(stream-ref) y @c(display-stream)? ¿Serían estas
        respuestas diferentes si hubiéramos implementado @c[(delay ⟨exp⟩)]
        simplemente como @c[(lambda () ⟨exp⟩)] sin utilizar la optimización
        proporcionada por @c(memo-proc)? Explique.

# *** 3.5.2 <> Infinite Streams
*** 3.5.2 <> Corrientes infinitas

#     We have seen how to support the illusion of manipulating streams as complete
#     entities even though, in actuality, we compute only as much of the stream as
#     we need to access. We can exploit this technique to represent sequences
#     efficiently as streams, even if the sequences are very long. What is more
#     striking, we can use streams to represent sequences that are infinitely long.
#     For instance, consider the following definition of the stream of positive
#     integers:
    Hemos visto cómo soportar la ilusión de manipular corrientes como entidades
    completas, aunque, en realidad, sólo calculamos la cantidad de flujo que
    necesitamos para acceder. Podemos explotar esta técnica para representar
    secuencias eficientemente como corrientes, incluso si las secuencias son muy
    largas. Lo que es más llamativo, podemos usar secuencias para representar
    secuencias que son infinitamente largas. Por ejemplo, considere la siguiente
    definición del flujo de enteros positivos:

#     ..src > scheme
#       (define (integers-starting-from n)
#         (cons-stream
#          n (integers-starting-from (+ n 1))))
#       (define integers (integers-starting-from 1))
#     < src..
    ..src > scheme
      (define (integers-starting-from n)
        (cons-stream
         n (integers-starting-from (+ n 1))))
      (define integers (integers-starting-from 1))
    < src..

#     This makes sense because @c(integers) will be a pair whose @c(car) is 1 and
#     whose @c(cdr) is a promise to produce the integers beginning with 2.  This is
#     an infinitely long stream, but in any given time we can examine only a finite
#     portion of it. Thus, our programs will never know that the entire infinite
#     stream is not there.
    Esto tiene sentido porque @c(integers) será un par cuyo número @c(car) es 1
    y cuya @c(cdr) promesa es producir los números enteros comenzando
    por 2. Esta es una corriente infinitamente larga, pero en cualquier momento
    dado podemos examinar solamente una porción finita de ella. Así, nuestros
    programas nunca sabrán que el flujo infinito entero no está allí.

#     Using @c(integers) we can define other infinite streams, such as the stream of
#     integers that are not divisible by 7:
    Usando @c(integers) podemos definir otros flujos infinitos, como el flujo de
    enteros que no son divisibles por 7:

#     ..src > scheme
#       (define (divisible? x y) (= (remainder x y) 0))
#       (define no-sevens
#         (stream-filter (lambda (x)
#                          (not (divisible? x 7)))
#                        integers))
#     < src..
    ..src > scheme
      (define (divisible? x y) (= (remainder x y) 0))
      (define no-sevens
        (stream-filter (lambda (x)
                         (not (divisible? x 7)))
                       integers))
    < src..

#     Then we can find integers not divisible by 7 simply by accessing elements of
#     this stream:
    Entonces podemos encontrar enteros no divisibles por 7 simplemente
    accediendo a elementos de este flujo:

#     ..srci > scheme
#       > (stream-ref no-sevens 100)
#       117
#     < srci..
    ..srci > scheme
      > (stream-ref no-sevens 100)
      117
    < srci..

#     In analogy with @c(integers), we can define the infinite stream of Fibonacci
#     numbers:
    En analogía con @c(integers), podemos definir la corriente infinita de
    números de Fibonacci:

#     ..src > scheme
#       (define (fibgen a b)
#         (cons-stream a (fibgen b (+ a b))))
#       (define fibs (fibgen 0 1))
#     < src..
    ..src > scheme
      (define (fibgen a b)
        (cons-stream a (fibgen b (+ a b))))
      (define fibs (fibgen 0 1))
    < src..

#     @c(Fibs) is a pair whose @c(car) is 0 and whose @c(cdr) is a promise to
#     evaluate @c[(fibgen 1 1)]. When we evaluate this delayed @c[(fibgen 1 1)], it
#     will produce a pair whose @c(car) is 1 and whose @c(cdr) is a promise to
#     evaluate @c[(fibgen 1 2)], and so on.
    @c(Fibs) Es un par que @c(car) es 0 y cuya @c(cdr) es una promesa de evaluar
    @c[(fibgen 1 1)]. Cuando evaluamos este retraso @c[(fibgen 1 1)], producirá
    un par cuyo valor @c(car) es 1 y cuya @c(cdr) promesa es evaluar @c[(fibgen
    1 2)], y así sucesivamente.

#     For a look at a more exciting infinite stream, we can generalize the
#     @c(no-sevens) example to construct the infinite stream of prime numbers, using
#     a method known as the @e(sieve of Eratosthenes).@n(188) We start with the
#     integers beginning with 2, which is the first prime. To get the rest of the
#     primes, we start by filtering the multiples of 2 from the rest of the
#     integers. This leaves a stream beginning with 3, which is the next prime. Now
#     we filter the multiples of 3 from the rest of this stream. This leaves a
#     stream beginning with 5, which is the next prime, and so on. In other words,
#     we construct the primes by a sieving process, described as follows: To sieve a
#     stream @c(S), form a stream whose first element is the first element of @c(S)
#     and the rest of which is obtained by filtering all multiples of the first
#     element of @c(S) out of the rest of @c(S) and sieving the result. This process
#     is readily described in terms of stream operations:
    Para una mirada a un flujo infinito más emocionante, podemos generalizar el
    @c(no-sevens) ejemplo para construir el flujo infinito de números primos,
    usando un método conocido como el @e(tamiz de Eratóstenes).@n(188)
    Empezamos con los números enteros empezando con 2, que es el primer
    jefe. Para obtener el resto de los primos, comenzamos por filtrar los
    múltiplos de 2 del resto de los enteros. Esto deja una corriente que
    comienza con 3, que es la siguiente prima. Ahora filtramos los múltiplos de
    3 del resto de este flujo. Esto deja una corriente que comienza con 5, que
    es la siguiente prima, y así sucesivamente. En otras palabras, construimos
    los primos mediante un proceso de tamizado, descrito como sigue: Para
    tamizar una corriente @c(S), @c(S) Forman una corriente cuyo primer elemento
    es el primer elemento de y el resto de los cuales se obtiene filtrando todos
    los múltiplos del primer elemento de @c(S) fuera del resto @c(S) y tamizando
    el resultado. Este proceso se describe fácilmente en términos de operaciones
    de flujo:

#     ..src > scheme
#       (define (sieve stream)
#         (cons-stream
#          (stream-car stream)
#          (sieve (stream-filter
#                  (lambda (x)
#                    (not (divisible?
#                          x (stream-car stream))))
#                  (stream-cdr stream)))))
#
#       (define primes
#         (sieve (integers-starting-from 2)))
#     < src..
    ..src > scheme
      (define (sieve stream)
        (cons-stream
         (stream-car stream)
         (sieve (stream-filter
                 (lambda (x)
                   (not (divisible?
                         x (stream-car stream))))
                 (stream-cdr stream)))))

      (define primes
        (sieve (integers-starting-from 2)))
    < src..

#     Now to find a particular prime we need only ask for it:
    Ahora para encontrar una prima en particular sólo necesitamos pedirla:

#     ..srci > scheme
#       > (stream-ref primes 50)
#       233
#     < srci..
    ..srci > scheme
      > (stream-ref primes 50)
      233
    < srci..

#     It is interesting to contemplate the signal-processing system set up by
#     @c(sieve), shown in the @"(Henderson diagram) in @l(#Figure 3.31).@n(189) The
#     input stream feeds into an @"(un@c(cons)er) that separates the first element
#     of the stream from the rest of the stream. The first element is used to
#     construct a divisibility filter, through which the rest is passed, and the
#     output of the filter is fed to another sieve box. Then the original first
#     element is @c(cons)ed onto the output of the internal sieve to form the output
#     stream.  Thus, not only is the stream infinite, but the signal processor is
#     also infinite, because the sieve contains a sieve within it.
    Es interesante contemplar el sistema de procesamiento de señales creado por
    @c(sieve), mostrado en el @"(diagrama de Henderson) en la
    @l(#Figura 3.31).@n(189) corriente La entrada alimenta
    en una @"(ONU @c(cons) er) que separa el primer elemento de la secuencia del
    resto de la corriente. El primer elemento se utiliza para construir un
    filtro de divisibilidad, a través del cual se pasa el resto, y la salida del
    filtro se alimenta a otra caja de tamiz. A continuación, el primer elemento
    original se @c(cons) ed en la salida del tamiz interno para formar el flujo
    de salida. Por lo tanto, no sólo el flujo es infinito, sino que el
    procesador de señal es también infinito, porque el tamiz contiene un tamiz
    dentro de él.

#     ..figure > @t(Figure 3.31) The prime sieve viewed as a signal-processing system.
    ..figure > @t(Figura 3.31) El primer tamiz visto como un sistema de
      procesamiento de señales.

#       ..art >
#           ╭───────────────────────────────────────────────────────────────╮
#           │ sieve                                                         │
#           │                                                               │
#           │        __/│                                        │\__       │
#           │     __/car│........................................│   \__    │
#           │   _/      │           :                            │      \_  │
#         ──┼─▶<_       │           ▼                            │  cons _>─┼──▶
#           │    \__    │    ╭────────────╮    ╭────────────╮    │    __/   │
#           │       \cdr│───▶│ filter:    │    │ sieve      │───▶│ __/      │
#           │          \│    │            │───▶│            │    │/         │
#           │                │ not        │    │            │               │
#           │                │ divisible? │    │            │               │
#           │                ╰────────────╯    ╰────────────╯               │
#           ╰───────────────────────────────────────────────────────────────╯
#       < art..
      ..art >
          ╭───────────────────────────────────────────────────────────────╮
          │ sieve                                                         │
          │                                                               │
          │        __/│                                        │\__       │
          │     __/car│........................................│   \__    │
          │   _/      │           :                            │      \_  │
        ──┼─▶<_       │           ▼                            │  cons _>─┼──▶
          │    \__    │    ╭────────────╮    ╭────────────╮    │    __/   │
          │       \cdr│───▶│ filter:    │    │ sieve      │───▶│ __/      │
          │          \│    │            │───▶│            │    │/         │
          │                │ not        │    │            │               │
          │                │ divisible? │    │            │               │
          │                ╰────────────╯    ╰────────────╯               │
          ╰───────────────────────────────────────────────────────────────╯
      < art..

# @   ..img > img/chap3/Fig3.31a.std.svg
@   ..img > img/chap3/Fig3.31a.std.svg

# **** Defining streams implicitly
**** Definición implícita de flujos

#      The @c(integers) and @c(fibs) streams above were defined by specifying
#      @"(generating) procedures that explicitly compute the stream elements one by
#      one. An alternative way to specify streams is to take advantage of delayed
#      evaluation to define streams implicitly. For example, the following expression
#      defines the stream @c(ones) to be an infinite stream of ones:
     Los @c(integers) y los @c(fibs) arroyos anteriores se definieron
     especificando procedimientos de @"(generación) que calculan explícitamente
     los elementos de flujo uno por uno. Una forma alternativa de especificar
     corrientes es aprovechar la evaluación retardada para definir flujos
     implícitamente. Por ejemplo, la siguiente expresión define el flujo
     @c(ones) como un flujo infinito de unos:

#      ..src > scheme
#        (define ones (cons-stream 1 ones))
#      < src..
     ..src > scheme
       (define ones (cons-stream 1 ones))
     < src..

#      This works much like the definition of a recursive procedure: @c(ones) is a
#      pair whose @c(car) is 1 and whose @c(cdr) is a promise to evaluate
#      @c(ones). Evaluating the @c(cdr) gives us again a 1 and a promise to evaluate
#      @c(ones), and so on.
     Esto funciona como la definición de un procedimiento recursivo: @c(ones) es
     un par cuyo @c(car)1 y cuya @c(cdr) es una promesa de evaluar @c(ones). La
     evaluación de la @c(cdr) nos da de nuevo un 1 y una promesa de evaluar
     @c(ones), y así sucesivamente.

#      We can do more interesting things by manipulating streams with operations such
#      as @c(add-streams), which produces the elementwise sum of two given
#      streams:@n(190)
     Podemos hacer cosas más interesantes manipulando corrientes con operaciones
     tales como @c(add-streams), que produce la suma elemental de dos flujos
     dados:@n(190)

#      ..src > scheme
#        (define (add-streams s1 s2)
#          (stream-map + s1 s2))
#      < src..
     ..src > scheme
       (define (add-streams s1 s2)
         (stream-map + s1 s2))
     < src..

#      Now we can define the integers as follows:
     Ahora podemos definir los enteros como sigue:

#      ..src > scheme
#        (define integers
#          (cons-stream 1 (add-streams ones integers)))
#      < src..
     ..src > scheme
       (define integers
         (cons-stream 1 (add-streams ones integers)))
     < src..

#      This defines @c(integers) to be a stream whose first element is 1 and the rest
#      of which is the sum of @c(ones) and @c(integers). Thus, the second element of
#      @c(integers) is 1 plus the first element of @c(integers), or 2; the third
#      element of @c(integers) is 1 plus the second element of @c(integers), or 3;
#      and so on. This definition works because, at any point, enough of the
#      @c(integers) stream has been generated so that we can feed it back into the
#      definition to produce the next integer.
     Esto define @c(integers) a ser una corriente cuyo primer elemento es 1 y el
     resto de la cual es la suma de @c(ones) y @c(integers). Así, el segundo
     elemento de @c(integers) es 1 más el primer elemento de @c(integers), o 2;
     El tercer elemento de @c(integers) es 1 más el segundo elemento de
     @c(integers), o 3; y así. Esta definición funciona porque, en cualquier
     momento, @c(integers) se ha generado suficiente flujo para poder devolverlo
     a la definición para producir el siguiente entero.

#      We can define the Fibonacci numbers in the same style:
     Podemos definir los números de Fibonacci en el mismo estilo:

#      ..src > scheme
#        (define fibs
#          (cons-stream
#           0 (cons-stream
#              1 (add-streams
#                 (stream-cdr fibs) fibs))))
#      < src..
     ..src > scheme
       (define fibs
         (cons-stream
          0 (cons-stream
             1 (add-streams
                (stream-cdr fibs) fibs))))
     < src..

#      This definition says that @c(fibs) is a stream beginning with 0 and 1, such
#      that the rest of the stream can be generated by adding @c(fibs) to itself
#      shifted by one place:
     Esta definición dice que @c(fibs) es un flujo que comienza con 0 y 1, de
     manera que el resto del flujo puede ser generado agregando @c(fibs) a sí
     mismo desplazado por un lugar:

#      ..example >
#            1 1 2 3 5  8 13 21 … = @c[(stream-cdr fibs)]
#            0 1 1 2 3  5  8 13 … = @c(fibs)
#        0 1 1 2 3 5 8 13 21 34 … = @c(fibs)
#      < example..
     ..example >
           1 1 2 3 5  8 13 21 … = @c[(stream-cdr fibs)]
           0 1 1 2 3  5  8 13 … = @c(fibs)
       0 1 1 2 3 5 8 13 21 34 … = @c(fibs)
     < example..

#      @c(Scale-stream) is another useful procedure in formulating such stream
#      definitions. This multiplies each item in a stream by a given constant:
     @c(Scale-stream) Es otro procedimiento útil en la formulación de tales
     definiciones de flujo. Esto multiplica cada elemento en un flujo por una
     constante dada:

#      ..src > scheme
#        (define (scale-stream stream factor)
#          (stream-map
#           (lambda (x) (* x factor))
#           stream))
#      < src..
     ..src > scheme
       (define (scale-stream stream factor)
         (stream-map
          (lambda (x) (* x factor))
          stream))
     < src..

#      For example,
     Por ejemplo,

#      ..src > scheme
#        (define double
#          (cons-stream 1 (scale-stream double 2)))
#      < src..
     ..src > scheme
       (define double
         (cons-stream 1 (scale-stream double 2)))
     < src..

#      produces the stream of powers of 2: 1, 2, 4, 8, 16, 32, ….
     Produce la corriente de poderes de 2: 1, 2, 4, 8, 16, 32, ....

#      An alternate definition of the stream of primes can be given by starting with
#      the integers and filtering them by testing for primality. We will need the
#      first prime, 2, to get started:
     Una definición alternativa de la corriente de primos se puede dar
     comenzando con los números enteros y filtrando los por la prueba de
     primalidad. Vamos a necesitar la primera prima, 2, para empezar:

#      ..src > scheme
#        (define primes
#          (cons-stream
#           2 (stream-filter
#              prime? (integers-starting-from 3))))
#      < src..
     ..src > scheme
       (define primes
         (cons-stream
          2 (stream-filter
             prime? (integers-starting-from 3))))
     < src..

#      This definition is not so straightforward as it appears, because we will test
#      whether a number @m(n) is prime by checking whether @m(n) is divisible by a
#      prime (not by just any integer) less than or equal to @m(√n):
     Esta definición no es tan sencilla como parece, porque probaremos si un
     número @m(n) es primo comprobando si @m(n) es divisible por un primo (no
     por cualquier número entero) menor o igual que @m(√n) :

#      ..src > scheme
#        (define (prime? n)
#          (define (iter ps)
#            (cond ((> (square (stream-car ps)) n) true)
#                  ((divisible? n (stream-car ps)) false)
#                  (else (iter (stream-cdr ps)))))
#          (iter primes))
#      < src..
     ..src > scheme
       (define (prime? n)
         (define (iter ps)
           (cond ((> (square (stream-car ps)) n) true)
                 ((divisible? n (stream-car ps)) false)
                 (else (iter (stream-cdr ps)))))
         (iter primes))
     < src..

#      This is a recursive definition, since @c(primes) is defined in terms of the
#      @c(prime?) predicate, which itself uses the @c(primes) stream. The reason this
#      procedure works is that, at any point, enough of the @c(primes) stream has
#      been generated to test the primality of the numbers we need to check
#      next. That is, for every @m(n) we test for primality, either @m(n) is not
#      prime (in which case there is a prime already generated that divides it) or
#      @m(n) is prime (in which case there is a prime already generated––i.e., a
#      prime less than @m(n)––that is greater than @m(√n)).@n(191)
     Esta es una definición recursiva, ya que @c(primes) se define en términos
     del @c(prime?) predicado, que por sí mismo utiliza el @c(primes) flujo. La
     razón de este procedimiento funciona es que, en cualquier momento,
     @c(primes) se ha generado suficiente flujo para probar la primalidad de los
     números que necesitamos comprobar a continuación. Es decir, para cada @m(n)
     probamos la primalidad, o bien @m(n) no es primo (en cuyo caso hay un primo
     ya generado que lo divide) o @m(n) es primo (en cuyo caso hay un primo ya
     generado - es decir, un primo Menor que @m(n) - que es mayor que @m(√n)
     ).@n(191)

#      :: @t(Exercise 3.53) :: Without running the program, describe the elements of
#         the stream defined by
     :: @t(Ejercicio 3.53) :: Sin ejecutar el programa, describa los elementos
        del flujo definidos por

#         ..src > scheme
#           (define s (cons-stream 1 (add-streams s s)))
#         < src..
        ..src > scheme
          (define s (cons-stream 1 (add-streams s s)))
        < src..

#      :: @t(Exercise 3.54) :: Define a procedure @c(mul-streams), analogous to
#         @c(add-streams), that produces the elementwise product of its two input
#         streams. Use this together with the stream of @c(integers) to complete the
#         following definition of the stream whose @m(nᵗʰ) element (counting from 0)
#         is @m(n + 1) factorial:
     :: @t(Ejercicio 3.54) :: Definir un procedimiento @c(mul-streams), análogo
        a @c(add-streams), que produce el producto elementwise de sus dos
        corrientes de entrada. Utilice esto junto con el flujo de @c(integers)
        para completar la siguiente definición de la secuencia cuyo elemento
        @m(nᵗʰ) (contando desde 0) es @m(n + 1) factorial:

#         ..src > scheme
#           (define factorials
#             (cons-stream 1 (mul-streams ⟨??⟩ ⟨??⟩)))
#         < src..
        ..src > scheme
          (define factorials
            (cons-stream 1 (mul-streams ⟨??⟩ ⟨??⟩)))
        < src..

#      :: @t(Exercise 3.55) :: Define a procedure @c(partial-sums) that takes as
#         argument a stream @m(S) and returns the stream whose elements are @m(S₀),
#         @m(S₀ + S₁), @m(S₀ + S₁ + S₂, …).  For example, @c[(partial-sums integers)]
#         should be the stream 1, 3, 6, 10, 15, ….
     :: @t(Ejercicio 3.55) :: Definir un procedimiento @c(partial-sums) que toma
        como argumento una corriente @m(S) y devuelve la corriente cuyos
        elementos son @m(S₀), @m(S₀ + S₁), @m(S₀ S₁ + + S₂, ...). Por ejemplo,
        @c[(partial-sums integers)] debe ser la corriente 1, 3, 6, 10, 15, ....

#      :: @t(Exercise 3.56) :: A famous problem, first raised by R. Hamming, is to
#         enumerate, in ascending order with no repetitions, all positive integers
#         with no prime factors other than 2, 3, or 5. One obvious way to do this is
#         to simply test each integer in turn to see whether it has any factors other
#         than 2, 3, and 5. But this is very inefficient, since, as the integers get
#         larger, fewer and fewer of them fit the requirement. As an alternative, let
#         us call the required stream of numbers @c(S) and notice the following facts
#         about it.
     :: @t(Ejercicio 3.56) :: Un problema famoso, planteado por primera vez por
        R. Hamming, es enumerar, en orden ascendente sin repeticiones, todos los
        enteros positivos sin factores primos distintos de 2, 3 o 5. Una manera
        obvia de hacerlo es simplemente probar cada entero A su vez para ver si
        tiene otros factores distintos de 2, 3 y 5. Pero esto es muy
        ineficiente, ya que, a medida que los números enteros se hacen más
        grandes, cada vez menos de ellos se ajustan al requisito. Como
        alternativa, llamemos a la corriente de números requerida @c(S) y
        observemos los siguientes hechos al respecto.

#         - @c(S) begins with 1.
        - @c(S) Comienza con 1.

#         - The elements of @c[(scale-stream S 2)] are also elements of @c(S).
        - Los elementos de @c[(scale-stream S 2)] son también elementos de
          @c(S).

#         - The same is true for @c[(scale-stream S 3)] and @c[(scale-stream S 5)].
        - Lo mismo es cierto para @c[(scale-stream S 3)] y @c[(scale-stream S
          5)].

#         - These are all the elements of @c(S).
        - Estos son todos los elementos de @c(S).

#         Now all we have to do is combine elements from these sources. For this we
#         define a procedure @c(merge) that combines two ordered streams into one
#         ordered result stream, eliminating repetitions:
        Ahora todo lo que tenemos que hacer es combinar elementos de estas
        fuentes. Para ello definimos un procedimiento @c(merge) que combina dos
        flujos ordenados en un flujo ordenado de resultados, eliminando
        repeticiones:

#         ..src > scheme
#           (define (merge s1 s2)
#             (cond ((stream-null? s1) s2)
#                   ((stream-null? s2) s1)
#                   (else
#                    (let ((s1car (stream-car s1))
#                          (s2car (stream-car s2)))
#                      (cond ((< s1car s2car)
#                             (cons-stream
#                              s1car
#                              (merge (stream-cdr s1)
#                                     s2)))
#                            ((> s1car s2car)
#                             (cons-stream
#                              s2car
#                              (merge s1
#                                     (stream-cdr s2))))
#                            (else
#                             (cons-stream
#                              s1car
#                              (merge
#                               (stream-cdr s1)
#                               (stream-cdr s2)))))))))
#         < src..
        ..src > scheme
          (define (merge s1 s2)
            (cond ((stream-null? s1) s2)
                  ((stream-null? s2) s1)
                  (else
                   (let ((s1car (stream-car s1))
                         (s2car (stream-car s2)))
                     (cond ((< s1car s2car)
                            (cons-stream
                             s1car
                             (merge (stream-cdr s1)
                                    s2)))
                           ((> s1car s2car)
                            (cons-stream
                             s2car
                             (merge s1
                                    (stream-cdr s2))))
                           (else
                            (cons-stream
                             s1car
                             (merge
                              (stream-cdr s1)
                              (stream-cdr s2)))))))))
        < src..

#         Then the required stream may be constructed with @c(merge), as follows:
        Entonces la corriente requerida puede construirse con @c(merge), como
        sigue:

#         ..src > scheme
#           (define S (cons-stream 1 (merge ⟨??⟩ ⟨??⟩)))
#         < src..
        ..src > scheme
          (define S (cons-stream 1 (merge ⟨??⟩ ⟨??⟩)))
        < src..

#         Fill in the missing expressions in the places marked @c[⟨??⟩] above.
        Rellene las expresiones que faltan en los lugares marcados @c(⟨??⟩)
        arriba.

#      :: @t(Exercise 3.57) :: How many additions are performed when we compute the
#         @m(nᵗʰ) Fibonacci number using the definition of @c(fibs) based on the
#         @c(add-streams) procedure?  Show that the number of additions would be
#         exponentially greater if we had implemented @c[(delay ⟨exp⟩)] simply as
#         @c[(lambda () ⟨exp⟩)], without using the optimization provided by the
#         @c(memo-proc) procedure described in section @l(#3.5.1).@n(192)
     :: @t(Ejercicio 3.57) :: ¿Cuántas adiciones se realizan cuando se calcula
        el @m(nᵗʰ) número de Fibonacci utilizando la definición de la @c(fibs)
        base en el procedimiento @c(add-streams)? Demuestre que el número de
        adiciones sería exponencialmente mayor si hubiéramos implementado
        @c[(delay ⟨exp⟩)] simplemente como @c[(lambda () ⟨exp⟩)], sin utilizar
        la optimización proporcionada por el procedimiento @c(memo-proc)
        descrito en la seccion @l(#3.5.1).@n(192)

#      :: @t(Exercise 3.58) :: Give an interpretation of the stream computed by the
#         following procedure:
     :: @t(Ejercicio 3.58) :: Dar una interpretación de la corriente calculada
        por el siguiente procedimiento:

#         ..src > scheme
#           (define (expand num den radix)
#             (cons-stream
#              (quotient (* num radix) den)
#              (expand (remainder (* num radix) den)
#                      den
#                      radix)))
#         < src..
        ..src > scheme
          (define (expand num den radix)
            (cons-stream
             (quotient (* num radix) den)
             (expand (remainder (* num radix) den)
                     den
                     radix)))
        < src..

#         (@c(Quotient) is a primitive that returns the integer quotient of two
#         integers.)  What are the successive elements produced by @c[(expand 1 7
#         10)]?  What is produced by @c[(expand 3 8 10)]?
        (@c(Quotient) Es una primitiva que devuelve el cociente entero de dos
        enteros.) ¿Cuáles son los elementos sucesivos producidos por @c[(expand
        1 7 10)]? ¿Qué es producido por @c[(expand 3 8 10)]?

#      :: @t(Exercise 3.59) :: in section @l(#2.5.3) we saw how to implement a polynomial
#         arithmetic system representing polynomials as lists of terms. In a similar
#         way, we can work with @e(power series), such as
     :: @t(Ejercicio 3.59) :: en la seccion @l(#2.5.3) vimos cómo implementar un
        sistema aritmético polinomial que representa polinomios como listas de
        términos. De manera similar, podemos trabajar con @e(series de
        potencia), como

#         ..example >
#                         x²      x³        x⁴
#           eˣ = 1 + x + ---- + ----- + --------- + ...
#                         2     3 ⋅ 2   4 ⋅ 3 ⋅ 2
#
#                        x²        x⁴
#           cos x = 1 − ---- + --------- − ...
#                        2     4 ⋅ 3 ⋅ 2
#
#                         x³          x⁵
#           sin x = x − ----- + ------------- − ...
#                       3 ⋅ 2   5 ⋅ 4 ⋅ 3 ⋅ 2
#         < example..
        ..example >
                        x²      x³        x⁴
          eˣ = 1 + x + ---- + ----- + --------- + ...
                        2     3 ⋅ 2   4 ⋅ 3 ⋅ 2

                       x²        x⁴
          cos x = 1 − ---- + --------- − ...
                       2     4 ⋅ 3 ⋅ 2

                        x³          x⁵
          sin x = x − ----- + ------------- − ...
                      3 ⋅ 2   5 ⋅ 4 ⋅ 3 ⋅ 2
        < example..

#         represented as infinite streams. We will represent the series @m(a₀ + a₁
#         x + a₂ x² + a₃ x³ + …) as the stream whose elements are the coefficients
#         @m(a₀), @m(a₁), @m(a₂), @m(a₃), ….
        Representados como corrientes infinitas. Vamos a representar la serie
        @m(a0 + a₁ x + a₂ x² + a₃ x³ + ...) como la corriente cuyos elementos
        son los coeficientes @m(a₀), @m(a₁), @m(a₂), @m(a₃), ....

#         1. The integral of the series @m(a₀ + a₁ x + a₂ x² + a₃ x³ + …) is the
#            series
        1. La integral de la serie @m(a₀ + a₁ x + a₂ x² + a₃ x³ + ...) es la
           serie

#            ..example >
#                         1          1          1
#              c + a₀x + --- a₁x² + --- a₂x³ + --- a₃ x⁴ + ...
#                         2          3          4
#            < example..
           ..example >
                        1          1          1
             c + a₀x + --- a₁x² + --- a₂x³ + --- a₃ x⁴ + ...
                        2          3          4
           < example..

#            where @m(c) is any constant. Define a procedure @c(integrate-series)
#            that takes as input a stream @m(a₀), @m(a₁), @m(a₂), … representing a
#            power series and returns the stream @m(a₀), @m(½a₁), @m(⅓a₂), … of
#            coefficients of the non-constant terms of the integral of the
#            series. (Since the result has no constant term, it doesn't represent a
#            power series; when we use @c(integrate-series), we will @c(cons) on the
#            appropriate constant.)
           Donde @m(c) es cualquier constante. Definir un procedimiento
           @c(integrate-series) que toma como entrada una corriente @m(a₀),
           @m(a₁), @m(a₂), ... que representa una serie de potencia y devuelve
           la corriente @m(a₀), @m(½a₁), @m(⅓a₂), ... de coeficientes de los
           términos no constantes de la integral de la serie. (Puesto que el
           resultado no tiene un término constante, no representa una serie de
           potencia, cuando usamos @c(integrate-series), vamos @c(cons) a la
           constante apropiada.)

#         2. The function @m(x ↦ eˣ) is its own derivative. This implies that @m(eˣ)
#            and the integral of @m(eˣ) are the same series, except for the constant
#            term, which is @m(e⁰ = 1). Accordingly, we can generate the series for
#            @m(eˣ) as
        2. La función @m(x ↦ eˣ) es su propia derivada. Esto implica que @m(eˣ)
           y la integral de @m(eˣ) son la misma serie, excepto el término
           constante, que es @m(e⁰ = 1). En consecuencia, podemos generar la
           serie para @m(eˣ) como

#            ..src > scheme
#              (define exp-series
#                (cons-stream
#                 1 (integrate-series exp-series)))
#            < src..
           ..src > scheme
             (define exp-series
               (cons-stream
                1 (integrate-series exp-series)))
           < src..

#            Show how to generate the series for sine and cosine, starting from the
#            facts that the derivative of sine is cosine and the derivative of cosine
#            is the negative of sine:
           Mostrar cómo generar la serie para seno y coseno, partiendo de los
           hechos que la derivada de seno es coseno y la derivada de coseno es
           la negativa de seno:

#            ..src > scheme
#              (define cosine-series
#                (cons-stream 1 ⟨??⟩))
#
#              (define sine-series
#                (cons-stream 0 ⟨??⟩))
#            < src..
           ..src > scheme
             (define cosine-series
               (cons-stream 1 ⟨??⟩))

             (define sine-series
               (cons-stream 0 ⟨??⟩))
           < src..

#      :: @t(Exercise 3.60) :: With power series represented as streams of
#         coefficients as in @l(#Exercise 3.59), adding series is implemented by
#         @c(add-streams). Complete the definition of the following procedure for
#         multiplying series:
     :: @t(Ejercicio 3.60) :: Con las series de potencias representadas como
        flujos de coeficientes como en el @l(#Ejercicio 3.59), la
        adición de series se implementa mediante @c(add-streams). Complete la
        definición del siguiente procedimiento para multiplicar series:

#         ..src > scheme
#           (define (mul-series s1 s2)
#             (cons-stream ⟨??⟩ (add-streams ⟨??⟩ ⟨??⟩)))
#         < src..
        ..src > scheme
          (define (mul-series s1 s2)
            (cons-stream ⟨??⟩ (add-streams ⟨??⟩ ⟨??⟩)))
        < src..

#         You can test your procedure by verifying that @m(sin²x + cos²x = 1), using
#         the series from @l(#Exercise 3.59).
        Puede probar su procedimiento comprobando que @m(sin²x + cos²x = 1),
        utilizando la serie del @l(#Ejercicio 3.59).

#      :: @t(Exercise 3.61) :: Let @m(S) be a power series (@l(#Exercise 3.59)) whose
#         constant term is 1. Suppose we want to find the power series @m(1 / S),
#         that is, the series @m(X) such that @m(SX = 1).  Write @M(S = 1 + S_R)
#         where @M[S_R] is the part of @m(S) after the constant term. Then we can
#         solve for @m(X) as follows:
     :: @t(Ejercicio 3.61) :: Sea @m(S) una serie de potencia (
     @l(#Ejercicio 3.59) ) cuyo término constante
     es 1. Supongamos que queremos encontrar la serie de potencia @m(1 / S), es
     decir, la serie @m(X) tal que @m(SX = 1). Escribir \ (S = 1 + S_R \) donde
     \ (S_R \) es la parte de @m(S) después del término constante. Entonces
     podemos resolver para @m(X) como sigue:

#         ..example >
#                   S ⋅ X = 1
#           (1 + S_R) ⋅ X = 1
#             X + S_R ⋅ X = 1
#                       X = 1 − S_R ⋅ X
#         < example..
        ..example >
                  S ⋅ X = 1
          (1 + S_R) ⋅ X = 1
            X + S_R ⋅ X = 1
                      X = 1 − S_R ⋅ X
        < example..

#         In other words, @m(X) is the power series whose constant term is 1 and
#         whose higher-order terms are given by the negative of @M(S_R) times
#         @m(X). Use this idea to write a procedure @c(invert-unit-series) that
#         computes @m(1 / S) for a power series @m(S) with constant term 1. You will
#         need to use @c(mul-series) from @l(#Exercise 3.60).
        En otras palabras, @m(X) es la serie de potencias cuyo término constante
        es 1 y cuyos términos de orden superior están dadas por el negativo de \
        (S_R \) veces @m(X). Utilice esta idea para escribir un procedimiento
        @c(invert-unit-series) que calcula @m(1 / S) para una serie de potencias
        @m(S) con un término constante 1. Necesitará usarlo @c(mul-series) desde
        el @l(#Ejercicio 3.60).

#      :: @t(Exercise 3.62) :: Use the results of @l(#Exercise 3.60) and @l(#Exercise
#         3.61) to define a procedure @c(div-series) that divides two power
#         series. @c(Div-series) should work for any two series, provided that the
#         denominator series begins with a nonzero constant term. (If the denominator
#         has a zero constant term, then @c(div-series) should signal an error.)
#         Show how to use @c(div-series) together with the result of @l(#Exercise
#         3.59) to generate the power series for tangent.
     :: @t(Ejercicio 3.62) :: Utilice los resultados del
        @l(#Ejercicio 3.60) y el @l(#Ejercicio
        3.61) para definir un procedimiento @c(div-series) que divida dos series
        de potencia. @c(Div-series) Debe funcionar para cualquier dos series,
        siempre que la serie denominador comience con un término constante no
        cero. (Si el denominador tiene un término cero constante, entonces
        @c(div-series) debe indicar un error.) Muestre cómo usar @c(div-series)
        junto con el resultado del @l(#Ejercicio 3.59) para
        generar la serie de potencias para la tangente.

# *** 3.5.3 <> Exploiting the Stream Paradigm
*** 3.5.3 <> Explorando el paradigma de la corriente

#     Streams with delayed evaluation can be a powerful modeling tool, providing
#     many of the benefits of local state and assignment. Moreover, they avoid some
#     of the theoretical tangles that accompany the introduction of assignment into
#     a programming language.
    Las corrientes con evaluación retardada pueden ser una poderosa herramienta
    de modelado, que proporciona muchos de los beneficios del estado local y la
    asignación. Además, evitan algunos de los enredos teóricos que acompañan la
    introducción de la asignación en un lenguaje de programación.

#     The stream approach can be illuminating because it allows us to build systems
#     with different module boundaries than systems organized around assignment to
#     state variables. For example, we can think of an entire time series (or
#     signal) as a focus of interest, rather than the values of the state variables
#     at individual moments. This makes it convenient to combine and compare
#     components of state from different moments.
    El enfoque de flujo puede ser iluminante porque nos permite construir
    sistemas con diferentes límites de módulo que los sistemas organizados
    alrededor de la asignación a variables de estado. Por ejemplo, podemos
    pensar en toda una serie de tiempo (o señal) como un foco de interés, en
    lugar de los valores de las variables de estado en momentos
    individuales. Esto hace que sea conveniente combinar y comparar componentes
    de estado de diferentes momentos.

# **** Formulating iterations as stream processes
**** Formulación de iteraciones como procesos de flujo

#      In section @l(#1.2.1), we introduced iterative processes, which proceed by
#      updating state variables. We know now that we can represent state as a
#      @"(timeless) stream of values rather than as a set of variables to be updated.
#      Let's adopt this perspective in revisiting the square-root procedure from
#      @l(#1.1.7). Recall that the idea is to generate a sequence of better and
#      better guesses for the square root of @m(x) by applying over and over again
#      the procedure that improves guesses:
     En la sección @l(#1.2.1), hemos introducido procesos iterativos, que
     proceden actualizando variables de estado. Ahora sabemos que podemos
     representar el estado como un flujo de valores @"(atemporal) en vez de como
     un conjunto de variables que se actualizarán. Adoptemos esta perspectiva al
     revisar el procedimiento de raíz cuadrada de la seccion @l(#1.1.7). Recordemos
     que la idea es generar una secuencia de mejores y mejores conjeturas para
     la raíz cuadrada de @m(x) aplicando una y otra vez el procedimiento que
     mejora las conjeturas:

#      ..src > scheme
#        (define (sqrt-improve guess x)
#          (average guess (/ x guess)))
#      < src..
     ..src > scheme
       (define (sqrt-improve guess x)
         (average guess (/ x guess)))
     < src..

#      In our original @c(sqrt) procedure, we made these guesses be the successive
#      values of a state variable. Instead we can generate the infinite stream of
#      guesses, starting with an initial guess of 1:@n(193)
     En nuestro procedimiento @c(sqrt) original, hicimos estas suposiciones ser
     los valores sucesivos de una variable de estado. En su lugar podemos
     generar la corriente infinita de conjeturas, comenzando con una estimación
     inicial de 1:@n(193)

#      ..srci > scheme
#        > (define (sqrt-stream x)
#        ^   (define guesses
#        ^     (cons-stream
#        ^      1.0 (stream-map
#        ^           (lambda (guess)
#        ^             (sqrt-improve guess x))
#        ^           guesses)))
#        ^   guesses)
#
#        > (display-stream (sqrt-stream 2))
#        1.
#        1.5
#        1.4166666666666665
#        1.4142156862745097
#        1.4142135623746899
#        …
#      < srci..
     ..srci > scheme
       > (define (sqrt-stream x)
       ^   (define guesses
       ^     (cons-stream
       ^      1.0 (stream-map
       ^           (lambda (guess)
       ^             (sqrt-improve guess x))
       ^           guesses)))
       ^   guesses)

       > (display-stream (sqrt-stream 2))
       1.
       1.5
       1.4166666666666665
       1.4142156862745097
       1.4142135623746899
       …
     < srci..

#      We can generate more and more terms of the stream to get better and better
#      guesses. If we like, we can write a procedure that keeps generating terms
#      until the answer is good enough. (See @l(#Exercise 3.64).)
     Podemos generar más y más términos del flujo para obtener mejores y mejores
     conjeturas. Si nos gusta, podemos escribir un procedimiento que siga
     generando términos hasta que la respuesta sea lo suficientemente
     buena. (Véase el @l(#Ejercicio 3.64) .)

#      Another iteration that we can treat in the same way is to generate an
#      approximation to @m(π), based upon the alternating series that we saw in
#      @l(#1.3.1):
     Otra iteración que podemos tratar de la misma manera es generar una
     aproximación a @m(π), basada en la serie alternante que vimos en
     @l(#1.3.1) :

#      ..example >
#         π         1     1     1
#        --- = 1 − --- + --- − --- + ...
#         4         3     5     7
#      < example..
     ..example >
        π         1     1     1
       --- = 1 − --- + --- − --- + ...
        4         3     5     7
     < example..

#      We first generate the stream of summands of the series (the reciprocals of the
#      odd integers, with alternating signs). Then we take the stream of sums of more
#      and more terms (using the @c(partial-sums) procedure of @l(#Exercise 3.55))
#      and scale the result by 4:
     Primero generamos la corriente de sumandos de la serie (los recíprocos de
     los números impares, con signos alternos). Entonces tomamos el flujo de
     sumas de más y más términos (usando el procedimiento @c(partial-sums) del
     @l(#Ejercicio 3.55) ) y escalamos el resultado por 4:

#      ..srci > scheme
#        > (define (pi-summands n)
#        ^   (cons-stream
#        ^    (/ 1.0 n)
#        ^    (stream-map - (pi-summands (+ n 2)))))
#
#        > (define pi-stream
#        ^   (scale-stream
#        ^    (partial-sums (pi-summands 1)) 4))
#
#        > (display-stream pi-stream)
#        4.
#        2.666666666666667
#        3.466666666666667
#        2.8952380952380956
#        3.3396825396825403
#        2.9760461760461765
#        3.2837384837384844
#        3.017071817071818
#        …
#      < srci..
     ..srci > scheme
       > (define (pi-summands n)
       ^   (cons-stream
       ^    (/ 1.0 n)
       ^    (stream-map - (pi-summands (+ n 2)))))

       > (define pi-stream
       ^   (scale-stream
       ^    (partial-sums (pi-summands 1)) 4))

       > (display-stream pi-stream)
       4.
       2.666666666666667
       3.466666666666667
       2.8952380952380956
       3.3396825396825403
       2.9760461760461765
       3.2837384837384844
       3.017071817071818
       …
     < srci..

#      This gives us a stream of better and better approximations to @m(π), although
#      the approximations converge rather slowly. Eight terms of the sequence bound
#      the value of @m(π) between 3.284 and 3.017.
     Esto nos da una corriente de mejores y mejores aproximaciones a @m(π),
     aunque las aproximaciones convergen bastante lentamente. Ocho términos de
     la secuencia unían el valor de @m(π) entre 3.284 y 3.017.

#      So far, our use of the stream of states approach is not much different from
#      updating state variables. But streams give us an opportunity to do some
#      interesting tricks. For example, we can transform a stream with a @e(sequence
#      accelerator) that converts a sequence of approximations to a new sequence that
#      converges to the same value as the original, only faster.
     Hasta ahora, nuestro uso de la corriente de enfoque de estados no es muy
     diferente de la actualización de las variables de estado. Pero los arroyos
     nos dan la oportunidad de hacer algunos trucos interesantes. Por ejemplo,
     podemos transformar un flujo con un @e(acelerador de secuencia) que
     convierte una secuencia de aproximaciones a una nueva secuencia que
     converge al mismo valor que el original, sólo más rápido.

#      One such accelerator, due to the eighteenth-century Swiss mathematician
#      Leonhard Euler, works well with sequences that are partial sums of alternating
#      series (series of terms with alternating signs). In Euler's technique, if
#      @m(Sₙ) is the @m(nᵗʰ) term of the original sum sequence, then the accelerated
#      sequence has terms
     Uno de estos aceleradores, debido al matemático suizo del siglo XVIII,
     Leonhard Euler, funciona bien con secuencias que son sumas parciales de
     series alternadas (serie de términos con signos alternantes). En la técnica
     de Euler, si @m(Sₙ) es el término @m(nᵗʰ) de la secuencia de suma original,
     entonces la secuencia acelerada tiene términos

#      ..example >
#                     (S₍ₙ₊₁₎ − Sₙ)²
#        S₍ₙ₊₁₎ − ---------------------
#                 S₍ₙ₋₁₎ − 2Sₙ + S₍ₙ₊₁₎
#      < example..
     ..example >
                    (S₍ₙ₊₁₎ − Sₙ)²
       S₍ₙ₊₁₎ − ---------------------
                S₍ₙ₋₁₎ − 2Sₙ + S₍ₙ₊₁₎
     < example..

#      Thus, if the original sequence is represented as a stream of values, the
#      transformed sequence is given by
     Por lo tanto, si la secuencia original se representa como una corriente de
     valores, la secuencia transformada se da por

#      ..src > scheme
#        (define (euler-transform s)
#          (let ((s0 (stream-ref s 0))     ; Sₙ₋₁
#                (s1 (stream-ref s 1))     ; Sₙ
#                (s2 (stream-ref s 2)))    ; Sₙ₊₁
#            (cons-stream
#             (- s2 (/ (square (- s2 s1))
#                      (+ s0 (* -2 s1) s2)))
#             (euler-transform (stream-cdr s)))))
#      < src..
     ..src > scheme
       (define (euler-transform s)
         (let ((s0 (stream-ref s 0))     ; Sₙ₋₁
               (s1 (stream-ref s 1))     ; Sₙ
               (s2 (stream-ref s 2)))    ; Sₙ₊₁
           (cons-stream
            (- s2 (/ (square (- s2 s1))
                     (+ s0 (* -2 s1) s2)))
            (euler-transform (stream-cdr s)))))
     < src..

#      We can demonstrate Euler acceleration with our sequence of approximations to
#      @m(π):
     Podemos demostrar la aceleración de Euler con nuestra secuencia de
     aproximaciones a @m(π) :

#      ..srci > scheme
#        > (display-stream
#        ^  (euler-transform pi-stream))
#        3.166666666666667
#        3.1333333333333337
#        3.1452380952380956
#        3.13968253968254
#        3.1427128427128435
#        3.1408813408813416
#        3.142071817071818
#        3.1412548236077655
#        …
#      < srci..
     ..srci > scheme
       > (display-stream
       ^  (euler-transform pi-stream))
       3.166666666666667
       3.1333333333333337
       3.1452380952380956
       3.13968253968254
       3.1427128427128435
       3.1408813408813416
       3.142071817071818
       3.1412548236077655
       …
     < srci..

#      Even better, we can accelerate the accelerated sequence, and recursively
#      accelerate that, and so on. Namely, we create a stream of streams (a structure
#      we'll call a @e(tableau)) in which each stream is the transform of the
#      preceding one:
     Aún mejor, podemos acelerar la secuencia acelerada, y recursivamente
     acelerar eso, y así sucesivamente. Es decir, creamos un flujo de flujos
     (una estructura que llamaremos un @e(cuadro) ) en el que cada flujo es la
     transformación del anterior:

#      ..src > scheme
#        (define (make-tableau transform s)
#          (cons-stream
#           s
#           (make-tableau
#            transform
#            (transform s))))
#      < src..
     ..src > scheme
       (define (make-tableau transform s)
         (cons-stream
          s
          (make-tableau
           transform
           (transform s))))
     < src..

#      The tableau has the form
     El cuadro tiene la forma

#      ..example >
#        s₀₀   s₀₁   s₀₂   s₀₃   s₀₄   ...
#              s₁₀   s₁₁   s₁₂   s₁₃   ...
#                    s₂₀   s₂₁   s₂₂   ...
#                                      ...
#      < example..
     ..example >
       s₀₀   s₀₁   s₀₂   s₀₃   s₀₄   ...
             s₁₀   s₁₁   s₁₂   s₁₃   ...
                   s₂₀   s₂₁   s₂₂   ...
                                     ...
     < example..

#      Finally, we form a sequence by taking the first term in each row of the
#      tableau:
     Finalmente, formamos una secuencia tomando el primer término en cada fila
     del cuadro:

#      ..src > scheme
#        (define (accelerated-sequence transform s)
#          (stream-map stream-car
#                      (make-tableau transform s)))
#      < src..
     ..src > scheme
       (define (accelerated-sequence transform s)
         (stream-map stream-car
                     (make-tableau transform s)))
     < src..

#      We can demonstrate this kind of @"(super-acceleration) of the @m(π) sequence:
     Podemos demostrar este tipo de @"(super-aceleración) de la secuencia
     @m(π) :

#      ..srci > scheme
#        > (display-stream
#        ^  (accelerated-sequence euler-transform
#        ^                        pi-stream))
#        4.
#        3.166666666666667
#        3.142105263157895
#        3.141599357319005
#        3.1415927140337785
#        3.1415926539752927
#        3.1415926535911765
#        3.141592653589778
#        …
#      < srci..
     ..srci > scheme
       > (display-stream
       ^   (accelerated-sequence euler-transform
       ^                         pi-stream))
       4.
       3.166666666666667
       3.142105263157895
       3.141599357319005
       3.1415927140337785
       3.1415926539752927
       3.1415926535911765
       3.141592653589778
       …
     < srci..

#      The result is impressive. Taking eight terms of the sequence yields the
#      correct value of @m(π) to 14 decimal places. If we had used only the original
#      @m(π) sequence, we would need to compute on the order of @m(10¹³) terms (i.e.,
#      expanding the series far enough so that the individual terms are less than
#      @m(10⁻¹³)) to get that much accuracy!
     El resultado es impresionante. Tomando ocho términos de la secuencia se
     obtiene el valor correcto de @m(π) a 14 decimales. Si hubiéramos usado sólo
     la secuencia @m(π) original, necesitaríamos calcular en el orden de
     @m(10¹³) términos (es decir, expandir la serie lo suficientemente lejos
     para que los términos individuales sean menores que @m(10⁻¹³) ) para
     obtener esa gran precisión!

#      We could have implemented these acceleration techniques without using streams.
#      But the stream formulation is particularly elegant and convenient because the
#      entire sequence of states is available to us as a data structure that can be
#      manipulated with a uniform set of operations.
     Podríamos haber implementado estas técnicas de aceleración sin usar
     corrientes. Pero la formulación de la corriente es particularmente elegante
     y conveniente porque toda la secuencia de estados está disponible para
     nosotros como una estructura de datos que se puede manipular con un
     conjunto uniforme de operaciones.

#      :: @t(Exercise 3.63) :: Louis Reasoner asks why the @c(sqrt-stream) procedure
#         was not written in the following more straightforward way, without the
#         local variable @c(guesses):
     :: @t(Ejercicio 3.63) :: Louis Reasoner pregunta por qué el procedimiento @c(sqrt-stream) no fue escrito de la siguiente manera más directa, sin la
        variable local @c(guesses):

#         ..src > scheme
#           (define (sqrt-stream x)
#             (cons-stream
#              1.0
#              (stream-map (lambda (guess)
#                            (sqrt-improve guess x))
#                          (sqrt-stream x))))
#         < src..
        ..src > scheme
          (define (sqrt-stream x)
            (cons-stream
             1.0
             (stream-map (lambda (guess)
                           (sqrt-improve guess x))
                         (sqrt-stream x))))
        < src..

#         Alyssa P. Hacker replies that this version of the procedure is considerably
#         less efficient because it performs redundant computation. Explain Alyssa's
#         answer. Would the two versions still differ in efficiency if our
#         implementation of @c(delay) used only @c[(lambda () ⟨exp⟩)] without using
#         the optimization provided by @c(memo-proc) (section @l(#3.5.1))?
        Alyssa P. Hacker responde que esta versión del procedimiento es
        considerablemente menos eficiente porque realiza cálculos
        redundantes. Explique la respuesta de Alyssa. ¿Serían las dos versiones
        todavía diferenciadas en eficiencia si nuestra implementación se
        @c(delay) utiliza sólo @c[(lambda () ⟨exp⟩)] sin utilizar la
        optimización proporcionada por @c(memo-proc) (seccion @l(#3.5.1))?

#      :: @t(Exercise 3.64) :: Write a procedure @c(stream-limit) that takes as
#         arguments a stream and a number (the tolerance). It should examine the
#         stream until it finds two successive elements that differ in absolute value
#         by less than the tolerance, and return the second of the two
#         elements. Using this, we could compute square roots up to a given tolerance
#         by
     :: @t(Ejercicio 3.64) :: Escriba un procedimiento @c(stream-limit) que tome
        como argumentos una secuencia y un número (la tolerancia). Debe examinar
        la corriente hasta encontrar dos elementos sucesivos que difieren en
        valor absoluto por menos que la tolerancia, y devolver el segundo de los
        dos elementos. Usando esto, podríamos calcular raíces cuadradas hasta
        una tolerancia dada por

#         ..src > scheme
#           (define (sqrt x tolerance)
#             (stream-limit (sqrt-stream x) tolerance))
#         < src..
        ..src > scheme
          (define (sqrt x tolerance)
            (stream-limit (sqrt-stream x) tolerance))
        < src..

#      :: @t(Exercise 3.65) :: Use the series
     :: @t(Ejercicio 3.65) :: Utilice la serie

#         ..example >
#                       1     1     1
#           ln 2 = 1 − --- + --- − --- + ...
#                       2     3     4
#         < example..
        ..example >
                      1     1     1
          ln 2 = 1 − --- + --- − --- + ...
                      2     3     4
        < example..

#         to compute three sequences of approximations to the natural logarithm of 2,
#         in the same way we did above for @m(π). How rapidly do these sequences
#         converge?
        Para calcular tres secuencias de aproximaciones al logaritmo natural de
        2, de la misma forma que lo hicimos anteriormente para @m(π). ¿Con qué
        rapidez convergen estas secuencias?

# **** Infinite streams of pairs
**** Corrientes infinitas de parejas

#      in section @l(#2.2.3), we saw how the sequence paradigm handles traditional nested
#      loops as processes defined on sequences of pairs. If we generalize this
#      technique to infinite streams, then we can write programs that are not easily
#      represented as loops, because the @"(looping) must range over an infinite set.
     en la seccion @l(#2.2.3), vimos cómo el paradigma de secuencias maneja bucles
     anidados tradicionales como procesos definidos en secuencias de pares. Si
     generalizamos esta técnica a corrientes infinitas, entonces podemos
     escribir programas que no son fácilmente representados como bucles, porque
     el @"(bucle) debe ir sobre un conjunto infinito.

#      For example, suppose we want to generalize the @c(prime-sum-pairs) procedure
#      of section @l(#2.2.3) to produce the stream of pairs of @e(all) integers @m[(i, j)]
#      with @m(i ≤ j) such that @m(i + j) is prime. If @c(int-pairs) is the sequence
#      of all pairs of integers @m[(i, j)] with @m(i ≤ j), then our required stream
#      is simply@n(194)
     Por ejemplo, supongamos que queremos generalizar el procedimiento @c(prime-sum-pairs) de la seccion @l(#2.2.3) para producir el flujo de pares de
     @e(todos los) enteros @m[(i, j)] con @m(i ≤ j) tal que @m(i + j) sea
     primo. Si @c(int-pairs) es la secuencia de todos los pares de enteros
     @m[(i, j)] con @m(i ≤ j), entonces nuestra corriente requerida es
     simplemente@n(194)

#      ..src > scheme
#        (stream-filter
#         (lambda (pair)
#           (prime? (+ (car pair) (cadr pair))))
#         int-pairs)
#      < src..
     ..src > scheme
       (stream-filter
        (lambda (pair)
          (prime? (+ (car pair) (cadr pair))))
        int-pairs)
     < src..

#      Our problem, then, is to produce the stream @c(int-pairs). More generally,
#      suppose we have two streams @m[S = (Sᵢ)] and @m[T = (Tⱼ)], and imagine the
#      infinite rectangular array
     Nuestro problema, entonces, es producir la corriente @c(int-pairs). En
     términos más generales, supongamos que tenemos dos flujos @m(S = (Sᵢ)) y
     @m(T = (Tⱼ)), e imaginemos el array rectangular infinito

#      ..example >
#        (S₀, T₀)  (S₀, T₁)  (S₀, T₂)  ...
#        (S₁, T₀)  (S₁, T₁)  (S₁, T₂)  ...
#        (S₂, T₀)  (S₂, T₁)  (S₂, T₂)  ...
#           ...
#      < example..
     ..example >
       (S₀, T₀)  (S₀, T₁)  (S₀, T₂)  ...
       (S₁, T₀)  (S₁, T₁)  (S₁, T₂)  ...
       (S₂, T₀)  (S₂, T₁)  (S₂, T₂)  ...
          ...
     < example..

#      We wish to generate a stream that contains all the pairs in the array that lie
#      on or above the diagonal, i.e., the pairs
     Deseamos generar un flujo que contenga todos los pares de la matriz que se
     encuentran sobre o por encima de la diagonal, es decir, los pares

#      ..example >
#        (S₀, T₀)  (S₀, T₁)  (S₀, T₂)  ...
#                  (S₁, T₁)  (S₁, T₂)  ...
#                            (S₂, T₂)  ...
#                                      ...
#      < example..
     ..example >
       (S₀, T₀)  (S₀, T₁)  (S₀, T₂)  ...
                 (S₁, T₁)  (S₁, T₂)  ...
                           (S₂, T₂)  ...
                                     ...
     < example..

#      (If we take both @m(S) and @m(T) to be the stream of integers, then this will
#      be our desired stream @c(int-pairs).)
     (Si tomamos @m(S) y @m(T) como el flujo de enteros, entonces este será
     nuestro flujo deseado @c(int-pairs).)

#      Call the general stream of pairs @c[(pairs S T)], and consider it to be
#      composed of three parts: the pair @m[(S₀, T₀)], the rest of the pairs in the
#      first row, and the remaining pairs:@n(195)
     Llamar a la corriente general de pares @c[(pairs S T)], y considerar que se
     compone de tres partes: el par @m[(S₀, T₀)], el resto de los pares en la
     primera fila, y los pares restantes:@n(195)

#      ..example >
#        (S₀, T₀)   | (S₀, T₁)  (S₀, T₂)  ...
#        -----------+-----------------------------
#                   | (S₁, T₁)  (S₁, T₂)  ...
#                   |           (S₂, T₂)  ...
#                   |                     ...
#      < example..
     ..example >
       (S₀, T₀)   | (S₀, T₁)  (S₀, T₂)  ...
       -----------+-----------------------------
                  | (S₁, T₁)  (S₁, T₂)  ...
                  |           (S₂, T₂)  ...
                  |                     ...
     < example..

#      Observe that the third piece in this decomposition (pairs that are not in the
#      first row) is (recursively) the pairs formed from @c[(stream-cdr S)] and
#      @c[(stream-cdr T)]. Also note that the second piece (the rest of the first
#      row) is
     Observe que la tercera pieza en esta descomposición (pares que no están en
     la primera fila) es (recursivamente) los pares formados de @c[(stream-cdr
     S)] y @c[(stream-cdr T)]. Observe también que la segunda pieza (el resto de
     la primera fila) es

#      ..src > scheme
#        (stream-map (lambda (x)
#                      (list (stream-car s) x))
#                    (stream-cdr t))
#      < src..
     ..src > scheme
       (stream-map (lambda (x)
                     (list (stream-car s) x))
                   (stream-cdr t))
     < src..

#      Thus we can form our stream of pairs as follows:
     Así podemos formar nuestra corriente de pares de la siguiente manera:

#      ..src > scheme
#        (define (pairs s t)
#          (cons-stream
#           (list (stream-car s) (stream-car t))
#           (⟨combine-in-some-way⟩
#            (stream-map (lambda (x)
#                          (list (stream-car s) x))
#                        (stream-cdr t))
#            (pairs (stream-cdr s)
#                   (stream-cdr t)))))
#      < src..
     ..src > scheme
       (define (pairs s t)
         (cons-stream
          (list (stream-car s) (stream-car t))
          (⟨combine-in-some-way⟩
           (stream-map (lambda (x)
                         (list (stream-car s) x))
                       (stream-cdr t))
           (pairs (stream-cdr s)
                  (stream-cdr t)))))
     < src..

#      In order to complete the procedure, we must choose some way to combine the two
#      inner streams. One idea is to use the stream analog of the @c(append)
#      procedure from @l(#2.2.1):
     Para completar el procedimiento, debemos elegir alguna forma de combinar
     los dos flujos internos. Una idea es usar la corriente analógica del
     procedimiento @c(append) de la seccion @l(#2.2.1) :

#      ..src > scheme
#        (define (stream-append s1 s2)
#          (if (stream-null? s1)
#              s2
#              (cons-stream
#               (stream-car s1)
#               (stream-append (stream-cdr s1) s2))))
#      < src..
     ..src > scheme
       (define (stream-append s1 s2)
         (if (stream-null? s1)
             s2
             (cons-stream
              (stream-car s1)
              (stream-append (stream-cdr s1) s2))))
     < src..

#      This is unsuitable for infinite streams, however, because it takes all the
#      elements from the first stream before incorporating the second stream. In
#      particular, if we try to generate all pairs of positive integers using
     Esto no es adecuado para corrientes infinitas, sin embargo, porque toma
     todos los elementos de la primera corriente antes de incorporar la segunda
     corriente. En particular, si tratamos de generar todos los pares de números
     enteros positivos usando

#      ..src > scheme
#        (pairs integers integers)
#      < src..
     ..src > scheme
       (pairs integers integers)
     < src..

#      our stream of results will first try to run through all pairs with the first
#      integer equal to 1, and hence will never produce pairs with any other value of
#      the first integer.
     Nuestro flujo de resultados intentará primero ejecutar todos los pares con
     el primer entero igual a 1, y por lo tanto nunca producirá pares con
     cualquier otro valor del primer entero.

#      To handle infinite streams, we need to devise an order of combination that
#      ensures that every element will eventually be reached if we let our program
#      run long enough. An elegant way to accomplish this is with the following
#      @c(interleave) procedure:@n(196)
     Para manejar flujos infinitos, necesitamos idear un orden de combinación
     que asegure que cada elemento sea alcanzado eventualmente si dejamos que
     nuestro programa funcione lo suficiente. Una forma elegante de lograr esto
     es con el siguiente procedimiento @c(interleave):@n(196)

#      ..src > scheme
#        (define (interleave s1 s2)
#          (if (stream-null? s1)
#              s2
#              (cons-stream
#               (stream-car s1)
#               (interleave s2 (stream-cdr s1)))))
#      < src..
     ..src > scheme
       (define (interleave s1 s2)
         (if (stream-null? s1)
             s2
             (cons-stream
              (stream-car s1)
              (interleave s2 (stream-cdr s1)))))
     < src..

#      Since @c(interleave) takes elements alternately from the two streams, every
#      element of the second stream will eventually find its way into the interleaved
#      stream, even if the first stream is infinite.
     Puesto que @c(interleave) toma elementos alternativamente de las dos
     corrientes, cada elemento de la segunda corriente llegará finalmente a la
     corriente entrelazada, incluso si la primera corriente es infinita.

#      We can thus generate the required stream of pairs as
     Podemos generar la corriente de pares requerida como

#      ..src > scheme
#        (define (pairs s t)
#          (cons-stream
#           (list (stream-car s) (stream-car t))
#           (interleave
#            (stream-map (lambda (x)
#                          (list (stream-car s) x))
#                        (stream-cdr t))
#            (pairs (stream-cdr s) (stream-cdr t)))))
#      < src..
     ..src > scheme
       (define (pairs s t)
         (cons-stream
          (list (stream-car s) (stream-car t))
          (interleave
           (stream-map (lambda (x)
                         (list (stream-car s) x))
                       (stream-cdr t))
           (pairs (stream-cdr s) (stream-cdr t)))))
     < src..

#      :: @t(Exercise 3.66) :: Examine the stream @c[(pairs integers integers)]. Can
#         you make any general comments about the order in which the pairs are placed
#         into the stream? For example, approximately how many pairs precede the pair
#         (1, 100)?  the pair (99, 100)? the pair (100, 100)? (If you can make
#         precise mathematical statements here, all the better. But feel free to give
#         more qualitative answers if you find yourself getting bogged down.)
     :: @t(Ejercicio 3.66) :: Examine el flujo @c[(pairs integers
        integers)]. ¿Puede hacer comentarios generales sobre el orden en que se
        colocan los pares en el flujo? Por ejemplo, ¿aproximadamente cuántos
        pares preceden al par (1, 100)? El par (99, 100)? El par (100, 100)? (Si
        usted puede hacer declaraciones matemáticas precisas aquí, mucho mejor,
        pero siéntase libre de dar más respuestas cualitativas si se encuentra
        atrapado.)

#      :: @t(Exercise 3.67) :: Modify the @c(pairs) procedure so that @c[(pairs
#         integers integers)] will produce the stream of @e(all) pairs of integers
#         @m[(i, j)] (without the condition @m(i ≤ j)). Hint: You will need to mix in
#         an additional stream.
     :: @t(Ejercicio 3.67) :: Modifique el procedimiento @c(pairs) para que
        @c[(pairs integers integers)] produzca el flujo de @e(todos los) pares
        de enteros @m[(i, j)] (sin la condición @m(i ≤ j) ). Sugerencia: Tendrá
        que mezclar un flujo adicional.

#      :: @t(Exercise 3.68) :: Louis Reasoner thinks that building a stream of pairs
#         from three parts is unnecessarily complicated.  Instead of separating the
#         pair @m[(S₀, T₀)] from the rest of the pairs in the first row, he proposes
#         to work with the whole first row, as follows:
     :: @t(Ejercicio 3.68) :: Louis Reasoner piensa que construir una corriente
        de pares de tres partes es innecesariamente complicado. En lugar de
        separar el par @m[(S₀, T₀)] del resto de los pares en la primera fila,
        propone trabajar con toda la primera fila, de la siguiente manera:

#         ..src > scheme
#           (define (pairs s t)
#             (interleave
#              (stream-map
#               (lambda (x)
#                 (list (stream-car s) x))
#               t)
#              (pairs (stream-cdr s)
#                     (stream-cdr t))))
#         < src..
        ..src > scheme
          (define (pairs s t)
            (interleave
             (stream-map
              (lambda (x)
                (list (stream-car s) x))
              t)
             (pairs (stream-cdr s)
                    (stream-cdr t))))
        < src..

#         Does this work?  Consider what happens if we evaluate @c[(pairs integers
#         integers)] using Louis's definition of @c(pairs).
        ¿Esto funciona? Considere lo que sucede si evaluamos @c[(pairs integers
        integers)] usando la definición de Louis de @c(pairs).

#      :: @t(Exercise 3.69) :: Write a procedure @c(triples) that takes three
#         infinite streams, @m(S), @m(T), and @m(U), and produces the stream of
#         triples @m[(Sᵢ, Tⱼ, Uₙ)] such that @m(i ≤ j ≤ k).  Use @c(triples) to
#         generate the stream of all Pythagorean triples of positive integers, i.e.,
#         the triples @m[(i, j, k)] such that @m(i ≤ j) and @m(i² + j² = k²).
     :: @t(Ejercicio 3.69) :: Escriba un procedimiento @c(triples) que tome tres
        corrientes infinitas, @m(S), @m(T) y @m(U), y produzca la corriente de
        triples @m[(Sᵢ, Tⱼ, Uₙ)] tal que @m(i ≤ j ≤ k). Se utiliza @c(triples)
        para generar la corriente de todos los triples pitagóricos de enteros
        positivos, es decir, los triples @m[(i, j, k)] tales que @m(i ≤ j) e
        @m(i² + j² = k²).

#      :: @t(Exercise 3.70) :: It would be nice to be able to generate streams in
#         which the pairs appear in some useful order, rather than in the order that
#         results from an @e(ad hoc) interleaving process. We can use a technique
#         similar to the @c(merge) procedure of @l(#Exercise 3.56), if we define a
#         way to say that one pair of integers is @"(less than) another. One way to
#         do this is to define a @"(weighting function) @m[W(i, j)] and stipulate
#         that @m[(i₁, j₁)] is less than @m[(i₂, j₂)] if @m[W(i₁, j₁) < W(i₂,
#         j₂)]. Write a procedure @c(merge-weighted) that is like @c(merge), except
#         that @c(merge-weighted) takes an additional argument @c(weight), which is a
#         procedure that computes the weight of a pair, and is used to determine the
#         order in which elements should appear in the resulting merged
#         stream.@n(197) Using this, generalize @c(pairs) to a procedure
#         @c(weighted-pairs) that takes two streams, together with a procedure that
#         computes a weighting function, and generates the stream of pairs, ordered
#         according to weight. Use your procedure to generate
     :: @t(Ejercicio 3.70) :: Sería bueno ser capaz de generar corrientes en las
        que los pares aparecen en algún orden útil, en lugar de en el orden que
        resulta de un proceso de entrelazado @e(ad hoc). Podemos usar una
        técnica similar al procedimiento @c(merge) del
        @l(#Ejercicio 3.56), si definimos una manera de decir que
        un par de números enteros es @"(menor que) otro. Una forma de hacerlo es
        definir una @"(función de ponderación ) @m(W (i, j)) y estipular que
        @m[(i₁, j₁)] es menor que @m[(i₂, j₂)] si @m(W (i₁, j₁) <W (i₂,
        j₂)). Escribir un procedimiento @c(merge-weighted) que es como
        @c(merge), excepto que @c(merge-weighted) toma un argumento adicional
        @c(weight), que es un procedimiento que calcula el peso de un par, Y se
        utiliza para determinar el orden en que los elementos deben aparecer en
        el flujo combinado resultante.@n(197) Usando esto, generalizar
        @c(pairs) a un procedimiento @c(weighted-pairs) que se lleva a dos
        corrientes, junto con un procedimiento que calcula una función de
        ponderación, y genera el flujo de pares, ordenados de acuerdo con el
        peso. Utilice su procedimiento para generar

#         1. the stream of all pairs of positive integers @m[(i, j)] with @m(i ≤ j)
#            ordered according to the sum @m(i + j),
        1. La corriente de todos los pares de enteros positivos @m[(i, j)] con
           @m(i ≤ j) ordenados de acuerdo con la suma @m(i + j) ,

#         2. the stream of all pairs of positive integers @m[(i, j)] with @m(i ≤ j),
#            where neither @m(i) nor @m(j) is divisible by 2, 3, or 5, and the pairs
#            are ordered according to the sum @m(2i + 3j + 5ij).
        2. La corriente de todos los pares de enteros positivos @m[(i, j)] con
           @m(i ≤ j), donde ni @m(i) ni @m(j) son divisibles por 2, 3 ó 5 y los
           pares están ordenados de acuerdo con la suma @m(2i + 3j + 5ij).

#      :: @t(Exercise 3.71) :: Numbers that can be expressed as the sum of two cubes
#         in more than one way are sometimes called @e(Ramanujan numbers), in honor
#         of the mathematician Srinivasa Ramanujan.@n(198) Ordered streams of pairs
#         provide an elegant solution to the problem of computing these numbers. To
#         find a number that can be written as the sum of two cubes in two different
#         ways, we need only generate the stream of pairs of integers @m[(i, j)]
#         weighted according to the sum @m(i³ + j³) (see @l(#Exercise 3.70)), then
#         search the stream for two consecutive pairs with the same weight. Write a
#         procedure to generate the Ramanujan numbers. The first such number is
#         1,729. What are the next five?
     :: @t(Ejercicio 3.71) :: Los números que se pueden expresar como la suma de
        dos cubos en más de una manera se llaman a veces @e(números de
        Ramanujan), en honor del matemático Srinivasa Ramanujan.@n(198)
        Los flujos ordenados de pares proporcionan una solución elegante al
        problema de calcular estos números. Para encontrar un número que se
        puede escribir como la suma de dos cubos de dos maneras diferentes, sólo
        necesitamos generar el flujo de pares de enteros @m[(i, j)] ponderados
        de acuerdo con la suma @m(i³ + j³) (véase el
        @l(#Ejercicio 3.70) ), luego buscar La corriente para dos
        pares consecutivos con el mismo peso. Escribe un procedimiento para
        generar los números de Ramanujan. El primer número es 1.729. ¿Cuáles son
        los próximos cinco?

#      :: @t(Exercise 3.72) :: In a similar way to @l(#Exercise 3.71) generate a
#         stream of all numbers that can be written as the sum of two squares in
#         three different ways (showing how they can be so written).
     :: @t(Ejercicio 3.72) :: De manera similar al @l(#Ejercicio
        3.71,) genere un flujo de todos los números que se pueden escribir como
        la suma de dos cuadrados de tres formas diferentes (mostrando cómo se
        pueden escribir así).

# **** Streams as signals
**** Corrientes como señales

#      We began our discussion of streams by describing them as computational analogs
#      of the @"(signals) in signal-processing systems. In fact, we can use streams
#      to model signal-processing systems in a very direct way, representing the
#      values of a signal at successive time intervals as consecutive elements of a
#      stream. For instance, we can implement an @e(integrator) or @e(summer) that,
#      for an input stream @m[x = (xᵢ)], an initial value @m(C), and a small
#      increment @m(dt), accumulates the sum
     Comenzamos nuestra discusión de los flujos describiéndolos como análogos
     computacionales de las @"(señales) en los sistemas de procesamiento de
     señales. De hecho, podemos usar corrientes para modelar sistemas de
     procesamiento de señal de una manera muy directa, representando los valores
     de una señal en intervalos de tiempo sucesivos como elementos consecutivos
     de una corriente. Por ejemplo, podemos implementar un @e(integrador) o
     @e(verano) que, para un flujo de entrada @m(x = (xᵢ)), un valor inicial
     @m(C), y un pequeño incremento @m(dt), acumule la suma

#      ..example >
#                 i
#        Sᵢ = C + ∑ xⱼdt
#                j=1
#      < example..
     ..example >
                i
       Sᵢ = C + ∑ xⱼdt
               j=1
     < example..

#      and returns the stream of values @m[S = (Sᵢ)]. The following @c(integral)
#      procedure is reminiscent of the @"(implicit style) definition of the stream of
#      integers (section @l(#3.5.2)):
     Y devuelve el flujo de valores @m(S = (Sᵢ)). El siguiente procedimiento @c(integral) es una reminiscencia de la definición de @"(estilo implícita)
     del flujo de enteros (seccion @l(#3.5.2)):

#      ..src > scheme
#        (define (integral integrand initial-value dt)
#          (define int
#            (cons-stream
#             initial-value
#             (add-streams (scale-stream integrand dt)
#                          int)))
#          int)
#      < src..
     ..src > scheme
       (define (integral integrand initial-value dt)
         (define int
           (cons-stream
            initial-value
            (add-streams (scale-stream integrand dt)
                         int)))
         int)
     < src..

#      @l(#Figure 3.32) is a picture of a signal-processing system that corresponds
#      to the @c(integral) procedure. The input stream is scaled by @m(dt) and passed
#      through an adder, whose output is passed back through the same adder.  The
#      self-reference in the definition of @c(int) is reflected in the figure by the
#      feedback loop that connects the output of the adder to one of the inputs.
     @l(#Figura 3.32) es una imagen de un sistema de
     procesamiento de señales que corresponde al procedimiento @c(integral). El
     flujo de entrada es escalado por @m(dt) y pasado a través de un sumador,
     cuya salida se pasa de nuevo a través del mismo sumador. La auto-referencia
     en la definición de @c(int) se refleja en la figura por el bucle de
     realimentación que conecta la salida del sumador a una de las entradas.

#      ..figure > @t(Figure 3.32) The @c(integral) procedure viewed as a
#        signal-processing system.
     ..figure > @t(Figura 3.32) El procedimiento @c(integral) visto como un
       sistema de procesamiento de señales.

#        ..art >
#                                       initial-value
#                                            │
#                 ╭───────────╮              │   │\__
#          input  │           │      │\__    ╰──▶│   \_  integral
#          ──────▶│ scale: dt ├─────▶│   \_      │cons_>──●───────▶
#                 │           │      │ add_>────▶│ __/    │
#                 ╰───────────╯  ╭──▶│ __/       │/       │
#                                │   │/                   │
#                                │                        │
#                                ╰────────────────────────╯
#        < art..
       ..art >
                                      initial-value
                                           │
                ╭───────────╮              │   │\__
         input  │           │      │\__    ╰──▶│   \_  integral
         ──────▶│ scale: dt ├─────▶│   \_      │cons_>──●───────▶
                │           │      │ add_>────▶│ __/    │
                ╰───────────╯  ╭──▶│ __/       │/       │
                               │   │/                   │
                               │                        │
                               ╰────────────────────────╯
       < art..

# @    ..img > img/chap3/Fig3.32a.std.svg
@    ..img > img/chap3/Fig3.32a.std.svg

#      :: @t(Exercise 3.73) :: We can model electrical circuits using streams to
#         represent the values of currents or voltages at a sequence of times. For
#         instance, suppose we have an @e(RC circuit) consisting of a resistor of
#         resistance @m(R) and a capacitor of capacitance @m(C) in series.  The
#         voltage response @m(v) of the circuit to an injected current @m(i) is
#         determined by the formula in @l(#Figure 3.33), whose structure is shown by
#         the accompanying signal-flow diagram.
     :: @t(Ejercicio 3.73) :: Podemos modelar circuitos eléctricos usando
        corrientes para representar los valores de corrientes o voltajes en una
        secuencia de veces. Por ejemplo, supongamos que tenemos un @e(circuito
        RC que) consiste en una resistencia de resistencia @m(R) y un
        condensador de capacitancia @m(C) en serie. La respuesta de voltaje
        @m(v) del circuito a una corriente inyectada @m(i) se determina por la
        fórmula de la @l(#Figura 3.33), cuya estructura se muestra
        mediante el diagrama de flujo de señal acompañante.

#         ..figure > @t(Figure 3.33) An RC circuit and the associated signal-flow diagram.
        ..figure > @t(Figura 3.33) Un circuito RC y el diagrama de flujo de
          señal asociado.

#           ..art >
#                   +        v        -
#
#                 ──▶────'\/\/\,─────┤ ├────                  ╭t
#                   i                           v = v₀ + (1/C)│ i dt +  R i
#                           R         C                       ╯0
#
#                     ╭────────────╮
#                     │            │
#                 ╭──▶│ scale:  R  ├───────────────────────╮
#                 │   │            │                       │   |\_
#                 │   ╰────────────╯                       ╰──▶|  \_
#                 │                                            |    \  v
#                 │   ╭────────────╮        ╭──────────╮       | add >───▶
#               i │   │            │        │          │       |   _/
#             ────●──▶│ scale: i/C ├───────▶│ integral ├──────▶| _/
#                     │            │        │          │       |/
#                     ╰────────────╯        ╰──────────╯
#                                                ▲
#                                                │
#                                                v₀
#           < art..
          ..art >
                  +        v        -

                ──▶────'\/\/\,─────┤ ├────                  ╭t
                  i                           v = v₀ + (1/C)│ i dt +  R i
                          R         C                       ╯0

                    ╭────────────╮
                    │            │
                ╭──▶│ scale:  R  ├───────────────────────╮
                │   │            │                       │   |\_
                │   ╰────────────╯                       ╰──▶|  \_
                │                                            |    \  v
                │   ╭────────────╮        ╭──────────╮       | add >───▶
              i │   │            │        │          │       |   _/
            ────●──▶│ scale: i/C ├───────▶│ integral ├──────▶| _/
                    │            │        │          │       |/
                    ╰────────────╯        ╰──────────╯
                                               ▲
                                               │
                                               v₀
          < art..

# @     ..img > img/chap3/Fig3.33a.std.svg
@     ..img > img/chap3/Fig3.33a.std.svg

#         Write a procedure @c(RC) that models this circuit. @c(RC) should take as
#         inputs the values of @m(R), @m(C), and @m(dt) and should return a procedure
#         that takes as inputs a stream representing the current @m(i) and an initial
#         value for the capacitor voltage @m(v₀) and produces as output the stream of
#         voltages @m(v). For example, you should be able to use @c(RC) to model an
#         RC circuit with @m(R) = 5 ohms, @m(C) = 1 farad, and a 0.5-second time step
#         by evaluating @c[(define RC1 (RC 5 1 0.5))]. This defines @c(RC1) as a
#         procedure that takes a stream representing the time sequence of currents
#         and an initial capacitor voltage and produces the output stream of
#         voltages.
        Escriba un procedimiento @c(RC) que modela este circuito. @c(RC) Debe
        tomar como entradas los valores de @m(R), @m(C) y @m(dt) y devolver un
        procedimiento que toma como entradas una corriente que representa la
        corriente @m(iy) un valor inicial para la tensión @m(v₀) del condensador
        y produce como salida la corriente de voltajes @m(v). Por ejemplo,
        debería ser capaz de usar @c(RC) para modelar un circuito RC con @m(R) =
        5 ohmios, @m(C) = 1 farad y un paso de tiempo de 0,5 segundos evaluando
        @c[(define RC1 (RC 5 1 0.5))]. Esto define @c(RC1) como un procedimiento
        que toma una corriente que representa la secuencia temporal de
        corrientes y una tensión inicial del condensador y produce la corriente
        de salida de voltajes.

#      :: @t(Exercise 3.74) :: Alyssa P. Hacker is designing a system to process
#         signals coming from physical sensors. One important feature she wishes to
#         produce is a signal that describes the @e(zero crossings) of the input
#         signal. That is, the resulting signal should be @m(+1) whenever the input
#         signal changes from negative to positive, @m(-1) whenever the input signal
#         changes from positive to negative, and @m(0) otherwise. (Assume that the
#         sign of a @m(0) input is positive.)  For example, a typical input signal
#         with its associated zero-crossing signal would be
     :: @t(Ejercicio 3.74) :: Alyssa P. Hacker está diseñando un sistema para
        procesar señales procedentes de sensores físicos. Una característica
        importante que desea producir es una señal que describe los @e(cruces)
        de @e(cero) de la señal de entrada. Es decir, la señal resultante debe
        ser @m(+1) cuando la señal de entrada cambia de negativo a positivo,
        @m(-1) cuando la señal de entrada cambia de positiva a negativa, y @m(0
        en) caso contrario. (Suponga que el signo de una entrada @m(0) es
        positivo). Por ejemplo, una señal de entrada típica con su señal de
        cruce por cero asociada sería

#         ..src > scheme
#           … 1 2 1.5 1 0.5 -0.1 -2 -3 -2 -0.5 0.2 3 4 …
#           … 0 0  0  0  0   -1   0  0  0   0   1  0 0 …
#         < src..
        ..src > scheme
          … 1 2 1.5 1 0.5 -0.1 -2 -3 -2 -0.5 0.2 3 4 …
          … 0 0  0  0  0   -1   0  0  0   0   1  0 0 …
        < src..

#         In Alyssa's system, the signal from the sensor is represented as a stream
#         @c(sense-data) and the stream @c(zero-crossings) is the corresponding
#         stream of zero crossings. Alyssa first writes a procedure
#         @c(sign-change-detector) that takes two values as arguments and compares
#         the signs of the values to produce an appropriate @m(0), @m(1), or
#         @m(-1). She then constructs her zero-crossing stream as follows:
        En el sistema de Alyssa, la señal del sensor se representa como una
        corriente @c(sense-data) y la corriente @c(zero-crossings) es la
        corriente correspondiente de cruces de cero. Alyssa escribe primero un
        procedimiento @c(sign-change-detector) que toma dos valores como
        argumentos y compara los signos de los valores para producir un @m(0),
        @m(1) o @m(-1) apropiado. A continuación, construye su flujo de cruce
        cero de la siguiente manera:

#         ..src > scheme
#           (define (make-zero-crossings
#                    input-stream last-value)
#             (cons-stream
#              (sign-change-detector
#               (stream-car input-stream)
#               last-value)
#              (make-zero-crossings
#               (stream-cdr input-stream)
#               (stream-car input-stream))))
#
#           (define zero-crossings
#             (make-zero-crossings sense-data 0))
#         < src..
        ..src > scheme
          (define (make-zero-crossings
                   input-stream last-value)
            (cons-stream
             (sign-change-detector
              (stream-car input-stream)
              last-value)
             (make-zero-crossings
              (stream-cdr input-stream)
              (stream-car input-stream))))

          (define zero-crossings
            (make-zero-crossings sense-data 0))
        < src..

#         Alyssa's boss, Eva Lu Ator, walks by and suggests that this program is
#         approximately equivalent to the following one, which uses the generalized
#         version of @c(stream-map) from @l(#Exercise 3.50):
        El jefe de Alyssa, Eva Lu Ator, camina y sugiere que este programa es
        aproximadamente equivalente al siguiente, que usa la versión
        generalizada @c(stream-map) del @l(#Ejercicio 3.50) :

#         ..src > scheme
#           (define zero-crossings
#             (stream-map sign-change-detector
#                         sense-data
#                         ⟨expression⟩))
#         < src..
        ..src > scheme
          (define zero-crossings
            (stream-map sign-change-detector
                        sense-data
                        ⟨expression⟩))
        < src..

#         Complete the program by supplying the indicated @c[(expression)].
        Complete el programa suministrando lo indicado @c[(expression)].

#      :: @t(Exercise 3.75) :: Unfortunately, Alyssa's zero-crossing detector in
#         @l(#Exercise 3.74) proves to be insufficient, because the noisy signal from
#         the sensor leads to spurious zero crossings. Lem E. Tweakit, a hardware
#         specialist, suggests that Alyssa smooth the signal to filter out the noise
#         before extracting the zero crossings. Alyssa takes his advice and decides
#         to extract the zero crossings from the signal constructed by averaging each
#         value of the sense data with the previous value. She explains the problem
#         to her assistant, Louis Reasoner, who attempts to implement the idea,
#         altering Alyssa's program as follows:
     :: @t(Ejercicio 3.75) :: Desafortunadamente, el detector de cruce cero de
     Alyssa en el @l(#Ejercicio 3.74) resulta insuficiente,
     porque la señal ruidosa del sensor conduce a falsos cruces de cero. Lem
     E. Tweakit, un especialista en hardware, sugiere que Alyssa suavizar la
     señal para filtrar el ruido antes de extraer los cruces de cero. Alyssa
     toma su consejo y decide extraer los cruces de cero de la señal construida
     promediando cada valor de los datos de sentido con el valor anterior. Ella
     explica el problema a su asistente, Louis Reasoner, que intenta implementar
     la idea, alterando el programa de Alyssa de la siguiente manera:

#         ..src > scheme
#           (define (make-zero-crossings
#                    input-stream last-value)
#             (let ((avpt
#                    (/ (+ (stream-car input-stream)
#                          last-value)
#                       2)))
#               (cons-stream
#                (sign-change-detector avpt last-value)
#                (make-zero-crossings
#                 (stream-cdr input-stream) avpt))))
#         < src..
        ..src > scheme
          (define (make-zero-crossings
                   input-stream last-value)
            (let ((avpt
                   (/ (+ (stream-car input-stream)
                         last-value)
                      2)))
              (cons-stream
               (sign-change-detector avpt last-value)
               (make-zero-crossings
                (stream-cdr input-stream) avpt))))
        < src..

#         This does not correctly implement Alyssa's plan. Find the bug that Louis
#         has installed and fix it without changing the structure of the
#         program. (Hint: You will need to increase the number of arguments to
#         @c(make-zero-crossings).)
        Esto no implementa correctamente el plan de Alyssa. Encuentra el error
        que Louis ha instalado y arreglarlo sin cambiar la estructura del
        programa. (Sugerencia: necesitará aumentar el número de argumentos a
        @c(make-zero-crossings).)

#      :: @t(Exercise 3.76) :: Eva Lu Ator has a criticism of Louis's approach in
#         @l(#Exercise 3.75). The program he wrote is not modular, because it
#         intermixes the operation of smoothing with the zero-crossing
#         extraction. For example, the extractor should not have to be changed if
#         Alyssa finds a better way to condition her input signal. Help Louis by
#         writing a procedure @c(smooth) that takes a stream as input and produces a
#         stream in which each element is the average of two successive input stream
#         elements.  Then use @c(smooth) as a component to implement the
#         zero-crossing detector in a more modular style.
     :: @t(Ejercicio 3.76) :: Eva Lu Ator tiene una crítica del enfoque de Louis
        en el @l(#Ejercicio 3.75). El programa que escribió no es
        modular, ya que entremezcla la operación de suavizado con la extracción
        de cruce cero. Por ejemplo, el extractor no debe ser cambiado si Alyssa
        encuentra una mejor forma de acondicionar su señal de entrada. Ayuda a
        Louis escribiendo un procedimiento @c(smooth) que toma un flujo como
        entrada y produce un flujo en el que cada elemento es el promedio de dos
        elementos de flujo de entrada sucesivos. A continuación, utilice
        @c(smooth) como un componente para implementar el detector de cruce cero
        en un estilo más modular.

# *** 3.5.4 <> Streams and Delayed Evaluation
*** 3.5.4 <> Flujos y Evaluación Retrasada

#     The @c(integral) procedure at the end of the preceding section shows how we
#     can use streams to model signal-processing systems that contain feedback
#     loops.  The feedback loop for the adder shown in @l(#Figure 3.32) is modeled
#     by the fact that @c(integral)'s internal stream @c(int) is defined in terms of
#     itself:
    El procedimiento @c(integral) al final de la sección anterior muestra cómo
    podemos utilizar los flujos para modelar sistemas de procesamiento de
    señales que contienen bucles de retroalimentación. El bucle de
    retroalimentación para el sumador mostrado en la @l(#Figura
    3.32) es modelado por el hecho de que @c(integral) el flujo interno @c(int)
    se define en términos de sí mismo:

#     ..src > scheme
#       (define int
#         (cons-stream
#          initial-value
#          (add-streams
#           (scale-stream integrand dt) int)))
#     < src..
    ..src > scheme
      (define int
        (cons-stream
         initial-value
         (add-streams
          (scale-stream integrand dt) int)))
    < src..

#     The interpreter's ability to deal with such an implicit definition depends on
#     the @c(delay) that is incorporated into @c(cons-stream). Without this
#     @c(delay), the interpreter could not construct @c(int) before evaluating both
#     arguments to @c(cons-stream), which would require that @c(int) already be
#     defined. In general, @c(delay) is crucial for using streams to model
#     signal-processing systems that contain loops. Without @c(delay), our models
#     would have to be formulated so that the inputs to any signal-processing
#     component would be fully evaluated before the output could be produced. This
#     would outlaw loops.
    La capacidad del intérprete para manejar tal definición implícita depende de
    lo @c(delay) que se incorpora en @c(cons-stream). Sin esto @c(delay), el
    intérprete no pudo construir @c(int) antes de evaluar ambos argumentos
    @c(cons-stream), lo que requeriría que @c(int) ya estuviera definido. En
    general, @c(delay) es crucial para usar los flujos para modelar sistemas de
    procesamiento de señales que contienen bucles. Sin @c(delay) embargo,
    nuestros modelos tendrían que ser formulados para que las entradas de
    cualquier componente de procesamiento de señales fueran evaluadas
    completamente antes de que se pudiera producir la salida. Esto haría
    ilegales los bucles.

#     Unfortunately, stream models of systems with loops may require uses of
#     @c(delay) beyond the @"(hidden) @c(delay) supplied by @c(cons-stream).  For
#     instance, @l(#Figure 3.34) shows a signal-processing system for solving the
#     differential equation @m[dy / dt = ƒ(y)] where @m(ƒ) is a given function. The
#     figure shows a mapping component, which applies @m(ƒ) to its input signal,
#     linked in a feedback loop to an integrator in a manner very similar to that of
#     the analog computer circuits that are actually used to solve such equations.
    Desafortunadamente, los modelos de flujo de sistemas con bucles pueden
    requerir usos de @c(delay) más allá de lo @"(oculto) @c(delay) proporcionado
    por @c(cons-stream). Por ejemplo, la @l(#Figura 3.34) muestra
    un sistema de procesamiento de señales para resolver la ecuación diferencial
    @m(dy / dt = f (y)) donde @m(ƒ) es una función dada. La figura muestra un
    componente de mapeo, que se aplica @m(ƒ) a su señal de entrada, enlazado en
    un bucle de realimentación a un integrador de una manera muy similar a la de
    los circuitos de computadora analógicos que se utilizan realmente para
    resolver dichas ecuaciones.

#     ..figure > @t(Figure 3.34) An @"(analog computer circuit) that solves the
#       equation @m[dy / dt = ƒ(y)].
    ..figure > @t(Figura 3.34) Un @"(circuito de computadora analógico) que
      resuelve la ecuación @m(dy / dt = f (y)).

#       ..art >
#                                     y₀
#                                      │
#                                      ▼
#             ╭──────────╮  dy   ╭──────────╮     y
#         ╭──▶│  map: f  ├──────▶│ integral ├──●─────▶
#         │   ╰──────────╯       ╰──────────╯  │
#         │                                    │
#         ╰────────────────────────────────────╯
#       < art..
      ..art >
                                    y₀
                                     │
                                     ▼
            ╭──────────╮  dy   ╭──────────╮     y
        ╭──▶│  map: f  ├──────▶│ integral ├──●─────▶
        │   ╰──────────╯       ╰──────────╯  │
        │                                    │
        ╰────────────────────────────────────╯
      < art..

# @   ..img > img/chap3/Fig3.34.std.svg
@   ..img > img/chap3/Fig3.34.std.svg

#     Assuming we are given an initial value @m(y₀) for @m(y), we could try to model
#     this system using the procedure
    Suponiendo que se nos da un valor inicial @m(y₀) para @m(y), podríamos
    tratar de modelar este sistema usando el procedimiento

#     ..src > scheme
#       (define (solve f y0 dt)
#         (define y (integral dy y0 dt))
#         (define dy (stream-map f y))
#         y)
#     < src..
    ..src > scheme
      (define (solve f y0 dt)
        (define y (integral dy y0 dt))
        (define dy (stream-map f y))
        y)
    < src..

#     This procedure does not work, because in the first line of @c(solve) the call
#     to @c(integral) requires that the input @c(dy) be defined, which does not
#     happen until the second line of @c(solve).
    Este procedimiento no funciona, ya que en la primera línea de @c(solve) la
    llamada a se @c(integral) requiere que la entrada @c(dy) se defina, lo que
    no ocurre hasta la segunda línea de @c(solve).

#     On the other hand, the intent of our definition does make sense, because we
#     can, in principle, begin to generate the @c(y) stream without knowing
#     @c(dy). Indeed, @c(integral) and many other stream operations have properties
#     similar to those of @c(cons-stream), in that we can generate part of the
#     answer given only partial information about the arguments. For @c(integral),
#     the first element of the output stream is the specified
#     @c(initial-value). Thus, we can generate the first element of the output
#     stream without evaluating the integrand @c(dy). Once we know the first element
#     of @c(y), the @c(stream-map) in the second line of @c(solve) can begin working
#     to generate the first element of @c(dy), which will produce the next element
#     of @c(y), and so on.
    Por otro lado, la intención de nuestra definición tiene sentido, porque en
    principio podemos comenzar a generar el @c(y) flujo sin saberlo @c(dy). De
    hecho, @c(integral) y muchas otras operaciones de flujo tienen propiedades
    similares a las de @c(cons-stream), en que podemos generar parte de la
    respuesta dada sólo información parcial sobre los argumentos. Para
    @c(integral), el primer elemento del flujo de salida es el especificado
    @c(initial-value). Así, podemos generar el primer elemento del flujo de
    salida sin evaluar el integrando @c(dy). Una vez que conozcamos el primer
    elemento de @c(y), el @c(stream-map) en la segunda línea de @c(solve) puede
    comenzar a trabajar para generar el primer elemento de @c(dy), que producirá
    el siguiente elemento de @c(y), y así sucesivamente.

#     To take advantage of this idea, we will redefine @c(integral) to expect the
#     integrand stream to be a @e(delayed argument). @c(Integral) will @c(force) the
#     integrand to be evaluated only when it is required to generate more than the
#     first element of the output stream:
    Para aprovechar esta idea, vamos a redefinir @c(integral) a esperar que el
    flujo de integrandos sea un @e(argumento retrasado). @c(Integral) será
    @c(force) el integrando a ser evaluado sólo cuando se requiere para generar
    más que el primer elemento de la secuencia de salida:

#     ..src > scheme
#       (define (integral
#                delayed-integrand initial-value dt)
#         (define int
#           (cons-stream
#            initial-value
#            (let ((integrand
#                   (force delayed-integrand)))
#              (add-streams
#               (scale-stream integrand dt)
#               int))))
#         int)
#     < src..
    ..src > scheme
      (define (integral
               delayed-integrand initial-value dt)
        (define int
          (cons-stream
           initial-value
           (let ((integrand
                  (force delayed-integrand)))
             (add-streams
              (scale-stream integrand dt)
              int))))
        int)
    < src..

#     Now we can implement our @c(solve) procedure by delaying the evaluation of
#     @c(dy) in the definition of @c(y):@n(199)
    Ahora podemos implementar nuestro procedimiento @c(solve) retrasando la
    evaluación de @c(dy) en la definición de @c(y):@n(199)

#     ..src > scheme
#       (define (solve f y0 dt)
#         (define y (integral (delay dy) y0 dt))
#         (define dy (stream-map f y))
#         y)
#     < src..
    ..src > scheme
      (define (solve f y0 dt)
        (define y (integral (delay dy) y0 dt))
        (define dy (stream-map f y))
        y)
    < src..

#     In general, every caller of @c(integral) must now @c(delay) the integrand
#     argument. We can demonstrate that the @c(solve) procedure works by
#     approximating @m(e ≈ 2.718) by computing the value at @m(y = 1) of the
#     solution to the differential equation @m(dy / dt = y) with initial condition
#     @m[y(0) = 1]:
    En general, todo llamador de @c(integral) debe ahora @c(delay) el argumento
    integrando. Podemos demostrar que el procedimiento @c(solve) funciona
    aproximando @m(e ≈ 2.718) calculando el valor en @m(y = 1) de la solución a
    la ecuación diferencial @m(dy / dt = y) con condición inicial @m(y (0)
    = 1) :

#     ..srci > scheme
#       > (stream-ref
#       ^  (solve (lambda (y) y) 1 0.001) 1000)
#       2.716924
#     < srci..
    ..srci > scheme
      > (stream-ref
      ^  (solve (lambda (y) y) 1 0.001) 1000)
      2.716924
    < srci..

#     :: @t(Exercise 3.77) :: The @c(integral) procedure used above was analogous to
#        the @"(implicit) definition of the infinite stream of integers in
#        @l(#3.5.2). Alternatively, we can give a definition of @c(integral) that is
#        more like @c(integers-starting-from) (also in section @l(#3.5.2)):
    :: @t(Ejercicio 3.77) :: El procedimiento @c(integral) utilizado
       anteriormente es análogo a la definición @"(implícita) de la corriente
       infinita de números enteros en la seccion @l(#3.5.2). Alternativamente,
       podemos dar una definición de @c(integral) que es más parecido
       @c(integers-starting-from)(también en la seccion @l(#3.5.2)):

#        ..src > scheme
#          (define (integral
#                   integrand initial-value dt)
#            (cons-stream
#             initial-value
#             (if (stream-null? integrand)
#                 the-empty-stream
#                 (integral
#                  (stream-cdr integrand)
#                  (+ (* dt (stream-car integrand))
#                     initial-value)
#                  dt))))
#        < src..
       ..src > scheme
         (define (integral
                  integrand initial-value dt)
           (cons-stream
            initial-value
            (if (stream-null? integrand)
                the-empty-stream
                (integral
                 (stream-cdr integrand)
                 (+ (* dt (stream-car integrand))
                    initial-value)
                 dt))))
       < src..

#        When used in systems with loops, this procedure has the same problem as
#        does our original version of @c(integral). Modify the procedure so that it
#        expects the @c(integrand) as a delayed argument and hence can be used in
#        the @c(solve) procedure shown above.
       Cuando se utiliza en sistemas con bucles, este procedimiento tiene el
       mismo problema que nuestra versión original de @c(integral). Modifique el
       procedimiento de modo que espera el @c(integrand) como un argumento
       retrasado y por lo tanto se puede utilizar en el procedimiento @c(solve)
       mostrado anteriormente.

#     :: @t(Exercise 3.78) :: Consider the problem of designing a signal-processing
#        system to study the homogeneous second-order linear differential equation
    :: @t(Ejercicio 3.78) :: Consideremos el problema de diseñar un sistema de
       procesamiento de señales para estudiar la ecuación diferencial lineal de
       segundo orden homogénea

#        ..example >
#          d²y     dy
#          --- − a---- −  by  =  0
#          dt²     dt
#        < example..
       ..example >
         d²y     dy
         --- − a---- −  by  =  0
         dt²     dt
       < example..

#        The output stream, modeling @m(y), is generated by a network that contains
#        a loop. This is because the value of @m(d² y / dt²) depends upon the values
#        of @m(y) and @m(dy / dt) and both of these are determined by integrating
#        @m(d² y / dt²). The diagram we would like to encode is shown in @l(#Figure
#        3.35). Write a procedure @c(solve-2nd) that takes as arguments the
#        constants @m(a), @m(b), and @m(dt) and the initial values @m(y₀) and
#        @m(dy₀) for @m(y) and @m(dy / dt) and generates the stream of successive
#        values of @m(y).
       El flujo de salida, modelado @m(y), es generado por una red que contiene
       un bucle. Esto es porque el valor de @m(d² y / dt²) depende de los
       valores de @m(y) y @m(dy / dt) y ambos de estos se determinó mediante la
       integración de @m(d² y / dt²). El diagrama que queremos codificar se
       muestra en la @l(#Figura 3.35). Escribir un procedimiento
       @c(solve-2nd) que toma como argumentos las constantes de @m(a), @m(b), y
       @m(dt) y los valores iniciales @m(y₀) y @m(dy₀) para @m(y) y @m(dt dy /)
       y genera el flujo de valores sucesivos de @m(y).

#     ..figure > @t(Figure 3.35) Signal-flow diagram for the solution to a
#       second-order linear differential equation.
    ..figure > @t(Figura 3.35) Diagrama de flujo de señal para la solución a una
      ecuación diferencial lineal de segundo orden.

#       ..art >
#                        dy₀                   y₀
#                         │                    │
#                         ▼                    ▼
#            ddy     ╭──────────╮    dy   ╭──────────╮    y
#         ╭─────────▶│ integral ├─────●──▶│ integral ├──●───▶
#         │          ╰──────────╯     │   ╰──────────╯  │
#         │                           │                 │
#         │            ╭──────────╮   │                 │
#         │     __/│◀──┤ scale: a │◀──╯                 │
#         │   _/   │   ╰──────────╯                     │
#         ╰──<_add │                                    │
#              \__ │   ╭──────────╮                     │
#                 \│◀──┤ scale: b │◀────────────────────+
#                      ╰──────────╯
#       < art..
      ..art >
                       dy₀                   y₀
                        │                    │
                        ▼                    ▼
           ddy     ╭──────────╮    dy   ╭──────────╮    y
        ╭─────────▶│ integral ├─────●──▶│ integral ├──●───▶
        │          ╰──────────╯     │   ╰──────────╯  │
        │                           │                 │
        │            ╭──────────╮   │                 │
        │     __/│◀──┤ scale: a │◀──╯                 │
        │   _/   │   ╰──────────╯                     │
        ╰──<_add │                                    │
             \__ │   ╭──────────╮                     │
                \│◀──┤ scale: b │◀────────────────────+
                     ╰──────────╯
      < art..

# @   ..img > img/chap3/Fig3.35b.std.svg
@   ..img > img/chap3/Fig3.35b.std.svg

#     :: @t(Exercise 3.79) :: Generalize the @c(solve-2nd) procedure of @l(#Exercise
#        3.78) so that it can be used to solve general second-order differential
#        equations @m[d²y / dt² = ƒ(dy / dt, y)].
    :: @t(Ejercicio 3.79) :: Generalizar el procedimiento @c(solve-2nd) del
       @l(#Ejercicio 3.78) para que pueda usarse para resolver
       ecuaciones diferenciales generales de segundo orden @m(d²y / dt² = f (dy
       / dt, y)).

#     ..figure > @t(Figure 3.36) A series RLC circuit.
    ..figure > @t(Figura 3.36) Un circuito RLC en serie.

#       ..art >
#                      +  v_R  ─
#                 i_R
#              ╭───▶────'\/\/\,────────╮
#              │                       │  i_L
#          +   │           R           ▼
#              ▼                       │
#              │  i_C                  │_   +
#         v_C  ┴                        _)
#              ┬  C                     _)  v_L
#              │                        _)
#          −   │                       │    −
#              ╰───────────────────────╯
#       < art..
      ..art >
                     +  v_R  ─
                i_R
             ╭───▶────'\/\/\,────────╮
             │                       │  i_L
         +   │           R           ▼
             ▼                       │
             │  i_C                  │_   +
        v_C  ┴                        _)
             ┬  C                     _)  v_L
             │                        _)
         −   │                       │    −
             ╰───────────────────────╯
      < art..

# @   ..img > img/chap3/Fig3.36.std.svg
@   ..img > img/chap3/Fig3.36.std.svg

#     :: @t(Exercise 3.80) :: A @e(series RLC circuit) consists of a resistor, a
#        capacitor, and an inductor connected in series, as shown in @l(#Figure
#        3.36). If @m(R), @m(L), and @m(C) are the resistance, inductance, and
#        capacitance, then the relations between voltage @m[(v)] and current @m[(i)]
#        for the three components are described by the equations
    :: @t(Ejercicio 3.80) :: Un @e(circuito RLC serie) consiste en una
    resistencia, un condensador y un inductor conectados en serie, como se
    muestra en la @l(#Figura 3.36). Si @m(R), @m(L) y @m(C) son la
    resistencia, la inductancia y la capacitancia, entonces las relaciones entre
    la tensión @m[(v)] y la corriente @m[(i)] para los tres componentes se
    describen mediante las ecuaciones

#        ..example >
#          v_R = i_R R
#
#                   d i_L
#          v_L = L -------
#                    d t
#
#                   d v_C
#          i_C = C -------
#                    d t
#        < example..
       ..example >
         v_R = i_R R

                  d i_L
         v_L = L -------
                   d t

                  d v_C
         i_C = C -------
                   d t
       < example..

#        and the circuit connections dictate the relations
       Y las conexiones del circuito dictan las relaciones

#        ..example >
#          i_R = i_L = −i_C
#
#          v_C = v_L + v_R
#        < example..
       ..example >
         i_R = i_L = −i_C

         v_C = v_L + v_R
       < example..

#        Combining these equations shows that the state of the circuit (summarized
#        by @M[v_C], the voltage across the capacitor, and @M[i_L], the current in
#        the inductor) is described by the pair of differential equations
       La combinación de estas ecuaciones muestra que el estado del circuito
       (resumido por \ (v_C \), la tensión a través del condensador, y \ (i_L
       \), la corriente en el inductor) se describe por el par de ecuaciones
       diferenciales

#        ..example >
#          d v_C        i_L
#          -----  =  −  ---
#           d t          C
#
#          d i_L      1           R
#          -----  =  --- v_C  −  --- i_L
#           d t       L           L
#        < example..
       ..example >
         d v_C        i_L
         -----  =  −  ---
          d t          C

         d i_L      1           R
         -----  =  --- v_C  −  --- i_L
          d t       L           L
       < example..

#        The signal-flow diagram representing this system of differential equations
#        is shown in @l(#Figure 3.37).
       El diagrama de flujo de señal que representa este sistema de ecuaciones
       diferenciales se muestra en la @l(#Figura 3.37).

#     ..figure > @t(Figure 3.37) A signal-flow diagram for the solution to a series
#       RLC circuit.
    ..figure > @t(Figura 3.37) Diagrama de flujo de señal para la solución a un
      circuito RLC en serie.

#       ..art >
#                          ╭─────────────╮
#         ╭────────────────┤  scale: l/L │◀──╮
#         │                ╰─────────────╯   │
#         │                                  │
#         │                ╭─────────────╮   │  v_C
#         │       dv_C ╭──▶│   integral  ├───●──────▶
#         │            │   ╰─────────────╯
#         │            │        ▲
#         │            │        ╰── v_(C_0)
#         │            │
#         │            │   ╭─────────────╮
#         │            ╰───┤ scale: −l/C │◀──╮
#         │                ╰─────────────╯   │
#         │  │\__                            │
#         ╰─▶│   \_  di_L  ╭─────────────╮   │  i_L
#            │ add_>──────▶│   integral  ├───●──────▶
#         ╭─▶│ __/         ╰─────────────╯   │
#         │  │/                 ▲            │
#         │                     ╰── i_(L_0)  │
#         │                                  │
#         │                ╭─────────────╮   │
#         ╰────────────────┤ scale: −R/L │◀──╯
#                          ╰─────────────╯
#       < art..
      ..art >
                         ╭─────────────╮
        ╭────────────────┤  scale: l/L │◀──╮
        │                ╰─────────────╯   │
        │                                  │
        │                ╭─────────────╮   │  v_C
        │       dv_C ╭──▶│   integral  ├───●──────▶
        │            │   ╰─────────────╯
        │            │        ▲
        │            │        ╰── v_(C_0)
        │            │
        │            │   ╭─────────────╮
        │            ╰───┤ scale: −l/C │◀──╮
        │                ╰─────────────╯   │
        │  │\__                            │
        ╰─▶│   \_  di_L  ╭─────────────╮   │  i_L
           │ add_>──────▶│   integral  ├───●──────▶
        ╭─▶│ __/         ╰─────────────╯   │
        │  │/                 ▲            │
        │                     ╰── i_(L_0)  │
        │                                  │
        │                ╭─────────────╮   │
        ╰────────────────┤ scale: −R/L │◀──╯
                         ╰─────────────╯
      < art..

# @   ..img > img/chap3/Fig3.37.std.svg
@   ..img > img/chap3/Fig3.37.std.svg

#     ..tab >
   ..tab >
#       Write a procedure @c(RLC) that takes as arguments the parameters @m(R),
#       @m(L), and @m(C) of the circuit and the time increment @m(dt). In a manner
#       similar to that of the @c(RC) procedure of @l(#Exercise 3.73), @c(RLC)
#       should produce a procedure that takes the initial values of the state
#       variables, @M[v_{C_0}] and @M[i_{L_0}], and produces a pair (using @c(cons))
#       of the streams of states @M[v_C] and @M[i_L]. Using @c(RLC), generate the
#       pair of streams that models the behavior of a series RLC circuit with @m(R)
#       = 1 ohm, @m(C) = 0.2 farad, @m(L) = 1 henry, @m(dt) = 0.1 second, and
#       initial values @M[i_{L_0}] = 0 amps and @M[v_{C_0}] = 10 volts.
      Escriba un procedimiento @c(RLC) que tome como argumentos los parámetros
      @m(R), @m(L) y @m(C) del circuito y el incremento de tiempo @m(dt). De
      manera similar a la del procedimiento @c(RC) del
      @l(#Ejercicio 3.73), @c(RLC) debería producirse un
      procedimiento que tome los valores iniciales de las variables de estado, \
      (v_ {C_0} \) y \ (i_ {L_0} \), y produce un par Utilizando @c(cons)) de
      los flujos de estados \ (v_C \) y \ (i_L \). Usando @c(RLC), generamos el
      par de corrientes que modela el comportamiento de un circuito RLC de serie
      con @m(R) = 1 ohmio, @m(C) = 0,2 farad, @m(L) = 1 henry, @m(dt) = 0,1
      segundo y valores iniciales \ (i_ {L_0} \) = 0 Amperios y \ (v_ {C_0} \) =
      10 voltios.

# **** Normal-order evaluation
**** Evaluación de orden normal

#      The examples in this section illustrate how the explicit use of @c(delay) and
#      @c(force) provides great programming flexibility, but the same examples also
#      show how this can make our programs more complex. Our new @c(integral)
#      procedure, for instance, gives us the power to model systems with loops, but
#      we must now remember that @c(integral) should be called with a delayed
#      integrand, and every procedure that uses @c(integral) must be aware of this.
#      In effect, we have created two classes of procedures: ordinary procedures and
#      procedures that take delayed arguments. In general, creating separate classes
#      of procedures forces us to create separate classes of higher-order procedures
#      as well.@n(200)
     Los ejemplos en esta sección ilustran cómo el uso explícito de @c(delay) y
     @c(force) proporciona gran flexibilidad de programación, pero los mismos
     ejemplos también muestran cómo esto puede hacer nuestros programas más
     complejos. Nuestro nuevo procedimiento @c(integral), por ejemplo, nos da el
     poder de modelar sistemas con bucles, pero ahora debemos recordar que se
     @c(integral) debe llamar con un integrando retrasado, y cada procedimiento
     que usa @c(integral) debe ser consciente de esto. En efecto, hemos creado
     dos clases de procedimientos: procedimientos ordinarios y procedimientos
     que toman argumentos demorados. En general, crear clases separadas de
     procedimientos nos obliga a crear clases separadas de procedimientos de
     orden superior también.@n(200)

#      One way to avoid the need for two different classes of procedures is to make
#      all procedures take delayed arguments. We could adopt a model of evaluation in
#      which all arguments to procedures are automatically delayed and arguments are
#      forced only when they are actually needed (for example, when they are required
#      by a primitive operation). This would transform our language to use
#      normal-order evaluation, which we first described when we introduced the
#      substitution model for evaluation in section @l(#1.1.5). Converting to normal-order
#      evaluation provides a uniform and elegant way to simplify the use of delayed
#      evaluation, and this would be a natural strategy to adopt if we were concerned
#      only with stream processing. in section @l(#4.2), after we have studied the evaluator,
#      we will see how to transform our language in just this way. Unfortunately,
#      including delays in procedure calls wreaks havoc with our ability to design
#      programs that depend on the order of events, such as programs that use
#      assignment, mutate data, or perform input or output. Even the single @c(delay)
#      in @c(cons-stream) can cause great confusion, as illustrated by @l(#Exercise
#      3.51) and @l(#Exercise 3.52). As far as anyone knows, mutability and delayed
#      evaluation do not mix well in programming languages, and devising ways to deal
#      with both of these at once is an active area of research.
     Una manera de evitar la necesidad de dos clases diferentes de
     procedimientos es hacer que todos los procedimientos tomen argumentos
     demorados. Podríamos adoptar un modelo de evaluación en el que todos los
     argumentos a los procedimientos se retrasan automáticamente y los
     argumentos se obligan sólo cuando son realmente necesarios (por ejemplo,
     cuando son requeridos por una operación primitiva). Esto transformaría
     nuestro lenguaje para utilizar la evaluación de orden normal, que
     describimos por primera vez cuando introdujimos el modelo de sustitución
     para la evaluación en la seccion @l(#1.1.5). La conversión a la evaluación de
     orden normal proporciona una manera uniforme y elegante de simplificar el
     uso de la evaluación retardada, y esta sería una estrategia natural para
     adoptar si sólo nos interesara el procesamiento de la corriente. En
     @l(#4.2), después de haber estudiado al evaluador, Veremos cómo
     transformar nuestra lengua de esta manera. Desafortunadamente, los retrasos
     en las llamadas a procedimientos causan estragos en nuestra capacidad de
     diseñar programas que dependen del orden de los eventos, como programas que
     usan asignaciones, muten datos o realizan entradas o salidas. @c(delay)
     Incluso el único en @c(cons-stream) puede causar gran confusión, como se
     ilustra en el @l(#Ejercicio 3.51) y el
     @l(#Ejercicio 3.52). Por lo que se sabe, la mutabilidad y la
     evaluación tardía no se mezclan bien en los lenguajes de programación, e
     idear maneras de lidiar con ambos de una vez es un área activa de
     investigación. Incluso el único en puede causar gran confusión, como se
     ilustra en el @l(#Ejercicio 3.51) y el
     @l(#Ejercicio 3.52). Por lo que se sabe, la mutabilidad y la
     evaluación tardía no se mezclan bien en los lenguajes de programación, e
     idear maneras de lidiar con ambos de una vez es un área activa de
     investigación. Incluso el único en puede causar gran confusión, como se
     ilustra en el @l(#Ejercicio 3.51) y el
     @l(#Ejercicio 3.52). Por lo que se sabe, la mutabilidad y la
     evaluación tardía no se mezclan bien en los lenguajes de programación, e
     idear maneras de lidiar con ambos de una vez es un área activa de
     investigación.

# *** 3.5.5 <> Modularity of Functional Programs and Modularity of Objects
*** 3.5.5 <> Modularidad de los Programas Funcionales y Modularidad de los Objetos

#     As we saw in section @l(#3.1.2), one of the major benefits of introducing assignment
#     is that we can increase the modularity of our systems by encapsulating, or
#     @"(hiding,) parts of the state of a large system within local
#     variables. Stream models can provide an equivalent modularity without the use
#     of assignment. As an illustration, we can reimplement the Monte Carlo
#     estimation of @m(π), which we examined in section @l(#3.1.2), from a stream-processing
#     point of view.
    Como vimos en la seccion @l(#3.1.2), uno de los principales beneficios de la
    introducción de asignación es que podemos aumentar la modularidad de
    nuestros sistemas encapsulando u @"(ocultando) partes del estado de un
    sistema grande dentro de variables locales. Los modelos de flujo pueden
    proporcionar una modularidad equivalente sin el uso de la asignación. Como
    ilustración, podemos reimplementar la estimación de Monte Carlo de @m(π),
    que examinamos en la seccion @l(#3.1.2), desde el punto de vista del
    procesamiento de la corriente.

#     The key modularity issue was that we wished to hide the internal state of a
#     random-number generator from programs that used random numbers. We began with
#     a procedure @c(rand-update), whose successive values furnished our supply of
#     random numbers, and used this to produce a random-number generator:
    El problema clave de la modularidad era que queríamos ocultar el estado
    interno de un generador de números aleatorios de los programas que usaban
    números aleatorios. Comenzamos con un procedimiento @c(rand-update) cuyos
    valores sucesivos proporcionaron nuestro suministro de números aleatorios y
    lo utilizamos para producir un generador de números aleatorios:

#     ..src > scheme
#       (define rand
#         (let ((x random-init))
#           (lambda ()
#             (set! x (rand-update x))
#             x)))
#     < src..
    ..src > scheme
      (define rand
        (let ((x random-init))
          (lambda ()
            (set! x (rand-update x))
            x)))
    < src..

#     In the stream formulation there is no random-number generator @e(per se), just
#     a stream of random numbers produced by successive calls to @c(rand-update):
    En la formulación de flujo no hay ningún generador de números aleatorios
    @e(per se), sólo una corriente de números aleatorios producidos por llamadas
    sucesivas a @c(rand-update):

#     ..src > scheme
#       (define random-numbers
#         (cons-stream random-init
#                      (stream-map rand-update
#                                  random-numbers)))
#     < src..
    ..src > scheme
      (define random-numbers
        (cons-stream random-init
                     (stream-map rand-update
                                 random-numbers)))
    < src..

#     We use this to construct the stream of outcomes of the Cesàro experiment
#     performed on consecutive pairs in the @c(random-numbers) stream:
    Utilizamos esto para construir la corriente de resultados de los

#     ..src > scheme
#       (define cesaro-stream
#         (map-successive-pairs
#          (lambda (r1 r2) (= (gcd r1 r2) 1))
#          random-numbers))
#
#       (define (map-successive-pairs f s)
#         (cons-stream
#          (f (stream-car s)
#             (stream-car (stream-cdr s)))
#          (map-successive-pairs
#           f (stream-cdr (stream-cdr s)))))
#     < src..
    ..src > scheme
      (define cesaro-stream
        (map-successive-pairs
         (lambda (r1 r2) (= (gcd r1 r2) 1))
         random-numbers))

      (define (map-successive-pairs f s)
        (cons-stream
         (f (stream-car s)
            (stream-car (stream-cdr s)))
         (map-successive-pairs
          f (stream-cdr (stream-cdr s)))))
    < src..

#     The @c(cesaro-stream) is now fed to a @c(monte-carlo) procedure, which
#     produces a stream of estimates of probabilities. The results are then
#     converted into a stream of estimates of @m(π). This version of the program
#     doesn't need a parameter telling how many trials to perform. Better estimates
#     of @m(π) (from performing more experiments) are obtained by looking farther
#     into the @c(pi) stream:
    El sistema @c(cesaro-stream) es ahora alimentado a un procedimiento @c(monte-carlo), que produce una corriente de estimaciones de
    probabilidades. Los resultados se convierten entonces en una corriente de
    estimaciones de @m(π). Esta versión del programa no necesita un parámetro
    que indique cuántos ensayos debe realizar. Mejores estimaciones de @m(π) (de
    realizar más experimentos) se obtienen mirando más lejos en la @c(pi)
    corriente:

#     ..src > scheme
#       (define (monte-carlo experiment-stream
#                            passed
#                            failed)
#         (define (next passed failed)
#           (cons-stream
#            (/ passed (+ passed failed))
#            (monte-carlo
#             (stream-cdr experiment-stream)
#             passed
#             failed)))
#         (if (stream-car experiment-stream)
#             (next (+ passed 1) failed)
#             (next passed (+ failed 1))))
#
#       (define pi
#         (stream-map
#          (lambda (p) (sqrt (/ 6 p)))
#          (monte-carlo cesaro-stream 0 0)))
#     < src..
    ..src > scheme
      (define (monte-carlo experiment-stream
                           passed
                           failed)
        (define (next passed failed)
          (cons-stream
           (/ passed (+ passed failed))
           (monte-carlo
            (stream-cdr experiment-stream)
            passed
            failed)))
        (if (stream-car experiment-stream)
            (next (+ passed 1) failed)
            (next passed (+ failed 1))))

      (define pi
        (stream-map
         (lambda (p) (sqrt (/ 6 p)))
         (monte-carlo cesaro-stream 0 0)))
    < src..

#     There is considerable modularity in this approach, because we still can
#     formulate a general @c(monte-carlo) procedure that can deal with arbitrary
#     experiments. Yet there is no assignment or local state.
    Hay una modularidad considerable en este enfoque, porque todavía podemos
    formular un procedimiento @c(monte-carlo) general que puede tratar con
    experimentos arbitrarios. Sin embargo, no hay asignación o estado local.

#     :: @t(Exercise 3.81) :: @l(#Exercise 3.6) discussed generalizing the
#        random-number generator to allow one to reset the random-number sequence so
#        as to produce repeatable sequences of @"(random) numbers. Produce a stream
#        formulation of this same generator that operates on an input stream of
#        requests to @c(generate) a new random number or to @c(reset) the sequence
#        to a specified value and that produces the desired stream of random
#        numbers. Don't use assignment in your solution.
    :: @t(Ejercicio 3.81) :: @l(#Ejercicio 3.6) discutió la
       generalización del generador de números aleatorios para permitir que uno
       restablezca la secuencia de números @"(aleatorios) para producir
       secuencias repetibles de números @"(aleatorios). Produce una formulación
       de flujo de este mismo generador que opera en un flujo de entrada de
       solicitudes a @c(generate) un nuevo número aleatorio o a @c(reset) la
       secuencia a un valor especificado y que produce el flujo deseado de
       números aleatorios. No utilice la asignación en su solución.

#     :: @t(Exercise 3.82) :: Redo @l(#Exercise 3.5) on Monte Carlo integration in
#        terms of streams. The stream version of @c(estimate-integral) will not have
#        an argument telling how many trials to perform. Instead, it will produce a
#        stream of estimates based on successively more trials.
    :: @t(Ejercicio 3.82) :: Rehacer el @l(#Ejercicio 3.5) sobre
       la integración de Monte Carlo en términos de arroyos. La versión de flujo
       de @c(estimate-integral) no tendrá un argumento que indica cuántos
       ensayos realizar. En su lugar, producirá una corriente de estimaciones
       basadas en ensayos sucesivos.

# **** A functional-programming view of time
**** Una visión de programación funcional del tiempo

#      Let us now return to the issues of objects and state that were raised at the
#      beginning of this chapter and examine them in a new light. We introduced
#      assignment and mutable objects to provide a mechanism for modular construction
#      of programs that model systems with state. We constructed computational
#      objects with local state variables and used assignment to modify these
#      variables. We modeled the temporal behavior of the objects in the world by the
#      temporal behavior of the corresponding computational objects.
     Volvamos ahora a las cuestiones de los objetos y del estado que fueron
     planteadas al comienzo de este capítulo y las examinamos bajo una nueva
     luz. Hemos introducido objetos de asignación y mutable para proporcionar un
     mecanismo para la construcción modular de programas que modelan sistemas
     con estado. Hemos construido objetos computacionales con variables de
     estado locales y la asignación utilizada para modificar estas
     variables. Modelamos el comportamiento temporal de los objetos en el mundo
     por el comportamiento temporal de los objetos computacionales
     correspondientes.

#      Now we have seen that streams provide an alternative way to model objects with
#      local state. We can model a changing quantity, such as the local state of some
#      object, using a stream that represents the time history of successive states.
#      In essence, we represent time explicitly, using streams, so that we decouple
#      time in our simulated world from the sequence of events that take place during
#      evaluation. Indeed, because of the presence of @c(delay) there may be little
#      relation between simulated time in the model and the order of events during
#      the evaluation.
     Ahora hemos visto que los arroyos proporcionan una forma alternativa de
     modelar objetos con estado local. Podemos modelar una cantidad variable,
     como el estado local de algún objeto, usando un flujo que representa la
     historia temporal de estados sucesivos. En esencia, representamos el tiempo
     de forma explícita, usando corrientes, por lo que desacoplamos vez en
     nuestro mundo simulado a partir de la secuencia de eventos que tienen lugar
     durante la evaluación. De hecho, debido a la presencia de @c(delay) que
     puede haber poca relación entre el tiempo simulado en el modelo y el orden
     de los acontecimientos durante la evaluación.

#      In order to contrast these two approaches to modeling, let us reconsider the
#      implementation of a @"(withdrawal processor) that monitors the balance in a
#      bank account. in section @l(#3.1.3) we implemented a simplified version of such a
#      processor:
     Con el fin de contrastar estos dos enfoques de modelado, vamos a
     reconsiderar la implementación de un @"(procesador de retirada) que
     monitorea el saldo en una cuenta bancaria. en la seccion @l(#3.1.3)
     implementamos una versión simplificada de un procesador de este tipo:

#      ..src > scheme
#        (define (make-simplified-withdraw balance)
#          (lambda (amount)
#            (set! balance (- balance amount))
#            balance))
#      < src..
     ..src > scheme
       (define (make-simplified-withdraw balance)
         (lambda (amount)
           (set! balance (- balance amount))
           balance))
     < src..

#      Calls to @c(make-simplified-withdraw) produce computational objects, each with
#      a local state variable @c(balance) that is decremented by successive calls to
#      the object. The object takes an @c(amount) as an argument and returns the new
#      balance. We can imagine the user of a bank account typing a sequence of inputs
#      to such an object and observing the sequence of returned values shown on a
#      display screen.
     Llamadas para @c(make-simplified-withdraw) producir objetos
     computacionales, cada uno con una variable de estado local @c(balance) que
     es decrementada por llamadas sucesivas al objeto. El objeto toma @c(amount)
     como argumento y devuelve el nuevo equilibrio. Podemos imaginar al usuario
     de una cuenta bancaria escribiendo una secuencia de entradas a dicho objeto
     y observando la secuencia de valores mostrados en una pantalla.

#      Alternatively, we can model a withdrawal processor as a procedure that takes
#      as input a balance and a stream of amounts to withdraw and produces the stream
#      of successive balances in the account:
     Alternativamente, podemos modelar un procesador de retiro como un
     procedimiento que toma como entrada un saldo y una corriente de cantidades
     para retirar y produce el flujo de saldos sucesivos en la cuenta:

#      ..src > scheme
#        (define (stream-withdraw balance amount-stream)
#          (cons-stream
#           balance
#           (stream-withdraw
#            (- balance (stream-car amount-stream))
#            (stream-cdr amount-stream))))
#      < src..
     ..src > scheme
       (define (stream-withdraw balance amount-stream)
         (cons-stream
          balance
          (stream-withdraw
           (- balance (stream-car amount-stream))
           (stream-cdr amount-stream))))
     < src..

#      @c(Stream-withdraw) implements a well-defined mathematical function whose
#      output is fully determined by its input. Suppose, however, that the input
#      @c(amount-stream) is the stream of successive values typed by the user and
#      that the resulting stream of balances is displayed. Then, from the perspective
#      of the user who is typing values and watching results, the stream process has
#      the same behavior as the object created by @c(make-simplified-withdraw).
#      However, with the stream version, there is no assignment, no local state
#      variable, and consequently none of the theoretical difficulties that we
#      encountered in section @l(#3.1.3). Yet the system has state!
     @c(Stream-withdraw) Implementa una función matemática bien definida cuya
     salida está totalmente determinada por su entrada. Supongamos, sin embargo,
     que la entrada @c(amount-stream) es el flujo de valores sucesivos tipados
     por el usuario y que se muestra el flujo de saldos resultante. Luego, desde
     la perspectiva del usuario que está escribiendo valores y viendo
     resultados, el proceso de flujo tiene el mismo comportamiento que el objeto
     creado por @c(make-simplified-withdraw). Sin embargo, con la versión de
     flujo, no hay ninguna asignación, ninguna variable de estado local y, en
     consecuencia, ninguna de las dificultades teóricas que encontramos en
     @l(#3.1.3). Sin embargo, el sistema tiene estado!

#      This is really remarkable. Even though @c(stream-withdraw) implements a
#      well-defined mathematical function whose behavior does not change, the user's
#      perception here is one of interacting with a system that has a changing state.
#      One way to resolve this paradox is to realize that it is the user's temporal
#      existence that imposes state on the system. If the user could step back from
#      the interaction and think in terms of streams of balances rather than
#      individual transactions, the system would appear stateless.@n(201)
     Esto es realmente notable. Aunque @c(stream-withdraw) implementa una
     función matemática bien definida cuyo comportamiento no cambia, la
     percepción del usuario aquí es la de interactuar con un sistema que tiene
     un estado cambiante. Una forma de resolver esta paradoja es darse cuenta de
     que es la existencia temporal del usuario la que impone el estado en el
     sistema. Si el usuario pudiera retroceder de la interacción y pensar en
     términos de flujos de saldos en lugar de transacciones individuales, el
     sistema parecería apátrida.@n(201)

#      From the point of view of one part of a complex process, the other parts
#      appear to change with time. They have hidden time-varying local state. If we
#      wish to write programs that model this kind of natural decomposition in our
#      world (as we see it from our viewpoint as a part of that world) with
#      structures in our computer, we make computational objects that are not
#      functional––they must change with time. We model state with local state
#      variables, and we model the changes of state with assignments to those
#      variables. By doing this we make the time of execution of a computation model
#      time in the world that we are part of, and thus we get @"(objects) in our
#      computer.
     Desde el punto de vista de una parte de un proceso complejo, las otras
     partes parecen cambiar con el tiempo. Ellos han ocultado el estado local
     que varía en el tiempo. Si queremos escribir programas que modelen este
     tipo de descomposición natural en nuestro mundo (como lo vemos desde
     nuestro punto de vista como parte de ese mundo) con estructuras en nuestro
     ordenador, hacemos objetos computacionales que no son funcionales - deben
     cambiar con tiempo. Modelamos el estado con variables de estado locales, y
     modelamos los cambios de estado con asignaciones a esas variables. Haciendo
     esto hacemos que el tiempo de ejecución de un modelo de cálculo sea el
     tiempo en el mundo del que formamos parte, y así obtenemos @"(objetos) en
     nuestro ordenador.

#      Modeling with objects is powerful and intuitive, largely because this matches
#      the perception of interacting with a world of which we are part. However, as
#      we've seen repeatedly throughout this chapter, these models raise thorny
#      problems of constraining the order of events and of synchronizing multiple
#      processes. The possibility of avoiding these problems has stimulated the
#      development of @e(functional programming languages), which do not include any
#      provision for assignment or mutable data. In such a language, all procedures
#      implement well-defined mathematical functions of their arguments, whose
#      behavior does not change. The functional approach is extremely attractive for
#      dealing with concurrent systems.@n(202)
     Modelar con objetos es poderoso e intuitivo, en gran parte porque esto
     coincide con la percepción de interactuar con un mundo del que formamos
     parte. Sin embargo, como hemos visto repetidamente a lo largo de este
     capítulo, estos modelos plantean problemas espinosos de restringir el orden
     de los eventos y de sincronizar múltiples procesos. La posibilidad de
     evitar estos problemas ha estimulado el desarrollo de @e(lenguajes de
     programación funcional), que no incluyen ninguna disposición para la
     asignación o mutable de datos. En tal lenguaje, todos los procedimientos
     implementan funciones matemáticas bien definidas de sus argumentos, cuyo
     comportamiento no cambia. El enfoque funcional es extremadamente atractivo
     para tratar con sistemas concurrentes.@n(202)

#      On the other hand, if we look closely, we can see time-related problems
#      creeping into functional models as well. One particularly troublesome area
#      arises when we wish to design interactive systems, especially ones that model
#      interactions between independent entities. For instance, consider once more
#      the implementation of a banking system that permits joint bank accounts. In a
#      conventional system using assignment and objects, we would model the fact that
#      Peter and Paul share an account by having both Peter and Paul send their
#      transaction requests to the same bank-account object, as we saw in
#      @l(#3.1.3). From the stream point of view, where there are no @"(objects)
#      @e(per se), we have already indicated that a bank account can be modeled as a
#      process that operates on a stream of transaction requests to produce a stream
#      of responses. Accordingly, we could model the fact that Peter and Paul have a
#      joint bank account by merging Peter's stream of transaction requests with
#      Paul's stream of requests and feeding the result to the bank-account stream
#      process, as shown in @l(#Figure 3.38).
     Por otro lado, si miramos de cerca, podemos ver problemas relacionados con
     el tiempo que también se adentran en modelos funcionales. Un área
     particularmente problemática surge cuando deseamos diseñar sistemas
     interactivos, especialmente aquellos que modelan interacciones entre
     entidades independientes. Por ejemplo, considerar una vez más la
     implementación de un sistema bancario que permita cuentas bancarias
     conjuntas. En un sistema convencional con asignación y objetos,
     modelaríamos el hecho de que Pedro y Pablo comparten una cuenta al tener a
     Pedro ya Pablo enviar sus solicitudes de transacción al mismo objeto de
     cuenta bancaria, como vimos en la seccion @l(#3.1.3). Desde el punto de vista
     de la corriente, donde no hay @"(objetos ) @e(per se), Ya hemos indicado
     que una cuenta bancaria puede ser modelada como un proceso que opera en un
     flujo de solicitudes de transacción para producir un flujo de
     respuestas. @l(#Figure-3.38<>Por consiguiente, podríamos modelar el hecho
     de que Peter y Paul tienen una cuenta bancaria conjunta fusionando el flujo
     de peticiones de transacciones de Peter con la corriente de solicitudes de
     Paul y alimentando el resultado al proceso de flujo de cuentas bancarias,
     como se muestra en la Figura 3.38).

#      ..figure > @t(Figure 3.38) A joint bank account, modeled by merging two
#        streams of transaction requests.
     ..figure > @t(Figura 3.38) Una cuenta bancaria conjunta, modelada por la
       fusión de dos flujos de solicitudes de transacción.

#        ..art >
#          Peter's requests   ╭─────────╮     ╭─────────╮
#          ──────────────────▶│         │     │         │
#          Paul's requests    │  merge  ├────▶│ bank    ├────▶
#          ──────────────────▶│         │     │ account │
#                             ╰─────────╯     ╰─────────╯
#        < art..
       ..art >
         Peter's requests   ╭─────────╮     ╭─────────╮
         ──────────────────▶│         │     │         │
         Paul's requests    │  merge  ├────▶│ bank    ├────▶
         ──────────────────▶│         │     │ account │
                            ╰─────────╯     ╰─────────╯
       < art..

# @    ..img > img/chap3/Fig3.38a.std.svg
@    ..img > img/chap3/Fig3.38a.std.svg

#      The trouble with this formulation is in the notion of @e(merge). It will not
#      do to merge the two streams by simply taking alternately one request from
#      Peter and one request from Paul. Suppose Paul accesses the account only very
#      rarely. We could hardly force Peter to wait for Paul to access the account
#      before he could issue a second transaction. However such a merge is
#      implemented, it must interleave the two transaction streams in some way that
#      is constrained by @"(real time) as perceived by Peter and Paul, in the sense
#      that, if Peter and Paul meet, they can agree that certain transactions were
#      processed before the meeting, and other transactions were processed after the
#      meeting.@n(203) This is precisely the same constraint that we had to deal with
#      in section @l(#3.4.1), where we found the need to introduce explicit synchronization
#      to ensure a @"(correct) order of events in concurrent processing of objects
#      with state. Thus, in an attempt to support the functional style, the need to
#      merge inputs from different agents reintroduces the same problems that the
#      functional style was meant to eliminate.
     El problema con esta formulación está en la noción de @e(fusión). No hará
     para fusionar las dos corrientes simplemente tomando alternativamente una
     petición de Pedro y una petición de Pablo. Supongamos que Paul accede a la
     cuenta muy rara vez. Apenas podíamos obligar a Peter a esperar a que Paul
     accediera a la cuenta antes de que pudiera emitir una segunda
     transacción. Sin embargo, tal combinación se implementa, debe intercalar
     los dos flujos de transacción de alguna manera que está constreñida por
     @"(el tiempo real) según lo perciben Pedro y Pablo, en el sentido de que si
     Pedro y Pablo se encuentran, pueden convenir que ciertas transacciones
     fueron procesadas antes La reunión, y otras transacciones fueron procesadas
     después de la reunión.@n(203) Esta es precisamente la misma
     restricción con la que hemos tenido que lidiar en la seccion @l(#3.4.1), Donde
     encontramos la necesidad de introducir sincronización explícita para
     asegurar un orden @"(correcto) de eventos en el procesamiento concurrente
     de objetos con estado. Así, en un intento por apoyar el estilo funcional,
     la necesidad de combinar insumos de diferentes agentes reintroduce los
     mismos problemas que el estilo funcional pretendía eliminar.

#      We began this chapter with the goal of building computational models whose
#      structure matches our perception of the real world we are trying to model. We
#      can model the world as a collection of separate, time-bound, interacting
#      objects with state, or we can model the world as a single, timeless, stateless
#      unity. Each view has powerful advantages, but neither view alone is completely
#      satisfactory. A grand unification has yet to emerge.@n(204)
     Comenzamos este capítulo con el objetivo de construir modelos
     computacionales cuya estructura coincida con nuestra percepción del mundo
     real que estamos tratando de modelar. Podemos modelar el mundo como una
     colección de objetos separados, vinculados al tiempo, que interactúan con
     el estado, o podemos modelar el mundo como una unidad única, atemporal,
     apátrida. Cada vista tiene poderosas ventajas, pero ninguna de las dos es
     completamente satisfactoria. Una gran unificación aún no ha
     surgido.@n(204)

# * Chapter 4 <> Metalinguistic Abstraction
* Capitulo 4 <> Abstracción metalingüística

#   ..quote >
  ..quote >
#     … It's in words that the magic is––Abracadabra, Open Sesame, and the
#     rest––but the magic words in one story aren't magical in the next. The real
#     magic is to understand which words work, and when, and for what; the trick
#     is to learn the trick.
    ... Es en palabras que la magia es - Abracadabra, Sesame Abierto, y el
    resto - pero las palabras mágicas en una historia no son mágicas en la
    siguiente. La verdadera magia es entender qué palabras funcionan, cuándo y
    por qué; El truco es aprender el truco.

#     … And those words are made from the letters of our alphabet: a couple-dozen
#     squiggles we can draw with the pen. This is the key!  And the treasure, too,
#     if we can only get our hands on it!  It's as if––as if the key to the
#     treasure @e(is) the treasure!
    ... Y esas palabras están hechas de las letras de nuestro alfabeto: una
    docena de garabatos que podemos dibujar con la pluma. Esta es la clave! Y el
    tesoro, también, si sólo podemos poner nuestras manos en él! Es como si -
    como si la llave del tesoro @e(es) el tesoro!

#     --John Barth, @q(Chimera)
    --John Barth, @"(Quimera)
#   < quote..
  < quote..

#   In our study of program design, we have seen that expert programmers control
#   the complexity of their designs with the same general techniques used by
#   designers of all complex systems. They combine primitive elements to form
#   compound objects, they abstract compound objects to form higher-level building
#   blocks, and they preserve modularity by adopting appropriate large-scale views
#   of system structure. In illustrating these techniques, we have used Lisp as a
#   language for describing processes and for constructing computational data
#   objects and processes to model complex phenomena in the real world. However,
#   as we confront increasingly complex problems, we will find that Lisp, or
#   indeed any fixed programming language, is not sufficient for our needs. We
#   must constantly turn to new languages in order to express our ideas more
#   effectively. Establishing new languages is a powerful strategy for controlling
#   complexity in engineering design; we can often enhance our ability to deal
#   with a complex problem by adopting a new language that enables us to describe
#   (and hence to think about) the problem in a different way, using primitives,
#   means of combination, and means of abstraction that are particularly well
#   suited to the problem at hand.@n(205)
  En nuestro estudio del diseño de programas, hemos visto que los programadores
  expertos controlan la complejidad de sus diseños con las mismas técnicas
  generales utilizadas por los diseñadores de todos los sistemas
  complejos. Combinan elementos primitivos para formar objetos compuestos,
  resumen objetos compuestos para formar bloques de construcción de alto nivel y
  preservan la modularidad adoptando las vistas apropiadas a gran escala de la
  estructura del sistema. Al ilustrar estas técnicas, hemos utilizado Lisp como
  un lenguaje para describir procesos y para construir objetos de datos
  computacionales y procesos para modelar fenómenos complejos en el mundo
  real. Sin embargo, a medida que nos enfrentamos a problemas cada vez más
  complejos, veremos que Lisp, o cualquier lenguaje de programación fijo, no es
  suficiente para nuestras necesidades. Debemos recurrir constantemente a nuevos
  idiomas para expresar nuestras ideas con mayor eficacia. Establecer nuevos
  lenguajes es una poderosa estrategia para controlar la complejidad en el
  diseño de ingeniería; A menudo podemos mejorar nuestra capacidad para abordar
  un problema complejo adoptando un nuevo lenguaje que nos permite describir (y
  por lo tanto pensar) el problema de una manera diferente, usando primitivos,
  medios de combinación y medios de abstracción que son particularmente Bien
  adaptado al problema en cuestión.@n(205)

#   Programming is endowed with a multitude of languages. There are physical
#   languages, such as the machine languages for particular computers. These
#   languages are concerned with the representation of data and control in terms
#   of individual bits of storage and primitive machine instructions. The
#   machine-language programmer is concerned with using the given hardware to
#   erect systems and utilities for the efficient implementation of
#   resource-limited computations. High-level languages, erected on a
#   machine-language substrate, hide concerns about the representation of data as
#   collections of bits and the representation of programs as sequences of
#   primitive instructions. These languages have means of combination and
#   abstraction, such as procedure definition, that are appropriate to the
#   larger-scale organization of systems.
  La programación está dotada de una multitud de idiomas. Hay lenguajes físicos,
  tales como los lenguajes de la máquina para ordenadores particulares. Estos
  lenguajes están relacionados con la representación de datos y el control en
  términos de bits individuales de almacenamiento y las instrucciones de la
  máquina primitiva. El programador en lenguaje de máquina se ocupa de utilizar
  el hardware dado para erigir sistemas y utilidades para la implementación
  eficiente de cálculos con recursos limitados. Los lenguajes de alto nivel,
  erigidos sobre un sustrato en lenguaje máquina, ocultan preocupaciones sobre
  la representación de datos como colecciones de bits y la representación de
  programas como secuencias de instrucciones primitivas. Estos lenguajes tienen
  medios de combinación y abstracción, como la definición de procedimientos, que
  son apropiados para la organización a gran escala de sistemas.

#   @e(Metalinguistic abstraction)––establishing new languages––plays an important
#   role in all branches of engineering design. It is particularly important to
#   computer programming, because in programming not only can we formulate new
#   languages but we can also implement these languages by constructing
#   evaluators. An @e(evaluator) (or @e(interpreter)) for a programming language
#   is a procedure that, when applied to an expression of the language, performs
#   the actions required to evaluate that expression.
  @e(La abstracción metalingüística) -estabelecimiento de nuevos lenguajes-
  juega un papel importante en todas las ramas del diseño de ingeniería. Es
  particularmente importante para la programación de computadoras, porque en la
  programación no sólo podemos formular nuevos idiomas, sino que también podemos
  implementar estos lenguajes mediante la construcción de evaluadores. Un
  @e(evaluador) (o @e(intérprete) ) para un lenguaje de programación es un
  procedimiento que, cuando se aplica a una expresión del lenguaje, realiza las
  acciones necesarias para evaluar esa expresión.

#   It is no exaggeration to regard this as the most fundamental idea in
#   programming:
  No es exagerado considerar esto como la idea más fundamental en la
  programación:

#   ..quote >
  ..quote >
#     The evaluator, which determines the meaning of expressions in a programming
#     language, is just another program.
    El evaluador, que determina el significado de las expresiones en un lenguaje
    de programación, es simplemente otro programa.

#   < quote..
  < quote..

#   To appreciate this point is to change our images of ourselves as programmers.
#   We come to see ourselves as designers of languages, rather than only users of
#   languages designed by others.
  Apreciar este punto es cambiar nuestras imágenes de nosotros mismos como
  programadores. Nos vemos a nosotros mismos como diseñadores de lenguajes, en
  lugar de sólo usuarios de lenguajes diseñados por otros.

#   In fact, we can regard almost any program as the evaluator for some language.
#   For instance, the polynomial manipulation system of section @l(#2.5.3) embodies the
#   rules of polynomial arithmetic and implements them in terms of operations on
#   list-structured data. If we augment this system with procedures to read and
#   print polynomial expressions, we have the core of a special-purpose language
#   for dealing with problems in symbolic mathematics. The digital-logic simulator
#   of section @l(#3.3.4) and the constraint propagator of section @l(#3.3.5) are legitimate
#   languages in their own right, each with its own primitives, means of
#   combination, and means of abstraction. Seen from this perspective, the
#   technology for coping with large-scale computer systems merges with the
#   technology for building new computer languages, and computer science itself
#   becomes no more (and no less) than the discipline of constructing appropriate
#   descriptive languages.
  De hecho, podemos considerar casi cualquier programa como el evaluador para
  algún idioma. Por ejemplo, el sistema de manipulación polinomial de
  @l(#2.5.3) incorpora las reglas de la aritmética polinomial y las
  implementa en términos de operaciones en datos estructurados por listas. Si
  aumentamos este sistema con procedimientos para leer e imprimir expresiones
  polinomiales, tenemos el núcleo de un lenguaje de propósito especial para
  tratar problemas en matemáticas simbólicas. El simulador digital-lógico de
  @l(#3.3.4) y el propagador de restricciones de la seccion @l(#3.3.5) son
  lenguajes legítimos por derecho propio, cada uno con sus primitivas propias,
  medios de combinación y medios de abstracción. Visto desde esta perspectiva,
  la tecnología para hacer frente a los sistemas informáticos a gran escala se
  fusiona con la tecnología para la construcción de nuevos lenguajes
  informáticos,

#   We now embark on a tour of the technology by which languages are established
#   in terms of other languages. In this chapter we shall use Lisp as a base,
#   implementing evaluators as Lisp procedures. Lisp is particularly well suited
#   to this task, because of its ability to represent and manipulate symbolic
#   expressions. We will take the first step in understanding how languages are
#   implemented by building an evaluator for Lisp itself. The language implemented
#   by our evaluator will be a subset of the Scheme dialect of Lisp that we use in
#   this book. Although the evaluator described in this chapter is written for a
#   particular dialect of Lisp, it contains the essential structure of an
#   evaluator for any expression-oriented language designed for writing programs
#   for a sequential machine. (In fact, most language processors contain, deep
#   within them, a little @"(Lisp) evaluator.)  The evaluator has been simplified
#   for the purposes of illustration and discussion, and some features have been
#   left out that would be important to include in a production-quality Lisp
#   system.  Nevertheless, this simple evaluator is adequate to execute most of
#   the programs in this book.@n(206)
  Ahora nos embarcamos en una gira de la tecnología por la que los idiomas se
  establecen en términos de otros idiomas. En este capítulo usaremos Lisp como
  base, implementando evaluadores como procedimientos Lisp. Lisp es
  particularmente adecuado para esta tarea, debido a su capacidad para
  representar y manipular expresiones simbólicas. Tomaremos el primer paso para
  entender cómo se implementan los lenguajes mediante la construcción de un
  evaluador para Lisp. El lenguaje implementado por nuestro evaluador será un
  subconjunto del dialecto Scheme de Lisp que usamos en este libro. Aunque el
  evaluador descrito en este capítulo está escrito para un dialecto particular
  de Lisp, contiene la estructura esencial de un evaluador para cualquier
  lenguaje orientado a la expresión diseñado para escribir programas para una
  máquina secuencial. (De hecho, la mayoría de los procesadores de lenguaje
  contienen, en su interior, Un evaluador poco @"(Lisp) .) El evaluador se ha
  simplificado con fines de ilustración y discusión, y algunas características
  se han dejado de lado que sería importante incluir en un sistema Lisp de
  calidad de producción. Sin embargo, este simple evaluador es adecuado para
  ejecutar la mayoría de los programas en este libro.@n(206)

#   An important advantage of making the evaluator accessible as a Lisp program is
#   that we can implement alternative evaluation rules by describing these as
#   modifications to the evaluator program. One place where we can use this power
#   to good effect is to gain extra control over the ways in which computational
#   models embody the notion of time, which was so central to the discussion in
#   @l(#Chapter 3). There, we mitigated some of the complexities of state and
#   assignment by using streams to decouple the representation of time in the
#   world from time in the computer. Our stream programs, however, were sometimes
#   cumbersome, because they were constrained by the applicative-order evaluation
#   of Scheme. in section @l(#4.2), we'll change the underlying language to provide for a
#   more elegant approach, by modifying the evaluator to provide for
#   @e(normal-order evaluation).
  Una ventaja importante de hacer accesible al evaluador como un programa Lisp
  es que podemos implementar reglas alternativas de evaluación describiéndolas
  como modificaciones al programa evaluador. Un lugar en el que podemos usar
  este poder con buenos resultados es ganar control adicional sobre las formas
  en que los modelos computacionales incorporan la noción de tiempo, que fue tan
  central en la discusión del @l(#Capitulo 3). Allí, hemos mitigado
  algunas de las complejidades de estado y asignación mediante el uso de arroyos
  para desacoplar la representación del tiempo en el mundo desde el tiempo en la
  computadora. Nuestros programas de flujo, sin embargo, eran a veces
  engorrosos, porque estaban limitados por la evaluación del pedido de
  Scheme. en la seccion @l(#4.2), cambiaremos el lenguaje subyacente para proporcionar
  un enfoque más elegante,@e()

#   Section @l(#4.3) implements a more ambitious linguistic change, whereby
#   expressions have many values, rather than just a single value. In this
#   language of @e(nondeterministic computing), it is natural to express processes
#   that generate all possible values for expressions and then search for those
#   values that satisfy certain constraints. In terms of models of computation and
#   time, this is like having time branch into a set of @"(possible futures) and
#   then searching for appropriate time lines. With our nondeterministic
#   evaluator, keeping track of multiple values and performing searches are
#   handled automatically by the underlying mechanism of the language.
  La Sección @l(#4.3) implementa un cambio lingüístico más ambicioso, en el
  cual las expresiones tienen muchos valores, en lugar de un solo valor. En este
  lenguaje de @e(computación no determinista), es natural expresar procesos que
  generan todos los valores posibles para las expresiones y luego buscar
  aquellos valores que satisfacen ciertas restricciones. En términos de modelos
  de cálculo y tiempo, esto es como tener rama de tiempo en un conjunto de
  @"(futuros posibles) y luego buscar líneas de tiempo apropiadas. Con nuestro
  evaluador no determinista, el seguimiento de múltiples valores y la
  realización de búsquedas son manejados automáticamente por el mecanismo
  subyacente del lenguaje.

#   in section @l(#4.4) we implement a @e(logic-programming) language in which knowledge
#   is expressed in terms of relations, rather than in terms of computations with
#   inputs and outputs. Even though this makes the language drastically different
#   from Lisp, or indeed from any conventional language, we will see that the
#   logic-programming evaluator shares the essential structure of the Lisp
#   evaluator.
  en la seccion @l(#4.4) implementamos un lenguaje de @e(programación lógica) en el
  que el conocimiento se expresa en términos de relaciones, más que en términos
  de cálculos con entradas y salidas. Aunque esto hace que el lenguaje sea
  drásticamente diferente de Lisp, o de cualquier lenguaje convencional, veremos
  que el evaluador de programación lógica comparte la estructura esencial del
  evaluador de Lisp.

# ** 4.1 <> The Metacircular Evaluator
** 4.1 <> El Evaluador Metacircular

#    Our evaluator for Lisp will be implemented as a Lisp program. It may seem
#    circular to think about evaluating Lisp programs using an evaluator that is
#    itself implemented in Lisp. However, evaluation is a process, so it is
#    appropriate to describe the evaluation process using Lisp, which, after all,
#    is our tool for describing processes.@n(207) An evaluator that is written in
#    the same language that it evaluates is said to be @e(metacircular).
   Nuestro evaluador para Lisp será implementado como un programa Lisp. Puede
   parecer circular pensar en la evaluación de los programas Lisp utilizando un
   evaluador que se implementa en Lisp. Sin embargo, la evaluación es un
   proceso, por lo que es apropiado describir el proceso de evaluación con Lisp,
   que, después de todo, es nuestra herramienta para describir
   procesos.@n(207) Un evaluador que está escrito en el mismo lenguaje
   que evalúa se dice que es @e(metacircular).

#    The metacircular evaluator is essentially a Scheme formulation of the
#    environment model of evaluation described in section @l(#3.2). Recall that the model
#    has two basic parts:
   El evaluador metacircular es esencialmente una formulación Scheme del modelo
   de evaluación ambiental descrito en la seccion @l(#3.2). Recordemos que el modelo
   tiene dos partes básicas:

#    1. To evaluate a combination (a compound expression other than a special
#       form), evaluate the subexpressions and then apply the value of the operator
#       subexpression to the values of the operand subexpressions.
   1. Para evaluar una combinación (una expresión compuesta distinta de una
      forma especial), evalúe las subexpresiones y luego aplique el valor de la
      subexpresión de operador a los valores de las subexpresiones de operando.

#    2. To apply a compound procedure to a set of arguments, evaluate the body of
#       the procedure in a new environment. To construct this environment, extend
#       the environment part of the procedure object by a frame in which the formal
#       parameters of the procedure are bound to the arguments to which the
#       procedure is applied.
   2. Para aplicar un procedimiento compuesto a un conjunto de argumentos,
      evalúe el cuerpo del procedimiento en un nuevo entorno. Para construir
      este entorno, extienda la parte de entorno del objeto de procedimiento
      mediante un marco en el que los parámetros formales del procedimiento
      estén enlazados a los argumentos a los que se aplica el procedimiento.


#    These two rules describe the essence of the evaluation process, a basic cycle
#    in which expressions to be evaluated in environments are reduced to procedures
#    to be applied to arguments, which in turn are reduced to new expressions to be
#    evaluated in new environments, and so on, until we get down to symbols, whose
#    values are looked up in the environment, and to primitive procedures, which
#    are applied directly (see @l(#Figure 4.1)).@n(208) This evaluation cycle will
#    be embodied by the interplay between the two critical procedures in the
#    evaluator, @c(eval) and @c(apply), which are described in section @l(#4.1.1) (see
#    @l(#Figure 4.1)).
   Estas dos reglas describen la esencia del proceso de evaluación, un ciclo
   básico en el cual las expresiones que se van a evaluar en entornos se reducen
   a procedimientos que se aplican a los argumentos, que a su vez se reducen a
   nuevas expresiones para ser evaluadas en nuevos ambientes, etc., Hasta llegar
   a los símbolos, cuyos valores se buscan en el entorno, ya los procedimientos
   primitivos, que se aplican directamente (véase la @l(#Figura 4.1)
   ).@n(208) Este ciclo de evaluación se materializará mediante la
   interacción entre los dos procedimientos críticos del evaluador, @c(eval) y
   @c(apply) que se describen en la seccion @l(#4.1.1) (véase la
   @l(#Figura 4.1) ).

#    ..figure > @t(Figure 4.1) The @c(eval)-@c(apply) cycle exposes the essence of
#      a computer language.
   ..figure > @t(Figura 4.1) El @c(eval)- @c(apply) ciclo expone la esencia de
     un lenguaje de programación.

#      ..art >
#                                   .,ad88888888baa,
#                          _    ,d8P"""        ""9888ba.      _
#                         /  .a8"          ,ad88888888888a   |\
#                       /   aP'          ,88888888888888888a   \
#                      /  ,8"           ,88888888888888888888,  \
#                     |  ,8'            (888888888888888888888, |
#                    /  ,8'             `8888888888888888888888  \
#                    |  8)               `888888888888888888888, |
#        Procedure,  |  8                  "88888 Apply 8888888) | Expression
#        Arguments   |  8     Eval          `888888888888888888) | Environment
#                    |  8)                    "8888888888888888  |
#                    \  (b                     "88888888888888'  /
#                     | `8,                     8888888888888)  |
#                     \  "8a                   ,888888888888)  /
#                      \   V8,                 d88888888888"  /
#                      _\| `8b,             ,d8888888888P' _/
#                             `V8a,       ,ad8888888888P'
#                                ""88888888888888888P"
#                                     """"""""""""
#
#                                       [graphic by Normand Veillux, modified]
#      < art..
     ..art >
                                  .,ad88888888baa,
                         _    ,d8P"""        ""9888ba.      _
                        /  .a8"          ,ad88888888888a   |\
                      /   aP'          ,88888888888888888a   \
                     /  ,8"           ,88888888888888888888,  \
                    |  ,8'            (888888888888888888888, |
                   /  ,8'             `8888888888888888888888  \
                   |  8)               `888888888888888888888, |
       Procedure,  |  8                  "88888 Apply 8888888) | Expression
       Arguments   |  8     Eval          `888888888888888888) | Environment
                   |  8)                    "8888888888888888  |
                   \  (b                     "88888888888888'  /
                    | `8,                     8888888888888)  |
                    \  "8a                   ,888888888888)  /
                     \   V8,                 d88888888888"  /
                     _\| `8b,             ,d8888888888P' _/
                            `V8a,       ,ad8888888888P'
                               ""88888888888888888P"
                                    """"""""""""

                                      [graphic by Normand Veillux, modified]
     < art..

# @  ..img > img/chap4/Fig4.1a.std.svg
@  ..img > img/chap4/Fig4.1a.std.svg

#    The implementation of the evaluator will depend upon procedures that define
#    the @e(syntax) of the expressions to be evaluated. We will use data
#    abstraction to make the evaluator independent of the representation of the
#    language. For example, rather than committing to a choice that an assignment
#    is to be represented by a list beginning with the symbol @c(set!) we use an
#    abstract predicate @c(assignment?) to test for an assignment, and we use
#    abstract selectors @c(assignment-variable) and @c(assignment-value) to access
#    the parts of an assignment. Implementation of expressions will be described in
#    detail in section @l(#4.1.2). There are also operations, described in section @l(#4.1.3), that
#    specify the representation of procedures and environments. For example,
#    @c(make-procedure) constructs compound procedures, @c(lookup-variable-value)
#    accesses the values of variables, and @c(apply-primitive-procedure) applies a
#    primitive procedure to a given list of arguments.
   La implementación del evaluador dependerá de procedimientos que definan la
   @e(sintaxis) de las expresiones a evaluar. Utilizaremos la abstracción de
   datos para hacer que el evaluador sea independiente de la representación del
   lenguaje. Por ejemplo, en lugar de comprometerse a elegir que una asignación
   deba ser representada por una lista comenzando por el símbolo @c(set!),
   usamos un predicado abstracto @c(assignment?) para probar una asignación, y
   usamos selectores abstractos @c(assignment-variable) y @c(assignment-value)
   para acceder a las partes de una asignación. La aplicación de las expresiones
   se describirá en detalle en la seccion @l(#4.1.2). También hay operaciones,
   descritas en la seccion @l(#4.1.3), que especifican la representación de
   procedimientos y entornos. Por ejemplo, se @c(make-procedure) construyen
   procedimientos
   compuestos,@c(lookup-variable-value)@c(apply-primitive-procedure)

# *** 4.1.1 <> The Core of the Evaluator
*** 4.1.1 <> El núcleo del evaluador

#     The evaluation process can be described as the interplay between two
#     procedures: @c(eval) and @c(apply).
    El proceso de evaluación puede ser descrito como la interacción entre dos
    procedimientos: @c(eval) y @c(apply).

# **** Eval
**** Eval

#      @c(Eval) takes as arguments an expression and an environment. It classifies
#      the expression and directs its evaluation. @c(Eval) is structured as a case
#      analysis of the syntactic type of the expression to be evaluated. In order to
#      keep the procedure general, we express the determination of the type of an
#      expression abstractly, making no commitment to any particular representation
#      for the various types of expressions. Each type of expression has a predicate
#      that tests for it and an abstract means for selecting its parts. This
#      @e(abstract syntax) makes it easy to see how we can change the syntax of the
#      language by using the same evaluator, but with a different collection of
#      syntax procedures.
     @c(Eval) Toma como argumentos una expresión y un entorno. Clasifica la
     expresión y dirige su evaluación. @c(Eval) Se estructura como un análisis
     de caso del tipo sintáctico de la expresión a ser evaluada. Con el fin de
     mantener el procedimiento general, expresamos la determinación del tipo de
     una expresión de forma abstracta, sin comprometer ninguna representación en
     particular para los distintos tipos de expresiones. Cada tipo de expresión
     tiene un predicado que lo prueba y un medio abstracto para seleccionar sus
     partes. Esta @e(sintaxis abstracta) facilita ver cómo podemos cambiar la
     sintaxis del lenguaje utilizando el mismo evaluador, pero con una colección
     diferente de procedimientos de sintaxis.

#      :: Primitive expressions ::
     :: Expresiones primitivas ::

#         - For self-evaluating expressions, such as numbers, @c(eval) returns the
#           expression itself.
        - Para expresiones de autoevaluación, como números, @c(eval) devuelve la
          expresión misma.

#         - @c(Eval) must look up variables in the environment to find their values.
        - @c(Eval) Debe buscar variables en el entorno para encontrar sus
          valores.

#      :: Special forms ::
     :: Formas especiales ::

#         - For quoted expressions, @c(eval) returns the expression that was quoted.
        - Para las expresiones entre comillas, @c(eval) devuelve la expresión
          que se citó.

#         - An assignment to (or a definition of) a variable must recursively call
#           @c(eval) to compute the new value to be associated with the variable. The
#           environment must be modified to change (or create) the binding of the
#           variable.
        - Una asignación a (o una definición de) una variable debe
          recursivamente llamar @c(eval) para calcular el nuevo valor que se va
          a asociar con la variable. El entorno debe modificarse para cambiar (o
          crear) el enlace de la variable.

#         - An @c(if) expression requires special processing of its parts, so as to
#           evaluate the consequent if the predicate is true, and otherwise to
#           evaluate the alternative.
        - Una @c(if) expresión requiere un procesamiento especial de sus partes,
          para evaluar el consecuente si el predicado es verdadero, y de otra
          manera evaluar la alternativa.

#         - A @c(lambda) expression must be transformed into an applicable procedure
#           by packaging together the parameters and body specified by the @c(lambda)
#           expression with the environment of the evaluation.
        - Una expresión @c(lambda) debe transformarse en un procedimiento
          aplicable mediante el empaquetado conjunto de los parámetros y el
          cuerpo especificado por la expresión @c(lambda) con el entorno de la
          evaluación.

#         - A @c(begin) expression requires evaluating its sequence of expressions in
#           the order in which they appear.
        - Una @c(begin) expresión requiere evaluar su secuencia de expresiones
          en el orden en que aparecen.

#         - A case analysis (@c(cond)) is transformed into a nest of @c(if)
#           expressions and then evaluated.
        - Un análisis de casos (@c(cond)) se transforma en un nido de @c(if)
          expresiones y luego se evalúa.

#      :: Combinations ::
     :: Combinaciones ::

#         - For a procedure application, @c(eval) must recursively evaluate the
#           operator part and the operands of the combination. The resulting procedure
#           and arguments are passed to @c(apply), which handles the actual procedure
#           application.
        - Para una aplicación de procedimiento, @c(eval) debe evaluar
          recursivamente la parte del operador y los operandos de la
          combinación. El procedimiento resultante y los argumentos se pasan a
          @c(apply), que maneja la aplicación de procedimiento actual.


#      Here is the definition of @c(eval):
     Aquí está la definición de @c(eval):

#      ..src > scheme
#        (define (eval exp env)
#          (cond ((self-evaluating? exp)
#                 exp)
#                ((variable? exp)
#                 (lookup-variable-value exp env))
#                ((quoted? exp)
#                 (text-of-quotation exp))
#                ((assignment? exp)
#                 (eval-assignment exp env))
#                ((definition? exp)
#                 (eval-definition exp env))
#                ((if? exp)
#                 (eval-if exp env))
#                ((lambda? exp)
#                 (make-procedure
#                  (lambda-parameters exp)
#                  (lambda-body exp)
#                  env))
#                ((begin? exp)
#                 (eval-sequence
#                  (begin-actions exp)
#                  env))
#                ((cond? exp)
#                 (eval (cond->if exp) env))
#                ((application? exp)
#                 (apply (eval (operator exp) env)
#                        (list-of-values
#                         (operands exp)
#                         env)))
#                (else
#                 (error "Unknown expression
#                         type: EVAL" exp))))
#      < src..
     ..src > scheme
       (define (eval exp env)
         (cond ((self-evaluating? exp)
                exp)
               ((variable? exp)
                (lookup-variable-value exp env))
               ((quoted? exp)
                (text-of-quotation exp))
               ((assignment? exp)
                (eval-assignment exp env))
               ((definition? exp)
                (eval-definition exp env))
               ((if? exp)
                (eval-if exp env))
               ((lambda? exp)
                (make-procedure
                 (lambda-parameters exp)
                 (lambda-body exp)
                 env))
               ((begin? exp)
                (eval-sequence
                 (begin-actions exp)
                 env))
               ((cond? exp)
                (eval (cond->if exp) env))
               ((application? exp)
                (apply (eval (operator exp) env)
                       (list-of-values
                        (operands exp)
                        env)))
               (else
                (error "Unknown expression
                        type: EVAL" exp))))
     < src..

#      For clarity, @c(eval) has been implemented as a case analysis using
#      @c(cond). The disadvantage of this is that our procedure handles only a few
#      distinguishable types of expressions, and no new ones can be defined without
#      editing the definition of @c(eval). In most Lisp implementations, dispatching
#      on the type of an expression is done in a data-directed style.  This allows a
#      user to add new types of expressions that @c(eval) can distinguish, without
#      modifying the definition of @c(eval) itself. (See @l(#Exercise 4.3).)
     Para mayor claridad, @c(eval) se ha implementado como un análisis de caso
     usando @c(cond). La desventaja de esto es que nuestro procedimiento maneja
     sólo unos pocos tipos distinguibles de expresiones, y no se pueden definir
     nuevos sin editar la definición de @c(eval). En la mayoría de las
     implementaciones de Lisp, el envío sobre el tipo de una expresión se
     realiza en un estilo dirigido a datos. Esto permite al usuario agregar
     nuevos tipos de expresiones que @c(eval) pueden distinguir, sin modificar
     la definición de @c(eval) sí mismo. (Véase el @l(#Ejercicio
     4.3) .)

# **** Apply
**** Aplicar

#      @c(Apply) takes two arguments, a procedure and a list of arguments to which
#      the procedure should be applied. @c(Apply) classifies procedures into two
#      kinds: It calls @c(apply-primitive-procedure) to apply primitives; it applies
#      compound procedures by sequentially evaluating the expressions that make up
#      the body of the procedure. The environment for the evaluation of the body of a
#      compound procedure is constructed by extending the base environment carried by
#      the procedure to include a frame that binds the parameters of the procedure to
#      the arguments to which the procedure is to be applied. Here is the definition
#      of @c(apply):
     @c(Apply) Toma dos argumentos, un procedimiento y una lista de argumentos a
     los que debe aplicarse el procedimiento. @c(Apply) Clasifica los
     procedimientos en dos tipos: Llama @c(apply-primitive-procedure) a aplicar
     primitivos; Aplica procedimientos compuestos mediante la evaluación
     secuencial de las expresiones que forman el cuerpo del procedimiento. El
     entorno para la evaluación del cuerpo de un procedimiento compuesto se
     construye extendiendo el entorno base llevado por el procedimiento para
     incluir un marco que une los parámetros del procedimiento con los
     argumentos a los que se aplica el procedimiento. Aquí está la definición de
     @c(apply):

#      ..src > scheme
#        (define (apply procedure arguments)
#          (cond ((primitive-procedure? procedure)
#                 (apply-primitive-procedure
#                  procedure
#                  arguments))
#                ((compound-procedure? procedure)
#                 (eval-sequence
#                   (procedure-body procedure)
#                   (extend-environment
#                     (procedure-parameters
#                      procedure)
#                     arguments
#                     (procedure-environment
#                      procedure))))
#                (else
#                 (error "Unknown procedure
#                         type: APPLY"
#                        procedure))))
#      < src..
     ..src > scheme
       (define (apply procedure arguments)
         (cond ((primitive-procedure? procedure)
                (apply-primitive-procedure
                 procedure
                 arguments))
               ((compound-procedure? procedure)
                (eval-sequence
                  (procedure-body procedure)
                  (extend-environment
                    (procedure-parameters
                     procedure)
                    arguments
                    (procedure-environment
                     procedure))))
               (else
                (error "Unknown procedure
                        type: APPLY"
                       procedure))))
     < src..

# **** Procedure arguments
**** Argumentos del procedimiento

#      When @c(eval) processes a procedure application, it uses @c(list-of-values) to
#      produce the list of arguments to which the procedure is to be
#      applied. @c(List-of-values) takes as an argument the operands of the
#      combination. It evaluates each operand and returns a list of the corresponding
#      values:@n(209)
     Cuando @c(eval) procesa una aplicación de procedimiento, utiliza
     @c(list-of-values) para producir la lista de argumentos a la que se va a
     aplicar el procedimiento. @c(List-of-values) Toma como argumento los
     operandos de la combinación. Evalúa cada operando y devuelve una lista de
     los valores correspondientes:@n(209)

#      ..src > scheme
#        (define (list-of-values exps env)
#          (if (no-operands? exps)
#              '()
#              (cons (eval (first-operand exps) env)
#                    (list-of-values
#                     (rest-operands exps)
#                     env))))
#      < src..
     ..src > scheme
       (define (list-of-values exps env)
         (if (no-operands? exps)
             '()
             (cons (eval (first-operand exps) env)
                   (list-of-values
                    (rest-operands exps)
                    env))))
     < src..

# **** Conditionals
**** Condicionales

#      @c(Eval-if) evaluates the predicate part of an @c(if) expression in the given
#      environment. If the result is true, @c(eval-if) evaluates the consequent,
#      otherwise it evaluates the alternative:
     @c(Eval-if) Evalúa la parte predicada de una @c(if) expresión en el entorno
     dado. Si el resultado es verdadero, @c(eval-if) evalúa el consecuente, de
     lo contrario evalúa la alternativa:

#      ..src > scheme
#        (define (eval-if exp env)
#          (if (true? (eval (if-predicate exp) env))
#              (eval (if-consequent exp) env)
#              (eval (if-alternative exp) env)))
#      < src..
     ..src > scheme
       (define (eval-if exp env)
         (if (true? (eval (if-predicate exp) env))
             (eval (if-consequent exp) env)
             (eval (if-alternative exp) env)))
     < src..

#      The use of @c(true?) in @c(eval-if) highlights the issue of the connection
#      between an implemented language and an implementation language. The
#      @c(if-predicate) is evaluated in the language being implemented and thus
#      yields a value in that language. The interpreter predicate @c(true?)
#      translates that value into a value that can be tested by the @c(if) in the
#      implementation language: The metacircular representation of truth might not be
#      the same as that of the underlying Scheme.@n(210)
     El uso de @c(true?) en @c(eval-if) destaca la cuestión de la conexión entre
     un lenguaje implementado y un lenguaje de implementación. Se
     @c(if-predicate) evalúa en el lenguaje que se está implementando y, por lo
     tanto, produce un valor en ese idioma. El predicado del intérprete
     @c(true?) traduce ese valor en un valor que puede ser probado por el @c(if)
     lenguaje de implementación: La representación metacircular de la verdad
     puede no ser la misma que la del Scheme subyacente.@n(210)

# **** Sequences
**** Secuencias

#      @c(Eval-sequence) is used by @c(apply) to evaluate the sequence of expressions
#      in a procedure body and by @c(eval) to evaluate the sequence of expressions in
#      a @c(begin) expression. It takes as arguments a sequence of expressions and an
#      environment, and evaluates the expressions in the order in which they
#      occur. The value returned is the value of the final expression.
     @c(Eval-sequence) Se utiliza @c(apply) para evaluar la secuencia de
     expresiones en un cuerpo de procedimiento y @c(eval) para evaluar la
     secuencia de expresiones en una @c(begin) expresión. Toma como argumentos
     una secuencia de expresiones y un entorno, y evalúa las expresiones en el
     orden en que se producen. El valor devuelto es el valor de la expresión
     final.

#      ..src > scheme
#        (define (eval-sequence exps env)
#          (cond ((last-exp? exps)
#                 (eval (first-exp exps) env))
#                (else
#                 (eval (first-exp exps) env)
#                 (eval-sequence (rest-exps exps)
#                                env))))
#      < src..
     ..src > scheme
       (define (eval-sequence exps env)
         (cond ((last-exp? exps)
                (eval (first-exp exps) env))
               (else
                (eval (first-exp exps) env)
                (eval-sequence (rest-exps exps)
                               env))))
     < src..

# **** Assignments and definitions
**** Asignaciones y definiciones

#      The following procedure handles assignments to variables. It calls @c(eval) to
#      find the value to be assigned and transmits the variable and the resulting
#      value to @c(set-variable-value!) to be installed in the designated
#      environment.
     El siguiente procedimiento maneja asignaciones a variables. Llama @c(eval)
     para encontrar el valor a ser asignado y transmite la variable y el valor
     resultante @c(set-variable-value!) a ser instalado en el entorno designado.

#      ..src > scheme
#        (define (eval-assignment exp env)
#          (set-variable-value!
#           (assignment-variable exp)
#           (eval (assignment-value exp) env)
#           env)
#          'ok)
#      < src..
     ..src > scheme
       (define (eval-assignment exp env)
         (set-variable-value!
          (assignment-variable exp)
          (eval (assignment-value exp) env)
          env)
         'ok)
     < src..

#      Definitions of variables are handled in a similar manner.@n(211)
     Las definiciones de variables se manejan de manera similar.@n(211)

#      ..src > scheme
#        (define (eval-definition exp env)
#          (define-variable!
#            (definition-variable exp)
#            (eval (definition-value exp) env)
#            env)
#          'ok)
#      < src..
     ..src > scheme
       (define (eval-definition exp env)
         (define-variable!
           (definition-variable exp)
           (eval (definition-value exp) env)
           env)
         'ok)
     < src..

#      We have chosen here to return the symbol @c(ok) as the value of an assignment
#      or a definition.@n(212)
     Hemos elegido aquí para devolver el símbolo @c(ok) como el valor de una
     asignación o una definición.@n(212)

#      :: @t(Exercise 4.1) :: Notice that we cannot tell whether the metacircular
#         evaluator evaluates operands from left to right or from right to left. Its
#         evaluation order is inherited from the underlying Lisp: If the arguments to
#         @c(cons) in @c(list-of-values) are evaluated from left to right, then
#         @c(list-of-values) will evaluate operands from left to right; and if the
#         arguments to @c(cons) are evaluated from right to left, then
#         @c(list-of-values) will evaluate operands from right to left.
     :: @t(Ejercicio 4.1) :: Observe que no podemos decir si el evaluador
        metacircular evalúa los operandos de izquierda a derecha o de derecha a
        izquierda. Su orden de evaluación se hereda de la Lisp subyacente: Si
        los argumentos a @c(cons) en @c(list-of-values) se evalúan de izquierda
        a derecha, entonces @c(list-of-values) evaluará operandos de izquierda a
        derecha; Y si los argumentos a @c(cons) se evalúan de derecha a
        izquierda, entonces @c(list-of-values) evaluará operandos de derecha a
        izquierda.

#         Write a version of @c(list-of-values) that evaluates operands from left to
#         right regardless of the order of evaluation in the underlying Lisp. Also
#         write a version of @c(list-of-values) that evaluates operands from right to
#         left.
        Escribir una versión de la @c(list-of-values) que evalúa operandos de
        izquierda a derecha independientemente del orden de evaluación en el
        Lisp subyacente. También escribe una versión de la @c(list-of-values)
        que evalúa los operandos de derecha a izquierda.

# *** 4.1.2 <> Representing Expressions
*** 4.1.2 <> Representación de expresiones

#     The evaluator is reminiscent of the symbolic differentiation program discussed
#     in section @l(#2.3.2). Both programs operate on symbolic expressions. In both
#     programs, the result of operating on a compound expression is determined by
#     operating recursively on the pieces of the expression and combining the
#     results in a way that depends on the type of the expression. In both programs
#     we used data abstraction to decouple the general rules of operation from the
#     details of how expressions are represented. In the differentiation program
#     this meant that the same differentiation procedure could deal with algebraic
#     expressions in prefix form, in infix form, or in some other form. For the
#     evaluator, this means that the syntax of the language being evaluated is
#     determined solely by the procedures that classify and extract pieces of
#     expressions.
    El evaluador es una reminiscencia del programa de diferenciación simbólica
    discutido en la seccion @l(#2.3.2). Ambos programas operan sobre expresiones
    simbólicas. En ambos programas, el resultado de operar en una expresión
    compuesta se determina operando recursivamente sobre las piezas de la
    expresión y combinando los resultados de una manera que depende del tipo de
    la expresión. En ambos programas utilizamos la abstracción de datos para
    desacoplar las reglas generales de operación de los detalles de cómo se
    representan las expresiones. En el programa de diferenciación esto significó
    que el mismo procedimiento de diferenciación podría tratar las expresiones
    algebraicas en forma de prefijo, en forma de infijo, o de alguna otra
    forma. Para el evaluador, esto significa que la sintaxis del lenguaje que se
    está evaluando está determinada únicamente por los procedimientos que
    clasifican y extraen fragmentos de expresiones.

#     Here is the specification of the syntax of our language:
    Aquí está la especificación de la sintaxis de nuestro lenguaje:

#     - The only self-evaluating items are numbers and strings:
    - Los únicos elementos de autoevaluación son números y cadenas:

#       ..src > scheme
#         (define (self-evaluating? exp)
#           (cond ((number? exp) true)
#                 ((string? exp) true)
#                 (else false)))
#       < src..
      ..src > scheme
        (define (self-evaluating? exp)
          (cond ((number? exp) true)
                ((string? exp) true)
                (else false)))
      < src..

#     - Variables are represented by symbols:
    - Las variables están representadas por símbolos:

#       ..src > scheme
#         (define (variable? exp) (symbol? exp))
#       < src..
      ..src > scheme
        (define (variable? exp) (symbol? exp))
      < src..

#     - Quotations have the form @c[(quote ⟨text-of-quotation⟩)]:@n(213)
    - Las citas tienen la forma @c[(quote ⟨text-of-quotation⟩)]:@n(213)

#       ..src > scheme
#         (define (quoted? exp)
#           (tagged-list? exp 'quote))
#
#         (define (text-of-quotation exp)
#           (cadr exp))
#       < src..
      ..src > scheme
        (define (quoted? exp)
          (tagged-list? exp 'quote))

        (define (text-of-quotation exp)
          (cadr exp))
      < src..

#       @c(Quoted?) is defined in terms of the procedure @c(tagged-list?), which
#       identifies lists beginning with a designated symbol:
      @c(Quoted?) Se define en términos del procedimiento @c(tagged-list?), que
      identifica las listas que comienzan con un símbolo designado:

#       ..src > scheme
#         (define (tagged-list? exp tag)
#           (if (pair? exp)
#               (eq? (car exp) tag)
#               false))
#       < src..
      ..src > scheme
        (define (tagged-list? exp tag)
          (if (pair? exp)
              (eq? (car exp) tag)
              false))
      < src..

#     - Assignments have the form @c[(set! ⟨var⟩ ⟨value⟩)]:
    - Las asignaciones tienen la forma @c[(set! ⟨var⟩ ⟨value⟩)]:

#       ..src > scheme
#         (define (assignment? exp)
#           (tagged-list? exp 'set!))
#
#         (define (assignment-variable exp)
#           (cadr exp))
#
#         (define (assignment-value exp) (caddr exp))
#       < src..
      ..src > scheme
        (define (assignment? exp)
          (tagged-list? exp 'set!))

        (define (assignment-variable exp)
          (cadr exp))

        (define (assignment-value exp) (caddr exp))
      < src..

#     - Definitions have the form
    - Las definiciones tienen la forma

#       ..src > scheme
#         (define ⟨var⟩ ⟨value⟩)
#       < src..
      ..src > scheme
        (define ⟨var⟩ ⟨value⟩)
      < src..

#       or the form
      O la forma

#       ..src > scheme
#         (define (⟨var⟩ ⟨param₁⟩ … ⟨paramₙ⟩)
#           ⟨body⟩)
#       < src..
      ..src > scheme
        (define (⟨var⟩ ⟨param₁⟩ … ⟨paramₙ⟩)
          ⟨body⟩)
      < src..

#       The latter form (standard procedure definition) is syntactic sugar for
      La última forma (definición de procedimiento estándar) es azúcar
      sintáctico para

#       ..src > scheme
#         (define ⟨var⟩
#           (lambda (⟨param₁⟩ … ⟨paramₙ⟩)
#             ⟨body⟩))
#       < src..
      ..src > scheme
        (define ⟨var⟩
          (lambda (⟨param₁⟩ … ⟨paramₙ⟩)
            ⟨body⟩))
      < src..

#       The corresponding syntax procedures are the following:
      Los procedimientos de sintaxis correspondientes son los siguientes:

#       ..src > scheme
#         (define (definition? exp)
#           (tagged-list? exp 'define))
#
#         (define (definition-variable exp)
#           (if (symbol? (cadr exp))
#               (cadr exp)
#               (caadr exp)))
#
#         (define (definition-value exp)
#           (if (symbol? (cadr exp))
#               (caddr exp)
#               (make-lambda
#                (cdadr exp)   ; formal parameters
#                (cddr exp)))) ; body
#       < src..
      ..src > scheme
        (define (definition? exp)
          (tagged-list? exp 'define))

        (define (definition-variable exp)
          (if (symbol? (cadr exp))
              (cadr exp)
              (caadr exp)))

        (define (definition-value exp)
          (if (symbol? (cadr exp))
              (caddr exp)
              (make-lambda
               (cdadr exp)   ; formal parameters
               (cddr exp)))) ; body
      < src..

#     - @c(Lambda) expressions are lists that begin with the symbol @c(lambda):
    - @c(Lambda) Las expresiones son listas que comienzan con el símbolo
      @c(lambda):

#       ..src > scheme
#         (define (lambda? exp)
#           (tagged-list? exp 'lambda))
#         (define (lambda-parameters exp) (cadr exp))
#         (define (lambda-body exp) (cddr exp))
#       < src..
      ..src > scheme
        (define (lambda? exp)
          (tagged-list? exp 'lambda))
        (define (lambda-parameters exp) (cadr exp))
        (define (lambda-body exp) (cddr exp))
      < src..

#       We also provide a constructor for @c(lambda) expressions, which is used by
#       @c(definition-value), above:
      También proporcionamos un constructor para @c(lambda) expresiones, que es
      usado por @c(definition-value), arriba:

#       ..src > scheme
#         (define (make-lambda parameters body)
#           (cons 'lambda (cons parameters body)))
#       < src..
      ..src > scheme
        (define (make-lambda parameters body)
          (cons 'lambda (cons parameters body)))
      < src..

#     - Conditionals begin with @c(if) and have a predicate, a consequent, and an
#       (optional) alternative. If the expression has no alternative part, we
#       provide @c(false) as the alternative.@n(214)
    - Los condicionales comienzan con @c(if) y tienen un predicado, una
      consecuencia y una alternativa (opcional). Si la expresión no tiene
      ninguna parte alternativa, se proporciona @c(false) como la
      alternativa.@n(214)

#       ..src > scheme
#         (define (if? exp) (tagged-list? exp 'if))
#         (define (if-predicate exp) (cadr exp))
#         (define (if-consequent exp) (caddr exp))
#         (define (if-alternative exp)
#           (if (not (null? (cdddr exp)))
#               (cadddr exp)
#               'false))
#       < src..
      ..src > scheme
        (define (if? exp) (tagged-list? exp 'if))
        (define (if-predicate exp) (cadr exp))
        (define (if-consequent exp) (caddr exp))
        (define (if-alternative exp)
          (if (not (null? (cdddr exp)))
              (cadddr exp)
              'false))
      < src..

#       We also provide a constructor for @c(if) expressions, to be used by
#       @c(cond->if) to transform @c(cond) expressions into @c(if) expressions:
      También proporcionamos un constructor para @c(if) expresiones, para ser
      utilizado por @c(cond->if) para transformar @c(cond) expresiones en
      @c(if) expresiones:

#       ..src > scheme
#         (define (make-if predicate
#                          consequent
#                          alternative)
#           (list 'if
#                 predicate
#                 consequent
#                 alternative))
#       < src..
      ..src > scheme
        (define (make-if predicate
                         consequent
                         alternative)
          (list 'if
                predicate
                consequent
                alternative))
      < src..

#     - @c(Begin) packages a sequence of expressions into a single expression. We
#       include syntax operations on @c(begin) expressions to extract the actual
#       sequence from the @c(begin) expression, as well as selectors that return the
#       first expression and the rest of the expressions in the sequence.@n(215)
    - @c(Begin) Empaqueta una secuencia de expresiones en una sola
      expresión. Incluimos operaciones de sintaxis en @c(begin) expresiones para
      extraer la secuencia real de la @c(begin) expresión, así como selectores
      que devuelven la primera expresión y el resto de las expresiones de la
      secuencia.@n(215)

#       ..src > scheme
#         (define (begin? exp)
#           (tagged-list? exp 'begin))
#         (define (begin-actions exp) (cdr exp))
#         (define (last-exp? seq) (null? (cdr seq)))
#         (define (first-exp seq) (car seq))
#         (define (rest-exps seq) (cdr seq))
#       < src..
      ..src > scheme
        (define (begin? exp)
          (tagged-list? exp 'begin))
        (define (begin-actions exp) (cdr exp))
        (define (last-exp? seq) (null? (cdr seq)))
        (define (first-exp seq) (car seq))
        (define (rest-exps seq) (cdr seq))
      < src..

#       We also include a constructor @c(sequence->exp) (for use by @c(cond->if))
#       that transforms a sequence into a single expression, using @c(begin) if
#       necessary:
      También incluimos un constructor @c(sequence->exp)(para uso de
      @c(cond->if)) que transforma una secuencia en una sola expresión,
      usando @c(begin) si es necesario:

#       ..src > scheme
#         (define (sequence->exp seq)
#           (cond ((null? seq) seq)
#                 ((last-exp? seq) (first-exp seq))
#                 (else (make-begin seq))))
#
#         (define (make-begin seq) (cons 'begin seq))
#       < src..
      ..src > scheme
        (define (sequence->exp seq)
          (cond ((null? seq) seq)
                ((last-exp? seq) (first-exp seq))
                (else (make-begin seq))))

        (define (make-begin seq) (cons 'begin seq))
      < src..

#     - A procedure application is any compound expression that is not one of the
#       above expression types. The @c(car) of the expression is the operator, and
#       the @c(cdr) is the list of operands:
    - Una aplicación de procedimiento es cualquier expresión compuesta que no es
      uno de los tipos de expresión anteriores. El @c(car) de la expresión es el
      operador, y el @c(cdr) es la lista de operandos:

#       ..src > scheme
#         (define (application? exp) (pair? exp))
#         (define (operator exp) (car exp))
#         (define (operands exp) (cdr exp))
#         (define (no-operands? ops) (null? ops))
#         (define (first-operand ops) (car ops))
#         (define (rest-operands ops) (cdr ops))
#       < src..
      ..src > scheme
        (define (application? exp) (pair? exp))
        (define (operator exp) (car exp))
        (define (operands exp) (cdr exp))
        (define (no-operands? ops) (null? ops))
        (define (first-operand ops) (car ops))
        (define (rest-operands ops) (cdr ops))
      < src..

# **** Derived expressions
**** Expresiones derivadas

#      Some special forms in our language can be defined in terms of expressions
#      involving other special forms, rather than being implemented directly. One
#      example is @c(cond), which can be implemented as a nest of @c(if)
#      expressions. For example, we can reduce the problem of evaluating the
#      expression
     Algunas formas especiales en nuestro lenguaje se pueden definir en términos
     de expresiones que implican otras formas especiales, en lugar de ser
     implementadas directamente. Un ejemplo es @c(cond), que puede ser
     implementado como un nido de @c(if) expresiones. Por ejemplo, podemos
     reducir el problema de evaluar la expresión

#      ..src > scheme
#        (cond ((> x 0) x)
#              ((= x 0) (display 'zero) 0)
#              (else (- x)))
#      < src..
     ..src > scheme
       (cond ((> x 0) x)
             ((= x 0) (display 'zero) 0)
             (else (- x)))
     < src..

#      to the problem of evaluating the following expression involving @c(if) and
#      @c(begin) expressions:
     Al problema de evaluar la siguiente expresión que implica @c(if) y
     @c(begin) expresiones:

#      ..src > scheme
#        (if (> x 0)
#            x
#            (if (= x 0)
#                (begin (display 'zero) 0)
#                (- x)))
#      < src..
     ..src > scheme
       (if (> x 0)
           x
           (if (= x 0)
               (begin (display 'zero) 0)
               (- x)))
     < src..

#      Implementing the evaluation of @c(cond) in this way simplifies the evaluator
#      because it reduces the number of special forms for which the evaluation
#      process must be explicitly specified.
     La implementación de la evaluación de @c(cond) esta manera simplifica al
     evaluador porque reduce el número de formularios especiales para los cuales
     se debe especificar explícitamente el proceso de evaluación.

#      We include syntax procedures that extract the parts of a @c(cond) expression,
#      and a procedure @c(cond->if) that transforms @c(cond) expressions into @c(if)
#      expressions. A case analysis begins with @c(cond) and has a list of
#      predicate-action clauses. A clause is an @c(else) clause if its predicate is
#      the symbol @c(else).@n(216)
     Incluimos procedimientos de sintaxis que extraen las partes de una @c(cond)
     expresión y un procedimiento @c(cond->if) que transforma @c(cond)
     expresiones en @c(if) expresiones. Un análisis de casos comienza con
     @c(cond) y tiene una lista de cláusulas predicado-acción. Una cláusula es
     una @c(else) cláusula si su predicado es el símbolo @c(else).@n(216)

#      ..src > scheme
#        (define (cond? exp)
#          (tagged-list? exp 'cond))
#        (define (cond-clauses exp) (cdr exp))
#        (define (cond-else-clause? clause)
#          (eq? (cond-predicate clause) 'else))
#        (define (cond-predicate clause)
#          (car clause))
#        (define (cond-actions clause)
#          (cdr clause))
#        (define (cond->if exp)
#          (expand-clauses (cond-clauses exp)))
#        (define (expand-clauses clauses)
#          (if (null? clauses)
#              'false     ; no @c(else) clause
#              (let ((first (car clauses))
#                    (rest (cdr clauses)))
#                (if (cond-else-clause? first)
#                    (if (null? rest)
#                        (sequence->exp
#                         (cond-actions first))
#                        (error "ELSE clause isn't
#                                last: COND->IF"
#                               clauses))
#                    (make-if (cond-predicate first)
#                             (sequence->exp
#                              (cond-actions first))
#                             (expand-clauses
#                              rest))))))
#      < src..
     ..src > scheme
       (define (cond? exp)
         (tagged-list? exp 'cond))
       (define (cond-clauses exp) (cdr exp))
       (define (cond-else-clause? clause)
         (eq? (cond-predicate clause) 'else))
       (define (cond-predicate clause)
         (car clause))
       (define (cond-actions clause)
         (cdr clause))
       (define (cond->if exp)
         (expand-clauses (cond-clauses exp)))
       (define (expand-clauses clauses)
         (if (null? clauses)
             'false     ; no @c(else) clause
             (let ((first (car clauses))
                   (rest (cdr clauses)))
               (if (cond-else-clause? first)
                   (if (null? rest)
                       (sequence->exp
                        (cond-actions first))
                       (error "ELSE clause isn't
                               last: COND->IF"
                              clauses))
                   (make-if (cond-predicate first)
                            (sequence->exp
                             (cond-actions first))
                            (expand-clauses
                             rest))))))
     < src..

#      Expressions (such as @c(cond)) that we choose to implement as syntactic
#      transformations are called @e(derived expressions). @c(Let) expressions are
#      also derived expressions (see @l(#Exercise 4.6)).@n(217)
     Las expresiones (como @c(cond)) que elegimos implementar como
     transformaciones sintácticas se llaman @e(expresiones derivadas). @c(Let)
     Las expresiones también son expresiones derivadas (véase el
     @l(#Ejercicio 4.6) ).@n(217)

#      :: @t(Exercise 4.2) :: Louis Reasoner plans to reorder the @c(cond) clauses in
#         @c(eval) so that the clause for procedure applications appears before the
#         clause for assignments. He argues that this will make the interpreter more
#         efficient: Since programs usually contain more applications than
#         assignments, definitions, and so on, his modified @c(eval) will usually
#         check fewer clauses than the original @c(eval) before identifying the type
#         of an expression.
     :: @t(Ejercicio 4.2) :: Louis Reasoner planea reordenar las @c(cond)
        cláusulas @c(eval) para que la cláusula de solicitudes de procedimiento
        aparezca antes de la cláusula de asignaciones. Sostiene que esto hará
        que el intérprete sea más eficiente: dado que los programas suelen
        contener más aplicaciones que asignaciones, definiciones, etc., su
        modificación @c(eval) suele comprobar menos cláusulas que el original
        @c(eval) antes de identificar el tipo de una expresión.

#         1. What is wrong with Louis's plan?  (Hint: What will Louis's evaluator do
#            with the expression @c[(define x 3)]?)
        1. ¿Qué pasa con el plan de Louis? (Sugerencia: ¿Qué hará el evaluador
           de Louis con la expresión @c[(define x 3)]?)

#         2. Louis is upset that his plan didn't work. He is willing to go to any
#            lengths to make his evaluator recognize procedure applications before it
#            checks for most other kinds of expressions. Help him by changing the
#            syntax of the evaluated language so that procedure applications start
#            with @c(call). For example, instead of @c[(factorial 3)] we will now
#            have to write @c[(call factorial 3)] and instead of @c[(+ 1 2)] we will
#            have to write @c[(call + 1 2)].
        2. Louis está molesto porque su plan no funcionó. Él está dispuesto a ir
           a cualquier longitud para hacer que su evaluador reconozca las
           aplicaciones de procedimiento antes de que compruebe la mayoría de
           los otros tipos de expresiones. Ayúdelo cambiando la sintaxis del
           lenguaje evaluado para que las aplicaciones de procedimiento
           comiencen con @c(call). Por ejemplo, en lugar de @c[(factorial 3)]
           ahora tendremos que escribir @c[(call factorial 3)] y en vez de @c[(+
           1 2)] tendremos que escribir @c[(call + 1 2)].

#      :: @t(Exercise 4.3) :: Rewrite @c(eval) so that the dispatch is done in
#         data-directed style. Compare this with the data-directed differentiation
#         procedure of @l(#Exercise 2.73). (You may use the @c(car) of a compound
#         expression as the type of the expression, as is appropriate for the syntax
#         implemented in this section.)
     :: @t(Ejercicio 4.3) :: Reescriba @c(eval) para que el despacho se haga en
        estilo dirigido a datos. Compare esto con el procedimiento de
        diferenciación dirigida a datos del @l(#Ejercicio
        2.73). (Puede utilizar el @c(car) de una expresión compuesta como el
        tipo de la expresión, como es apropiado para la sintaxis implementada en
        esta sección.)

#      :: @t(Exercise 4.4) :: Recall the definitions of the special forms @c(and) and
#         @c(or) from @l(#Chapter 1):
     :: @t(Ejercicio 4.4) :: Recordemos las definiciones de los formularios
        especiales @c(and) y @c(or) del @l(#Capitulo 1) :

#         - @c(and): The expressions are evaluated from left to right. If any
#           expression evaluates to false, false is returned; any remaining
#           expressions are not evaluated. If all the expressions evaluate to true
#           values, the value of the last expression is returned. If there are no
#           expressions then true is returned.
        - @c(and): Las expresiones se evalúan de izquierda a derecha. Si
          cualquier expresión se evalúa como falsa, se devuelve false; Las
          expresiones restantes no se evalúan. Si todas las expresiones se
          evalen a valores verdaderos, se devuelve el valor de la última
          expresión. Si no hay expresiones, se devuelve true.

#         - @c(or): The expressions are evaluated from left to right. If any
#           expression evaluates to a true value, that value is returned; any
#           remaining expressions are not evaluated. If all expressions evaluate to
#           false, or if there are no expressions, then false is returned.

        - @c(or): Las expresiones se evalúan de izquierda a derecha. Si
          cualquier expresión se evalúa como un valor verdadero, se devuelve ese
          valor; Las expresiones restantes no se evalúan. Si todas las
          expresiones se evalúan como falsas, o si no hay expresiones, se
          devuelve false.

#         Install @c(and) and @c(or) as new special forms for the evaluator by
#         defining appropriate syntax procedures and evaluation procedures
#         @c(eval-and) and @c(eval-or). Alternatively, show how to implement @c(and)
#         and @c(or) as derived expressions.
        Instalar @c(and) y @c(or) como nuevos formularios especiales para el
        evaluador mediante la definición de procedimientos de sintaxis y
        procedimientos de evaluación apropiados @c(eval-and) y
        @c(eval-or). Alternativamente, muestre cómo implementar @c(and) y @c(or)
        como expresiones derivadas.

#      :: @t(Exercise 4.5) :: Scheme allows an additional syntax for @c(cond)
#         clauses, @c[(⟨test⟩ => ⟨recipient⟩)]. If @c[(test)] evaluates to a true
#         value, then @c[(recipient)] is evaluated.  Its value must be a procedure of
#         one argument; this procedure is then invoked on the value of the
#         @c[(test)], and the result is returned as the value of the @c(cond)
#         expression. For example
     :: @t(Ejercicio 4.5) :: Scheme permite una sintaxis adicional para
        @c(cond) cláusulas, @c[(⟨test⟩ => ⟨recipient⟩)]. Si se @c[(test)]
        evalúa a un valor verdadero, entonces @c[(recipient)] se evalúa. Su
        valor debe ser un procedimiento de un argumento; Este procedimiento se
        invoca en el valor de @c[(test)], y el resultado se devuelve como el
        valor de la @c(cond) expresión. Por ejemplo

#         ..src > scheme
#           (cond ((assoc 'b '((a 1) (b 2))) => cadr)
#                 (else false))
#         < src..
        ..src > scheme
          (cond ((assoc 'b '((a 1) (b 2))) => cadr)
                (else false))
        < src..

#         returns 2. Modify the handling of @c(cond) so that it supports this
#         extended syntax.
        Returns 2. Modifique el manejo de @c(cond) para que admita esta sintaxis
        extendida.

#      :: @t(Exercise 4.6) :: @c(Let) expressions are derived expressions, because
     :: @t(Ejercicio 4.6) :: @c(Let) Expresiones son expresiones derivadas,
        porque

#         ..src > scheme
#           (let ((⟨var₁⟩ ⟨exp₁⟩) … (⟨varₙ⟩ ⟨expₙ⟩))
#             ⟨body⟩)
#         < src..
        ..src > scheme
          (let ((⟨var₁⟩ ⟨exp₁⟩) … (⟨varₙ⟩ ⟨expₙ⟩))
            ⟨body⟩)
        < src..

#         is equivalent to
        es equivalente a

#         ..src > scheme
#           ((lambda (⟨var₁⟩ … ⟨varₙ⟩)
#              ⟨body⟩)
#            ⟨exp₁⟩
#            …
#            ⟨expₙ⟩)
#         < src..
        ..src > scheme
          ((lambda (⟨var₁⟩ … ⟨varₙ⟩)
             ⟨body⟩)
           ⟨exp₁⟩
           …
           ⟨expₙ⟩)
        < src..

#         Implement a syntactic transformation @c(let->combination) that reduces
#         evaluating @c(let) expressions to evaluating combinations of the type shown
#         above, and add the appropriate clause to @c(eval) to handle @c(let)
#         expressions.
        Implementar una transformación sintáctica @c(let->combination) que
        reduzca las @c(let) expresiones de evaluación a las combinaciones de
        evaluación del tipo mostrado anteriormente, y agregue la cláusula
        apropiada @c(eval) para manejar @c(let) expresiones.

#      :: @t(Exercise 4.7) :: @c(Let*) is similar to @c(let), except that the
#         bindings of the @c(let*) variables are performed sequentially from left to
#         right, and each binding is made in an environment in which all of the
#         preceding bindings are visible. For example
     :: @t(Ejercicio 4.7) :: @c(Let*) Es similar a @c(let), excepto que los
        enlaces de las @c(let*) variables se realizan secuencialmente de
        izquierda a derecha, y cada enlace se realiza en un entorno en el que
        todos los enlaces anteriores son visibles. Por ejemplo

#         ..src > scheme
#           (let* ((x 3)
#                  (y (+ x 2))
#                  (z (+ x y 5)))
#             (* x z))
#         < src..
        ..src > scheme
          (let* ((x 3)
                 (y (+ x 2))
                 (z (+ x y 5)))
            (* x z))
        < src..

#         returns 39. Explain how a @c(let*) expression can be rewritten as a set of
#         nested @c(let) expressions, and write a procedure @c(let*->nested-lets)
#         that performs this transformation. If we have already implemented @c(let)
#         (@l(#Exercise 4.6)) and we want to extend the evaluator to handle @c(let*),
#         is it sufficient to add a clause to @c(eval) whose action is
        Regresa 39. Explique cómo una @c(let*) expresión puede ser reescrita
        como un conjunto de @c(let) expresiones anidadas y escriba un
        procedimiento @c(let*->nested-lets) que realice esta
        transformación. Si ya hemos implementado @c(let)(
        @l(#Ejercicio 4.6) ) y queremos extender el evaluador a
        manejar @c(let*), ¿es suficiente agregar una cláusula a @c(eval) cuya
        acción es

#         ..src > scheme
#           (eval (let*->nested-lets exp) env)
#         < src..
        ..src > scheme
          (eval (let*->nested-lets exp) env)
        < src..

#         or must we explicitly expand @c(let*) in terms of non-derived expressions?
        O debemos expandir explícitamente @c(let*) en términos de expresiones no
        derivadas?

#      :: @t(Exercise 4.8) :: @"(Named @c(let)) is a variant of @c(let) that has the
#         form
     :: @t(Ejercicio 4.8) :: @"(Nombrado@c(let)) es una variante de @c(let) que
        tiene la forma

#         ..src > scheme
#           (let ⟨var⟩ ⟨bindings⟩ ⟨body⟩)
#         < src..
        ..src > scheme
          (let ⟨var⟩ ⟨bindings⟩ ⟨body⟩)
        < src..

#         The @c[(bindings)] and @c[(body)] are just as in ordinary @c(let), except
#         that @c[(var)] is bound within @c[(body)] to a procedure whose body is
#         @c[(body)] and whose parameters are the variables in the @c[(bindings)].
#         Thus, one can repeatedly execute the @c[(body)] by invoking the procedure
#         named @c[(var)]. For example, the iterative Fibonacci procedure
#         (section @l(#1.2.2)) can be rewritten using named @c(let) as follows:
        El @c[(bindings)] y @c[(body)] son como en el ordinario @c(let), excepto
        que @c[(var)] está ligado dentro @c[(body)] de un procedimiento cuyo
        cuerpo es @c[(body)] y cuyos parámetros son las variables en el
        @c[(bindings)]. Por lo tanto, se puede ejecutar repetidamente el
        @c[(body)] invocando el procedimiento denominado @c[(var)]. Por ejemplo,
        el procedimiento iterativo de Fibonacci (seccion @l(#1.2.2)) puede ser
        reescrito usando el nombre de la @c(let) siguiente manera:

#         ..src > scheme
#           (define (fib n)
#             (let fib-iter ((a 1) (b 0) (count n))
#               (if (= count 0)
#                   b
#                   (fib-iter (+ a b)
#                             a
#                             (- count 1)))))
#         < src..
        ..src > scheme
          (define (fib n)
            (let fib-iter ((a 1) (b 0) (count n))
              (if (= count 0)
                  b
                  (fib-iter (+ a b)
                            a
                            (- count 1)))))
        < src..

#         Modify @c(let->combination) of @l(#Exercise 4.6) to also support named
#         @c(let).
        Modificar @c(let->combination) del @l(#Ejercicio 4.6) a
        apoyar también nombrado @c(let).

#      :: @t(Exercise 4.9) :: Many languages support a variety of iteration
#         constructs, such as @c(do), @c(for), @c(while), and @c(until). In Scheme,
#         iterative processes can be expressed in terms of ordinary procedure calls,
#         so special iteration constructs provide no essential gain in computational
#         power. On the other hand, such constructs are often convenient. Design some
#         iteration constructs, give examples of their use, and show how to implement
#         them as derived expressions.
     :: @t(Ejercicio 4.9) :: Muchos lenguajes soportan una gran variedad de
        estructuras iterativas, como @c(do), @c(for), @c(while), y @c(until). En
        Scheme, los procesos iterativos pueden expresarse en términos de
        llamadas a procedimientos ordinarios, por lo que las construcciones de
        iteración especiales no proporcionan ganancia esencial en potencia
        computacional. Por otra parte, tales construcciones son a menudo
        convenientes. Diseñar algunas construcciones de iteración, dar ejemplos
        de su uso y mostrar cómo implementarlas como expresiones derivadas.

#      :: @t(Exercise 4.10) :: By using data abstraction, we were able to write an
#         @c(eval) procedure that is independent of the particular syntax of the
#         language to be evaluated. To illustrate this, design and implement a new
#         syntax for Scheme by modifying the procedures in this section, without
#         changing @c(eval) or @c(apply).
     :: @t(Ejercicio 4.10) :: Al utilizar la abstracción de datos, pudimos
        escribir un procedimiento @c(eval) que es independiente de la sintaxis
        particular del lenguaje que se va a evaluar. Para ilustrar esto, diseñar
        e implementar una nueva sintaxis para Scheme modificando los
        procedimientos de esta sección, sin cambiar @c(eval) o @c(apply).

# *** 4.1.3 <> Evaluator Data Structures
*** 4.1.3 <> Estructuras de datos del evaluador

#     In addition to defining the external syntax of expressions, the evaluator
#     implementation must also define the data structures that the evaluator
#     manipulates internally, as part of the execution of a program, such as the
#     representation of procedures and environments and the representation of true
#     and false.
    Además de definir la sintaxis externa de las expresiones, la implementación
    del evaluador también debe definir las estructuras de datos que el evaluador
    manipula internamente, como parte de la ejecución de un programa, como la
    representación de procedimientos y entornos y la representación de verdadero
    y falso.

# **** Testing of predicates
**** Pruebas de predicados

#      For conditionals, we accept anything to be true that is not the explicit
#      @c(false) object.
     Para los condicionales, aceptamos cualquier cosa que sea verdadera que no
     sea el @c(false) objeto explícito.

#      ..src > scheme
#        (define (true? x)
#          (not (eq? x false)))
#
#        (define (false? x)
#          (eq? x false))
#      < src..
     ..src > scheme
       (define (true? x)
         (not (eq? x false)))

       (define (false? x)
         (eq? x false))
     < src..

# **** Representing procedures
**** Representación de procedimientos

#      To handle primitives, we assume that we have available the following
#      procedures:
     Para manejar primitivas, asumimos que tenemos disponibles los siguientes
     procedimientos:

#      - @c[(apply-primitive-procedure ⟨proc⟩ ⟨args⟩)]
     - @c[(apply-primitive-procedure ⟨proc⟩ ⟨args⟩)]

#        applies the given primitive procedure to the argument values in the list
#        @c[(args)] and returns the result of the application.
       Aplica el procedimiento primitivo dado a los valores de argumento en la
       lista @c[(args)] y devuelve el resultado de la aplicación.

#      - @c[(primitive-procedure? ⟨proc⟩)]
     - @c[(primitive-procedure? ⟨proc⟩)]

#        tests whether @c[(proc)] is a primitive procedure.
       Prueba si @c[(proc)] es un procedimiento primitivo.


#      These mechanisms for handling primitives are further described in section @l(#4.1.4).
     Estos mecanismos para manejar primitivas se describen con mayor
     @l(#4.1.4<>detalle) en la seccion @l(#4.1.4).

#      Compound procedures are constructed from parameters, procedure bodies, and
#      environments using the constructor @c(make-procedure):
     Los procedimientos compuestos se construyen a partir de parámetros, cuerpos
     de procedimiento y entornos usando el constructor @c(make-procedure):

#      ..src > scheme
#        (define (make-procedure parameters body env)
#          (list 'procedure parameters body env))
#        (define (compound-procedure? p)
#          (tagged-list? p 'procedure))
#        (define (procedure-parameters p) (cadr p))
#        (define (procedure-body p) (caddr p))
#        (define (procedure-environment p) (cadddr p))
#      < src..
     ..src > scheme
       (define (make-procedure parameters body env)
         (list 'procedure parameters body env))
       (define (compound-procedure? p)
         (tagged-list? p 'procedure))
       (define (procedure-parameters p) (cadr p))
       (define (procedure-body p) (caddr p))
       (define (procedure-environment p) (cadddr p))
     < src..

# **** Operations on Environments
**** Operaciones en entornos

#      The evaluator needs operations for manipulating environments. As explained in
#      @l(#3.2), an environment is a sequence of frames, where each frame is a table
#      of bindings that associate variables with their corresponding values.  We use
#      the following operations for manipulating environments:
     El evaluador necesita operaciones para manipular ambientes. Como se explica
     en la seccion @l(#3.2), un entorno es una secuencia de tramas, donde cada trama
     es una tabla de enlaces que asocian variables con sus valores
     correspondientes. Utilizamos las siguientes operaciones para manipular
     ambientes:

#      - @c[(lookup-variable-value ⟨var⟩ ⟨env⟩)]
     - @c[(lookup-variable-value ⟨var⟩ ⟨env⟩)]

#        returns the value that is bound to the symbol @c[(var)] in the environment
#        @c[(env)], or signals an error if the variable is unbound.
       Devuelve el valor que está enlazado al símbolo @c[(var)] en el entorno
       @c[(env)], o señala un error si la variable no está unida.

#      - @c[(extend-environment ⟨variables⟩ ⟨values⟩ ⟨base-env⟩)]
     - @c[(extend-environment ⟨variables⟩ ⟨values⟩ ⟨base-env⟩)]

#        returns a new environment, consisting of a new frame in which the symbols in
#        the list @c[(variables)] are bound to the corresponding elements in the list
#        @c[(values)], where the enclosing environment is the environment
#        @c[(base-env)].
       Devuelve un nuevo entorno, que consiste en un nuevo marco en el que los
       símbolos de la lista @c[(variables)] están enlazados a los elementos
       correspondientes de la lista @c[(values)], donde el entorno que lo rodea
       es el entorno @c[(base-env)].

#      - @c[(define-variable! ⟨var⟩ ⟨value⟩ ⟨env⟩)]
     - @c[(define-variable! ⟨var⟩ ⟨value⟩ ⟨env⟩)]

#        adds to the first frame in the environment @c[(env)] a new binding that
#        associates the variable @c[(var)] with the value @c[(value)].
       Agrega a la primera trama en el entorno @c[(env)] una nueva vinculación
       que asocia la variable @c[(var)] con el valor @c[(value)].

#      - @c[(set-variable-value! ⟨var⟩ ⟨value⟩ ⟨env⟩)]
     - @c[(set-variable-value! ⟨var⟩ ⟨value⟩ ⟨env⟩)]

#        changes the binding of the variable @c[(var)] in the environment @c[(env)]
#        so that the variable is now bound to the value @c[(value)], or signals an
#        error if the variable is unbound.
       Cambia la vinculación de la variable @c[(var)] en el entorno @c[(env)]
       para que la variable esté ahora enlazada al valor @c[(value)] o señale un
       error si la variable no está unida.


#      To implement these operations we represent an environment as a list of frames.
#      The enclosing environment of an environment is the @c(cdr) of the list. The
#      empty environment is simply the empty list.
     Para implementar estas operaciones representamos un entorno como una lista
     de marcos. El entorno de inclusión de un entorno es el @c(cdr) de la
     lista. El entorno vacío es simplemente la lista vacía.

#      ..src > scheme
#        (define (enclosing-environment env) (cdr env))
#        (define (first-frame env) (car env))
#        (define the-empty-environment '())
#      < src..
     ..src > scheme
       (define (enclosing-environment env) (cdr env))
       (define (first-frame env) (car env))
       (define the-empty-environment '())
     < src..

#      Each frame of an environment is represented as a pair of lists: a list of the
#      variables bound in that frame and a list of the associated values.@n(218)
     Cada trama de un entorno se representa como un par de listas: una lista de
     las variables enlazadas en ese marco y una lista de los valores
     asociados.@n(218)

#      ..src > scheme
#        (define (make-frame variables values)
#          (cons variables values))
#        (define (frame-variables frame) (car frame))
#        (define (frame-values frame) (cdr frame))
#        (define (add-binding-to-frame! var val frame)
#          (set-car! frame (cons var (car frame)))
#          (set-cdr! frame (cons val (cdr frame))))
#      < src..
     ..src > scheme
       (define (make-frame variables values)
         (cons variables values))
       (define (frame-variables frame) (car frame))
       (define (frame-values frame) (cdr frame))
       (define (add-binding-to-frame! var val frame)
         (set-car! frame (cons var (car frame)))
         (set-cdr! frame (cons val (cdr frame))))
     < src..

#      To extend an environment by a new frame that associates variables with values,
#      we make a frame consisting of the list of variables and the list of values,
#      and we adjoin this to the environment. We signal an error if the number of
#      variables does not match the number of values.
     Para extender un entorno mediante un nuevo marco que asocia variables con
     valores, hacemos un cuadro que consta de la lista de variables y la lista
     de valores, y adjuntamos esto al entorno. Señalamos un error si el número
     de variables no coincide con el número de valores.

#      ..src > scheme
#        (define (extend-environment vars vals base-env)
#          (if (= (length vars) (length vals))
#              (cons (make-frame vars vals) base-env)
#              (if (< (length vars) (length vals))
#                  (error "Too many arguments supplied"
#                         vars
#                         vals)
#                  (error "Too few arguments supplied"
#                         vars
#                         vals))))
#      < src..
     ..src > scheme
       (define (extend-environment vars vals base-env)
         (if (= (length vars) (length vals))
             (cons (make-frame vars vals) base-env)
             (if (< (length vars) (length vals))
                 (error "Too many arguments supplied"
                        vars
                        vals)
                 (error "Too few arguments supplied"
                        vars
                        vals))))
     < src..

#      To look up a variable in an environment, we scan the list of variables in the
#      first frame. If we find the desired variable, we return the corresponding
#      element in the list of values. If we do not find the variable in the current
#      frame, we search the enclosing environment, and so on. If we reach the empty
#      environment, we signal an @"(unbound variable) error.
     Para buscar una variable en un entorno, analizamos la lista de variables en
     el primer fotograma. Si encontramos la variable deseada, devolvemos el
     elemento correspondiente en la lista de valores. Si no encontramos la
     variable en el marco actual, buscamos el entorno que lo rodea, y así
     sucesivamente. Si llegamos al entorno vacío, se señala un error de
     @"(variable no unida).

#      ..src > scheme
#        (define (lookup-variable-value var env)
#          (define (env-loop env)
#            (define (scan vars vals)
#              (cond ((null? vars)
#                     (env-loop
#                      (enclosing-environment env)))
#                    ((eq? var (car vars))
#                     (car vals))
#                    (else (scan (cdr vars)
#                                (cdr vals)))))
#            (if (eq? env the-empty-environment)
#                (error "Unbound variable" var)
#                (let ((frame (first-frame env)))
#                  (scan (frame-variables frame)
#                        (frame-values frame)))))
#          (env-loop env))
#      < src..
     ..src > scheme
       (define (lookup-variable-value var env)
         (define (env-loop env)
           (define (scan vars vals)
             (cond ((null? vars)
                    (env-loop
                     (enclosing-environment env)))
                   ((eq? var (car vars))
                    (car vals))
                   (else (scan (cdr vars)
                               (cdr vals)))))
           (if (eq? env the-empty-environment)
               (error "Unbound variable" var)
               (let ((frame (first-frame env)))
                 (scan (frame-variables frame)
                       (frame-values frame)))))
         (env-loop env))
     < src..

#      To set a variable to a new value in a specified environment, we scan for the
#      variable, just as in @c(lookup-variable-value), and change the corresponding
#      value when we find it.
     Para establecer una variable en un nuevo valor en un entorno especificado,
     buscamos la variable, igual que en @c(lookup-variable-value), y cambiamos
     el valor correspondiente cuando la encontramos.

#      ..src > scheme
#        (define (set-variable-value! var val env)
#          (define (env-loop env)
#            (define (scan vars vals)
#              (cond ((null? vars)
#                     (env-loop
#                      (enclosing-environment env)))
#                    ((eq? var (car vars))
#                     (set-car! vals val))
#                    (else (scan (cdr vars)
#                                (cdr vals)))))
#            (if (eq? env the-empty-environment)
#                (error "Unbound variable: SET!" var)
#                (let ((frame (first-frame env)))
#                  (scan (frame-variables frame)
#                        (frame-values frame)))))
#          (env-loop env))
#      < src..
     ..src > scheme
       (define (set-variable-value! var val env)
         (define (env-loop env)
           (define (scan vars vals)
             (cond ((null? vars)
                    (env-loop
                     (enclosing-environment env)))
                   ((eq? var (car vars))
                    (set-car! vals val))
                   (else (scan (cdr vars)
                               (cdr vals)))))
           (if (eq? env the-empty-environment)
               (error "Unbound variable: SET!" var)
               (let ((frame (first-frame env)))
                 (scan (frame-variables frame)
                       (frame-values frame)))))
         (env-loop env))
     < src..

#      To define a variable, we search the first frame for a binding for the
#      variable, and change the binding if it exists (just as in
#      @c(set-variable-value!)).  If no such binding exists, we adjoin one to the
#      first frame.
     Para definir una variable, buscamos en el primer marco un enlace para la
     variable y cambiamos el enlace si existe (igual que en
     @c(set-variable-value!)). Si no existe tal encuadernación, adjuntamos uno
     al primer cuadro.

#      ..src > scheme
#        (define (define-variable! var val env)
#          (let ((frame (first-frame env)))
#            (define (scan vars vals)
#              (cond ((null? vars)
#                     (add-binding-to-frame!
#                      var val frame))
#                    ((eq? var (car vars))
#                     (set-car! vals val))
#                    (else (scan (cdr vars)
#                                (cdr vals)))))
#            (scan (frame-variables frame)
#                  (frame-values frame))))
#      < src..
     ..src > scheme
       (define (define-variable! var val env)
         (let ((frame (first-frame env)))
           (define (scan vars vals)
             (cond ((null? vars)
                    (add-binding-to-frame!
                     var val frame))
                   ((eq? var (car vars))
                    (set-car! vals val))
                   (else (scan (cdr vars)
                               (cdr vals)))))
           (scan (frame-variables frame)
                 (frame-values frame))))
     < src..

#      The method described here is only one of many plausible ways to represent
#      environments. Since we used data abstraction to isolate the rest of the
#      evaluator from the detailed choice of representation, we could change the
#      environment representation if we wanted to. (See @l(#Exercise 4.11).)  In a
#      production-quality Lisp system, the speed of the evaluator's environment
#      operations––especially that of variable lookup––has a major impact on the
#      performance of the system. The representation described here, although
#      conceptually simple, is not efficient and would not ordinarily be used in a
#      production system.@n(219)
     El método descrito aquí es sólo una de muchas maneras plausibles de
     representar ambientes. Dado que utilizamos la abstracción de datos para
     aislar al resto del evaluador de la elección detallada de la
     representación, podríamos cambiar la representación del entorno si así lo
     deseáramos. (Véase el @l(#Ejercicio 4.11) .) En un sistema
     Lisp de calidad de producción, la velocidad de las operaciones del entorno
     del evaluador -especialmente la de la búsqueda de variables- tiene un
     impacto importante en el rendimiento del sistema. La representación aquí
     descrita, aunque conceptualmente simple, no es eficiente y normalmente no
     se usaría en un sistema de producción.@n(219)

#      :: @t(Exercise 4.11) :: Instead of representing a frame as a pair of lists, we
#         can represent a frame as a list of bindings, where each binding is a
#         name-value pair. Rewrite the environment operations to use this alternative
#         representation.
     :: @t(Ejercicio 4.11) :: En lugar de representar un marco como un par de
        listas, podemos representar un marco como una lista de enlaces, donde
        cada enlace es un par nombre-valor. Vuelva a escribir las operaciones de
        entorno para utilizar esta representación alternativa.

#      :: @t(Exercise 4.12) :: The procedures @c(define-variable!),
#         @c(set-variable-value!) and @c(lookup-variable-value) can be expressed in
#         terms of more abstract procedures for traversing the environment
#         structure. Define abstractions that capture the common patterns and
#         redefine the three procedures in terms of these abstractions.
     :: @t(Ejercicio 4.12) :: Los procedimientos @c(define-variable!),
        @c(set-variable-value!) y @c(lookup-variable-value) se pueden expresar
        en términos de procedimientos más abstractos para atravesar la
        estructura ambiental. Definir las abstracciones que capturan los
        patrones comunes y redefinir los tres procedimientos en términos de
        estas abstracciones.

#      :: @t(Exercise 4.13) :: Scheme allows us to create new bindings for variables
#         by means of @c(define), but provides no way to get rid of
#         bindings. Implement for the evaluator a special form @c(make-unbound!) that
#         removes the binding of a given symbol from the environment in which the
#         @c(make-unbound!) expression is evaluated. This problem is not completely
#         specified. For example, should we remove only the binding in the first
#         frame of the environment?  Complete the specification and justify any
#         choices you make.
     :: @t(Ejercicio 4.13) :: Scheme nos permite crear nuevos enlaces para
        variables mediante @c(define), pero no proporciona ninguna manera de
        deshacerse de enlaces. Implementar para el evaluador un formulario
        especial @c(make-unbound!) que elimine la vinculación de un símbolo dado
        del entorno en el que @c(make-unbound!) se evalúa la expresión. Este
        problema no se especifica completamente. Por ejemplo, ¿debemos eliminar
        sólo el enlace en el primer marco del entorno? Completa la
        especificación y justifica cualquier elección que realices.

# *** 4.1.4 <> Running the Evaluator as a Program
*** 4.1.4 <> Ejecución del evaluador como un programa

#     Given the evaluator, we have in our hands a description (expressed in Lisp) of
#     the process by which Lisp expressions are evaluated. One advantage of
#     expressing the evaluator as a program is that we can run the program. This
#     gives us, running within Lisp, a working model of how Lisp itself evaluates
#     expressions. This can serve as a framework for experimenting with evaluation
#     rules, as we shall do later in this chapter.
    Dado el evaluador, tenemos en nuestras manos una descripción (expresada en
    Lisp) del proceso por el cual se evalúan las expresiones Lisp. Una ventaja
    de expresar el evaluador como un programa es que podemos ejecutar el
    programa. Esto nos da, funcionando dentro de Lisp, un modelo de
    funcionamiento de cómo el propio Lisp evalúa las expresiones. Esto puede
    servir como marco para experimentar con las reglas de evaluación, como lo
    haremos más adelante en este capítulo.

#     Our evaluator program reduces expressions ultimately to the application of
#     primitive procedures. Therefore, all that we need to run the evaluator is to
#     create a mechanism that calls on the underlying Lisp system to model the
#     application of primitive procedures.
    Nuestro programa evaluador reduce las expresiones en última instancia a la
    aplicación de procedimientos primitivos. Por lo tanto, todo lo que
    necesitamos para ejecutar el evaluador es crear un mecanismo que llama al
    sistema Lisp subyacente para modelar la aplicación de procedimientos
    primitivos.

#     There must be a binding for each primitive procedure name, so that when
#     @c(eval) evaluates the operator of an application of a primitive, it will find
#     an object to pass to @c(apply). We thus set up a global environment that
#     associates unique objects with the names of the primitive procedures that can
#     appear in the expressions we will be evaluating. The global environment also
#     includes bindings for the symbols @c(true) and @c(false), so that they can be
#     used as variables in expressions to be evaluated.
    Debe haber un enlace para cada nombre de procedimiento primitivo, de modo
    que cuando @c(eval) evalúa el operador de una aplicación de una primitiva,
    encontrará un objeto al que pasar @c(apply). De este modo, establecemos un
    entorno global que asocia objetos únicos con los nombres de los
    procedimientos primitivos que pueden aparecer en las expresiones que
    estaremos evaluando. El entorno global también incluye enlaces para los
    símbolos @c(true) y @c(false), para que puedan ser utilizados como variables
    en las expresiones que se van a evaluar.

#     ..src > scheme
#       (define (setup-environment)
#         (let ((initial-env
#                (extend-environment
#                 (primitive-procedure-names)
#                 (primitive-procedure-objects)
#                 the-empty-environment)))
#           (define-variable! 'true true initial-env)
#           (define-variable! 'false false initial-env)
#           initial-env))
#
#       (define the-global-environment
#         (setup-environment))
#     < src..
    ..src > scheme
      (define (setup-environment)
        (let ((initial-env
               (extend-environment
                (primitive-procedure-names)
                (primitive-procedure-objects)
                the-empty-environment)))
          (define-variable! 'true true initial-env)
          (define-variable! 'false false initial-env)
          initial-env))

      (define the-global-environment
        (setup-environment))
    < src..

#     It does not matter how we represent the primitive procedure objects, so long
#     as @c(apply) can identify and apply them by using the procedures
#     @c(primitive-procedure?) and @c(apply-primitive-procedure). We have chosen to
#     represent a primitive procedure as a list beginning with the symbol
#     @c(primitive) and containing a procedure in the underlying Lisp that
#     implements that primitive.
    No importa cómo representamos los objetos de procedimiento primitivo,
    siempre que @c(apply) puedan identificarlos y aplicarlos usando los
    procedimientos @c(primitive-procedure?) y
    @c(apply-primitive-procedure). Hemos elegido representar un procedimiento
    primitivo como una lista que comienza con el símbolo @c(primitive) y que
    contiene un procedimiento en el Lisp subyacente que implementa esa
    primitiva.

#     ..src > scheme
#       (define (primitive-procedure? proc)
#         (tagged-list? proc 'primitive))
#
#       (define (primitive-implementation proc)
#         (cadr proc))
#     < src..
    ..src > scheme
      (define (primitive-procedure? proc)
        (tagged-list? proc 'primitive))

      (define (primitive-implementation proc)
        (cadr proc))
    < src..

#     @c(Setup-environment) will get the primitive names and implementation
#     procedures from a list:@n(220)
    @c(Setup-environment) Obtendrá los nombres primitivos y los procedimientos
    de implementación de una lista:@n(220)

#     ..src > scheme
#       (define primitive-procedures
#         (list (list 'car car)
#               (list 'cdr cdr)
#               (list 'cons cons)
#               (list 'null? null?)
#               ⟨more primitives⟩ ))
#
#       (define (primitive-procedure-names)
#         (map car primitive-procedures))
#
#       (define (primitive-procedure-objects)
#         (map (lambda (proc)
#                (list 'primitive (cadr proc)))
#              primitive-procedures))
#     < src..
    ..src > scheme
      (define primitive-procedures
        (list (list 'car car)
              (list 'cdr cdr)
              (list 'cons cons)
              (list 'null? null?)
              ⟨more primitives⟩ ))

      (define (primitive-procedure-names)
        (map car primitive-procedures))

      (define (primitive-procedure-objects)
        (map (lambda (proc)
               (list 'primitive (cadr proc)))
             primitive-procedures))
    < src..

#     To apply a primitive procedure, we simply apply the implementation procedure
#     to the arguments, using the underlying Lisp system:@n(221)
    Para aplicar un procedimiento primitivo, simplemente aplicamos el
    procedimiento de implementación a los argumentos, usando el sistema Lisp
    subyacente:@n(221)

#     ..src > scheme
#       (define (apply-primitive-procedure proc args)
#         (apply-in-underlying-scheme
#          (primitive-implementation proc) args))
#     < src..
    ..src > scheme
      (define (apply-primitive-procedure proc args)
        (apply-in-underlying-scheme
         (primitive-implementation proc) args))
    < src..

#     For convenience in running the metacircular evaluator, we provide a @e(driver
#     loop) that models the read-eval-print loop of the underlying Lisp system. It
#     prints a @e(prompt), reads an input expression, evaluates this expression in
#     the global environment, and prints the result. We precede each printed result
#     by an @e(output prompt) so as to distinguish the value of the expression from
#     other output that may be printed.@n(222)
    Para mayor comodidad al ejecutar el evaluador metacircular, proporcionamos
    un @e(bucle de controlador) que modela el @e(bucle de) lectura-eval-print
    del sistema Lisp subyacente. Imprime un @e(mensaje), lee una expresión de
    entrada, evalúa esta expresión en el entorno global e imprime el
    resultado. Prevemos cada resultado impreso mediante un @e(aviso de salida)
    para distinguir el valor de la expresión de otra salida que se puede
    imprimir.@n(222)

#     ..src > scheme
#       (define input-prompt  ";;; M-Eval input:")
#       (define output-prompt ";;; M-Eval value:")
#
#       (define (driver-loop)
#         (prompt-for-input input-prompt)
#         (let ((input (read)))
#           (let ((output
#                  (eval input
#                        the-global-environment)))
#             (announce-output output-prompt)
#             (user-print output)))
#         (driver-loop))
#
#       (define (prompt-for-input string)
#         (newline) (newline)
#         (display string) (newline))
#
#       (define (announce-output string)
#         (newline) (display string) (newline))
#     < src..
    ..src > scheme
      (define input-prompt  ";;; M-Eval input:")
      (define output-prompt ";;; M-Eval value:")

      (define (driver-loop)
        (prompt-for-input input-prompt)
        (let ((input (read)))
          (let ((output
                 (eval input
                       the-global-environment)))
            (announce-output output-prompt)
            (user-print output)))
        (driver-loop))

      (define (prompt-for-input string)
        (newline) (newline)
        (display string) (newline))

      (define (announce-output string)
        (newline) (display string) (newline))
    < src..

#     We use a special printing procedure, @c(user-print), to avoid printing the
#     environment part of a compound procedure, which may be a very long list (or
#     may even contain cycles).
    Utilizamos un procedimiento de impresión especial,, @c(user-print) para
    evitar la impresión del medio ambiente parte de un procedimiento compuesto,
    que puede ser una lista muy larga (o incluso puede contener ciclos).

#     ..src > scheme
#       (define (user-print object)
#         (if (compound-procedure? object)
#             (display
#              (list 'compound-procedure
#                    (procedure-parameters object)
#                    (procedure-body object)
#                    '<procedure-env>))
#             (display object)))
#     < src..
    ..src > scheme
      (define (user-print object)
        (if (compound-procedure? object)
            (display
             (list 'compound-procedure
                   (procedure-parameters object)
                   (procedure-body object)
                   '<procedure-env>))
            (display object)))
    < src..

#     Now all we need to do to run the evaluator is to initialize the global
#     environment and start the driver loop. Here is a sample interaction:
    Ahora todo lo que necesitamos hacer para ejecutar el evaluador es
    inicializar el entorno global e iniciar el bucle del controlador. Aquí hay
    una muestra de interacción:

#     ..srci > scheme
#       > (define the-global-environment
#       ^   (setup-environment))
#       > (driver-loop)
#       > ;;; M-Eval input:
#       > (define (append x y)
#       ^   (if (null? x)
#       ^       y
#       ^       (cons (car x) (append (cdr x) y))))
#       ;;; M-Eval value:
#       ok
#       > ;;; M-Eval input:
#       > (append '(a b c) '(d e f))
#       ;;; M-Eval value:
#       (a b c d e f)
#     < srci..
    ..srci > scheme
      > (define the-global-environment
      ^   (setup-environment))
      > (driver-loop)
      > ;;; M-Eval input:
      > (define (append x y)
      ^   (if (null? x)
      ^       y
      ^       (cons (car x) (append (cdr x) y))))
      ;;; M-Eval value:
      ok
      > ;;; M-Eval input:
      > (append '(a b c) '(d e f))
      ;;; M-Eval value:
      (a b c d e f)
    < srci..

#     :: @t(Exercise 4.14) :: Eva Lu Ator and Louis Reasoner are each experimenting
#        with the metacircular evaluator. Eva types in the definition of @c(map),
#        and runs some test programs that use it. They work fine. Louis, in
#        contrast, has installed the system version of @c(map) as a primitive for
#        the metacircular evaluator. When he tries it, things go terribly
#        wrong. Explain why Louis's @c(map) fails even though Eva's works.
    :: @t(Ejercicio 4.14) :: Eva Lu Ator y Louis Reasoner están experimentando
       con el evaluador metacircular. Eva tipifica en la definición de @c(map),
       y ejecuta algunos programas de prueba que lo utilizan. Ellos trabajan
       bien. Louis, por el contrario, ha instalado la versión del sistema
       @c(map) como una primitiva para el evaluador metacircular. Cuando lo
       intenta, las cosas van terriblemente mal. Explique por qué @c(map) falla
       Louis, aunque las obras de Eva.

# *** 4.1.5 <> Data as Programs
*** 4.1.5 <> Datos como programas

#     In thinking about a Lisp program that evaluates Lisp expressions, an analogy
#     might be helpful. One operational view of the meaning of a program is that a
#     program is a description of an abstract (perhaps infinitely large) machine.
#     For example, consider the familiar program to compute factorials:
    Al pensar en un programa Lisp que evalúa expresiones Lisp, una analogía
    podría ser útil. Una visión operativa del significado de un programa es que
    un programa es una descripción de una máquina abstracta (tal vez
    infinitamente grande). Por ejemplo, considere el programa familiar para
    calcular factorials:

#     ..src > scheme
#       (define (factorial n)
#         (if (= n 1)
#             1
#             (* (factorial (- n 1)) n)))
#     < src..
    ..src > scheme
      (define (factorial n)
        (if (= n 1)
            1
            (* (factorial (- n 1)) n)))
    < src..

#     We may regard this program as the description of a machine containing parts
#     that decrement, multiply, and test for equality, together with a two-position
#     switch and another factorial machine. (The factorial machine is infinite
#     because it contains another factorial machine within it.)  @l(#Figure 4.2) is
#     a flow diagram for the factorial machine, showing how the parts are wired
#     together.
    Podemos considerar este programa como la descripción de una máquina que
    contiene partes que decrementan, multiplican y prueban la igualdad, junto
    con un interruptor de dos posiciones y otra máquina factorial. (La máquina
    factorial es infinita porque contiene otra máquina factorial dentro de
    ella). La @l(#Figura 4.2) es un diagrama de flujo de la máquina
    factorial, que muestra cómo las partes están conectadas entre sí.

#     ..figure > @t(Figure 4.2) The factorial program, viewed as an abstract
#       machine.
    ..figure > @t(Figura 4.2) El programa factorial, visto como una máquina
      abstracta.

#       ..art >
#             ╭────────────────────────────────────╮
#             │ factorial                    │1    │
#             │               │1             V     │
#             │               │           ╭─────╮  │
#             │               ▼           │ •   │  │
#             │            ╭─────╮        │     │  │
#         6 ──┼─────●─────▶│  =  ├───────▶│  •  ├──┼──▶ 720
#             │     │      ╰─────╯        │  ╱  │  │
#             │     │                     │  •  │  │
#             │     │                     ╰─────╯  │
#             │     │                        ▲     │
#             │     │                        │     │
#             │     │                     ╭──┴──╮  │
#             │     ●────────────────────▶│  *  │  │
#             │     │                     ╰─────╯  │
#             │     ▼                        ▲     │
#             │  ╭─────╮     ╭───────────╮   │     │
#             │  │  ─  ├────▶│ factorial ├───╯     │
#             │  ╰─────╯     ╰───────────╯         │
#             │     ▲                              │
#             │     │1                             │
#             ╰────────────────────────────────────╯
#       < art..
      ..art >
            ╭────────────────────────────────────╮
            │ factorial                    │1    │
            │               │1             V     │
            │               │           ╭─────╮  │
            │               ▼           │ •   │  │
            │            ╭─────╮        │     │  │
        6 ──┼─────●─────▶│  =  ├───────▶│  •  ├──┼──▶ 720
            │     │      ╰─────╯        │  ╱  │  │
            │     │                     │  •  │  │
            │     │                     ╰─────╯  │
            │     │                        ▲     │
            │     │                        │     │
            │     │                     ╭──┴──╮  │
            │     ●────────────────────▶│  *  │  │
            │     │                     ╰─────╯  │
            │     ▼                        ▲     │
            │  ╭─────╮     ╭───────────╮   │     │
            │  │  ─  ├────▶│ factorial ├───╯     │
            │  ╰─────╯     ╰───────────╯         │
            │     ▲                              │
            │     │1                             │
            ╰────────────────────────────────────╯
      < art..

# @   ..img > img/chap4/Fig4.2a.std.svg
@   ..img > img/chap4/Fig4.2a.std.svg

#     In a similar way, we can regard the evaluator as a very special machine that
#     takes as input a description of a machine. Given this input, the evaluator
#     configures itself to emulate the machine described. For example, if we feed
#     our evaluator the definition of @c(factorial), as shown in @l(#Figure 4.3),
#     the evaluator will be able to compute factorials.
    De manera similar, podemos considerar al evaluador como una máquina muy
    especial que toma como entrada una descripción de una máquina. Dada esta
    entrada, el evaluador se configura para emular la máquina descrita. Por
    ejemplo, si alimentamos a nuestro evaluador la definición de @c(factorial),
    como se muestra en la @l(#Figura 4.3), el evaluador será capaz
    de calcular factorials.

#     ..figure > @t(Figure 4.3) The evaluator emulating a factorial machine.
    ..figure > @t(Figura 4.3) El evaluador emula una máquina factorial.

#       ..art >
#                            ╭────────╮
#                     6 ────▶│  eval  ├────▶ 720
#                            ╰────────╯
#                                ◥
#                      . . .    /  . . .
#                . . .       ../. .      .
#              .                           ..
#             .   (define (factorial n)      . . .
#            .      (if (= n 1)                   . .
#             .         1                            .
#             .         (* (factorial (- n 1)) n)))   .
#               . .                       . .        .
#                   . . . .      . . . .     . . . .
#                            . ..
#       < art..
      ..art >
                           ╭────────╮
                    6 ────▶│  eval  ├────▶ 720
                           ╰────────╯
                               ◥
                     . . .    /  . . .
               . . .       ../. .      .
             .                           ..
            .   (define (factorial n)      . . .
           .      (if (= n 1)                   . .
            .         1                            .
            .         (* (factorial (- n 1)) n)))   .
              . .                       . .        .
                  . . . .      . . . .     . . . .
                           . ..
      < art..

# @   ..img > img/chap4/Fig4.3.std.svg
@   ..img > img/chap4/Fig4.3.std.svg

#     From this perspective, our evaluator is seen to be a @e(universal machine).
#     It mimics other machines when these are described as Lisp programs.@n(223)
#     This is striking. Try to imagine an analogous evaluator for electrical
#     circuits. This would be a circuit that takes as input a signal encoding the
#     plans for some other circuit, such as a filter. Given this input, the circuit
#     evaluator would then behave like a filter with the same description. Such a
#     universal electrical circuit is almost unimaginably complex. It is remarkable
#     that the program evaluator is a rather simple program.@n(224)
    Desde esta perspectiva, nuestro evaluador es visto como una @e(máquina
    universal). Se imita a otras máquinas cuando se describen como programas
    Lisp.@n(223) Esta es sorprendente. Trate de imaginar un evaluador
    análogo para circuitos eléctricos. Esto sería un circuito que toma como
    entrada una señal que codifica los planes para algún otro circuito, como un
    filtro. Dada esta entrada, el evaluador de circuito se comportaría entonces
    como un filtro con la misma descripción. Este circuito eléctrico universal
    es casi inimaginablemente complejo. Es notable que el evaluador del programa
    sea un programa bastante simple.@n(224)

#     Another striking aspect of the evaluator is that it acts as a bridge between
#     the data objects that are manipulated by our programming language and the
#     programming language itself. Imagine that the evaluator program (implemented
#     in Lisp) is running, and that a user is typing expressions to the evaluator
#     and observing the results. From the perspective of the user, an input
#     expression such as @c[(* x x)] is an expression in the programming language,
#     which the evaluator should execute. From the perspective of the evaluator,
#     however, the expression is simply a list (in this case, a list of three
#     symbols: @c(*), @c(x), and @c(x)) that is to be manipulated according to a
#     well-defined set of rules.
    Otro aspecto llamativo del evaluador es que actúa como un puente entre los
    objetos de datos que son manipulados por nuestro lenguaje de programación y
    el propio lenguaje de programación. Imagine que el programa evaluador
    (implementado en Lisp) se está ejecutando, y que un usuario está escribiendo
    expresiones al evaluador y observando los resultados. Desde la perspectiva
    del usuario, una expresión de entrada tal como @c[(* x x)] es una expresión
    en el lenguaje de programación, que el evaluador debe ejecutar. Desde la
    perspectiva del evaluador, sin embargo, la expresión es simplemente una
    lista (en este caso, una lista de tres símbolos: @c(*), @c(x) y @c(x)) que
    es para ser manipulado de acuerdo con un conjunto bien definido de reglas.

#     That the user's programs are the evaluator's data need not be a source of
#     confusion. In fact, it is sometimes convenient to ignore this distinction, and
#     to give the user the ability to explicitly evaluate a data object as a Lisp
#     expression, by making @c(eval) available for use in programs. Many Lisp
#     dialects provide a primitive @c(eval) procedure that takes as arguments an
#     expression and an environment and evaluates the expression relative to the
#     environment.@n(225) Thus,
    Que los programas del usuario sean los datos del evaluador no tiene que ser
    una fuente de confusión. De hecho, a veces es conveniente ignorar esta
    distinción y dar al usuario la capacidad de evaluar explícitamente un objeto
    de datos como una expresión Lisp, poniéndolo @c(eval) disponible para su uso
    en programas. Muchos dialectos Lisp proporcionan un procedimiento @c(eval)
    primitivo que toma como argumentos una expresión y un entorno y evalúa la
    expresión relativa al entorno.@n(225) Así,

#     ..src > scheme
#       (eval '(* 5 5) user-initial-environment)
#     < src..
    ..src > scheme
      (eval '(* 5 5) user-initial-environment)
    < src..

#     and
    y

#     ..src > scheme
#       (eval (cons '* (list 5 5))
#             user-initial-environment)
#     < src..
    ..src > scheme
      (eval (cons '* (list 5 5))
            user-initial-environment)
    < src..

#     will both return 25.@n(226)
    Ambos regresarán 25.@n(226)

#     :: @t(Exercise 4.15) :: Given a one-argument procedure @c(p) and an object
#        @c(a), @c(p) is said to @"(halt) on @c(a) if evaluating the expression
#        @c[(p a)] returns a value (as opposed to terminating with an error message
#        or running forever). Show that it is impossible to write a procedure
#        @c(halts?) that correctly determines whether @c(p) halts on @c(a) for any
#        procedure @c(p) and object @c(a). Use the following reasoning: If you had
#        such a procedure @c(halts?), you could implement the following program:
    :: @t(Ejercicio 4.15) :: Dado un procedimiento de una sola argumento @c(p) y
       un objeto @c(a), @c(p) se dice que @"(detener) en @c(a) si la evaluación
       de la expresión @c[(p a)] devuelve un valor (en contraposición a que
       termina con un mensaje de error o correr siempre). Mostrar que es
       imposible escribir un procedimiento @c(halts?) que determina
       correctamente si se @c(p) detiene @c(a) para cualquier procedimiento
       @c(p) y objeto @c(a). Utilice el siguiente razonamiento: Si tuviera un
       procedimiento de este tipo @c(halts?), podría implementar el siguiente
       programa:

#        ..src > scheme
#          (define (run-forever)
#            (run-forever))
#
#          (define (try p)
#            (if (halts? p p)
#                (run-forever)
#                'halted))
#        < src..
       ..src > scheme
         (define (run-forever)
           (run-forever))

         (define (try p)
           (if (halts? p p)
               (run-forever)
               'halted))
       < src..

#        Now consider evaluating the expression @c[(try try)] and show that any
#        possible outcome (either halting or running forever) violates the intended
#        behavior of @c(halts?).@n(227)
       Ahora considere la posibilidad de evaluar la expresión @c[(try try)] y
       mostrar que cualquier posible resultado (ya sea detener o correr para
       siempre) viola el comportamiento previsto de @c(halts?).@n(227)

# *** 4.1.6 <> Internal Definitions
*** 4.1.6 <> Definiciones internas

#     Our environment model of evaluation and our metacircular evaluator execute
#     definitions in sequence, extending the environment frame one definition at a
#     time. This is particularly convenient for interactive program development, in
#     which the programmer needs to freely mix the application of procedures with
#     the definition of new procedures. However, if we think carefully about the
#     internal definitions used to implement block structure (introduced in
#     @l(#1.1.8)), we will find that name-by-name extension of the environment may
#     not be the best way to define local variables.
    Nuestro modelo de evaluación ambiental y nuestro evaluador metacircular
    ejecutan las definiciones en secuencia, extendiendo el marco del entorno una
    definición a la vez. Esto es particularmente conveniente para el desarrollo
    de programas interactivos, en el que el programador necesita mezclar
    libremente la aplicación de procedimientos con la definición de nuevos
    procedimientos. Sin embargo, si pensamos cuidadosamente en las definiciones
    internas utilizadas para implementar la estructura de bloques (introducida
    en la seccion @l(#1.1.8)), veremos que la extensión de nombre por nombre del
    entorno puede no ser la mejor manera de definir variables locales.

#     Consider a procedure with internal definitions, such as
    Considere un procedimiento con definiciones internas, como

#     ..src > scheme
#       (define (f x)
#         (define (even? n)
#           (if (= n 0)
#               true
#               (odd? (- n 1))))
#         (define (odd? n)
#           (if (= n 0)
#               false
#               (even? (- n 1))))
#         ⟨rest of body of @c(f)⟩)
#     < src..
    ..src > scheme
      (define (f x)
        (define (even? n)
          (if (= n 0)
              true
              (odd? (- n 1))))
        (define (odd? n)
          (if (= n 0)
              false
              (even? (- n 1))))
        ⟨rest of body of @c(f)⟩)
    < src..

#     Our intention here is that the name @c(odd?) in the body of the procedure
#     @c(even?) should refer to the procedure @c(odd?) that is defined after
#     @c(even?). The scope of the name @c(odd?) is the entire body of @c(f), not
#     just the portion of the body of @c(f) starting at the point where the
#     @c(define) for @c(odd?) occurs. Indeed, when we consider that @c(odd?) is
#     itself defined in terms of @c(even?)––so that @c(even?)  and @c(odd?) are
#     mutually recursive procedures––we see that the only satisfactory
#     interpretation of the two @c(define)s is to regard them as if the names
#     @c(even?) and @c(odd?) were being added to the environment
#     simultaneously. More generally, in block structure, the scope of a local name
#     is the entire procedure body in which the @c(define) is evaluated.
    Nuestra intención aquí es que el nombre @c(odd?) en el cuerpo del
    procedimiento @c(even?) debe referirse al procedimiento @c(odd?) que se
    define después @c(even?). El alcance del nombre @c(odd?) es el cuerpo entero
    de @c(f), no sólo la parte del cuerpo de @c(f) comenzar en el punto donde
    ocurre el @c(define) para @c(odd?). De hecho, cuando consideramos que
    @c(odd?) se define a sí mismo en términos de - por lo @c(even?) tanto,
    @c(even?)  y @c(odd?) son procedimientos recursivos mutuamente - vemos que
    la única interpretación satisfactoria de los dos @c(define) s es
    considerarlos como si los nombres @c(even?) y @c(odd?) se agregaran al
    ambiente simultáneamente. De manera más general, en la estructura de
    bloques, el alcance de un nombre local es el cuerpo de procedimiento
    completo en el que @c(define) se evalúa.

#     As it happens, our interpreter will evaluate calls to @c(f) correctly, but for
#     an @"(accidental) reason: Since the definitions of the internal procedures
#     come first, no calls to these procedures will be evaluated until all of them
#     have been defined. Hence, @c(odd?)  will have been defined by the time
#     @c(even?) is executed. In fact, our sequential evaluation mechanism will give
#     the same result as a mechanism that directly implements simultaneous
#     definition for any procedure in which the internal definitions come first in a
#     body and evaluation of the value expressions for the defined variables doesn't
#     actually use any of the defined variables. (For an example of a procedure that
#     doesn't obey these restrictions, so that sequential definition isn't
#     equivalent to simultaneous definition, see @l(#Exercise 4.19).)@n(228)
    Como sucede, nuestro intérprete evalúa las llamadas @c(f) correctamente,
    pero por una razón @"(accidental) : Puesto que las definiciones de los
    procedimientos internos vienen primero, ninguna llamada a estos
    procedimientos será evaluada hasta que todos ellos hayan sido definidos. Por
    lo tanto, @c(odd?)  habrá sido definido por el tiempo que @c(even?) se
    ejecuta. De hecho, nuestro mecanismo de evaluación secuencial dará el mismo
    resultado que un mecanismo que implementa directamente la definición
    simultánea para cualquier procedimiento en el que las definiciones internas
    vienen primero en un cuerpo y la evaluación de las expresiones de valor para
    las variables definidas no utiliza ninguna de Las variables definidas. (Para
    un ejemplo de un procedimiento que no obedece estas restricciones, de modo
    que la definición secuencial no es equivalente a la definición simultánea,
    @l(Ejercicio 4.19)).@n(228)

#     There is, however, a simple way to treat definitions so that internally
#     defined names have truly simultaneous scope––just create all local variables
#     that will be in the current environment before evaluating any of the value
#     expressions.  One way to do this is by a syntax transformation on @c(lambda)
#     expressions.  Before evaluating the body of a @c(lambda) expression, we
#     @"(scan out) and eliminate all the internal definitions in the body. The
#     internally defined variables will be created with a @c(let) and then set to
#     their values by assignment. For example, the procedure
    Sin embargo, existe una manera simple de tratar las definiciones para que
    los nombres definidos internamente tengan un alcance verdaderamente
    simultáneo: simplemente cree todas las variables locales que estarán en el
    entorno actual antes de evaluar cualquier expresión de valor. Una forma de
    hacerlo es mediante una transformación de sintaxis en @c(lambda)
    expresiones. Antes de evaluar el cuerpo de una expresión @c(lambda),
    @"(escanear) y eliminar todas las definiciones internas en el cuerpo. Las
    variables internamente definidas se crearán con a @c(let) y luego se fijarán
    a sus valores por asignación. Por ejemplo, el procedimiento

#     ..src > scheme
#       (lambda ⟨vars⟩
#         (define u ⟨e1⟩)
#         (define v ⟨e2⟩)
#         ⟨e3⟩)
#     < src..
    ..src > scheme
      (lambda ⟨vars⟩
        (define u ⟨e1⟩)
        (define v ⟨e2⟩)
        ⟨e3⟩)
    < src..

#     would be transformed into
    Se transformaría en

#     ..src > scheme
#       (lambda ⟨vars⟩
#         (let ((u '*unassigned*)
#               (v '*unassigned*))
#           (set! u ⟨e1⟩)
#           (set! v ⟨e2⟩)
#           ⟨e3⟩))
#     < src..
    ..src > scheme
      (lambda ⟨vars⟩
        (let ((u '*unassigned*)
              (v '*unassigned*))
          (set! u ⟨e1⟩)
          (set! v ⟨e2⟩)
          ⟨e3⟩))
    < src..

#     where @c(*unassigned*) is a special symbol that causes looking up a variable
#     to signal an error if an attempt is made to use the value of the
#     not-yet-assigned variable.
    Donde @c(*unassigned*) es un símbolo especial que hace buscar una variable
    para señalar un error si se intenta utilizar el valor de la variable no
    asignada.

#     An alternative strategy for scanning out internal definitions is shown in
#     @l(#Exercise 4.18). Unlike the transformation shown above, this enforces the
#     restriction that the defined variables' values can be evaluated without using
#     any of the variables' values.@n(229)
    Una estrategia alternativa para escanear las definiciones internas se
    muestra en el @l(#Ejercicio 4.18). A diferencia de la
    transformación mostrada anteriormente, esto impone la restricción de que los
    valores de las variables definidas pueden ser evaluados sin usar ninguno de
    los valores de las variables.@n(229)

#     :: @t(Exercise 4.16) :: In this exercise we implement the method just
#        described for interpreting internal definitions. We assume that the
#        evaluator supports @c(let) (see @l(#Exercise 4.6)).
    :: @t(Ejercicio 4.16) :: En este ejercicio implementamos el método que
       acabamos de describir para interpretar las definiciones
       internas. Suponemos que el evaluador apoya @c(let)(ver el
       @l(#Ejercicio 4.6) ).

#        1. Change @c(lookup-variable-value) (section @l(#4.1.3)) to signal an error if the
#           value it finds is the symbol @c(*unassigned*).
       1. Cambie @c(lookup-variable-value)(seccion @l(#4.1.3)) para indicar un
          error si el valor que encuentra es el símbolo @c(*unassigned*).

#        2. Write a procedure @c(scan-out-defines) that takes a procedure body and
#           returns an equivalent one that has no internal definitions, by making
#           the transformation described above.
       2. Escriba un procedimiento @c(scan-out-defines) que tome un cuerpo de
          procedimiento y devuelva un equivalente que no tenga definiciones
          internas, realizando la transformación descrita anteriormente.

#        3. Install @c(scan-out-defines) in the interpreter, either in
#           @c(make-procedure) or in @c(procedure-body) (see @l(#4.1.3)).  Which
#           place is better?  Why?
       3. Instalar @c(scan-out-defines) en el intérprete, ya sea en
          @c(make-procedure) o en @c(procedure-body)(véase @l(#4.1.3)
          ). ¿Qué lugar es mejor? ¿Por qué?

#     :: @t(Exercise 4.17) :: Draw diagrams of the environment in effect when
#        evaluating the expression @c[(e3)] in the procedure in the text, comparing
#        how this will be structured when definitions are interpreted sequentially
#        with how it will be structured if definitions are scanned out as
#        described. Why is there an extra frame in the transformed program?  Explain
#        why this difference in environment structure can never make a difference in
#        the behavior of a correct program. Design a way to make the interpreter
#        implement the @"(simultaneous) scope rule for internal definitions without
#        constructing the extra frame.
    :: @t(Ejercicio 4.17) :: Dibuje diagramas del entorno en vigor al evaluar la
       expresión @c[(e3)] en el procedimiento en el texto, comparando cómo se
       estructurará cuando las definiciones se interpretan secuencialmente con
       cómo se estructurará si se escanean las definiciones como se
       describe. ¿Por qué hay un marco extra en el programa transformado?
       Explique por qué esta diferencia en la estructura del entorno nunca puede
       marcar la diferencia en el comportamiento de un programa correcto. Diseñe
       una forma de hacer que el intérprete implemente la regla de alcance
       @"(simultáneo) para las definiciones internas sin construir el marco
       extra.

#     :: @t(Exercise 4.18) :: Consider an alternative strategy for scanning out
#        definitions that translates the example in the text to
    :: @t(Ejercicio 4.18) :: Considere una estrategia alternativa para escanear
       definiciones que traduce el ejemplo en el texto a

#        ..src > scheme
#          (lambda ⟨vars⟩
#            (let ((u '*unassigned*)
#                  (v '*unassigned*))
#              (let ((a ⟨e1⟩)
#                    (b ⟨e2⟩))
#                (set! u a)
#                (set! v b))
#              ⟨e3⟩))
#        < src..
       ..src > scheme
         (lambda ⟨vars⟩
           (let ((u '*unassigned*)
                 (v '*unassigned*))
             (let ((a ⟨e1⟩)
                   (b ⟨e2⟩))
               (set! u a)
               (set! v b))
             ⟨e3⟩))
       < src..

#        Here @c(a) and @c(b) are meant to represent new variable names, created by
#        the interpreter, that do not appear in the user's program. Consider the
#        @c(solve) procedure from @l(#3.5.4):
       Aquí @c(a) y @c(b) están destinados a representar nuevos nombres de
       variables, creados por el intérprete, que no aparecen en el programa del
       usuario. Considere el procedimiento @c(solve) de la seccion @l(#3.5.4) :

#        ..src > scheme
#          (define (solve f y0 dt)
#            (define y (integral (delay dy) y0 dt))
#            (define dy (stream-map f y))
#            y)
#        < src..
       ..src > scheme
         (define (solve f y0 dt)
           (define y (integral (delay dy) y0 dt))
           (define dy (stream-map f y))
           y)
       < src..

#        Will this procedure work if internal definitions are scanned out as shown
#        in this exercise?  What if they are scanned out as shown in the text?
#        Explain.
       ¿Funcionará este procedimiento si las definiciones internas son
       escaneadas como se muestra en este ejercicio? ¿Qué pasa si se escanean
       como se muestra en el texto? Explique.

#     :: @t(Exercise 4.19) :: Ben Bitdiddle, Alyssa P. Hacker, and Eva Lu Ator are
#        arguing about the desired result of evaluating the expression
    :: @t(Ejercicio 4.19) :: Ben Bitdiddle, Alyssa P. Hacker y Eva Lu Ator están
       discutiendo sobre el resultado deseado de evaluar la expresión

#        ..src > scheme
#          (let ((a 1))
#            (define (f x)
#              (define b (+ a x))
#              (define a 5)
#              (+ a b))
#            (f 10))
#        < src..
       ..src > scheme
         (let ((a 1))
           (define (f x)
             (define b (+ a x))
             (define a 5)
             (+ a b))
           (f 10))
       < src..

#        Ben asserts that the result should be obtained using the sequential rule
#        for @c(define): @c(b) is defined to be 11, then @c(a) is defined to be 5,
#        so the result is 16. Alyssa objects that mutual recursion requires the
#        simultaneous scope rule for internal procedure definitions, and that it is
#        unreasonable to treat procedure names differently from other names. Thus,
#        she argues for the mechanism implemented in @l(#Exercise 4.16). This would
#        lead to @c(a) being unassigned at the time that the value for @c(b) is to
#        be computed. Hence, in Alyssa's view the procedure should produce an
#        error. Eva has a third opinion. She says that if the definitions of @c(a)
#        and @c(b) are truly meant to be simultaneous, then the value 5 for @c(a)
#        should be used in evaluating @c(b). Hence, in Eva's view @c(a) should be 5,
#        @c(b) should be 15, and the result should be 20. Which (if any) of these
#        viewpoints do you support?  Can you devise a way to implement internal
#        definitions so that they behave as Eva prefers?@n(230)
       Ben afirma que el resultado debe obtenerse usando la regla secuencial
       para @c(define): @c(b) se define como 11, entonces @c(a) se define como
       5, por lo que el resultado es 16. Alyssa objeta que la recursión mutua
       requiere la regla de alcance simultáneo para las definiciones de
       procedimientos internos y que No es razonable tratar los nombres de
       procedimiento de forma diferente a otros nombres. Por lo tanto, ella
       argumenta por el mecanismo implementado en el
       @l(#Ejercicio 4.16). Esto conduciría a @c(a) ser no
       asignado en el momento en que se @c(b) va a calcular el valor para. Por
       lo tanto, en la opinión de Alyssa el procedimiento debe producir un
       error. Eva tiene una tercera opinión. Ella dice que si las definiciones
       de @c(a) y @c(b) son verdaderamente significa ser simultáneo, entonces el
       valor 5 para se @c(a) debe utilizar en la evaluación @c(b). Por lo tanto,
       @c(a) En la opinión de Eva debe ser 5, @c(b) debe ser 15, y el resultado
       debe ser 20. ¿Cuál (si alguno) de estos puntos de vista apoya? ¿Puedes
       idear una forma de implementar definiciones internas para que se
       comporten como Eva prefiere?@n(230)

#     :: @t(Exercise 4.20) :: Because internal definitions look sequential but are
#        actually simultaneous, some people prefer to avoid them entirely, and use
#        the special form @c(letrec) instead. @c(Letrec) looks like @c(let), so it
#        is not surprising that the variables it binds are bound simultaneously and
#        have the same scope as each other. The sample procedure @c(f) above can be
#        written without internal definitions, but with exactly the same meaning, as
    :: @t(Ejercicio 4.20) :: Debido a que las definiciones internas parecen
       secuenciales pero en realidad son simultáneas, algunas personas prefieren
       evitarlas por completo y usan el formulario especial
       @c(letrec). @c(Letrec) Parece @c(let), por lo que no es de extrañar que
       las variables que vincula se vinculan simultáneamente y tienen el mismo
       alcance que cada uno. El procedimiento de ejemplo @c(f) anterior puede
       escribirse sin definiciones internas, pero con exactamente el mismo
       significado, como

#        ..src > scheme
#          (define (f x)
#            (letrec
#                ((even?
#                  (lambda (n)
#                    (if (= n 0)
#                        true
#                        (odd? (- n 1)))))
#                 (odd?
#                  (lambda (n)
#                    (if (= n 0)
#                        false
#                        (even? (- n 1))))))
#              ⟨rest of body of @c(f)⟩))
#        < src..
       ..src > scheme
         (define (f x)
           (letrec
               ((even?
                 (lambda (n)
                   (if (= n 0)
                       true
                       (odd? (- n 1)))))
                (odd?
                 (lambda (n)
                   (if (= n 0)
                       false
                       (even? (- n 1))))))
             ⟨rest of body of @c(f)⟩))
       < src..

#        @c(Letrec) expressions, which have the form
       @c(Letrec) Expresiones, que tienen la forma

#        ..src > scheme
#          (letrec ((⟨var₁⟩ ⟨exp₁⟩) … (⟨varₙ⟩ ⟨expₙ⟩))
#            ⟨body⟩)
#        < src..
       ..src > scheme
         (letrec ((⟨var₁⟩ ⟨exp₁⟩) … (⟨varₙ⟩ ⟨expₙ⟩))
           ⟨body⟩)
       < src..

#        are a variation on @c(let) in which the expressions @m[⟨expₙ⟩] that provide
#        the initial values for the variables @m[⟨varₙ⟩] are evaluated in an
#        environment that includes all the @c(letrec) bindings. This permits
#        recursion in the bindings, such as the mutual recursion of @c(even?) and
#        @c(odd?) in the example above, or the evaluation of 10 factorial with
       Son una variación @c(let) en la que las expresiones @m(⟨expₙ⟩) que
       proporcionan los valores iniciales para las variables @m(⟨varₙ⟩) se
       evalúan en un entorno que incluye todos los @c(letrec) enlaces. Esto
       permite la recursión en los enlaces, como la recursión mutua de @c(even?)
       y @c(odd?) en el ejemplo anterior, o la evaluación de 10 factorial con

#        ..src > scheme
#          (letrec
#              ((fact
#                (lambda (n)
#                  (if (= n 1)
#                      1
#                      (* n (fact (- n 1)))))))
#            (fact 10))
#        < src..
       ..src > scheme
         (letrec
             ((fact
               (lambda (n)
                 (if (= n 1)
                     1
                     (* n (fact (- n 1)))))))
           (fact 10))
       < src..

#        1. Implement @c(letrec) as a derived expression, by transforming a
#           @c(letrec) expression into a @c(let) expression as shown in the text
#           above or in @l(#Exercise 4.18). That is, the @c(letrec) variables should
#           be created with a @c(let) and then be assigned their values with
#           @c(set!).
       1. Implementar @c(letrec) como una expresión derivada, transformando una
          @c(letrec) expresión en una expresión @c(let) como se muestra en el
          texto anterior o en el @l(#Ejercicio 4.18). Es decir,
          las @c(letrec) variables deben ser creadas con un @c(let) y luego ser
          asignados sus valores con @c(set!).

#        2. Louis Reasoner is confused by all this fuss about internal
#           definitions. The way he sees it, if you don't like to use @c(define)
#           inside a procedure, you can just use @c(let). Illustrate what is loose
#           about his reasoning by drawing an environment diagram that shows the
#           environment in which the @c[(rest of body of @c(f))] is evaluated during
#           evaluation of the expression @c[(f 5)], with @c(f) defined as in this
#           exercise. Draw an environment diagram for the same evaluation, but with
#           @c(let) in place of @c(letrec) in the definition of @c(f).
       2. Louis Reasoner está confundido por todo este alboroto acerca de las
          definiciones internas. La forma en que lo ve, si no te gusta usar
          @c(define) dentro de un procedimiento, sólo puedes usarlo
          @c(let). Ilustre lo que está suelto de su razonamiento dibujando un
          diagrama de entorno que muestre el entorno en el que se evalúa durante
          la evaluación de la expresión, con lo definido como en este
          ejercicio. Dibuja un diagrama de entorno para la misma evaluación,
          pero en lugar de en la definición de .@c[(rest of body of @c(f))]@c[(f
          5)]@c(f)@c(let)@c(letrec)@c(f)

#     :: @t(Exercise 4.21) :: Amazingly, Louis's intuition in @l(#Exercise 4.20) is
#        correct. It is indeed possible to specify recursive procedures without
#        using @c(letrec) (or even @c(define)), although the method for
#        accomplishing this is much more subtle than Louis imagined. The following
#        expression computes 10 factorial by applying a recursive factorial
#        procedure:@n(231)
    :: @t(Ejercicio 4.21) :: Sorprendentemente, la intuición de Louis en el
       @l(#Ejercicio 4.20) es correcta. De hecho, es posible
       especificar los procedimientos recursivos sin usar @c(letrec)(o incluso
       @c(define)), aunque el método para lograr esto es mucho más sutil que
       Louis imaginado. La siguiente expresión computa el factorial 10 aplicando
       un procedimiento factorial recursivo:@n(231)

#        ..src > scheme
#          ((lambda (n)
#             ((lambda (fact) (fact fact n))
#              (lambda (ft k)
#                (if (= k 1)
#                    1
#                    (* k (ft ft (- k 1)))))))
#           10)
#        < src..
       ..src > scheme
         ((lambda (n)
            ((lambda (fact) (fact fact n))
             (lambda (ft k)
               (if (= k 1)
                   1
                   (* k (ft ft (- k 1)))))))
          10)
       < src..

#        1. Check (by evaluating the expression) that this really does compute
#           factorials.  Devise an analogous expression for computing Fibonacci
#           numbers.
       1. Compruebe (mediante la evaluación de la expresión) que esto realmente
          calcula factorials. Desarrolle una expresión análoga para calcular
          números de Fibonacci.

#        2. Consider the following procedure, which includes mutually recursive
#           internal definitions:
       2. Considere el siguiente procedimiento, que incluye definiciones
          internas mutuamente recursivas:

#           ..src > scheme
#             (define (f x)
#               (define (even? n)
#                 (if (= n 0)
#                     true
#                     (odd? (- n 1))))
#               (define (odd? n)
#                 (if (= n 0)
#                     false
#                     (even? (- n 1))))
#               (even? x))
#           < src..
          ..src > scheme
            (define (f x)
              (define (even? n)
                (if (= n 0)
                    true
                    (odd? (- n 1))))
              (define (odd? n)
                (if (= n 0)
                    false
                    (even? (- n 1))))
              (even? x))
          < src..

#           Fill in the missing expressions to complete an alternative definition of
#           @c(f), which uses neither internal definitions nor @c(letrec):
          Complete las expresiones que faltan para completar una definición
          alternativa de @c(f), que no utiliza ni definiciones internas ni
          @c(letrec):

#           ..src > scheme
#             (define (f x)
#               ((lambda (even? odd?)
#                  (even? even? odd? x))
#                (lambda (ev? od? n)
#                  (if (= n 0)
#                      true
#                      (od? ⟨??⟩ ⟨??⟩ ⟨??⟩)))
#                (lambda (ev? od? n)
#                  (if (= n 0)
#                      false
#                      (ev? ⟨??⟩ ⟨??⟩ ⟨??⟩)))))
#           < src..
          ..src > scheme
            (define (f x)
              ((lambda (even? odd?)
                 (even? even? odd? x))
               (lambda (ev? od? n)
                 (if (= n 0)
                     true
                     (od? ⟨??⟩ ⟨??⟩ ⟨??⟩)))
               (lambda (ev? od? n)
                 (if (= n 0)
                     false
                     (ev? ⟨??⟩ ⟨??⟩ ⟨??⟩)))))
          < src..

# *** 4.1.7 <> Separating Syntactic Analysis from Execution
*** 4.1.7 <> Separar el análisis sintáctico de la ejecución

#     The evaluator implemented above is simple, but it is very inefficient, because
#     the syntactic analysis of expressions is interleaved with their execution.
#     Thus if a program is executed many times, its syntax is analyzed many times.
#     Consider, for example, evaluating @c[(factorial 4)] using the following
#     definition of @c(factorial):
    El evaluador implementado arriba es simple, pero es muy ineficiente, porque
    el análisis sintáctico de las expresiones se entrelaza con su
    ejecución. Así, si un programa se ejecuta muchas veces, su sintaxis se
    analiza muchas veces. Considere, por ejemplo, la evaluación @c[(factorial
    4)] utilizando la siguiente definición de @c(factorial):

#     ..src > scheme
#       (define (factorial n)
#         (if (= n 1)
#             1
#             (* (factorial (- n 1)) n)))
#     < src..
    ..src > scheme
      (define (factorial n)
        (if (= n 1)
            1
            (* (factorial (- n 1)) n)))
    < src..

#     Each time @c(factorial) is called, the evaluator must determine that the body
#     is an @c(if) expression and extract the predicate. Only then can it evaluate
#     the predicate and dispatch on its value. Each time it evaluates the expression
#     @c[(* (factorial (- n 1)) n)], or the subexpressions @c[(factorial (- n 1))]
#     and @c[(- n 1)], the evaluator must perform the case analysis in @c(eval) to
#     determine that the expression is an application, and must extract its operator
#     and operands. This analysis is expensive. Performing it repeatedly is
#     wasteful.
    Cada vez que @c(factorial) se llama, el evaluador debe determinar que el
    cuerpo es una @c(if) expresión y extraer el predicado. Sólo entonces puede
    evaluar el predicado y enviar su valor. Cada vez que evalúa la expresión
    @c[(* (factorial (- n 1)) n)], o las subexpresiones @c[(factorial (- n 1))]
    y @c[(- n 1)], el evaluador debe realizar el análisis de casos @c(eval) para
    determinar que la expresión es una aplicación, y debe extraer su operador y
    operandos. Este análisis es caro. Realizarlo repetidamente es un derroche.

#     We can transform the evaluator to be significantly more efficient by arranging
#     things so that syntactic analysis is performed only once.@n(232) We split
#     @c(eval), which takes an expression and an environment, into two parts. The
#     procedure @c(analyze) takes only the expression. It performs the syntactic
#     analysis and returns a new procedure, the @e(execution procedure), that
#     encapsulates the work to be done in executing the analyzed expression. The
#     execution procedure takes an environment as its argument and completes the
#     evaluation. This saves work because @c(analyze) will be called only once on an
#     expression, while the execution procedure may be called many times.
    Podemos transformar al evaluador para ser significativamente más eficiente
    organizando las cosas para que el análisis sintáctico se realice sólo una
    vez.@n(232) Nos dividimos @c(eval), que toma una expresión y un
    ambiente, en dos partes. El procedimiento @c(analyze) toma sólo la
    expresión. Realiza el análisis sintáctico y devuelve un nuevo procedimiento,
    el @e(procedimiento de ejecución), que encapsula el trabajo a realizar en la
    ejecución de la expresión analizada. El procedimiento de ejecución toma como
    argumento un entorno y completa la evaluación. Esto ahorra trabajo porque
    @c(analyze) se llamará sólo una vez en una expresión, mientras que el
    procedimiento de ejecución se puede llamar muchas veces.

#     With the separation into analysis and execution, @c(eval) now becomes
    Con la separación en análisis y ejecución, @c(eval) ahora se convierte en

#     ..src > scheme
#       (define (eval exp env) ((analyze exp) env))
#     < src..
    ..src > scheme
      (define (eval exp env) ((analyze exp) env))
    < src..

#     The result of calling @c(analyze) is the execution procedure to be applied to
#     the environment. The @c(analyze) procedure is the same case analysis as
#     performed by the original @c(eval) of section @l(#4.1.1), except that the procedures
#     to which we dispatch perform only analysis, not full evaluation:
    El resultado de la llamada @c(analyze) es el procedimiento de ejecución que
    se aplicará al entorno. El procedimiento @c(analyze) es el mismo análisis de
    casos realizado por el original @c(eval) de la seccion @l(#4.1.1), excepto que
    los procedimientos a los que enviamos realizan solamente análisis, no
    evaluación completa:

#     ..src > scheme
#       (define (analyze exp)
#         (cond ((self-evaluating? exp)
#                (analyze-self-evaluating exp))
#               ((quoted? exp)
#                (analyze-quoted exp))
#               ((variable? exp)
#                (analyze-variable exp))
#               ((assignment? exp)
#                (analyze-assignment exp))
#               ((definition? exp)
#                (analyze-definition exp))
#               ((if? exp)
#                (analyze-if exp))
#               ((lambda? exp)
#                (analyze-lambda exp))
#               ((begin? exp)
#                (analyze-sequence
#                 (begin-actions exp)))
#               ((cond? exp)
#                (analyze (cond->if exp)))
#               ((application? exp)
#                (analyze-application exp))
#               (else
#                (error "Unknown expression
#                        type: ANALYZE"
#                       exp))))
#     < src..
    ..src > scheme
      (define (analyze exp)
        (cond ((self-evaluating? exp)
               (analyze-self-evaluating exp))
              ((quoted? exp)
               (analyze-quoted exp))
              ((variable? exp)
               (analyze-variable exp))
              ((assignment? exp)
               (analyze-assignment exp))
              ((definition? exp)
               (analyze-definition exp))
              ((if? exp)
               (analyze-if exp))
              ((lambda? exp)
               (analyze-lambda exp))
              ((begin? exp)
               (analyze-sequence
                (begin-actions exp)))
              ((cond? exp)
               (analyze (cond->if exp)))
              ((application? exp)
               (analyze-application exp))
              (else
               (error "Unknown expression
                       type: ANALYZE"
                      exp))))
    < src..

#     Here is the simplest syntactic analysis procedure, which handles
#     self-evaluating expressions. It returns an execution procedure that ignores
#     its environment argument and just returns the expression:
    Aquí está el procedimiento de análisis sintáctico más sencillo, que maneja
    las expresiones de autoevaluación. Devuelve un procedimiento de ejecución
    que ignora su argumento de entorno y simplemente devuelve la expresión:

#     ..src > scheme
#       (define (analyze-self-evaluating exp)
#         (lambda (env) exp))
#     < src..
    ..src > scheme
      (define (analyze-self-evaluating exp)
        (lambda (env) exp))
    < src..

#     For a quoted expression, we can gain a little efficiency by extracting the
#     text of the quotation only once, in the analysis phase, rather than in the
#     execution phase.
    Para una expresión citada, podemos obtener un poco de eficiencia extrayendo
    el texto de la cita sólo una vez, en la fase de análisis, en lugar de en la
    fase de ejecución.

#     ..src > scheme
#       (define (analyze-quoted exp)
#         (let ((qval (text-of-quotation exp)))
#           (lambda (env) qval)))
#     < src..
    ..src > scheme
      (define (analyze-quoted exp)
        (let ((qval (text-of-quotation exp)))
          (lambda (env) qval)))
    < src..

#     Looking up a variable value must still be done in the execution phase, since
#     this depends upon knowing the environment.@n(233)
    La búsqueda de un valor variable debe realizarse en la fase de ejecución, ya
    que esto depende de conocer el entorno.@n(233)

#     ..src > scheme
#       (define (analyze-variable exp)
#         (lambda (env)
#           (lookup-variable-value exp env)))
#     < src..
    ..src > scheme
      (define (analyze-variable exp)
        (lambda (env)
          (lookup-variable-value exp env)))
    < src..

#     @c(Analyze-assignment) also must defer actually setting the variable until the
#     execution, when the environment has been supplied. However, the fact that the
#     @c(assignment-value) expression can be analyzed (recursively) during analysis
#     is a major gain in efficiency, because the @c(assignment-value) expression
#     will now be analyzed only once. The same holds true for definitions.
    @c(Analyze-assignment) También debe aplazar realmente el establecimiento de
    la variable hasta la ejecución, cuando el medio ambiente ha sido
    suministrado. Sin embargo, el hecho de que la @c(assignment-value) expresión
    pueda ser analizada (recursivamente) durante el análisis es una ganancia
    importante en eficiencia, porque la @c(assignment-value) expresión será
    analizada una sola vez. Lo mismo ocurre con las definiciones.

#     ..src > scheme
#       (define (analyze-assignment exp)
#         (let ((var (assignment-variable exp))
#               (vproc (analyze
#                       (assignment-value exp))))
#           (lambda (env)
#             (set-variable-value!
#              var (vproc env) env)
#             'ok)))
#
#       (define (analyze-definition exp)
#         (let ((var (definition-variable exp))
#               (vproc (analyze
#                       (definition-value exp))))
#           (lambda (env)
#             (define-variable! var (vproc env) env)
#             'ok)))
#     < src..
    ..src > scheme
      (define (analyze-assignment exp)
        (let ((var (assignment-variable exp))
              (vproc (analyze
                      (assignment-value exp))))
          (lambda (env)
            (set-variable-value!
             var (vproc env) env)
            'ok)))

      (define (analyze-definition exp)
        (let ((var (definition-variable exp))
              (vproc (analyze
                      (definition-value exp))))
          (lambda (env)
            (define-variable! var (vproc env) env)
            'ok)))
    < src..

#     For @c(if) expressions, we extract and analyze the predicate, consequent, and
#     alternative at analysis time.
    Para @c(if) expresiones, extraemos y analizamos el predicado, consecuente y
    alternativo en el tiempo de análisis.

#     ..src > scheme
#       (define (analyze-if exp)
#         (let ((pproc (analyze (if-predicate exp)))
#               (cproc (analyze (if-consequent exp)))
#               (aproc (analyze (if-alternative exp))))
#           (lambda (env)
#             (if (true? (pproc env))
#                 (cproc env)
#                 (aproc env)))))
#     < src..
    ..src > scheme
      (define (analyze-if exp)
        (let ((pproc (analyze (if-predicate exp)))
              (cproc (analyze (if-consequent exp)))
              (aproc (analyze (if-alternative exp))))
          (lambda (env)
            (if (true? (pproc env))
                (cproc env)
                (aproc env)))))
    < src..

#     Analyzing a @c(lambda) expression also achieves a major gain in efficiency: We
#     analyze the @c(lambda) body only once, even though procedures resulting from
#     evaluation of the @c(lambda) may be applied many times.
    Analizar una expresión @c(lambda) también logra una mayor ganancia de
    eficiencia: Analizamos el @c(lambda) cuerpo sólo una vez, aunque los
    procedimientos resultantes de la evaluación de la @c(lambda) puede ser
    aplicado muchas veces.

#     ..src > scheme
#       (define (analyze-lambda exp)
#         (let ((vars (lambda-parameters exp))
#               (bproc (analyze-sequence
#                       (lambda-body exp))))
#           (lambda (env)
#             (make-procedure vars bproc env))))
#     < src..
    ..src > scheme
      (define (analyze-lambda exp)
        (let ((vars (lambda-parameters exp))
              (bproc (analyze-sequence
                      (lambda-body exp))))
          (lambda (env)
            (make-procedure vars bproc env))))
    < src..

#     Analysis of a sequence of expressions (as in a @c(begin) or the body of a
#     @c(lambda) expression) is more involved.@n(234) Each expression in the
#     sequence is analyzed, yielding an execution procedure. These execution
#     procedures are combined to produce an execution procedure that takes an
#     environment as argument and sequentially calls each individual execution
#     procedure with the environment as argument.
    El análisis de una secuencia de expresiones (como en a @c(begin) o el cuerpo
    de una expresión @c(lambda)) es más complicado.@n(234) Cada expresión
    en la secuencia se analiza, dando lugar a un procedimiento de
    ejecución. Estos procedimientos de ejecución se combinan para producir un
    procedimiento de ejecución que toma un entorno como argumento y llama
    secuencialmente cada procedimiento de ejecución individual con el entorno
    como argumento.

#     ..src > scheme
#       (define (analyze-sequence exps)
#         (define (sequentially proc1 proc2)
#           (lambda (env) (proc1 env) (proc2 env)))
#         (define (loop first-proc rest-procs)
#           (if (null? rest-procs)
#               first-proc
#               (loop (sequentially first-proc
#                                   (car rest-procs))
#                     (cdr rest-procs))))
#         (let ((procs (map analyze exps)))
#           (if (null? procs)
#               (error "Empty sequence: ANALYZE"))
#           (loop (car procs) (cdr procs))))
#     < src..
    ..src > scheme
      (define (analyze-sequence exps)
        (define (sequentially proc1 proc2)
          (lambda (env) (proc1 env) (proc2 env)))
        (define (loop first-proc rest-procs)
          (if (null? rest-procs)
              first-proc
              (loop (sequentially first-proc
                                  (car rest-procs))
                    (cdr rest-procs))))
        (let ((procs (map analyze exps)))
          (if (null? procs)
              (error "Empty sequence: ANALYZE"))
          (loop (car procs) (cdr procs))))
    < src..

#     To analyze an application, we analyze the operator and operands and construct
#     an execution procedure that calls the operator execution procedure (to obtain
#     the actual procedure to be applied) and the operand execution procedures (to
#     obtain the actual arguments). We then pass these to @c(execute-application),
#     which is the analog of @c(apply) in section @l(#4.1.1). @c(Execute-application)
#     differs from @c(apply) in that the procedure body for a compound procedure has
#     already been analyzed, so there is no need to do further analysis. Instead, we
#     just call the execution procedure for the body on the extended environment.
    Para analizar una aplicación, analizamos el operador y los operandos y
    construimos un procedimiento de ejecución que llama al procedimiento de
    ejecución del operador (para obtener el procedimiento actual a aplicar) y
    los procedimientos de ejecución del operando (para obtener los argumentos
    reales). A continuación, pasamos a estos @c(execute-application), que es el
    análogo de @c(apply) en la seccion @l(#4.1.1). @c(Execute-application) Difiere
    de @c(apply) que el cuerpo del procedimiento para un procedimiento compuesto
    ya ha sido analizado, por lo que no hay necesidad de hacer más análisis. En
    lugar, apenas llamamos el procedimiento de ejecución para el cuerpo en el
    ambiente extendido.

#     ..src > scheme
#       (define (analyze-application exp)
#         (let ((fproc (analyze (operator exp)))
#               (aprocs (map analyze (operands exp))))
#           (lambda (env)
#             (execute-application
#              (fproc env)
#              (map (lambda (aproc) (aproc env))
#                   aprocs)))))
#
#       (define (execute-application proc args)
#         (cond ((primitive-procedure? proc)
#                (apply-primitive-procedure proc args))
#               ((compound-procedure? proc)
#                ((procedure-body proc)
#                 (extend-environment
#                  (procedure-parameters proc)
#                  args
#                  (procedure-environment proc))))
#               (else (error "Unknown procedure type:
#                             EXECUTE-APPLICATION"
#                            proc))))
#     < src..
    ..src > scheme
      (define (analyze-application exp)
        (let ((fproc (analyze (operator exp)))
              (aprocs (map analyze (operands exp))))
          (lambda (env)
            (execute-application
             (fproc env)
             (map (lambda (aproc) (aproc env))
                  aprocs)))))

      (define (execute-application proc args)
        (cond ((primitive-procedure? proc)
               (apply-primitive-procedure proc args))
              ((compound-procedure? proc)
               ((procedure-body proc)
                (extend-environment
                 (procedure-parameters proc)
                 args
                 (procedure-environment proc))))
              (else (error "Unknown procedure type:
                            EXECUTE-APPLICATION"
                           proc))))
    < src..

#     Our new evaluator uses the same data structures, syntax procedures, and
#     run-time support procedures as in section @l(#4.1.2), @l(#4.1.3), and @l(#4.1.4).
    Nuestro nuevo evaluador utiliza las mismas estructuras de datos,
    procedimientos de sintaxis y procedimientos de soporte en tiempo de
    ejecución como en la seccion @l(#4.1.2), @l(#4.1.3) y @l(#4.1.4).

#     :: @t(Exercise 4.22) :: Extend the evaluator in this section to support the
#        special form @c(let). (See @l(#Exercise 4.6).)
    :: @t(Ejercicio 4.22) :: Extienda el evaluador en esta sección para apoyar
       el formulario especial @c(let). (Véase el @l(#Ejercicio
       4.6) .)

#     :: @t(Exercise 4.23) :: Alyssa P. Hacker doesn't understand why
#        @c(analyze-sequence) needs to be so complicated. All the other analysis
#        procedures are straightforward transformations of the corresponding
#        evaluation procedures (or @c(eval) clauses) in section @l(#4.1.1). She expected
#        @c(analyze-sequence) to look like this:
    :: @t(Ejercicio 4.23) :: Alyssa P. Hacker no entiende por qué
       @c(analyze-sequence) tiene que ser tan complicado. Todos los demás
       procedimientos de análisis son transformaciones directas de los
       procedimientos de evaluación (o @c(eval) cláusulas) correspondientes en
       @l(#4.1.1). Ella esperaba @c(analyze-sequence) verse así:

#        ..src > scheme
#          (define (analyze-sequence exps)
#            (define (execute-sequence procs env)
#              (cond ((null? (cdr procs))
#                     ((car procs) env))
#                    (else ((car procs) env)
#                          (execute-sequence
#                           (cdr procs) env))))
#            (let ((procs (map analyze exps)))
#              (if (null? procs)
#                  (error "Empty sequence:
#                          ANALYZE"))
#              (lambda (env)
#                (execute-sequence procs env))))
#        < src..
       ..src > scheme
         (define (analyze-sequence exps)
           (define (execute-sequence procs env)
             (cond ((null? (cdr procs))
                    ((car procs) env))
                   (else ((car procs) env)
                         (execute-sequence
                          (cdr procs) env))))
           (let ((procs (map analyze exps)))
             (if (null? procs)
                 (error "Empty sequence:
                         ANALYZE"))
             (lambda (env)
               (execute-sequence procs env))))
       < src..

#        Eva Lu Ator explains to Alyssa that the version in the text does more of
#        the work of evaluating a sequence at analysis time. Alyssa's
#        sequence-execution procedure, rather than having the calls to the
#        individual execution procedures built in, loops through the procedures in
#        order to call them: In effect, although the individual expressions in the
#        sequence have been analyzed, the sequence itself has not been.
       Eva Lu Ator explica a Alyssa que la versión en el texto hace más del
       trabajo de evaluar una secuencia en el momento del análisis. El
       procedimiento de ejecución de secuencia de Alyssa, en lugar de tener las
       llamadas a los procedimientos de ejecución individuales incorporados,
       recorre los procedimientos para llamarlos: En efecto, aunque las
       expresiones individuales en la secuencia han sido analizadas, la
       secuencia en sí no ha sido.

#        Compare the two versions of @c(analyze-sequence). For example, consider the
#        common case (typical of procedure bodies) where the sequence has just one
#        expression. What work will the execution procedure produced by Alyssa's
#        program do?  What about the execution procedure produced by the program in
#        the text above?  How do the two versions compare for a sequence with two
#        expressions?
       Compare las dos versiones de @c(analyze-sequence). Por ejemplo, considere
       el caso común (típico de los cuerpos de procedimiento) donde la secuencia
       tiene sólo una expresión. ¿Qué trabajo realizará el procedimiento de
       ejecución producido por el programa de Alyssa? ¿Qué pasa con el
       procedimiento de ejecución producido por el programa en el texto
       anterior? ¿Cómo se comparan las dos versiones para una secuencia con dos
       expresiones?

#     :: @t(Exercise 4.24) :: Design and carry out some experiments to compare the
#        speed of the original metacircular evaluator with the version in this
#        section. Use your results to estimate the fraction of time that is spent in
#        analysis versus execution for various procedures.
    :: @t(Ejercicio 4.24) :: Diseñar y llevar a cabo algunos experimentos para
       comparar la velocidad del evaluador metacircular original con la versión
       de esta sección. Utilice sus resultados para estimar la fracción de
       tiempo que se gasta en el análisis frente a la ejecución de varios
       procedimientos.

# ** 4.2 <> Variations on a Scheme –– Lazy Evaluation
** 4.2 <> Variaciones en un esquema - Evaluación perezosa

#    Now that we have an evaluator expressed as a Lisp program, we can experiment
#    with alternative choices in language design simply by modifying the evaluator.
#    Indeed, new languages are often invented by first writing an evaluator that
#    embeds the new language within an existing high-level language. For example,
#    if we wish to discuss some aspect of a proposed modification to Lisp with
#    another member of the Lisp community, we can supply an evaluator that embodies
#    the change. The recipient can then experiment with the new evaluator and send
#    back comments as further modifications. Not only does the high-level
#    implementation base make it easier to test and debug the evaluator; in
#    addition, the embedding enables the designer to snarf@n(235) features from the
#    underlying language, just as our embedded Lisp evaluator uses primitives and
#    control structure from the underlying Lisp. Only later (if ever) need the
#    designer go to the trouble of building a complete implementation in a
#    low-level language or in hardware. In this section and the next we explore
#    some variations on Scheme that provide significant additional expressive
#    power.
   Ahora que tenemos un evaluador expresado como un programa Lisp, podemos
   experimentar con opciones alternativas en el diseño del lenguaje simplemente
   modificando al evaluador. De hecho, a menudo se inventan nuevos idiomas
   escribiendo primero un evaluador que incorpora el nuevo idioma dentro de un
   lenguaje de alto nivel existente. Por ejemplo, si deseamos discutir algún
   aspecto de una modificación propuesta a Lisp con otro miembro de la comunidad
   Lisp, podemos proporcionar un evaluador que encarne el cambio. El
   destinatario puede experimentar con el nuevo evaluador y enviar comentarios
   como modificaciones adicionales. No sólo la base de implementación de alto
   nivel facilita la prueba y depuración del evaluador; Además, la incrustación
   permite al diseñador snarf@n(235) características del lenguaje
   subyacente, Así como nuestro evaluador Lisp incorporado utiliza primitivas y
   estructura de control del Lisp subyacente. Sólo más tarde (si alguna vez)
   necesita el diseñador se vaya a la molestia de construir una implementación
   completa en un lenguaje de bajo nivel o en hardware. En esta sección y en el
   siguiente exploramos algunas variaciones en Scheme que proporcionan un poder
   expresivo significativo adicional.

# *** 4.2.1 <> Normal Order and Applicative Order
*** 4.2.1 <> Orden normal y orden aplicable

#     in section @l(#1.1), where we began our discussion of models of evaluation, we noted
#     that Scheme is an @e(applicative-order) language, namely, that all the
#     arguments to Scheme procedures are evaluated when the procedure is applied.
#     In contrast, @e(normal-order) languages delay evaluation of procedure
#     arguments until the actual argument values are needed. Delaying evaluation of
#     procedure arguments until the last possible moment (e.g., until they are
#     required by a primitive operation) is called @e(lazy evaluation).@n(236)
#     Consider the procedure
    en la seccion @l(#1.1), donde comenzamos nuestra discusión sobre los modelos de
    evaluación, observamos que Scheme es un lenguaje de @e(orden aplicacional),
    es decir, que todos los argumentos a los procedimientos de Scheme se evalúan
    cuando se aplica el procedimiento. En cambio, @e(los) lenguajes de @e(orden
    normal) demoran la evaluación de los argumentos de procedimiento hasta que
    se necesitan los valores de los argumentos reales. Retrasar la evaluación de
    los argumentos de procedimiento hasta el último momento posible (por
    ejemplo, hasta que sean requeridos por una operación primitiva) se denomina
    @e(evaluación perezosa).@n(236) Considere el procedimiento

#     ..src > scheme
#       (define (try a b)
#         (if (= a 0) 1 b))
#     < src..
    ..src > scheme
      (define (try a b)
        (if (= a 0) 1 b))
    < src..

#     Evaluating @c[(try 0 (/ 1 0))] generates an error in Scheme. With lazy
#     evaluation, there would be no error. Evaluating the expression would return 1,
#     because the argument @c[(/ 1 0)] would never be evaluated.
    La evaluación @c[(try 0 (/ 1 0))] genera un error en Scheme. Con la
    evaluación perezosa, no habría error. La evaluación de la expresión
    devolvería 1, porque el argumento @c[(/ 1 0)] nunca sería evaluado.

#     An example that exploits lazy evaluation is the definition of a procedure
#     @c(unless)
    Un ejemplo que explora la evaluación perezosa es la definición de un
    procedimiento @c(unless)

#     ..src > scheme
#       (define (unless condition
#                       usual-value
#                       exceptional-value)
#         (if condition
#             exceptional-value
#             usual-value))
#     < src..
    ..src > scheme
      (define (unless condition
                      usual-value
                      exceptional-value)
        (if condition
            exceptional-value
            usual-value))
    < src..

#     that can be used in expressions such as
    Que se pueden utilizar en expresiones tales como

#     ..src > scheme
#       (unless (= b 0)
#               (/ a b)
#               (begin
#                 (display "exception: returning 0")
#                 0))
#     < src..
    ..src > scheme
      (unless (= b 0)
              (/ a b)
              (begin
                (display "exception: returning 0")
                0))
    < src..

#     This won't work in an applicative-order language because both the usual value
#     and the exceptional value will be evaluated before @c(unless) is called
#     (compare @l(#Exercise 1.6)). An advantage of lazy evaluation is that some
#     procedures, such as @c(unless), can do useful computation even if evaluation
#     of some of their arguments would produce errors or would not terminate.
    Esto no funcionará en un lenguaje de orden aplicacional porque tanto el
    valor normal como el valor excepcional serán evaluados antes de que
    @c(unless) se llame (compare @l(#Ejercicio 1.6) ). Una ventaja
    de la evaluación perezosa es que algunos procedimientos, como @c(unless),
    pueden hacer cálculos útiles incluso si la evaluación de algunos de sus
    argumentos producirá errores o no terminará.

#     If the body of a procedure is entered before an argument has been evaluated we
#     say that the procedure is @e(non-strict) in that argument. If the argument is
#     evaluated before the body of the procedure is entered we say that the
#     procedure is @e(strict) in that argument.@n(237) In a purely applicative-order
#     language, all procedures are strict in each argument. In a purely normal-order
#     language, all compound procedures are non-strict in each argument, and
#     primitive procedures may be either strict or non-strict. There are also
#     languages (see @l(#Exercise 4.31)) that give programmers detailed control over
#     the strictness of the procedures they define.
    Si el cuerpo de un procedimiento se introduce antes de que un argumento haya
    sido evaluado, decimos que el procedimiento @e(no) es @e(estricto) en ese
    argumento. Si el argumento se evalúa antes de introducir el cuerpo del
    procedimiento, decimos que el procedimiento es @e(estricto) en ese
    argumento.@n(237) En un lenguaje de orden puramente aplicacional,
    todos los procedimientos son estrictos en cada argumento. En un lenguaje de
    orden normal, todos los procedimientos compuestos no son estrictos en cada
    argumento y los procedimientos primitivos pueden ser estrictos o no
    estrictos. También hay lenguajes (véase el @l(#Ejercicio
    4.31) ) que dan a los programadores un control detallado de la rigurosidad
    de los procedimientos que definen.

#     A striking example of a procedure that can usefully be made non-strict is
#     @c(cons) (or, in general, almost any constructor for data structures). One can
#     do useful computation, combining elements to form data structures and
#     operating on the resulting data structures, even if the values of the elements
#     are not known. It makes perfect sense, for instance, to compute the length of
#     a list without knowing the values of the individual elements in the list. We
#     will exploit this idea in section @l(#4.2.3) to implement the streams of
#     @l(#Chapter 3) as lists formed of non-strict @c(cons) pairs.
    Un ejemplo llamativo de un procedimiento que puede hacerse útil no es
    estricto es @c(cons)(o, en general, casi cualquier constructor de
    estructuras de datos). Se puede hacer computación útil, combinando elementos
    para formar estructuras de datos y operando sobre las estructuras de datos
    resultantes, incluso si los valores de los elementos no son conocidos. Tiene
    sentido, por ejemplo, calcular la longitud de una lista sin conocer los
    valores de los elementos individuales de la lista. Exploraremos esta idea en
    @l(#4.2.3) para implementar los flujos del @l(#Capitulo 3)
    como listas formadas de @c(cons) pares no estrictos.

#     :: @t(Exercise 4.25) :: Suppose that (in ordinary applicative-order Scheme) we
#        define @c(unless) as shown above and then define @c(factorial) in terms of
#        @c(unless) as
    :: @t(Ejercicio 4.25) :: Supongamos que (en ordinario aplicativo orden
       Scheme) definimos @c(unless) como se muestra arriba y luego definir
       @c(factorial) en términos de @c(unless) como

#        ..src > scheme
#          (define (factorial n)
#            (unless (= n 1)
#                    (* n (factorial (- n 1)))
#                    1))
#        < src..
       ..src > scheme
         (define (factorial n)
           (unless (= n 1)
                   (* n (factorial (- n 1)))
                   1))
       < src..

#        What happens if we attempt to evaluate @c[(factorial 5)]?  Will our
#        definitions work in a normal-order language?
       ¿Qué pasa si intentamos evaluar @c[(factorial 5)]? ¿Funcionarán nuestras
       definiciones en un lenguaje de orden normal?

#     :: @t(Exercise 4.26) :: Ben Bitdiddle and Alyssa P. Hacker disagree over the
#        importance of lazy evaluation for implementing things such as
#        @c(unless). Ben points out that it's possible to implement @c(unless) in
#        applicative order as a special form. Alyssa counters that, if one did that,
#        @c(unless) would be merely syntax, not a procedure that could be used in
#        conjunction with higher-order procedures. Fill in the details on both sides
#        of the argument. Show how to implement @c(unless) as a derived expression
#        (like @c(cond) or @c(let)), and give an example of a situation where it
#        might be useful to have @c(unless) available as a procedure, rather than as
#        a special form.
    :: @t(Ejercicio 4.26) :: Ben Bitdiddle y Alyssa P. Hacker no están de
       acuerdo sobre la importancia de la evaluación perezosa para implementar
       cosas como @c(unless). Ben señala que es posible implementar @c(unless)
       en orden aplicacional como una forma especial. Alyssa contesta que, si se
       hiciera eso, @c(unless) sería simplemente sintaxis, no un procedimiento
       que podría ser usado en conjunción con procedimientos de orden
       superior. Rellene los detalles en ambos lados del argumento. Mostrar cómo
       implementar @c(unless) como una expresión derivada (como @c(cond) or
       @c(let)), y dar un ejemplo de una situación en la que podría ser útil
       tener @c(unless) disponible como un procedimiento, en lugar de como una
       forma especial.

# *** 4.2.2 <> An Interpreter with Lazy Evaluation
*** 4.2.2 <> Un intérprete con una evaluación perezosa

#     In this section we will implement a normal-order language that is the same as
#     Scheme except that compound procedures are non-strict in each argument.
#     Primitive procedures will still be strict. It is not difficult to modify the
#     evaluator of section @l(#4.1.1) so that the language it interprets behaves this
#     way. Almost all the required changes center around procedure application.
    En esta sección implementaremos un lenguaje de orden normal que es el mismo
    que Scheme, excepto que los procedimientos compuestos no son estrictos en
    cada argumento. Los procedimientos primitivos seguirán siendo estrictos. No
    es difícil modificar el evaluador de la seccion @l(#4.1.1) para que el lenguaje
    que interpreta se comporte de esta manera. Casi todos los cambios necesarios
    se centran en la aplicación del procedimiento.

#     The basic idea is that, when applying a procedure, the interpreter must
#     determine which arguments are to be evaluated and which are to be delayed. The
#     delayed arguments are not evaluated; instead, they are transformed into
#     objects called @e(thunks).@n(238) The thunk must contain the information
#     required to produce the value of the argument when it is needed, as if it had
#     been evaluated at the time of the application. Thus, the thunk must contain
#     the argument expression and the environment in which the procedure application
#     is being evaluated.
    La idea básica es que, al aplicar un procedimiento, el intérprete debe
    determinar qué argumentos deben evaluarse y cuáles deben ser retrasados. Los
    argumentos demorados no se evalúan; En cambio, se transforman en objetos
    llamados @e(thunks).@n(238) El thunk debe contener la información
    necesaria para producir el valor del argumento cuando sea necesario, como si
    hubiera sido evaluado en el momento de la solicitud. Por lo tanto, el thunk
    debe contener la expresión del argumento y el entorno en el que se está
    evaluando la aplicación del procedimiento.

#     The process of evaluating the expression in a thunk is called
#     @e(forcing).@n(239) In general, a thunk will be forced only when its value is
#     needed: when it is passed to a primitive procedure that will use the value of
#     the thunk; when it is the value of a predicate of a conditional; and when it
#     is the value of an operator that is about to be applied as a procedure. One
#     design choice we have available is whether or not to @e(memoize) thunks, as we
#     did with delayed objects in section @l(#3.5.1). With memoization, the first time a
#     thunk is forced, it stores the value that is computed. Subsequent forcings
#     simply return the stored value without repeating the computation. We'll make
#     our interpreter memoize, because this is more efficient for many applications.
#     There are tricky considerations here, however.@n(240)
    El proceso de evaluar la expresión en un thunk se llama
    @e(forzar).@n(239) En general, un thunk se forzará sólo cuando su
    valor sea necesario: cuando se pasa a un procedimiento primitivo que
    utilizará el valor del thunk; Cuando es el valor de un predicado de un
    condicional; Y cuando es el valor de un operador que está a punto de ser
    aplicado como un procedimiento. Una elección de diseño que tenemos
    disponible es si se debe o no @e(memorizar) thunks, como lo hicimos con los
    objetos retrasados en la seccion @l(#3.5.1). Con la memorización, la primera vez
    que se invierte un thunk, almacena el valor que se calcula. Los forzamientos
    posteriores simplemente devuelven el valor almacenado sin repetir el
    cálculo. Haremos que nuestro intérprete recuerde, porque esto es más
    eficiente para muchas aplicaciones. Hay consideraciones difíciles aquí, sin
    embargo.@n(240)

# **** Modifying the evaluator
**** Modificación del evaluador

#      The main difference between the lazy evaluator and the one in section @l(#4.1) is in
#      the handling of procedure applications in @c(eval) and @c(apply).
     La principal diferencia entre el evaluador perezoso y el de la seccion @l(#4.1)
     es en el manejo de aplicaciones de procedimiento en @c(eval) y @c(apply).

#      The @c(application?) clause of @c(eval) becomes
     La @c(application?) cláusula de se @c(eval) convierte en

#      ..src > scheme
#        ((application? exp)
#         (apply (actual-value (operator exp) env)
#                (operands exp)
#                env))
#      < src..
     ..src > scheme
       ((application? exp)
        (apply (actual-value (operator exp) env)
               (operands exp)
               env))
     < src..

#      This is almost the same as the @c(application?) clause of @c(eval) in
#      @l(#4.1.1). For lazy evaluation, however, we call @c(apply) with the operand
#      expressions, rather than the arguments produced by evaluating them.  Since we
#      will need the environment to construct thunks if the arguments are to be
#      delayed, we must pass this as well. We still evaluate the operator, because
#      @c(apply) needs the actual procedure to be applied in order to dispatch on its
#      type (primitive versus compound) and apply it.
     Esto es casi la misma que la @c(application?) cláusula de @c(eval) en
     @l(#4.1.1). Para la evaluación perezosa, sin embargo, llamamos
     @c(apply) con las expresiones de los operandos, en lugar de los argumentos
     producidos al evaluarlos. Puesto que necesitaremos el ambiente para
     construir thunks si los argumentos van a ser retrasados, debemos pasar esto
     también. Todavía evaluamos al operador, porque @c(apply) necesita el
     procedimiento real que se aplicará para enviar su tipo (primitivo versus
     compuesto) y aplicarlo.

#      Whenever we need the actual value of an expression, we use
     Siempre que necesitamos el valor real de una expresión, usamos

#      ..src > scheme
#        (define (actual-value exp env)
#          (force-it (eval exp env)))
#      < src..
     ..src > scheme
       (define (actual-value exp env)
         (force-it (eval exp env)))
     < src..

#      instead of just @c(eval), so that if the expression's value is a thunk, it
#      will be forced.
     En lugar de sólo @c(eval), de modo que si el valor de la expresión es un
     thunk, se verá obligado.

#      Our new version of @c(apply) is also almost the same as the version in
#      @l(#4.1.1). The difference is that @c(eval) has passed in unevaluated operand
#      expressions: For primitive procedures (which are strict), we evaluate all the
#      arguments before applying the primitive; for compound procedures (which are
#      non-strict) we delay all the arguments before applying the procedure.
     Nuestra nueva versión de @c(apply) es casi igual que la versión en
     @l(#4.1.1). La diferencia es que @c(eval) ha pasado en expresiones
     de operandos sin valor: Para procedimientos primitivos (que son estrictos),
     evaluamos todos los argumentos antes de aplicar el primitivo; Para
     procedimientos compuestos (que no son estrictos) retrasamos todos los
     argumentos antes de aplicar el procedimiento.

#      ..src > scheme
#        (define (apply procedure arguments env)
#          (cond ((primitive-procedure? procedure)
#                 (apply-primitive-procedure
#                  procedure
#                  (list-of-arg-values
#                   arguments
#                   env)))  ; changed
#                ((compound-procedure? procedure)
#                 (eval-sequence
#                  (procedure-body procedure)
#                  (extend-environment
#                   (procedure-parameters procedure)
#                   (list-of-delayed-args
#                    arguments
#                    env)   ; changed
#                   (procedure-environment procedure))))
#                (else (error "Unknown procedure
#                              type: APPLY"
#                             procedure))))
#      < src..
     ..src > scheme
       (define (apply procedure arguments env)
         (cond ((primitive-procedure? procedure)
                (apply-primitive-procedure
                 procedure
                 (list-of-arg-values
                  arguments
                  env)))  ; changed
               ((compound-procedure? procedure)
                (eval-sequence
                 (procedure-body procedure)
                 (extend-environment
                  (procedure-parameters procedure)
                  (list-of-delayed-args
                   arguments
                   env)   ; changed
                  (procedure-environment procedure))))
               (else (error "Unknown procedure
                             type: APPLY"
                            procedure))))
     < src..

#      The procedures that process the arguments are just like @c(list-of-values)
#      from @l(#4.1.1), except that @c(list-of-delayed-args) delays the arguments
#      instead of evaluating them, and @c(list-of-arg-values) uses @c(actual-value)
#      instead of @c(eval):
     Los procedimientos que procesan los argumentos son iguales a
     @c(list-of-values) partir de la seccion @l(#4.1.1), excepto que
     @c(list-of-delayed-args) retrasa los argumentos en lugar de la evaluación y
     detección @c(list-of-arg-values) utiliza @c(actual-value) en lugar de
     @c(eval):

#      ..src > scheme
#        (define (list-of-arg-values exps env)
#          (if (no-operands? exps)
#              '()
#              (cons (actual-value
#                     (first-operand exps)
#                     env)
#                    (list-of-arg-values
#                     (rest-operands exps)
#                     env))))
#
#        (define (list-of-delayed-args exps env)
#          (if (no-operands? exps)
#              '()
#              (cons (delay-it
#                     (first-operand exps)
#                     env)
#                    (list-of-delayed-args
#                     (rest-operands exps)
#                     env))))
#      < src..
     ..src > scheme
       (define (list-of-arg-values exps env)
         (if (no-operands? exps)
             '()
             (cons (actual-value
                    (first-operand exps)
                    env)
                   (list-of-arg-values
                    (rest-operands exps)
                    env))))

       (define (list-of-delayed-args exps env)
         (if (no-operands? exps)
             '()
             (cons (delay-it
                    (first-operand exps)
                    env)
                   (list-of-delayed-args
                    (rest-operands exps)
                    env))))
     < src..

#      The other place we must change the evaluator is in the handling of @c(if),
#      where we must use @c(actual-value) instead of @c(eval) to get the value of the
#      predicate expression before testing whether it is true or false:
     El otro lugar debemos cambiar el evaluador está en el manejo de @c(if),
     donde debemos usar en @c(actual-value) lugar de @c(eval) para obtener el
     valor de la expresión de predicado antes de probar si es verdadero o falso:

#      ..src > scheme
#        (define (eval-if exp env)
#          (if (true? (actual-value (if-predicate exp)
#                                   env))
#              (eval (if-consequent exp) env)
#              (eval (if-alternative exp) env)))
#      < src..
     ..src > scheme
       (define (eval-if exp env)
         (if (true? (actual-value (if-predicate exp)
                                  env))
             (eval (if-consequent exp) env)
             (eval (if-alternative exp) env)))
     < src..

#      Finally, we must change the @c(driver-loop) procedure (section @l(#4.1.4)) to use
#      @c(actual-value) instead of @c(eval), so that if a delayed value is propagated
#      back to the read-eval-print loop, it will be forced before being printed. We
#      also change the prompts to indicate that this is the lazy evaluator:
     Finalmente, debemos cambiar el procedimiento @c(driver-loop) (
     @l(#4.1.4)) para usar en @c(actual-value) lugar de @c(eval), de
     modo que si un valor retardado se propaga de nuevo al bucle de
     lectura-eval-print, se forzará antes de ser impreso. También cambiamos las
     indicaciones para indicar que este es el evaluador perezoso:

#      ..src > scheme
#        (define input-prompt  ";;; L-Eval input:")
#        (define output-prompt ";;; L-Eval value:")
#
#        (define (driver-loop)
#          (prompt-for-input input-prompt)
#          (let ((input (read)))
#            (let ((output (actual-value
#                           input
#                           the-global-environment)))
#              (announce-output output-prompt)
#              (user-print output)))
#          (driver-loop))
#      < src..
     ..src > scheme
       (define input-prompt  ";;; L-Eval input:")
       (define output-prompt ";;; L-Eval value:")

       (define (driver-loop)
         (prompt-for-input input-prompt)
         (let ((input (read)))
           (let ((output (actual-value
                          input
                          the-global-environment)))
             (announce-output output-prompt)
             (user-print output)))
         (driver-loop))
     < src..

#      With these changes made, we can start the evaluator and test it. The
#      successful evaluation of the @c(try) expression discussed in section @l(#4.2.1)
#      indicates that the interpreter is performing lazy evaluation:
     Con estos cambios, podemos iniciar el evaluador y probarlo. La evaluación
     exitosa de la @c(try) expresión discutida en la seccion @l(#4.2.1) indica que
     el intérprete está realizando una evaluación perezosa:

#      ..srci > scheme
#        > (define the-global-environment
#        ^   (setup-environment))
#        > (driver-loop)
#        ;;; L-Eval input:
#        > (define (try a b) (if (= a 0) 1 b))
#        ;;; L-Eval value:
#        ok
#        ;;; L-Eval input:
#        > (try 0 (/ 1 0))
#        ;;; L-Eval value:
#        1
#      < srci..
     ..srci > scheme
       > (define the-global-environment
       ^   (setup-environment))
       > (driver-loop)
       ;;; L-Eval input:
       > (define (try a b) (if (= a 0) 1 b))
       ;;; L-Eval value:
       ok
       ;;; L-Eval input:
       > (try 0 (/ 1 0))
       ;;; L-Eval value:
       1
     < srci..

# **** Representing thunks
**** Representación de thunks

#      Our evaluator must arrange to create thunks when procedures are applied to
#      arguments and to force these thunks later. A thunk must package an expression
#      together with the environment, so that the argument can be produced later. To
#      force the thunk, we simply extract the expression and environment from the
#      thunk and evaluate the expression in the environment. We use @c(actual-value)
#      rather than @c(eval) so that in case the value of the expression is itself a
#      thunk, we will force that, and so on, until we reach something that is not a
#      thunk:
     Nuestro evaluador debe arreglar para crear thunks cuando los procedimientos
     se aplican a los argumentos y forzar estos thunks más tarde. Un thunk debe
     empaquetar una expresión junto con el entorno, de modo que el argumento
     pueda ser producido más tarde. Para forzar el thunk, simplemente extraemos
     la expresión y el entorno del thunk y evaluamos la expresión en el
     entorno. Usamos @c(actual-value) más que @c(eval) para que en el caso de
     que el valor de la expresión sea en sí mismo un thunk, lo forzaremos, y así
     sucesivamente, hasta llegar a algo que no es un thunk:

#      ..src > scheme
#        (define (force-it obj)
#          (if (thunk? obj)
#              (actual-value (thunk-exp obj)
#                            (thunk-env obj))
#              obj))
#      < src..
     ..src > scheme
       (define (force-it obj)
         (if (thunk? obj)
             (actual-value (thunk-exp obj)
                           (thunk-env obj))
             obj))
     < src..

#      One easy way to package an expression with an environment is to make a list
#      containing the expression and the environment. Thus, we create a thunk as
#      follows:
     Una manera fácil de empaquetar una expresión con un entorno es hacer una
     lista que contenga la expresión y el entorno. Así, creamos un thunk de la
     siguiente manera:

#      ..src > scheme
#        (define (delay-it exp env)
#          (list 'thunk exp env))
#        (define (thunk? obj) (tagged-list? obj 'thunk))
#        (define (thunk-exp thunk) (cadr thunk))
#        (define (thunk-env thunk) (caddr thunk))
#      < src..
     ..src > scheme
       (define (delay-it exp env)
         (list 'thunk exp env))
       (define (thunk? obj) (tagged-list? obj 'thunk))
       (define (thunk-exp thunk) (cadr thunk))
       (define (thunk-env thunk) (caddr thunk))
     < src..

#      Actually, what we want for our interpreter is not quite this, but rather
#      thunks that have been memoized. When a thunk is forced, we will turn it into
#      an evaluated thunk by replacing the stored expression with its value and
#      changing the @c(thunk) tag so that it can be recognized as already
#      evaluated.@n(241)
     En realidad, lo que queremos para nuestro intérprete no es exactamente
     esto, sino más bien thunks que se han memorizado. Cuando se invierte un
     thunk, lo convertiremos en thunk evaluado reemplazando la expresión
     almacenada por su valor y cambiando la @c(thunk) etiqueta para que pueda
     reconocerse como ya evaluada.@n(241)

#      ..src > scheme
#        (define (evaluated-thunk? obj)
#          (tagged-list? obj 'evaluated-thunk))
#
#        (define (thunk-value evaluated-thunk)
#          (cadr evaluated-thunk))
#
#        (define (force-it obj)
#          (cond ((thunk? obj)
#                 (let ((result
#                        (actual-value
#                         (thunk-exp obj)
#                         (thunk-env obj))))
#                   (set-car! obj 'evaluated-thunk)
#                   ;; replace @c(exp) with its value:
#                   (set-car! (cdr obj) result)
#                   ;; forget unneeded @c(env):
#                   (set-cdr! (cdr obj) '())
#                   result))
#                ((evaluated-thunk? obj)
#                 (thunk-value obj))
#                (else obj)))
#      < src..
     ..src > scheme
       (define (evaluated-thunk? obj)
         (tagged-list? obj 'evaluated-thunk))

       (define (thunk-value evaluated-thunk)
         (cadr evaluated-thunk))

       (define (force-it obj)
         (cond ((thunk? obj)
                (let ((result
                       (actual-value
                        (thunk-exp obj)
                        (thunk-env obj))))
                  (set-car! obj 'evaluated-thunk)
                  ;; replace @c(exp) with its value:
                  (set-car! (cdr obj) result)
                  ;; forget unneeded @c(env):
                  (set-cdr! (cdr obj) '())
                  result))
               ((evaluated-thunk? obj)
                (thunk-value obj))
               (else obj)))
     < src..

#      Notice that the same @c(delay-it) procedure works both with and without
#      memoization.
     Observe que el mismo procedimiento @c(delay-it) funciona con y sin
     memoization.

#      :: @t(Exercise 4.27) :: Suppose we type in the following definitions to the
#         lazy evaluator:
     :: @t(Ejercicio 4.27) :: Supongamos que escribimos las siguientes
        definiciones en el evaluador perezoso:

#         ..src > scheme
#           (define count 0)
#           (define (id x) (set! count (+ count 1)) x)
#         < src..
        ..src > scheme
          (define count 0)
          (define (id x) (set! count (+ count 1)) x)
        < src..

#         Give the missing values in the following sequence of interactions, and
#         explain your answers.@n(242)
        Dé los valores faltantes en la siguiente secuencia de interacciones y
        explique sus respuestas.@n(242)

#         ..srci > scheme
#           > (define w (id (id 10)))
#           ;;; L-Eval input:
#           > count
#           ;;; L-Eval value:
#           > ⟨response⟩
#           ;;; L-Eval input:
#           > w
#           ;;; L-Eval value:
#           > ⟨response⟩
#           ;;; L-Eval input:
#           > count
#           ;;; L-Eval value:
#           > ⟨response⟩
#         < srci..
        ..srci > scheme
          > (define w (id (id 10)))
          ;;; L-Eval input:
          > count
          ;;; L-Eval value:
          > ⟨response⟩
          ;;; L-Eval input:
          > w
          ;;; L-Eval value:
          > ⟨response⟩
          ;;; L-Eval input:
          > count
          ;;; L-Eval value:
          > ⟨response⟩
        < srci..

#      :: @t(Exercise 4.28) :: @c(Eval) uses @c(actual-value) rather than @c(eval) to
#         evaluate the operator before passing it to @c(apply), in order to force the
#         value of the operator. Give an example that demonstrates the need for this
#         forcing.
     :: @t(Ejercicio 4.28) :: @c(Eval) Utiliza en @c(actual-value) lugar de
        @c(eval) evaluar al operador antes de pasarlo a @c(apply), con el fin de
        forzar el valor del operador. Dé un ejemplo que demuestre la necesidad
        de este forzamiento.

#      :: @t(Exercise 4.29) :: Exhibit a program that you would expect to run much
#         more slowly without memoization than with memoization.  Also, consider the
#         following interaction, where the @c(id) procedure is defined as in
#         @l(#Exercise 4.27) and @c(count) starts at 0:
     :: @t(Ejercicio 4.29) :: Exponga un programa que usted esperaría para
        funcionar mucho más lentamente sin memoization que con
        memoization. Además, considere la siguiente interacción, donde el
        procedimiento @c(id) se define como en el @l(#Ejercicio 4.27) y
        @c(count) comienza en 0:

#         ..srci > scheme
#           > (define (square x) (* x x))
#           ;;; L-Eval input:
#           > (square (id 10))
#           ;;; L-Eval value:
#           > ⟨response⟩
#           ;;; L-Eval input:
#           > count
#           ;;; L-Eval value:
#           > ⟨response⟩
#         < srci..
        ..srci > scheme
          > (define (square x) (* x x))
          ;;; L-Eval input:
          > (square (id 10))
          ;;; L-Eval value:
          > ⟨response⟩
          ;;; L-Eval input:
          > count
          ;;; L-Eval value:
          > ⟨response⟩
        < srci..

#         Give the responses both when the evaluator memoizes and when it does not.
        Dar las respuestas tanto cuando el evaluador de notas y cuando no lo
        hace.

#      :: @t(Exercise 4.30) :: Cy D. Fect, a reformed C programmer, is worried that
#         some side effects may never take place, because the lazy evaluator doesn't
#         force the expressions in a sequence. Since the value of an expression in a
#         sequence other than the last one is not used (the expression is there only
#         for its effect, such as assigning to a variable or printing), there can be
#         no subsequent use of this value (e.g., as an argument to a primitive
#         procedure) that will cause it to be forced. Cy thus thinks that when
#         evaluating sequences, we must force all expressions in the sequence except
#         the final one. He proposes to modify @c(eval-sequence) from @l(#4.1.1) to
#         use @c(actual-value) rather than @c(eval):
     :: @t(Ejercicio 4.30) :: Cy D. Fect, un programador C reformado, está
        preocupado de que algunos efectos secundarios nunca se produzcan, porque
        el evaluador perezoso no fuerza las expresiones en una secuencia. Dado
        que no se utiliza el valor de una expresión en una secuencia distinta de
        la última (la expresión sólo existe para su efecto, como la asignación a
        una variable o la impresión), no puede utilizarse posteriormente este
        valor (por ejemplo, como Un argumento a un procedimiento primitivo) que
        hará que sea forzado. Cy piensa así que al evaluar las secuencias,
        debemos forzar todas las expresiones en la secuencia excepto la
        final. Propone modificar @c(eval-sequence) de la seccion @l(#4.1.1) a
        utilizar en @c(actual-value) lugar de @c(eval):

#         ..src > scheme
#           (define (eval-sequence exps env)
#             (cond ((last-exp? exps)
#                    (eval (first-exp exps) env))
#                   (else
#                    (actual-value (first-exp exps)
#                                  env)
#                    (eval-sequence (rest-exps exps)
#                                   env))))
#         < src..
        ..src > scheme
          (define (eval-sequence exps env)
            (cond ((last-exp? exps)
                   (eval (first-exp exps) env))
                  (else
                   (actual-value (first-exp exps)
                                 env)
                   (eval-sequence (rest-exps exps)
                                  env))))
        < src..

#         1. Ben Bitdiddle thinks Cy is wrong. He shows Cy the @c(for-each) procedure
#            described in @l(#Exercise 2.23), which gives an important example of a
#            sequence with side effects:
        1. Ben Bitdiddle piensa que Cy está equivocado. Muestra Cy el
           procedimiento @c(for-each) descrito en el
           @l(#Ejercicio 2.23), que da un ejemplo importante de
           una secuencia con efectos secundarios:

#            ..src > scheme
#              (define (for-each proc items)
#                (if (null? items)
#                    'done
#                    (begin (proc (car items))
#                           (for-each proc
#                                     (cdr items)))))
#            < src..
           ..src > scheme
             (define (for-each proc items)
               (if (null? items)
                   'done
                   (begin (proc (car items))
                          (for-each proc
                                    (cdr items)))))
           < src..

#            He claims that the evaluator in the text (with the original
#            @c(eval-sequence)) handles this correctly:
           Afirma que el evaluador en el texto (con el original
           @c(eval-sequence)) maneja esto correctamente:

#            ..srci > scheme
#              ;;; L-Eval input:
#              > (for-each
#              ^  (lambda (x) (newline) (display x))
#              ^  (list 57 321 88))
#              57
#              321
#              88
#
#              ;;; L-Eval value:
#              > done
#            < srci..
           ..srci > scheme
             ;;; L-Eval input:
             > (for-each
             ^  (lambda (x) (newline) (display x))
             ^  (list 57 321 88))
             57
             321
             88

             ;;; L-Eval value:
             > done
           < srci..

#            Explain why Ben is right about the behavior of @c(for-each).
           Explique por qué Ben tiene razón sobre el comportamiento de
           @c(for-each).

#         2. Cy agrees that Ben is right about the @c(for-each) example, but says
#            that that's not the kind of program he was thinking about when he
#            proposed his change to @c(eval-sequence). He defines the following two
#            procedures in the lazy evaluator:
        2. Cy está de acuerdo en que Ben tiene razón sobre el @c(for-each)
           ejemplo, pero dice que ese no es el tipo de programa en el que estaba
           pensando cuando propuso su cambio @c(eval-sequence). Él define los
           dos procedimientos siguientes en el evaluador perezoso:

#            ..src > scheme
#              (define (p1 x)
#                (set! x (cons x '(2))) x)
#
#              (define (p2 x)
#                (define (p e) e x)
#                (p (set! x (cons x '(2)))))
#            < src..
           ..src > scheme
             (define (p1 x)
               (set! x (cons x '(2))) x)

             (define (p2 x)
               (define (p e) e x)
               (p (set! x (cons x '(2)))))
           < src..

#            What are the values of @c[(p1 1)] and @c[(p2 1)] with the original
#            @c(eval-sequence)?  What would the values be with Cy's proposed change
#            to @c(eval-sequence)?
           ¿Cuáles son los valores de @c[(p1 1)] y @c[(p2 1)] con el original
           @c(eval-sequence)? ¿Cuáles serían los valores con el cambio propuesto
           por Cy @c(eval-sequence)?

#         3. Cy also points out that changing @c(eval-sequence) as he proposes does
#            not affect the behavior of the example in part a. Explain why this is
#            true.
        3. Cy también señala que el cambio @c(eval-sequence) como él propone no
           afecta el comportamiento del ejemplo en la parte a. Explique por qué
           esto es cierto.

#         4. How do you think sequences ought to be treated in the lazy evaluator?
#            Do you like Cy's approach, the approach in the text, or some other
#            approach?
        4. ¿Cómo crees que las secuencias deben ser tratadas en el evaluador
           perezoso? ¿Te gusta el enfoque de Cy, el enfoque en el texto, o algún
           otro enfoque?

#      :: @t(Exercise 4.31) :: The approach taken in this section is somewhat
#         unpleasant, because it makes an incompatible change to Scheme. It might be
#         nicer to implement lazy evaluation as an @e(upward-compatible extension),
#         that is, so that ordinary Scheme programs will work as before. We can do
#         this by extending the syntax of procedure declarations to let the user
#         control whether or not arguments are to be delayed. While we're at it, we
#         may as well also give the user the choice between delaying with and without
#         memoization. For example, the definition
     :: @t(Ejercicio 4.31) :: El enfoque adoptado en esta sección es algo
        desagradable, ya que hace un cambio incompatible en Scheme. Podría ser
        más agradable implementar la evaluación perezosa como una @e(extensión
        compatible ascendente), es decir, para que los programas comunes de
        Scheme funcionen como antes. Podemos hacerlo ampliando la sintaxis de
        las declaraciones de procedimiento para permitir al usuario controlar si
        los argumentos deben o no ser retrasados. Mientras estamos en ello,
        podemos también dar al usuario la opción entre retrasar con y sin
        memoization. Por ejemplo, la definición

#         ..src > scheme
#           (define (f a (b lazy) c (d lazy-memo))
#             …)
#         < src..
        ..src > scheme
          (define (f a (b lazy) c (d lazy-memo))
            …)
        < src..

#         would define @c(f) to be a procedure of four arguments, where the first and
#         third arguments are evaluated when the procedure is called, the second
#         argument is delayed, and the fourth argument is both delayed and
#         memoized. Thus, ordinary procedure definitions will produce the same
#         behavior as ordinary Scheme, while adding the @c(lazy-memo) declaration to
#         each parameter of every compound procedure will produce the behavior of the
#         lazy evaluator defined in this section. Design and implement the changes
#         required to produce such an extension to Scheme. You will have to implement
#         new syntax procedures to handle the new syntax for @c(define). You must
#         also arrange for @c(eval) or @c(apply) to determine when arguments are to
#         be delayed, and to force or delay arguments accordingly, and you must
#         arrange for forcing to memoize or not, as appropriate.
        Se definiría @c(f) como un procedimiento de cuatro argumentos, donde el
        primer y el tercer argumento se evalúan cuando se llama al
        procedimiento, el segundo argumento se retrasa y el cuarto argumento se
        retrasa y se memoriza. Así, las definiciones de procedimiento ordinario
        producirán el mismo comportamiento que Scheme ordinario, mientras que la
        adición de la @c(lazy-memo) declaración a cada parámetro de cada
        procedimiento compuesto producirá el comportamiento del evaluador
        perezoso definido en esta sección. Diseñar e implementar los cambios
        necesarios para producir tal extensión a Scheme. Tendrá que implementar
        nuevos procedimientos de sintaxis para manejar la nueva sintaxis
        @c(define). Usted debe también arreglar para @c(eval) o @c(apply) para
        determinar cuándo los argumentos deben ser retrasados, y para forzar o
        retrasar argumentos en consecuencia, y usted debe arreglar para forzar a
        memoize o no,

# *** 4.2.3 <> Streams as Lazy Lists
*** 4.2.3 <> Corrientes como listas perezosas

#     in section @l(#3.5.1), we showed how to implement streams as delayed lists.  We
#     introduced special forms @c(delay) and @c(cons-stream), which allowed us to
#     construct a @"(promise) to compute the @c(cdr) of a stream, without actually
#     fulfilling that promise until later. We could use this general technique of
#     introducing special forms whenever we need more control over the evaluation
#     process, but this is awkward. For one thing, a special form is not a
#     first-class object like a procedure, so we cannot use it together with
#     higher-order procedures.@n(243) Additionally, we were forced to create streams
#     as a new kind of data object similar but not identical to lists, and this
#     required us to reimplement many ordinary list operations (@c(map), @c(append),
#     and so on) for use with streams.
    en la seccion @l(#3.5.1), mostramos cómo implementar los flujos como listas
    retrasadas. Introducimos formas especiales @c(delay) y @c(cons-stream), lo
    que nos permitió construir una @"(promesa) de calcular el @c(cdr) de una
    corriente, sin cumplir realmente esa promesa hasta más tarde. Podríamos
    utilizar esta técnica general de introducir formas especiales cada vez que
    necesitamos más control sobre el proceso de evaluación, pero esto es
    incómodo. Por una parte, una forma especial no es un objeto de primera clase
    como un procedimiento, por lo que no podemos usarlo junto con procedimientos
    de orden superior.@n(243) Además, nos vimos obligados a crear flujos
    como un nuevo tipo de datos de objeto similar pero no idéntica a las listas,
    y esto nos exige volver a implementar muchas operaciones de lista ordinaria
    (@c(map), @c(append), etc.) para su uso con corrientes.

#     With lazy evaluation, streams and lists can be identical, so there is no need
#     for special forms or for separate list and stream operations. All we need to
#     do is to arrange matters so that @c(cons) is non-strict. One way to accomplish
#     this is to extend the lazy evaluator to allow for non-strict primitives, and
#     to implement @c(cons) as one of these. An easier way is to recall (section @l(#2.1.3))
#     that there is no fundamental need to implement @c(cons) as a primitive at
#     all. Instead, we can represent pairs as procedures:@n(244)
    Con la evaluación perezosa, los flujos y las listas pueden ser idénticos,
    por lo que no hay necesidad de formularios especiales ni de operaciones
    separadas de listas y flujos. Todo lo que necesitamos hacer es organizar los
    asuntos de modo que @c(cons) no sea estricto. Una manera de lograr esto es
    extender el evaluador perezoso para permitir primitivas no estrictas, e
    implementar @c(cons) como una de estas. Una manera más fácil es recordar (
    @l(#2.1.3)) que no hay ninguna necesidad fundamental de implementar
    @c(cons) como un primitivo en absoluto. En cambio, podemos representar pares
    como procedimientos:@n(244)

#     ..src > scheme
#       (define (cons x y) (lambda (m) (m x y)))
#       (define (car z) (z (lambda (p q) p)))
#       (define (cdr z) (z (lambda (p q) q)))
#     < src..
    ..src > scheme
      (define (cons x y) (lambda (m) (m x y)))
      (define (car z) (z (lambda (p q) p)))
      (define (cdr z) (z (lambda (p q) q)))
    < src..

#     In terms of these basic operations, the standard definitions of the list
#     operations will work with infinite lists (streams) as well as finite ones, and
#     the stream operations can be implemented as list operations. Here are some
#     examples:
    En términos de estas operaciones básicas, las definiciones estándar de las
    operaciones de lista funcionarán con listas infinitas (secuencias) y
    finitas, y las operaciones de flujo se pueden implementar como operaciones
    de lista. Aquí hay unos ejemplos:

#     ..srci > scheme
#       > (define (list-ref items n)
#       ^   (if (= n 0)
#       ^       (car items)
#       ^       (list-ref (cdr items) (- n 1))))
#       > (define (map proc items)
#       ^   (if (null? items)
#       ^       '()
#       ^       (cons (proc (car items))
#       ^             (map proc (cdr items)))))
#       > (define (scale-list items factor)
#       ^   (map (lambda (x) (* x factor))
#       ^        items))
#       > (define (add-lists list1 list2)
#       ^   (cond ((null? list1) list2)
#       ^         ((null? list2) list1)
#       ^         (else (cons (+ (car list1)
#       ^                        (car list2))
#       ^                     (add-lists
#       ^                      (cdr list1)
#       ^                      (cdr list2))))))
#       > (define ones (cons 1 ones))
#       > (define integers
#       ^   (cons 1 (add-lists ones integers)))
#       ;;; L-Eval input:
#       >  (list-ref integers 17)
#       ;;; L-Eval value:
#       18
#     < srci..
    ..srci > scheme
      > (define (list-ref items n)
      ^   (if (= n 0)
      ^       (car items)
      ^       (list-ref (cdr items) (- n 1))))
      > (define (map proc items)
      ^   (if (null? items)
      ^       '()
      ^       (cons (proc (car items))
      ^             (map proc (cdr items)))))
      > (define (scale-list items factor)
      ^   (map (lambda (x) (* x factor))
      ^        items))
      > (define (add-lists list1 list2)
      ^   (cond ((null? list1) list2)
      ^         ((null? list2) list1)
      ^         (else (cons (+ (car list1)
      ^                        (car list2))
      ^                     (add-lists
      ^                      (cdr list1)
      ^                      (cdr list2))))))
      > (define ones (cons 1 ones))
      > (define integers
      ^   (cons 1 (add-lists ones integers)))
      ;;; L-Eval input:
      >  (list-ref integers 17)
      ;;; L-Eval value:
      18
    < srci..

#     Note that these lazy lists are even lazier than the streams of @l(#Chapter 3):
#     The @c(car) of the list, as well as the @c(cdr), is delayed.@n(245) In fact,
#     even accessing the @c(car) or @c(cdr) of a lazy pair need not force the value
#     of a list element. The value will be forced only when it is really
#     needed––e.g., for use as the argument of a primitive, or to be printed as an
#     answer.
    Tenga en cuenta que estas listas perezosas son incluso más perezosas que las
    corrientes del @l(#Capitulo 3) : El @c(car) de la lista, así como
    el @c(cdr), se retrasa.@n(245) De hecho, incluso el acceso al @c(car)
    o @c(cdr) de un par perezoso no necesita forzar el valor de un elemento de
    lista. El valor sólo se forzará cuando sea realmente necesario, por ejemplo,
    para utilizarlo como argumento de una primitiva o para imprimirse como
    respuesta.

#     Lazy pairs also help with the problem that arose with streams in section @l(#3.5.4),
#     where we found that formulating stream models of systems with loops may
#     require us to sprinkle our programs with explicit @c(delay) operations, beyond
#     the ones supplied by @c(cons-stream). With lazy evaluation, all arguments to
#     procedures are delayed uniformly. For instance, we can implement procedures to
#     integrate lists and solve differential equations as we originally intended in
#     @l(#3.5.4):
    Los pares perezosos también ayudan con el problema que surgió con los
    arroyos en la seccion @l(#3.5.4), donde encontramos que la formulación de
    modelos de flujo de sistemas con bucles puede requerir que espolvoreemos
    nuestros programas con @c(delay) operaciones explícitas, más allá de las
    suministradas por @c(cons-stream). Con la evaluación perezosa, todos los
    argumentos a los procedimientos se retrasan de manera uniforme. Por ejemplo,
    podemos implementar procedimientos para integrar listas y resolver
    ecuaciones diferenciales tal como originalmente se pretendía en
    @l(#3.5.4) :

#     ..srci > scheme
#       > (define (integral integrand initial-value dt)
#       ^   (define int
#       ^     (cons initial-value
#       ^           (add-lists (scale-list integrand dt)
#       ^                      int)))
#       ^   int)
#       > (define (solve f y0 dt)
#       ^   (define y (integral dy y0 dt))
#       ^   (define dy (map f y))
#       ^   y)
#       ;;; L-Eval input:
#       > (list-ref (solve (lambda (x) x) 1 0.001) 1000)
#       ;;; L-Eval value:
#       2.716924
#     < srci..
    ..srci > scheme
      > (define (integral integrand initial-value dt)
      ^   (define int
      ^     (cons initial-value
      ^           (add-lists (scale-list integrand dt)
      ^                      int)))
      ^   int)
      > (define (solve f y0 dt)
      ^   (define y (integral dy y0 dt))
      ^   (define dy (map f y))
      ^   y)
      ;;; L-Eval input:
      > (list-ref (solve (lambda (x) x) 1 0.001) 1000)
      ;;; L-Eval value:
      2.716924
    < srci..

#     :: @t(Exercise 4.32) :: Give some examples that illustrate the difference
#        between the streams of @l(#Chapter 3) and the @"(lazier) lazy lists
#        described in this section. How can you take advantage of this extra
#        laziness?
    :: @t(Ejercicio 4.32) :: Dé algunos ejemplos que ilustran la diferencia
       entre los flujos del @l(#Capitulo 3) y las listas perezosas
       @"(más) perezosas descritas en esta sección. ¿Cómo puede aprovechar esta
       pereza extra?

#     :: @t(Exercise 4.33) :: Ben Bitdiddle tests the lazy list implementation given
#        above by evaluating the expression
    :: @t(Ejercicio 4.33) :: Ben Bitdiddle prueba la implementación de la lista
       perezosa dada anteriormente evaluando la expresión

#        ..src > scheme
#          (car '(a b c))
#        < src..
       ..src > scheme
         (car '(a b c))
       < src..

#        To his surprise, this produces an error. After some thought, he realizes
#        that the @"(lists) obtained by reading in quoted expressions are different
#        from the lists manipulated by the new definitions of @c(cons), @c(car), and
#        @c(cdr). Modify the evaluator's treatment of quoted expressions so that
#        quoted lists typed at the driver loop will produce true lazy lists.
       Para su sorpresa, esto produce un error. Después de pensarlo, se da
       cuenta de que las @"(listas) obtenidas mediante la lectura de las
       expresiones citadas son diferentes de las listas manipulados por las
       nuevas definiciones de @c(cons), @c(car) y @c(cdr). Modifique el
       tratamiento del evaluador de las expresiones entre comillas para que las
       listas citadas escritas en el bucle del controlador produzcan listas
       verdaderamente perezosas.

#     :: @t(Exercise 4.34) :: Modify the driver loop for the evaluator so that lazy
#        pairs and lists will print in some reasonable way.  (What are you going to
#        do about infinite lists?)  You may also need to modify the representation
#        of lazy pairs so that the evaluator can identify them in order to print
#        them.
    :: @t(Ejercicio 4.34) :: Modifique el bucle del controlador para el
       evaluador para que pares perezosos y listas impriman de alguna manera
       razonable. (¿Qué vas a hacer con respecto a las listas infinitas?)
       También puede ser necesario modificar la representación de los pares
       perezosos para que el evaluador pueda identificarlos para poder
       imprimirlos.

# ** 4.3 <> Variations on a Scheme –– Nondeterministic Computing
** 4.3 <> Variaciones en un esquema - Computación no determinista

#    In this section, we extend the Scheme evaluator to support a programming
#    paradigm called @e(nondeterministic computing) by building into the evaluator
#    a facility to support automatic search. This is a much more profound change to
#    the language than the introduction of lazy evaluation in section @l(#4.2).
   En esta sección, ampliamos el evaluador de Scheme para apoyar un paradigma de
   programación llamado @e(computación no determinística), incorporando en el
   evaluador una facilidad para soportar la búsqueda automática. Este es un
   cambio mucho más profundo en el lenguaje que la introducción de la evaluación
   perezosa en la seccion @l(#4.2).

#    Nondeterministic computing, like stream processing, is useful for @"(generate
#    and test) applications. Consider the task of starting with two lists of
#    positive integers and finding a pair of integers––one from the first list and
#    one from the second list––whose sum is prime. We saw how to handle this with
#    finite sequence operations in section @l(#2.2.3) and with infinite streams in
#    @l(#3.5.3). Our approach was to generate the sequence of all possible pairs
#    and filter these to select the pairs whose sum is prime. Whether we actually
#    generate the entire sequence of pairs first as in @l(#Chapter 2), or
#    interleave the generating and filtering as in @l(#Chapter 3), is immaterial to
#    the essential image of how the computation is organized.
   La computación no determinística, como el procesamiento de secuencias, es
   útil para @"(generar y probar) aplicaciones. Considere la tarea de comenzar
   con dos listas de enteros positivos y encontrar un par de números enteros -
   uno de la primera lista y uno de la segunda lista - cuya suma es primo. Vimos
   cómo manejar esto con operaciones de secuencia finita en la seccion @l(#2.2.3) y
   con flujos infinitos en la seccion @l(#3.5.3). Nuestro enfoque fue generar la
   secuencia de todos los pares posibles y filtrarlos para seleccionar los pares
   cuya suma es primo. Si realmente generamos la secuencia entera de pares
   primero como en el @l(#Capitulo 2), o entrelazamos la generación y
   el filtrado como en el @l(#Capitulo 3), es inmaterial a la imagen
   esencial de cómo se organiza el cómputo.

#    The nondeterministic approach evokes a different image. Imagine simply that we
#    choose (in some way) a number from the first list and a number from the second
#    list and require (using some mechanism) that their sum be prime. This is
#    expressed by following procedure:
   El enfoque no determinista evoca una imagen diferente. Imagínese simplemente
   que elegimos (de alguna manera) un número de la primera lista y un número de
   la segunda lista y requerimos (usando algún mecanismo) que su suma sea
   primo. Esto se expresa siguiendo el procedimiento siguiente:

#    ..src > scheme
#      (define (prime-sum-pair list1 list2)
#        (let ((a (an-element-of list1))
#              (b (an-element-of list2)))
#          (require (prime? (+ a b)))
#          (list a b)))
#    < src..
   ..src > scheme
     (define (prime-sum-pair list1 list2)
       (let ((a (an-element-of list1))
             (b (an-element-of list2)))
         (require (prime? (+ a b)))
         (list a b)))
   < src..

#    It might seem as if this procedure merely restates the problem, rather than
#    specifying a way to solve it. Nevertheless, this is a legitimate
#    nondeterministic program.@n(246)
   Podría parecer como si este procedimiento simplemente reafirmar el problema,
   en lugar de especificar una manera de resolverlo. Sin embargo, este es un
   programa legítimo no determinista.@n(246)

#    The key idea here is that expressions in a nondeterministic language can have
#    more than one possible value. For instance, @c(an-element-of) might return any
#    element of the given list. Our nondeterministic program evaluator will work by
#    automatically choosing a possible value and keeping track of the choice. If a
#    subsequent requirement is not met, the evaluator will try a different choice,
#    and it will keep trying new choices until the evaluation succeeds, or until we
#    run out of choices. Just as the lazy evaluator freed the programmer from the
#    details of how values are delayed and forced, the nondeterministic program
#    evaluator will free the programmer from the details of how choices are made.
   La idea clave aquí es que las expresiones en un lenguaje no determinista
   pueden tener más de un valor posible. Por ejemplo, @c(an-element-of) puede
   devolver cualquier elemento de la lista dada. Nuestro evaluador de programa
   no determinista trabajará eligiendo automáticamente un valor posible y
   haciendo un seguimiento de la elección. Si no se cumple un requisito
   subsiguiente, el evaluador intentará una opción diferente, y seguirá
   intentando nuevas opciones hasta que la evaluación tenga éxito, o hasta que
   nos quedemos sin opciones. Así como el evaluador perezoso liberó al
   programador de los detalles de cómo los valores son retrasados y forzados, el
   evaluador de programa no determinista liberará al programador de los detalles
   de cómo se hacen las elecciones.

#    It is instructive to contrast the different images of time evoked by
#    nondeterministic evaluation and stream processing. Stream processing uses lazy
#    evaluation to decouple the time when the stream of possible answers is
#    assembled from the time when the actual stream elements are produced. The
#    evaluator supports the illusion that all the possible answers are laid out
#    before us in a timeless sequence. With nondeterministic evaluation, an
#    expression represents the exploration of a set of possible worlds, each
#    determined by a set of choices. Some of the possible worlds lead to dead ends,
#    while others have useful values. The nondeterministic program evaluator
#    supports the illusion that time branches, and that our programs have different
#    possible execution histories. When we reach a dead end, we can revisit a
#    previous choice point and proceed along a different branch.
   Es instructivo contrastar las diferentes imágenes de tiempo evocadas por la
   evaluación no determinista y el procesamiento de la corriente. El
   procesamiento de secuencias utiliza una evaluación perezosa para desacoplar
   el tiempo cuando se reúne el flujo de respuestas posibles desde el momento en
   que se producen los elementos de flujo reales. El evaluador apoya la ilusión
   de que todas las respuestas posibles se presentan ante nosotros en una
   secuencia atemporal. Con la evaluación no determinista, una expresión
   representa la exploración de un conjunto de mundos posibles, cada uno
   determinado por un conjunto de opciones. Algunos de los mundos posibles
   conducen a callejones sin salida, mientras que otros tienen valores
   útiles. El evaluador de programa no determinista apoya la ilusión de que el
   tiempo se ramifica, y que nuestros programas tienen diferentes historias de
   ejecución posibles. Cuando llegamos a un callejón sin salida,

#    The nondeterministic program evaluator implemented below is called the @c(amb)
#    evaluator because it is based on a new special form called @c(amb). We can
#    type the above definition of @c(prime-sum-pair) at the @c(amb) evaluator
#    driver loop (along with definitions of @c(prime?), @c(an-element-of), and
#    @c(require)) and run the procedure as follows:
   El evaluador de programa no determinístico implementado a continuación se
   denomina @c(amb) evaluador porque se basa en un nuevo formulario especial
   llamado @c(amb). Podemos escribir la definición anterior de
   @c(prime-sum-pair) en el @c(amb) bucle conductor evaluador (junto con las
   definiciones de @c(prime?), @c(an-element-of) y @c(require)) y ejecutar el
   procedimiento como sigue:

#    ..srci > scheme
#      ;;; Amb-Eval input:
#      > (prime-sum-pair '(1 3 5 8) '(20 35 110))
#      ;;; Starting a new problem
#      ;;; Amb-Eval value:
#      (3 20)
#    < srci..
   ..srci > scheme
     ;;; Amb-Eval input:
     > (prime-sum-pair '(1 3 5 8) '(20 35 110))
     ;;; Starting a new problem
     ;;; Amb-Eval value:
     (3 20)
   < srci..

#    The value returned was obtained after the evaluator repeatedly chose elements
#    from each of the lists, until a successful choice was made.
   El valor devuelto se obtuvo después de que el evaluador eligió repetidamente
   elementos de cada una de las listas, hasta que se hizo una elección exitosa.

#    Section @l(#4.3.1) introduces @c(amb) and explains how it supports
#    nondeterminism through the evaluator's automatic search mechanism.  @l(#4.3.2)
#    presents examples of nondeterministic programs, and @l(#4.3.3) gives the
#    details of how to implement the @c(amb) evaluator by modifying the ordinary
#    Scheme evaluator.
   La Sección @l(#4.3.1) presenta @c(amb) y explica cómo apoya el no
   determinismo a través del mecanismo automático de búsqueda del evaluador.
   @l(#4.3.2) presenta ejemplos de programas no determinísticos, y
   @l(#4.3.3) da los detalles de cómo implementar el @c(amb) evaluador
   modificando el evaluador del Scheme ordinario.

# *** 4.3.1 <> Amb and Search
*** 4.3.1 <> Amb y Búsqueda

#     To extend Scheme to support nondeterminism, we introduce a new special form
#     called @c(amb).@n(247) The expression
    Para extender el esquema para apoyar el no determinismo, introducimos una
    nueva forma especial llamada @c(amb).@n(247) La expresión

#     ..src > scheme
#       (amb ⟨e₁⟩ ⟨e₂⟩ … ⟨eₙ⟩)
#     < src..
    ..src > scheme
      (amb ⟨e₁⟩ ⟨e₂⟩ … ⟨eₙ⟩)
    < src..

#     returns the value of one of the @m(n) expressions @m[⟨eᵢ⟩] @"(ambiguously.)
#     For example, the expression
    Devuelve el valor de una de las @m(n) expresiones @m(⟨eᵢ⟩ de forma )
    @"(ambigua. ) Por ejemplo, la expresión

#     ..src > scheme
#       (list (amb 1 2 3) (amb 'a 'b))
#     < src..
    ..src > scheme
      (list (amb 1 2 3) (amb 'a 'b))
    < src..

#     can have six possible values:
    Puede tener seis valores posibles:

#     ..example >
#       (1 a) (1 b) (2 a) (2 b) (3 a) (3 b)
#     < example..
    ..example >
      (1 a) (1 b) (2 a) (2 b) (3 a) (3 b)
    < example..

#     @c(Amb) with a single choice produces an ordinary (single) value.
    @c(Amb) Con una sola opción produce un valor ordinario (único).

#     @c(Amb) with no choices––the expression @c[(amb)]––is an expression with no
#     acceptable values. Operationally, we can think of @c[(amb)] as an expression
#     that when evaluated causes the computation to @"(fail): The computation aborts
#     and no value is produced. Using this idea, we can express the requirement that
#     a particular predicate expression @c(p) must be true as follows:
    @c(Amb) Sin opciones - la expresión @c[(amb)]- es una expresión sin valores
    aceptables. Operacionalmente, podemos pensar @c[(amb)] como una expresión
    que cuando se evalúa hace que el cómputo @"(fracase) : El cómputo aborta y
    no se produce ningún valor. Usando esta idea, podemos expresar el requisito
    de que una expresión particular de predicado @c(p) debe ser verdadera como
    sigue:

#     ..src > scheme
#       (define (require p)
#         (if (not p) (amb)))
#     < src..
    ..src > scheme
      (define (require p)
        (if (not p) (amb)))
    < src..

#     With @c(amb) and @c(require), we can implement the @c(an-element-of) procedure
#     used above:
    Con @c(amb) y @c(require), podemos implementar el procedimiento @c(an-element-of) utilizado anteriormente:

#     ..src > scheme
#       (define (an-element-of items)
#         (require (not (null? items)))
#         (amb (car items)
#              (an-element-of (cdr items))))
#     < src..
    ..src > scheme
      (define (an-element-of items)
        (require (not (null? items)))
        (amb (car items)
             (an-element-of (cdr items))))
    < src..

#     @c(An-element-of) fails if the list is empty. Otherwise it ambiguously returns
#     either the first element of the list or an element chosen from the rest of the
#     list.
    @c(An-element-of) Falla si la lista está vacía. De lo contrario, devuelve de
    forma ambigua el primer elemento de la lista o un elemento elegido del resto
    de la lista.

#     We can also express infinite ranges of choices. The following procedure
#     potentially returns any integer greater than or equal to some given @m(n):
    También podemos expresar infinitas gamas de opciones. El procedimiento
    siguiente devuelve potencialmente cualquier entero mayor o igual que un dado
    @m(n) :

#     ..src > scheme
#       (define (an-integer-starting-from n)
#         (amb n (an-integer-starting-from (+ n 1))))
#     < src..
    ..src > scheme
      (define (an-integer-starting-from n)
        (amb n (an-integer-starting-from (+ n 1))))
    < src..

#     This is like the stream procedure @c(integers-starting-from) described in
#     @l(#3.5.2), but with an important difference: The stream procedure returns an
#     object that represents the sequence of all integers beginning with @m(n),
#     whereas the @c(amb) procedure returns a single integer.@n(248)
    Esto es como el procedimiento de flujo @c(integers-starting-from) descrito
    en la seccion @l(#3.5.2), pero con una diferencia importante: El procedimiento
    de flujo devuelve un objeto que representa la secuencia de todos los enteros
    que empiezan por @m(n), mientras que el procedimiento @c(amb) devuelve un
    solo entero.@n(248)

#     Abstractly, we can imagine that evaluating an @c(amb) expression causes time
#     to split into branches, where the computation continues on each branch with
#     one of the possible values of the expression. We say that @c(amb) represents a
#     @e(nondeterministic choice point). If we had a machine with a sufficient
#     number of processors that could be dynamically allocated, we could implement
#     the search in a straightforward way. Execution would proceed as in a
#     sequential machine, until an @c(amb) expression is encountered. At this point,
#     more processors would be allocated and initialized to continue all of the
#     parallel executions implied by the choice. Each processor would proceed
#     sequentially as if it were the only choice, until it either terminates by
#     encountering a failure, or it further subdivides, or it finishes.@n(249)
    En resumen, podemos imaginar que la evaluación de una @c(amb) expresión hace
    que el tiempo se divida en ramas, donde el cálculo continúa en cada rama con
    uno de los posibles valores de la expresión. Decimos que @c(amb) representa
    un @e(punto de elección no determinista). Si tuviéramos una máquina con un
    número suficiente de procesadores que pudieran ser asignados dinámicamente,
    podríamos implementar la búsqueda de una manera sencilla. La ejecución
    procedería como en una máquina secuencial, hasta @c(amb) que se encuentre
    una expresión. En este punto, más procesadores serían asignados e
    inicializados para continuar con todas las ejecuciones paralelas implícitas
    en la elección. Cada procesador procedería secuencialmente como si fuera la
    única opción, hasta que termina por encontrarse con un fallo, o subdivide o
    termina.@n(249)

#     On the other hand, if we have a machine that can execute only one process (or
#     a few concurrent processes), we must consider the alternatives
#     sequentially. One could imagine modifying an evaluator to pick at random a
#     branch to follow whenever it encounters a choice point. Random choice,
#     however, can easily lead to failing values. We might try running the evaluator
#     over and over, making random choices and hoping to find a non-failing value,
#     but it is better to @e(systematically search) all possible execution
#     paths. The @c(amb) evaluator that we will develop and work with in this
#     section implements a systematic search as follows: When the evaluator
#     encounters an application of @c(amb), it initially selects the first
#     alternative. This selection may itself lead to a further choice. The evaluator
#     will always initially choose the first alternative at each choice point. If a
#     choice results in a failure, then the evaluator automagically@n(250)
#     @e(backtracks) to the most recent choice point and tries the next
#     alternative. If it runs out of alternatives at any choice point, the evaluator
#     will back up to the previous choice point and resume from there. This process
#     leads to a search strategy known as @e(depth-first search) or @e(chronological
#     backtracking).@n(251)
    Por otro lado, si tenemos una máquina que puede ejecutar sólo un proceso (o
    unos pocos procesos concurrentes), debemos considerar las alternativas
    secuencialmente. Se podría imaginar la modificación de un evaluador para
    elegir al azar una rama a seguir cada vez que se encuentra con un punto de
    elección. La elección aleatoria, sin embargo, puede conducir fácilmente a
    los valores que fallan. Podemos tratar de ejecutar el evaluador una y otra
    vez, haciendo elecciones al azar y esperando encontrar un valor que no
    falla, pero es mejor @e(buscar sistemáticamente) todas las posibles rutas de
    ejecución. El @c(amb) evaluador que vamos a desarrollar y trabajar en esta
    sección implementa una búsqueda sistemática de la siguiente manera: Cuando
    el evaluador encuentra una aplicación de @c(amb), inicialmente selecciona la
    primera alternativa. Esta selección puede conducir a otra elección. El
    evaluador siempre seleccionará inicialmente la primera alternativa en cada
    punto de elección.@n(#250<>Si una opción resulta en un fracaso, a
    continuación, el evaluador automágicamente 250) @e( preclasificación) a la
    más reciente punto de elección y trata la siguiente alternativa. Si se queda
    sin alternativas en cualquier punto de elección, el evaluador volverá al
    punto de selección anterior y se reanudará desde allí. Este proceso conduce
    a una estrategia de búsqueda conocida como búsqueda en @e(profundidad) o
    @e(retroceso cronológico).@n(251) El evaluador realizará una copia
    de seguridad hasta el punto de elección anterior y se reanudará desde
    allí. @e(Este proceso conduce a una estrategia de búsqueda conocida como
    búsqueda en profundidad) o @e(retroceso cronológico).@n(251) El
    evaluador realizará una copia de seguridad hasta el punto de elección
    anterior y se reanudará desde allí. @e(Este proceso conduce a una estrategia
    de búsqueda conocida como búsqueda en profundidad) o @e(retroceso
    cronológico).@n(251)

# **** Driver loop
**** Bucle del conductor

#      The driver loop for the @c(amb) evaluator has some unusual properties. It
#      reads an expression and prints the value of the first non-failing execution,
#      as in the @c(prime-sum-pair) example shown above. If we want to see the value
#      of the next successful execution, we can ask the interpreter to backtrack and
#      attempt to generate a second non-failing execution. This is signaled by typing
#      the symbol @c(try-again). If any expression except @c(try-again) is given, the
#      interpreter will start a new problem, discarding the unexplored alternatives
#      in the previous problem. Here is a sample interaction:
     El bucle del controlador para el @c(amb) evaluador tiene algunas
     propiedades inusuales. Lee una expresión e imprime el valor de la primera
     ejecución que no falla, como en el @c(prime-sum-pair) ejemplo mostrado
     anteriormente. Si queremos ver el valor de la siguiente ejecución exitosa,
     podemos pedirle al intérprete que retroceda e intente generar una segunda
     ejecución que no falla. Esto se señaliza escribiendo el símbolo
     @c(try-again). Si se da alguna expresión @c(try-again), el intérprete
     iniciará un nuevo problema, descartando las alternativas inexploradas en el
     problema anterior. Aquí hay una muestra de interacción:

#      ..srci > scheme
#        ;;; Amb-Eval input:
#        > (prime-sum-pair '(1 3 5 8) '(20 35 110))
#        ;;; Starting a new problem
#        ;;; Amb-Eval value:
#        (3 20)
#
#        ;;; Amb-Eval input:
#        > try-again
#
#        ;;; Amb-Eval value:
#        (3 110)
#
#        ;;; Amb-Eval input:
#        > try-again
#
#        ;;; Amb-Eval value:
#        (8 35)
#
#        ;;; Amb-Eval input:
#        > try-again
#
#        ;;; There are no more values of
#        (prime-sum-pair
#          (quote (1 3 5 8))
#          (quote (20 35 110)))
#
#        ;;; Amb-Eval input:
#        > (prime-sum-pair '(19 27 30) '(11 36 58))
#
#        ;;; Starting a new problem
#        ;;; Amb-Eval value:
#        (30 11)
#      < srci..
     ..srci > scheme
       ;;; Amb-Eval input:
       > (prime-sum-pair '(1 3 5 8) '(20 35 110))
       ;;; Starting a new problem
       ;;; Amb-Eval value:
       (3 20)

       ;;; Amb-Eval input:
       > try-again

       ;;; Amb-Eval value:
       (3 110)

       ;;; Amb-Eval input:
       > try-again

       ;;; Amb-Eval value:
       (8 35)

       ;;; Amb-Eval input:
       > try-again

       ;;; There are no more values of
       (prime-sum-pair
         (quote (1 3 5 8))
         (quote (20 35 110)))

       ;;; Amb-Eval input:
       > (prime-sum-pair '(19 27 30) '(11 36 58))

       ;;; Starting a new problem
       ;;; Amb-Eval value:
       (30 11)
     < srci..

#      :: @t(Exercise 4.35) :: Write a procedure @c(an-integer-between) that returns
#         an integer between two given bounds.  This can be used to implement a
#         procedure that finds Pythagorean triples, i.e., triples of integers @m[(i,
#         j, k)] between the given bounds such that @m(i ≤ j) and @m(i² + j² = k²),
#         as follows:
     :: @t(Ejercicio 4.35) :: Escriba un procedimiento @c(an-integer-between)
        que devuelve un entero entre dos límites dados. Esto puede ser utilizado
        para implementar un procedimiento que encuentre triples de Pitágoras, es
        decir, triples de enteros @m[(i, j, k)] entre los límites dados tal que
        @m(i ≤ j) e @m(i² + j² = k²), como sigue:

#         ..src > scheme
#           (define (a-pythagorean-triple-between low high)
#             (let ((i (an-integer-between low high)))
#               (let ((j (an-integer-between i high)))
#                 (let ((k (an-integer-between j high)))
#                   (require (= (+ (* i i) (* j j))
#                               (* k k)))
#                   (list i j k)))))
#         < src..
        ..src > scheme
          (define (a-pythagorean-triple-between low high)
            (let ((i (an-integer-between low high)))
              (let ((j (an-integer-between i high)))
                (let ((k (an-integer-between j high)))
                  (require (= (+ (* i i) (* j j))
                              (* k k)))
                  (list i j k)))))
        < src..

#      :: @t(Exercise 4.36) :: @l(#Exercise 3.69) discussed how to generate the
#         stream of @e(all) Pythagorean triples, with no upper bound on the size of
#         the integers to be searched. Explain why simply replacing
#         @c(an-integer-between) by @c(an-integer-starting-from) in the procedure in
#         @l(#Exercise 4.35) is not an adequate way to generate arbitrary Pythagorean
#         triples. Write a procedure that actually will accomplish this. (That is,
#         write a procedure for which repeatedly typing @c(try-again) would in
#         principle eventually generate all Pythagorean triples.)
     :: @t(Ejercicio 4.36) :: @l(#Ejercicio 3.69) discutió
        cómo generar el flujo de @e(todos los) triples pitagóricos, sin límite
        superior en el tamaño de los enteros a buscar. Explique por qué
        simplemente reemplazar @c(an-integer-between) por
        @c(an-integer-starting-from) en el procedimiento del
        @l(#Ejercicio 4.35) no es una manera adecuada de generar
        triples pitagóricos arbitrarios. Escribir un procedimiento que realmente
        va a lograr esto. (Es decir, escribir un procedimiento para el cual
        escribir repetidamente @c(try-again) en principio eventualmente
        generaría todos los triples pitagóricos).

#      :: @t(Exercise 4.37) :: Ben Bitdiddle claims that the following method for
#         generating Pythagorean triples is more efficient than the one in
#         @l(#Exercise 4.35). Is he correct?  (Hint: Consider the number of
#         possibilities that must be explored.)
     :: @t(Ejercicio 4.37) :: Ben Bitdiddle afirma que el siguiente método para
        generar triples pitagóricos es más eficiente que el del
        @l(#Ejercicio 4.35). ¿Es correcto? (Sugerencia: Considere
        el número de posibilidades que debe explorarse.)

#         ..src > scheme
#           (define (a-pythagorean-triple-between low high)
#             (let ((i (an-integer-between low high))
#                   (hsq (* high high)))
#               (let ((j (an-integer-between i high)))
#                 (let ((ksq (+ (* i i) (* j j))))
#                   (require (>= hsq ksq))
#                   (let ((k (sqrt ksq)))
#                     (require (integer? k))
#                     (list i j k))))))
#         < src..
        ..src > scheme
          (define (a-pythagorean-triple-between low high)
            (let ((i (an-integer-between low high))
                  (hsq (* high high)))
              (let ((j (an-integer-between i high)))
                (let ((ksq (+ (* i i) (* j j))))
                  (require (>= hsq ksq))
                  (let ((k (sqrt ksq)))
                    (require (integer? k))
                    (list i j k))))))
        < src..

# *** 4.3.2 <> Examples of Nondeterministic Programs
*** 4.3.2 <> Ejemplos de Programas No Deterministas

#     Section @l(#4.3.3) describes the implementation of the @c(amb) evaluator.
#     First, however, we give some examples of how it can be used. The advantage of
#     nondeterministic programming is that we can suppress the details of how search
#     is carried out, thereby expressing our programs at a higher level of
#     abstraction.
    La sección @l(#4.3.3) describe la implementación del @c(amb)
    evaluador. En primer lugar, sin embargo, damos algunos ejemplos de cómo se
    puede utilizar. La ventaja de la programación no determinista es que podemos
    suprimir los detalles de cómo se lleva a cabo la búsqueda, expresando así
    nuestros programas en un nivel superior de abstracción.

# **** Logic Puzzles
**** Puzzles lógicos

#      The following puzzle (taken from @l(#Dinesman 1968)) is typical of a large
#      class of simple logic puzzles:
     El siguiente rompecabezas (tomado de @l(#Dinesman-1968<>Dinesman 1968) ) es
     típico de una gran clase de puzles lógicos simples:

#      ..tab >
    ..tab >
#        Baker, Cooper, Fletcher, Miller, and Smith live on different floors of an
#        apartment house that contains only five floors. Baker does not live on the
#        top floor. Cooper does not live on the bottom floor. Fletcher does not live
#        on either the top or the bottom floor. Miller lives on a higher floor than
#        does Cooper. Smith does not live on a floor adjacent to Fletcher's. Fletcher
#        does not live on a floor adjacent to Cooper's. Where does everyone live?
       Baker, Cooper, Fletcher, Miller y Smith viven en pisos diferentes de una
       casa de apartamentos que contiene sólo cinco pisos. Baker no vive en la
       planta superior. Cooper no vive en la planta baja. Fletcher no vive ni en
       la parte superior ni en la planta baja. Miller vive en un piso más alto
       que Cooper. Smith no vive en un piso adyacente a Fletcher. Fletcher no
       vive en un piso adyacente al de Cooper. ¿Dónde vive todo el mundo?


#      We can determine who lives on each floor in a straightforward way by
#      enumerating all the possibilities and imposing the given restrictions:@n(252)
     Podemos determinar que vive en cada piso de una manera directa mediante la
     enumeración de todas las posibilidades y la imposición de las restricciones
     dadas:@n(252)

#      ..src > scheme
#        (define (multiple-dwelling)
#          (let ((baker (amb 1 2 3 4 5))
#                (cooper (amb 1 2 3 4 5))
#                (fletcher (amb 1 2 3 4 5))
#                (miller (amb 1 2 3 4 5))
#                (smith (amb 1 2 3 4 5)))
#            (require
#             (distinct? (list baker cooper fletcher
#                              miller smith)))
#            (require (not (= baker 5)))
#            (require (not (= cooper 1)))
#            (require (not (= fletcher 5)))
#            (require (not (= fletcher 1)))
#            (require (> miller cooper))
#            (require
#             (not (= (abs (- smith fletcher)) 1)))
#            (require
#             (not (= (abs (- fletcher cooper)) 1)))
#            (list (list 'baker baker)
#                  (list 'cooper cooper)
#                  (list 'fletcher fletcher)
#                  (list 'miller miller)
#                  (list 'smith smith))))
#      < src..
     ..src > scheme
       (define (multiple-dwelling)
         (let ((baker (amb 1 2 3 4 5))
               (cooper (amb 1 2 3 4 5))
               (fletcher (amb 1 2 3 4 5))
               (miller (amb 1 2 3 4 5))
               (smith (amb 1 2 3 4 5)))
           (require
            (distinct? (list baker cooper fletcher
                             miller smith)))
           (require (not (= baker 5)))
           (require (not (= cooper 1)))
           (require (not (= fletcher 5)))
           (require (not (= fletcher 1)))
           (require (> miller cooper))
           (require
            (not (= (abs (- smith fletcher)) 1)))
           (require
            (not (= (abs (- fletcher cooper)) 1)))
           (list (list 'baker baker)
                 (list 'cooper cooper)
                 (list 'fletcher fletcher)
                 (list 'miller miller)
                 (list 'smith smith))))
     < src..

#      Evaluating the expression @c[(multiple-dwelling)] produces the result
     La evaluación de la expresión @c[(multiple-dwelling)] produce el resultado

#      ..src > scheme
#        ((baker 3) (cooper 2) (fletcher 4)
#         (miller 5) (smith 1))
#      < src..
     ..src > scheme
       ((baker 3) (cooper 2) (fletcher 4)
        (miller 5) (smith 1))
     < src..

#      Although this simple procedure works, it is very slow. @l(#Exercise 4.39) and
#      @l(#Exercise 4.40) discuss some possible improvements.
     Aunque este procedimiento simple funciona, es muy lento.
     @l(#Ejercicio 4.39) y el @l(#Ejercicio
     4.40) discuten algunas posibles mejoras.

#      :: @t(Exercise 4.38) :: Modify the multiple-dwelling procedure to omit the
#         requirement that Smith and Fletcher do not live on adjacent floors. How
#         many solutions are there to this modified puzzle?
     :: @t(Ejercicio 4.38) :: Modifique el procedimiento de múltiples viviendas
        para omitir el requisito de que Smith y Fletcher no vivan en pisos
        adyacentes. ¿Cuántas soluciones hay para este rompecabezas modificado?

#      :: @t(Exercise 4.39) :: Does the order of the restrictions in the
#         multiple-dwelling procedure affect the answer? Does it affect the time to
#         find an answer?  If you think it matters, demonstrate a faster program
#         obtained from the given one by reordering the restrictions. If you think it
#         does not matter, argue your case.
     :: @t(Ejercicio 4.39) :: ¿El orden de las restricciones en el procedimiento
        de vivienda múltiple afecta a la respuesta? ¿Afecta el tiempo para
        encontrar una respuesta? Si usted piensa que importa, demuestre un
        programa más rápido obtenido del dado reordenando las restricciones. Si
        usted piensa que no importa, discuta su caso.

#      :: @t(Exercise 4.40) :: In the multiple dwelling problem, how many sets of
#         assignments are there of people to floors, both before and after the
#         requirement that floor assignments be distinct?  It is very inefficient to
#         generate all possible assignments of people to floors and then leave it to
#         backtracking to eliminate them. For example, most of the restrictions
#         depend on only one or two of the person-floor variables, and can thus be
#         imposed before floors have been selected for all the people. Write and
#         demonstrate a much more efficient nondeterministic procedure that solves
#         this problem based upon generating only those possibilities that are not
#         already ruled out by previous restrictions. (Hint: This will require a nest
#         of @c(let) expressions.)
     :: @t(Ejercicio 4.40) :: En el problema de vivienda múltiple, ¿cuántos
        conjuntos de asignaciones hay de personas a pisos, tanto antes como
        después del requisito de que las asignaciones de piso sean distintas? Es
        muy ineficiente para generar todas las asignaciones posibles de personas
        a los pisos y luego dejarlo a retroceder para eliminarlos. Por ejemplo,
        la mayoría de las restricciones dependen sólo de una o dos variables de
        la persona-piso, y por lo tanto pueden ser impuestas antes de que los
        pisos hayan sido seleccionados para todas las personas. Escribir y
        demostrar un procedimiento mucho más eficiente no determinista que
        resuelve este problema basado en generar sólo aquellas posibilidades que
        ya no están descartadas por restricciones anteriores. (Sugerencia: Esto
        requerirá un nido de @c(let) expresiones.)

#      :: @t(Exercise 4.41) :: Write an ordinary Scheme program to solve the multiple
#         dwelling puzzle.
     :: @t(Ejercicio 4.41) :: Escriba un programa de Scheme ordinario para
        resolver el rompecabezas de múltiples viviendas.

#      :: @t(Exercise 4.42) :: Solve the following @"(Liars) puzzle (from
#         @l(#Phillips 1934)):
     :: @t(Ejercicio 4.42) :: Resuelve el siguiente puzzle de @"(mentirosos) (de
        @l(#Phillips-1934<>Phillips 1934) ):

#         Five schoolgirls sat for an examination. Their parents––so they
#         thought––showed an undue degree of interest in the result. They therefore
#         agreed that, in writing home about the examination, each girl should make
#         one true statement and one untrue one. The following are the relevant
#         passages from their letters:
        Cinco colegialas se sentaron para un examen. Sus padres, por lo que
        pensaban, mostraron un interés indebido por el resultado. Por lo tanto,
        acordaron que, al escribir en casa sobre el examen, cada niña debe hacer
        una declaración verdadera y una falsa. Los siguientes son los pasajes
        relevantes de sus cartas:

#         - Betty: @"(Kitty was second in the examination. I was only third.)
        - Betty: @"(Kitty fue la segunda en el examen. Yo sólo estaba tercero.)

#         - Ethel: @"(You'll be glad to hear that I was on top. Joan was second.)
        - Ethel: @"(Te alegrará saber que estaba en la cima. Joan fue segundo.)

#         - Joan: @"(I was third, and poor old Ethel was bottom.)
        - Joan: @"(Yo era tercero, y la pobre Ethel era baja.)

#         - Kitty: @"(I came out second. Mary was only fourth.)
        - Kitty: @"(Yo salí segundo. María era sólo cuarto.)

#         - Mary: @"(I was fourth. Top place was taken by Betty.)
        - Mary: @"(Yo era cuarto. El mejor lugar fue tomado por Betty.)


#         What in fact was the order in which the five girls were placed?
        ¿Cuál era, de hecho, el orden en que se colocaban las cinco niñas?

#      :: @t(Exercise 4.43) :: Use the @c(amb) evaluator to solve the following
#         puzzle:@n(253)
     :: @t(Ejercicio 4.43) :: Usa el @c(amb) evaluador para resolver el
        siguiente rompecabezas:@n(253)

#         ..tab >
       ..tab >
#           Mary Ann Moore's father has a yacht and so has each of his four friends:
#           Colonel Downing, Mr. Hall, Sir Barnacle Hood, and Dr. Parker. Each of the
#           five also has one daughter and each has named his yacht after a daughter
#           of one of the others. Sir Barnacle's yacht is the Gabrielle, Mr. Moore
#           owns the Lorna; Mr. Hall the Rosalind. The Melissa, owned by Colonel
#           Downing, is named after Sir Barnacle's daughter. Gabrielle's father owns
#           the yacht that is named after Dr. Parker's daughter. Who is Lorna's
#           father?
          El padre de Mary Ann Moore tiene un yate y también lo ha hecho cada
          uno de sus cuatro amigos: el Coronel Downing, el Sr. Hall, Sir
          Barnacle Hood y el Dr. Parker. Cada uno de los cinco también tiene una
          hija y cada uno ha nombrado su yate después de una hija de uno de los
          otros. El yate de Sir Barnacle es la Gabrielle, el señor Moore es
          dueño de la Lorna; Sr. Hall, el Rosalind. La Melissa, propiedad del
          Coronel Downing, lleva el nombre de la hija de Sir Barnacle. El padre
          de Gabrielle es dueño del yate que lleva el nombre de la hija del
          Dr. Parker. ¿Quién es el padre de Lorna?

#         Try to write the program so that it runs efficiently (see @l(#Exercise
#         4.40)). Also determine how many solutions there are if we are not told that
#         Mary Ann's last name is Moore.
        Trate de escribir el programa para que funcione eficientemente (ver el
        @l(#Ejercicio 4.40) ). También determinar cuántas
        soluciones hay si no se nos dice que el apellido de Mary Ann es Moore.

#      :: @t(Exercise 4.44) :: @l(#Exercise 2.42) described the @"(eight-queens
#         puzzle) of placing queens on a chessboard so that no two attack each
#         other. Write a nondeterministic program to solve this puzzle.
     :: @t(Ejercicio 4.44) :: @l(#Ejercicio 2.42) describió el
        @"(rompecabezas) de @"(ocho reinas) colocando a las reinas en un tablero
        de ajedrez para que ninguno se atacara entre sí. Escribe un programa no
        determinista para resolver este rompecabezas.

# **** Parsing natural language
**** Parsing lenguaje natural

#      Programs designed to accept natural language as input usually start by
#      attempting to @e(parse) the input, that is, to match the input against some
#      grammatical structure. For example, we might try to recognize simple sentences
#      consisting of an article followed by a noun followed by a verb, such as @"(The
#      cat eats.)  To accomplish such an analysis, we must be able to identify the
#      parts of speech of individual words. We could start with some lists that
#      classify various words:@n(254)
     Los programas diseñados para aceptar el lenguaje natural como entrada
     usualmente comienzan intentando @e(analizar) la entrada, es decir, para
     emparejar la entrada con alguna estructura gramatical. Por ejemplo,
     podríamos tratar de reconocer oraciones simples que consisten en un
     artículo seguido de un sustantivo seguido de un verbo, como @"(El gato
     come. )  Para lograr tal análisis, debemos ser capaces de identificar las
     partes del discurso de las palabras individuales. Podríamos comenzar con
     algunas listas que clasifican varias palabras:@n(254)

#      ..src > scheme
#        (define nouns
#          '(noun student professor cat class))
#
#        (define verbs
#          '(verb studies lectures eats sleeps))
#
#        (define articles '(article the a))
#      < src..
     ..src > scheme
       (define nouns
         '(noun student professor cat class))

       (define verbs
         '(verb studies lectures eats sleeps))

       (define articles '(article the a))
     < src..

#      We also need a @e(grammar), that is, a set of rules describing how grammatical
#      elements are composed from simpler elements. A very simple grammar might
#      stipulate that a sentence always consists of two pieces––a noun phrase
#      followed by a verb––and that a noun phrase consists of an article followed by
#      a noun. With this grammar, the sentence @"(The cat eats) is parsed as follows:
     También necesitamos una @e(gramática), es decir, un conjunto de reglas que
     describen cómo se componen elementos gramaticales a partir de elementos más
     simples. Una gramática muy simple puede estipular que una oración consta
     siempre de dos partes - una frase nominal seguida por un verbo - y que una
     frase nominal consiste en un artículo seguido por un sustantivo. Con esta
     gramática, la frase @"(El gato come) se analiza de la siguiente manera:

#      ..src > scheme
#        (sentence
#         (noun-phrase (article the) (noun cat))
#         (verb eats))
#      < src..
     ..src > scheme
       (sentence
        (noun-phrase (article the) (noun cat))
        (verb eats))
     < src..

#      We can generate such a parse with a simple program that has separate
#      procedures for each of the grammatical rules. To parse a sentence, we identify
#      its two constituent pieces and return a list of these two elements, tagged
#      with the symbol @c(sentence):
     Podemos generar tal análisis con un programa simple que tiene
     procedimientos separados para cada una de las reglas gramaticales. Para
     analizar una oración, identificamos sus dos piezas constituyentes y
     devolvemos una lista de estos dos elementos, marcados con el símbolo
     @c(sentence):

#      ..src > scheme
#        (define (parse-sentence)
#          (list 'sentence
#                 (parse-noun-phrase)
#                 (parse-word verbs)))
#      < src..
     ..src > scheme
       (define (parse-sentence)
         (list 'sentence
                (parse-noun-phrase)
                (parse-word verbs)))
     < src..

#      A noun phrase, similarly, is parsed by finding an article followed by a noun:
     Un sintagma nominal, similarmente, se analiza al encontrar un artículo
     seguido de un sustantivo:

#      ..src > scheme
#        (define (parse-noun-phrase)
#          (list 'noun-phrase
#                (parse-word articles)
#                (parse-word nouns)))
#      < src..
     ..src > scheme
       (define (parse-noun-phrase)
         (list 'noun-phrase
               (parse-word articles)
               (parse-word nouns)))
     < src..

#      At the lowest level, parsing boils down to repeatedly checking that the next
#      unparsed word is a member of the list of words for the required part of
#      speech.  To implement this, we maintain a global variable @c(*unparsed*),
#      which is the input that has not yet been parsed. Each time we check a word, we
#      require that @c(*unparsed*) must be non-empty and that it should begin with a
#      word from the designated list. If so, we remove that word from @c(*unparsed*)
#      and return the word together with its part of speech (which is found at the
#      head of the list):@n(255)
     En el nivel más bajo, analizar se reduce a comprobar repetidamente que la
     siguiente palabra no filtrada es un miembro de la lista de palabras para la
     parte requerida de la palabra. Para implementar esto, mantenemos una
     variable global @c(*unparsed*), que es la entrada que aún no se ha
     analizado. Cada vez que revisamos una palabra, necesitamos que
     @c(*unparsed*) no sea vacía y que comience con una palabra de la lista
     designada. Si es así, eliminamos esa palabra @c(*unparsed*) y le devolvemos
     la palabra junto con su parte del discurso (que se encuentra al principio
     de la lista):@n(255)

#      ..src > scheme
#        (define (parse-word word-list)
#          (require (not (null? *unparsed*)))
#          (require (memq (car *unparsed*)
#                         (cdr word-list)))
#          (let ((found-word (car *unparsed*)))
#            (set! *unparsed* (cdr *unparsed*))
#            (list (car word-list) found-word)))
#      < src..
     ..src > scheme
       (define (parse-word word-list)
         (require (not (null? *unparsed*)))
         (require (memq (car *unparsed*)
                        (cdr word-list)))
         (let ((found-word (car *unparsed*)))
           (set! *unparsed* (cdr *unparsed*))
           (list (car word-list) found-word)))
     < src..

#      To start the parsing, all we need to do is set @c(*unparsed*) to be the entire
#      input, try to parse a sentence, and check that nothing is left over:
     Para iniciar el análisis, todo lo que tenemos que hacer es establecer
     @c(*unparsed*) la entrada entera, tratar de analizar una oración y
     comprobar que no queda nada:

#      ..src > scheme
#        (define *unparsed* '())
#        (define (parse input)
#          (set! *unparsed* input)
#          (let ((sent (parse-sentence)))
#            (require (null? *unparsed*))
#            sent))
#      < src..
     ..src > scheme
       (define *unparsed* '())
       (define (parse input)
         (set! *unparsed* input)
         (let ((sent (parse-sentence)))
           (require (null? *unparsed*))
           sent))
     < src..

#      We can now try the parser and verify that it works for our simple test
#      sentence:
     Ahora podemos probar el analizador y verificar que funciona para nuestra
     oración de prueba simple:

#      ..src > scheme
#        ;;; Amb-Eval input:
#        (parse '(the cat eats))
#
#        ;;; Starting a new problem
#        ;;; Amb-Eval value:
#        (sentence
#         (noun-phrase (article the) (noun cat))
#         (verb eats))
#      < src..
     ..src > scheme
       ;;; Amb-Eval input:
       (parse '(the cat eats))

       ;;; Starting a new problem
       ;;; Amb-Eval value:
       (sentence
        (noun-phrase (article the) (noun cat))
        (verb eats))
     < src..

#      The @c(amb) evaluator is useful here because it is convenient to express the
#      parsing constraints with the aid of @c(require). Automatic search and
#      backtracking really pay off, however, when we consider more complex grammars
#      where there are choices for how the units can be decomposed.
     El @c(amb) evaluador es útil aquí porque es conveniente expresar las
     restricciones de análisis con la ayuda de @c(require). Sin embargo, la
     búsqueda automática y el retroceso son realmente beneficiosos cuando
     consideramos las gramáticas más complejas donde hay opciones para cómo se
     pueden descomponer las unidades.

#      Let's add to our grammar a list of prepositions:
     Añadamos a nuestra gramática una lista de preposiciones:

#      ..src > scheme
#        (define prepositions
#          '(prep for to in by with))
#      < src..
     ..src > scheme
       (define prepositions
         '(prep for to in by with))
     < src..

#      and define a prepositional phrase (e.g., @"(for the cat)) to be a preposition
#      followed by a noun phrase:
     Y definir una frase preposicional (por ejemplo, @"(para el gato) ) para ser
     una preposición seguida por una frase nominal:

#      ..src > scheme
#        (define (parse-prepositional-phrase)
#          (list 'prep-phrase
#                (parse-word prepositions)
#                (parse-noun-phrase)))
#      < src..
     ..src > scheme
       (define (parse-prepositional-phrase)
         (list 'prep-phrase
               (parse-word prepositions)
               (parse-noun-phrase)))
     < src..

#      Now we can define a sentence to be a noun phrase followed by a verb phrase,
#      where a verb phrase can be either a verb or a verb phrase extended by a
#      prepositional phrase:@n(256)
     Ahora podemos definir una oración como una frase nominal seguida por una
     frase verbal, donde una frase verbal puede ser un verbo o una frase verbal
     extendida por una frase preposicional:@n(256)

#      ..src > scheme
#        (define (parse-sentence)
#          (list 'sentence
#                 (parse-noun-phrase)
#                 (parse-verb-phrase)))
#
#        (define (parse-verb-phrase)
#          (define (maybe-extend verb-phrase)
#            (amb
#             verb-phrase
#             (maybe-extend
#              (list 'verb-phrase
#                    verb-phrase
#                    (parse-prepositional-phrase)))))
#          (maybe-extend (parse-word verbs)))
#      < src..
     ..src > scheme
       (define (parse-sentence)
         (list 'sentence
                (parse-noun-phrase)
                (parse-verb-phrase)))

       (define (parse-verb-phrase)
         (define (maybe-extend verb-phrase)
           (amb
            verb-phrase
            (maybe-extend
             (list 'verb-phrase
                   verb-phrase
                   (parse-prepositional-phrase)))))
         (maybe-extend (parse-word verbs)))
     < src..

#      While we're at it, we can also elaborate the definition of noun phrases to
#      permit such things as @"(a cat in the class.)  What we used to call a noun
#      phrase, we'll now call a simple noun phrase, and a noun phrase will now be
#      either a simple noun phrase or a noun phrase extended by a prepositional
#      phrase:
     Mientras estamos en ello, también podemos elaborar la definición de frases
     nominales para permitir cosas como @"(un gato en la clase. )  Lo que
     solíamos llamar una frase nominal, ahora llamaremos una frase nominal
     simple, y una frase nominal será ahora una frase nominal simple o una frase
     nominal extendida por una frase preposicional:

#      ..src > scheme
#        (define (parse-simple-noun-phrase)
#          (list 'simple-noun-phrase
#                (parse-word articles)
#                (parse-word nouns)))
#
#        (define (parse-noun-phrase)
#          (define (maybe-extend noun-phrase)
#            (amb
#             noun-phrase
#             (maybe-extend
#              (list 'noun-phrase
#                    noun-phrase
#                    (parse-prepositional-phrase)))))
#          (maybe-extend (parse-simple-noun-phrase)))
#      < src..
     ..src > scheme
       (define (parse-simple-noun-phrase)
         (list 'simple-noun-phrase
               (parse-word articles)
               (parse-word nouns)))

       (define (parse-noun-phrase)
         (define (maybe-extend noun-phrase)
           (amb
            noun-phrase
            (maybe-extend
             (list 'noun-phrase
                   noun-phrase
                   (parse-prepositional-phrase)))))
         (maybe-extend (parse-simple-noun-phrase)))
     < src..

#      Our new grammar lets us parse more complex sentences. For example
     Nuestra nueva gramática nos permite analizar frases más complejas. Por
     ejemplo

#      ..src > scheme
#        (parse '(the student with the cat
#                 sleeps in the class))
#      < src..
     ..src > scheme
       (parse '(the student with the cat
                sleeps in the class))
     < src..

#      produces
     Produce

#      ..src > scheme
#        (sentence
#         (noun-phrase
#          (simple-noun-phrase (article the)
#                              (noun student))
#          (prep-phrase (prep with)
#                       (simple-noun-phrase
#                        (article the)
#                        (noun cat))))
#         (verb-phrase
#          (verb sleeps)
#          (prep-phrase (prep in)
#                       (simple-noun-phrase
#                        (article the)
#                        (noun class)))))
#      < src..
     ..src > scheme
       (sentence
        (noun-phrase
         (simple-noun-phrase (article the)
                             (noun student))
         (prep-phrase (prep with)
                      (simple-noun-phrase
                       (article the)
                       (noun cat))))
        (verb-phrase
         (verb sleeps)
         (prep-phrase (prep in)
                      (simple-noun-phrase
                       (article the)
                       (noun class)))))
     < src..

#      Observe that a given input may have more than one legal parse. In the sentence
#      @"(The professor lectures to the student with the cat,) it may be that the
#      professor is lecturing with the cat, or that the student has the cat. Our
#      nondeterministic program finds both possibilities:
     Observe que una entrada dada puede tener más de un análisis legal. En la
     oración @"(El profesor le enseña al estudiante con el gato,) puede ser que
     el profesor esté dando conferencias con el gato, o que el estudiante tenga
     el gato. Nuestro programa no determinista encuentra ambas posibilidades:

#      ..src > scheme
#        (parse '(the professor lectures to
#                 the student with the cat))
#      < src..
     ..src > scheme
       (parse '(the professor lectures to
                the student with the cat))
     < src..

#      produces
     Produce

#      ..src > scheme
#        (sentence
#         (simple-noun-phrase (article the)
#                             (noun professor))
#         (verb-phrase
#          (verb-phrase
#           (verb lectures)
#           (prep-phrase (prep to)
#                        (simple-noun-phrase
#                         (article the)
#                         (noun student))))
#          (prep-phrase (prep with)
#                       (simple-noun-phrase
#                        (article the)
#                        (noun cat)))))
#      < src..
     ..src > scheme
       (sentence
        (simple-noun-phrase (article the)
                            (noun professor))
        (verb-phrase
         (verb-phrase
          (verb lectures)
          (prep-phrase (prep to)
                       (simple-noun-phrase
                        (article the)
                        (noun student))))
         (prep-phrase (prep with)
                      (simple-noun-phrase
                       (article the)
                       (noun cat)))))
     < src..

#      Asking the evaluator to try again yields
     Pedir al evaluador que vuelva a intentarlo

#      ..src > scheme
#        (sentence
#         (simple-noun-phrase (article the)
#                             (noun professor))
#         (verb-phrase (verb lectures)
#                      (prep-phrase
#                       (prep to)
#                       (noun-phrase
#                        (simple-noun-phrase
#                         (article the)
#                         (noun student))
#                        (prep-phrase
#                         (prep with)
#                         (simple-noun-phrase
#                          (article the)
#                          (noun cat)))))))
#      < src..
     ..src > scheme
       (sentence
        (simple-noun-phrase (article the)
                            (noun professor))
        (verb-phrase (verb lectures)
                     (prep-phrase
                      (prep to)
                      (noun-phrase
                       (simple-noun-phrase
                        (article the)
                        (noun student))
                       (prep-phrase
                        (prep with)
                        (simple-noun-phrase
                         (article the)
                         (noun cat)))))))
     < src..

#      :: @t(Exercise 4.45) :: With the grammar given above, the following sentence
#         can be parsed in five different ways: @"(The professor lectures to the
#         student in the class with the cat.)  Give the five parses and explain the
#         differences in shades of meaning among them.
     :: @t(Ejercicio 4.45) :: Con la gramática dada arriba, la siguiente oración
        puede ser analizada de cinco maneras diferentes: @"(El profesor da
        clases al estudiante en la clase con el gato. )  Dé los cinco parses y
        explique las diferencias en las sombras del significado entre ellos.

#      :: @t(Exercise 4.46) :: The evaluators in section @l(#4.1) and @l(#4.2) do not
#         determine what order operands are evaluated in.  We will see that the
#         @c(amb) evaluator evaluates them from left to right.  Explain why our
#         parsing program wouldn't work if the operands were evaluated in some other
#         order.
     :: @t(Ejercicio 4.46) :: Los evaluadores en la seccion @l(#4.1) y @l(#4.2)
        no determinan en qué orden se evalúan los operandos. Veremos que el
        @c(amb) evaluador los evalúa de izquierda a derecha. Explique por qué
        nuestro programa de análisis no funcionaría si los operandos fueran
        evaluados en algún otro orden.

#      :: @t(Exercise 4.47) :: Louis Reasoner suggests that, since a verb phrase is
#         either a verb or a verb phrase followed by a prepositional phrase, it would
#         be much more straightforward to define the procedure @c(parse-verb-phrase)
#         as follows (and similarly for noun phrases):
     :: @t(Ejercicio 4.47) :: Louis Reasoner sugiere que, puesto que una frase
        verbal es un verbo o una frase verbal seguida de una frase
        preposicional, sería mucho más sencillo definir el procedimiento de la
        @c(parse-verb-phrase) siguiente manera (y de manera similar para los
        sintagmas nominales):

#         ..src > scheme
#           (define (parse-verb-phrase)
#             (amb (parse-word verbs)
#                  (list
#                   'verb-phrase
#                   (parse-verb-phrase)
#                   (parse-prepositional-phrase))))
#         < src..
        ..src > scheme
          (define (parse-verb-phrase)
            (amb (parse-word verbs)
                 (list
                  'verb-phrase
                  (parse-verb-phrase)
                  (parse-prepositional-phrase))))
        < src..

#         Does this work?  Does the program's behavior change if we interchange the
#         order of expressions in the @c(amb)?
        ¿Esto funciona? ¿Cambia el comportamiento del programa si intercambiamos
        el orden de las expresiones en el @c(amb)?

#      :: @t(Exercise 4.48) :: Extend the grammar given above to handle more complex
#         sentences. For example, you could extend noun phrases and verb phrases to
#         include adjectives and adverbs, or you could handle compound
#         sentences.@n(257)
     :: @t(Ejercicio 4.48) :: Extender la gramática dada anteriormente para
        manejar oraciones más complejas. Por ejemplo, podrías extender frases
        nominales y verbales para incluir adjetivos y adverbios, o puedes
        manejar oraciones compuestas.@n(257)

#      :: @t(Exercise 4.49) :: Alyssa P. Hacker is more interested in generating
#         interesting sentences than in parsing them. She reasons that by simply
#         changing the procedure @c(parse-word) so that it ignores the @"(input
#         sentence) and instead always succeeds and generates an appropriate word, we
#         can use the programs we had built for parsing to do generation
#         instead. Implement Alyssa's idea, and show the first half-dozen or so
#         sentences generated.@n(258)
     :: @t(Ejercicio 4.49) :: Alyssa P. Hacker está más interesada en generar
        oraciones interesantes que en analizarlas. Ella razona que simplemente
        cambiando el procedimiento @c(parse-word) para que ignore la @"(frase de
        entrada) y en su lugar siempre tiene éxito y genera una palabra
        apropiada, podemos usar los programas que habíamos construido para
        analizar para hacer generación en su lugar. Implementar la idea de
        Alyssa, y mostrar la primera media docena o más oraciones
        generadas.@n(258)

# *** 4.3.3 <> Implementing the @c(Amb) Evaluator
*** 4.3.3 <> Implementación del @c(Amb) Evaluador

#     The evaluation of an ordinary Scheme expression may return a value, may never
#     terminate, or may signal an error. In nondeterministic Scheme the evaluation
#     of an expression may in addition result in the discovery of a dead end, in
#     which case evaluation must backtrack to a previous choice point. The
#     interpretation of nondeterministic Scheme is complicated by this extra case.
    La evaluación de una expresión de Scheme ordinaria puede devolver un valor,
    nunca puede finalizar, o puede indicar un error. En un esquema no
    determinista, la evaluación de una expresión puede además resultar en el
    descubrimiento de un callejón sin salida, en cuyo caso la evaluación debe
    retroceder a un punto de elección anterior. La interpretación del esquema no
    determinista se complica por este caso extra.

#     We will construct the @c(amb) evaluator for nondeterministic Scheme by
#     modifying the analyzing evaluator of section @l(#4.1.7).@n(259) As in the analyzing
#     evaluator, evaluation of an expression is accomplished by calling an execution
#     procedure produced by analysis of that expression. The difference between the
#     interpretation of ordinary Scheme and the interpretation of nondeterministic
#     Scheme will be entirely in the execution procedures.
    Construiremos el @c(amb) evaluador para el esquema no determinístico
    modificando el evaluador de análisis de la seccion @l(#4.1.7).@n(259) Al
    igual que en el evaluador de análisis, la evaluación de una expresión se
    realiza llamando a un procedimiento de ejecución producido por el análisis
    de esa expresión. La diferencia entre la interpretación del esquema
    ordinario y la interpretación del esquema no determinista estará enteramente
    en los procedimientos de ejecución.

# **** Execution procedures and continuations
**** Procedimientos de ejecución y continuación

#      Recall that the execution procedures for the ordinary evaluator take one
#      argument: the environment of execution. In contrast, the execution procedures
#      in the @c(amb) evaluator take three arguments: the environment, and two
#      procedures called @e(continuation procedures). The evaluation of an expression
#      will finish by calling one of these two continuations: If the evaluation
#      results in a value, the @e(success continuation) is called with that value; if
#      the evaluation results in the discovery of a dead end, the @e(failure
#      continuation) is called. Constructing and calling appropriate continuations is
#      the mechanism by which the nondeterministic evaluator implements backtracking.
     Recordemos que los procedimientos de ejecución para el evaluador ordinario
     toman un argumento: el entorno de ejecución. Por el contrario, los
     procedimientos de ejecución en el @c(amb) evaluador toman tres argumentos:
     el medio ambiente, y dos procedimientos llamados @e(procedimientos de
     continuación). La evaluación de una expresión terminará llamando a una de
     estas dos continuaciones: Si la evaluación da lugar a un valor, la
     @e(continuación) del @e(éxito) se llama con ese valor; Si la evaluación
     resulta en el descubrimiento de un callejón sin salida, se llama la
     @e(continuación) del @e(fallo). Construir y llamar continuaciones
     apropiadas es el mecanismo por el cual el evaluador no determinista
     implementa el retroceso.

#      It is the job of the success continuation to receive a value and proceed with
#      the computation. Along with that value, the success continuation is passed
#      another failure continuation, which is to be called subsequently if the use of
#      that value leads to a dead end.
     Es el trabajo de la continuación del éxito recibir un valor y proceder con
     el cálculo. Junto con ese valor, la continuación del éxito se pasa otra
     continuación de falla, que se llamará posteriormente si el uso de ese valor
     conduce a un callejón sin salida.

#      It is the job of the failure continuation to try another branch of the
#      nondeterministic process. The essence of the nondeterministic language is in
#      the fact that expressions may represent choices among alternatives. The
#      evaluation of such an expression must proceed with one of the indicated
#      alternative choices, even though it is not known in advance which choices will
#      lead to acceptable results. To deal with this, the evaluator picks one of the
#      alternatives and passes this value to the success continuation. Together with
#      this value, the evaluator constructs and passes along a failure continuation
#      that can be called later to choose a different alternative.
     Es tarea de la continuación del fracaso intentar otra rama del proceso no
     determinista. La esencia del lenguaje no determinista radica en el hecho de
     que las expresiones pueden representar elecciones entre alternativas. La
     evaluación de tal expresión debe proceder con una de las opciones
     alternativas indicadas, a pesar de que no se sabe de antemano qué opciones
     conducirá a resultados aceptables. Para hacer frente a esto, el evaluador
     escoge una de las alternativas y pasa este valor a la continuación del
     éxito. Junto con este valor, el evaluador construye y pasa a lo largo de
     una continuación de falla que se puede llamar más tarde para elegir una
     alternativa diferente.

#      A failure is triggered during evaluation (that is, a failure continuation is
#      called) when a user program explicitly rejects the current line of attack (for
#      example, a call to @c(require) may result in execution of @c[(amb)], an
#      expression that always fails––see @l(#4.3.1)). The failure continuation in
#      hand at that point will cause the most recent choice point to choose another
#      alternative. If there are no more alternatives to be considered at that choice
#      point, a failure at an earlier choice point is triggered, and so on. Failure
#      continuations are also invoked by the driver loop in response to a
#      @c(try-again) request, to find another value of the expression.
     Un fallo se activa durante la evaluación (es decir, se llama una
     continuación de fallo) cuando un programa de usuario rechaza explícitamente
     la línea de ataque actual (por ejemplo, una llamada a @c(require) puede
     resultar en la ejecución de @c[(amb)] una expresión que siempre falla
     @l(#4.3.1<>. 1) ). La continuación del fallo en la mano en ese punto hará
     que el punto de elección más reciente elija otra alternativa. Si no hay más
     alternativas a considerar en ese punto de selección, se activa un fallo en
     un punto de selección anterior, y así sucesivamente. Las continuaciones de
     fallo también son invocadas por el bucle del controlador en respuesta a una
     @c(try-again) petición, para encontrar otro valor de la expresión.

#      In addition, if a side-effect operation (such as assignment to a variable)
#      occurs on a branch of the process resulting from a choice, it may be
#      necessary, when the process finds a dead end, to undo the side effect before
#      making a new choice. This is accomplished by having the side-effect operation
#      produce a failure continuation that undoes the side effect and propagates the
#      failure.
     Además, si una operación de efecto secundario (como la asignación a una
     variable) se produce en una rama del proceso resultante de una elección,
     puede ser necesario, cuando el proceso encuentra un callejón sin salida,
     deshacer el efecto secundario antes de hacer una Nueva opción. Esto se
     logra haciendo que la operación de efecto secundario produzca una
     continuación de falla que deshaga el efecto secundario y propague el fallo.

#      In summary, failure continuations are constructed by
     En resumen, las continuaciones de falla son construidas por

#      - @c(amb) expressions––to provide a mechanism to make alternative choices if
#        the current choice made by the @c(amb) expression leads to a dead end;
     - @c(amb) Expresiones - para proporcionar un mecanismo para hacer
       elecciones alternativas si la elección actual hecha por la @c(amb)
       expresión conduce a un callejón sin salida;

#      - the top-level driver––to provide a mechanism to report failure when the
#        choices are exhausted;
     - El controlador de nivel superior - para proporcionar un mecanismo para
       informar el fallo cuando se agotan las opciones;

#      - assignments––to intercept failures and undo assignments during backtracking.
     - Asignaciones - para interceptar fallas y deshacer asignaciones durante
       retroceso.

#      Failures are initiated only when a dead end is encountered. This occurs
     Los fallos se inician sólo cuando se encuentra un callejón sin salida. Esto
     ocurre

#      - if the user program executes @c[(amb)];
     - Si el programa de usuario se ejecuta @c[(amb)];

#      - if the user types @c(try-again) at the top-level driver.
     - Si el usuario escribe @c(try-again) en el controlador de nivel superior.

#      Failure continuations are also called during processing of a failure:
     Las continuaciones de falla también se llaman durante el procesamiento de
     un fallo:

#      - When the failure continuation created by an assignment finishes undoing a
#        side effect, it calls the failure continuation it intercepted, in order to
#        propagate the failure back to the choice point that led to this assignment
#        or to the top level.
     - Cuando la continuación del fallo creada por una asignación termina de
       deshacer un efecto secundario, llama a la continuación del fallo
       interceptada, para propagar el fallo de nuevo al punto de selección que
       condujo a esta asignación o al nivel superior.

#      - When the failure continuation for an @c(amb) runs out of choices, it calls
#        the failure continuation that was originally given to the @c(amb), in order
#        to propagate the failure back to the previous choice point or to the top
#        level.
     - Cuando la continuación del fallo para un se @c(amb) queda sin opciones,
       llama a la continuación del fallo que se dio originalmente al @c(amb),
       para propagar el fallo de nuevo al punto de elección anterior o al nivel
       superior.

# **** Structure of the evaluator
**** Estructura del evaluador

#      The syntax- and data-representation procedures for the @c(amb) evaluator, and
#      also the basic @c(analyze) procedure, are identical to those in the evaluator
#      of section @l(#4.1.7), except for the fact that we need additional syntax procedures
#      to recognize the @c(amb) special form:@n(260)
     Los procedimientos de sintaxis y de representación de datos para el @c(amb)
     evaluador, así como el procedimiento @c(analyze) básico, son idénticos a
     los del evaluador de la seccion @l(#4.1.7), excepto por el hecho de que
     necesitamos procedimientos de sintaxis adicionales para reconocer el
     @c(amb) formulario especial:@n(260)

#      ..src > scheme
#        (define (amb? exp) (tagged-list? exp 'amb))
#        (define (amb-choices exp) (cdr exp))
#      < src..
     ..src > scheme
       (define (amb? exp) (tagged-list? exp 'amb))
       (define (amb-choices exp) (cdr exp))
     < src..

#      We must also add to the dispatch in @c(analyze) a clause that will recognize
#      this special form and generate an appropriate execution procedure:
     También debemos añadir al despacho en @c(analyze) una cláusula que
     reconocerá este formulario especial y generará un procedimiento de
     ejecución apropiado:

#      ..src > scheme
#        ((amb? exp) (analyze-amb exp))
#      < src..
     ..src > scheme
       ((amb? exp) (analyze-amb exp))
     < src..

#      The top-level procedure @c(ambeval) (similar to the version of @c(eval) given
#      in section @l(#4.1.7)) analyzes the given expression and applies the resulting
#      execution procedure to the given environment, together with two given
#      continuations:
     El procedimiento de nivel superior @c(ambeval)(similar a la versión de
     @c(eval) dado en la seccion @l(#4.1.7)) analiza la expresión dada y aplica el
     procedimiento de ejecución resultante al entorno dado, junto con dos
     continuaciones dadas:

#      ..src > scheme
#        (define (ambeval exp env succeed fail)
#          ((analyze exp) env succeed fail))
#      < src..
     ..src > scheme
       (define (ambeval exp env succeed fail)
         ((analyze exp) env succeed fail))
     < src..

#      A success continuation is a procedure of two arguments: the value just
#      obtained and another failure continuation to be used if that value leads to a
#      subsequent failure. A failure continuation is a procedure of no arguments. So
#      the general form of an execution procedure is
     Una continuación de éxito es un procedimiento de dos argumentos: el valor
     recién obtenido y otra continuación de fallo que se utiliza si ese valor
     conduce a un fallo posterior. Una continuación de la falla es un
     procedimiento sin argumentos. Así, la forma general de un procedimiento de
     ejecución es

#      ..src > scheme
#        (lambda (env succeed fail)
#          ;; succeed is (lambda (value fail) …)
#          ;; fail is (lambda () …)
#          …)
#      < src..
     ..src > scheme
       (lambda (env succeed fail)
         ;; succeed is (lambda (value fail) …)
         ;; fail is (lambda () …)
         …)
     < src..

#      For example, executing
     Por ejemplo, ejecutar

#      ..src > scheme
#        (ambeval ⟨exp⟩
#                 the-global-environment
#                 (lambda (value fail) value)
#                 (lambda () 'failed))
#      < src..
     ..src > scheme
       (ambeval ⟨exp⟩
                the-global-environment
                (lambda (value fail) value)
                (lambda () 'failed))
     < src..

#      will attempt to evaluate the given expression and will return either the
#      expression's value (if the evaluation succeeds) or the symbol @c(failed) (if
#      the evaluation fails). The call to @c(ambeval) in the driver loop shown below
#      uses much more complicated continuation procedures, which continue the loop
#      and support the @c(try-again) request.
     Intentará evaluar la expresión dada y devolverá el valor de la expresión
     (si la evaluación tiene éxito) o el símbolo @c(failed)(si la evaluación
     falla). La llamada a @c(ambeval) en el bucle del controlador que se muestra
     a continuación utiliza procedimientos de continuación mucho más
     complicados, que continúan el bucle y admiten la @c(try-again) solicitud.

#      Most of the complexity of the @c(amb) evaluator results from the mechanics of
#      passing the continuations around as the execution procedures call each
#      other. In going through the following code, you should compare each of the
#      execution procedures with the corresponding procedure for the ordinary
#      evaluator given in section @l(#4.1.7).
     La mayor parte de la complejidad del @c(amb) evaluador es el resultado de
     la mecánica de pasar las continuaciones a medida que los procedimientos de
     ejecución se llaman. Al pasar por el siguiente código, debe comparar cada
     uno de los procedimientos de ejecución con el procedimiento correspondiente
     para el evaluador ordinario dado en la seccion @l(#4.1.7).

# **** Simple expressions
**** Expresiones sencillas

#      The execution procedures for the simplest kinds of expressions are essentially
#      the same as those for the ordinary evaluator, except for the need to manage
#      the continuations. The execution procedures simply succeed with the value of
#      the expression, passing along the failure continuation that was passed to
#      them.
     Los procedimientos de ejecución para los tipos más simples de expresiones
     son esencialmente los mismos que para el evaluador ordinario, excepto para
     la necesidad de gestionar las continuaciones. Los procedimientos de
     ejecución simplemente tienen éxito con el valor de la expresión, pasando a
     lo largo de la continuación de la falla que se les pasó.

#      ..src > scheme
#        (define (analyze-self-evaluating exp)
#          (lambda (env succeed fail)
#            (succeed exp fail)))
#
#        (define (analyze-quoted exp)
#          (let ((qval (text-of-quotation exp)))
#            (lambda (env succeed fail)
#              (succeed qval fail))))
#
#        (define (analyze-variable exp)
#          (lambda (env succeed fail)
#            (succeed (lookup-variable-value exp env)
#                     fail)))
#
#        (define (analyze-lambda exp)
#          (let ((vars (lambda-parameters exp))
#                (bproc (analyze-sequence
#                        (lambda-body exp))))
#            (lambda (env succeed fail)
#              (succeed (make-procedure vars bproc env)
#                       fail))))
#      < src..
     ..src > scheme
       (define (analyze-self-evaluating exp)
         (lambda (env succeed fail)
           (succeed exp fail)))

       (define (analyze-quoted exp)
         (let ((qval (text-of-quotation exp)))
           (lambda (env succeed fail)
             (succeed qval fail))))

       (define (analyze-variable exp)
         (lambda (env succeed fail)
           (succeed (lookup-variable-value exp env)
                    fail)))

       (define (analyze-lambda exp)
         (let ((vars (lambda-parameters exp))
               (bproc (analyze-sequence
                       (lambda-body exp))))
           (lambda (env succeed fail)
             (succeed (make-procedure vars bproc env)
                      fail))))
     < src..

#      Notice that looking up a variable always @'(succeeds).  If
#      @c(lookup-variable-value) fails to find the variable, it signals an error, as
#      usual. Such a @"(failure) indicates a program bug––a reference to an unbound
#      variable; it is not an indication that we should try another nondeterministic
#      choice instead of the one that is currently being tried.
     Observe que buscar una variable siempre @'(Tiene éxito). Si
     @c(lookup-variable-value) falla al encontrar la variable, indica un error,
     como de costumbre. Este @"(fallo) indica un error de programa - una
     referencia a una variable no enlazada; No es una indicación de que debamos
     intentar otra elección no determinista en lugar de la que está siendo
     juzgada.

# **** Conditionals and sequences
**** Condicionales y secuencias

#      Conditionals are also handled in a similar way as in the ordinary evaluator.
#      The execution procedure generated by @c(analyze-if) invokes the predicate
#      execution procedure @c(pproc) with a success continuation that checks whether
#      the predicate value is true and goes on to execute either the consequent or
#      the alternative. If the execution of @c(pproc) fails, the original failure
#      continuation for the @c(if) expression is called.
     Los condicionales también se manejan de manera similar al evaluador
     ordinario. El procedimiento de ejecución generado @c(analyze-if) invoca el
     procedimiento de ejecución del predicado @c(pproc) con una continuación de
     éxito que comprueba si el valor del predicado es verdadero y continúa
     ejecutando el consecuente o la alternativa. Si la ejecución de @c(pproc)
     falla, se invoca la continuación del error original para la @c(if)
     expresión.

#      ..src > scheme
#        (define (analyze-if exp)
#          (let ((pproc (analyze (if-predicate exp)))
#                (cproc (analyze (if-consequent exp)))
#                (aproc (analyze (if-alternative exp))))
#            (lambda (env succeed fail)
#              (pproc env
#                     ;; success continuation for evaluating
#                     ;; the predicate to obtain pred-value
#                     (lambda (pred-value fail2)
#                       (if (true? pred-value)
#                           (cproc env succeed fail2)
#                           (aproc env succeed fail2)))
#                     ;; failure continuation for
#                     ;; evaluating the predicate
#                     fail))))
#      < src..
     ..src > scheme
       (define (analyze-if exp)
         (let ((pproc (analyze (if-predicate exp)))
               (cproc (analyze (if-consequent exp)))
               (aproc (analyze (if-alternative exp))))
           (lambda (env succeed fail)
             (pproc env
                    ;; success continuation for evaluating
                    ;; the predicate to obtain pred-value
                    (lambda (pred-value fail2)
                      (if (true? pred-value)
                          (cproc env succeed fail2)
                          (aproc env succeed fail2)))
                    ;; failure continuation for
                    ;; evaluating the predicate
                    fail))))
     < src..

#      Sequences are also handled in the same way as in the previous evaluator,
#      except for the machinations in the subprocedure @c(sequentially) that are
#      required for passing the continuations. Namely, to sequentially execute @c(a)
#      and then @c(b), we call @c(a) with a success continuation that calls @c(b).
     Las secuencias también se manejan de la misma manera que en el evaluador
     anterior, a excepción de las maquinaciones en el subprocedimiento
     @c(sequentially) que se requieren para pasar las continuaciones. Es decir,
     ejecutar secuencialmente @c(a) y luego @c(b), llamamos @c(a) con una
     continuación de éxito que llama @c(b).

#      ..src > scheme
#        (define (analyze-sequence exps)
#          (define (sequentially a b)
#            (lambda (env succeed fail)
#              (a env
#                 ;; success continuation for calling a
#                 (lambda (a-value fail2)
#                   (b env succeed fail2))
#                 ;; failure continuation for calling a
#                 fail)))
#          (define (loop first-proc rest-procs)
#            (if (null? rest-procs)
#                first-proc
#                (loop (sequentially first-proc
#                                    (car rest-procs))
#                      (cdr rest-procs))))
#          (let ((procs (map analyze exps)))
#            (if (null? procs)
#                (error "Empty sequence: ANALYZE"))
#            (loop (car procs) (cdr procs))))
#      < src..
     ..src > scheme
       (define (analyze-sequence exps)
         (define (sequentially a b)
           (lambda (env succeed fail)
             (a env
                ;; success continuation for calling a
                (lambda (a-value fail2)
                  (b env succeed fail2))
                ;; failure continuation for calling a
                fail)))
         (define (loop first-proc rest-procs)
           (if (null? rest-procs)
               first-proc
               (loop (sequentially first-proc
                                   (car rest-procs))
                     (cdr rest-procs))))
         (let ((procs (map analyze exps)))
           (if (null? procs)
               (error "Empty sequence: ANALYZE"))
           (loop (car procs) (cdr procs))))
     < src..

# **** Definitions and assignments
**** Definiciones y asignaciones

#      Definitions are another case where we must go to some trouble to manage the
#      continuations, because it is necessary to evaluate the definition-value
#      expression before actually defining the new variable. To accomplish this, the
#      definition-value execution procedure @c(vproc) is called with the environment,
#      a success continuation, and the failure continuation. If the execution of
#      @c(vproc) succeeds, obtaining a value @c(val) for the defined variable, the
#      variable is defined and the success is propagated:
     Las definiciones son otro caso en el que debemos ir a algún problema para
     gestionar las continuaciones, porque es necesario evaluar la expresión de
     valor de definición antes de definir realmente la nueva variable. Para
     lograr esto, @c(vproc) se llama al procedimiento de ejecución del valor de
     definición con el entorno, una continuación del éxito y la continuación del
     fallo. Si la ejecución de @c(vproc) sucede, obteniendo un valor @c(val)
     para la variable definida, la variable se define y el éxito se propaga:

#      ..src > scheme
#        (define (analyze-definition exp)
#          (let ((var (definition-variable exp))
#                (vproc (analyze
#                        (definition-value exp))))
#            (lambda (env succeed fail)
#              (vproc env
#                     (lambda (val fail2)
#                       (define-variable! var val env)
#                       (succeed 'ok fail2))
#                     fail))))
#      < src..
     ..src > scheme
       (define (analyze-definition exp)
         (let ((var (definition-variable exp))
               (vproc (analyze
                       (definition-value exp))))
           (lambda (env succeed fail)
             (vproc env
                    (lambda (val fail2)
                      (define-variable! var val env)
                      (succeed 'ok fail2))
                    fail))))
     < src..

#      Assignments are more interesting. This is the first place where we really use
#      the continuations, rather than just passing them around. The execution
#      procedure for assignments starts out like the one for definitions. It first
#      attempts to obtain the new value to be assigned to the variable. If this
#      evaluation of @c(vproc) fails, the assignment fails.
     Las asignaciones son más interesantes. Este es el primer lugar donde
     realmente usamos las continuaciones, en lugar de simplemente pasarlas
     alrededor. El procedimiento de ejecución de las asignaciones comienza como
     el de las definiciones. Primero intenta obtener el nuevo valor que se va a
     asignar a la variable. Si esta evaluación de @c(vproc) falla, la asignación
     falla.

#      If @c(vproc) succeeds, however, and we go on to make the assignment, we must
#      consider the possibility that this branch of the computation might later fail,
#      which will require us to backtrack out of the assignment. Thus, we must
#      arrange to undo the assignment as part of the backtracking process.@n(261)
     Si se @c(vproc) logra, sin embargo, y vamos a realizar la asignación,
     debemos considerar la posibilidad de que esta rama del cálculo pueda fallar
     posteriormente, lo que nos obligará a retroceder fuera de la
     asignación. Por lo tanto, debemos arreglar para deshacer la asignación como
     parte del proceso de retroceso.@n(261)

#      This is accomplished by giving @c(vproc) a success continuation (marked with
#      the comment @"(*1*) below) that saves the old value of the variable before
#      assigning the new value to the variable and proceeding from the assignment.
#      The failure continuation that is passed along with the value of the assignment
#      (marked with the comment @"(*2*) below) restores the old value of the variable
#      before continuing the failure. That is, a successful assignment provides a
#      failure continuation that will intercept a subsequent failure; whatever
#      failure would otherwise have called @c(fail2) calls this procedure instead, to
#      undo the assignment before actually calling @c(fail2).
     Esto se logra dando @c(vproc) una continuación de éxito (marcada con el
     comentario @"(* 1 * a) continuación) que guarda el valor antiguo de la
     variable antes de asignar el nuevo valor a la variable y proceder de la
     asignación. La continuación de la falla que se pasa junto con el valor de
     la asignación (marcada con el comentario @"(* 2 * a) continuación) restaura
     el valor antiguo de la variable antes de continuar con la falla. Es decir,
     una asignación exitosa proporciona una continuación de fallo que
     interceptará un fallo subsiguiente; Cualquier fallo que de otro modo habría
     llamado @c(fail2) llamadas este procedimiento en lugar, para deshacer la
     asignación antes de llamar realmente @c(fail2).

#      ..src > scheme
#        (define (analyze-assignment exp)
#          (let ((var (assignment-variable exp))
#                (vproc (analyze
#                        (assignment-value exp))))
#            (lambda (env succeed fail)
#              (vproc env
#                     (lambda (val fail2)    ; *1*
#                       (let ((old-value
#                              (lookup-variable-value
#                               var
#                               env)))
#                         (set-variable-value!
#                          var
#                          val
#                          env)
#                         (succeed
#                          'ok
#                          (lambda ()    ; *2*
#                            (set-variable-value!
#                             var
#                             old-value
#                             env)
#                            (fail2)))))
#                       fail))))
#      < src..
     ..src > scheme
       (define (analyze-assignment exp)
         (let ((var (assignment-variable exp))
               (vproc (analyze
                       (assignment-value exp))))
           (lambda (env succeed fail)
             (vproc env
                    (lambda (val fail2)    ; *1*
                      (let ((old-value
                             (lookup-variable-value
                              var
                              env)))
                        (set-variable-value!
                         var
                         val
                         env)
                        (succeed
                         'ok
                         (lambda ()    ; *2*
                           (set-variable-value!
                            var
                            old-value
                            env)
                           (fail2)))))
                      fail))))
     < src..

# **** Procedure applications
**** Aplicaciones de procedimiento

#      The execution procedure for applications contains no new ideas except for the
#      technical complexity of managing the continuations. This complexity arises in
#      @c(analyze-application), due to the need to keep track of the success and
#      failure continuations as we evaluate the operands. We use a procedure
#      @c(get-args) to evaluate the list of operands, rather than a simple @c(map) as
#      in the ordinary evaluator.
     El procedimiento de ejecución de las solicitudes no contiene nuevas ideas
     excepto por la complejidad técnica de gestionar las continuaciones. Esta
     complejidad surge @c(analyze-application) debido a la necesidad de mantener
     un seguimiento de las continuaciones de éxito y falla al evaluar los
     operandos. Utilizamos un procedimiento @c(get-args) para evaluar la lista
     de operandos, en lugar de un simple @c(map) como en el evaluador ordinario.

#      ..src > scheme
#        (define (analyze-application exp)
#          (let ((fproc (analyze (operator exp)))
#                (aprocs (map analyze (operands exp))))
#            (lambda (env succeed fail)
#              (fproc env
#                     (lambda (proc fail2)
#                       (get-args
#                        aprocs
#                        env
#                        (lambda (args fail3)
#                          (execute-application
#                           proc args succeed fail3))
#                        fail2))
#                     fail))))
#      < src..
     ..src > scheme
       (define (analyze-application exp)
         (let ((fproc (analyze (operator exp)))
               (aprocs (map analyze (operands exp))))
           (lambda (env succeed fail)
             (fproc env
                    (lambda (proc fail2)
                      (get-args
                       aprocs
                       env
                       (lambda (args fail3)
                         (execute-application
                          proc args succeed fail3))
                       fail2))
                    fail))))
     < src..

#      In @c(get-args), notice how @c(cdr)-ing down the list of @c(aproc) execution
#      procedures and @c(cons)ing up the resulting list of @c(args) is accomplished
#      by calling each @c(aproc) in the list with a success continuation that
#      recursively calls @c(get-args). Each of these recursive calls to @c(get-args)
#      has a success continuation whose value is the @c(cons) of the newly obtained
#      argument onto the list of accumulated arguments:
     En @c(get-args), observe cómo @c(cdr)-abajo la lista de los procedimientos @c(aproc)
     de la ejecución e @c(cons) ing encima de la lista resultante
     de @c(args) se realiza llamando cada uno @c(aproc) en la lista con una
     continuación del éxito que recursively llama @c(get-args). Cada una de
     estas llamadas recursivas @c(get-args) tiene una continuación de éxito cuyo
     valor es el @c(cons) del argumento recién obtenido en la lista de
     argumentos acumulados:

#      ..src > scheme
#        (define (get-args aprocs env succeed fail)
#          (if (null? aprocs)
#              (succeed '() fail)
#              ((car aprocs)
#               env
#               ;; success continuation for this @c(aproc)
#               (lambda (arg fail2)
#                 (get-args
#                  (cdr aprocs)
#                  env
#                  ;; success continuation for
#                  ;; recursive call to @c(get-args)
#                  (lambda (args fail3)
#                    (succeed (cons arg args)
#                             fail3))
#                  fail2))
#               fail)))
#      < src..
     ..src > scheme
       (define (get-args aprocs env succeed fail)
         (if (null? aprocs)
             (succeed '() fail)
             ((car aprocs)
              env
              ;; success continuation for this @c(aproc)
              (lambda (arg fail2)
                (get-args
                 (cdr aprocs)
                 env
                 ;; success continuation for
                 ;; recursive call to @c(get-args)
                 (lambda (args fail3)
                   (succeed (cons arg args)
                            fail3))
                 fail2))
              fail)))
     < src..

#      The actual procedure application, which is performed by
#      @c(execute-application), is accomplished in the same way as for the ordinary
#      evaluator, except for the need to manage the continuations.
     La aplicación de procedimiento real, que es realizada por
     @c(execute-application), se realiza de la misma manera que para el
     evaluador ordinario, excepto para la necesidad de administrar las
     continuaciones.

#      ..src > scheme
#        (define (execute-application
#                 proc args succeed fail)
#          (cond ((primitive-procedure? proc)
#                 (succeed
#                  (apply-primitive-procedure
#                   proc args)
#                  fail))
#                ((compound-procedure? proc)
#                 ((procedure-body proc)
#                  (extend-environment
#                   (procedure-parameters proc)
#                   args
#                   (procedure-environment proc))
#                  succeed
#                  fail))
#                (else (error "Unknown procedure type:
#                              EXECUTE-APPLICATION"
#                             proc))))
#      < src..
     ..src > scheme
       (define (execute-application
                proc args succeed fail)
         (cond ((primitive-procedure? proc)
                (succeed
                 (apply-primitive-procedure
                  proc args)
                 fail))
               ((compound-procedure? proc)
                ((procedure-body proc)
                 (extend-environment
                  (procedure-parameters proc)
                  args
                  (procedure-environment proc))
                 succeed
                 fail))
               (else (error "Unknown procedure type:
                             EXECUTE-APPLICATION"
                            proc))))
     < src..

# **** Evaluating @c(amb) expressions
**** Evaluación de @c(amb) expresiones

#      The @c(amb) special form is the key element in the nondeterministic
#      language. Here we see the essence of the interpretation process and the reason
#      for keeping track of the continuations. The execution procedure for @c(amb)
#      defines a loop @c(try-next) that cycles through the execution procedures for
#      all the possible values of the @c(amb) expression. Each execution procedure is
#      called with a failure continuation that will try the next one. When there are
#      no more alternatives to try, the entire @c(amb) expression fails.
     La @c(amb) forma especial es el elemento clave en el lenguaje no
     determinista. Aquí vemos la esencia del proceso de interpretación y la
     razón para seguir las continuaciones. El procedimiento de ejecución @c(amb)
     define un bucle @c(try-next) que recorre los procedimientos de ejecución
     para todos los valores posibles de la @c(amb) expresión. Cada procedimiento
     de ejecución se llama con una continuación de fallo que intentará el
     siguiente. Cuando ya no hay más alternativas para intentar, toda la @c(amb)
     expresión falla.

#      ..src > scheme
#        (define (analyze-amb exp)
#          (let ((cprocs
#                 (map analyze (amb-choices exp))))
#            (lambda (env succeed fail)
#              (define (try-next choices)
#                (if (null? choices)
#                    (fail)
#                    ((car choices)
#                     env
#                     succeed
#                     (lambda ()
#                       (try-next (cdr choices))))))
#              (try-next cprocs))))
#      < src..
     ..src > scheme
       (define (analyze-amb exp)
         (let ((cprocs
                (map analyze (amb-choices exp))))
           (lambda (env succeed fail)
             (define (try-next choices)
               (if (null? choices)
                   (fail)
                   ((car choices)
                    env
                    succeed
                    (lambda ()
                      (try-next (cdr choices))))))
             (try-next cprocs))))
     < src..

# **** Driver loop
**** Bucle del conductor

#      The driver loop for the @c(amb) evaluator is complex, due to the mechanism
#      that permits the user to try again in evaluating an expression. The driver
#      uses a procedure called @c(internal-loop), which takes as argument a procedure
#      @c(try-again). The intent is that calling @c(try-again) should go on to the
#      next untried alternative in the nondeterministic evaluation.
#      @c(Internal-loop) either calls @c(try-again) in response to the user typing
#      @c(try-again) at the driver loop, or else starts a new evaluation by calling
#      @c(ambeval).
     El bucle del controlador para el @c(amb) evaluador es complejo, debido al
     mecanismo que permite al usuario intentar de nuevo en la evaluación de una
     expresión. El conductor utiliza un procedimiento llamado @c(internal-loop),
     que toma como argumento un procedimiento @c(try-again). La intención es que
     la llamada @c(try-again) debe pasar a la siguiente alternativa no probada
     en la evaluación no determinista. @c(Internal-loop) O llama @c(try-again)
     en respuesta al usuario que teclea @c(try-again) en el bucle del
     controlador, o bien inicia una nueva evaluación llamando @c(ambeval).

#      The failure continuation for this call to @c(ambeval) informs the user that
#      there are no more values and re-invokes the driver loop.
     La continuación del fallo para esta llamada @c(ambeval) informa al usuario
     de que no hay más valores y vuelve a invocar el bucle del controlador.

#      The success continuation for the call to @c(ambeval) is more subtle. We print
#      the obtained value and then invoke the internal loop again with a
#      @c(try-again) procedure that will be able to try the next alternative. This
#      @c(next-alternative) procedure is the second argument that was passed to the
#      success continuation. Ordinarily, we think of this second argument as a
#      failure continuation to be used if the current evaluation branch later fails.
#      In this case, however, we have completed a successful evaluation, so we can
#      invoke the @"(failure) alternative branch in order to search for additional
#      successful evaluations.
     La continuación del éxito para la llamada a @c(ambeval) es más
     sutil. Imprimimos el valor obtenido y luego invocamos el bucle interno de
     nuevo con un procedimiento @c(try-again) que será capaz de probar la
     siguiente alternativa. Este procedimiento @c(next-alternative) es el
     segundo argumento que se pasó a la continuación del éxito. Normalmente,
     pensamos en este segundo argumento como una continuación del fallo que se
     utilizará si la rama de evaluación actual falla posteriormente. En este
     caso, sin embargo, hemos completado una evaluación exitosa, por lo que
     podemos invocar la rama alternativa de @"(fallo) para buscar evaluaciones
     exitosas adicionales.

#      ..src > scheme
#        (define input-prompt  ";;; Amb-Eval input:")
#        (define output-prompt ";;; Amb-Eval value:")
#
#        (define (driver-loop)
#          (define (internal-loop try-again)
#            (prompt-for-input input-prompt)
#            (let ((input (read)))
#              (if (eq? input 'try-again)
#                  (try-again)
#                  (begin
#                    (newline)
#                    (display
#                     ";;; Starting a new problem ")
#                    (ambeval
#                     input
#                     the-global-environment
#                     ;; @c(ambeval) success
#                     (lambda (val next-alternative)
#                       (announce-output
#                        output-prompt)
#                       (user-print val)
#                       (internal-loop
#                        next-alternative))
#                     ;; @c(ambeval) failure
#                     (lambda ()
#                       (announce-output
#                        ";;; There are no
#                         more values of")
#                       (user-print input)
#                       (driver-loop)))))))
#          (internal-loop
#           (lambda ()
#             (newline)
#             (display
#              ";;; There is no current problem")
#             (driver-loop))))
#      < src..
     ..src > scheme
       (define input-prompt  ";;; Amb-Eval input:")
       (define output-prompt ";;; Amb-Eval value:")

       (define (driver-loop)
         (define (internal-loop try-again)
           (prompt-for-input input-prompt)
           (let ((input (read)))
             (if (eq? input 'try-again)
                 (try-again)
                 (begin
                   (newline)
                   (display
                    ";;; Starting a new problem ")
                   (ambeval
                    input
                    the-global-environment
                    ;; @c(ambeval) success
                    (lambda (val next-alternative)
                      (announce-output
                       output-prompt)
                      (user-print val)
                      (internal-loop
                       next-alternative))
                    ;; @c(ambeval) failure
                    (lambda ()
                      (announce-output
                       ";;; There are no
                        more values of")
                      (user-print input)
                      (driver-loop)))))))
         (internal-loop
          (lambda ()
            (newline)
            (display
             ";;; There is no current problem")
            (driver-loop))))
     < src..

#      The initial call to @c(internal-loop) uses a @c(try-again) procedure that
#      complains that there is no current problem and restarts the driver loop. This
#      is the behavior that will happen if the user types @c(try-again) when there is
#      no evaluation in progress.
     La llamada inicial @c(internal-loop) utiliza un procedimiento @c(try-again)
     que se queja de que no hay ningún problema actual y reinicia el bucle del
     controlador. Este es el comportamiento que sucederá si el usuario escribe
     @c(try-again) cuando no hay evaluación en curso.

#      :: @t(Exercise 4.50) :: Implement a new special form @c(ramb) that is like
#         @c(amb) except that it searches alternatives in a random order, rather than
#         from left to right. Show how this can help with Alyssa's problem in
#         @l(#Exercise 4.49).
     :: @t(Ejercicio 4.50) :: Implementar una nueva forma especial @c(ramb) que
        es como, @c(amb) excepto que busca alternativas en un orden aleatorio,
        en lugar de de izquierda a derecha. Muestre cómo esto puede ayudar con
        el problema de Alyssa en el @l(#Ejercicio 4.49).

#      :: @t(Exercise 4.51) :: Implement a new kind of assignment called
#         @c(permanent-set!) that is not undone upon failure. For example, we can
#         choose two distinct elements from a list and count the number of trials
#         required to make a successful choice as follows:
     :: @t(Ejercicio 4.51) :: Implementar un nuevo tipo de asignación llamada
        @c(permanent-set!) que no se deshace en caso de fallo. Por ejemplo,
        podemos elegir dos elementos distintos de una lista y contar el número
        de ensayos necesarios para hacer una elección correcta de la siguiente
        manera:

#         ..srci > scheme
#           > (define count 0)
#           > (let ((x (an-element-of '(a b c)))
#           ^       (y (an-element-of '(a b c))))
#           ^   (permanent-set! count (+ count 1))
#           ^   (require (not (eq? x y)))
#           ^   (list x y count))
#
#           ;;; Starting a new problem
#           ;;; Amb-Eval value:
#           (a b 2)
#
#           ;;; Amb-Eval input:
#           > try-again
#
#           ;;; Amb-Eval value:
#           (a c 3)
#         < srci..
        ..srci > scheme
          > (define count 0)
          > (let ((x (an-element-of '(a b c)))
          ^       (y (an-element-of '(a b c))))
          ^   (permanent-set! count (+ count 1))
          ^   (require (not (eq? x y)))
          ^   (list x y count))

          ;;; Starting a new problem
          ;;; Amb-Eval value:
          (a b 2)

          ;;; Amb-Eval input:
          > try-again

          ;;; Amb-Eval value:
          (a c 3)
        < srci..

#         What values would have been displayed if we had used @c(set!) here rather
#         than @c(permanent-set!)?
        ¿Qué valores se habrían mostrado si hubiéramos usado @c(set!) aquí en
        lugar de @c(permanent-set!)?

#      :: @t(Exercise 4.52) :: Implement a new construct called @c(if-fail) that
#         permits the user to catch the failure of an expression.  @c(If-fail) takes
#         two expressions. It evaluates the first expression as usual and returns as
#         usual if the evaluation succeeds. If the evaluation fails, however, the
#         value of the second expression is returned, as in the following example:
     :: @t(Ejercicio 4.52) :: Implementar una nueva construcción llamada
        @c(if-fail) que permite al usuario capturar el error de una expresión.
        @c(If-fail) Toma dos expresiones. Evalúa la primera expresión como de
        costumbre y devuelve como de costumbre si la evaluación tiene éxito. Sin
        embargo, si la evaluación falla, se devuelve el valor de la segunda
        expresión, como en el ejemplo siguiente:

#         ..srci > scheme
#           ;;; Amb-Eval input:
#           > (if-fail
#           ^  (let ((x (an-element-of '(1 3 5))))
#           ^    (require (even? x))
#           ^    x)
#           ^  'all-odd)
#           ;;; Starting a new problem
#           ;;; Amb-Eval value:
#           all-odd
#
#           ;;; Amb-Eval input:
#           > (if-fail
#           ^  (let ((x (an-element-of '(1 3 5 8))))
#           ^    (require (even? x))
#           ^    x)
#           ^  'all-odd)
#
#           ;;; Starting a new problem
#           ;;; Amb-Eval value:
#           8
#         < srci..
        ..srci > scheme
          ;;; Amb-Eval input:
          > (if-fail
          ^  (let ((x (an-element-of '(1 3 5))))
          ^    (require (even? x))
          ^    x)
          ^  'all-odd)
          ;;; Starting a new problem
          ;;; Amb-Eval value:
          all-odd

          ;;; Amb-Eval input:
          > (if-fail
          ^  (let ((x (an-element-of '(1 3 5 8))))
          ^    (require (even? x))
          ^    x)
          ^  'all-odd)

          ;;; Starting a new problem
          ;;; Amb-Eval value:
          8
        < srci..

#      :: @t(Exercise 4.53) :: With @c(permanent-set!) as described in @l(#Exercise
#         4.51) and @c(if-fail) as in @l(#Exercise 4.52), what will be the result of
#         evaluating
     :: @t(Ejercicio 4.53) :: Con @c(permanent-set!) lo descrito en el
        @l(#Ejercicio 4.51) y @c(if-fail) como en el
        @l(#Ejercicio 4.52), ¿cuál será el resultado de la
        evaluación

#         ..src > scheme
#           (let ((pairs '()))
#             (if-fail
#              (let ((p (prime-sum-pair
#                        '(1 3 5 8)
#                        '(20 35 110))))
#                (permanent-set! pairs
#                                (cons p pairs))
#                (amb))
#              pairs))
#         < src..
        ..src > scheme
          (let ((pairs '()))
            (if-fail
             (let ((p (prime-sum-pair
                       '(1 3 5 8)
                       '(20 35 110))))
               (permanent-set! pairs
                               (cons p pairs))
               (amb))
             pairs))
        < src..

#      :: @t(Exercise 4.54) :: If we had not realized that @c(require) could be
#         implemented as an ordinary procedure that uses @c(amb), to be defined by
#         the user as part of a nondeterministic program, we would have had to
#         implement it as a special form. This would require syntax procedures
     :: @t(Ejercicio 4.54) :: Si no nos hubiéramos dado cuenta de que
        @c(require) podría ser implementado como un procedimiento ordinario que
        usa @c(amb), para ser definido por el usuario como parte de un programa
        no determinista, habríamos tenido que implementarlo como una forma
        especial. Esto requeriría procedimientos de sintaxis

#         ..src > scheme
#           (define (require? exp)
#             (tagged-list? exp 'require))
#
#           (define (require-predicate exp)
#             (cadr exp))
#         < src..
        ..src > scheme
          (define (require? exp)
            (tagged-list? exp 'require))

          (define (require-predicate exp)
            (cadr exp))
        < src..

#         and a new clause in the dispatch in @c(analyze)
        Y una nueva cláusula en el despacho @c(analyze)

#         ..src > scheme
#           ((require? exp) (analyze-require exp))
#         < src..
        ..src > scheme
          ((require? exp) (analyze-require exp))
        < src..

#         as well the procedure @c(analyze-require) that handles @c(require)
#         expressions. Complete the following definition of @c(analyze-require).
        Así como el procedimiento @c(analyze-require) que maneja las @c(require)
        expresiones. Complete la siguiente definición de @c(analyze-require).

#         ..src > scheme
#           (define (analyze-require exp)
#             (let ((pproc (analyze
#                           (require-predicate exp))))
#               (lambda (env succeed fail)
#                 (pproc env
#                        (lambda (pred-value fail2)
#                          (if ⟨??⟩
#                              ⟨??⟩
#                              (succeed 'ok fail2)))
#                        fail))))
#         < src..
        ..src > scheme
          (define (analyze-require exp)
            (let ((pproc (analyze
                          (require-predicate exp))))
              (lambda (env succeed fail)
                (pproc env
                       (lambda (pred-value fail2)
                         (if ⟨??⟩
                             ⟨??⟩
                             (succeed 'ok fail2)))
                       fail))))
        < src..

# ** 4.4 <> Logic Programming
** 4.4 <> Programación lógica

#    In @l(#Chapter 1) we stressed that computer science deals with imperative (how
#    to) knowledge, whereas mathematics deals with declarative (what is) knowledge.
#    Indeed, programming languages require that the programmer express knowledge in
#    a form that indicates the step-by-step methods for solving particular
#    problems.  On the other hand, high-level languages provide, as part of the
#    language implementation, a substantial amount of methodological knowledge that
#    frees the user from concern with numerous details of how a specified
#    computation will progress.
   En el @l(Capitulo 1) hemos subrayado que la informática se ocupa
   del imperativo (cómo) el conocimiento, mientras que la matemática trata del
   conocimiento declarativo (lo que es). De hecho, los lenguajes de programación
   requieren que el programador exprese el conocimiento de una forma que indique
   los métodos paso a paso para resolver problemas particulares. Por otro lado,
   los lenguajes de alto nivel proporcionan, como parte de la implementación del
   lenguaje, una cantidad sustancial de conocimiento metodológico que libera al
   usuario de la preocupación con numerosos detalles de cómo progresará un
   cálculo especificado.

#    Most programming languages, including Lisp, are organized around computing the
#    values of mathematical functions. Expression-oriented languages (such as Lisp,
#    Fortran, and Algol) capitalize on the @"(pun) that an expression that
#    describes the value of a function may also be interpreted as a means of
#    computing that value. Because of this, most programming languages are strongly
#    biased toward unidirectional computations (computations with well-defined
#    inputs and outputs). There are, however, radically different programming
#    languages that relax this bias. We saw one such example in section @l(#3.3.5), where
#    the objects of computation were arithmetic constraints. In a constraint system
#    the direction and the order of computation are not so well specified; in
#    carrying out a computation the system must therefore provide more detailed
#    @"(how to) knowledge than would be the case with an ordinary arithmetic
#    computation. This does not mean, however, that the user is released altogether
#    from the responsibility of providing imperative knowledge. There are many
#    constraint networks that implement the same set of constraints, and the user
#    must choose from the set of mathematically equivalent networks a suitable
#    network to specify a particular computation.
   La mayoría de los lenguajes de programación, incluyendo Lisp, se organizan
   alrededor de la computación de los valores de las funciones matemáticas. Los
   lenguajes orientados a la expresión (como Lisp, Fortran y Algol) capitalizan
   en el @"(juego de palabras) que una expresión que describe el valor de una
   función también puede interpretarse como un medio de calcular ese
   valor. Debido a esto, la mayoría de los lenguajes de programación están
   fuertemente sesgados hacia cálculos unidireccionales (cálculos con entradas y
   salidas bien definidas). Sin embargo, hay lenguajes de programación
   radicalmente diferentes que relajan este sesgo. Vimos un ejemplo en
   @l(#3.3.5), donde los objetos de cálculo eran restricciones
   aritméticas. En un sistema de restricciones, la dirección y el orden de
   cálculo no están tan bien especificados; @"(En la realización de un cálculo
   el sistema debe por lo tanto proporcionar más detallada cómo al) conocimiento
   que sería el caso con un cálculo aritmético ordinario. Esto no significa, sin
   embargo, que el usuario es liberado por completo de la responsabilidad de
   proporcionar conocimiento imperativo. Existen muchas redes de restricciones
   que implementan el mismo conjunto de restricciones, y el usuario debe elegir
   entre el conjunto de redes matemáticamente equivalentes una red adecuada para
   especificar un cálculo particular.

#    The nondeterministic program evaluator of section @l(#4.3) also moves away from the
#    view that programming is about constructing algorithms for computing
#    unidirectional functions. In a nondeterministic language, expressions can have
#    more than one value, and, as a result, the computation is dealing with
#    relations rather than with single-valued functions. Logic programming extends
#    this idea by combining a relational vision of programming with a powerful kind
#    of symbolic pattern matching called @e(unification).@n(262)
   El evaluador de programa no determinístico de la seccion @l(#4.3) también se aleja
   de la visión de que la programación se basa en la construcción de algoritmos
   para calcular funciones unidireccionales. En un lenguaje no determinista, las
   expresiones pueden tener más de un valor y, como resultado, el cálculo trata
   de relaciones más que de funciones de un solo valor. La programación lógica
   extiende esta idea combinando una visión relacional de la programación con un
   poderoso tipo de concordancia simbólica de patrones llamada
   @e(unificación).@n(262)

#    This approach, when it works, can be a very powerful way to write programs.
#    Part of the power comes from the fact that a single @"(what is) fact can be
#    used to solve a number of different problems that would have different @"(how
#    to) components. As an example, consider the @c(append) operation, which takes
#    two lists as arguments and combines their elements to form a single list.  In
#    a procedural language such as Lisp, we could define @c(append) in terms of the
#    basic list constructor @c(cons), as we did in section @l(#2.2.1):
   Este enfoque, cuando funciona, puede ser una forma muy poderosa de escribir
   programas. Parte de la energía viene del hecho de que un solo @"(qué es)
   hecho se puede utilizar para resolver una serie de diversos problemas que
   tendrían diversa @"(cómo a los) componentes. Como ejemplo, considere la
   @c(append) operación, que toma dos listas como argumentos y combina sus
   elementos para formar una lista única. En un lenguaje procedural como Lisp,
   podríamos definir @c(append) en términos del constructor de lista básica
   @c(cons), como lo hicimos en la seccion @l(#2.2.1) :

#    ..src > scheme
#      (define (append x y)
#        (if (null? x)
#            y
#            (cons (car x) (append (cdr x) y))))
#    < src..
   ..src > scheme
     (define (append x y)
       (if (null? x)
           y
           (cons (car x) (append (cdr x) y))))
   < src..

#    This procedure can be regarded as a translation into Lisp of the following two
#    rules, the first of which covers the case where the first list is empty and
#    the second of which handles the case of a nonempty list, which is a @c(cons)
#    of two parts:
   Este procedimiento puede considerarse como una traducción a Lisp de las dos
   reglas siguientes, la primera de las cuales cubre el caso en que la primera
   lista está vacía y la segunda trata el caso de una lista no vacía, que es
   @c(cons) de dos partes:

#    - For any list @c(y), the empty list and @c(y) @c(append) to form @c(y).
   - Para cualquier lista @c(y), la lista vacía y @c(y) @c(append) para formar
     @c(y).

#    - For any @c(u), @c(v), @c(y), and @c(z), @c[(cons u v)] and @c(y) @c(append)
#      to form @c[(cons u z)] if @c(v) and @c(y) @c(append) to form @c(z).@n(263)

   - Para cualquier @c(u), @c(v), @c(y), y @c(z), @c[(cons u v)] y @c(y)
     @c(append) para formar @c[(cons u z)] si @c(v) y @c(y) @c(append) para
     formar @c(z).@n(263)

#    Using the @c(append) procedure, we can answer questions such as
   Utilizando el procedimiento @c(append), podemos responder preguntas como

#    ..tab >
  ..tab >
#      Find the @c(append) of @c[(a b)] and @c[(c d)].
     Encuentra el @c(append) de @c[(a b)] y @c[(c d)].

#    But the same two rules are also sufficient for answering the following sorts
#    of questions, which the procedure can't answer:
   Pero las mismas dos reglas son suficientes para contestar las siguientes
   preguntas, que el procedimiento no puede responder:

#    ..tab >
  ..tab >
#      Find a list @c(y) that @c(append)s with @c[(a b)] to produce @c[(a b c d)].
     Encontrar una lista @c(y) que @c(append) es la @c[(a b)] de producir @c[(a
     b c d)].

#      Find all @c(x) and @c(y) that @c(append) to form @c[(a b c d)].
     Encuentra todo @c(x) y @c(y) eso @c(append) para formar @c[(a b c d)].
#    < tab..
  < tab..

#    In a logic programming language, the programmer writes an @c(append)
#    @"(procedure) by stating the two rules about @c(append) given above. @"(How
#    to) knowledge is provided automatically by the interpreter to allow this
#    single pair of rules to be used to answer all three types of questions about
#    @c(append).@n(264)
  En un lenguaje de programación lógica, el programador escribe un @c(append)
  @"(procedimiento) indicando las dos reglas sobre @c(append) dado
  arriba. @"(Cómo el) conocimiento es proporcionado automáticamente por el
  intérprete para permitir que este solo par de reglas para ser utilizado para
  responder a los tres tipos de preguntas sobre @c(append).@n(264)

#    Contemporary logic programming languages (including the one we implement here)
#    have substantial deficiencies, in that their general @"(how to) methods can
#    lead them into spurious infinite loops or other undesirable behavior. Logic
#    programming is an active field of research in computer science.@n(265)
  Los lenguajes de programación de lógica contemporánea (incluyendo el que
  implementamos aquí) tienen deficiencias sustanciales, en que su general
  @"(cómo a los) métodos puede conducirlos a espirales bucles infinitos u otro
  comportamiento indeseable. La programación lógica es un campo activo de
  investigación en informática.@n(265)

#    Earlier in this chapter we explored the technology of implementing
#    interpreters and described the elements that are essential to an interpreter
#    for a Lisp-like language (indeed, to an interpreter for any conventional
#    language). Now we will apply these ideas to discuss an interpreter for a logic
#    programming language. We call this language the @e(query language), because it
#    is very useful for retrieving information from data bases by formulating
#    @e(queries), or questions, expressed in the language. Even though the query
#    language is very different from Lisp, we will find it convenient to describe
#    the language in terms of the same general framework we have been using all
#    along: as a collection of primitive elements, together with means of
#    combination that enable us to combine simple elements to create more complex
#    elements and means of abstraction that enable us to regard complex elements as
#    single conceptual units. An interpreter for a logic programming language is
#    considerably more complex than an interpreter for a language like Lisp.
#    Nevertheless, we will see that our query-language interpreter contains many of
#    the same elements found in the interpreter of section @l(#4.1). In particular, there
#    will be an @"(eval) part that classifies expressions according to type and an
#    @"(apply) part that implements the language's abstraction mechanism
#    (procedures in the case of Lisp, and @e(rules) in the case of logic
#    programming). Also, a central role is played in the implementation by a frame
#    data structure, which determines the correspondence between symbols and their
#    associated values. One additional interesting aspect of our query-language
#    implementation is that we make substantial use of streams, which were
#    introduced in @l(#Chapter 3).
  A principios de este capítulo exploramos la tecnología de implementación de
  intérpretes y describimos los elementos que son esenciales para un intérprete
  para un lenguaje semejante a Lisp (de hecho, a un intérprete para cualquier
  lenguaje convencional). Ahora vamos a aplicar estas ideas para discutir un
  intérprete para un lenguaje de programación lógica. Llamamos a este lenguaje
  el lenguaje de @e(consulta), porque es muy útil para recuperar información de
  las bases de datos mediante la formulación de @e(consultas), o preguntas,
  expresadas en el lenguaje. A pesar de que el lenguaje de consulta es muy
  diferente de Lisp, encontraremos conveniente describir el lenguaje en términos
  del mismo marco general que hemos estado usando a lo largo: como una colección
  de elementos primitivos, Junto con medios de combinación que nos permiten
  combinar elementos simples para crear elementos más complejos y medios de
  abstracción que nos permitan considerar elementos complejos como unidades
  conceptuales únicas. Un intérprete para un lenguaje de programación lógica es
  considerablemente más complejo que un intérprete para un lenguaje como
  Lisp. @l(#4.1<>Sin embargo, veremos que nuestro intérprete de lenguaje de
  consulta contiene muchos de los mismos elementos encontrados en el intérprete
  de 4.1). En particular, habrá una parte @"(eval) que clasifique las
  expresiones según el tipo y una parte @"(aplicable) que implemente el
  mecanismo de abstracción del lenguaje (procedimientos en el caso de Lisp y
  @e(reglas) en el caso de la programación lógica). También, Se juega un papel
  central en la implementación por una estructura de datos de trama, que
  determina la correspondencia entre los símbolos y sus valores
  asociados. @l(#Chapter-3<>Otro aspecto interesante de nuestra implementación
  de lenguaje de consulta es que usamos substancialmente los flujos, que fueron
  introducidos en el Capitulo 3).

# *** 4.4.1 <> Deductive Information Retrieval
*** 4.4.1 <> Recuperación de información deducible

#     Logic programming excels in providing interfaces to data bases for information
#     retrieval. The query language we shall implement in this chapter is designed
#     to be used in this way.
    La programación lógica sobresale al proporcionar interfaces a bases de datos
    para la recuperación de información. El lenguaje de consulta que
    implementaremos en este capítulo está diseñado para ser utilizado de esta
    manera.

#     In order to illustrate what the query system does, we will show how it can be
#     used to manage the data base of personnel records for Microshaft, a thriving
#     high-technology company in the Boston area. The language provides
#     pattern-directed access to personnel information and can also take advantage
#     of general rules in order to make logical deductions.
    Con el fin de ilustrar lo que hace el sistema de consulta, mostraremos cómo
    se puede utilizar para administrar la base de datos de registros de personal
    de Microshaft, una próspera empresa de alta tecnología en el área de
    Boston. El lenguaje proporciona acceso dirigido a patrones a la información
    del personal y también puede aprovechar las reglas generales para hacer
    deducciones lógicas.

# **** A sample data base
**** Un ejemplo de base de datos

#      The personnel data base for Microshaft contains @e(assertions) about company
#      personnel. Here is the information about Ben Bitdiddle, the resident computer
#      wizard:
     La base de datos de personal de Microshaft contiene @e(afirmaciones) sobre
     el personal de la empresa. Aquí está la información sobre Ben Bitdiddle, el
     asistente de computadora residente:

#      ..src > scheme
#        (address (Bitdiddle Ben)
#                 (Slumerville (Ridge Road) 10))
#        (job (Bitdiddle Ben) (computer wizard))
#        (salary (Bitdiddle Ben) 60000)
#      < src..
     ..src > scheme
       (address (Bitdiddle Ben)
                (Slumerville (Ridge Road) 10))
       (job (Bitdiddle Ben) (computer wizard))
       (salary (Bitdiddle Ben) 60000)
     < src..

#      Each assertion is a list (in this case a triple) whose elements can themselves
#      be lists.
     Cada aserción es una lista (en este caso un triple) cuyos elementos pueden
     ser listas.

#      As resident wizard, Ben is in charge of the company's computer division, and
#      he supervises two programmers and one technician. Here is the information
#      about them:
     Como asistente residente, Ben está a cargo de la división de computadoras
     de la compañía, y supervisa a dos programadores y un técnico. Aquí está la
     información sobre ellos:

#      ..src > scheme
#        (address (Hacker Alyssa P)
#                 (Cambridge (Mass Ave) 78))
#        (job (Hacker Alyssa P) (computer programmer))
#        (salary (Hacker Alyssa P) 40000)
#        (supervisor (Hacker Alyssa P) (Bitdiddle Ben))
#
#        (address (Fect Cy D)
#                 (Cambridge (Ames Street) 3))
#        (job (Fect Cy D) (computer programmer))
#        (salary (Fect Cy D) 35000)
#        (supervisor (Fect Cy D) (Bitdiddle Ben))
#
#        (address (Tweakit Lem E)
#                 (Boston (Bay State Road) 22))
#        (job (Tweakit Lem E) (computer technician))
#        (salary (Tweakit Lem E) 25000)
#        (supervisor (Tweakit Lem E) (Bitdiddle Ben))
#      < src..
     ..src > scheme
       (address (Hacker Alyssa P)
                (Cambridge (Mass Ave) 78))
       (job (Hacker Alyssa P) (computer programmer))
       (salary (Hacker Alyssa P) 40000)
       (supervisor (Hacker Alyssa P) (Bitdiddle Ben))

       (address (Fect Cy D)
                (Cambridge (Ames Street) 3))
       (job (Fect Cy D) (computer programmer))
       (salary (Fect Cy D) 35000)
       (supervisor (Fect Cy D) (Bitdiddle Ben))

       (address (Tweakit Lem E)
                (Boston (Bay State Road) 22))
       (job (Tweakit Lem E) (computer technician))
       (salary (Tweakit Lem E) 25000)
       (supervisor (Tweakit Lem E) (Bitdiddle Ben))
     < src..

#      There is also a programmer trainee, who is supervised by Alyssa:
     También hay un aprendiz de programador, que está supervisado por Alyssa:

#      ..src > scheme
#        (address (Reasoner Louis)
#                 (Slumerville (Pine Tree Road) 80))
#        (job (Reasoner Louis)
#             (computer programmer trainee))
#        (salary (Reasoner Louis) 30000)
#        (supervisor (Reasoner Louis)
#                    (Hacker Alyssa P))
#      < src..
     ..src > scheme
       (address (Reasoner Louis)
                (Slumerville (Pine Tree Road) 80))
       (job (Reasoner Louis)
            (computer programmer trainee))
       (salary (Reasoner Louis) 30000)
       (supervisor (Reasoner Louis)
                   (Hacker Alyssa P))
     < src..

#      All of these people are in the computer division, as indicated by the word
#      @c(computer) as the first item in their job descriptions.
     Todas estas personas están en la división de informática, como lo indica la
     palabra @c(computer) como el primer elemento en sus descripciones de
     trabajo.

#      Ben is a high-level employee. His supervisor is the company's big wheel
#      himself:
     Ben es un empleado de alto nivel. Su supervisor es la propia gran rueda de
     la compañía:

#      ..src > scheme
#        (supervisor (Bitdiddle Ben) (Warbucks Oliver))
#        (address (Warbucks Oliver)
#                 (Swellesley (Top Heap Road)))
#        (job (Warbucks Oliver)
#             (administration big wheel))
#        (salary (Warbucks Oliver) 150000)
#      < src..
     ..src > scheme
       (supervisor (Bitdiddle Ben) (Warbucks Oliver))
       (address (Warbucks Oliver)
                (Swellesley (Top Heap Road)))
       (job (Warbucks Oliver)
            (administration big wheel))
       (salary (Warbucks Oliver) 150000)
     < src..

#      Besides the computer division supervised by Ben, the company has an accounting
#      division, consisting of a chief accountant and his assistant:
     Además de la división de informática supervisada por Ben, la empresa cuenta
     con una división de contabilidad, compuesta por un contador principal y su
     asistente:

#      ..src > scheme
#        (address (Scrooge Eben)
#                 (Weston (Shady Lane) 10))
#        (job (Scrooge Eben)
#             (accounting chief accountant))
#        (salary (Scrooge Eben) 75000)
#        (supervisor (Scrooge Eben) (Warbucks Oliver))
#
#        (address (Cratchet Robert)
#                 (Allston (N Harvard Street) 16))
#        (job (Cratchet Robert) (accounting scrivener))
#        (salary (Cratchet Robert) 18000)
#        (supervisor (Cratchet Robert) (Scrooge Eben))
#      < src..
     ..src > scheme
       (address (Scrooge Eben)
                (Weston (Shady Lane) 10))
       (job (Scrooge Eben)
            (accounting chief accountant))
       (salary (Scrooge Eben) 75000)
       (supervisor (Scrooge Eben) (Warbucks Oliver))

       (address (Cratchet Robert)
                (Allston (N Harvard Street) 16))
       (job (Cratchet Robert) (accounting scrivener))
       (salary (Cratchet Robert) 18000)
       (supervisor (Cratchet Robert) (Scrooge Eben))
     < src..

#      There is also a secretary for the big wheel:
     También hay una secretaria para la rueda grande:

#      ..src > scheme
#        (address (Aull DeWitt)
#                 (Slumerville (Onion Square) 5))
#        (job (Aull DeWitt) (administration secretary))
#        (salary (Aull DeWitt) 25000)
#        (supervisor (Aull DeWitt) (Warbucks Oliver))
#      < src..
     ..src > scheme
       (address (Aull DeWitt)
                (Slumerville (Onion Square) 5))
       (job (Aull DeWitt) (administration secretary))
       (salary (Aull DeWitt) 25000)
       (supervisor (Aull DeWitt) (Warbucks Oliver))
     < src..

#      The data base also contains assertions about which kinds of jobs can be done
#      by people holding other kinds of jobs. For instance, a computer wizard can do
#      the jobs of both a computer programmer and a computer technician:
     La base de datos también contiene afirmaciones sobre qué tipos de trabajos
     pueden ser realizados por personas que tienen otros tipos de trabajos. Por
     ejemplo, un asistente de computadora puede hacer los trabajos de un
     programador de computadora y un técnico de computadora:

#      ..src > scheme
#        (can-do-job (computer wizard)
#                    (computer programmer))
#
#        (can-do-job (computer wizard)
#                    (computer technician))
#      < src..
     ..src > scheme
       (can-do-job (computer wizard)
                   (computer programmer))

       (can-do-job (computer wizard)
                   (computer technician))
     < src..

#      A computer programmer could fill in for a trainee:
     Un programador de computadora podría llenar para un aprendiz:

#      ..src > scheme
#        (can-do-job (computer programmer)
#                    (computer programmer trainee))
#      < src..
     ..src > scheme
       (can-do-job (computer programmer)
                   (computer programmer trainee))
     < src..

#      Also, as is well known,
     También, como es bien conocido,

#      ..src > scheme
#        (can-do-job (administration secretary)
#                    (administration big wheel))
#      < src..
     ..src > scheme
       (can-do-job (administration secretary)
                   (administration big wheel))
     < src..

# **** Simple queries
**** Consultas sencillas

#      The query language allows users to retrieve information from the data base by
#      posing queries in response to the system's prompt. For example, to find all
#      computer programmers one can say
     El lenguaje de consulta permite a los usuarios recuperar información de la
     base de datos mediante la presentación de consultas en respuesta a la
     solicitud del sistema. Por ejemplo, para encontrar todos los programadores
     de computadoras uno puede decir

#      ..srci > scheme
#        ;;; Query input:
#        > (job ?x (computer programmer))
#      < srci..
     ..srci > scheme
       ;;; Query input:
       > (job ?x (computer programmer))
     < srci..

#      The system will respond with the following items:
     El sistema responderá con los siguientes elementos:

#      ..srci > scheme
#        ;;; Query results:
#        > (job (Hacker Alyssa P) (computer programmer))
#        > (job (Fect Cy D) (computer programmer))
#      < srci..
     ..srci > scheme
       ;;; Query results:
       > (job (Hacker Alyssa P) (computer programmer))
       > (job (Fect Cy D) (computer programmer))
     < srci..

#      The input query specifies that we are looking for entries in the data base
#      that match a certain @e(pattern). In this example, the pattern specifies
#      entries consisting of three items, of which the first is the literal symbol
#      @c(job), the second can be anything, and the third is the literal list
#      @c[(computer programmer)]. The @"(anything) that can be the second item in the
#      matching list is specified by a @e(pattern variable), @c(?x). The general form
#      of a pattern variable is a symbol, taken to be the name of the variable,
#      preceded by a question mark. We will see below why it is useful to specify
#      names for pattern variables rather than just putting @c(?) into patterns to
#      represent @"(anything.)  The system responds to a simple query by showing all
#      entries in the data base that match the specified pattern.
     La consulta de entrada especifica que estamos buscando entradas en la base
     de datos que coincidan con un determinado @e(patrón). En este ejemplo, el
     patrón especifica entradas que consisten en tres elementos, de los cuales
     el primero es el símbolo literal @c(job), el segundo puede ser cualquier
     cosa y el tercero es la lista literal @c[(computer programmer)]. La
     @"(cosa) que puede ser el segundo elemento de la lista de coincidencias es
     especificado por una @e(variable de patrón), @c(?x). La forma general de
     una variable de patrón es un símbolo, tomado como el nombre de la variable,
     precedido por un signo de interrogación. Veremos a continuación por qué es
     útil especificar nombres para variables de patrón en lugar de simplemente
     poner @c(?) en patrones para representar @"(cualquier cosa.)

#      A pattern can have more than one variable. For example, the query
     Un patrón puede tener más de una variable. Por ejemplo, la consulta

#      ..src > scheme
#        (address ?x ?y)
#      < src..
     ..src > scheme
       (address ?x ?y)
     < src..

#      will list all the employees' addresses.
     Listará todas las direcciones de los empleados.

#      A pattern can have no variables, in which case the query simply determines
#      whether that pattern is an entry in the data base. If so, there will be one
#      match; if not, there will be no matches.
     Un patrón no puede tener variables, en cuyo caso la consulta simplemente
     determina si ese patrón es una entrada en la base de datos. Si es así,
     habrá un partido; Si no, no habrá partidos.

#      The same pattern variable can appear more than once in a query, specifying
#      that the same @"(anything) must appear in each position. This is why variables
#      have names. For example,
     La misma variable patrón puede aparecer más de una vez en una consulta,
     especificando que la misma @"(nada) debe aparecer en cada posición. Esta es
     la razón por la cual las variables tienen nombres. Por ejemplo,

#      ..src > scheme
#        (supervisor ?x ?x)
#      < src..
     ..src > scheme
       (supervisor ?x ?x)
     < src..

#      finds all people who supervise themselves (though there are no such assertions
#      in our sample data base).
     Encuentra a todas las personas que se supervisan (aunque no hay tales
     afirmaciones en nuestra base de datos de muestra).

#      The query
     La consulta

#      ..src > scheme
#        (job ?x (computer ?type))
#      < src..
     ..src > scheme
       (job ?x (computer ?type))
     < src..

#      matches all job entries whose third item is a two-element list whose first
#      item is @c(computer):
     Coincide con todas las entradas de trabajo cuyo tercer elemento es una
     lista de dos elementos cuyo primer elemento es @c(computer):

#      ..src > scheme
#        (job (Bitdiddle Ben) (computer wizard))
#        (job (Hacker Alyssa P) (computer programmer))
#        (job (Fect Cy D) (computer programmer))
#        (job (Tweakit Lem E) (computer technician))
#      < src..
     ..src > scheme
       (job (Bitdiddle Ben) (computer wizard))
       (job (Hacker Alyssa P) (computer programmer))
       (job (Fect Cy D) (computer programmer))
       (job (Tweakit Lem E) (computer technician))
     < src..

#      This same pattern does @e(not) match
     Este mismo patrón @e(no) coincide

#      ..src > scheme
#        (job (Reasoner Louis)
#             (computer programmer trainee))
#      < src..
     ..src > scheme
       (job (Reasoner Louis)
            (computer programmer trainee))
     < src..

#      because the third item in the entry is a list of three elements, and the
#      pattern's third item specifies that there should be two elements. If we wanted
#      to change the pattern so that the third item could be any list beginning with
#      @c(computer), we could specify@n(266)
     Porque el tercer elemento de la entrada es una lista de tres elementos y el
     tercer elemento del patrón especifica que debe haber dos elementos. Si
     queríamos cambiar el patrón de modo que el tercer elemento pudiera ser
     cualquier lista comenzando con @c(computer), podríamos especificar
    @n(266)

#      ..src > scheme
#        (job ?x (computer . ?type))
#      < src..
     ..src > scheme
       (job ?x (computer . ?type))
     < src..

#      For example,
     Por ejemplo,

#      ..src > scheme
#        (computer . ?type)
#      < src..
     ..src > scheme
       (computer . ?type)
     < src..

#      matches the data
     Coincide con los datos

#      ..src > scheme
#        (computer programmer trainee)
#      < src..
     ..src > scheme
       (computer programmer trainee)
     < src..

#      with @c(?type) as the list @c[(programmer trainee)]. It also matches the data
     Con @c(?type) como la lista @c[(programmer trainee)]. También coincide con
     los datos

#      ..src > scheme
#        (computer programmer)
#      < src..
     ..src > scheme
       (computer programmer)
     < src..

#      with @c(?type) as the list @c[(programmer)], and matches the data
     Con @c(?type) la lista @c[(programmer)] y coincide con los datos

#      ..src > scheme
#        (computer)
#      < src..
     ..src > scheme
       (computer)
     < src..

#      with @c(?type) as the empty list @c[()].
     Con @c(?type) la lista vacía @c[()].

#      We can describe the query language's processing of simple queries as follows:
     Podemos describir el procesamiento del lenguaje de consulta de consultas
     simples de la siguiente manera:

#      - The system finds all assignments to variables in the query pattern that
#        @e(satisfy) the pattern––that is, all sets of values for the variables such
#        that if the pattern variables are @e(instantiated with) (replaced by) the
#        values, the result is in the data base.
     - El sistema encuentra todas las asignaciones a variables en el patrón de
       consulta que @e(satisfacen) el patrón, es decir, todos los conjuntos de
       valores para las variables, de modo que si las variables de patrón se
       @e(instancian con) (reemplazados) por los valores, el resultado está en
       la base de datos.

#      - The system responds to the query by listing all instantiations of the query
#        pattern with the variable assignments that satisfy it.
     - El sistema responde a la consulta enumerando todas las instanciaciones
       del patrón de consulta con las asignaciones de variables que lo
       satisfacen.


#      Note that if the pattern has no variables, the query reduces to a
#      determination of whether that pattern is in the data base. If so, the empty
#      assignment, which assigns no values to variables, satisfies that pattern for
#      that data base.
     Tenga en cuenta que si el patrón no tiene variables, la consulta se reduce
     a una determinación de si ese patrón está en la base de datos. Si es así,
     la asignación vacía, que no asigna valores a las variables, satisface ese
     patrón para esa base de datos.

#      :: @t(Exercise 4.55) :: Give simple queries that retrieve the following
#         information from the data base:
     :: @t(Ejercicio 4.55) :: Proporcione consultas simples que recuperen la
        siguiente información de la base de datos:

#         1. all people supervised by Ben Bitdiddle;
        1. Todas las personas supervisadas por Ben Bitdiddle;

#         2. the names and jobs of all people in the accounting division;
        2. Los nombres y trabajos de todas las personas de la división de
           contabilidad;

#         3. the names and addresses of all people who live in Slumerville.
        3. Los nombres y direcciones de todas las personas que viven en
           Slumerville.

# **** Compound queries
**** Consultas compuestas

#      Simple queries form the primitive operations of the query language. In order
#      to form compound operations, the query language provides means of combination.
#      One thing that makes the query language a logic programming language is that
#      the means of combination mirror the means of combination used in forming
#      logical expressions: @c(and), @c(or), and @c(not). (Here @c(and), @c(or), and
#      @c(not) are not the Lisp primitives, but rather operations built into the
#      query language.)
     Las consultas simples forman las operaciones primitivas del lenguaje de
     consulta. Para formar operaciones compuestas, el lenguaje de consulta
     proporciona medios de combinación. Una cosa que hace el lenguaje de
     consulta de un lenguaje de programación lógica es que los medios de
     combinación reflejan los medios de combinación utilizados en la formación
     de las expresiones lógicas: @c(and), @c(or), y @c(not). (Aquí @c(and),
     @c(or) y @c(not) no son las primitivas Lisp, sino más bien las operaciones
     integradas en el lenguaje de consulta.)

#      We can use @c(and) as follows to find the addresses of all the computer
#      programmers:
     Podemos utilizar @c(and) como sigue para encontrar las direcciones de todos
     los programadores de computadora:

#      ..src > scheme
#        (and (job ?person (computer programmer))
#             (address ?person ?where))
#      < src..
     ..src > scheme
       (and (job ?person (computer programmer))
            (address ?person ?where))
     < src..

#      The resulting output is
     La salida resultante es

#      ..src > scheme
#        (and (job (Hacker Alyssa P)
#                  (computer programmer))
#             (address (Hacker Alyssa P)
#                      (Cambridge (Mass Ave) 78)))
#
#        (and (job (Fect Cy D) (computer programmer))
#             (address (Fect Cy D)
#                      (Cambridge (Ames Street) 3)))
#      < src..
     ..src > scheme
       (and (job (Hacker Alyssa P)
                 (computer programmer))
            (address (Hacker Alyssa P)
                     (Cambridge (Mass Ave) 78)))

       (and (job (Fect Cy D) (computer programmer))
            (address (Fect Cy D)
                     (Cambridge (Ames Street) 3)))
     < src..

#      In general,
     En general,

#      ..src > scheme
#        (and ⟨query₁⟩ ⟨query₂⟩ … ⟨queryₙ⟩)
#      < src..
     ..src > scheme
       (and ⟨query₁⟩ ⟨query₂⟩ … ⟨queryₙ⟩)
     < src..

#      is satisfied by all sets of values for the pattern variables that
#      simultaneously satisfy @m[⟨query₁⟩] … @m[⟨queryₙ⟩].
     Es satisfecha por todos los conjuntos de valores para las variables de
     patrón que satisfacen simultáneamente @m(⟨query₁⟩) ... @m(⟨queryₙ⟩).

#      As for simple queries, the system processes a compound query by finding all
#      assignments to the pattern variables that satisfy the query, then displaying
#      instantiations of the query with those values.
     En cuanto a las consultas simples, el sistema procesa una consulta
     compuesta al encontrar todas las asignaciones a las variables de patrón que
     satisfacen la consulta, luego mostrar las instanciaciones de la consulta
     con esos valores.

#      Another means of constructing compound queries is through @c(or). For example,
     Otro medio de construir consultas compuestas es a través de @c(or). Por
     ejemplo,

#      ..src > scheme
#        (or (supervisor ?x (Bitdiddle Ben))
#            (supervisor ?x (Hacker Alyssa P)))
#      < src..
     ..src > scheme
       (or (supervisor ?x (Bitdiddle Ben))
           (supervisor ?x (Hacker Alyssa P)))
     < src..

#      will find all employees supervised by Ben Bitdiddle or Alyssa P. Hacker:
     Encontrará a todos los empleados supervisados por Ben Bitdiddle o Alyssa
     P. Hacker:

#      ..src > scheme
#        (or (supervisor (Hacker Alyssa P)
#                        (Bitdiddle Ben))
#            (supervisor (Hacker Alyssa P)
#                        (Hacker Alyssa P)))
#
#        (or (supervisor (Fect Cy D)
#                        (Bitdiddle Ben))
#            (supervisor (Fect Cy D)
#                        (Hacker Alyssa P)))
#
#        (or (supervisor (Tweakit Lem E)
#                        (Bitdiddle Ben))
#            (supervisor (Tweakit Lem E)
#                        (Hacker Alyssa P)))
#
#        (or (supervisor (Reasoner Louis)
#                        (Bitdiddle Ben))
#            (supervisor (Reasoner Louis)
#                        (Hacker Alyssa P)))
#      < src..
     ..src > scheme
       (or (supervisor (Hacker Alyssa P)
                       (Bitdiddle Ben))
           (supervisor (Hacker Alyssa P)
                       (Hacker Alyssa P)))

       (or (supervisor (Fect Cy D)
                       (Bitdiddle Ben))
           (supervisor (Fect Cy D)
                       (Hacker Alyssa P)))

       (or (supervisor (Tweakit Lem E)
                       (Bitdiddle Ben))
           (supervisor (Tweakit Lem E)
                       (Hacker Alyssa P)))

       (or (supervisor (Reasoner Louis)
                       (Bitdiddle Ben))
           (supervisor (Reasoner Louis)
                       (Hacker Alyssa P)))
     < src..

#      In general,
     En general,

#      ..src > scheme
#        (or ⟨query₁⟩ ⟨query₂⟩ … ⟨queryₙ⟩)
#      < src..
     ..src > scheme
       (or ⟨query₁⟩ ⟨query₂⟩ … ⟨queryₙ⟩)
     < src..

#      is satisfied by all sets of values for the pattern variables that satisfy at
#      least one of @m[⟨query₁⟩] … @m[⟨queryₙ⟩].
     Es satisfecha por todos los conjuntos de valores para las variables de
     patrón que satisfacen al menos uno de @m(⟨query₁⟩) ... @m(⟨queryₙ⟩).

#      Compound queries can also be formed with @c(not). For example,
     También se pueden formar consultas compuestas @c(not). Por ejemplo,

#      ..src > scheme
#        (and (supervisor ?x (Bitdiddle Ben))
#             (not (job ?x (computer programmer))))
#      < src..
     ..src > scheme
       (and (supervisor ?x (Bitdiddle Ben))
            (not (job ?x (computer programmer))))
     < src..

#      finds all people supervised by Ben Bitdiddle who are not computer programmers.
#      In general,
     Encuentra a todas las personas supervisadas por Ben Bitdiddle que no son
     programadores de computadoras. En general,

#      ..src > scheme
#        (not ⟨query₁⟩)
#      < src..
     ..src > scheme
       (not ⟨query₁⟩)
     < src..

#      is satisfied by all assignments to the pattern variables that do not satisfy
#      @m[⟨query₁⟩].@n(267)
     Se satisface por todas las asignaciones a las variables de patrón que no
     satisfacen @m(⟨query₁⟩).@n(267)

#      The final combining form is called @c(lisp-value). When @c(lisp-value) is the
#      first element of a pattern, it specifies that the next element is a Lisp
#      predicate to be applied to the rest of the (instantiated) elements as
#      arguments. In general,
     La forma de combinación final se llama @c(lisp-value). Cuando
     @c(lisp-value) es el primer elemento de un patrón, especifica que el
     siguiente elemento es un predicado Lisp que se aplicará al resto de los
     elementos (instanciados) como argumentos. En general,

#      ..src > scheme
#        (lisp-value ⟨predicate⟩ ⟨arg₁⟩ … ⟨argₙ⟩)
#      < src..
     ..src > scheme
       (lisp-value ⟨predicate⟩ ⟨arg₁⟩ … ⟨argₙ⟩)
     < src..

#      will be satisfied by assignments to the pattern variables for which the
#      @c[(predicate)] applied to the instantiated @m[⟨arg₁⟩] …  @m[⟨argₙ⟩] is
#      true. For example, to find all people whose salary is greater than $30,000 we
#      could write@n(268)
     Será satisfecho por asignaciones a las variables de patrón para las cuales
     la @c[(predicate)] aplicada a la @m(⟨arg₁⟩) ...  @m(⟨arg )@m(inst)
     instanciada es verdadera. Por ejemplo, para encontrar a todas las personas
     cuyo salario es mayor a $ 30,000 podríamos escribir@n(268)

#      ..src > scheme
#        (and (salary ?person ?amount)
#             (lisp-value > ?amount 30000))
#      < src..
     ..src > scheme
       (and (salary ?person ?amount)
            (lisp-value > ?amount 30000))
     < src..

#      :: @t(Exercise 4.56) :: Formulate compound queries that
#         retrieve the following information:
     :: @t(Ejercicio 4.56) :: Formular consultas compuestas que recuperan la
        siguiente información:

#         1. the names of all people who are supervised by Ben Bitdiddle, together
#            with their addresses;
        1. Los nombres de todas las personas que son supervisadas por Ben
           Bitdiddle, junto con sus direcciones;

#         2. all people whose salary is less than Ben Bitdiddle's, together with
#            their salary and Ben Bitdiddle's salary;
        2. Todas las personas cuyo salario es inferior al de Ben Bitdiddle,
           junto con su salario y el salario de Ben Bitdiddle;

#         3. all people who are supervised by someone who is not in the computer
#            division, together with the supervisor's name and job.
        3. Todas las personas que son supervisadas por alguien que no está en la
           división de informática, junto con el nombre del supervisor y el
           trabajo.

# **** Rules
**** Reglas

#      In addition to primitive queries and compound queries, the query language
#      provides means for abstracting queries. These are given by @e(rules).  The
#      rule
     Además de consultas primitivas y consultas compuestas, el lenguaje de
     consulta proporciona medios para abstraer las consultas. Estos son dados
     por las @e(reglas). La regla

#      ..src > scheme
#        (rule (lives-near ?person-1 ?person-2)
#              (and (address ?person-1
#                            (?town . ?rest-1))
#                   (address ?person-2
#                            (?town . ?rest-2))
#                   (not (same ?person-1 ?person-2))))
#      < src..
     ..src > scheme
       (rule (lives-near ?person-1 ?person-2)
             (and (address ?person-1
                           (?town . ?rest-1))
                  (address ?person-2
                           (?town . ?rest-2))
                  (not (same ?person-1 ?person-2))))
     < src..

#      specifies that two people live near each other if they live in the same town.
#      The final @c(not) clause prevents the rule from saying that all people live
#      near themselves. The @c(same) relation is defined by a very simple
#      rule:@n(269)
     Especifica que dos personas viven cerca unas de otras si viven en la misma
     ciudad. La @c(not) cláusula final impide que la regla diga que todas las
     personas viven cerca de sí mismas. La @c(same) relación se define por una
     regla muy simple:@n(269)

#      ..src > scheme
#        (rule (same ?x ?x))
#      < src..
     ..src > scheme
       (rule (same ?x ?x))
     < src..

#      The following rule declares that a person is a @"(wheel) in an organization if
#      he supervises someone who is in turn a supervisor:
     La siguiente regla declara que una persona es una @"(rueda) en una
     organización si supervisa a alguien que a su vez es un supervisor:

#      ..src > scheme
#        (rule (wheel ?person)
#              (and (supervisor ?middle-manager
#                               ?person)
#                   (supervisor ?x ?middle-manager)))
#      < src..
     ..src > scheme
       (rule (wheel ?person)
             (and (supervisor ?middle-manager
                              ?person)
                  (supervisor ?x ?middle-manager)))
     < src..

#      The general form of a rule is
     La forma general de una regla es

#      ..src > scheme
#        (rule ⟨conclusion⟩ ⟨body⟩)
#      < src..
     ..src > scheme
       (rule ⟨conclusion⟩ ⟨body⟩)
     < src..

#      where @c[(conclusion)] is a pattern and @c[(body)] is any query.@n(270) We can
#      think of a rule as representing a large (even infinite) set of assertions,
#      namely all instantiations of the rule conclusion with variable assignments
#      that satisfy the rule body. When we described simple queries (patterns), we
#      said that an assignment to variables satisfies a pattern if the instantiated
#      pattern is in the data base. But the pattern needn't be explicitly in the data
#      base as an assertion. It can be an implicit assertion implied by a rule. For
#      example, the query
     Donde @c[(conclusion)] es un patrón y @c[(body)] es cualquier
     consulta.@n(270) Se puede pensar en una regla como la representación
     de un grande (incluso infinito) conjunto de afirmaciones, es decir, todas
     las instancias de la conclusión de la regla con las asignaciones de
     variables que satisfacen la regla cuerpo. Cuando describimos consultas
     simples (patrones), dijimos que una asignación a variables satisface un
     patrón si el patrón instanciado está en la base de datos. Pero el patrón no
     necesita estar explícitamente en la base de datos como una
     afirmación. Puede ser una aseveración implícita implícita en una regla. Por
     ejemplo, la consulta

#      ..src > scheme
#        (lives-near ?x (Bitdiddle Ben))
#      < src..
     ..src > scheme
       (lives-near ?x (Bitdiddle Ben))
     < src..

#      results in
     Resulta en

#      ..src > scheme
#        (lives-near (Reasoner Louis) (Bitdiddle Ben))
#        (lives-near (Aull DeWitt) (Bitdiddle Ben))
#      < src..
     ..src > scheme
       (lives-near (Reasoner Louis) (Bitdiddle Ben))
       (lives-near (Aull DeWitt) (Bitdiddle Ben))
     < src..

#      To find all computer programmers who live near Ben Bitdiddle, we can ask
     Para encontrar todos los programadores que viven cerca de Ben Bitdiddle,
     podemos preguntar

#      ..src > scheme
#        (and (job ?x (computer programmer))
#             (lives-near ?x (Bitdiddle Ben)))
#      < src..
     ..src > scheme
       (and (job ?x (computer programmer))
            (lives-near ?x (Bitdiddle Ben)))
     < src..

#      As in the case of compound procedures, rules can be used as parts of other
#      rules (as we saw with the @c(lives-near) rule above) or even be defined
#      recursively. For instance, the rule
     Como en el caso de los procedimientos compuestos, las reglas pueden usarse
     como partes de otras reglas (como vimos con la @c(lives-near) regla
     anterior) o incluso ser definidas recursivamente. Por ejemplo, la regla

#      ..src > scheme
#        (rule (outranked-by ?staff-person ?boss)
#              (or (supervisor ?staff-person ?boss)
#                  (and (supervisor ?staff-person
#                                   ?middle-manager)
#                       (outranked-by ?middle-manager
#                                     ?boss))))
#      < src..
     ..src > scheme
       (rule (outranked-by ?staff-person ?boss)
             (or (supervisor ?staff-person ?boss)
                 (and (supervisor ?staff-person
                                  ?middle-manager)
                      (outranked-by ?middle-manager
                                    ?boss))))
     < src..

#      says that a staff person is outranked by a boss in the organization if the
#      boss is the person's supervisor or (recursively) if the person's supervisor is
#      outranked by the boss.
     Dice que una persona del personal es superada por un jefe en la
     organización si el jefe es el supervisor de la persona o (recursivamente)
     si el supervisor de la persona es superado por el jefe.

#      :: @t(Exercise 4.57) :: Define a rule that says that person 1 can replace
#         person 2 if either person 1 does the same job as person 2 or someone who
#         does person 1's job can also do person 2's job, and if person 1 and person
#         2 are not the same person. Using your rule, give queries that find the
#         following:
     :: @t(Ejercicio 4.57) :: Definir una regla que dice que la persona 1 puede
        reemplazar a la persona 2 si cualquiera de las personas 1 hace el mismo
        trabajo que la persona 2 o alguien que hace el trabajo de la persona 1
        también puede hacer el trabajo de la persona 2 y si la persona 1 y la
        persona 2 no son la misma persona. Utilizando su regla, realice
        consultas que encuentren lo siguiente:

#         1. all people who can replace Cy D. Fect;
        1. Todas las personas que pueden reemplazar a Cy D. Fect;

#         2. all people who can replace someone who is being paid more than they are,
#            together with the two salaries.
        2. Todas las personas que pueden reemplazar a alguien que está pagando
           más de lo que son, junto con los dos salarios.

#      :: @t(Exercise 4.58) :: Define a rule that says that a person is a @"(big
#         shot) in a division if the person works in the division but does not have a
#         supervisor who works in the division.
     :: @t(Ejercicio 4.58) :: Definir una regla que dice que una persona es un
        @"(gran disparo) en una división si la persona trabaja en la división
        pero no tiene un supervisor que trabaja en la división.

#      :: @t(Exercise 4.59) :: Ben Bitdiddle has missed one meeting too many. Fearing
#         that his habit of forgetting meetings could cost him his job, Ben decides
#         to do something about it. He adds all the weekly meetings of the firm to
#         the Microshaft data base by asserting the following:
     :: @t(Ejercicio 4.59) :: Ben Bitdiddle ha perdido una reunión
        demasiado. Temiendo que su hábito de olvidar las reuniones pudiera
        costarle su trabajo, Ben decide hacer algo al respecto. Añade todas las
        reuniones semanales de la empresa a la base de datos Microshaft
        afirmando lo siguiente:

#         ..src > scheme
#           (meeting accounting (Monday 9am))
#           (meeting administration (Monday 10am))
#           (meeting computer (Wednesday 3pm))
#           (meeting administration (Friday 1pm))
#         < src..
        ..src > scheme
          (meeting accounting (Monday 9am))
          (meeting administration (Monday 10am))
          (meeting computer (Wednesday 3pm))
          (meeting administration (Friday 1pm))
        < src..

#         Each of the above assertions is for a meeting of an entire division. Ben
#         also adds an entry for the company-wide meeting that spans all the
#         divisions. All of the company's employees attend this meeting.
        Cada una de las afirmaciones anteriores es para una reunión de una
        división entera. Ben también agrega una entrada para la reunión de toda
        la compañía que abarca todas las divisiones. Todos los empleados de la
        empresa asisten a esta reunión.

#         ..src > scheme
#           (meeting whole-company (Wednesday 4pm))
#         < src..
        ..src > scheme
          (meeting whole-company (Wednesday 4pm))
        < src..

#         1. On Friday morning, Ben wants to query the data base for all the meetings
#            that occur that day. What query should he use?
        1. El viernes por la mañana, Ben quiere consultar la base de datos para
           todas las reuniones que ocurren ese día. ¿Qué consulta debe utilizar?

#         2. Alyssa P. Hacker is unimpressed. She thinks it would be much more useful
#            to be able to ask for her meetings by specifying her name. So she
#            designs a rule that says that a person's meetings include all
#            @c(whole-company) meetings plus all meetings of that person's
#            division. Fill in the body of Alyssa's rule.
        2. Alyssa P. Hacker no está impresionado. Ella piensa que sería mucho
           más útil poder pedir sus reuniones especificando su nombre. Así que
           diseña una regla que dice que las reuniones de una persona incluyen
           todas las @c(whole-company) reuniones y todas las reuniones de la
           división de esa persona. Rellena el cuerpo de la regla de Alyssa.

#            ..src > scheme
#              (rule (meeting-time ?person ?day-and-time)
#                    ⟨rule-body⟩)
#            < src..
           ..src > scheme
             (rule (meeting-time ?person ?day-and-time)
                   ⟨rule-body⟩)
           < src..

#         3. Alyssa arrives at work on Wednesday morning and wonders what meetings
#            she has to attend that day. Having defined the above rule, what query
#            should she make to find this out?
        3. Alyssa llega a trabajar el miércoles por la mañana y se pregunta qué
           reuniones tiene que asistir ese día. Una vez definida la regla
           anterior, ¿qué consulta debe hacer para averiguar esto?

#      :: @t(Exercise 4.60) :: By giving the query
     :: @t(Ejercicio 4.60) :: Al dar la consulta

#         ..src > scheme
#           (lives-near ?person (Hacker Alyssa P))
#         < src..
        ..src > scheme
          (lives-near ?person (Hacker Alyssa P))
        < src..

#         Alyssa P. Hacker is able to find people who live near her, with whom she
#         can ride to work. On the other hand, when she tries to find all pairs of
#         people who live near each other by querying
        Alyssa P. Hacker es capaz de encontrar personas que viven cerca de ella,
        con quien puede montar a trabajar. Por otro lado, cuando trata de
        encontrar a todos los pares de personas que viven cerca de uno al otro
        consultando

#         ..src > scheme
#           (lives-near ?person-1 ?person-2)
#         < src..
        ..src > scheme
          (lives-near ?person-1 ?person-2)
        < src..

#         she notices that each pair of people who live near each other is listed
#         twice; for example,
        Se da cuenta de que cada par de personas que viven cerca uno del otro se
        enumera dos veces; por ejemplo,

#         ..src > scheme
#           (lives-near (Hacker Alyssa P) (Fect Cy D))
#           (lives-near (Fect Cy D) (Hacker Alyssa P))
#         < src..
        ..src > scheme
          (lives-near (Hacker Alyssa P) (Fect Cy D))
          (lives-near (Fect Cy D) (Hacker Alyssa P))
        < src..

#         Why does this happen?  Is there a way to find a list of people who live
#         near each other, in which each pair appears only once?  Explain.
        ¿Por qué pasó esto? ¿Hay una manera de encontrar una lista de personas
        que viven cerca de la otra, en la que cada par aparece sólo una vez?
        Explique.

# **** Logic as programs
**** Lógica como programas

#      We can regard a rule as a kind of logical implication: @e(If) an assignment of
#      values to pattern variables satisfies the body, @e(then) it satisfies the
#      conclusion. Consequently, we can regard the query language as having the
#      ability to perform @e(logical deductions) based upon the rules. As an example,
#      consider the @c(append) operation described at the beginning of section @l(#4.4). As
#      we said, @c(append) can be characterized by the following two rules:
     Podemos considerar una regla como una especie de implicación lógica: @e(Si)
     una asignación de valores a variables de patrón satisface al cuerpo,
     @e(entonces) satisface la conclusión. En consecuencia, podemos considerar
     que el lenguaje de consulta tiene la capacidad de realizar @e(deducciones
     lógicas) basadas en las reglas. Por ejemplo, considere la @c(append)
     operación descrita al principio de la seccion @l(#4.4). Como hemos dicho,
     @c(append) se puede caracterizar por las siguientes dos reglas:

#      - For any list @c(y), the empty list and @c(y) @c(append) to form @c(y).
     - Para cualquier lista @c(y), la lista vacía y @c(y) @c(append) para formar
       @c(y).

#      - For any @c(u), @c(v), @c(y), and @c(z), @c[(cons u v)] and @c(y) @c(append)
#        to form @c[(cons u z)] if @c(v) and @c(y) @c(append) to form @c(z).
     - Para cualquier @c(u), @c(v), @c(y), y @c(z), @c[(cons u v)] y @c(y)
       @c(append) para formar @c[(cons u z)] si @c(v) y @c(y) @c(append) para
       formar @c(z).

#      To express this in our query language, we define two rules for a relation
     Para expresar esto en nuestro lenguaje de consulta, definimos dos reglas
     para una relación

#      ..src > scheme
#        (append-to-form x y z)
#      < src..
     ..src > scheme
       (append-to-form x y z)
     < src..

#      which we can interpret to mean @"(@c(x) and @c(y) @c(append) to form @c(z)):
     Que podemos interpretar para significar @"(@c(x) y @c(y) @c(append)
     formar@c(z)) :

#      ..src > scheme
#        (rule (append-to-form () ?y ?y))
#        (rule (append-to-form (?u . ?v) ?y (?u . ?z))
#              (append-to-form ?v ?y ?z))
#      < src..
     ..src > scheme
       (rule (append-to-form () ?y ?y))
       (rule (append-to-form (?u . ?v) ?y (?u . ?z))
             (append-to-form ?v ?y ?z))
     < src..

#      The first rule has no body, which means that the conclusion holds for any
#      value of @c(?y). Note how the second rule makes use of dotted-tail notation to
#      name the @c(car) and @c(cdr) of a list.
     La primera regla no tiene cuerpo, lo que significa que la conclusión vale
     para cualquier valor de @c(?y). Observe cómo la segunda regla hace uso de
     la notación de punteado para nombrar el @c(car) y @c(cdr) de una lista.

#      Given these two rules, we can formulate queries that compute the @c(append) of
#      two lists:
     Dadas estas dos reglas, podemos formular consultas que calculan la
     @c(append) de dos listas:

#      ..srci > scheme
#        ;;; Query input:
#        > (append-to-form (a b) (c d) ?z)
#
#        ;;; Query results:
#        > (append-to-form (a b) (c d) (a b c d))
#      < srci..
     ..srci > scheme
       ;;; Query input:
       > (append-to-form (a b) (c d) ?z)

       ;;; Query results:
       > (append-to-form (a b) (c d) (a b c d))
     < srci..

#      What is more striking, we can use the same rules to ask the question @"(Which
#      list, when @c(append)ed to @c[(a b)], yields @c[(a b c d)]?)  This is done as
#      follows:
     Lo que es más llamativo, podemos usar las mismas reglas para hacer la
     pregunta @"(¿Qué lista, cuando se @c(append) ed @c[(a b)], produce @c[(a b
     c d)]? )  Esto se hace de la siguiente manera:

#      ..srci > scheme
#        ;;; Query input:
#        > (append-to-form (a b) ?y (a b c d))
#
#        ;;; Query results:
#        > (append-to-form (a b) (c d) (a b c d))
#      < srci..
     ..srci > scheme
       ;;; Query input:
       > (append-to-form (a b) ?y (a b c d))

       ;;; Query results:
       > (append-to-form (a b) (c d) (a b c d))
     < srci..

#      We can also ask for all pairs of lists that @c(append) to form @c[(a b c d)]:
     También podemos solicitar todos los pares de listas que @c(append) formen
     @c[(a b c d)]:

#      ..srci > scheme
#        ;;; Query input:
#        > (append-to-form ?x ?y (a b c d))
#
#        ;;; Query results:
#        > (append-to-form () (a b c d) (a b c d))
#        > (append-to-form (a) (b c d) (a b c d))
#        > (append-to-form (a b) (c d) (a b c d))
#        > (append-to-form (a b c) (d) (a b c d))
#        > (append-to-form (a b c d) () (a b c d))
#      < srci..
     ..srci > scheme
       ;;; Query input:
       > (append-to-form ?x ?y (a b c d))

       ;;; Query results:
       > (append-to-form () (a b c d) (a b c d))
       > (append-to-form (a) (b c d) (a b c d))
       > (append-to-form (a b) (c d) (a b c d))
       > (append-to-form (a b c) (d) (a b c d))
       > (append-to-form (a b c d) () (a b c d))
     < srci..

#      The query system may seem to exhibit quite a bit of intelligence in using the
#      rules to deduce the answers to the queries above. Actually, as we will see in
#      the next section, the system is following a well-determined algorithm in
#      unraveling the rules. Unfortunately, although the system works impressively in
#      the @c(append) case, the general methods may break down in more complex cases,
#      as we will see in section @l(#4.4.3).
     El sistema de consulta puede parecer tener bastante inteligencia en el uso
     de las reglas para deducir las respuestas a las consultas anteriores. En
     realidad, como veremos en la siguiente sección, el sistema está siguiendo
     un algoritmo bien determinado para desentrañar las
     reglas. Desafortunadamente, aunque el sistema funciona de manera
     impresionante en el @c(append) caso, los métodos generales pueden
     desglosarse en casos más complejos, como veremos en la seccion @l(#4.4.3).

#      :: @t(Exercise 4.61) :: The following rules implement a @c(next-to) relation
#         that finds adjacent elements of a list:
     :: @t(Ejercicio 4.61) :: Las siguientes reglas implementan una @c(next-to)
        relación que encuentra elementos adyacentes de una lista:

#         ..src > scheme
#           (rule (?x next-to ?y in (?x ?y . ?u)))
#           (rule (?x next-to ?y in (?v . ?z))
#                 (?x next-to ?y in ?z))
#         < src..
        ..src > scheme
          (rule (?x next-to ?y in (?x ?y . ?u)))
          (rule (?x next-to ?y in (?v . ?z))
                (?x next-to ?y in ?z))
        < src..

#         What will the response be to the following queries?
        ¿Cuál será la respuesta a las siguientes preguntas?

#         ..src > scheme
#           (?x next-to ?y in (1 (2 3) 4))
#           (?x next-to 1 in (2 1 3 1))
#         < src..
        ..src > scheme
          (?x next-to ?y in (1 (2 3) 4))
          (?x next-to 1 in (2 1 3 1))
        < src..

#      :: @t(Exercise 4.62) :: Define rules to implement the @c(last-pair) operation
#         of @l(#Exercise 2.17), which returns a list containing the last element of
#         a nonempty list. Check your rules on queries such as @c[(last-pair (3)
#         ?x)], @c[(last-pair (1 2 3) ?x)] and @c[(last-pair (2 ?x) (3))]. Do your
#         rules work correctly on queries such as @c[(last-pair ?x (3))]?
     :: @t(Ejercicio 4.62) :: Definir reglas para implementar la @c(last-pair)
        operación del @l(#Ejercicio 2.17), que devuelve una lista
        que contiene el último elemento de una lista no vacía. Revise sus reglas
        en consultas como @c[(last-pair (3) ?x)], @c[(last-pair (1 2 3) ?x)] y
        @c[(last-pair (2 ?x) (3))]. ¿Sus reglas funcionan correctamente en
        consultas como @c[(last-pair ?x (3))]?

#      :: @t(Exercise 4.63) :: The following data base (see Genesis 4) traces the
#         genealogy of the descendants of Ada back to Adam, by way of Cain:
     :: @t(Ejercicio 4.63) :: La siguiente base de datos (ver Génesis 4) traza
        la genealogía de los descendientes de Ada de nuevo a Adán, a través de
        Caín:

#         ..src > scheme
#           (son Adam Cain) (son Cain Enoch)
#           (son Enoch Irad) (son Irad Mehujael)
#           (son Mehujael Methushael)
#           (son Methushael Lamech)
#           (wife Lamech Ada) (son Ada Jabal)
#           (son Ada Jubal)
#         < src..
        ..src > scheme
          (son Adam Cain) (son Cain Enoch)
          (son Enoch Irad) (son Irad Mehujael)
          (son Mehujael Methushael)
          (son Methushael Lamech)
          (wife Lamech Ada) (son Ada Jabal)
          (son Ada Jubal)
        < src..

#         Formulate rules such as @"(If @m(S) is the son of @m(ƒ), and @m(ƒ) is the
#         son of @m(G), then @m(S) is the grandson of @m(G)) and @"(If @m(W) is the
#         wife of @m(M), and @m(S) is the son of @m(W), then @m(S) is the son of
#         @m(M)) (which was supposedly more true in biblical times than today) that
#         will enable the query system to find the grandson of Cain; the sons of
#         Lamech; the grandsons of Methushael. (See @l(#Exercise 4.69) for some rules
#         to deduce more complicated relationships.)
        Formular reglas tales como @"(Si @m(S) es el hijo de @m(ƒ), y @m(ƒ) es
        el hijo de @m(G), entonces @m(S) es el nieto de @m(G)) y @"(Si @m(W) es
        la esposa de @m(M), y @m(S) es el hijo de @m(W), entonces @m(S) es el
        hijo de @m(M)) (que supuestamente era más cierto en tiempos bíblicos que
        hoy) que permitirá al sistema de consulta encontrar al nieto de Caín;
        Los hijos de Lamec; Los nietos de Matusalén. (Ver el
        @l(#Ejercicio 4.69) para algunas reglas para deducir
        relaciones más complicadas.)

# *** 4.4.2 <> How the Query System Works
*** 4.4.2 <> Cómo funciona el sistema de consultas

#     In section @l(#4.4.4) we will present an implementation of the query
#     interpreter as a collection of procedures. In this section we give an overview
#     that explains the general structure of the system independent of low-level
#     implementation details. After describing the implementation of the
#     interpreter, we will be in a position to understand some of its limitations
#     and some of the subtle ways in which the query language's logical operations
#     differ from the operations of mathematical logic.
    En la sección @l(#4.4.4) presentamos una implementación del
    intérprete de consultas como una colección de procedimientos. En esta
    sección se ofrece una visión general que explica la estructura general del
    sistema independientemente de los detalles de implementación de bajo
    nivel. Después de describir la implementación del intérprete, estaremos en
    condiciones de entender algunas de sus limitaciones y algunas de las sutiles
    maneras en que las operaciones lógicas del lenguaje de consulta difieren de
    las operaciones de la lógica matemática.

#     It should be apparent that the query evaluator must perform some kind of
#     search in order to match queries against facts and rules in the data base. One
#     way to do this would be to implement the query system as a nondeterministic
#     program, using the @c(amb) evaluator of section @l(#4.3) (see @l(#Exercise 4.78)).
#     Another possibility is to manage the search with the aid of streams. Our
#     implementation follows this second approach.
    Debe ser evidente que el evaluador de consultas debe realizar algún tipo de
    búsqueda para poder hacer coincidir las consultas con los hechos y las
    reglas de la base de datos. Una manera de hacer esto sería implementar el
    sistema de consulta como un programa no determinista, usando el @c(amb)
    evaluador de la seccion @l(#4.3) (véase el @l(#Ejercicio 4.78)
    ). Otra posibilidad es administrar la búsqueda con la ayuda de
    corrientes. Nuestra implementación sigue este segundo enfoque.

#     The query system is organized around two central operations called @e(pattern
#     matching) and @e(unification). We first describe pattern matching and explain
#     how this operation, together with the organization of information in terms of
#     streams of frames, enables us to implement both simple and compound
#     queries. We next discuss unification, a generalization of pattern matching
#     needed to implement rules. Finally, we show how the entire query interpreter
#     fits together through a procedure that classifies expressions in a manner
#     analogous to the way @c(eval) classifies expressions for the interpreter
#     described in section @l(#4.1).
    El sistema de consulta está organizado en torno a dos operaciones centrales
    llamadas @e(coincidencia de patrones) y @e(unificación). Describimos primero
    la correspondencia de patrones y explicamos cómo esta operación, junto con
    la organización de la información en términos de flujos de marcos, nos
    permite implementar consultas simples y compuestos. A continuación
    discutiremos la unificación, una generalización de la correspondencia de
    patrones necesaria para implementar las reglas. Finalmente, mostramos cómo
    el intérprete de consultas completo se ajusta a través de un procedimiento
    que clasifica las expresiones de una manera análoga a la forma en que se
    @c(eval) clasifican las expresiones para el intérprete descrito en
    @l(#4.1).

# **** Pattern matching
**** La coincidencia de patrones

#      A @e(pattern matcher) is a program that tests whether some datum fits a
#      specified pattern. For example, the data list @c[((a b) c (a b))] matches the
#      pattern @c[(?x c ?x)] with the pattern variable @c(?x) bound to @c[(a b)]. The
#      same data list matches the pattern @c[(?x ?y ?z)] with @c(?x) and @c(?z) both
#      bound to @c[(a b)] and @c(?y) bound to @c(c). It also matches the pattern
#      @c[((?x ?y) c (?x ?y))] with @c(?x) bound to @c(a) and @c(?y) bound to
#      @c(b). However, it does not match the pattern @c[(?x a ?y)], since that
#      pattern specifies a list whose second element is the symbol @c(a).
     Un @e(matcher de patrones) es un programa que prueba si algún datum se
     ajusta a un patrón especificado. Por ejemplo, la lista de datos @c[((a b) c
     (a b))] coincide con el patrón @c[(?x c ?x)] con la variable de patrón
     @c(?x) vinculada a @c[(a b)]. La misma lista de datos coincide con el
     patrón @c[(?x ?y ?z)] con @c(?x) y @c(?z) ambos vinculados @c[(a b)] y
     @c(?y) vinculados a @c(c). También coincide con el patrón @c[((?x ?y) c (?x
     ?y))] con @c(?x) vinculado @c(a) y @c(?y) vinculado a @c(b). Sin embargo,
     no coincide con el patrón @c[(?x a ?y)], ya que ese patrón especifica una
     lista cuyo segundo elemento es el símbolo @c(a).

#      The pattern matcher used by the query system takes as inputs a pattern, a
#      datum, and a @e(frame) that specifies bindings for various pattern
#      variables. It checks whether the datum matches the pattern in a way that is
#      consistent with the bindings already in the frame. If so, it returns the given
#      frame augmented by any bindings that may have been determined by the match.
#      Otherwise, it indicates that the match has failed.
     El matcher de patrones utilizado por el sistema de consulta toma como
     entradas un patrón, un datum y un @e(marco) que especifica enlaces para
     varias variables de patrón. Comprueba si el datum coincide con el patrón de
     una manera que es consistente con los enlaces ya en el marco. Si es así,
     devuelve el marco dado aumentado por cualquier enlace que pueda haber sido
     determinado por la coincidencia. De lo contrario, indica que la
     coincidencia ha fallado.

#      For example, using the pattern @c[(?x ?y ?x)] to match @c[(a b a)] given an
#      empty frame will return a frame specifying that @c(?x) is bound to @c(a) and
#      @c(?y) is bound to @c(b). Trying the match with the same pattern, the same
#      datum, and a frame specifying that @c(?y) is bound to @c(a) will fail. Trying
#      the match with the same pattern, the same datum, and a frame in which @c(?y)
#      is bound to @c(b) and @c(?x) is unbound will return the given frame augmented
#      by a binding of @c(?x) to @c(a).
     Por ejemplo, usar el patrón @c[(?x ?y ?x)] para que coincida @c[(a b a)]
     con un marco vacío devolverá un marco especificando que @c(?x) está
     enlazado @c(a) y @c(?y) está enlazado @c(b). Intentar el partido con el
     mismo patrón, el mismo dato, y un marco especificando que @c(?y) está
     obligado a @c(a) fallará. Al intentar el partido con el mismo patrón, el
     mismo dato, y un marco en el que @c(?y) está enlazado @c(b) y @c(?x) no
     está unido, devolverá el fotograma dado aumentado por un enlace de @c(?x) a
     @c(a).

#      The pattern matcher is all the mechanism that is needed to process simple
#      queries that don't involve rules. For instance, to process the query
     El matcher de patrones es todo el mecanismo que se necesita para procesar
     consultas simples que no implican reglas. Por ejemplo, para procesar la
     consulta

#      ..src > scheme
#        (job ?x (computer programmer))
#      < src..
     ..src > scheme
       (job ?x (computer programmer))
     < src..

#      we scan through all assertions in the data base and select those that match
#      the pattern with respect to an initially empty frame. For each match we find,
#      we use the frame returned by the match to instantiate the pattern with a value
#      for @c(?x).
     Exploramos todas las aserciones de la base de datos y seleccionamos
     aquellas que coinciden con el patrón con respecto a un marco inicialmente
     vacío. Para cada coincidencia encontramos, usamos el frame devuelto por la
     coincidencia para instanciar el patrón con un valor para @c(?x).

# **** Streams of frames
**** Corrientes de marcos

#      The testing of patterns against frames is organized through the use of
#      streams.  Given a single frame, the matching process runs through the
#      data-base entries one by one. For each data-base entry, the matcher generates
#      either a special symbol indicating that the match has failed or an extension
#      to the frame. The results for all the data-base entries are collected into a
#      stream, which is passed through a filter to weed out the failures. The result
#      is a stream of all the frames that extend the given frame via a match to some
#      assertion in the data base.@n(271)
     La prueba de patrones contra marcos se organiza a través del uso de
     corrientes. Dado un solo marco, el proceso de coincidencia pasa por las
     entradas de la base de datos uno por uno. Para cada entrada de base de
     datos, el generador genera un símbolo especial que indica que la
     coincidencia ha fallado o una extensión al marco. Los resultados de todas
     las entradas de la base de datos se recogen en un flujo, que se pasa a
     través de un filtro para eliminar las fallas. El resultado es un flujo de
     todos los cuadros que amplían la trama dada mediante una coincidencia con
     alguna aserción en la base de datos.@n(271)

#      In our system, a query takes an input stream of frames and performs the above
#      matching operation for every frame in the stream, as indicated in @l(#Figure
#      4.4).  That is, for each frame in the input stream, the query generates a new
#      stream consisting of all extensions to that frame by matches to assertions in
#      the data base. All these streams are then combined to form one huge stream,
#      which contains all possible extensions of every frame in the input stream.
#      This stream is the output of the query.
     En nuestro sistema, una consulta toma un flujo de entrada de tramas y
     realiza la operación de coincidencia anterior para cada trama en el flujo,
     como se indica en la @l(#Figura 4.4). Es decir, para cada trama
     en el flujo de entrada, la consulta genera un nuevo flujo consistente en
     todas las extensiones de ese cuadro por coincidencias con aserciones en la
     base de datos. Todos estos flujos se combinan para formar un flujo enorme,
     que contiene todas las extensiones posibles de cada trama en el flujo de
     entrada. Esta secuencia es la salida de la consulta.

#      ..figure > @t(Figure 4.4) A query processes a stream of frames.
     ..figure > @t(Figura 4.4) Una consulta procesa un flujo de tramas.

#        ..art >
#                                            output stream
#            input stream   ╭─────────────╮  of frames,
#            of frames      │    query    │  filtered and extended
#          ────────────────▶│             ├─────────────────────────▶
#                           │ (job ?x ?y) │
#                           ╰─────────────╯
#                                  ▲
#                                  │
#                         stream of assertions
#                            from data base
#        < art..
       ..art >
                                           output stream
           input stream   ╭─────────────╮  of frames,
           of frames      │    query    │  filtered and extended
         ────────────────▶│             ├─────────────────────────▶
                          │ (job ?x ?y) │
                          ╰─────────────╯
                                 ▲
                                 │
                        stream of assertions
                           from data base
       < art..

# @    ..img > img/chap4/Fig4.4a.std.svg
@    ..img > img/chap4/Fig4.4a.std.svg

#      To answer a simple query, we use the query with an input stream consisting of
#      a single empty frame. The resulting output stream contains all extensions to
#      the empty frame (that is, all answers to our query). This stream of frames is
#      then used to generate a stream of copies of the original query pattern with
#      the variables instantiated by the values in each frame, and this is the stream
#      that is finally printed.
     Para responder a una consulta simple, usamos la consulta con un flujo de
     entrada que consta de un único marco vacío. El flujo de salida resultante
     contiene todas las extensiones del marco vacío (es decir, todas las
     respuestas a nuestra consulta). Este flujo de tramas se utiliza entonces
     para generar una secuencia de copias del patrón de consulta original con
     las variables instanciadas por los valores en cada trama, y ésta es la
     secuencia que finalmente se imprime.

# **** Compound queries
**** Consultas compuestas

#      The real elegance of the stream-of-frames implementation is evident when we
#      deal with compound queries. The processing of compound queries makes use of
#      the ability of our matcher to demand that a match be consistent with a
#      specified frame. For example, to handle the @c(and) of two queries, such as
     La elegancia real de la implementación de flujo de marcos es evidente
     cuando tratamos con consultas compuestas. El procesamiento de consultas
     compuestas hace uso de la capacidad de nuestro encuestador para exigir que
     una coincidencia sea consistente con un marco especificado. Por ejemplo,
     para manejar la @c(and) de dos consultas, como

#      ..src > scheme
#        (and (can-do-job
#              ?x
#              (computer programmer trainee))
#             (job ?person ?x))
#      < src..
     ..src > scheme
       (and (can-do-job
             ?x
             (computer programmer trainee))
            (job ?person ?x))
     < src..

#      (informally, @"(Find all people who can do the job of a computer programmer
#      trainee)), we first find all entries that match the pattern
     (Informalmente, @"(Encuentre todas las personas que puedan hacer el trabajo
     de un programador de prácticas) ), primero encontraremos todas las entradas
     que coincidan con el patrón

#      ..src > scheme
#        (can-do-job ?x (computer programmer trainee))
#      < src..
     ..src > scheme
       (can-do-job ?x (computer programmer trainee))
     < src..

#      This produces a stream of frames, each of which contains a binding for
#      @c(?x). Then for each frame in the stream we find all entries that match
     Esto produce una corriente de marcos, cada uno de los cuales contiene una
     unión para @c(?x). Luego, para cada trama de la secuencia encontramos todas
     las entradas que coincidan

#      ..src > scheme
#        (job ?person ?x)
#      < src..
     ..src > scheme
       (job ?person ?x)
     < src..

#      in a way that is consistent with the given binding for @c(?x). Each such match
#      will produce a frame containing bindings for @c(?x) and @c(?person). The
#      @c(and) of two queries can be viewed as a series combination of the two
#      component queries, as shown in @l(#Figure 4.5). The frames that pass through
#      the first query filter are filtered and further extended by the second query.
     De una manera que sea consistente con la unión dada para @c(?x). Cada
     coincidencia producirá un marco que contiene enlaces para @c(?x) y
     @c(?person). La @c(and) de dos consultas se puede ver como una combinación
     en serie de las dos consultas de componentes, como se muestra en la
     @l(#Figura 4.5). Los fotogramas que pasan a través del primer
     filtro de consulta son filtrados y ampliados por la segunda consulta.

#      ..figure > @t(Figure 4.5) The @c(and) combination of two queries is produced
#        by operating on the stream of frames in series.
     ..figure > @t(Figura 4.5) La @c(and) combinación de dos consultas se
       produce al operar en el flujo de tramas en serie.

#        ..art >
#                          ╭──────────────────────╮
#                          │       (and A B)      │
#            input stream  │                      │  output stream
#            of frames     │   ╭───╮       ╭───╮  │  of frames
#          ────────────────┼──▶│ A ├──────▶│ B ├──┼─────────────────▶
#                          │   ╰───╯       ╰───╯  │
#                          │     ▲           ▲    │
#                          │     │           │    │
#                          │     ╰─────●─────╯    │
#                          ╰───────────┼──────────╯
#                                      │
#                                  data base
#        < art..
       ..art >
                         ╭──────────────────────╮
                         │       (and A B)      │
           input stream  │                      │  output stream
           of frames     │   ╭───╮       ╭───╮  │  of frames
         ────────────────┼──▶│ A ├──────▶│ B ├──┼─────────────────▶
                         │   ╰───╯       ╰───╯  │
                         │     ▲           ▲    │
                         │     │           │    │
                         │     ╰─────●─────╯    │
                         ╰───────────┼──────────╯
                                     │
                                 data base
       < art..

# @    ..img > img/chap4/Fig4.5a.std.svg
@    ..img > img/chap4/Fig4.5a.std.svg

#      @l(#Figure 4.6) shows the analogous method for computing the @c(or) of two
#      queries as a parallel combination of the two component queries. The input
#      stream of frames is extended separately by each query. The two resulting
#      streams are then merged to produce the final output stream.
     @l(#Figura 4.6) muestra el método análogo para calcular la
     @c(or) de dos consultas como una combinación paralela de las dos consultas
     de componentes. El flujo de entrada de tramas se extiende por separado por
     cada consulta. Las dos corrientes resultantes se fusionan para producir el
     flujo de salida final.

#      ..figure > @t(Figure 4.6) The @c(or) combination of two queries is produced by
#        operating on the stream of frames in parallel and merging the results.
     ..figure > @t(Figura 4.6) La @c(or) combinación de dos consultas se produce
       operando en el flujo de tramas en paralelo y fusionando los resultados.

#        ..art >
#                     ╭───────────────────────────╮
#                     │          (or A B)         │
#                     │    ╭───╮                  │
#          input      │ ╭─▶│ A │────────────╮     │  output
#          stream of  │ │  ╰───╯            ▼     │  stream of
#          frames     │ │    ▲          ╭───────╮ │  frames
#          ───────────┼─●    │          │ merge ├─┼─────────────▶
#                     │ │    │          ╰───────╯ │
#                     │ │    │              ▲     │
#                     │ │    │   ╭───╮      │     │
#                     │ ╰────┼──▶│ B ├──────╯     │
#                     │      │   ╰───╯            │
#                     │      │     ▲              │
#                     │      │     │              │
#                     │      ╰──●──╯              │
#                     ╰─────────┼─────────────────╯
#                               │
#                           data base
#        < art..
       ..art >
                    ╭───────────────────────────╮
                    │          (or A B)         │
                    │    ╭───╮                  │
         input      │ ╭─▶│ A │────────────╮     │  output
         stream of  │ │  ╰───╯            ▼     │  stream of
         frames     │ │    ▲          ╭───────╮ │  frames
         ───────────┼─●    │          │ merge ├─┼─────────────▶
                    │ │    │          ╰───────╯ │
                    │ │    │              ▲     │
                    │ │    │   ╭───╮      │     │
                    │ ╰────┼──▶│ B ├──────╯     │
                    │      │   ╰───╯            │
                    │      │     ▲              │
                    │      │     │              │
                    │      ╰──●──╯              │
                    ╰─────────┼─────────────────╯
                              │
                          data base
       < art..

# @    ..img > img/chap4/Fig4.6a.std.svg
@    ..img > img/chap4/Fig4.6a.std.svg

#      Even from this high-level description, it is apparent that the processing of
#      compound queries can be slow. For example, since a query may produce more than
#      one output frame for each input frame, and each query in an @c(and) gets its
#      input frames from the previous query, an @c(and) query could, in the worst
#      case, have to perform a number of matches that is exponential in the number of
#      queries (see @l(#Exercise 4.76)).@n(272) Though systems for handling only
#      simple queries are quite practical, dealing with complex queries is extremely
#      difficult.@n(273)
     Incluso a partir de esta descripción de alto nivel, es evidente que el
     procesamiento de consultas de compuestos puede ser lento. Por ejemplo, dado
     que una consulta puede producir más de una trama de salida para cada trama
     de entrada, y cada consulta en una @c(and) obtiene sus tramas de entrada de
     la consulta anterior, una @c(and) consulta podría, en el peor de los casos,
     tener que realizar una serie de coincidencias Exponencial en el número de
     consultas (véase el @l(#Ejercicio 4.76) ).@n(272)
     Aunque los sistemas para manejar sólo consultas simples son bastante
     prácticos, tratar con consultas complejas es extremadamente
     difícil.@n(273)

#      From the stream-of-frames viewpoint, the @c(not) of some query acts as a
#      filter that removes all frames for which the query can be satisfied. For
#      instance, given the pattern
     Desde el punto de vista de flujo de tramas, el @c(not) de alguna consulta
     actúa como un filtro que elimina todos los marcos para los que se puede
     satisfacer la consulta. Por ejemplo, dado el patrón

#      ..src > scheme
#        (not (job ?x (computer programmer)))
#      < src..
     ..src > scheme
       (not (job ?x (computer programmer)))
     < src..

#      we attempt, for each frame in the input stream, to produce extension frames
#      that satisfy @c[(job ?x (computer programmer))]. We remove from the input
#      stream all frames for which such extensions exist. The result is a stream
#      consisting of only those frames in which the binding for @c(?x) does not
#      satisfy @c[(job ?x (computer programmer))]. For example, in processing the
#      query
     Intentamos, para cada trama en el flujo de entrada, producir tramas de
     extensión que satisfagan @c[(job ?x (computer programmer))]. Eliminamos del
     flujo de entrada todos los fotogramas para los que existen dichas
     extensiones. El resultado es un flujo consistente en sólo aquellas tramas
     en las que la encuadernación @c(?x) no satisface @c[(job ?x (computer
     programmer))]. Por ejemplo, al procesar la consulta

#      ..src > scheme
#        (and (supervisor ?x ?y)
#             (not (job ?x (computer programmer))))
#      < src..
     ..src > scheme
       (and (supervisor ?x ?y)
            (not (job ?x (computer programmer))))
     < src..

#      the first clause will generate frames with bindings for @c(?x) and @c(?y). The
#      @c(not) clause will then filter these by removing all frames in which the
#      binding for @c(?x) satisfies the restriction that @c(?x) is a computer
#      programmer.@n(274)
     La primera cláusula generará marcos con enlaces para @c(?x) y @c(?y). La
     @c(not) cláusula a continuación, filtrar estos mediante la eliminación de
     todos los marcos en los que el enlace para @c(?x) satisfacer la restricción
     que @c(?x) es un programador de computadoras.@n(274)

#      The @c(lisp-value) special form is implemented as a similar filter on frame
#      streams. We use each frame in the stream to instantiate any variables in the
#      pattern, then apply the Lisp predicate. We remove from the input stream all
#      frames for which the predicate fails.
     El @c(lisp-value) formulario especial se implementa como un filtro similar
     en los flujos de tramas. Utilizamos cada trama en la secuencia para
     instanciar cualquier variable en el patrón, a continuación, aplicar el
     predicado Lisp. Eliminamos del flujo de entrada todos los fotogramas para
     los que falla el predicado.

# **** Unification
**** Unificación

#      In order to handle rules in the query language, we must be able to find the
#      rules whose conclusions match a given query pattern. Rule conclusions are like
#      assertions except that they can contain variables, so we will need a
#      generalization of pattern matching––called @e(unification)––in which both the
#      @"(pattern) and the @"(datum) may contain variables.
     Con el fin de manejar las reglas en el lenguaje de consulta, debemos ser
     capaces de encontrar las reglas cuyas conclusiones coinciden con un patrón
     de consulta dado. Las conclusiones de la regla son como afirmaciones,
     excepto que pueden contener variables, por lo que necesitaremos una
     generalización de concordancia de patrones - llamada @e(unificación) - en
     la cual tanto el @"(patrón) como el @"(dato) pueden contener variables.

#      A unifier takes two patterns, each containing constants and variables, and
#      determines whether it is possible to assign values to the variables that will
#      make the two patterns equal. If so, it returns a frame containing these
#      bindings. For example, unifying @c[(?x a ?y)] and @c[(?y ?z a)] will specify a
#      frame in which @c(?x), @c(?y), and @c(?z) must all be bound to @c(a). On the
#      other hand, unifying @c[(?x ?y a)] and @c[(?x b ?y)] will fail, because there
#      is no value for @c(?y) that can make the two patterns equal. (For the second
#      elements of the patterns to be equal, @c(?y) would have to be @c(b); however,
#      for the third elements to be equal, @c(?y) would have to be @c(a).)  The
#      unifier used in the query system, like the pattern matcher, takes a frame as
#      input and performs unifications that are consistent with this frame.
     Un unificador toma dos patrones, cada uno contiene constantes y variables,
     y determina si es posible asignar valores a las variables que harán que los
     dos patrones sean iguales. Si es así, devuelve un marco que contiene estos
     enlaces. Por ejemplo, la unificación @c[(?x a ?y)] y @c[(?y ?z a)]
     especificará un marco en el cual @c(?x), @c(?y) y @c(?z) todos deben estar
     unidos a @c(a). Por otro lado, unificando @c[(?x ?y a)] y @c[(?x b ?y)]
     fallando, porque no hay valor para @c(?y) eso puede hacer que los dos
     patrones sean iguales. (Para que los segundos elementos de los patrones
     sean iguales, @c(?y) tendría que ser @c(b), sin embargo, para que los
     terceros elementos sean iguales, @c(?y) tendría que ser @c(a).) El
     unificador usado en el sistema de consulta, como el matcher de patrones,

#      The unification algorithm is the most technically difficult part of the query
#      system. With complex patterns, performing unification may seem to require
#      deduction. To unify @c[(?x ?x)] and @c[((a ?y c) (a b ?z))], for example, the
#      algorithm must infer that @c(?x) should be @c[(a b c)], @c(?y) should be
#      @c(b), and @c(?z) should be @c(c). We may think of this process as solving a
#      set of equations among the pattern components. In general, these are
#      simultaneous equations, which may require substantial manipulation to
#      solve.@n(275) For example, unifying @c[(?x ?x)] and @c[((a ?y c) (a b ?z))]
#      may be thought of as specifying the simultaneous equations
     El algoritmo de unificación es la parte técnicamente más difícil del
     sistema de consulta. Con patrones complejos, la realización de la
     unificación puede requerir deducción. Para unificar @c[(?x ?x)] y @c[((a ?y
     c) (a b ?z))], por ejemplo, el algoritmo debe inferir que @c(?x) debe ser
     @c[(a b c)], @c(?y) debe ser @c(b), y @c(?z) debe ser @c(c). Podemos pensar
     en este proceso como la solución de un conjunto de ecuaciones entre los
     componentes del patrón. En general, se trata de ecuaciones simultáneas, que
     pueden requerir manipulación sustancial para resolver.@n(275) Por
     ejemplo, unificando @c[(?x ?x)] y @c[((a ?y c) (a b ?z))] pudiendo
     considerarse como especificando las ecuaciones simultáneas

#      ..src > scheme
#        ?x = (a ?y c)
#        ?x = (a b ?z)
#      < src..
     ..src > scheme
       ?x = (a ?y c)
       ?x = (a b ?z)
     < src..

#      These equations imply that
     Estas ecuaciones implican que

#      ..src > scheme
#        (a ?y c) = (a b ?z)
#      < src..
     ..src > scheme
       (a ?y c) = (a b ?z)
     < src..

#      which in turn implies that
     Que a su vez implica que

#      ..src > scheme
#        a = a, ?y = b, c = ?z,
#      < src..
     ..src > scheme
       a = a, ?y = b, c = ?z,
     < src..

#      and hence that
     Y por lo tanto eso

#      ..src > scheme
#        ?x = (a b c)
#      < src..
     ..src > scheme
       ?x = (a b c)
     < src..

#      In a successful pattern match, all pattern variables become bound, and the
#      values to which they are bound contain only constants. This is also true of
#      all the examples of unification we have seen so far. In general, however, a
#      successful unification may not completely determine the variable values; some
#      variables may remain unbound and others may be bound to values that contain
#      variables.
     En una coincidencia de patrón satisfactoria, todas las variables de patrón
     se unen y los valores a los que están enlazados contienen sólo
     constantes. Esto también es cierto para todos los ejemplos de unificación
     que hemos visto hasta ahora. En general, sin embargo, una unificación
     exitosa puede no determinar completamente los valores de las variables;
     Algunas variables pueden permanecer desvinculadas y otras pueden estar
     vinculadas a valores que contienen variables.

#      Consider the unification of @c[(?x a)] and @c[((b ?y) ?z)]. We can deduce that
#      @c(?x = (b ?y)) and @c(a = ?z), but we cannot further solve for @c(?x) or
#      @c(?y). The unification doesn't fail, since it is certainly possible to make
#      the two patterns equal by assigning values to @c(?x) and @c(?y). Since this
#      match in no way restricts the values @c(?y) can take on, no binding for @c(?y)
#      is put into the result frame.  The match does, however, restrict the value of
#      @c(?x). Whatever value @c(?y) has, @c(?x) must be @c[(b ?y)]. A binding of
#      @c(?x) to the pattern @c[(b ?y)] is thus put into the frame. If a value for
#      @c(?y) is later determined and added to the frame (by a pattern match or
#      unification that is required to be consistent with this frame), the previously
#      bound @c(?x) will refer to this value.@n(276)
     Considere la unificación de @c[(?x a)] y @c[((b ?y) ?z)]. Podemos deducir
     eso @c(?x = (b ?y)) y @c(a = ?z), pero no podemos resolver más para @c(?x)
     o @c(?y). La unificación no falla, ya que ciertamente es posible hacer los
     dos patrones iguales asignando valores a @c(?x) y @c(?y). Puesto que este
     partido no restringe en modo alguno los valores que @c(?y) puede asumir, no
     se enlaza para @c(?y) se pone en el marco de resultado. El partido, sin
     embargo, restringir el valor de @c(?x). Cualquier valor @c(?y) tiene,
     @c(?x) debe ser @c[(b ?y)]. Una unión del @c(?x) patrón @c[(b ?y)] se pone
     así en el marco. Si @c(?y) posteriormente se determina un valor para y se
     agrega a la trama (mediante una coincidencia o unificación de patrones que
     se requiere para ser consistente con esta trama) @c(?x) El límite anterior
     se referirá a este valor.@n(276)

# **** Applying rules
**** Aplicación de reglas

#      Unification is the key to the component of the query system that makes
#      inferences from rules. To see how this is accomplished, consider processing a
#      query that involves applying a rule, such as
     La unificación es la clave del componente del sistema de consulta que hace
     inferencias de las reglas. Para ver cómo se lleva a cabo esto, considere
     procesar una consulta que implique la aplicación de una regla, como

#      ..src > scheme
#        (lives-near ?x (Hacker Alyssa P))
#      < src..
     ..src > scheme
       (lives-near ?x (Hacker Alyssa P))
     < src..

#      To process this query, we first use the ordinary pattern-match procedure
#      described above to see if there are any assertions in the data base that match
#      this pattern. (There will not be any in this case, since our data base
#      includes no direct assertions about who lives near whom.)  The next step is to
#      attempt to unify the query pattern with the conclusion of each rule. We find
#      that the pattern unifies with the conclusion of the rule
     Para procesar esta consulta, usamos primero el procedimiento de
     coincidencia de patrones ordinario descrito anteriormente para ver si hay
     alguna aserción en la base de datos que coincida con este patrón. (No habrá
     ninguna en este caso, ya que nuestra base de datos no incluye afirmaciones
     directas sobre quién vive cerca de quién). El siguiente paso es intentar
     unificar el patrón de consulta con la conclusión de cada regla. Encontramos
     que el patrón unifica con la conclusión de la regla

#      ..src > scheme
#        (rule (lives-near ?person-1 ?person-2)
#              (and (address ?person-1
#                            (?town . ?rest-1))
#                   (address ?person-2
#                            (?town . ?rest-2))
#                   (not (same ?person-1 ?person-2))))
#      < src..
     ..src > scheme
       (rule (lives-near ?person-1 ?person-2)
             (and (address ?person-1
                           (?town . ?rest-1))
                  (address ?person-2
                           (?town . ?rest-2))
                  (not (same ?person-1 ?person-2))))
     < src..

#      resulting in a frame specifying that @c(?person-2) is bound to @c[(Hacker
#      Alyssa P)] and that @c(?x) should be bound to (have the same value as)
#      @c(?person-1). Now, relative to this frame, we evaluate the compound query
#      given by the body of the rule. Successful matches will extend this frame by
#      providing a binding for @c(?person-1), and consequently a value for @c(?x),
#      which we can use to instantiate the original query pattern.
     Resultando en un marco que especifica que @c(?person-2) está enlazado
     @c[(Hacker Alyssa P)] y que @c(?x) debe estar vinculado a (tienen el mismo
     valor que) @c(?person-1). Ahora, en relación con este marco, evaluamos la
     consulta compuesta dada por el cuerpo de la regla. Las coincidencias
     exitosas ampliarán este marco proporcionando un enlace para @c(?person-1),
     y consecuentemente un valor para @c(?x), el cual podemos usar para
     instanciar el patrón de consulta original.

#      In general, the query evaluator uses the following method to apply a rule when
#      trying to establish a query pattern in a frame that specifies bindings for
#      some of the pattern variables:
     En general, el evaluador de consultas utiliza el siguiente método para
     aplicar una regla cuando se intenta establecer un patrón de consulta en un
     marco que especifica enlaces para algunas de las variables de patrón:

#      - Unify the query with the conclusion of the rule to form, if successful, an
#        extension of the original frame.
     - Unificar la consulta con la conclusión de la regla para formar, si tiene
       éxito, una extensión del marco original.

#      - Relative to the extended frame, evaluate the query formed by the body of the
#        rule.
     - En relación con el marco extendido, evalúe la consulta formada por el
       cuerpo de la regla.


#      Notice how similar this is to the method for applying a procedure in the
#      @c(eval)/@c(apply) evaluator for Lisp:
     Observe cómo es similar esto es el método para aplicar un procedimiento en
     el @c(eval)/ @c(apply) evaluador para Lisp:

#      - Bind the procedure's parameters to its arguments to form a frame that
#        extends the original procedure environment.
     - Vincule los parámetros del procedimiento a sus argumentos para formar un
       marco que amplíe el entorno del procedimiento original.

#      - Relative to the extended environment, evaluate the expression formed by the
#        body of the procedure.
     - En relación con el entorno extendido, evaluar la expresión formada por el
       cuerpo del procedimiento.


#      The similarity between the two evaluators should come as no surprise. Just as
#      procedure definitions are the means of abstraction in Lisp, rule definitions
#      are the means of abstraction in the query language. In each case, we unwind
#      the abstraction by creating appropriate bindings and evaluating the rule or
#      procedure body relative to these.
     La similitud entre los dos evaluadores no debería sorprendernos. Así como
     las definiciones de procedimiento son los medios de abstracción en Lisp,
     las definiciones de reglas son los medios de abstracción en el lenguaje de
     consulta. En cada caso, desenrollamos la abstracción creando enlaces
     apropiados y evaluando la regla o el cuerpo del procedimiento relativo a
     éstos.

# **** Simple queries
**** Consultas sencillas

#      We saw earlier in this section how to evaluate simple queries in the absence
#      of rules. Now that we have seen how to apply rules, we can describe how to
#      evaluate simple queries by using both rules and assertions.
     Vimos anteriormente en esta sección cómo evaluar las consultas simples en
     ausencia de reglas. Ahora que hemos visto cómo aplicar las reglas, podemos
     describir cómo evaluar las consultas simples mediante el uso de reglas y
     aserciones.

#      Given the query pattern and a stream of frames, we produce, for each frame in
#      the input stream, two streams:
     Dado el patrón de consulta y un flujo de tramas, producimos, para cada
     trama en el flujo de entrada, dos flujos:

#      - a stream of extended frames obtained by matching the pattern against all
#        assertions in the data base (using the pattern matcher), and
     - Un flujo de tramas extendidas obtenido haciendo coincidir el patrón con
       todas las aserciones en la base de datos (usando el matcher de patrones),
       y

#      - a stream of extended frames obtained by applying all possible rules (using
#        the unifier).@n(277)
     - Una corriente de tramas extendidas obtenidas aplicando todas las reglas
       posibles (usando el unificador).@n(277)

#      Appending these two streams produces a stream that consists of all the ways
#      that the given pattern can be satisfied consistent with the original frame.
#      These streams (one for each frame in the input stream) are now all combined to
#      form one large stream, which therefore consists of all the ways that any of
#      the frames in the original input stream can be extended to produce a match
#      with the given pattern.
     La adición de estos dos flujos produce un flujo que consiste en todas las
     formas en que el patrón dado se puede satisfacer consistente con el marco
     original. Estas corrientes (una para cada trama en la corriente de entrada)
     ahora están todas combinadas para formar una corriente grande, que por lo
     tanto consiste en todas las formas en que cualquiera de los fotogramas en
     la corriente de entrada original puede extenderse para producir una
     coincidencia con el patrón dado.

# **** The query evaluator and the driver loop
**** El evaluador de consultas y el bucle del controlador

#      Despite the complexity of the underlying matching operations, the system is
#      organized much like an evaluator for any language. The procedure that
#      coordinates the matching operations is called @c(qeval), and it plays a role
#      analogous to that of the @c(eval) procedure for Lisp. @c(Qeval) takes as
#      inputs a query and a stream of frames. Its output is a stream of frames,
#      corresponding to successful matches to the query pattern, that extend some
#      frame in the input stream, as indicated in @l(#Figure 4.4). Like @c(eval),
#      @c(qeval) classifies the different types of expressions (queries) and
#      dispatches to an appropriate procedure for each. There is a procedure for each
#      special form (@c(and), @c(or), @c(not), and @c(lisp-value)) and one for simple
#      queries.
     A pesar de la complejidad de las operaciones de matching subyacentes, el
     sistema se organiza como un evaluador para cualquier idioma. El
     procedimiento que coordina las operaciones de coincidencia se llama
     @c(qeval) y desempeña un papel análogo al del procedimiento @c(eval) para
     Lisp. @c(Qeval) Toma como entradas una consulta y una secuencia de
     tramas. Su salida es un flujo de tramas, que corresponden a coincidencias
     satisfactorias con el patrón de consulta, que amplían algún trama en el
     flujo de entrada, como se indica en la @l(#Figura 4.4). Al
     igual que @c(eval), @c(qeval) clasifica los diferentes tipos de expresiones
     (consultas) y envíos a un procedimiento adecuado para cada uno. Existe un
     procedimiento para cada forma especial (@c(and), @c(or), @c(not), y
     @c(lisp-value)) y una para consultas sencillas.

#      The driver loop, which is analogous to the @c(driver-loop) procedure for the
#      other evaluators in this chapter, reads queries from the terminal. For each
#      query, it calls @c(qeval) with the query and a stream that consists of a
#      single empty frame. This will produce the stream of all possible matches (all
#      possible extensions to the empty frame). For each frame in the resulting
#      stream, it instantiates the original query using the values of the variables
#      found in the frame. This stream of instantiated queries is then
#      printed.@n(278)
     El bucle del controlador, que es análogo al procedimiento @c(driver-loop)
     para los otros evaluadores de este capítulo, lee las consultas del
     terminal. Para cada consulta, llama @c(qeval) con la consulta y una
     secuencia que consta de un único marco vacío. Esto producirá el flujo de
     todas las coincidencias posibles (todas las extensiones posibles al marco
     vacío). Para cada trama en el flujo resultante, instancia la consulta
     original utilizando los valores de las variables encontradas en el
     marco. Esta secuencia de consultas instanciadas se imprime a
     continuación.@n(278)

#      The driver also checks for the special command @c(assert!), which signals that
#      the input is not a query but rather an assertion or rule to be added to the
#      data base. For instance,
     El controlador también comprueba el comando especial @c(assert!), que
     indica que la entrada no es una consulta, sino más bien una afirmación o
     una regla que se agregará a la base de datos. Por ejemplo,

#      ..src > scheme
#        (assert!
#         (job (Bitdiddle Ben)
#              (computer wizard)))
#
#        (assert!
#         (rule (wheel ?person)
#               (and (supervisor
#                     ?middle-manager ?person)
#                    (supervisor
#                     ?x ?middle-manager))))
#      < src..
     ..src > scheme
       (assert!
        (job (Bitdiddle Ben)
             (computer wizard)))

       (assert!
        (rule (wheel ?person)
              (and (supervisor
                    ?middle-manager ?person)
                   (supervisor
                    ?x ?middle-manager))))
     < src..

# *** 4.4.3 <> Is Logic Programming Mathematical Logic?
*** 4.4.3 <> Qué es la lógica de programación lógica matemática?

#     The means of combination used in the query language may at first seem
#     identical to the operations @c(and), @c(or), and @c(not) of mathematical
#     logic, and the application of query-language rules is in fact accomplished
#     through a legitimate method of inference.@n(279) This identification of the
#     query language with mathematical logic is not really valid, though, because
#     the query language provides a @e(control structure) that interprets the
#     logical statements procedurally. We can often take advantage of this control
#     structure. For example, to find all of the supervisors of programmers we could
#     formulate a query in either of two logically equivalent forms:
    Los medios de combinación utilizados en el lenguaje de consulta pueden
    parecer al principio idénticos a las operaciones @c(and), @c(or) y @c(not)
    de la lógica matemática, y la aplicación de reglas de lenguaje de consulta
    se logra de hecho mediante un método legítimo de inferencia.@n(279)
    Esta identificación del lenguaje de consulta con la lógica matemática no es
    realmente válida, sin embargo, porque el lenguaje de consulta proporciona
    una @e(estructura de control) que interpreta los estados lógicos de
    procedimiento. A menudo podemos aprovechar esta estructura de control. Por
    ejemplo, para encontrar a todos los supervisores de programadores podríamos
    formular una consulta en cualquiera de dos formas lógicamente equivalentes:

#     ..src > scheme
#       (and (job ?x (computer programmer))
#            (supervisor ?x ?y))
#     < src..
    ..src > scheme
      (and (job ?x (computer programmer))
           (supervisor ?x ?y))
    < src..

#     or
    o

#     ..src > scheme
#       (and (supervisor ?x ?y)
#            (job ?x (computer programmer)))
#     < src..
    ..src > scheme
      (and (supervisor ?x ?y)
           (job ?x (computer programmer)))
    < src..

#     If a company has many more supervisors than programmers (the usual case), it
#     is better to use the first form rather than the second because the data base
#     must be scanned for each intermediate result (frame) produced by the first
#     clause of the @c(and).
    Si una empresa tiene muchos más supervisores que los programadores (el caso
    habitual), es mejor usar la primera forma que la segunda porque la base de
    datos debe ser escaneada para cada resultado intermedio (marco) producido
    por la primera cláusula de la @c(and).

#     The aim of logic programming is to provide the programmer with techniques for
#     decomposing a computational problem into two separate problems: @"(what) is to
#     be computed, and @"(how) this should be computed. This is accomplished by
#     selecting a subset of the statements of mathematical logic that is powerful
#     enough to be able to describe anything one might want to compute, yet weak
#     enough to have a controllable procedural interpretation. The intention here is
#     that, on the one hand, a program specified in a logic programming language
#     should be an effective program that can be carried out by a computer. Control
#     (@"(how) to compute) is effected by using the order of evaluation of the
#     language. We should be able to arrange the order of clauses and the order of
#     subgoals within each clause so that the computation is done in an order deemed
#     to be effective and efficient. At the same time, we should be able to view the
#     result of the computation (@"(what) to compute) as a simple consequence of the
#     laws of logic.
    El objetivo de la programación lógica es proporcionar al programador
    técnicas para descomponer un problema computacional en dos problemas
    separados: @"(qué) se calcula y @"(cómo) se calcula. Esto se logra mediante
    la selección de un subconjunto de las declaraciones de lógica matemática que
    es lo suficientemente potente como para poder describir cualquier cosa que
    se quiera computar, pero lo suficientemente débil como para tener una
    interpretación procesal controlable. La intención aquí es que, por un lado,
    un programa especificado en un lenguaje de programación lógica debe ser un
    programa eficaz que puede ser llevado a cabo por un ordenador. El control (
    @"(cómo) calcular) se efectúa utilizando el orden de evaluación del
    lenguaje. Deberíamos ser capaces de ordenar el orden de las cláusulas y el
    orden de los subobjetivos dentro de cada cláusula para que el cálculo se
    realice en un orden considerado eficaz y eficiente. @"(Al mismo tiempo,
    deberíamos ser capaces de ver el resultado de la computación ( qué)
    calcular) como una simple consecuencia de las leyes de la lógica.

#     Our query language can be regarded as just such a procedurally interpretable
#     subset of mathematical logic. An assertion represents a simple fact (an atomic
#     proposition). A rule represents the implication that the rule conclusion holds
#     for those cases where the rule body holds. A rule has a natural procedural
#     interpretation: To establish the conclusion of the rule, establish the body of
#     the rule. Rules, therefore, specify computations. However, because rules can
#     also be regarded as statements of mathematical logic, we can justify any
#     @"(inference) accomplished by a logic program by asserting that the same
#     result could be obtained by working entirely within mathematical logic.@n(280)
    Nuestro lenguaje de consulta puede considerarse como un subconjunto de la
    lógica matemática que puede interpretarse de forma procesable. Una aserción
    representa un hecho simple (una proposición atómica). Una regla representa
    la implicación de que la conclusión de la regla es válida para aquellos
    casos en los que el cuerpo de la regla tiene. Una regla tiene una
    interpretación de procedimiento natural: Para establecer la conclusión de la
    regla, establecer el cuerpo de la regla. Las reglas, por lo tanto,
    especifican los cálculos. Sin embargo, debido a que las reglas también
    pueden considerarse como declaraciones de lógica matemática, podemos
    justificar cualquier @"(inferencia) lograda por un programa lógico afirmando
    que el mismo resultado podría obtenerse trabajando totalmente dentro de la
    lógica matemática.@n(280)

# **** Infinite loops
**** Bucles infinitos

#      A consequence of the procedural interpretation of logic programs is that it is
#      possible to construct hopelessly inefficient programs for solving certain
#      problems. An extreme case of inefficiency occurs when the system falls into
#      infinite loops in making deductions. As a simple example, suppose we are
#      setting up a data base of famous marriages, including
     Una consecuencia de la interpretación procedimental de los programas
     lógicos es que es posible construir programas desesperadamente ineficientes
     para resolver ciertos problemas. Un caso extremo de ineficiencia ocurre
     cuando el sistema cae en lazos infinitos al hacer deducciones. Como ejemplo
     simple, supongamos que estamos creando una base de datos de matrimonios
     famosos, incluyendo

#      ..src > scheme
#        (assert! (married Minnie Mickey))
#      < src..
     ..src > scheme
       (assert! (married Minnie Mickey))
     < src..

#      If we now ask
     Si ahora preguntamos

#      ..src > scheme
#        (married Mickey ?who)
#      < src..
     ..src > scheme
       (married Mickey ?who)
     < src..

#      we will get no response, because the system doesn't know that if @m(a) is
#      married to @m(B), then @m(B) is married to @m(a). So we assert the rule
     No obtendremos ninguna respuesta, porque el sistema no sabe que si @m(a)
     está casado con @m(B), entonces @m(B) está casado con @m(a). Así que
     afirmamos la regla

#      ..src > scheme
#        (assert! (rule (married ?x ?y)
#                       (married ?y ?x)))
#      < src..
     ..src > scheme
       (assert! (rule (married ?x ?y)
                      (married ?y ?x)))
     < src..

#      and again query
     Y de nuevo consulta

#      ..src > scheme
#        (married Mickey ?who)
#      < src..
     ..src > scheme
       (married Mickey ?who)
     < src..

#      Unfortunately, this will drive the system into an infinite loop, as follows:
     Desafortunadamente, esto conducirá al sistema en un bucle infinito, como
     sigue:

#      - The system finds that the @c(married) rule is applicable; that is, the rule
#        conclusion @c[(married ?x ?y)] successfully unifies with the query pattern
#        @c[(married Mickey ?who)] to produce a frame in which @c(?x) is bound to
#        @c(Mickey) and @c(?y) is bound to @c(?who). So the interpreter proceeds to
#        evaluate the rule body @c[(married ?y ?x)] in this frame––in effect, to
#        process the query @c[(married ?who Mickey)].
     - El sistema considera que la @c(married) regla es aplicable; Es decir, la
       conclusión de la regla se @c[(married ?x ?y)] unifica exitosamente con el
       patrón de consulta @c[(married Mickey ?who)] para producir un marco en el
       que @c(?x) está enlazado @c(Mickey) y @c(?y) está enlazado @c(?who). Así
       que el intérprete procede a evaluar el cuerpo de la regla @c[(married ?y
       ?x)] en este marco - en efecto, para procesar la consulta @c[(married
       ?who Mickey)].

#      - One answer appears directly as an assertion in the data base: @c[(married
#        Minnie Mickey)].
     - Una respuesta aparece directamente como una afirmación en la base de
       datos: @c[(married Minnie Mickey)].

#      - The @c(married) rule is also applicable, so the interpreter again evaluates
#        the rule body, which this time is equivalent to @c[(married Mickey ?who)].
     - La @c(married) regla también es aplicable, por lo que el intérprete
       evalúa nuevamente el cuerpo de la regla, que esta vez es equivalente a
       @c[(married Mickey ?who)].


#      The system is now in an infinite loop. Indeed, whether the system will find
#      the simple answer @c[(married Minnie Mickey)] before it goes into the loop
#      depends on implementation details concerning the order in which the system
#      checks the items in the data base. This is a very simple example of the kinds
#      of loops that can occur. Collections of interrelated rules can lead to loops
#      that are much harder to anticipate, and the appearance of a loop can depend on
#      the order of clauses in an @c(and) (see @l(#Exercise 4.64)) or on low-level
#      details concerning the order in which the system processes queries.@n(281)
     El sistema está ahora en un bucle infinito. De hecho, si el sistema
     encontrará la respuesta simple @c[(married Minnie Mickey)] antes de entrar
     en el bucle depende de los detalles de implementación relativos al orden en
     que el sistema comprueba los elementos de la base de datos. Este es un
     ejemplo muy simple de los tipos de bucles que pueden ocurrir. Las
     colecciones de reglas interrelacionadas pueden conducir a bucles mucho más
     difíciles de prever, y la aparición de un bucle puede depender del orden de
     las cláusulas de un @l(#Ejercicio)@c(and) (véase el
     @l(#Ejercicio 4.64) ) o de detalles de bajo nivel relativos
     al orden en que el sistema procesa las consultas.@n(281)

# **** Problems with @c(not)
**** Problemas con @c(not)

#      Another quirk in the query system concerns @c(not). Given the data base of
#      @l(#4.4.1), consider the following two queries:
     Otra peculiaridad en el sistema de consulta se refiere @c(not). Teniendo en
     cuenta la base de datos de la seccion @l(#4.4.1), considere las siguientes dos
     consultas:

#      ..src > scheme
#        (and (supervisor ?x ?y)
#             (not (job ?x (computer programmer))))
#
#        (and (not (job ?x (computer programmer)))
#             (supervisor ?x ?y))
#      < src..
     ..src > scheme
       (and (supervisor ?x ?y)
            (not (job ?x (computer programmer))))

       (and (not (job ?x (computer programmer)))
            (supervisor ?x ?y))
     < src..

#      These two queries do not produce the same result. The first query begins by
#      finding all entries in the data base that match @c[(supervisor ?x ?y)], and
#      then filters the resulting frames by removing the ones in which the value of
#      @c(?x) satisfies @c[(job ?x (computer programmer))]. The second query begins
#      by filtering the incoming frames to remove those that can satisfy @c[(job ?x
#      (computer programmer))]. Since the only incoming frame is empty, it checks the
#      data base to see if there are any patterns that satisfy @c[(job ?x (computer
#      programmer))]. Since there generally are entries of this form, the @c(not)
#      clause filters out the empty frame and returns an empty stream of
#      frames. Consequently, the entire compound query returns an empty stream.
     Estas dos consultas no producen el mismo resultado. La primera consulta
     comienza encontrando todas las entradas en la base de datos que coinciden
     @c[(supervisor ?x ?y)] y, a continuación, filtra los cuadros resultantes
     quitando los en los que el valor de @c(?x) satisface @c[(job ?x (computer
     programmer))]. La segunda consulta comienza filtrando los cuadros entrantes
     para quitar aquellos que pueden satisfacer @c[(job ?x (computer
     programmer))]. Dado que la única trama entrante está vacía, comprueba la
     base de datos para ver si hay patrones que satisfagan @c[(job ?x (computer
     programmer))]. Puesto que generalmente hay entradas de este formulario, la
     @c(not) cláusula filtra el marco vacío y devuelve un flujo vacío de
     marcos. En consecuencia, toda la consulta compuesta devuelve una secuencia
     vacía.

#      The trouble is that our implementation of @c(not) really is meant to serve as
#      a filter on values for the variables. If a @c(not) clause is processed with a
#      frame in which some of the variables remain unbound (as does @c(?x) in the
#      example above), the system will produce unexpected results. Similar problems
#      occur with the use of @c(lisp-value)––the Lisp predicate can't work if some of
#      its arguments are unbound. See @l(#Exercise 4.77).
     El problema es que nuestra implementación de @c(not) realmente está
     destinado a servir como un filtro de valores para las variables. Si una
     @c(not) cláusula se procesa con un marco en el que algunas de las variables
     permanecen sin consolidar (como @c(?x) en el ejemplo anterior), el sistema
     producirá resultados inesperados. Problemas similares ocurren con el uso de
     @c(lisp-value)- el predicado Lisp no puede funcionar si algunos de sus
     argumentos no están unidos. Véase el @l(#Ejercicio 4.77).

#      There is also a much more serious way in which the @c(not) of the query
#      language differs from the @c(not) of mathematical logic. In logic, we
#      interpret the statement @"(not @m(P)) to mean that @m(P) is not true. In the
#      query system, however, @"(not @m(P)) means that @m(P) is not deducible from
#      the knowledge in the data base. For example, given the personnel data base of
#      @l(#4.4.1), the system would happily deduce all sorts of @c(not) statements,
#      such as that Ben Bitdiddle is not a baseball fan, that it is not raining
#      outside, and that 2 + 2 is not 4.@n(282) In other words, the @c(not) of logic
#      programming languages reflects the so-called @e(closed world assumption) that
#      all relevant information has been included in the data base.@n(283)
     Hay también una manera mucho más seria en que el @c(not) del lenguaje de la
     pregunta difiere del @c(not) de la lógica matemática. En lógica,
     interpretamos la afirmación @"(no @m(P)) para significar que @m(P) no es
     verdadera. En el sistema de consulta, sin embargo, @"(no @m(P)) significa
     que @m(P) no es deducible del conocimiento en la base de datos. Por
     ejemplo, dada la base de datos del personal de la seccion @l(#4.4.1), el
     sistema deduciría felizmente todo tipo de @c(not) enunciados, tales como
     que Ben Bitdiddle no es un aficionado al béisbol, que no está lloviendo
     fuera y que 2 + 2 no es 4.@n(282) En otras palabras, @c(not) El de
     los lenguajes de programación lógica refleja la supuesta @e(suposición de
     mundo cerrado de) que toda la información relevante ha sido incluida en la
     base de datos.@n(283)

#      :: @t(Exercise 4.64) :: Louis Reasoner mistakenly deletes the @c(outranked-by)
#         rule (section @l(#4.4.1)) from the data base. When he realizes this, he quickly
#         reinstalls it. Unfortunately, he makes a slight change in the rule, and
#         types it in as
     :: @t(Ejercicio 4.64) :: Louis Reasoner elimina por error la
        @c(outranked-by) regla (seccion @l(#4.4.1)) de la base de datos. Cuando
        se da cuenta de esto, rápidamente lo reinstala. Desafortunadamente, él
        hace un ligero cambio en la regla, y lo escribe como

#         ..src > scheme
#           (rule (outranked-by ?staff-person ?boss)
#             (or (supervisor ?staff-person ?boss)
#                 (and (outranked-by ?middle-manager
#                                    ?boss)
#                      (supervisor ?staff-person
#                                  ?middle-manager))))
#         < src..
        ..src > scheme
          (rule (outranked-by ?staff-person ?boss)
            (or (supervisor ?staff-person ?boss)
                (and (outranked-by ?middle-manager
                                   ?boss)
                     (supervisor ?staff-person
                                 ?middle-manager))))
        < src..

#         Just after Louis types this information into the system, DeWitt Aull comes
#         by to find out who outranks Ben Bitdiddle. He issues the query
        Justo después de Louis escribir esta información en el sistema, DeWitt
        Aull viene para averiguar quién supera a Ben Bitdiddle. Emite la
        consulta

#         ..src > scheme
#           (outranked-by (Bitdiddle Ben) ?who)
#         < src..
        ..src > scheme
          (outranked-by (Bitdiddle Ben) ?who)
        < src..

#         After answering, the system goes into an infinite loop. Explain why.
        Después de responder, el sistema entra en un bucle infinito. Explicar
        por qué.

#      :: @t(Exercise 4.65) :: Cy D. Fect, looking forward to the day when he will
#         rise in the organization, gives a query to find all the wheels (using the
#         @c(wheel) rule of section @l(#4.4.1)):
     :: @t(Ejercicio 4.65) :: Cy D. Fect, esperando el día en que se levante en
        la organización, da una consulta para encontrar todas las ruedas (usando
        la @c(wheel) regla de la seccion @l(#4.4.1)):

#         ..src > scheme
#           (wheel ?who)
#         < src..
        ..src > scheme
          (wheel ?who)
        < src..

#         To his surprise, the system responds
        Para su sorpresa, el sistema responde

#         ..srci > scheme
#           ;;; Query results:
#           > (wheel (Warbucks Oliver))
#           > (wheel (Bitdiddle Ben))
#           > (wheel (Warbucks Oliver))
#           > (wheel (Warbucks Oliver))
#           > (wheel (Warbucks Oliver))
#         < srci..
        ..srci > scheme
          ;;; Query results:
          > (wheel (Warbucks Oliver))
          > (wheel (Bitdiddle Ben))
          > (wheel (Warbucks Oliver))
          > (wheel (Warbucks Oliver))
          > (wheel (Warbucks Oliver))
        < srci..

#         Why is Oliver Warbucks listed four times?
        ¿Por qué aparece Oliver Warbucks cuatro veces?

#      :: @t(Exercise 4.66) :: Ben has been generalizing the query system to provide
#         statistics about the company. For example, to find the total salaries of
#         all the computer programmers one will be able to say
     :: @t(Ejercicio 4.66) :: Ben ha estado generalizando el sistema de
        consultas para proporcionar estadísticas sobre la empresa. Por ejemplo,
        para encontrar los salarios totales de todos los programadores de
        computadoras uno será capaz de decir

#         ..src > scheme
#           (sum ?amount
#                (and (job ?x (computer programmer))
#                     (salary ?x ?amount)))
#         < src..
        ..src > scheme
          (sum ?amount
               (and (job ?x (computer programmer))
                    (salary ?x ?amount)))
        < src..

#         In general, Ben's new system allows expressions of the form
        En general, el nuevo sistema de Ben permite expresiones de la forma

#         ..src > scheme
#           (accumulation-function ⟨variable⟩
#                                  ⟨query pattern⟩)
#         < src..
        ..src > scheme
          (accumulation-function ⟨variable⟩
                                 ⟨query pattern⟩)
        < src..

#         where @c(accumulation-function) can be things like @c(sum), @c(average), or
#         @c(maximum). Ben reasons that it should be a cinch to implement this. He
#         will simply feed the query pattern to @c(qeval). This will produce a stream
#         of frames. He will then pass this stream through a mapping function that
#         extracts the value of the designated variable from each frame in the stream
#         and feed the resulting stream of values to the accumulation function. Just
#         as Ben completes the implementation and is about to try it out, Cy walks
#         by, still puzzling over the @c(wheel) query result in @l(#Exercise
#         4.65). When Cy shows Ben the system's response, Ben groans, @"(Oh, no, my
#         simple accumulation scheme won't work!)
        donde @c(accumulation-function) pueden ser cosas como @c(sum),
        @c(average) o @c(maximum). Ben razona que debe ser un cinch para
        implementar esto. Simplemente alimentará el patrón de consulta a
        @c(qeval). Esto producirá una secuencia de tramas. A continuación,
        pasará este flujo a través de una función de correlación que extrae el
        valor de la variable designada de cada trama en el flujo y alimentar el
        flujo resultante de valores a la función de acumulación. Así como Ben
        completa la implementación y está a punto de probarlo, Cy camina por,
        todavía desconcertante sobre el @c(wheel) resultado de la consulta en el
        @l(#Ejercicio 4.65). Cuando Cy muestra Ben la respuesta
        del sistema, Ben gime, @"(¡Oh, no, mi esquema de acumulación simple no
        funcionará!)

#         What has Ben just realized?  Outline a method he can use to salvage the
#         situation.
        ¿Qué Ben acaba de darse cuenta? Describe un método que puede usar para
        salvar la situación.

#      :: @t(Exercise 4.67) :: Devise a way to install a loop detector in the query
#         system so as to avoid the kinds of simple loops illustrated in the text and
#         in @l(#Exercise 4.64). The general idea is that the system should maintain
#         some sort of history of its current chain of deductions and should not
#         begin processing a query that it is already working on. Describe what kind
#         of information (patterns and frames) is included in this history, and how
#         the check should be made. (After you study the details of the query-system
#         implementation in section @l(#4.4.4), you may want to modify the system to include
#         your loop detector.)
     :: @t(Ejercicio 4.67) :: Diseñar una manera de instalar un detector de
        bucle en el sistema de consulta para evitar los tipos de bucles simples
        ilustrados en el texto y en el @l(#Ejercicio 4.64). La
        idea general es que el sistema debe mantener algún tipo de historia de
        su actual cadena de deducciones y no debe comenzar a procesar una
        consulta que ya está trabajando. Describa qué tipo de información
        (patrones y marcos) se incluye en esta historia, y cómo debe hacerse el
        cheque. (Después de estudiar los detalles de la implementación del
        sistema de consulta en la seccion @l(#4.4.4), puede que desee modificar el
        sistema para que incluya su detector de bucle).

#      :: @t(Exercise 4.68) :: Define rules to implement the @c(reverse) operation of
#         @l(#Exercise 2.18), which returns a list containing the same elements as a
#         given list in reverse order. (Hint: Use @c(append-to-form).)  Can your
#         rules answer both @c[(reverse (1 2 3) ?x)] and @c[(reverse ?x (1 2 3))]?
     :: @t(Ejercicio 4.68) :: Definir reglas para implementar la @c(reverse)
        operación del @l(#Ejercicio 2.18), que devuelve una lista
        que contiene los mismos elementos de una lista dada en orden
        inverso. (Sugerencia: Use @c(append-to-form).) ¿Pueden sus reglas
        contestar tanto @c[(reverse (1 2 3) ?x)] y @c[(reverse ?x (1 2 3))]?

#      :: @t(Exercise 4.69) :: Beginning with the data base and the rules you
#         formulated in @l(#Exercise 4.63), devise a rule for adding @"(greats) to a
#         grandson relationship. This should enable the system to deduce that Irad is
#         the great-grandson of Adam, or that Jabal and Jubal are the
#         great-great-great-great-great-grandsons of Adam. (Hint: Represent the fact
#         about Irad, for example, as @c[((great grandson) Adam Irad)]. Write rules
#         that determine if a list ends in the word @c(grandson). Use this to express
#         a rule that allows one to derive the relationship @c[((great . ?rel) ?x
#         ?y)], where @c(?rel) is a list ending in @c(grandson).)  Check your rules
#         on queries such as @c[((great grandson) ?g ?ggs)] and @c[(?relationship
#         Adam Irad)].
     :: @t(Ejercicio 4.69) :: Comenzando con la base de datos y las reglas que
        formuló en el @l(#Ejercicio 4.63), diseñar una regla para
        agregar @"(grandes) a una relación de nieto. Esto debería permitir que
        el sistema dedujera que Irad es el bisnieto de Adán, o que Jabal y Jubal
        son los tataravos-grandes-bisnietos de Adán. (Sugerencia: Represente el
        hecho acerca de Irad, por ejemplo, como @c[((great grandson) Adam
        Irad)]: Escribir reglas que determinan si una lista termina en la
        palabra.Usar @c(grandson) esto para expresar una regla que permite
        derivar la relación @c[((great. ?rel) ?x ?y)], donde @c(?rel) es una
        lista que termina en @c(grandson). Reglas sobre consultas como
        @c[((great grandson) ?g ?ggs)] y @c[(?relationship Adam Irad)].

# *** 4.4.4 <> Implementing the Query System
*** 4.4.4 <> Implementación del sistema de consultas

#     Section @l(#4.4.2) described how the query system works. Now we fill in the
#     details by presenting a complete implementation of the system.
    La sección @l(#4.4.2) describe cómo funciona el sistema de
    consultas. Ahora llenamos los detalles presentando una implementación
    completa del sistema.

# **** 4.4.4.1 <> The Driver Loop and Instantiation
**** 4.4.4.1 <> El bucle del controlador y la instancia

#      The driver loop for the query system repeatedly reads input expressions. If
#      the expression is a rule or assertion to be added to the data base, then the
#      information is added. Otherwise the expression is assumed to be a query. The
#      driver passes this query to the evaluator @c(qeval) together with an initial
#      frame stream consisting of a single empty frame. The result of the evaluation
#      is a stream of frames generated by satisfying the query with variable values
#      found in the data base. These frames are used to form a new stream consisting
#      of copies of the original query in which the variables are instantiated with
#      values supplied by the stream of frames, and this final stream is printed at
#      the terminal:
     El bucle del controlador para el sistema de consulta lee repetidamente las
     expresiones de entrada. Si la expresión es una regla o aserción que se
     agrega a la base de datos, se agrega la información. De lo contrario, se
     supone que la expresión es una consulta. El controlador pasa esta consulta
     al evaluador @c(qeval) junto con una secuencia de trama inicial que consta
     de un único marco vacío. El resultado de la evaluación es un flujo de
     tramas generadas al satisfacer la consulta con valores de variable
     encontrados en la base de datos. Estas tramas se utilizan para formar una
     nueva corriente consistente en copias de la consulta original en la que las
     variables se instancian con valores suministrados por el flujo de tramas y
     esta corriente final se imprime en el terminal:

#      ..src > scheme
#        (define input-prompt  ";;; Query input:")
#        (define output-prompt ";;; Query results:")
#
#        (define (query-driver-loop)
#          (prompt-for-input input-prompt)
#          (let ((q (query-syntax-process (read))))
#            (cond ((assertion-to-be-added? q)
#                   (add-rule-or-assertion!
#                    (add-assertion-body q))
#                   (newline)
#                   (display
#                    "Assertion added to data base.")
#                   (query-driver-loop))
#                  (else
#                   (newline)
#                   (display output-prompt)
#                   (display-stream
#                    (stream-map
#                     (lambda (frame)
#                       (instantiate
#                        q
#                        frame
#                        (lambda (v f)
#                          (contract-question-mark v))))
#                     (qeval q (singleton-stream '()))))
#                   (query-driver-loop)))))
#      < src..
     ..src > scheme
       (define input-prompt  ";;; Query input:")
       (define output-prompt ";;; Query results:")

       (define (query-driver-loop)
         (prompt-for-input input-prompt)
         (let ((q (query-syntax-process (read))))
           (cond ((assertion-to-be-added? q)
                  (add-rule-or-assertion!
                   (add-assertion-body q))
                  (newline)
                  (display
                   "Assertion added to data base.")
                  (query-driver-loop))
                 (else
                  (newline)
                  (display output-prompt)
                  (display-stream
                   (stream-map
                    (lambda (frame)
                      (instantiate
                       q
                       frame
                       (lambda (v f)
                         (contract-question-mark v))))
                    (qeval q (singleton-stream '()))))
                  (query-driver-loop)))))
     < src..

#      Here, as in the other evaluators in this chapter, we use an abstract syntax
#      for the expressions of the query language. The implementation of the
#      expression syntax, including the predicate @c(assertion-to-be-added?) and the
#      selector @c(add-assertion-body), is given in section @l(#4.4.4.7).
#      @c(Add-rule-or-assertion!) is defined in section @l(#4.4.4.5).
     Aquí, al igual que en los otros evaluadores de este capítulo, utilizamos
     una sintaxis abstracta para las expresiones del lenguaje de consulta. La
     implementación de la sintaxis de expresión, incluyendo el predicado
     @c(assertion-to-be-added?) y el selector @c(add-assertion-body), se da en
     @l(#4.4.4.7). @c(Add-rule-or-assertion!) Se define en
     @l(#4.4.4.5).

#      Before doing any processing on an input expression, the driver loop transforms
#      it syntactically into a form that makes the processing more efficient. This
#      involves changing the representation of pattern variables. When the query is
#      instantiated, any variables that remain unbound are transformed back to the
#      input representation before being printed. These transformations are performed
#      by the two procedures @c(query-syntax-process) and @c(contract-question-mark)
#      (section @l(#4.4.4.7)).
     Antes de realizar cualquier procesamiento en una expresión de entrada, el
     bucle de controlador lo transforma sintácticamente en una forma que hace
     que el procesamiento sea más eficiente. Esto implica cambiar la
     representación de variables de patrón. Cuando se instancia la consulta, las
     variables que permanecen sin enlazar se transforman de nuevo en la
     representación de entrada antes de imprimirse. Estas transformaciones se
     realizan mediante los dos procedimientos @c(query-syntax-process) y
     @c(contract-question-mark)(seccion @l(#4.4.4.7)).

#      To instantiate an expression, we copy it, replacing any variables in the
#      expression by their values in a given frame. The values are themselves
#      instantiated, since they could contain variables (for example, if @c(?x) in
#      @c(exp) is bound to @c(?y) as the result of unification and @c(?y) is in turn
#      bound to 5). The action to take if a variable cannot be instantiated is given
#      by a procedural argument to @c(instantiate).
     Para instanciar una expresión, lo copiamos, reemplazando cualquier variable
     de la expresión por sus valores en un marco dado. Los valores son ellos
     mismos instanciados, ya que podrían contener variables (por ejemplo, si
     @c(?x) in @c(exp) está unido a @c(?y) como resultado de la unificación y
     @c(?y) está a su vez unido a 5). La acción a tomar si una variable no puede
     ser instanciada es dada por un argumento procedimental a @c(instantiate).

#      ..src > scheme
#        (define (instantiate
#                 exp frame unbound-var-handler)
#          (define (copy exp)
#            (cond ((var? exp)
#                   (let ((binding
#                          (binding-in-frame
#                           exp frame)))
#                     (if binding
#                         (copy
#                          (binding-value binding))
#                         (unbound-var-handler
#                          exp frame))))
#                  ((pair? exp)
#                   (cons (copy (car exp))
#                         (copy (cdr exp))))
#                  (else exp)))
#          (copy exp))
#      < src..
     ..src > scheme
       (define (instantiate
                exp frame unbound-var-handler)
         (define (copy exp)
           (cond ((var? exp)
                  (let ((binding
                         (binding-in-frame
                          exp frame)))
                    (if binding
                        (copy
                         (binding-value binding))
                        (unbound-var-handler
                         exp frame))))
                 ((pair? exp)
                  (cons (copy (car exp))
                        (copy (cdr exp))))
                 (else exp)))
         (copy exp))
     < src..

#      The procedures that manipulate bindings are defined in section @l(#4.4.4.8).
     Los procedimientos que manipulan los enlaces se definen en
     @l(#4.4.4.8).

# **** 4.4.4.2 <> The Evaluator
**** 4.4.4.2 <> El Evaluador

#      The @c(qeval) procedure, called by the @c(query-driver-loop), is the basic
#      evaluator of the query system. It takes as inputs a query and a stream of
#      frames, and it returns a stream of extended frames. It identifies special
#      forms by a data-directed dispatch using @c(get) and @c(put), just as we did in
#      implementing generic operations in @l(#Chapter 2). Any query that is not
#      identified as a special form is assumed to be a simple query, to be processed
#      by @c(simple-query).
     El procedimiento @c(qeval), llamado por el @c(query-driver-loop), es el
     evaluador básico del sistema de consulta. Toma como entradas una consulta y
     una secuencia de tramas, y devuelve una secuencia de tramas
     extendidas. Identifica formularios especiales mediante un envío dirigido a
     datos utilizando @c(get) y @c(put), al igual que lo hicimos en la
     implementación de operaciones genéricas en el @l(#Capitulo
     2). Cualquier consulta que no se identifique como un formulario especial se
     supone que es una consulta simple, para ser procesado por @c(simple-query).

#      ..src > scheme
#        (define (qeval query frame-stream)
#          (let ((qproc (get (type query) 'qeval)))
#            (if qproc
#                (qproc (contents query) frame-stream)
#                (simple-query query frame-stream))))
#      < src..
     ..src > scheme
       (define (qeval query frame-stream)
         (let ((qproc (get (type query) 'qeval)))
           (if qproc
               (qproc (contents query) frame-stream)
               (simple-query query frame-stream))))
     < src..

#      @c(Type) and @c(contents), defined in section @l(#4.4.4.7), implement the abstract
#      syntax of the special forms.
     @c(Type) Y @c(contents), definidas en la seccion @l(#4.4.4.7), implementan la
     sintaxis abstracta de los formularios especiales.

# ***** Simple queries
***** Consultas sencillas

#       The @c(simple-query) procedure handles simple queries. It takes as arguments a
#       simple query (a pattern) together with a stream of frames, and it returns the
#       stream formed by extending each frame by all data-base matches of the query.
      El procedimiento @c(simple-query) maneja consultas simples. Toma como
      argumentos una consulta simple (un patrón) junto con un flujo de tramas, y
      devuelve el flujo formado al extender cada trama por todas las
      coincidencias de base de datos de la consulta.

#       ..src > scheme
#         (define (simple-query query-pattern
#                               frame-stream)
#           (stream-flatmap
#            (lambda (frame)
#              (stream-append-delayed
#               (find-assertions query-pattern frame)
#               (delay
#                 (apply-rules query-pattern frame))))
#            frame-stream))
#       < src..
      ..src > scheme
        (define (simple-query query-pattern
                              frame-stream)
          (stream-flatmap
           (lambda (frame)
             (stream-append-delayed
              (find-assertions query-pattern frame)
              (delay
                (apply-rules query-pattern frame))))
           frame-stream))
      < src..

#       For each frame in the input stream, we use @c(find-assertions) (section @l(#4.4.4.3))
#       to match the pattern against all assertions in the data base, producing a
#       stream of extended frames, and we use @c(apply-rules) (section @l(#4.4.4.4)) to apply
#       all possible rules, producing another stream of extended frames. These two
#       streams are combined (using @c(stream-append-delayed), @l(#4.4.4.6)) to make a
#       stream of all the ways that the given pattern can be satisfied consistent with
#       the original frame (see @l(#Exercise 4.71)). The streams for the individual
#       input frames are combined using @c(stream-flatmap) (section @l(#4.4.4.6)) to form one
#       large stream of all the ways that any of the frames in the original input
#       stream can be extended to produce a match with the given pattern.
      Para cada trama en el flujo de entrada, usamos @c(find-assertions)(
      @l(#4.4.4.3)) para hacer coincidir el patrón con todas las
      aserciones en la base de datos, produciendo un flujo de tramas extendidas,
      y usamos @c(apply-rules)(seccion @l(#4.4.4.4)) para aplicar todas las
      reglas posibles, produciendo otro Corriente de marcos extendidos. Estas
      dos corrientes se combinan (usando @c(stream-append-delayed),
      @l(#4.4.4.6)) para hacer una corriente de todas las maneras en
      que el patrón dado puede ser satisfecho consistente con el marco original
      (véase el @l(#Ejercicio 4.71) ). Las corrientes para las
      tramas de entrada individuales se combinan usando @c(stream-flatmap)(
      @l(#4.4.4.6)) para formar un flujo grande de todas las formas en
      que cualquiera de los fotogramas en el flujo de entrada original puede
      extenderse para producir una coincidencia con el patrón dado.

# ***** Compound queries
***** Consultas compuestas

#       @c(And) queries are handled as illustrated in @l(#Figure 4.5) by the
#       @c(conjoin) procedure. @c(Conjoin) takes as inputs the conjuncts and the frame
#       stream and returns the stream of extended frames. First, @c(conjoin) processes
#       the stream of frames to find the stream of all possible frame extensions that
#       satisfy the first query in the conjunction. Then, using this as the new frame
#       stream, it recursively applies @c(conjoin) to the rest of the queries.
      @c(And) Las consultas se manejan como se ilustra en la
      @l(#Figura 4.5) por el procedimiento @c(conjoin). @c(Conjoin)
      Toma como entradas los conjuntos y el flujo de trama y devuelve el flujo
      de tramas extendidas. En primer lugar, @c(conjoin) procesa el flujo de
      tramas para encontrar el flujo de todas las extensiones de trama posibles
      que satisfagan la primera consulta en la conjunción. Entonces, utilizando
      esto como la nueva secuencia de tramas, se aplica recursivamente
      @c(conjoin) al resto de las consultas.

#       ..src > scheme
#         (define (conjoin conjuncts frame-stream)
#           (if (empty-conjunction? conjuncts)
#               frame-stream
#               (conjoin (rest-conjuncts conjuncts)
#                        (qeval
#                         (first-conjunct conjuncts)
#                         frame-stream))))
#       < src..
      ..src > scheme
        (define (conjoin conjuncts frame-stream)
          (if (empty-conjunction? conjuncts)
              frame-stream
              (conjoin (rest-conjuncts conjuncts)
                       (qeval
                        (first-conjunct conjuncts)
                        frame-stream))))
      < src..

#       The expression
      La expresion

#       ..src > scheme
#         (put 'and 'qeval conjoin)
#       < src..
      ..src > scheme
        (put 'and 'qeval conjoin)
      < src..

#       sets up @c(qeval) to dispatch to @c(conjoin) when an @c(and) form is
#       encountered.
      Se configura @c(qeval) para enviar a @c(conjoin) cuando @c(and) se
      encuentra un formulario.

#       @c(Or) queries are handled similarly, as shown in @l(#Figure 4.6). The output
#       streams for the various disjuncts of the @c(or) are computed separately and
#       merged using the @c(interleave-delayed) procedure from @l(#4.4.4.6). (See
#       @l(#Exercise 4.71) and @l(#Exercise 4.72).)
      @c(Or) Las consultas se manejan de forma similar, como se muestra en la
      @l(#Figura 4.6). Los flujos de salida para los distintos
      disjuntos de la @c(or) se calculan por separado y se combinan utilizando
      el procedimiento @c(interleave-delayed) de la seccion @l(#4.4.4.6). (Véase
      el @l(#Ejercicio 4.71) y el @l(#Ejercicio
      4.72) .)

#       ..src > scheme
#         (define (disjoin disjuncts frame-stream)
#           (if (empty-disjunction? disjuncts)
#               the-empty-stream
#               (interleave-delayed
#                (qeval (first-disjunct disjuncts)
#                       frame-stream)
#                (delay (disjoin
#                        (rest-disjuncts disjuncts)
#                        frame-stream)))))
#         (put 'or 'qeval disjoin)
#       < src..
      ..src > scheme
        (define (disjoin disjuncts frame-stream)
          (if (empty-disjunction? disjuncts)
              the-empty-stream
              (interleave-delayed
               (qeval (first-disjunct disjuncts)
                      frame-stream)
               (delay (disjoin
                       (rest-disjuncts disjuncts)
                       frame-stream)))))
        (put 'or 'qeval disjoin)
      < src..

#       The predicates and selectors for the syntax of conjuncts and disjuncts are
#       given in section @l(#4.4.4.7).
      Los predicados y selectores para la sintaxis de conjuntas y disyunciones
      se dan en la seccion @l(#4.4.4.7).

# ***** Filters
***** Filtros

#       @c(Not) is handled by the method outlined in section @l(#4.4.2). We attempt to extend
#       each frame in the input stream to satisfy the query being negated, and we
#       include a given frame in the output stream only if it cannot be extended.
      @c(Not) Se maneja por el método descrito en la seccion @l(#4.4.2). Intentamos
      extender cada trama en el flujo de entrada para satisfacer la consulta que
      se niega, e incluimos un marco dado en el flujo de salida sólo si no se
      puede extender.

#       ..src > scheme
#         (define (negate operands frame-stream)
#           (stream-flatmap
#            (lambda (frame)
#              (if (stream-null?
#                   (qeval (negated-query operands)
#                          (singleton-stream frame)))
#                  (singleton-stream frame)
#                  the-empty-stream))
#            frame-stream))
#         (put 'not 'qeval negate)
#       < src..
      ..src > scheme
        (define (negate operands frame-stream)
          (stream-flatmap
           (lambda (frame)
             (if (stream-null?
                  (qeval (negated-query operands)
                         (singleton-stream frame)))
                 (singleton-stream frame)
                 the-empty-stream))
           frame-stream))
        (put 'not 'qeval negate)
      < src..

#       @c(Lisp-value) is a filter similar to @c(not). Each frame in the stream is
#       used to instantiate the variables in the pattern, the indicated predicate is
#       applied, and the frames for which the predicate returns false are filtered out
#       of the input stream. An error results if there are unbound pattern variables.
      @c(Lisp-value) Es un filtro similar a @c(not). Cada trama de la secuencia
      se utiliza para instanciar las variables en el patrón, se aplica el
      predicado indicado y las tramas para las que el predicado devuelve false
      se filtran fuera del flujo de entrada. Se produce un error si hay
      variables de patrón no unidas.

#       ..src > scheme
#         (define (lisp-value call frame-stream)
#           (stream-flatmap
#            (lambda (frame)
#              (if (execute
#                   (instantiate
#                    call
#                    frame
#                    (lambda (v f)
#                      (error
#                       "Unknown pat var: LISP-VALUE"
#                       v))))
#                  (singleton-stream frame)
#                  the-empty-stream))
#            frame-stream))
#         (put 'lisp-value 'qeval lisp-value)
#       < src..
      ..src > scheme
        (define (lisp-value call frame-stream)
          (stream-flatmap
           (lambda (frame)
             (if (execute
                  (instantiate
                   call
                   frame
                   (lambda (v f)
                     (error
                      "Unknown pat var: LISP-VALUE"
                      v))))
                 (singleton-stream frame)
                 the-empty-stream))
           frame-stream))
        (put 'lisp-value 'qeval lisp-value)
      < src..

#       @c(Execute), which applies the predicate to the arguments, must @c(eval) the
#       predicate expression to get the procedure to apply. However, it must not
#       evaluate the arguments, since they are already the actual arguments, not
#       expressions whose evaluation (in Lisp) will produce the arguments. Note that
#       @c(execute) is implemented using @c(eval) and @c(apply) from the underlying
#       Lisp system.
      @c(Execute), Que aplica el predicado a los argumentos, debe @c(eval) la
      expresión de predicado para obtener el procedimiento para aplicar. Sin
      embargo, no debe evaluar los argumentos, ya que ya son los argumentos
      reales, no las expresiones cuya evaluación (en Lisp) producirá los
      argumentos. Tenga en cuenta que @c(execute) se implementa utilizando
      @c(eval) y @c(apply) desde el sistema Lisp subyacente.

#       ..src > scheme
#         (define (execute exp)
#           (apply (eval (predicate exp)
#                        user-initial-environment)
#                  (args exp)))
#       < src..
      ..src > scheme
        (define (execute exp)
          (apply (eval (predicate exp)
                       user-initial-environment)
                 (args exp)))
      < src..

#       The @c(always-true) special form provides for a query that is always
#       satisfied. It ignores its contents (normally empty) and simply passes through
#       all the frames in the input stream. @c(Always-true) is used by the
#       @c(rule-body) selector (section @l(#4.4.4.7)) to provide bodies for rules that were
#       defined without bodies (that is, rules whose conclusions are always
#       satisfied).
      El @c(always-true) formulario especial proporciona una consulta que
      siempre se satisface. Ignora su contenido (normalmente vacío) y
      simplemente pasa a través de todos los fotogramas en el flujo de
      entrada. @c(Always-true) Es utilizado por el @c(rule-body) selector (
      @l(#4.4.4.7)) para proporcionar cuerpos para reglas que fueron
      definidas sin cuerpos (es decir, reglas cuyas conclusiones siempre están
      satisfechas).

#       ..src > scheme
#         (define (always-true ignore frame-stream)
#           frame-stream)
#         (put 'always-true 'qeval always-true)
#       < src..
      ..src > scheme
        (define (always-true ignore frame-stream)
          frame-stream)
        (put 'always-true 'qeval always-true)
      < src..

#       The selectors that define the syntax of @c(not) and @c(lisp-value) are given
#       in section @l(#4.4.4.7).
      Los selectores que definen la sintaxis de @c(not) y @c(lisp-value) se dan
      en la seccion @l(#4.4.4.7).

# **** 4.4.4.3 <> Finding Assertions by Pattern Matching
**** 4.4.4.3 <> Cómo encontrar afirmaciones por coincidencia de patrones

#      @c(Find-assertions), called by @c(simple-query) (section @l(#4.4.4.2)), takes as input
#      a pattern and a frame. It returns a stream of frames, each extending the given
#      one by a data-base match of the given pattern. It uses @c(fetch-assertions)
#      (section @l(#4.4.4.5)) to get a stream of all the assertions in the data base that
#      should be checked for a match against the pattern and the frame. The reason
#      for @c(fetch-assertions) here is that we can often apply simple tests that
#      will eliminate many of the entries in the data base from the pool of
#      candidates for a successful match. The system would still work if we
#      eliminated @c(fetch-assertions) and simply checked a stream of all assertions
#      in the data base, but the computation would be less efficient because we would
#      need to make many more calls to the matcher.
     @c(Find-assertions), Llamado por @c(simple-query)(seccion @l(#4.4.4.2)),
     toma como entrada un patrón y una trama. Devuelve una secuencia de tramas,
     cada una de las cuales se extiende por una coincidencia de base de datos
     del patrón dado. Utiliza @c(fetch-assertions)(seccion @l(#4.4.4.5)) para
     obtener una corriente de todas las aserciones en la base de datos que se
     debe comprobar para una coincidencia con el patrón y el marco. La razón de
     @c(fetch-assertions) aquí es que a menudo podemos aplicar pruebas simples
     que eliminarán muchas de las entradas en la base de datos del grupo de
     candidatos para una coincidencia exitosa. El sistema seguiría funcionando
     si eliminábamos @c(fetch-assertions) y simplemente comprobábamos un flujo
     de todas las aserciones en la base de datos, pero el cálculo sería menos
     eficiente porque tendríamos que hacer muchas más llamadas al matcher.

#      ..src > scheme
#        (define (find-assertions pattern frame)
#          (stream-flatmap
#            (lambda (datum)
#              (check-an-assertion datum pattern frame))
#            (fetch-assertions pattern frame)))
#      < src..
     ..src > scheme
       (define (find-assertions pattern frame)
         (stream-flatmap
           (lambda (datum)
             (check-an-assertion datum pattern frame))
           (fetch-assertions pattern frame)))
     < src..

#      @c(Check-an-assertion) takes as arguments a pattern, a data object
#      (assertion), and a frame and returns either a one-element stream containing
#      the extended frame or @c(the-empty-stream) if the match fails.
     @c(Check-an-assertion) Toma como argumentos un patrón, un objeto de datos
     (aserción) y un marco y devuelve un flujo de un solo elemento que contiene
     el marco extendido o @c(the-empty-stream) si la coincidencia falla.

#      ..src > scheme
#        (define (check-an-assertion
#                 assertion query-pat query-frame)
#          (let ((match-result
#                 (pattern-match
#                  query-pat assertion query-frame)))
#            (if (eq? match-result 'failed)
#                the-empty-stream
#                (singleton-stream match-result))))
#      < src..
     ..src > scheme
       (define (check-an-assertion
                assertion query-pat query-frame)
         (let ((match-result
                (pattern-match
                 query-pat assertion query-frame)))
           (if (eq? match-result 'failed)
               the-empty-stream
               (singleton-stream match-result))))
     < src..

#      The basic pattern matcher returns either the symbol @c(failed) or an extension
#      of the given frame. The basic idea of the matcher is to check the pattern
#      against the data, element by element, accumulating bindings for the pattern
#      variables. If the pattern and the data object are the same, the match succeeds
#      and we return the frame of bindings accumulated so far. Otherwise, if the
#      pattern is a variable we extend the current frame by binding the variable to
#      the data, so long as this is consistent with the bindings already in the
#      frame. If the pattern and the data are both pairs, we (recursively) match the
#      @c(car) of the pattern against the @c(car) of the data to produce a frame; in
#      this frame we then match the @c(cdr) of the pattern against the @c(cdr) of the
#      data. If none of these cases are applicable, the match fails and we return the
#      symbol @c(failed).
     El trazador de patrones básico devuelve el símbolo @c(failed) o una
     extensión del marco dado. La idea básica del matcher es comprobar el patrón
     contra los datos, elemento por elemento, acumulando enlaces para las
     variables de patrón. Si el patrón y el objeto de datos son iguales, la
     coincidencia tiene éxito y devolvemos el marco de enlaces acumulados hasta
     ahora. De lo contrario, si el patrón es una variable extendemos el marco
     actual vinculando la variable a los datos, siempre y cuando sea coherente
     con los enlaces ya en el marco. Si el patrón y los datos son ambos pares,
     nosotros (recursivamente) emparejamos el @c(car) del patrón contra el
     @c(car) de los datos para producir un marco; En este marco entonces
     coincidimos con el @c(cdr) del patrón contra el @c(cdr) de los datos. Si
     ninguno de estos casos es aplicable,@c(failed)

#      ..src > scheme
#        (define (pattern-match pat dat frame)
#          (cond ((eq? frame 'failed) 'failed)
#                ((equal? pat dat) frame)
#                ((var? pat)
#                 (extend-if-consistent
#                  pat dat frame))
#                ((and (pair? pat) (pair? dat))
#                 (pattern-match
#                  (cdr pat)
#                  (cdr dat)
#                  (pattern-match
#                   (car pat) (car dat) frame)))
#                (else 'failed)))
#      < src..
     ..src > scheme
       (define (pattern-match pat dat frame)
         (cond ((eq? frame 'failed) 'failed)
               ((equal? pat dat) frame)
               ((var? pat)
                (extend-if-consistent
                 pat dat frame))
               ((and (pair? pat) (pair? dat))
                (pattern-match
                 (cdr pat)
                 (cdr dat)
                 (pattern-match
                  (car pat) (car dat) frame)))
               (else 'failed)))
     < src..

#      Here is the procedure that extends a frame by adding a new binding, if this is
#      consistent with the bindings already in the frame:
     Aquí está el procedimiento que extiende un marco añadiendo un nuevo enlace,
     si esto es consistente con los enlaces ya en el marco:

#      ..src > scheme
#        (define (extend-if-consistent var dat frame)
#          (let ((binding (binding-in-frame var frame)))
#            (if binding
#                (pattern-match
#                 (binding-value binding) dat frame)
#                (extend var dat frame))))
#      < src..
     ..src > scheme
       (define (extend-if-consistent var dat frame)
         (let ((binding (binding-in-frame var frame)))
           (if binding
               (pattern-match
                (binding-value binding) dat frame)
               (extend var dat frame))))
     < src..

#      If there is no binding for the variable in the frame, we simply add the
#      binding of the variable to the data. Otherwise we match, in the frame, the
#      data against the value of the variable in the frame. If the stored value
#      contains only constants, as it must if it was stored during pattern matching
#      by @c(extend-if-consistent), then the match simply tests whether the stored
#      and new values are the same. If so, it returns the unmodified frame; if not,
#      it returns a failure indication. The stored value may, however, contain
#      pattern variables if it was stored during unification (see @l(#4.4.4.4)). The
#      recursive match of the stored pattern against the new data will add or check
#      bindings for the variables in this pattern. For example, suppose we have a
#      frame in which @c(?x) is bound to @c[(f ?y)] and @c(?y) is unbound, and we
#      wish to augment this frame by a binding of @c(?x) to @c[(f b)].  We look up
#      @c(?x) and find that it is bound to @c[(f ?y)]. This leads us to match @c[(f
#      ?y)] against the proposed new value @c[(f b)] in the same frame. Eventually
#      this match extends the frame by adding a binding of @c(?y) to @c(b). @c(?X)
#      remains bound to @c[(f ?y)]. We never modify a stored binding and we never
#      store more than one binding for a given variable.
     Si no hay vinculación para la variable en el marco, simplemente agregamos
     el enlace de la variable a los datos. De lo contrario, coincidimos, en el
     marco, con los datos contra el valor de la variable en el marco. Si el
     valor almacenado contiene sólo constantes, como debe hacerlo si se almacenó
     durante la coincidencia de patrones @c(extend-if-consistent), entonces el
     resultado simplemente comprueba si los valores almacenados y nuevos son
     iguales. Si es así, devuelve el marco no modificado; Si no, devuelve una
     indicación de fallo. Sin embargo, el valor almacenado puede contener
     variables de patrón si se almacenó durante la unificación (véase
     @l(#4.4.4.4)). La coincidencia recursiva del patrón almacenado
     con los nuevos datos agregará o comprobará los enlaces para las variables
     en este patrón. Por ejemplo, supongamos que tenemos un marco en el que
     @c(?x) está vinculado @c[(f ?y)] y @c(?y) está desatado, @c(?x) Y deseamos
     aumentar este marco por una unión de a @c[(f b)]. Miramos hacia arriba
     @c(?x) y encontramos que está obligado a hacerlo @c[(f ?y)]. Esto nos lleva
     a coincidir @c[(f ?y)] con el nuevo valor propuesto @c[(f b)] en el mismo
     marco. Eventualmente este partido extiende el marco añadiendo un enlace de
     @c(?y) a @c(b). @c(?X) Sigue atado a @c[(f ?y)]. Nunca modificamos un
     enlace almacenado y nunca almacenamos más de un enlace para una variable
     dada.

#      The procedures used by @c(extend-if-consistent) to manipulate bindings are
#      defined in section @l(#4.4.4.8).
     Los procedimientos utilizados @c(extend-if-consistent) para manipular
     enlaces se definen en la seccion @l(#4.4.4.8).

# ***** Patterns with dotted tails
***** Patrones con colas punteadas

#       If a pattern contains a dot followed by a pattern variable, the pattern
#       variable matches the rest of the data list (rather than the next element of
#       the data list), just as one would expect with the dotted-tail notation
#       described in @l(#Exercise 2.20). Although the pattern matcher we have just
#       implemented doesn't look for dots, it does behave as we want. This is because
#       the Lisp @c(read) primitive, which is used by @c(query-driver-loop) to read
#       the query and represent it as a list structure, treats dots in a special way.
      Si un patrón contiene un punto seguido por una variable de patrón, la
      variable de patrón coincide con el resto de la lista de datos (en lugar
      del siguiente elemento de la lista de datos), tal como se esperaría con la
      notación de punteado descrita en el @l(#Ejercicio
      2.20). Aunque el marcador de patrones que acabamos de implementar no busca
      puntos, se comporta como queremos. Esto se debe a que la @c(read)
      primitiva Lisp, que es usada por @c(query-driver-loop) leer la consulta y
      representarla como una estructura de lista, trata los puntos de una manera
      especial.

#       When @c(read) sees a dot, instead of making the next item be the next element
#       of a list (the @c(car) of a @c(cons) whose @c(cdr) will be the rest of the
#       list) it makes the next item be the @c(cdr) of the list structure. For
#       example, the list structure produced by @c(read) for the pattern @c[(computer
#       ?type)] could be constructed by evaluating the expression @c[(cons 'computer
#       (cons '?type '()))], and that for @c[(computer . ?type)] could be constructed
#       by evaluating the expression @c[(cons 'computer '?type)].
      Cuando @c(read) ve un punto, en lugar de hacer que el siguiente elemento
      sea el siguiente elemento de una lista (el @c(car) de un @c(cons) cuyo
      @c(cdr) será el resto de la lista), hace que el siguiente elemento sea el
      @c(cdr) de la estructura de lista. Por ejemplo, la estructura de lista
      producida por @c(read) para el patrón se @c[(computer ?type)] podría
      construir evaluando la expresión @c[(cons 'computer (cons '?type '()))], y
      que para @c[(computer. ?type)] podría ser construida evaluando la
      expresión @c[(cons 'computer '?type)].

#       Thus, as @c(pattern-match) recursively compares @c(car)s and @c(cdr)s of a
#       data list and a pattern that had a dot, it eventually matches the variable
#       after the dot (which is a @c(cdr) of the pattern) against a sublist of the
#       data list, binding the variable to that list. For example, matching the
#       pattern @c[(computer . ?type)] against @c[(computer programmer trainee)] will
#       match @c(?type) against the list @c[(programmer trainee)].
      Así, al @c(pattern-match) comparar recursivamente @c(car) s y @c(cdr) s de
      una lista de datos y un patrón que tenía un punto, eventualmente coincide
      con la variable después del punto (que es uno @c(cdr) del patrón) contra
      una sublista de la lista de datos, vinculando la variable a esa lista. Por
      ejemplo, comparar el patrón @c[(computer. ?type)] contra @c[(computer
      programmer trainee)] coincidirá @c(?type) con la lista @c[(programmer
      trainee)].

# **** 4.4.4.4 <> Rules and Unification
**** 4.4.4.4 <> Reglas y Unificación

#      @c(Apply-rules) is the rule analog of @c(find-assertions) (section @l(#4.4.4.3)). It
#      takes as input a pattern and a frame, and it forms a stream of extension
#      frames by applying rules from the data base.  @c(Stream-flatmap) maps
#      @c(apply-a-rule) down the stream of possibly applicable rules (selected by
#      @c(fetch-rules), @l(#4.4.4.5)) and combines the resulting streams of frames.
     @c(Apply-rules) Es la regla análoga de @c(find-assertions)(
     @l(#4.4.4.3)). Toma como entrada un patrón y un marco, y forma un
     flujo de tramas de extensión aplicando reglas desde la base de datos.
     @c(Stream-flatmap) mapas @c(apply-a-rule) por la corriente de las normas
     aplicables, posiblemente, (seleccionado por @c(fetch-rules),
     @l(#4.4.4.5)) y combina las corrientes resultantes de los marcos.

#      ..src > scheme
#        (define (apply-rules pattern frame)
#          (stream-flatmap
#           (lambda (rule)
#             (apply-a-rule rule pattern frame))
#           (fetch-rules pattern frame)))
#      < src..
     ..src > scheme
       (define (apply-rules pattern frame)
         (stream-flatmap
          (lambda (rule)
            (apply-a-rule rule pattern frame))
          (fetch-rules pattern frame)))
     < src..

#      @c(Apply-a-rule) applies rules using the method outlined in section @l(#4.4.2). It
#      first augments its argument frame by unifying the rule conclusion with the
#      pattern in the given frame. If this succeeds, it evaluates the rule body in
#      this new frame.
     @c(Apply-a-rule) Aplica las reglas utilizando el método descrito en
     @l(#4.4.2). Primero aumenta su marco de argumentos unificando la
     conclusión de la regla con el patrón en el marco dado. Si esto tiene éxito,
     evalúa el cuerpo de la regla en este nuevo marco.

#      Before any of this happens, however, the program renames all the variables in
#      the rule with unique new names. The reason for this is to prevent the
#      variables for different rule applications from becoming confused with each
#      other. For instance, if two rules both use a variable named @c(?x), then each
#      one may add a binding for @c(?x) to the frame when it is applied.  These two
#      @c(?x)'s have nothing to do with each other, and we should not be fooled into
#      thinking that the two bindings must be consistent. Rather than rename
#      variables, we could devise a more clever environment structure; however, the
#      renaming approach we have chosen here is the most straightforward, even if not
#      the most efficient. (See @l(#Exercise 4.79).)  Here is the @c(apply-a-rule)
#      procedure:
     Sin embargo, antes de que esto suceda, el programa cambia el nombre de
     todas las variables de la regla con nombres nuevos únicos. La razón de esto
     es evitar que las variables para diferentes aplicaciones de reglas se
     confundan entre sí. Por ejemplo, si dos reglas utilizan una variable
     denominada @c(?x), cada una puede agregar una vinculación para @c(?x) el
     marco cuando se aplica. Estos dos @c(?x) no tienen nada que ver el uno con
     el otro, y no debemos dejarnos engañar pensando que los dos ataduras deben
     ser consistentes. En lugar de cambiar el nombre de las variables, podríamos
     diseñar una estructura de entorno más inteligente; Sin embargo, el enfoque
     de cambio de nombre que hemos elegido aquí es el más directo, incluso si no
     el más eficiente. (Véase el @l(#Ejercicio 4.79) .) Aquí está
     el procedimiento @c(apply-a-rule):

#      ..src > scheme
#        (define (apply-a-rule rule
#                              query-pattern
#                              query-frame)
#          (let ((clean-rule
#                 (rename-variables-in rule)))
#            (let ((unify-result
#                   (unify-match query-pattern
#                                (conclusion clean-rule)
#                                query-frame)))
#              (if (eq? unify-result 'failed)
#                  the-empty-stream
#                  (qeval (rule-body clean-rule)
#                         (singleton-stream
#                          unify-result))))))
#      < src..
     ..src > scheme
       (define (apply-a-rule rule
                             query-pattern
                             query-frame)
         (let ((clean-rule
                (rename-variables-in rule)))
           (let ((unify-result
                  (unify-match query-pattern
                               (conclusion clean-rule)
                               query-frame)))
             (if (eq? unify-result 'failed)
                 the-empty-stream
                 (qeval (rule-body clean-rule)
                        (singleton-stream
                         unify-result))))))
     < src..

#      The selectors @c(rule-body) and @c(conclusion) that extract parts of a rule
#      are defined in section @l(#4.4.4.7).
     Los selectores @c(rule-body) y @c(conclusion) que extraen partes de una
     regla se definen en la seccion @l(#4.4.4.7).

#      We generate unique variable names by associating a unique identifier (such as
#      a number) with each rule application and combining this identifier with the
#      original variable names. For example, if the rule-application identifier is 7,
#      we might change each @c(?x) in the rule to @c(?x-7) and each @c(?y) in the
#      rule to @c(?y-7). (@c(Make-new-variable) and @c(new-rule-application-id) are
#      included with the syntax procedures in section @l(#4.4.4.7).)
     Generamos nombres de variable únicos asociando un identificador único (como
     un número) con cada aplicación de regla y combinando este identificador con
     los nombres de variables originales. Por ejemplo, si el identificador de la
     aplicación de reglas es 7, podríamos cambiar cada uno @c(?x) en la regla
     @c(?x-7) y cada uno @c(?y) en la regla a @c(?y-7). (@c(Make-new-variable)
     Y @c(new-rule-application-id) se incluyen con los procedimientos de
     sintaxis en la seccion @l(#4.4.4.7) .)

#      ..src > scheme
#        (define (rename-variables-in rule)
#          (let ((rule-application-id
#                 (new-rule-application-id)))
#            (define (tree-walk exp)
#              (cond ((var? exp)
#                     (make-new-variable
#                      exp
#                      rule-application-id))
#                    ((pair? exp)
#                     (cons (tree-walk (car exp))
#                           (tree-walk (cdr exp))))
#                    (else exp)))
#            (tree-walk rule)))
#      < src..
     ..src > scheme
       (define (rename-variables-in rule)
         (let ((rule-application-id
                (new-rule-application-id)))
           (define (tree-walk exp)
             (cond ((var? exp)
                    (make-new-variable
                     exp
                     rule-application-id))
                   ((pair? exp)
                    (cons (tree-walk (car exp))
                          (tree-walk (cdr exp))))
                   (else exp)))
           (tree-walk rule)))
     < src..

#      The unification algorithm is implemented as a procedure that takes as inputs
#      two patterns and a frame and returns either the extended frame or the symbol
#      @c(failed). The unifier is like the pattern matcher except that it is
#      symmetrical––variables are allowed on both sides of the match.
#      @c(Unify-match) is basically the same as @c(pattern-match), except that there
#      is extra code (marked @"(@c(***)) below) to handle the case where the object
#      on the right side of the match is a variable.
     El algoritmo de unificación se implementa como un procedimiento que toma
     como entradas dos patrones y un marco y devuelve el marco extendido o el
     símbolo @c(failed). El unificador es como el matcher del patrón excepto que
     es simétrico - las variables se permiten en ambos lados del
     fósforo. @c(Unify-match) Es básicamente el mismo que @c(pattern-match),
     excepto que hay código adicional (marcado @"(@c(***)) debajo) para manejar
     el caso en el que el objeto en el lado derecho de la coincidencia es una
     variable.

#      ..src > scheme
#        (define (unify-match p1 p2 frame)
#          (cond ((eq? frame 'failed) 'failed)
#                ((equal? p1 p2) frame)
#                ((var? p1)
#                 (extend-if-possible p1 p2 frame))
#                ((var? p2)
#                 (extend-if-possible
#                  p2
#                  p1
#                  frame))        ; ***
#                ((and (pair? p1)
#                      (pair? p2))
#                 (unify-match
#                  (cdr p1)
#                  (cdr p2)
#                  (unify-match
#                   (car p1)
#                   (car p2)
#                   frame)))
#                (else 'failed)))
#      < src..
     ..src > scheme
       (define (unify-match p1 p2 frame)
         (cond ((eq? frame 'failed) 'failed)
               ((equal? p1 p2) frame)
               ((var? p1)
                (extend-if-possible p1 p2 frame))
               ((var? p2)
                (extend-if-possible
                 p2
                 p1
                 frame))        ; ***
               ((and (pair? p1)
                     (pair? p2))
                (unify-match
                 (cdr p1)
                 (cdr p2)
                 (unify-match
                  (car p1)
                  (car p2)
                  frame)))
               (else 'failed)))
     < src..

#      In unification, as in one-sided pattern matching, we want to accept a proposed
#      extension of the frame only if it is consistent with existing bindings. The
#      procedure @c(extend-if-possible) used in unification is the same as the
#      @c(extend-if-consistent) used in pattern matching except for two special
#      checks, marked @"(@c(***)) in the program below. In the first case, if the
#      variable we are trying to match is not bound, but the value we are trying to
#      match it with is itself a (different) variable, it is necessary to check to
#      see if the value is bound, and if so, to match its value. If both parties to
#      the match are unbound, we may bind either to the other.
     En la unificación, como en la coincidencia unilateral de patrones, queremos
     aceptar una extensión propuesta del marco sólo si es consistente con los
     enlaces existentes. El procedimiento @c(extend-if-possible) utilizado en la
     unificación es el mismo que el @c(extend-if-consistent) utilizado en la
     combinación de patrones, excepto en dos controles especiales, marcados
     @"(@c(***)) en el programa siguiente. En el primer caso, si la variable que
     estamos tratando de coincidir no está enlazada, pero el valor con el que
     tratamos de hacer coincidir es una variable (diferente), es necesario
     comprobar si el valor está enlazado y si Por lo tanto, para que coincida
     con su valor. Si ambas partes del partido no están unidas, podemos unirnos
     al otro.

#      The second check deals with attempts to bind a variable to a pattern that
#      includes that variable. Such a situation can occur whenever a variable is
#      repeated in both patterns. Consider, for example, unifying the two patterns
#      @c[(?x ?x)] and @c[(?y ⟨expression involving @c(?y)⟩)] in a frame where both
#      @c(?x) and @c(?y) are unbound. First @c(?x) is matched against @c(?y), making
#      a binding of @c(?x) to @c(?y). Next, the same @c(?x) is matched against the
#      given expression involving @c(?y).  Since @c(?x) is already bound to @c(?y),
#      this results in matching @c(?y) against the expression. If we think of the
#      unifier as finding a set of values for the pattern variables that make the
#      patterns the same, then these patterns imply instructions to find a @c(?y)
#      such that @c(?y) is equal to the expression involving @c(?y). There is no
#      general method for solving such equations, so we reject such bindings; these
#      cases are recognized by the predicate @c(depends-on?).@n(284) On the other
#      hand, we do not want to reject attempts to bind a variable to itself.  For
#      example, consider unifying @c[(?x ?x)] and @c[(?y ?y)]. The second attempt to
#      bind @c(?x) to @c(?y) matches @c(?y) (the stored value of @c(?x)) against
#      @c(?y) (the new value of @c(?x)). This is taken care of by the @c(equal?)
#      clause of @c(unify-match).
     La segunda verificación trata de los intentos de vincular una variable a un
     patrón que incluye esa variable. Tal situación puede ocurrir cada vez que
     una variable se repite en ambos patrones. Considere, por ejemplo, la
     unificación de los dos patrones @c[(?x ?x)] y en un marco donde ambos y no
     están unidos. En primer lugar se compara con, por lo que una unión de a. A
     continuación, se compara la misma con la expresión dada que implica. Dado
     que ya está vinculado a, esto resulta en la coincidencia con la
     expresión. Si pensamos en el unificador como encontrar un conjunto de
     valores para las variables de patrón que hacen que los patrones sean
     iguales, Entonces estos patrones implican instrucciones para encontrar un
     tal que sea igual a la expresión que implica. No existe un método general
     para resolver estas ecuaciones, por lo que rechazamos tales ataduras; Estos
     casos son reconocidos por el predicado.@n(284) Por otra parte, no
     queremos rechazar los intentos de obligar a una variable a sí mismo. Por
     ejemplo, considere unificar y. El segundo intento de vincular a
     coincidencias (el valor almacenado de ) contra (el nuevo valor de ). Esto
     es atendido por la cláusula de.@n(284) Por otra parte, no queremos
     rechazar los intentos de obligar a una variable a sí mismo. Por ejemplo,
     considere unificar y. El segundo intento de vincular a coincidencias (el
     valor almacenado de ) contra (el nuevo valor de ). Esto es atendido por la
     cláusula de.@n(284) Por otra parte, no queremos rechazar los
     intentos de obligar a una variable a sí mismo. Por ejemplo, considere
     unificar y. El segundo intento de vincular a coincidencias (el valor
     almacenado de ) contra (el nuevo valor de ). Esto es atendido por la
     cláusula de .@c[(?y ⟨expression involving
     @c(?y)⟩)]@c(?x)@c(?y)@c(?x)@c(?y)@c(?x)@c(?y)@c(?x)@c(?y)@c(?x)@c(?y)@c(?y)@c(?y)@c(?y)@c(?y)@c(depends-on?)@n(284)@c[(?x ?x)]@c[(?y
     ?y)]@c(?x)@c(?y)@c(?y)@c(?x)@c(?y)@c(?x)@c(equal?)@c(unify-match)

#      ..src > scheme
#        (define (extend-if-possible var val frame)
#          (let ((binding (binding-in-frame var frame)))
#            (cond (binding
#                   (unify-match
#                    (binding-value binding) val frame))
#                  ((var? val)                   ; ***
#                   (let ((binding
#                          (binding-in-frame
#                           val
#                           frame)))
#                     (if binding
#                         (unify-match
#                          var
#                          (binding-value binding)
#                          frame)
#                         (extend var val frame))))
#                  ((depends-on? val var frame)  ; ***
#                   'failed)
#                  (else (extend var val frame)))))
#      < src..
     ..src > scheme
       (define (extend-if-possible var val frame)
         (let ((binding (binding-in-frame var frame)))
           (cond (binding
                  (unify-match
                   (binding-value binding) val frame))
                 ((var? val)                   ; ***
                  (let ((binding
                         (binding-in-frame
                          val
                          frame)))
                    (if binding
                        (unify-match
                         var
                         (binding-value binding)
                         frame)
                        (extend var val frame))))
                 ((depends-on? val var frame)  ; ***
                  'failed)
                 (else (extend var val frame)))))
     < src..

#      @c(Depends-on?) is a predicate that tests whether an expression proposed to be
#      the value of a pattern variable depends on the variable. This must be done
#      relative to the current frame because the expression may contain occurrences
#      of a variable that already has a value that depends on our test variable. The
#      structure of @c(depends-on?) is a simple recursive tree walk in which we
#      substitute for the values of variables whenever necessary.
     @c(Depends-on?) Es un predicado que prueba si una expresión propuesta para
     ser el valor de una variable de patrón depende de la variable. Esto debe
     hacerse con relación a la trama actual porque la expresión puede contener
     las ocurrencias de una variable que ya tiene un valor que depende de
     nuestra variable de prueba. La estructura de @c(depends-on?) es una
     caminata recursiva simple del árbol en la cual substituimos los valores de
     variables siempre que sea necesario.

#      ..src > scheme
#        (define (depends-on? exp var frame)
#          (define (tree-walk e)
#            (cond ((var? e)
#                   (if (equal? var e)
#                       true
#                       (let
#                         ((b (binding-in-frame
#                              e
#                              frame)))
#                          (if b
#                              (tree-walk
#                               (binding-value b))
#                              false))))
#                  ((pair? e)
#                   (or (tree-walk (car e))
#                       (tree-walk (cdr e))))
#                  (else false)))
#          (tree-walk exp))
#      < src..
     ..src > scheme
       (define (depends-on? exp var frame)
         (define (tree-walk e)
           (cond ((var? e)
                  (if (equal? var e)
                      true
                      (let
                        ((b (binding-in-frame
                             e
                             frame)))
                         (if b
                             (tree-walk
                              (binding-value b))
                             false))))
                 ((pair? e)
                  (or (tree-walk (car e))
                      (tree-walk (cdr e))))
                 (else false)))
         (tree-walk exp))
     < src..

# **** 4.4.4.5 <> Maintaining the Data Base
**** 4.4.4.5 <> Mantenimiento de la base de datos

#      One important problem in designing logic programming languages is that of
#      arranging things so that as few irrelevant data-base entries as possible will
#      be examined in checking a given pattern. In our system, in addition to storing
#      all assertions in one big stream, we store all assertions whose @c(car)s are
#      constant symbols in separate streams, in a table indexed by the symbol. To
#      fetch an assertion that may match a pattern, we first check to see if the
#      @c(car) of the pattern is a constant symbol. If so, we return (to be tested
#      using the matcher) all the stored assertions that have the same @c(car). If
#      the pattern's @c(car) is not a constant symbol, we return all the stored
#      assertions. Cleverer methods could also take advantage of information in the
#      frame, or try also to optimize the case where the @c(car) of the pattern is
#      not a constant symbol. We avoid building our criteria for indexing (using the
#      @c(car), handling only the case of constant symbols) into the program; instead
#      we call on predicates and selectors that embody our criteria.
     Un problema importante en el diseño de lenguajes de programación lógica es
     el de organizar las cosas de modo que como pocos datos irrelevantes de
     entrada de datos como sea posible se examinará en la comprobación de un
     determinado patrón. En nuestro sistema, además de almacenar todas las
     aserciones en un gran flujo, almacenamos todas las aserciones cuyos @c(car)
     s son símbolos constantes en flujos separados, en una tabla indexada por el
     símbolo. Para buscar una aserción que pueda coincidir con un patrón,
     primero verificamos si @c(car) el patrón es un símbolo constante. Si es
     así, devolvemos (para ser probado usando el matcher) todas las aserciones
     almacenadas que tienen lo mismo @c(car). Si el patrón @c(car) no es un
     símbolo constante, devolvemos todas las aserciones almacenadas. Métodos más
     inteligentes también podrían aprovechar la información en el marco, @c(car)
     O tratar también de optimizar el caso en el que el del patrón no es un
     símbolo constante. Evitamos construir nuestros criterios para la indexación
     (usando el @c(car), manejando solamente el caso de símbolos constantes) en
     el programa; En lugar de eso llamamos predicados y selectores que
     incorporan nuestros criterios.

#      ..src > scheme
#        (define THE-ASSERTIONS the-empty-stream)
#
#        (define (fetch-assertions pattern frame)
#          (if (use-index? pattern)
#              (get-indexed-assertions pattern)
#              (get-all-assertions)))
#
#        (define (get-all-assertions) THE-ASSERTIONS)
#
#        (define (get-indexed-assertions pattern)
#          (get-stream (index-key-of pattern)
#                      'assertion-stream))
#      < src..
     ..src > scheme
       (define THE-ASSERTIONS the-empty-stream)

       (define (fetch-assertions pattern frame)
         (if (use-index? pattern)
             (get-indexed-assertions pattern)
             (get-all-assertions)))

       (define (get-all-assertions) THE-ASSERTIONS)

       (define (get-indexed-assertions pattern)
         (get-stream (index-key-of pattern)
                     'assertion-stream))
     < src..

#      @c(Get-stream) looks up a stream in the table and returns an empty stream if
#      nothing is stored there.
     @c(Get-stream) Busca una secuencia en la tabla y devuelve una secuencia
     vacía si no hay nada almacenado allí.

#      ..src > scheme
#        (define (get-stream key1 key2)
#          (let ((s (get key1 key2)))
#            (if s s the-empty-stream)))
#      < src..
     ..src > scheme
       (define (get-stream key1 key2)
         (let ((s (get key1 key2)))
           (if s s the-empty-stream)))
     < src..

#      Rules are stored similarly, using the @c(car) of the rule conclusion. Rule
#      conclusions are arbitrary patterns, however, so they differ from assertions in
#      that they can contain variables. A pattern whose @c(car) is a constant symbol
#      can match rules whose conclusions start with a variable as well as rules whose
#      conclusions have the same @c(car). Thus, when fetching rules that might match
#      a pattern whose @c(car) is a constant symbol we fetch all rules whose
#      conclusions start with a variable as well as those whose conclusions have the
#      same @c(car) as the pattern. For this purpose we store all rules whose
#      conclusions start with a variable in a separate stream in our table, indexed
#      by the symbol @c(?).
     Las reglas se almacenan de manera similar, utilizando @c(car) la regla de
     la conclusión. Las conclusiones de la regla son patrones arbitrarios, sin
     embargo, así que difieren de aserciones en que pueden contener
     variables. Un patrón cuyo @c(car) símbolo es constante puede coincidir con
     reglas cuyas conclusiones comienzan con una variable, así como reglas cuyas
     conclusiones tienen lo mismo @c(car). Por lo tanto, al buscar reglas que
     pueden coincidir con un patrón cuyo @c(car) símbolo es constante, buscamos
     todas las reglas cuyas conclusiones comienzan con una variable, así como
     aquellas cuyas conclusiones tienen el mismo @c(car) patrón. Para este
     propósito almacenamos todas las reglas cuyas conclusiones comienzan con una
     variable en un flujo separado en nuestra tabla, indexado por el símbolo
     @c(?).

#      ..src > scheme
#        (define THE-RULES the-empty-stream)
#
#        (define (fetch-rules pattern frame)
#          (if (use-index? pattern)
#              (get-indexed-rules pattern)
#              (get-all-rules)))
#
#        (define (get-all-rules) THE-RULES)
#
#        (define (get-indexed-rules pattern)
#          (stream-append
#           (get-stream (index-key-of pattern)
#                       'rule-stream)
#           (get-stream '? 'rule-stream)))
#      < src..
     ..src > scheme
       (define THE-RULES the-empty-stream)

       (define (fetch-rules pattern frame)
         (if (use-index? pattern)
             (get-indexed-rules pattern)
             (get-all-rules)))

       (define (get-all-rules) THE-RULES)

       (define (get-indexed-rules pattern)
         (stream-append
          (get-stream (index-key-of pattern)
                      'rule-stream)
          (get-stream '? 'rule-stream)))
     < src..

#      @c(Add-rule-or-assertion!) is used by @c(query-driver-loop) to add assertions
#      and rules to the data base. Each item is stored in the index, if appropriate,
#      and in a stream of all assertions or rules in the data base.
     @c(Add-rule-or-assertion!) Se utiliza @c(query-driver-loop) para añadir
     aserciones y reglas a la base de datos. Cada elemento se almacena en el
     índice, si es apropiado, y en un flujo de todas las aserciones o reglas en
     la base de datos.

#      ..src > scheme
#        (define (add-rule-or-assertion! assertion)
#          (if (rule? assertion)
#              (add-rule! assertion)
#              (add-assertion! assertion)))
#
#        (define (add-assertion! assertion)
#          (store-assertion-in-index assertion)
#          (let ((old-assertions THE-ASSERTIONS))
#            (set! THE-ASSERTIONS
#                  (cons-stream assertion
#                               old-assertions))
#            'ok))
#
#        (define (add-rule! rule)
#          (store-rule-in-index rule)
#          (let ((old-rules THE-RULES))
#            (set! THE-RULES
#                  (cons-stream rule old-rules))
#            'ok))
#      < src..
     ..src > scheme
       (define (add-rule-or-assertion! assertion)
         (if (rule? assertion)
             (add-rule! assertion)
             (add-assertion! assertion)))

       (define (add-assertion! assertion)
         (store-assertion-in-index assertion)
         (let ((old-assertions THE-ASSERTIONS))
           (set! THE-ASSERTIONS
                 (cons-stream assertion
                              old-assertions))
           'ok))

       (define (add-rule! rule)
         (store-rule-in-index rule)
         (let ((old-rules THE-RULES))
           (set! THE-RULES
                 (cons-stream rule old-rules))
           'ok))
     < src..

#      To actually store an assertion or a rule, we check to see if it can be
#      indexed.  If so, we store it in the appropriate stream.
     Para almacenar realmente una aserción o una regla, verificamos si se puede
     indexar. Si es así, lo almacenamos en el flujo adecuado.

#      ..src > scheme
#        (define (store-assertion-in-index assertion)
#          (if (indexable? assertion)
#              (let ((key (index-key-of assertion)))
#                (let ((current-assertion-stream
#                       (get-stream
#                        key 'assertion-stream)))
#                  (put key
#                       'assertion-stream
#                       (cons-stream
#                        assertion
#                        current-assertion-stream))))))
#
#        (define (store-rule-in-index rule)
#          (let ((pattern (conclusion rule)))
#            (if (indexable? pattern)
#                (let ((key (index-key-of pattern)))
#                  (let ((current-rule-stream
#                         (get-stream
#                          key 'rule-stream)))
#                    (put key
#                         'rule-stream
#                         (cons-stream
#                          rule
#                          current-rule-stream)))))))
#      < src..
     ..src > scheme
       (define (store-assertion-in-index assertion)
         (if (indexable? assertion)
             (let ((key (index-key-of assertion)))
               (let ((current-assertion-stream
                      (get-stream
                       key 'assertion-stream)))
                 (put key
                      'assertion-stream
                      (cons-stream
                       assertion
                       current-assertion-stream))))))

       (define (store-rule-in-index rule)
         (let ((pattern (conclusion rule)))
           (if (indexable? pattern)
               (let ((key (index-key-of pattern)))
                 (let ((current-rule-stream
                        (get-stream
                         key 'rule-stream)))
                   (put key
                        'rule-stream
                        (cons-stream
                         rule
                         current-rule-stream)))))))
     < src..

#      The following procedures define how the data-base index is used. A pattern (an
#      assertion or a rule conclusion) will be stored in the table if it starts with
#      a variable or a constant symbol.
     Los procedimientos siguientes definen cómo se utiliza el índice de base de
     datos. Un patrón (una aserción o una conclusión de la regla) se almacenará
     en la tabla si comienza con una variable o un símbolo constante.

#      ..src > scheme
#        (define (indexable? pat)
#          (or (constant-symbol? (car pat))
#              (var? (car pat))))
#      < src..
     ..src > scheme
       (define (indexable? pat)
         (or (constant-symbol? (car pat))
             (var? (car pat))))
     < src..

#      The key under which a pattern is stored in the table is either @c(?) (if it
#      starts with a variable) or the constant symbol with which it starts.
     La clave bajo la cual se almacena un patrón en la tabla es @c(?)(si empieza
     con una variable) o el símbolo constante con el que se inicia.

#      ..src > scheme
#        (define (index-key-of pat)
#          (let ((key (car pat)))
#            (if (var? key) '? key)))
#      < src..
     ..src > scheme
       (define (index-key-of pat)
         (let ((key (car pat)))
           (if (var? key) '? key)))
     < src..

#      The index will be used to retrieve items that might match a pattern if the
#      pattern starts with a constant symbol.
     El índice se utilizará para recuperar elementos que puedan coincidir con un
     patrón si el patrón comienza con un símbolo constante.

#      ..src > scheme
#        (define (use-index? pat)
#          (constant-symbol? (car pat)))
#      < src..
     ..src > scheme
       (define (use-index? pat)
         (constant-symbol? (car pat)))
     < src..

#      :: @t(Exercise 4.70) :: What is the purpose of the @c(let) bindings in the
#         procedures @c(add-assertion!) and @c(add-rule!)?  What would be wrong with
#         the following implementation of @c(add-assertion!)?  Hint: Recall the
#         definition of the infinite stream of ones in section @l(#3.5.2): @c[(define ones
#         (cons-stream 1 ones))].
     :: @t(Ejercicio 4.70) :: ¿Cuál es el propósito de los @c(let) enlaces en
        los procedimientos @c(add-assertion!) y @c(add-rule!)? ¿Qué estaría mal
        con la siguiente implementación de @c(add-assertion!)? Sugerencia:
        Recordemos la definición del flujo infinito de aquellas en
        @l(#3.5.2) : @c[(define ones (cons-stream 1 ones))].

#         ..src > scheme
#           (define (add-assertion! assertion)
#             (store-assertion-in-index assertion)
#             (set! THE-ASSERTIONS
#                   (cons-stream assertion
#                                THE-ASSERTIONS))
#             'ok)
#         < src..
        ..src > scheme
          (define (add-assertion! assertion)
            (store-assertion-in-index assertion)
            (set! THE-ASSERTIONS
                  (cons-stream assertion
                               THE-ASSERTIONS))
            'ok)
        < src..

# **** 4.4.4.6 <> Stream Operations
**** 4.4.4.6 <> Operaciones de flujo

#      The query system uses a few stream operations that were not presented in
#      @l(#Chapter 3).
     El sistema de consultas utiliza algunas operaciones de flujo que no se
     presentaron en el @l(#Capitulo 3).

#      @c(Stream-append-delayed) and @c(interleave-delayed) are just like
#      @c(stream-append) and @c(interleave) (section @l(#3.5.3)), except that they take a
#      delayed argument (like the @c(integral) procedure in section @l(#3.5.4)). This
#      postpones looping in some cases (see @l(#Exercise 4.71)).
     @c(Stream-append-delayed) Y @c(interleave-delayed) son como
     @c(stream-append) y @c(interleave)(seccion @l(#3.5.3)), excepto que toman
     un argumento retrasado (como el procedimiento @c(integral) en
     @l(#3.5.4)). Esto pospone el bucle en algunos casos (véase el
     @l(#Ejercicio 4.71) ).

#      ..src > scheme
#        (define (stream-append-delayed s1 delayed-s2)
#          (if (stream-null? s1)
#              (force delayed-s2)
#              (cons-stream
#               (stream-car s1)
#               (stream-append-delayed (stream-cdr s1)
#                                      delayed-s2))))
#
#        (define (interleave-delayed s1 delayed-s2)
#          (if (stream-null? s1)
#              (force delayed-s2)
#              (cons-stream
#               (stream-car s1)
#               (interleave-delayed
#                (force delayed-s2)
#                (delay (stream-cdr s1))))))
#      < src..
     ..src > scheme
       (define (stream-append-delayed s1 delayed-s2)
         (if (stream-null? s1)
             (force delayed-s2)
             (cons-stream
              (stream-car s1)
              (stream-append-delayed (stream-cdr s1)
                                     delayed-s2))))

       (define (interleave-delayed s1 delayed-s2)
         (if (stream-null? s1)
             (force delayed-s2)
             (cons-stream
              (stream-car s1)
              (interleave-delayed
               (force delayed-s2)
               (delay (stream-cdr s1))))))
     < src..

#      @c(Stream-flatmap), which is used throughout the query evaluator to map a
#      procedure over a stream of frames and combine the resulting streams of frames,
#      is the stream analog of the @c(flatmap) procedure introduced for ordinary
#      lists in section @l(#2.2.3). Unlike ordinary @c(flatmap), however, we accumulate the
#      streams with an interleaving process, rather than simply appending them (see
#      @l(#Exercise 4.72) and @l(#Exercise 4.73)).
     @c(Stream-flatmap), Que se utiliza en todo el evaluador de consultas para
     asignar un procedimiento sobre un flujo de tramas y combinar los flujos
     resultantes de tramas, es el análogo de flujo del procedimiento @c(flatmap)
     introducido para las listas ordinarias en la seccion @l(#2.2.3). @c(flatmap)
     Sin embargo, a diferencia de lo normal, acumulamos los flujos con un
     proceso de intercalación, en lugar de simplemente anexarlos (ver
     @l(#Ejercicio 4.72) y @l(#Ejercicio 4.73) ).

#      ..src > scheme
#        (define (stream-flatmap proc s)
#          (flatten-stream (stream-map proc s)))
#
#        (define (flatten-stream stream)
#          (if (stream-null? stream)
#              the-empty-stream
#              (interleave-delayed
#               (stream-car stream)
#               (delay (flatten-stream
#                       (stream-cdr stream))))))
#      < src..
     ..src > scheme
       (define (stream-flatmap proc s)
         (flatten-stream (stream-map proc s)))

       (define (flatten-stream stream)
         (if (stream-null? stream)
             the-empty-stream
             (interleave-delayed
              (stream-car stream)
              (delay (flatten-stream
                      (stream-cdr stream))))))
     < src..

#      The evaluator also uses the following simple procedure to generate a stream
#      consisting of a single element:
     El evaluador también utiliza el siguiente procedimiento simple para generar
     un flujo que consiste en un solo elemento:

#      ..src > scheme
#        (define (singleton-stream x)
#          (cons-stream x the-empty-stream))
#      < src..
     ..src > scheme
       (define (singleton-stream x)
         (cons-stream x the-empty-stream))
     < src..

# **** 4.4.4.7 <> Query Syntax Procedures
**** 4.4.4.7 <> Procedimientos de sintaxis de consulta

#      @c(Type) and @c(contents), used by @c(qeval) (section @l(#4.4.4.2)), specify that a
#      special form is identified by the symbol in its @c(car).  They are the same as
#      the @c(type-tag) and @c(contents) procedures in section @l(#2.4.2), except for the
#      error message.
     @c(Type) Y @c(contents), usado por @c(qeval)(seccion @l(#4.4.4.2)),
     especifica que una forma especial es identificada por el símbolo en su
     @c(car). Son los mismos que los procedimientos @c(type-tag) y @c(contents)
     en la seccion @l(#2.4.2), excepto para el mensaje de error.

#      ..src > scheme
#        (define (type exp)
#          (if (pair? exp)
#              (car exp)
#              (error "Unknown expression TYPE"
#                     exp)))
#
#        (define (contents exp)
#          (if (pair? exp)
#              (cdr exp)
#              (error "Unknown expression CONTENTS"
#                     exp)))
#      < src..
     ..src > scheme
       (define (type exp)
         (if (pair? exp)
             (car exp)
             (error "Unknown expression TYPE"
                    exp)))

       (define (contents exp)
         (if (pair? exp)
             (cdr exp)
             (error "Unknown expression CONTENTS"
                    exp)))
     < src..

#      The following procedures, used by @c(query-driver-loop) (in section @l(#4.4.4.1)),
#      specify that rules and assertions are added to the data base by expressions of
#      the form @c[(assert! ⟨rule-or-assertion⟩)]:
     Los siguientes procedimientos, utilizados por @c(query-driver-loop)(en
     @l(#4.4.4.1)), especifican que las reglas y aserciones se agregan
     a la base de datos mediante expresiones del formulario @c[(assert!
     ⟨rule-or-assertion⟩)]:

#      ..src > scheme
#        (define (assertion-to-be-added? exp)
#          (eq? (type exp) 'assert!))
#
#        (define (add-assertion-body exp)
#          (car (contents exp)))
#      < src..
     ..src > scheme
       (define (assertion-to-be-added? exp)
         (eq? (type exp) 'assert!))

       (define (add-assertion-body exp)
         (car (contents exp)))
     < src..

#      Here are the syntax definitions for the @c(and), @c(or), @c(not), and
#      @c(lisp-value) special forms (section @l(#4.4.4.2)):
     Aquí están las definiciones de sintaxis para los @c(and), @c(or), @c(not),
     y @c(lisp-value) formas especiales (seccion @l(#4.4.4.2)):

#      ..src > scheme
#        (define (empty-conjunction? exps) (null? exps))
#        (define (first-conjunct exps) (car exps))
#        (define (rest-conjuncts exps) (cdr exps))
#        (define (empty-disjunction? exps) (null? exps))
#        (define (first-disjunct exps) (car exps))
#        (define (rest-disjuncts exps) (cdr exps))
#        (define (negated-query exps) (car exps))
#        (define (predicate exps) (car exps))
#        (define (args exps) (cdr exps))
#      < src..
     ..src > scheme
       (define (empty-conjunction? exps) (null? exps))
       (define (first-conjunct exps) (car exps))
       (define (rest-conjuncts exps) (cdr exps))
       (define (empty-disjunction? exps) (null? exps))
       (define (first-disjunct exps) (car exps))
       (define (rest-disjuncts exps) (cdr exps))
       (define (negated-query exps) (car exps))
       (define (predicate exps) (car exps))
       (define (args exps) (cdr exps))
     < src..

#      The following three procedures define the syntax of rules:
     Los siguientes tres procedimientos definen la sintaxis de las reglas:

#      ..src > scheme
#        (define (rule? statement)
#          (tagged-list? statement 'rule))
#
#        (define (conclusion rule) (cadr rule))
#
#        (define (rule-body rule)
#          (if (null? (cddr rule))
#              '(always-true)
#              (caddr rule)))
#      < src..
     ..src > scheme
       (define (rule? statement)
         (tagged-list? statement 'rule))

       (define (conclusion rule) (cadr rule))

       (define (rule-body rule)
         (if (null? (cddr rule))
             '(always-true)
             (caddr rule)))
     < src..

#      @c(Query-driver-loop) (section @l(#4.4.4.1)) calls @c(query-syntax-process) to
#      transform pattern variables in the expression, which have the form
#      @c(?symbol), into the internal format @c[(? symbol)].  That is to say, a
#      pattern such as @c[(job ?x ?y)] is actually represented internally by the
#      system as @c[(job (? x) (? y))]. This increases the efficiency of query
#      processing, since it means that the system can check to see if an expression
#      is a pattern variable by checking whether the @c(car) of the expression is the
#      symbol @c(?), rather than having to extract characters from the symbol. The
#      syntax transformation is accomplished by the following procedure:@n(285)
     @c(Query-driver-loop)(seccion @l(#4.4.4.1)) @c(query-syntax-process)
     para transformar variables de patrón en la expresión, que tienen la forma
     @c(?symbol), en el formato interno @c[(? symbol)]. Es decir, un patrón tal
     como @c[(job ?x ?y)] está realmente representado internamente por el
     sistema como @c[(job (? x) (? y))]. Esto aumenta la eficiencia del
     procesamiento de consultas, ya que significa que el sistema puede comprobar
     si una expresión es una variable de patrón comprobando si la @c(car) de la
     expresión es el símbolo @c(?), en lugar de tener que extraer caracteres del
     símbolo. La transformación de sintaxis se realiza mediante el siguiente
     procedimiento:@n(285)

#      ..src > scheme
#        (define (query-syntax-process exp)
#          (map-over-symbols expand-question-mark exp))
#
#        (define (map-over-symbols proc exp)
#          (cond ((pair? exp)
#                 (cons (map-over-symbols
#                        proc (car exp))
#                       (map-over-symbols
#                        proc (cdr exp))))
#                ((symbol? exp) (proc exp))
#                (else exp)))
#
#        (define (expand-question-mark symbol)
#          (let ((chars (symbol->string symbol)))
#            (if (string=? (substring chars 0 1) "?")
#                (list '? (string->symbol
#                          (substring
#                           chars
#                           1
#                           (string-length chars))))
#                symbol)))
#      < src..
     ..src > scheme
       (define (query-syntax-process exp)
         (map-over-symbols expand-question-mark exp))

       (define (map-over-symbols proc exp)
         (cond ((pair? exp)
                (cons (map-over-symbols
                       proc (car exp))
                      (map-over-symbols
                       proc (cdr exp))))
               ((symbol? exp) (proc exp))
               (else exp)))

       (define (expand-question-mark symbol)
         (let ((chars (symbol->string symbol)))
           (if (string=? (substring chars 0 1) "?")
               (list '? (string->symbol
                         (substring
                          chars
                          1
                          (string-length chars))))
               symbol)))
     < src..

#      Once the variables are transformed in this way, the variables in a pattern are
#      lists starting with @c(?), and the constant symbols (which need to be
#      recognized for data-base indexing, @l(#4.4.4.5)) are just the symbols.
     Una vez que las variables se transforman de esta manera, las variables en
     un patrón son listas que comienzan con @c(?), y los símbolos constantes
     (que deben ser reconocidos para la indexación de la base de datos,
     @l(#4.4.4.5)) son sólo los símbolos.

#      ..src > scheme
#        (define (var? exp) (tagged-list? exp '?))
#        (define (constant-symbol? exp) (symbol? exp))
#      < src..
     ..src > scheme
       (define (var? exp) (tagged-list? exp '?))
       (define (constant-symbol? exp) (symbol? exp))
     < src..

#      Unique variables are constructed during rule application (in section @l(#4.4.4.4)) by
#      means of the following procedures. The unique identifier for a rule
#      application is a number, which is incremented each time a rule is applied.
     Las variables únicas se construyen durante la aplicación de la regla (en
     @l(#4.4.4.4)) por medio de los procedimientos siguientes. El
     identificador único para una aplicación de regla es un número, que se
     incrementa cada vez que se aplica una regla.

#      ..src > scheme
#        (define rule-counter 0)
#
#        (define (new-rule-application-id)
#          (set! rule-counter (+ 1 rule-counter))
#          rule-counter)
#
#        (define (make-new-variable
#                 var rule-application-id)
#          (cons '? (cons rule-application-id
#                         (cdr var))))
#      < src..
     ..src > scheme
       (define rule-counter 0)

       (define (new-rule-application-id)
         (set! rule-counter (+ 1 rule-counter))
         rule-counter)

       (define (make-new-variable
                var rule-application-id)
         (cons '? (cons rule-application-id
                        (cdr var))))
     < src..

#      When @c(query-driver-loop) instantiates the query to print the answer, it
#      converts any unbound pattern variables back to the right form for printing,
#      using
     Cuando @c(query-driver-loop) instancia la consulta para imprimir la
     respuesta, convierte cualquier variable de patrón no vinculado de nuevo en
     el formato correcto para imprimir, utilizando

#      ..src > scheme
#        (define (contract-question-mark variable)
#          (string->symbol
#           (string-append "?"
#             (if (number? (cadr variable))
#                 (string-append
#                  (symbol->string (caddr variable))
#                  "-"
#                  (number->string (cadr variable)))
#                 (symbol->string (cadr variable))))))
#      < src..
     ..src > scheme
       (define (contract-question-mark variable)
         (string->symbol
          (string-append "?"
            (if (number? (cadr variable))
                (string-append
                 (symbol->string (caddr variable))
                 "-"
                 (number->string (cadr variable)))
                (symbol->string (cadr variable))))))
     < src..

# **** 4.4.4.8 <> Frames and Bindings
**** 4.4.4.8 <> Marcos y fijaciones

#      Frames are represented as lists of bindings, which are variable-value pairs:
     Los marcos se representan como listas de enlaces, que son pares de valores
     variables:

#      ..src > scheme
#        (define (make-binding variable value)
#          (cons variable value))
#
#        (define (binding-variable binding)
#          (car binding))
#
#        (define (binding-value binding)
#          (cdr binding))
#
#        (define (binding-in-frame variable frame)
#          (assoc variable frame))
#
#        (define (extend variable value frame)
#          (cons (make-binding variable value) frame))
#      < src..
     ..src > scheme
       (define (make-binding variable value)
         (cons variable value))

       (define (binding-variable binding)
         (car binding))

       (define (binding-value binding)
         (cdr binding))

       (define (binding-in-frame variable frame)
         (assoc variable frame))

       (define (extend variable value frame)
         (cons (make-binding variable value) frame))
     < src..

#      :: @t(Exercise 4.71) :: Louis Reasoner wonders why the @c(simple-query) and
#         @c(disjoin) procedures (section @l(#4.4.4.2)) are implemented using explicit
#         @c(delay) operations, rather than being defined as follows:
     :: @t(Ejercicio 4.71) :: Louis Reasoner se pregunta por qué los
        procedimientos @c(simple-query) y @c(disjoin)(seccion @l(#4.4.4.2))
        se implementan mediante @c(delay) operaciones explícitas, en lugar de
        definirse como sigue:

#         ..src > scheme
#           (define (simple-query
#                    query-pattern frame-stream)
#             (stream-flatmap
#              (lambda (frame)
#                (stream-append
#                 (find-assertions query-pattern frame)
#                 (apply-rules query-pattern frame)))
#              frame-stream))
#
#           (define (disjoin disjuncts frame-stream)
#             (if (empty-disjunction? disjuncts)
#                 the-empty-stream
#                 (interleave
#                  (qeval (first-disjunct disjuncts)
#                         frame-stream)
#                  (disjoin (rest-disjuncts disjuncts)
#                           frame-stream))))
#         < src..
        ..src > scheme
          (define (simple-query
                   query-pattern frame-stream)
            (stream-flatmap
             (lambda (frame)
               (stream-append
                (find-assertions query-pattern frame)
                (apply-rules query-pattern frame)))
             frame-stream))

          (define (disjoin disjuncts frame-stream)
            (if (empty-disjunction? disjuncts)
                the-empty-stream
                (interleave
                 (qeval (first-disjunct disjuncts)
                        frame-stream)
                 (disjoin (rest-disjuncts disjuncts)
                          frame-stream))))
        < src..

#         Can you give examples of queries where these simpler definitions would lead
#         to undesirable behavior?
        ¿Puede dar ejemplos de consultas en las que estas definiciones más
        simples conducirían a un comportamiento indeseable?

#      :: @t(Exercise 4.72) :: Why do @c(disjoin) and @c(stream-flatmap) interleave
#         the streams rather than simply append them?  Give examples that illustrate
#         why interleaving works better. (Hint: Why did we use @c(interleave) in
#         @l(#3.5.3)?)
     :: @t(Ejercicio 4.72) :: ¿Por qué hacer @c(disjoin) y @c(stream-flatmap)
        entrelazar los arroyos en lugar de simplemente anexarlos? Dé ejemplos
        que ilustren por qué el entrelazado funciona mejor. (Sugerencia: ¿Por
        qué usamos @c(interleave) en la seccion @l(#3.5.3) ?)

#      :: @t(Exercise 4.73) :: Why does @c(flatten-stream) use @c(delay) explicitly?
#         What would be wrong with defining it as follows:
     :: @t(Ejercicio 4.73) :: ¿Por qué se @c(flatten-stream) utiliza @c(delay)
        explícitamente? ¿Qué sería incorrecto al definirlo de la siguiente manera:

#         ..src > scheme
#           (define (flatten-stream stream)
#             (if (stream-null? stream)
#                 the-empty-stream
#                 (interleave (stream-car stream)
#                             (flatten-stream
#                              (stream-cdr stream)))))
#         < src..
        ..src > scheme
          (define (flatten-stream stream)
            (if (stream-null? stream)
                the-empty-stream
                (interleave (stream-car stream)
                            (flatten-stream
                             (stream-cdr stream)))))
        < src..

#      :: @t(Exercise 4.74) :: Alyssa P. Hacker proposes to use a simpler version of
#         @c(stream-flatmap) in @c(negate), @c(lisp-value), and
#         @c(find-assertions). She observes that the procedure that is mapped over
#         the frame stream in these cases always produces either the empty stream or
#         a singleton stream, so no interleaving is needed when combining these
#         streams.
     :: @t(Ejercicio 4.74) :: Alyssa P. Hacker propone utilizar una versión más
        simple de @c(stream-flatmap) en @c(negate), @c(lisp-value) y
        @c(find-assertions). Observa que el procedimiento que se mapea sobre el
        flujo de trama en estos casos siempre produce el flujo vacío o un flujo
        simple, por lo que no se necesita entrelazado al combinar estos flujos.

#         1. Fill in the missing expressions in Alyssa's program.
        1. Rellena las expresiones que faltan en el programa de Alyssa.

#            ..src > scheme
#              (define (simple-stream-flatmap proc s)
#                (simple-flatten (stream-map proc s)))
#
#              (define (simple-flatten stream)
#                (stream-map ⟨??⟩
#                            (stream-filter ⟨??⟩
#                                           stream)))
#            < src..
           ..src > scheme
             (define (simple-stream-flatmap proc s)
               (simple-flatten (stream-map proc s)))

             (define (simple-flatten stream)
               (stream-map ⟨??⟩
                           (stream-filter ⟨??⟩
                                          stream)))
           < src..

#         2. Does the query system's behavior change if we change it in this way?
        2. ¿Cambia el comportamiento del sistema de consulta si lo cambiamos de
           esta manera?

#      :: @t(Exercise 4.75) :: Implement for the query language a new special form
#         called @c(unique). @c(Unique) should succeed if there is precisely one item
#         in the data base satisfying a specified query. For example,
     :: @t(Ejercicio 4.75) :: Implementar para el lenguaje de consulta un nuevo
        formulario especial llamado @c(unique). @c(Unique) Debe tener éxito si
        hay precisamente un elemento en la base de datos que satisface una
        consulta especificada. Por ejemplo,

#         ..src > scheme
#           (unique (job ?x (computer wizard)))
#         < src..
        ..src > scheme
          (unique (job ?x (computer wizard)))
        < src..

#         should print the one-item stream
        Debe imprimir la secuencia de un elemento

#         ..src > scheme
#           (unique (job (Bitdiddle Ben)
#                        (computer wizard)))
#         < src..
        ..src > scheme
          (unique (job (Bitdiddle Ben)
                       (computer wizard)))
        < src..

#         since Ben is the only computer wizard, and
        Ya que Ben es el único asistente de computadora, y

#         ..src > scheme
#           (unique (job ?x (computer programmer)))
#         < src..
        ..src > scheme
          (unique (job ?x (computer programmer)))
        < src..

#         should print the empty stream, since there is more than one computer
#         programmer. Moreover,
        Debe imprimir el flujo vacío, ya que hay más de un programador de
        computadora. Además,

#         ..src > scheme
#           (and (job ?x ?j)
#                (unique (job ?anyone ?j)))
#         < src..
        ..src > scheme
          (and (job ?x ?j)
               (unique (job ?anyone ?j)))
        < src..

#         should list all the jobs that are filled by only one person, and the people
#         who fill them.
        Debe enumerar todos los trabajos que son llenados por solamente una
        persona, y las personas que los llenan.

#         There are two parts to implementing @c(unique). The first is to write a
#         procedure that handles this special form, and the second is to make
#         @c(qeval) dispatch to that procedure. The second part is trivial, since
#         @c(qeval) does its dispatching in a data-directed way. If your procedure is
#         called @c(uniquely-asserted), all you need to do is
        Hay dos partes para implementar @c(unique). El primero es escribir un
        procedimiento que maneja este formulario especial, y el segundo es hacer
        el @c(qeval) envío a ese procedimiento. La segunda parte es trivial, ya
        @c(qeval) que su despacho en una forma dirigida a datos. Si se llama a
        su procedimiento @c(uniquely-asserted), todo lo que necesita hacer es

#         ..src > scheme
#           (put 'unique 'qeval uniquely-asserted)
#         < src..
        ..src > scheme
          (put 'unique 'qeval uniquely-asserted)
        < src..

#         and @c(qeval) will dispatch to this procedure for every query whose
#         @c(type) (@c(car)) is the symbol @c(unique).
        Y @c(qeval) enviará a este procedimiento para cada consulta cuyo
        @c(type)(@c(car)) es el símbolo @c(unique).

#         The real problem is to write the procedure @c(uniquely-asserted). This
#         should take as input the @c(contents) (@c(cdr)) of the @c(unique) query,
#         together with a stream of frames. For each frame in the stream, it should
#         use @c(qeval) to find the stream of all extensions to the frame that
#         satisfy the given query. Any stream that does not have exactly one item in
#         it should be eliminated. The remaining streams should be passed back to be
#         accumulated into one big stream that is the result of the @c(unique) query.
#         This is similar to the implementation of the @c(not) special form.
        El verdadero problema es escribir el procedimiento
        @c(uniquely-asserted). Esto debe tomar como entrada el @c(contents)(
        @c(cdr)) de la @c(unique) consulta, junto con una secuencia de
        marcos. Para cada trama en la secuencia, debe utilizar @c(qeval) para
        encontrar la secuencia de todas las extensiones a la trama que
        satisfacen la consulta dada. Cualquier flujo que no tenga exactamente un
        elemento en él debe ser eliminado. Los flujos restantes deben ser
        devueltos para ser acumulados en un flujo grande que es el resultado de
        la @c(unique) consulta. Esto es similar a la implementación de la
        @c(not) forma especial.

#         Test your implementation by forming a query that lists all people who
#         supervise precisely one person.
        Pruebe su implementación formando una consulta que enumera a todas las
        personas que supervisan exactamente a una persona.

#      :: @t(Exercise 4.76) :: Our implementation of @c(and) as a series combination
#         of queries (@l(#Figure 4.5)) is elegant, but it is inefficient because in
#         processing the second query of the @c(and) we must scan the data base for
#         each frame produced by the first query. If the data base has @m(n)
#         elements, and a typical query produces a number of output frames
#         proportional to @m(n) (say @m(n / k)), then scanning the data base for each
#         frame produced by the first query will require @m(n² / k) calls to the
#         pattern matcher. Another approach would be to process the two clauses of
#         the @c(and) separately, then look for all pairs of output frames that are
#         compatible. If each query produces @m(n / k) output frames, then this means
#         that we must perform @m(n² / k²) compatibility checks––a factor of @m(k)
#         fewer than the number of matches required in our current method.
     :: @t(Ejercicio 4.76) :: Nuestra implementación de @c(and) una serie de
        combinaciones de consultas (@l(#Figura 4.5) ) es elegante,
        pero es ineficiente porque en el procesamiento de la segunda consulta de
        la @c(and) debe escanear la base de datos para cada marco producido por
        la primera consulta. Si la base de datos tiene @m(n) elementos, y una
        consulta típica produce un número de cuadros de salida proporcionales a
        @m(n) (digamos @m(n / k) ), entonces escanear la base de datos para cada
        trama producida por la primera consulta requerirá @m(n² / k) llamadas al
        patrón Matcher Otro enfoque sería procesar las dos cláusulas de la por
        @c(and) separado, a continuación, buscar todos los pares de marcos de
        salida que son compatibles. Si cada consulta produce @m(n / k) tramas de
        salida,@m()@m()

#         Devise an implementation of @c(and) that uses this strategy. You must
#         implement a procedure that takes two frames as inputs, checks whether the
#         bindings in the frames are compatible, and, if so, produces a frame that
#         merges the two sets of bindings. This operation is similar to unification.
        Diseñar una implementación de la @c(and) que utiliza esta
        estrategia. Debe implementar un procedimiento que tome dos marcos como
        entradas, compruebe si los enlaces en los marcos son compatibles y, de
        ser así, produce un marco que fusiona los dos conjuntos de enlaces. Esta
        operación es similar a la unificación.

#      :: @t(Exercise 4.77) :: in section @l(#4.4.3) we saw that @c(not) and @c(lisp-value)
#         can cause the query language to give @"(wrong) answers if these filtering
#         operations are applied to frames in which variables are unbound. Devise a
#         way to fix this shortcoming. One idea is to perform the filtering in a
#         @"(delayed) manner by appending to the frame a @"(promise) to filter that
#         is fulfilled only when enough variables have been bound to make the
#         operation possible. We could wait to perform filtering until all other
#         operations have been performed. However, for efficiency's sake, we would
#         like to perform filtering as soon as possible so as to cut down on the
#         number of intermediate frames generated.
     :: @t(Ejercicio 4.77) :: en la seccion @l(#4.4.3) lo vimos @c(not) y
        @c(lisp-value) podemos hacer que el lenguaje de consulta dé respuestas
        @"(erróneas) si estas operaciones de filtrado se aplican a los
        fotogramas en los que las variables no están enlazadas. Diseñar una
        manera de solucionar este defecto. Una idea es realizar el filtrado de
        una manera @"(retrasada) añadiendo al marco una @"(promesa) de filtrar
        que se cumple sólo cuando se han obligado variables suficientes para
        hacer posible la operación. Podríamos esperar a realizar el filtrado
        hasta que se hayan realizado todas las otras operaciones. Sin embargo,
        por razones de eficiencia, queremos realizar el filtrado tan pronto como
        sea posible para reducir el número de tramas intermedias generadas.

#      :: @t(Exercise 4.78) :: Redesign the query language as a nondeterministic
#         program to be implemented using the evaluator of section @l(#4.3), rather than as a
#         stream process. In this approach, each query will produce a single answer
#         (rather than the stream of all answers) and the user can type @c(try-again)
#         to see more answers. You should find that much of the mechanism we built in
#         this section is subsumed by nondeterministic search and backtracking. You
#         will probably also find, however, that your new query language has subtle
#         differences in behavior from the one implemented here. Can you find
#         examples that illustrate this difference?
     :: @t(Ejercicio 4.78) :: Rediseñar el lenguaje de consulta como un programa
        no determinístico que se implementará utilizando el evaluador de
        @l(#4.3), en lugar de como un proceso de flujo. En este enfoque,
        cada consulta producirá una sola respuesta (en lugar de la secuencia de
        todas las respuestas) y el usuario puede escribir @c(try-again) para ver
        más respuestas. Debería descubrir que gran parte del mecanismo que
        construimos en esta sección está subsumido por la búsqueda no
        determinística y la retrotracción. Probablemente también encontrará, sin
        embargo, que su nuevo lenguaje de consulta tiene sutiles diferencias en
        el comportamiento de la implementada aquí. ¿Puedes encontrar ejemplos
        que ilustren esta diferencia?

#      :: @t(Exercise 4.79) :: When we implemented the Lisp evaluator in section @l(#4.1), we
#         saw how to use local environments to avoid name conflicts between the
#         parameters of procedures. For example, in evaluating
     :: @t(Ejercicio 4.79) :: Cuando implementamos el evaluador Lisp en
        @l(#4.1), vimos cómo usar los entornos locales para evitar
        conflictos de nombres entre los parámetros de los procedimientos. Por
        ejemplo, al evaluar

#         ..src > scheme
#           (define (square x)
#             (* x x))
#
#           (define (sum-of-squares x y)
#             (+ (square x) (square y)))
#
#           (sum-of-squares 3 4)
#         < src..
        ..src > scheme
          (define (square x)
            (* x x))

          (define (sum-of-squares x y)
            (+ (square x) (square y)))

          (sum-of-squares 3 4)
        < src..

#         there is no confusion between the @c(x) in @c(square) and the @c(x) in
#         @c(sum-of-squares), because we evaluate the body of each procedure in an
#         environment that is specially constructed to contain bindings for the local
#         variables. In the query system, we used a different strategy to avoid name
#         conflicts in applying rules. Each time we apply a rule we rename the
#         variables with new names that are guaranteed to be unique. The analogous
#         strategy for the Lisp evaluator would be to do away with local environments
#         and simply rename the variables in the body of a procedure each time we
#         apply the procedure.
        No hay confusión entre el @c(x) in @c(square) y el @c(x) in
        @c(sum-of-squares), porque evaluamos el cuerpo de cada procedimiento en
        un entorno que está especialmente construido para contener enlaces para
        las variables locales. En el sistema de consultas, utilizamos una
        estrategia diferente para evitar conflictos de nombres al aplicar las
        reglas. Cada vez que aplicamos una regla, cambiamos el nombre de las
        variables con nombres nuevos que se garantizan que son únicos. La
        estrategia análoga para el evaluador Lisp sería acabar con los entornos
        locales y simplemente cambiar el nombre de las variables en el cuerpo de
        un procedimiento cada vez que apliquemos el procedimiento.

#         Implement for the query language a rule-application method that uses
#         environments rather than renaming. See if you can build on your environment
#         structure to create constructs in the query language for dealing with large
#         systems, such as the rule analog of block-structured procedures. Can you
#         relate any of this to the problem of making deductions in a context (e.g.,
#         @"(If I supposed that @m(P) were true, then I would be able to deduce @m(a)
#         and @m(B).)) as a method of problem solving?  (This problem is
#         open-ended. A good answer is probably worth a Ph.D.)
        Implementar para el lenguaje de consulta un método de aplicación de
        reglas que utiliza los entornos en lugar de cambiar el nombre. Vea si
        puede construir en su estructura de entorno para crear construcciones en
        el lenguaje de consulta para tratar con sistemas grandes, como la regla
        análoga de los procedimientos estructurados en bloques. Puede usted se
        relaciona todo esto con el problema de las retenciones en un contexto
        (por ejemplo, @"(si se supone que @m(P) fuera cierto, entonces yo sería
        capaz de deducir @m(a) y @m(B) .) ) Como método de resolución de
        problemas? (Este problema es de duración indefinida, una buena respuesta
        probablemente valga la pena un Ph.D.)

# * Chapter 5 <> Computing with Register Machines
* Capitulo 5 <> Informática con máquinas registradoras

#   ..quote >
  ..quote >
#     My aim is to show that the heavenly machine is not a kind of divine, live
#     being, but a kind of clockwork (and he who believes that a clock has soul
#     attributes the maker's glory to the work), insofar as nearly all the
#     manifold motions are caused by a most simple and material force, just as all
#     motions of the clock are caused by a single weight.
    Mi objetivo es mostrar que la máquina celestial no es una especie de ser
    divino, vivo, sino una especie de reloj (y el que cree que un reloj tiene
    atributos del alma la gloria del creador a la obra), en la medida en que
    casi todos los movimientos múltiples Son causadas por una fuerza más simple
    y material, así como todos los movimientos del reloj son causados por un
    solo peso.

#     --Johannes Kepler (letter to Herwart von Hohenburg, 1605)
    --Johannes Kepler (carta a Herwart von Hohenburg, 1605)
#   < quote..
  < quote..


#   We began this book by studying processes and by describing processes in terms
#   of procedures written in Lisp. To explain the meanings of these procedures, we
#   used a succession of models of evaluation: the substitution model of
#   @l(#Chapter 1), the environment model of @l(#Chapter 3), and the metacircular
#   evaluator of @l(#Chapter 4). Our examination of the metacircular evaluator, in
#   particular, dispelled much of the mystery of how Lisp-like languages are
#   interpreted. But even the metacircular evaluator leaves important questions
#   unanswered, because it fails to elucidate the mechanisms of control in a Lisp
#   system. For instance, the evaluator does not explain how the evaluation of a
#   subexpression manages to return a value to the expression that uses this
#   value, nor does the evaluator explain how some recursive procedures generate
#   iterative processes (that is, are evaluated using constant space) whereas
#   other recursive procedures generate recursive processes. These questions
#   remain unanswered because the metacircular evaluator is itself a Lisp program
#   and hence inherits the control structure of the underlying Lisp system. In
#   order to provide a more complete description of the control structure of the
#   Lisp evaluator, we must work at a more primitive level than Lisp itself.
  Comenzamos este libro estudiando procesos y describiendo procesos en términos
  de procedimientos escritos en Lisp. Para explicar los significados de estos
  procedimientos, se utilizó una sucesión de modelos de evaluación: el modelo de
  sustitución del @l(Capitulo 1), el modelo ambiental del
  @l(#Capitulo 3) y el evaluador metacircular del
  @l(Capitulo 4). Nuestro examen del evaluador metacircular, en
  particular, disipó gran parte del misterio de cómo se interpretan las lenguas
  de tipo Lisp. Pero incluso el evaluador metacircular deja preguntas
  importantes sin respuesta, porque no logra dilucidar los mecanismos de control
  en un sistema Lisp. Por ejemplo, el evaluador no explica cómo la evaluación de
  una subexpresión consigue devolver un valor a la expresión que utiliza este
  valor, Ni el evaluador explica cómo algunos procedimientos recursivos generan
  procesos iterativos (es decir, se evalúan utilizando un espacio constante)
  mientras que otros procedimientos recursivos generan procesos
  recursivos. Estas preguntas siguen sin respuesta porque el evaluador
  metacircular es en sí mismo un programa Lisp y por lo tanto hereda la
  estructura de control del sistema Lisp subyacente. Con el fin de proporcionar
  una descripción más completa de la estructura de control del evaluador Lisp,
  debemos trabajar en un nivel más primitivo que el propio Lisp.

#   In this chapter we will describe processes in terms of the step-by-step
#   operation of a traditional computer. Such a computer, or @e(register machine),
#   sequentially executes @e(instructions) that manipulate the contents of a fixed
#   set of storage elements called @e(registers). A typical register-machine
#   instruction applies a primitive operation to the contents of some registers
#   and assigns the result to another register. Our descriptions of processes
#   executed by register machines will look very much like @"(machine-language)
#   programs for traditional computers. However, instead of focusing on the
#   machine language of any particular computer, we will examine several Lisp
#   procedures and design a specific register machine to execute each
#   procedure. Thus, we will approach our task from the perspective of a hardware
#   architect rather than that of a machine-language computer programmer. In
#   designing register machines, we will develop mechanisms for implementing
#   important programming constructs such as recursion. We will also present a
#   language for describing designs for register machines. in section @l(#5.2) we will
#   implement a Lisp program that uses these descriptions to simulate the machines
#   we design.
  En este capítulo describiremos los procesos en términos de la operación paso a
  paso de un ordenador tradicional. Tal ordenador, o @e(máquina registradora),
  ejecuta secuencialmente @e(instrucciones) que manipulan el contenido de un
  conjunto fijo de elementos de almacenamiento llamados @e(registros). Una
  instrucción típica de registro-máquina aplica una operación primitiva al
  contenido de algunos registros y asigna el resultado a otro registro. Nuestras
  descripciones de los procesos ejecutados por las máquinas registradoras se
  parecerán mucho a @"(los) programas en @"(lenguaje máquina) para las
  computadoras tradicionales. Sin embargo, en lugar de centrarse en el lenguaje
  de máquina de cualquier computadora en particular, examinaremos varios
  procedimientos de Lisp y diseñaremos una máquina de registro específica para
  ejecutar cada procedimiento. Así, Nos acercaremos a nuestra tarea desde la
  perspectiva de un arquitecto de hardware en lugar de la de un programador de
  computadoras en lenguaje máquina. En el diseño de máquinas registradoras,
  desarrollaremos mecanismos para implementar importantes construcciones de
  programación como la recursión. También presentaremos un lenguaje para
  describir diseños para máquinas de registro. @l(#5.2<>En 5.2) implementaremos
  un programa Lisp que usa estas descripciones para simular las máquinas que
  diseñamos.

#   Most of the primitive operations of our register machines are very simple. For
#   example, an operation might add the numbers fetched from two registers,
#   producing a result to be stored into a third register. Such an operation can
#   be performed by easily described hardware. In order to deal with list
#   structure, however, we will also use the memory operations @c(car), @c(cdr),
#   and @c(cons), which require an elaborate storage-allocation mechanism. In
#   @l(#5.3) we study their implementation in terms of more elementary operations.
  La mayoría de las operaciones primitivas de nuestras máquinas registradoras
  son muy simples. Por ejemplo, una operación puede agregar los números
  obtenidos de dos registros, produciendo un resultado que se almacenará en un
  tercer registro. Una operación de este tipo puede realizarse mediante hardware
  fácilmente descrito. Con el fin de hacer frente a la estructura de lista, sin
  embargo, vamos a utilizar también las operaciones de memoria @c(car), @c(cdr)
  y @c(cons), que requieren un mecanismo de almacenamiento de asignación
  elaborado. en la seccion @l(#5.3) estudiamos su implementación en términos de
  operaciones más elementales.

#   in section @l(#5.4), after we have accumulated experience formulating simple
#   procedures as register machines, we will design a machine that carries out the
#   algorithm described by the metacircular evaluator of section @l(#4.1). This will fill
#   in the gap in our understanding of how Scheme expressions are interpreted, by
#   providing an explicit model for the mechanisms of control in the evaluator. In
#   @l(#5.5) we will study a simple compiler that translates Scheme programs into
#   sequences of instructions that can be executed directly with the registers and
#   operations of the evaluator register machine.
  en la seccion @l(#5.4), después de haber acumulado experiencia formulando
  procedimientos simples como máquinas registradoras, diseñaremos una máquina
  que realice el algoritmo descrito por el evaluador metacircular de
  @l(#4.1). Esto llenará la brecha en nuestra comprensión de cómo se
  interpretan las expresiones del Scheme, proporcionando un modelo explícito
  para los mecanismos de control en el evaluador. en la seccion @l(#5.5) estudiaremos
  un compilador simple que traducirá los programas Scheme en secuencias de
  instrucciones que se pueden ejecutar directamente con los registros y
  operaciones de la máquina de registro de evaluadores.

# ** 5.1 <> Designing Register Machines
** 5.1 <> Diseño de máquinas de registro

#    To design a register machine, we must design its @e(data paths) (registers and
#    operations) and the @e(controller) that sequences these operations. To
#    illustrate the design of a simple register machine, let us examine Euclid's
#    Algorithm, which is used to compute the greatest common divisor (@A(GCD)) of
#    two integers. As we saw in section @l(#1.2.5), Euclid's Algorithm can be carried out
#    by an iterative process, as specified by the following procedure:
   Para diseñar una máquina de registro, debemos diseñar sus @e(rutas de datos)
   (registros y operaciones) y el @e(controlador) que secuencias de estas
   operaciones. Para ilustrar el diseño de una máquina de registro simple,
   examinemos el Algoritmo de Euclides, que se utiliza para calcular el mayor
   divisor común (@A(GCD) ) de dos enteros. Como vimos en la seccion @l(#1.2.5), el
   Algoritmo de Euclides puede ser llevado a cabo por un proceso iterativo, como
   se especifica por el siguiente procedimiento:

#    ..src > scheme
#      (define (gcd a b)
#        (if (= b 0)
#            a
#            (gcd b (remainder a b))))
#    < src..
   ..src > scheme
     (define (gcd a b)
       (if (= b 0)
           a
           (gcd b (remainder a b))))
   < src..

#    A machine to carry out this algorithm must keep track of two numbers, @m(a)
#    and @m(b), so let us assume that these numbers are stored in two registers
#    with those names. The basic operations required are testing whether the
#    contents of register @c(b) is zero and computing the remainder of the contents
#    of register @c(a) divided by the contents of register @c(b). The remainder
#    operation is a complex process, but assume for the moment that we have a
#    primitive device that computes remainders. On each cycle of the @A(GCD)
#    algorithm, the contents of register @c(a) must be replaced by the contents of
#    register @c(b), and the contents of @c(b) must be replaced by the remainder of
#    the old contents of @c(a) divided by the old contents of @c(b). It would be
#    convenient if these replacements could be done simultaneously, but in our
#    model of register machines we will assume that only one register can be
#    assigned a new value at each step. To accomplish the replacements, our machine
#    will use a third @"(temporary) register, which we call @c(t). (First the
#    remainder will be placed in @c(t), then the contents of @c(b) will be placed
#    in @c(a), and finally the remainder stored in @c(t) will be placed in @c(b).)
   Una máquina para llevar a cabo este algoritmo debe realizar un seguimiento de
   dos números, @m(a) y @m(B), así que vamos a suponer que estos números se
   almacenan en dos registros con esos nombres. Las operaciones básicas
   requeridas son probar si el contenido del registro @c(b) es cero y calcular
   el resto del contenido del registro @c(a) dividido por el contenido del
   registro @c(b). La operación restante es un proceso complejo, pero asumimos
   por el momento que tenemos un dispositivo primitivo que calcula los
   restos. En cada ciclo del algoritmo @A(GCD), el contenido de registro @c(a)
   debe ser reemplazado por el contenido de registro @c(b), y el contenido de
   @c(b) debe ser reemplazado por el resto del contenido antiguo de @c(a)
   dividido por el contenido antiguo de @c(b). Sería conveniente que estos
   reemplazos pudieran realizarse simultáneamente, pero en nuestro modelo de
   máquinas de registro asumiremos que sólo un registro puede tener asignado un
   nuevo valor en cada paso. Para realizar los reemplazos, nuestra máquina
   utilizará un tercer registro @"(temporal), al que llamamos @c(t). (Primera el
   resto se coloca en @c(t), a continuación, el contenido de @c(b) se colocará
   en @c(a), y finalmente el resto almacenado en @c(t) será colocado en @c(b).)

#    We can illustrate the registers and operations required for this machine by
#    using the data-path diagram shown in @l(#Figure 5.1). In this diagram, the
#    registers (@c(a), @c(b), and @c(t)) are represented by rectangles.  Each way
#    to assign a value to a register is indicated by an arrow with an @c(X) behind
#    the head, pointing from the source of data to the register. We can think of
#    the @c(X) as a button that, when pushed, allows the value at the source to
#    @"(flow) into the designated register. The label next to each button is the
#    name we will use to refer to the button. The names are arbitrary, and can be
#    chosen to have mnemonic value (for example, @c(a<-b) denotes pushing the
#    button that assigns the contents of register @c(b) to register @c(a)). The
#    source of data for a register can be another register (as in the @c(a<-b)
#    assignment), an operation result (as in the @c(t<-r) assignment), or a
#    constant (a built-in value that cannot be changed, represented in a data-path
#    diagram by a triangle containing the constant).
   Podemos ilustrar los registros y operaciones requeridos para esta máquina
   usando el diagrama de ruta de datos mostrado en la @l(#Figura
   5.1). En este diagrama, los registros (@c(a), @c(b), y @c(t)) están
   representadas por rectángulos. Cada forma de asignar un valor a un registro
   se indica mediante una flecha con un @c(X) detrás de la cabeza, apuntando
   desde la fuente de datos al registro. Podemos pensar en el @c(X) como un
   botón que, cuando se empuja, permite que el valor en la fuente @"(fluya)
   hacia el registro designado. La etiqueta al lado de cada botón es el nombre
   que usaremos para referirnos al botón. Los nombres son arbitrarios y pueden
   ser elegidos para tener un valor mnemotécnico (por ejemplo, @c(a<-b)
   indica empujar el botón que asigna el contenido del registro @c(b) para
   registrarse @c(a)).@c(a<-b)@c(t<-r)

#    ..figure > @t(Figure 5.1) Data paths for a @A(GCD) machine.
   ..figure > @t(Figura 5.1 Rutas de) datos para una máquina @A(GCD).

#      ..art >
#                                      ___
#        ╭─────╮          ╭─────╮     ╱   ╲
#        │  a  │◀──(X)────│  b  ├───▶(  =  )
#        ╰──┬──╯   a←b    ╰─┬───╯     ╲___╱
#           │               │  ▲        ▲
#           ╰──────╮   ╭────╯  │        │
#                  ▼   ▼      (X) b←t   │
#               .─────────.    │       ╱ ╲
#                ╲  rem  ╱     │      ╱ O ╲
#                 ╲_____╱      │     '─────'
#                    │         │
#                   (X) t←r    │
#                    │         │
#                    ▼         │
#                 ╭─────╮      │
#                 │  t  +──────╯
#                 ╰─────╯
#      < art..
     ..art >
                                     ___
       ╭─────╮          ╭─────╮     ╱   ╲
       │  a  │◀──(X)────│  b  ├───▶(  =  )
       ╰──┬──╯   a←b    ╰─┬───╯     ╲___╱
          │               │  ▲        ▲
          ╰──────╮   ╭────╯  │        │
                 ▼   ▼      (X) b←t   │
              .─────────.    │       ╱ ╲
               ╲  rem  ╱     │      ╱ O ╲
                ╲_____╱      │     '─────'
                   │         │
                  (X) t←r    │
                   │         │
                   ▼         │
                ╭─────╮      │
                │  t  +──────╯
                ╰─────╯
     < art..

# @  ..img > img/chap5/Fig5.1a.std.svg
@  ..img > img/chap5/Fig5.1a.std.svg

#    An operation that computes a value from constants and the contents of
#    registers is represented in a data-path diagram by a trapezoid containing a
#    name for the operation. For example, the box marked @c(rem) in @l(#Figure 5.1)
#    represents an operation that computes the remainder of the contents of the
#    registers @c(a) and @c(b) to which it is attached. Arrows (without buttons)
#    point from the input registers and constants to the box, and arrows connect
#    the operation's output value to registers. A test is represented by a circle
#    containing a name for the test. For example, our @A(GCD) machine has an
#    operation that tests whether the contents of register @c(b) is zero.  A test
#    also has arrows from its input registers and constants, but it has no output
#    arrows; its value is used by the controller rather than by the data
#    paths. Overall, the data-path diagram shows the registers and operations that
#    are required for the machine and how they must be connected. If we view the
#    arrows as wires and the @c(X) buttons as switches, the data-path diagram is
#    very like the wiring diagram for a machine that could be constructed from
#    electrical components.
   Una operación que calcula un valor a partir de constantes y el contenido de
   registros se representa en un diagrama de ruta de datos por un trapezoide que
   contiene un nombre para la operación. Por ejemplo, la casilla marcada @c(rem)
   en la @l(#Figura 5.1) representa una operación que calcula el
   resto del contenido de los registros @c(a) ya los @c(b) que está
   conectado. Las flechas (sin botones) apuntan desde los registros de entrada y
   las constantes hasta el cuadro, y las flechas conectan el valor de salida de
   la operación a los registros. Una prueba está representada por un círculo que
   contiene un nombre para la prueba. Por ejemplo, nuestra máquina @A(GCD) tiene
   una operación que prueba si el contenido del registro @c(b) es cero. Una
   prueba también tiene flechas de sus registros de entrada y constantes, pero
   no tiene flechas de salida; Su valor es utilizado por el controlador en lugar
   de por las rutas de datos. En general, el diagrama de ruta de datos muestra
   los registros y operaciones que se requieren para la máquina y cómo deben
   conectarse. @c(X) Si vemos las flechas como cables y los botones como
   interruptores, el diagrama de la trayectoria de datos es muy parecido al
   diagrama de cableado de una máquina que podría construirse a partir de
   componentes eléctricos.

#    In order for the data paths to actually compute @A(GCD)s, the buttons must be
#    pushed in the correct sequence. We will describe this sequence in terms of a
#    controller diagram, as illustrated in @l(#Figure 5.2). The elements of the
#    controller diagram indicate how the data-path components should be
#    operated. The rectangular boxes in the controller diagram identify data-path
#    buttons to be pushed, and the arrows describe the sequencing from one step to
#    the next. The diamond in the diagram represents a decision. One of the two
#    sequencing arrows will be followed, depending on the value of the data-path
#    test identified in the diamond. We can interpret the controller in terms of a
#    physical analogy: Think of the diagram as a maze in which a marble is
#    rolling. When the marble rolls into a box, it pushes the data-path button that
#    is named by the box. When the marble rolls into a decision node (such as the
#    test for @c(b) = 0), it leaves the node on the path determined by the result
#    of the indicated test. Taken together, the data paths and the controller
#    completely describe a machine for computing @A(GCD)s. We start the controller
#    (the rolling marble) at the place marked @c(start), after placing numbers in
#    registers @c(a) and @c(b). When the controller reaches @c(done), we will find
#    the value of the @A(GCD) in register @c(a).
   Para que las rutas de datos calculen realmente @A(GCD) s, los botones deben
   ser empujados en la secuencia correcta. Describiremos esta secuencia en
   términos de un diagrama de controlador, como se ilustra en la
   @l(#Figura 5.2). Los elementos del diagrama del controlador
   indican cómo se deben operar los componentes de la ruta de datos. Las
   casillas rectangulares del diagrama del controlador identifican los botones
   de ruta de datos que se deben empujar y las flechas describen la secuencia de
   un paso al siguiente. El diamante en el diagrama representa una decisión. Se
   seguirá una de las dos flechas de secuenciación, dependiendo del valor de la
   prueba de trayectoria de datos identificada en el diamante. Podemos
   interpretar al controlador en términos de una analogía física: Piense en el
   diagrama como un laberinto en el que un mármol está rodando. Cuando el mármol
   rueda en una caja, Empuja el botón de ruta de datos que se denomina por el
   cuadro. @c(b) Cuando el mármol rueda en un nodo de decisión (tal como la
   prueba para = 0), deja al nodo en la trayectoria determinada por el resultado
   de la prueba indicada. En conjunto, las rutas de datos y el controlador
   describen completamente una máquina para calcular @A(GCD) s. Iniciamos el
   controlador (el mármol rodante) en el lugar marcado @c(start), después de
   colocar los números en los registros @c(a) y @c(b). Cuando el controlador
   alcance @c(done), encontraremos el valor del @A(GCD) en el registro
   @c(a). @A(Las rutas de datos y el controlador describen completamente una
   máquina para calcular GCD) s. Iniciamos el controlador (el mármol rodante) en
   el lugar marcado, después de colocar los números en los registros y. Cuando
   el controlador alcance, encontraremos el valor del @A(GCD) en el
   registro. @A(Las rutas de datos y el controlador describen completamente una
   máquina para calcular GCD) s. Iniciamos el controlador (el mármol rodante) en
   el lugar marcado, después de colocar los números en los registros y. Cuando
   el controlador alcance, encontraremos el valor del @A(GCD) en el registro.

#    ..figure > @t(Figure 5.2) Controller for a @A(GCD) machine.
   ..figure > @t(Figura 5.2) Controlador para una máquina @A(GCD).

#      ..art >
#             start
#               │
#               ▼
#              ╱ ╲  no   ╭─────╮
#        ╭───▶( = )─────▶│ t←r │
#        │     ╲ ╱       ╰──┬──╯
#        │      │           │
#        │      │ yes       ▼
#        │      ▼        ╭─────╮
#        │     done      │ a←b │
#        │               ╰──┬──╯
#        │                  │
#        │                  ▼
#        │               ╭─────╮
#        ╰───────────────┤ b←t │
#                        ╰─────╯
#      < art..
     ..art >
            start
              │
              ▼
             ╱ ╲  no   ╭─────╮
       ╭───▶( = )─────▶│ t←r │
       │     ╲ ╱       ╰──┬──╯
       │      │           │
       │      │ yes       ▼
       │      ▼        ╭─────╮
       │     done      │ a←b │
       │               ╰──┬──╯
       │                  │
       │                  ▼
       │               ╭─────╮
       ╰───────────────┤ b←t │
                       ╰─────╯
     < art..

# @  ..img > img/chap5/Fig5.2.std.svg
@  ..img > img/chap5/Fig5.2.std.svg

#    :: @t(Exercise 5.1) :: Design a register machine to compute factorials using
#       the iterative algorithm specified by the following procedure. Draw
#       data-path and controller diagrams for this machine.
   :: @t(Ejercicio 5.1) :: Diseñar una máquina registradora para calcular
      factorials utilizando el algoritmo iterativo especificado por el siguiente
      procedimiento. Dibuje diagramas de ruta de datos y controladores para esta
      máquina.

#       ..src > scheme
#         (define (factorial n)
#           (define (iter product counter)
#             (if (> counter n)
#                 product
#                 (iter (* counter product)
#                       (+ counter 1))))
#           (iter 1 1))
#       < src..
      ..src > scheme
        (define (factorial n)
          (define (iter product counter)
            (if (> counter n)
                product
                (iter (* counter product)
                      (+ counter 1))))
          (iter 1 1))
      < src..

# *** 5.1.1 <> A Language for Describing Register Machines
*** 5.1.1 <> Un lenguaje para describir las máquinas de registro

#     Data-path and controller diagrams are adequate for representing simple
#     machines such as @A(GCD), but they are unwieldy for describing large machines
#     such as a Lisp interpreter. To make it possible to deal with complex machines,
#     we will create a language that presents, in textual form, all the information
#     given by the data-path and controller diagrams. We will start with a notation
#     that directly mirrors the diagrams.
    Los diagramas de ruta de datos y de controlador son adecuados para
    representar máquinas simples como @A(GCD), pero son poco manejables para
    describir máquinas grandes como un intérprete de Lisp. Para hacer posible el
    manejo de máquinas complejas, crearemos un lenguaje que presente, en forma
    textual, toda la información dada por los diagramas de ruta de datos y
    controlador. Comenzaremos con una notación que refleja directamente los
    diagramas.

#     We define the data paths of a machine by describing the registers and the
#     operations. To describe a register, we give it a name and specify the buttons
#     that control assignment to it. We give each of these buttons a name and
#     specify the source of the data that enters the register under the button's
#     control. (The source is a register, a constant, or an operation.)  To describe
#     an operation, we give it a name and specify its inputs (registers or
#     constants).
    Definimos las rutas de datos de una máquina describiendo los registros y las
    operaciones. Para describir un registro, le damos un nombre y especificamos
    los botones que controlan la asignación a él. Damos a cada uno de estos
    botones un nombre y especificamos el origen de los datos que entran en el
    registro bajo el control del botón. (La fuente es un registro, una constante
    o una operación.) Para describir una operación, le damos un nombre y
    especificamos sus entradas (registros o constantes).

#     We define the controller of a machine as a sequence of @e(instructions)
#     together with @e(labels) that identify @e(entry points) in the sequence. An
#     instruction is one of the following:
    Definimos el controlador de una máquina como una secuencia de
    @e(instrucciones) junto con @e(etiquetas) que identifican @e(puntos de
    entrada) en la secuencia. Una instrucción es una de las siguientes:

#     - The name of a data-path button to push to assign a value to a
#       register. (This corresponds to a box in the controller diagram.)
    - El nombre de un botón de ruta de datos para empujar para asignar un valor
      a un registro. (Esto corresponde a una caja en el diagrama del
      controlador).

#     - A @c(test) instruction, that performs a specified test.
    - Una @c(test) instrucción que realiza una prueba especificada.

#     - A conditional branch (@c(branch) instruction) to a location indicated by a
#       controller label, based on the result of the previous test. (The test and
#       branch together correspond to a diamond in the controller diagram.)  If the
#       test is false, the controller should continue with the next instruction in
#       the sequence. Otherwise, the controller should continue with the instruction
#       after the label.
    - Una rama condicional (@c(branch) instrucción) a una ubicación indicada
      por una etiqueta del controlador, basada en el resultado de la prueba
      anterior. (La prueba y la rama corresponden a un diamante en el diagrama
      del controlador). Si la prueba es falsa, el controlador debe continuar con
      la siguiente instrucción en la secuencia. De lo contrario, el controlador
      debe continuar con la instrucción después de la etiqueta.

#     - An unconditional branch (@c(goto) instruction) naming a controller label at
#       which to continue execution.
    - Una rama incondicional (@c(goto) instrucción) que nombra una etiqueta del
      controlador en la que continuar la ejecución.


#     The machine starts at the beginning of the controller instruction sequence and
#     stops when execution reaches the end of the sequence. Except when a branch
#     changes the flow of control, instructions are executed in the order in which
#     they are listed.
    La máquina comienza al principio de la secuencia de instrucciones del
    controlador y se detiene cuando la ejecución llega al final de la
    secuencia. Excepto cuando una rama cambia el flujo de control, las
    instrucciones se ejecutan en el orden en que se enumeran.

#     @l(#Figure 5.3) shows the @A(GCD) machine described in this way. This example
#     only hints at the generality of these descriptions, since the @A(GCD) machine
#     is a very simple case: Each register has only one button, and each button and
#     test is used only once in the controller.
    @l(#Figura 5.3) muestra la máquina @A(GCD) descrita de esta
    manera. Este ejemplo sólo sugiere la generalidad de estas descripciones, ya
    que la máquina @A(GCD) es un caso muy simple: Cada registro tiene sólo un
    botón, y cada botón y prueba se utiliza sólo una vez en el controlador.

#     ..figure > @t(Figure 5.3) A specification of the @A(GCD) machine.
    ..figure > @t(Figura 5.3) Una especificación de la máquina @A(GCD).

#       ..src > scheme
#         (data-paths
#          (registers
#           ((name a)
#            (buttons ((name a<-b)
#                      (source (register b)))))
#           ((name b)
#            (buttons ((name b<-t)
#                      (source (register t)))))
#           ((name t)
#            (buttons ((name t<-r)
#                      (source (operation rem))))))
#          (operations
#           ((name rem)
#            (inputs (register a) (register b)))
#           ((name =)
#            (inputs (register b) (constant 0)))))
#
#         (controller
#          test-b                ; label
#            (test =)            ; test
#            (branch
#             (label gcd-done))  ; conditional branch
#            (t<-r)              ; button push
#            (a<-b)              ; button push
#            (b<-t)              ; button push
#            (goto
#             (label test-b))    ; unconditional branch
#          gcd-done)             ; label
#       < src..
      ..src > scheme
        (data-paths
         (registers
          ((name a)
           (buttons ((name a<-b)
                     (source (register b)))))
          ((name b)
           (buttons ((name b<-t)
                     (source (register t)))))
          ((name t)
           (buttons ((name t<-r)
                     (source (operation rem))))))
         (operations
          ((name rem)
           (inputs (register a) (register b)))
          ((name =)
           (inputs (register b) (constant 0)))))

        (controller
         test-b                ; label
           (test =)            ; test
           (branch
            (label gcd-done))  ; conditional branch
           (t<-r)              ; button push
           (a<-b)              ; button push
           (b<-t)              ; button push
           (goto
            (label test-b))    ; unconditional branch
         gcd-done)             ; label
      < src..


#     Unfortunately, it is difficult to read such a description. In order to
#     understand the controller instructions we must constantly refer back to the
#     definitions of the button names and the operation names, and to understand
#     what the buttons do we may have to refer to the definitions of the operation
#     names.  We will thus transform our notation to combine the information from
#     the data-path and controller descriptions so that we see it all together.
    Desafortunadamente, es difícil leer tal descripción. Para entender las
    instrucciones del controlador debemos constantemente referirnos a las
    definiciones de los nombres de los botones y los nombres de las operaciones,
    y para entender qué botones necesitaremos para referirnos a las definiciones
    de los nombres de las operaciones. Transformaremos así nuestra notación para
    combinar la información de la trayectoria de datos y las descripciones del
    controlador para que podamos verla en conjunto.

#     To obtain this form of description, we will replace the arbitrary button and
#     operation names by the definitions of their behavior. That is, instead of
#     saying (in the controller) @"(Push button @c(t<-r)) and separately saying (in
#     the data paths) @"(Button @c(t<-r) assigns the value of the @c(rem) operation
#     to register @c(t)) and @"(The @c(rem) operation's inputs are the contents of
#     registers @c(a) and @c(b),) we will say (in the controller) @"(Push the button
#     that assigns to register @c(t) the value of the @c(rem) operation on the
#     contents of registers @c(a) and @c(b).)  Similarly, instead of saying (in the
#     controller) @"(Perform the @c(=) test) and separately saying (in the data
#     paths) @"(The @c(=) test operates on the contents of register @c(b) and the
#     constant 0,) we will say @"(Perform the @c(=) test on the contents of register
#     @c(b) and the constant 0.)  We will omit the data-path description, leaving
#     only the controller sequence.  Thus, the @A(GCD) machine is described as
#     follows:
    Para obtener esta forma de descripción, reemplazaremos el botón arbitrario y
    los nombres de operación por las definiciones de su comportamiento. Es
    decir, en lugar de decir (en el controlador) @"(Pulsar el botón@c(t<-r))
    y decir por separado (en los caminos de datos) @"(Botón @c(t<-r) asigna
    el valor de la @c(rem) operación para registrar@c(t)) y @"(Las @c(rem)
    entradas de la operación son el contenido de los registros @c(a) y @c(b),)
    vamos a decir (en el controlador) @"(Pulse el botón que asigna para
    registrar @c(t) el valor de la @c(rem) operación en el contenido de los
    registros @c(a) y @c(b). )  Similar, @"(En lugar de decir (en el
    controlador) Realizar la @c(=) prueba) y diciendo por separado (en los
    caminos de datos) @"(La @c(=) prueba opera sobre el contenido del registro
    @c(b) y la constante 0,) vamos a decir @"(Realizar la @c(=) prueba sobre el
    contenido del registro @c(b) y la constante 0.)  Nosotros Omitirá la
    descripción de la ruta de datos, dejando sólo la secuencia del
    controlador. Por lo tanto, la máquina @A(GCD) se describe como sigue:

#     ..src > scheme
#       (controller
#        test-b
#          (test (op =) (reg b) (const 0))
#          (branch (label gcd-done))
#          (assign t (op rem) (reg a) (reg b))
#          (assign a (reg b))
#          (assign b (reg t))
#          (goto (label test-b))
#        gcd-done)
#     < src..
    ..src > scheme
      (controller
       test-b
         (test (op =) (reg b) (const 0))
         (branch (label gcd-done))
         (assign t (op rem) (reg a) (reg b))
         (assign a (reg b))
         (assign b (reg t))
         (goto (label test-b))
       gcd-done)
    < src..

#     This form of description is easier to read than the kind illustrated in
#     @l(#Figure 5.3), but it also has disadvantages:
    Esta forma de descripción es más fácil de leer que la ilustrada en la
    @l(#Figura 5.3), pero también tiene inconvenientes:

#     - It is more verbose for large machines, because complete descriptions of the
#       data-path elements are repeated whenever the elements are mentioned in the
#       controller instruction sequence. (This is not a problem in the @A(GCD)
#       example, because each operation and button is used only once.)  Moreover,
#       repeating the data-path descriptions obscures the actual data-path structure
#       of the machine; it is not obvious for a large machine how many registers,
#       operations, and buttons there are and how they are interconnected.
    - Es más detallado para máquinas grandes, porque las descripciones completas
      de los elementos de la ruta de datos se repiten cada vez que los elementos
      se mencionan en la secuencia de instrucciones del controlador. (Esto no es
      un problema en el ejemplo de @A(GCD), ya que cada operación y botón se
      utiliza sólo una vez.) Además, la repetición de las descripciones de ruta
      de datos oculta la estructura de ruta de datos real de la máquina; No es
      obvio para una máquina grande cuántos registros, operaciones y botones hay
      y cómo están interconectados.

#     - Because the controller instructions in a machine definition look like Lisp
#       expressions, it is easy to forget that they are not arbitrary Lisp
#       expressions.  They can notate only legal machine operations. For example,
#       operations can operate directly only on constants and the contents of
#       registers, not on the results of other operations.
    - Debido a que las instrucciones del controlador en una definición de
      máquina parecen expresiones Lisp, es fácil olvidar que no son expresiones
      Lisp arbitrarias. Pueden notificar sólo las operaciones legales de la
      máquina. Por ejemplo, las operaciones pueden operar directamente sólo en
      las constantes y el contenido de los registros, no en los resultados de
      otras operaciones.

#     In spite of these disadvantages, we will use this register-machine language
#     throughout this chapter, because we will be more concerned with understanding
#     controllers than with understanding the elements and connections in data
#     paths.  We should keep in mind, however, that data-path design is crucial in
#     designing real machines.
    A pesar de estas desventajas, usaremos este lenguaje de registro-máquina a
    lo largo de este capítulo, porque estaremos más interesados en entender a
    los controladores que en entender los elementos y conexiones en las rutas de
    datos. Sin embargo, debemos tener en cuenta que el diseño de la ruta de
    datos es crucial en el diseño de máquinas reales.

#     :: @t(Exercise 5.2) :: Use the register-machine language to describe the
#        iterative factorial machine of @l(#Exercise 5.1).
    :: @t(Ejercicio 5.2) :: Utilice el lenguaje registro-máquina para describir
       la máquina factorial iterativa del @l(#Ejercicio 5.1).

# **** Actions
**** Comportamiento

#      Let us modify the @A(GCD) machine so that we can type in the numbers whose
#      @A(GCD) we want and get the answer printed at our terminal. We will not
#      discuss how to make a machine that can read and print, but will assume (as we
#      do when we use @c(read) and @c(display) in Scheme) that they are available as
#      primitive operations.@n(286)
     Permítanos modificar la máquina @A(GCD) para que podamos escribir los
     números cuyo @A(GCD) queremos y obtener la respuesta impresa en nuestro
     terminal. No discutiremos cómo hacer una máquina que pueda leer e imprimir,
     sino asumir (como lo hacemos cuando usamos @c(read) y @c(display) en
     Scheme) que están disponibles como operaciones primitivas.@n(286)

#      @c(Read) is like the operations we have been using in that it produces a value
#      that can be stored in a register. But @c(read) does not take inputs from any
#      registers; its value depends on something that happens outside the parts of
#      the machine we are designing. We will allow our machine's operations to have
#      such behavior, and thus will draw and notate the use of @c(read) just as we do
#      any other operation that computes a value.
     @c(Read) Es como las operaciones que hemos estado usando en que produce un
     valor que se puede almacenar en un registro. Pero @c(read) no toma entradas
     de ningún registro; Su valor depende de algo que sucede fuera de las partes
     de la máquina que estamos diseñando. Permitiremos que las operaciones de
     nuestra máquina tengan tal comportamiento, y por lo tanto dibujaremos y
     notaremos el uso de la @c(read) misma manera que hacemos cualquier otra
     operación que calcule un valor.

#      @c(Print), on the other hand, differs from the operations we have been using
#      in a fundamental way: It does not produce an output value to be stored in a
#      register. Though it has an effect, this effect is not on a part of the machine
#      we are designing. We will refer to this kind of operation as an @e(action). We
#      will represent an action in a data-path diagram just as we represent an
#      operation that computes a value––as a trapezoid that contains the name of the
#      action. Arrows point to the action box from any inputs (registers or
#      constants). We also associate a button with the action. Pushing the button
#      makes the action happen. To make a controller push an action button we use a
#      new kind of instruction called @c(perform). Thus, the action of printing the
#      contents of register @c(a) is represented in a controller sequence by the
#      instruction
     @c(Print), Por otro lado, difiere de las operaciones que hemos estado
     utilizando de manera fundamental: No produce un valor de salida que se
     almacene en un registro. Aunque tiene un efecto, este efecto no está en una
     parte de la máquina que estamos diseñando. Nos referiremos a este tipo de
     operación como una @e(acción). Representaremos una acción en un diagrama de
     ruta de datos tal como representamos una operación que calcula un valor,
     como un trapezoide que contiene el nombre de la acción. Las flechas apuntan
     al cuadro de acción desde cualquier entrada (registros o
     constantes). También asociamos un botón con la acción. Al pulsar el botón
     se activa la acción. Para hacer que un controlador empuje un botón de
     acción usamos un nuevo tipo de instrucción llamada @c(perform). Así,@c(a)

#      ..src > scheme
#        (perform (op print) (reg a))
#      < src..
     ..src > scheme
       (perform (op print) (reg a))
     < src..

#      @l(#Figure 5.4) shows the data paths and controller for the new @A(GCD)
#      machine. Instead of having the machine stop after printing the answer, we have
#      made it start over, so that it repeatedly reads a pair of numbers, computes
#      their @A(GCD), and prints the result. This structure is like the driver loops
#      we used in the interpreters of @l(#Chapter 4).
     @l(#Figura 5.4) muestra las rutas de datos y el controlador
     para la nueva máquina @A(GCD). En lugar de hacer que la máquina se detenga
     después de imprimir la respuesta, hemos hecho que comience de nuevo, de
     modo que repetidamente lea un par de números, calcule su @A(GCD) e imprima
     el resultado. Esta estructura es como los lazos del conductor que
     utilizamos en los intérpretes del @l(Capitulo 4).

#      ..figure > @t(Figure 5.4) A @A(GCD) machine that reads inputs and prints results.
     ..figure > @t(Figura 5.4) Una máquina @A(GCD) que lee entradas e imprime
       resultados.

#        ..art >
#                            .─────────.
#                             ╲ read  ╱
#                              ╲_____╱
#                                 │
#                         ╭───────*──────╮
#                         │              │
#                   a←rd (X)            (X) b←rd
#                         │              │
#                         ▼              ▼           ___
#                      ╭─────╮        ╭─────╮       ╱   ╲
#                      │  a  │◀──(X)──┤  b  ├─────▶(  =  )
#                      ╰─┬─┬─╯   a←b  ╰─┬───╯       ╲___╱
#                        │ │            │  ▲          ▲
#                     ╭──╯ ╰────╮    ╭──╯  │          │
#                     │         │    │    (X) b←t    ╱ ╲
#                     ▼         ▼    ▼     │        ╱ O ╲
#                .─────────.  .─────────.  │       ╱_____╲
#          ──(X)─▶╲ print ╱    ╲  rem  ╱   │
#             P    ╲_____╱      ╲_____╱    │
#                                  │       │
#                                 (X) t←r  │
#                                  │       │
#                                  ▼       │
#                               ╭─────╮    │
#                               │  t  ├────╯
#                               ╰─────╯
#        < art..
       ..art >
                           .─────────.
                            ╲ read  ╱
                             ╲_____╱
                                │
                        ╭───────*──────╮
                        │              │
                  a←rd (X)            (X) b←rd
                        │              │
                        ▼              ▼           ___
                     ╭─────╮        ╭─────╮       ╱   ╲
                     │  a  │◀──(X)──┤  b  ├─────▶(  =  )
                     ╰─┬─┬─╯   a←b  ╰─┬───╯       ╲___╱
                       │ │            │  ▲          ▲
                    ╭──╯ ╰────╮    ╭──╯  │          │
                    │         │    │    (X) b←t    ╱ ╲
                    ▼         ▼    ▼     │        ╱ O ╲
               .─────────.  .─────────.  │       ╱_____╲
         ──(X)─▶╲ print ╱    ╲  rem  ╱   │
            P    ╲_____╱      ╲_____╱    │
                                 │       │
                                (X) t←r  │
                                 │       │
                                 ▼       │
                              ╭─────╮    │
                              │  t  ├────╯
                              ╰─────╯
       < art..

#        ..src > scheme
#           (controller
#            gcd-loop
#              (assign a (op read))
#              (assign b (op read))
#            test-b
#              (test (op =) (reg b) (const 0))
#              (branch (label gcd-done))
#              (assign t (op rem) (reg a) (reg b))
#              (assign a (reg b))
#              (assign b (reg t))
#              (goto (label test-b))
#            gcd-done
#              (perform (op print) (reg a))
#              (goto (label gcd-loop)))
#        < src..
       ..src > scheme
          (controller
           gcd-loop
             (assign a (op read))
             (assign b (op read))
           test-b
             (test (op =) (reg b) (const 0))
             (branch (label gcd-done))
             (assign t (op rem) (reg a) (reg b))
             (assign a (reg b))
             (assign b (reg t))
             (goto (label test-b))
           gcd-done
             (perform (op print) (reg a))
             (goto (label gcd-loop)))
       < src..

# *** 5.1.2 <> Abstraction in Machine Design
*** 5.1.2 <> Abstracción en Diseño de Máquina

#     We will often define a machine to include @"(primitive) operations that are
#     actually very complex. For example, in section @l(#5.4) and @l(#5.5) we will treat
#     Scheme's environment manipulations as primitive. Such abstraction is valuable
#     because it allows us to ignore the details of parts of a machine so that we
#     can concentrate on other aspects of the design. The fact that we have swept a
#     lot of complexity under the rug, however, does not mean that a machine design
#     is unrealistic. We can always replace the complex @"(primitives) by simpler
#     primitive operations.
    Definiremos a menudo una máquina para incluir @"(las) operaciones
    @"(primitivas) que son realmente muy complejas. Por ejemplo, en
    @l(#5.4) y @l(#5.5) trataremos las manipulaciones ambientales de
    Scheme como primitivas. Tal abstracción es valiosa porque nos permite
    ignorar los detalles de las partes de una máquina para que podamos
    concentrarnos en otros aspectos del diseño. El hecho de que hemos barrido
    una gran cantidad de complejidad bajo la alfombra, sin embargo, no significa
    que el diseño de una máquina no es realista. Siempre podemos reemplazar las
    @"(primitivas) complejas por operaciones primitivas más simples.

#     Consider the @A(GCD) machine. The machine has an instruction that computes the
#     remainder of the contents of registers @c(a) and @c(b) and assigns the result
#     to register @c(t). If we want to construct the @A(GCD) machine without using a
#     primitive remainder operation, we must specify how to compute remainders in
#     terms of simpler operations, such as subtraction. Indeed, we can write a
#     Scheme procedure that finds remainders in this way:
    Considere la máquina @A(GCD). La máquina tiene una instrucción que calcula
    el resto de los contenidos de los registros @c(a) y @c(b) asigna el
    resultado a registrarse @c(t). Si queremos construir la máquina @A(GCD) sin
    utilizar una operación de resto primitivo, debemos especificar cómo calcular
    los restos en términos de operaciones más simples, como la sustracción. De
    hecho, podemos escribir un procedimiento Scheme que encuentra los restos de
    esta manera:

#     ..src > scheme
#       (define (remainder n d)
#         (if (< n d) n (remainder (- n d) d)))
#     < src..
    ..src > scheme
      (define (remainder n d)
        (if (< n d) n (remainder (- n d) d)))
    < src..

#     We can thus replace the remainder operation in the @A(GCD) machine's data
#     paths with a subtraction operation and a comparison test. @l(#Figure 5.5)
#     shows the data paths and controller for the elaborated machine. The
#     instruction
    Por lo tanto, podemos reemplazar la operación restante en las rutas de datos
    de la máquina @A(GCD) con una operación de sustracción y una prueba de
    comparación. @l(#Figura 5.5) muestra las rutas de datos y el
    controlador para la máquina elaborada. La instrucción

#     ..src > scheme
#       (assign t (op rem) (reg a) (reg b))
#     < src..
    ..src > scheme
      (assign t (op rem) (reg a) (reg b))
    < src..

#     in the @A(GCD) controller definition is replaced by a sequence of instructions
#     that contains a loop, as shown in @l(#Figure 5.6).
    En la definición del controlador @A(GCD) se sustituye por una secuencia de
    instrucciones que contiene un bucle, como se muestra en la
    @l(#Figura 5.6).

#     ..figure > @t(Figure 5.5) Data paths and controller for the elaborated @A(GCD) machine.
    ..figure > @t(Figura 5.5 Rutas de) datos y controlador para la máquina
      @A(GCD) elaborada.

#       ..art >
#                                             ___
#         ╭─────╮         ╭─────╮            ╱   ╲
#         │  a  │◀──(X)───┤  b  ├───────●──▶(  =  )
#         ╰──┬──╯   a←b   ╰─┬───╯       │    ╲___╱
#            │              │  ▲        │
#           (X) t←a         │  │        │
#            │              │ (X) b←t   │
#            ▼              │  │       _▼_
#         ╭─────╮           │  │      ╱   ╲
#         │  t  ├───────●───┼──●─────(  <  )
#         ╰─────╯       │   │         ╲___╱
#            ▲          ▼   ▼
#            │       .─────────.
#           (X) t←d   ╲   −   ╱
#            │         '──┬──'
#            │            │
#            ╰────────────╯
#
#
#            start
#              │
#              ▼
#             ╱ ╲ yes            ╭───────╮
#         ╭─▶( = )────▶ done     │  t←d  │◀──╮
#         │   ╲ ╱                ╰───┬───╯   │
#         │    │ no                  │       │
#         │    │                     ▼       │
#         │    │   ╭───────╮        ╱ ╲ no   │
#         │    ╰──▶│  t←a  ├──────▶( < )─────╯
#         │        ╰───────╯        ╲ ╱
#         │                          │ yes
#         │      ╭───────────────────╯
#         │      ▼
#         │  ╭───────╮
#         │  │  a←b  │
#         │  ╰───┬───╯
#         │      │
#         │      ▼
#         │  ╭───────╮
#         ╰──┤  b←t  │
#            ╰───────╯
#       < art..
      ..art >
                                            ___
        ╭─────╮         ╭─────╮            ╱   ╲
        │  a  │◀──(X)───┤  b  ├───────●──▶(  =  )
        ╰──┬──╯   a←b   ╰─┬───╯       │    ╲___╱
           │              │  ▲        │
          (X) t←a         │  │        │
           │              │ (X) b←t   │
           ▼              │  │       _▼_
        ╭─────╮           │  │      ╱   ╲
        │  t  ├───────●───┼──●─────(  <  )
        ╰─────╯       │   │         ╲___╱
           ▲          ▼   ▼
           │       .─────────.
          (X) t←d   ╲   −   ╱
           │         '──┬──'
           │            │
           ╰────────────╯


           start
             │
             ▼
            ╱ ╲ yes            ╭───────╮
        ╭─▶( = )────▶ done     │  t←d  │◀──╮
        │   ╲ ╱                ╰───┬───╯   │
        │    │ no                  │       │
        │    │                     ▼       │
        │    │   ╭───────╮        ╱ ╲ no   │
        │    ╰──▶│  t←a  ├──────▶( < )─────╯
        │        ╰───────╯        ╲ ╱
        │                          │ yes
        │      ╭───────────────────╯
        │      ▼
        │  ╭───────╮
        │  │  a←b  │
        │  ╰───┬───╯
        │      │
        │      ▼
        │  ╭───────╮
        ╰──┤  b←t  │
           ╰───────╯
      < art..

# @   ..img > img/chap5/Fig5.5b.std.svg
@   ..img > img/chap5/Fig5.5b.std.svg

#     ..figure > @t(Figure 5.6) Controller instruction sequence for the @A(GCD)
#       machine in @l(#Figure 5.5).
    ..figure > @t(Figura 5.6) Secuencia de instrucciones del controlador para la
      máquina @A(GCD) en la @l(#Figura 5.5).

#       ..src > scheme
#         (controller
#          test-b
#            (test (op =) (reg b) (const 0))
#            (branch (label gcd-done))
#            (assign t (reg a))
#          rem-loop
#            (test (op <) (reg t) (reg b))
#            (branch (label rem-done))
#            (assign t (op -) (reg t) (reg b))
#            (goto (label rem-loop))
#          rem-done
#            (assign a (reg b))
#            (assign b (reg t))
#            (goto (label test-b))
#          gcd-done)
#       < src..
      ..src > scheme
        (controller
         test-b
           (test (op =) (reg b) (const 0))
           (branch (label gcd-done))
           (assign t (reg a))
         rem-loop
           (test (op <) (reg t) (reg b))
           (branch (label rem-done))
           (assign t (op -) (reg t) (reg b))
           (goto (label rem-loop))
         rem-done
           (assign a (reg b))
           (assign b (reg t))
           (goto (label test-b))
         gcd-done)
      < src..


#     :: @t(Exercise 5.3) :: Design a machine to compute square roots using Newton's
#        method, as described in @l(#Sec.1.1.7,,1.1.7):
    :: @t(Ejercicio 5.3) :: Diseñar una máquina para calcular raíces cuadradas
       usando el método Newton, como se describe en
       @l(#Sec.1.1.7,,1.1.7<>Sec.1.1.7,, 1.1.7) :

#        ..src > scheme
#          (define (sqrt x)
#            (define (good-enough? guess)
#              (< (abs (- (square guess) x)) 0.001))
#            (define (improve guess)
#              (average guess (/ x guess)))
#            (define (sqrt-iter guess)
#              (if (good-enough? guess)
#                  guess
#                  (sqrt-iter (improve guess))))
#            (sqrt-iter 1.0))
#        < src..
       ..src > scheme
         (define (sqrt x)
           (define (good-enough? guess)
             (< (abs (- (square guess) x)) 0.001))
           (define (improve guess)
             (average guess (/ x guess)))
           (define (sqrt-iter guess)
             (if (good-enough? guess)
                 guess
                 (sqrt-iter (improve guess))))
           (sqrt-iter 1.0))
       < src..

#       Begin by assuming that @c(good-enough?) and @c(improve) operations are
#       available as primitives. Then show how to expand these in terms of
#       arithmetic operations. Describe each version of the @c(sqrt) machine design
#       by drawing a data-path diagram and writing a controller definition in the
#       register-machine language.
      Comience suponiendo que @c(good-enough?) y las @c(improve) operaciones
      están disponibles como primitivas. A continuación, muestra cómo
      expandirlos en términos de operaciones aritméticas. Describir cada versión
      del @c(sqrt) diseño de la máquina dibujando un diagrama de ruta de datos y
      escribiendo una definición de controlador en el lenguaje de
      registro-máquina.

# *** 5.1.3 <> Subroutines
*** 5.1.3 <> Subrutinas

#     When designing a machine to perform a computation, we would often prefer to
#     arrange for components to be shared by different parts of the computation
#     rather than duplicate the components. Consider a machine that includes two
#     @A(GCD) computations––one that finds the @A(GCD) of the contents of registers
#     @c(a) and @c(b) and one that finds the @A(GCD) of the contents of registers
#     @c(c) and @c(d). We might start by assuming we have a primitive @c(gcd)
#     operation, then expand the two instances of @c(gcd) in terms of more primitive
#     operations. @l(#Figure 5.7) shows just the @A(GCD) portions of the resulting
#     machine's data paths, without showing how they connect to the rest of the
#     machine. The figure also shows the corresponding portions of the machine's
#     controller sequence.
    Al diseñar una máquina para realizar un cálculo, a menudo preferiríamos que
    los componentes fueran compartidos por diferentes partes del cálculo en
    lugar de duplicar los componentes. Considere una máquina que incluye dos
    @A(GCD) cálculos - que encuentra la @A(GCD) de los contenidos de los
    registros @c(a) y @c(b) y uno que encuentra el @A(GCD) de los contenidos de
    los registros @c(c) y @c(d). Podríamos comenzar asumiendo que tenemos una
    @c(gcd) operación primitiva, luego expandimos las dos instancias de @c(gcd)
    en términos de operaciones más primitivas. @l(#Figura 5.7)
    muestra sólo las partes @A(GCD) de las rutas de datos de la máquina
    resultante, sin mostrar cómo se conectan al resto de la máquina.

#     ..figure > @t(Figure 5.7) Portions of the data paths and controller sequence
#       for a machine with two @A(GCD) computations.
    ..figure > @t(Figura 5.7) Porciones de las rutas de datos y la secuencia del
    controlador para una máquina con dos cálculos @A(GCD).

#       ..cols >
      ..cols >

#         ..art >
#                                        ___
#           ╭─────╮        ╭─────╮      ╱   ╲
#           │  a  │◀─(X)───┤  b  │────▶(  =  )
#           ╰──┬──╯  a←b   ╰┬────╯      ╲___╱
#              │            │   ▲         ▲
#              ╰────╮   ╭───╯   │         │
#                   ▼   ▼      (X) b←t    │
#                 .───────.     │        ╱ ╲
#                  ╲ rem ╱      │       ╱ 0 ╲
#                   ──┬──       │      '─────'
#                     │         │
#                    (X) t←r    │
#                     │         │
#                     V         │
#                  ╭─────╮      │
#                  │  t  ├──────╯
#                  ╰─────╯
#         < art..
        ..art >
                                       ___
          ╭─────╮        ╭─────╮      ╱   ╲
          │  a  │◀─(X)───┤  b  │────▶(  =  )
          ╰──┬──╯  a←b   ╰┬────╯      ╲___╱
             │            │   ▲         ▲
             ╰────╮   ╭───╯   │         │
                  ▼   ▼      (X) b←t    │
                .───────.     │        ╱ ╲
                 ╲ rem ╱      │       ╱ 0 ╲
                  ──┬──       │      '─────'
                    │         │
                   (X) t←r    │
                    │         │
                    V         │
                 ╭─────╮      │
                 │  t  ├──────╯
                 ╰─────╯
        < art..

#         ::
        ::

#         ..src > scheme
#           gcd-1
#            (test (op =) (reg b) (const 0))
#            (branch (label after-gcd-1))
#            (assign t (op rem) (reg a) (reg b))
#            (assign a (reg b))
#            (assign b (reg t))
#            (goto (label gcd-1))
#           after-gcd-1
#         < src..
        ..src > scheme
          gcd-1
           (test (op =) (reg b) (const 0))
           (branch (label after-gcd-1))
           (assign t (op rem) (reg a) (reg b))
           (assign a (reg b))
           (assign b (reg t))
           (goto (label gcd-1))
          after-gcd-1
        < src..

#       ..cols >
      ..cols >

#         ..art >
#                                        ___
#           ╭─────╮        ╭─────╮      ╱   ╲
#           │  c  │◀─(X)───┤  d  │────▶(  =  )
#           ╰──┬──╯  c←d   ╰┬────╯      ╲___╱
#              │            │   ▲         ▲
#              ╰────╮   ╭───╯   │         │
#                   ▼   ▼      (X) d←t    │
#                 .───────.     │        ╱ ╲
#                  ╲ rem ╱      │       ╱ 0 ╲
#                   ──┬──       │      '─────'
#                     │         │
#                    (X) s←r    │
#                     │         │
#                     V         │
#                  ╭─────╮      │
#                  │  s  ├──────╯
#                  ╰─────╯
#         < art..
        ..art >
                                       ___
          ╭─────╮        ╭─────╮      ╱   ╲
          │  c  │◀─(X)───┤  d  │────▶(  =  )
          ╰──┬──╯  c←d   ╰┬────╯      ╲___╱
             │            │   ▲         ▲
             ╰────╮   ╭───╯   │         │
                  ▼   ▼      (X) d←t    │
                .───────.     │        ╱ ╲
                 ╲ rem ╱      │       ╱ 0 ╲
                  ──┬──       │      '─────'
                    │         │
                   (X) s←r    │
                    │         │
                    V         │
                 ╭─────╮      │
                 │  s  ├──────╯
                 ╰─────╯
        < art..

#         ::
        ::

#         ..src > scheme
#           gcd-2
#            (test (op =) (reg d) (const 0))
#            (branch (label after-gcd-2))
#            (assign s (op rem) (reg c) (reg d))
#            (assign c (reg d))
#            (assign d (reg s))
#            (goto (label gcd-2))
#           after-gcd-2
#         < src..
        ..src > scheme
          gcd-2
           (test (op =) (reg d) (const 0))
           (branch (label after-gcd-2))
           (assign s (op rem) (reg c) (reg d))
           (assign c (reg d))
           (assign d (reg s))
           (goto (label gcd-2))
          after-gcd-2
        < src..

# @   ..img > img/chap5/Fig5.7b.std.svg
@   ..img > img/chap5/Fig5.7b.std.svg

#     This machine has two remainder operation boxes and two boxes for testing
#     equality. If the duplicated components are complicated, as is the remainder
#     box, this will not be an economical way to build the machine. We can avoid
#     duplicating the data-path components by using the same components for both
#     @A(GCD) computations, provided that doing so will not affect the rest of the
#     larger machine's computation. If the values in registers @c(a) and @c(b) are
#     not needed by the time the controller gets to @c(gcd-2) (or if these values
#     can be moved to other registers for safekeeping), we can change the machine so
#     that it uses registers @c(a) and @c(b), rather than registers @c(c) and @c(d),
#     in computing the second @A(GCD) as well as the first. If we do this, we obtain
#     the controller sequence shown in @l(#Figure 5.8).
    Esta máquina tiene dos cajas de operación restantes y dos cajas para probar
    la igualdad. Si los componentes duplicados son complicados, al igual que el
    resto de la caja, esto no será una manera económica de construir la
    máquina. Podemos evitar la duplicación de los componentes de la ruta de
    datos mediante el uso de los mismos componentes para ambos cálculos @A(GCD),
    siempre que hacerlo no afectará al resto de la computación de la máquina más
    grande. Si los valores en los registros @c(a) y @c(b) no son necesarios por
    el tiempo que el controlador llega a @c(gcd-2)(o si estos valores pueden ser
    movidos a otros registros para la custodia), podemos cambiar la máquina para
    que utilice registros @c(a) y @c(b), en lugar de registros @c(c) y @c(d), en
    la informática El segundo @A(GCD), así como el primero. Si hacemos esto,
    @l(#Figura 5.8)

#     ..figure > @t(Figure 5.8) Portions of the controller sequence for a machine
#       that uses the same data-path components for two different @A(GCD)
#       computations.
    ..figure > @t(Figura 5.8) Porciones de la secuencia del controlador para una
      máquina que utiliza los mismos componentes de la ruta de datos para dos
      cálculos diferentes de @A(GCD).

#       ..src > scheme
#         gcd-1
#          (test (op =) (reg b) (const 0))
#          (branch (label after-gcd-1))
#          (assign t (op rem) (reg a) (reg b))
#          (assign a (reg b))
#          (assign b (reg t))
#          (goto (label gcd-1))
#         after-gcd-1
#           …
#         gcd-2
#          (test (op =) (reg b) (const 0))
#          (branch (label after-gcd-2))
#          (assign t (op rem) (reg a) (reg b))
#          (assign a (reg b))
#          (assign b (reg t))
#          (goto (label gcd-2))
#         after-gcd-2
#       < src..
      ..src > scheme
        gcd-1
         (test (op =) (reg b) (const 0))
         (branch (label after-gcd-1))
         (assign t (op rem) (reg a) (reg b))
         (assign a (reg b))
         (assign b (reg t))
         (goto (label gcd-1))
        after-gcd-1
          …
        gcd-2
         (test (op =) (reg b) (const 0))
         (branch (label after-gcd-2))
         (assign t (op rem) (reg a) (reg b))
         (assign a (reg b))
         (assign b (reg t))
         (goto (label gcd-2))
        after-gcd-2
      < src..

#     We have removed the duplicate data-path components (so that the data paths are
#     again as in @l(#Figure 5.1)), but the controller now has two @A(GCD) sequences
#     that differ only in their entry-point labels. It would be better to replace
#     these two sequences by branches to a single sequence––a @c(gcd)
#     @e(subroutine)––at the end of which we branch back to the correct place in the
#     main instruction sequence. We can accomplish this as follows: Before branching
#     to @c(gcd), we place a distinguishing value (such as 0 or 1) into a special
#     register, @c(continue). At the end of the @c(gcd) subroutine we return either
#     to @c(after-gcd-1) or to @c(after-gcd-2), depending on the value of the
#     @c(continue) register. @l(#Figure 5.9) shows the relevant portion of the
#     resulting controller sequence, which includes only a single copy of the
#     @c(gcd) instructions.
    Hemos eliminado los componentes de ruta de datos duplicados (de modo que las
    rutas de datos son de nuevo como en la @l(#Figura 5.1) ), pero
    el controlador ahora tiene dos secuencias @A(GCD) que sólo difieren en sus
    etiquetas de punto de entrada. Sería mejor reemplazar estas dos secuencias
    por ramas a una sola secuencia - una @c(gcd) @e(subrutina) - al final de la
    cual nos ramificamos de nuevo al lugar correcto en la secuencia de
    instrucciones principal. Podemos lograr esto de la siguiente manera: Antes
    de ramificación a @c(gcd), que poner un valor distintivo (como 0 ó 1) en un
    registro especial, @c(continue). Al final de la @c(gcd) subrutina regresamos
    a @c(after-gcd-1) o hacia @c(after-gcd-2), dependiendo del valor del
    @c(continue) registro. @l(#Figura 5.9) muestra la porción
    relevante de la secuencia del controlador resultante,@c(gcd)

#     ..figure > @t(Figure 5.9) Using a @c(continue) register to avoid the duplicate
#       controller sequence in @l(#Figure 5.8).
    ..figure > @t(Figura 5.9) Uso de un @c(continue) registro para evitar la
      secuencia del controlador duplicado en la @l(#Figura 5.8).

#       ..src > scheme
#         gcd
#          (test (op =) (reg b) (const 0))
#          (branch (label gcd-done))
#          (assign t (op rem) (reg a) (reg b))
#          (assign a (reg b))
#          (assign b (reg t))
#          (goto (label gcd))
#         gcd-done
#          (test (op =) (reg continue) (const 0))
#          (branch (label after-gcd-1))
#          (goto (label after-gcd-2))
#           …
#         ;; Before branching to gcd from
#         ;; the first place where it is needed,
#         ;; we place 0 in the continue register
#          (assign continue (const 0))
#          (goto (label gcd))
#         after-gcd-1
#           …
#         ;; Before the second use of gcd,
#         ;; we place 1 in the continue register
#          (assign continue (const 1))
#          (goto (label gcd))
#         after-gcd-2
#       < src..
      ..src > scheme
        gcd
         (test (op =) (reg b) (const 0))
         (branch (label gcd-done))
         (assign t (op rem) (reg a) (reg b))
         (assign a (reg b))
         (assign b (reg t))
         (goto (label gcd))
        gcd-done
         (test (op =) (reg continue) (const 0))
         (branch (label after-gcd-1))
         (goto (label after-gcd-2))
          …
        ;; Before branching to gcd from
        ;; the first place where it is needed,
        ;; we place 0 in the continue register
         (assign continue (const 0))
         (goto (label gcd))
        after-gcd-1
          …
        ;; Before the second use of gcd,
        ;; we place 1 in the continue register
         (assign continue (const 1))
         (goto (label gcd))
        after-gcd-2
      < src..


#     This is a reasonable approach for handling small problems, but it would be
#     awkward if there were many instances of @A(GCD) computations in the controller
#     sequence. To decide where to continue executing after the @c(gcd) subroutine,
#     we would need tests in the data paths and branch instructions in the
#     controller for all the places that use @c(gcd). A more powerful method for
#     implementing subroutines is to have the @c(continue) register hold the label
#     of the entry point in the controller sequence at which execution should
#     continue when the subroutine is finished. Implementing this strategy requires
#     a new kind of connection between the data paths and the controller of a
#     register machine: There must be a way to assign to a register a label in the
#     controller sequence in such a way that this value can be fetched from the
#     register and used to continue execution at the designated entry point.
    Este es un enfoque razonable para manejar pequeños problemas, pero sería
    difícil si hubiera muchos casos de cálculos @A(GCD) en la secuencia del
    controlador. Para decidir dónde continuar la ejecución después de la @c(gcd)
    subrutina, necesitaríamos pruebas en las rutas de datos y las instrucciones
    de ramificación en el controlador para todos los lugares que lo usan
    @c(gcd). Un método más potente para implementar las subrutinas es tener el
    @c(continue) registro mantenga la etiqueta del punto de entrada en la
    secuencia del controlador en la que la ejecución debe continuar cuando la
    subrutina ha terminado. La implementación de esta estrategia requiere un
    nuevo tipo de conexión entre las rutas de datos y el controlador de una
    máquina de registro:

#     To reflect this ability, we will extend the @c(assign) instruction of the
#     register-machine language to allow a register to be assigned as value a label
#     from the controller sequence (as a special kind of constant). We will also
#     extend the @c(goto) instruction to allow execution to continue at the entry
#     point described by the contents of a register rather than only at an entry
#     point described by a constant label. Using these new constructs we can
#     terminate the @c(gcd) subroutine with a branch to the location stored in the
#     @c(continue) register. This leads to the controller sequence shown in
#     @l(#Figure 5.10).
    Para reflejar esta capacidad, extenderemos la @c(assign) instrucción del
    lenguaje registro-máquina para permitir que un registro sea asignado como
    valor a una etiqueta de la secuencia del controlador (como un tipo especial
    de constante). También extenderemos la @c(goto) instrucción para permitir
    que la ejecución continúe en el punto de entrada descrito por el contenido
    de un registro en vez de solamente en un punto de entrada descrito por una
    etiqueta constante. Usando estas nuevas construcciones podemos terminar la
    @c(gcd) subrutina con una rama a la localización almacenada en el
    @c(continue) registro. Esto conduce a la secuencia del controlador mostrada
    en la @l(#Figura 5.10).

#     ..figure > @t(Figure 5.10) Assigning labels to the @c(continue) register
#       simplifies and generalizes the strategy shown in @l(#Figure 5.9).
    ..figure > @t(Figura 5.10 La) asignación de etiquetas al @c(continue)
      registro simplifica y generaliza la estrategia mostrada en la
      @l(#Figura 5.9).

#       ..src > scheme
#         gcd
#          (test (op =) (reg b) (const 0))
#          (branch (label gcd-done))
#          (assign t (op rem) (reg a) (reg b))
#          (assign a (reg b))
#          (assign b (reg t))
#          (goto (label gcd))
#         gcd-done
#          (goto (reg continue))
#           …
#         ;; Before calling gcd,
#         ;; we assign to continue the label
#         ;; to which gcd should return.
#          (assign continue (label after-gcd-1))
#          (goto (label gcd))
#         after-gcd-1
#           …
#         ;; Here is the second call to gcd,
#         ;; with a different continuation.
#          (assign continue (label after-gcd-2))
#          (goto (label gcd))
#         after-gcd-2
#       < src..
      ..src > scheme
        gcd
         (test (op =) (reg b) (const 0))
         (branch (label gcd-done))
         (assign t (op rem) (reg a) (reg b))
         (assign a (reg b))
         (assign b (reg t))
         (goto (label gcd))
        gcd-done
         (goto (reg continue))
          …
        ;; Before calling gcd,
        ;; we assign to continue the label
        ;; to which gcd should return.
         (assign continue (label after-gcd-1))
         (goto (label gcd))
        after-gcd-1
          …
        ;; Here is the second call to gcd,
        ;; with a different continuation.
         (assign continue (label after-gcd-2))
         (goto (label gcd))
        after-gcd-2
      < src..

#     A machine with more than one subroutine could use multiple continuation
#     registers (e.g., @c(gcd-continue), @c(factorial-continue)) or we could have
#     all subroutines share a single @c(continue) register. Sharing is more
#     economical, but we must be careful if we have a subroutine (@c(sub1)) that
#     calls another subroutine (@c(sub2)). Unless @c(sub1) saves the contents of
#     @c(continue) in some other register before setting up @c(continue) for the
#     call to @c(sub2), @c(sub1) will not know where to go when it is finished. The
#     mechanism developed in the next section to handle recursion also provides a
#     better solution to this problem of nested subroutine calls.
    Una máquina con más de una subrutina podría usar múltiples registros de
    continuación (por ejemplo, @c(gcd-continue), @c(factorial-continue)) o que
    podría tener todas las subrutinas comparten un único @c(continue)
    registro. Compartir es más económico, pero debemos tener cuidado si tenemos
    una subrutina (@c(sub1)) que llama a otra subrutina (@c(sub2)). A menos
    que @c(sub1) guarde el contenido de @c(continue) en algún otro registro
    antes de configurar @c(continue) para la llamada a @c(sub2), @c(sub1) no
    sabrá a dónde ir cuando haya terminado. El mecanismo desarrollado en la
    siguiente sección para manejar la recursión también proporciona una mejor
    solución a este problema de llamadas subrutinas anidadas.

# *** 5.1.4 <> Using a Stack to Implement Recursion
*** 5.1.4 <> Utilizar una pila para implementar la recursión

#     With the ideas illustrated so far, we can implement any iterative process by
#     specifying a register machine that has a register corresponding to each state
#     variable of the process. The machine repeatedly executes a controller loop,
#     changing the contents of the registers, until some termination condition is
#     satisfied. At each point in the controller sequence, the state of the machine
#     (representing the state of the iterative process) is completely determined by
#     the contents of the registers (the values of the state variables).
    Con las ideas ilustradas hasta ahora, podemos implementar cualquier proceso
    iterativo especificando una máquina de registro que tenga un registro
    correspondiente a cada variable de estado del proceso. La máquina ejecuta
    repetidamente un bucle de controlador, cambiando el contenido de los
    registros, hasta que se cumple alguna condición de terminación. En cada
    punto de la secuencia del controlador, el estado de la máquina (que
    representa el estado del proceso iterativo) está completamente determinado
    por el contenido de los registros (los valores de las variables de estado).

#     Implementing recursive processes, however, requires an additional mechanism.
#     Consider the following recursive method for computing factorials, which we
#     first examined in section @l(#1.2.1):
    La implementación de procesos recursivos, sin embargo, requiere un mecanismo
    adicional. Consideremos el siguiente método recursivo para calcular
    factorials, que examinamos primero en la seccion @l(#1.2.1) :

#     ..src > scheme
#       (define (factorial n)
#         (if (= n 1)
#             1
#             (* (factorial (- n 1)) n)))
#     < src..
    ..src > scheme
      (define (factorial n)
        (if (= n 1)
            1
            (* (factorial (- n 1)) n)))
    < src..

#     As we see from the procedure, computing @m(n!) requires computing @m[(n - 1)!].
#     Our @A(GCD) machine, modeled on the procedure
    Como vemos desde el procedimiento, la computación @m(n! ) Requiere
    computación @m[(n - 1)] ). Nuestra máquina @A(GCD), modelada en el
    procedimiento

#     ..src > scheme
#       (define (gcd a b)
#         (if (= b 0)
#             a
#             (gcd b (remainder a b))))
#     < src..
    ..src > scheme
      (define (gcd a b)
        (if (= b 0)
            a
            (gcd b (remainder a b))))
    < src..

#     similarly had to compute another @A(GCD). But there is an important difference
#     between the @c(gcd) procedure, which reduces the original computation to a new
#     @A(GCD) computation, and @c(factorial), which requires computing another
#     factorial as a subproblem. In @A(GCD), the answer to the new @A(GCD)
#     computation is the answer to the original problem. To compute the next
#     @A(GCD), we simply place the new arguments in the input registers of the
#     @A(GCD) machine and reuse the machine's data paths by executing the same
#     controller sequence. When the machine is finished solving the final @A(GCD)
#     problem, it has completed the entire computation.
    También tuvo que computar otro @A(GCD). Pero hay una diferencia importante
    entre el procedimiento @c(gcd), que reduce el cálculo original a un nuevo
    cálculo @A(GCD), y @c(factorial) que requiere computar otro factorial como
    un subproblema. En @A(GCD), la respuesta a la nueva computación @A(GCD) es
    la respuesta al problema original. Para calcular el siguiente @A(GCD),
    simplemente colocamos los nuevos argumentos en los registros de entrada de
    la máquina @A(GCD) y reutilizamos las rutas de datos de la máquina
    ejecutando la misma secuencia del controlador. Cuando la máquina ha
    terminado de resolver el problema @A(GCD) final, ha completado todo el
    cálculo.

#     In the case of factorial (or any recursive process) the answer to the new
#     factorial subproblem is not the answer to the original problem. The value
#     obtained for @m[(n - 1)!] must be multiplied by @m(n) to get the final answer.
#     If we try to imitate the @A(GCD) design, and solve the factorial subproblem by
#     decrementing the @c(n) register and rerunning the factorial machine, we will
#     no longer have available the old value of @c(n) by which to multiply the
#     result. We thus need a second factorial machine to work on the
#     subproblem. This second factorial computation itself has a factorial
#     subproblem, which requires a third factorial machine, and so on. Since each
#     factorial machine contains another factorial machine within it, the total
#     machine contains an infinite nest of similar machines and hence cannot be
#     constructed from a fixed, finite number of parts.
    En el caso de factorial (o cualquier proceso recursivo) la respuesta al
    nuevo subproblema factorial no es la respuesta al problema original. El
    valor obtenido para @m[(n - 1)] ) Debe ser multiplicado por @m(n) para
    obtener la respuesta final. Si tratamos de imitar el diseño @A(GCD), y
    resolver el subproblema factorial decrementando el @c(n) registro y
    rerunning la máquina factorial, ya no tendremos disponible el antiguo valor
    de @c(n) por qué multiplicar el resultado. Necesitamos una segunda máquina
    factorial para trabajar en el subproblema. Este segundo cálculo factorial
    tiene un subproblema factorial, que requiere una tercera máquina factorial,
    y así sucesivamente. Puesto que cada máquina factorial contiene otra máquina
    factorial dentro de ella,

#     Nevertheless, we can implement the factorial process as a register machine if
#     we can arrange to use the same components for each nested instance of the
#     machine. Specifically, the machine that computes @m(n!)  should use the same
#     components to work on the subproblem of computing @m[(n - 1)!], on the
#     subproblem for @m[(n - 2)!], and so on. This is plausible because, although
#     the factorial process dictates that an unbounded number of copies of the same
#     machine are needed to perform a computation, only one of these copies needs to
#     be active at any given time. When the machine encounters a recursive
#     subproblem, it can suspend work on the main problem, reuse the same physical
#     parts to work on the subproblem, then continue the suspended computation.
    Sin embargo, podemos implementar el proceso factorial como una máquina de
    registro si podemos organizar usar los mismos componentes para cada
    instancia anidada de la máquina. Específicamente, la máquina que calcula
    @m(n! )  Debe utilizar los mismos componentes para trabajar en el
    subproblema de la computación @m[(n - 1)] ), En el subproblema de @m[(n -
    2)] ), y así. Esto es plausible porque, aunque el proceso factorial dicta
    que se necesita un número ilimitado de copias de la misma máquina para
    realizar un cálculo, sólo una de estas copias necesita estar activa en un
    momento dado. Cuando la máquina encuentra un subproblema recursivo, puede
    suspender el trabajo sobre el problema principal, reutilizar las mismas
    partes físicas para trabajar en el subproblema y luego continuar el cálculo
    suspendido.

#     In the subproblem, the contents of the registers will be different than they
#     were in the main problem. (In this case the @c(n) register is decremented.)
#     In order to be able to continue the suspended computation, the machine must
#     save the contents of any registers that will be needed after the subproblem is
#     solved so that these can be restored to continue the suspended computation. In
#     the case of factorial, we will save the old value of @c(n), to be restored
#     when we are finished computing the factorial of the decremented @c(n)
#     register.@n(287)
    En el subproblema, el contenido de los registros será diferente de lo que
    estaban en el problema principal. (En este caso, el @c(n) registro se
    decrementa). Para poder continuar el cálculo suspendido, la máquina debe
    guardar el contenido de cualquier registro que se necesite después de que el
    subproblema sea resuelto para que estos puedan ser restaurados para
    continuar el cálculo suspendido. En el caso de factorial, se ahorrará el
    valor antiguo de @c(n), para ser restaurado cuando haya terminado de
    calcular el factorial del @c(n) registro decrementado.@n(287)

#     Since there is no @e(a priori) limit on the depth of nested recursive calls,
#     we may need to save an arbitrary number of register values. These values must
#     be restored in the reverse of the order in which they were saved, since in a
#     nest of recursions the last subproblem to be entered is the first to be
#     finished. This dictates the use of a @e(stack), or @"(last in, first out) data
#     structure, to save register values. We can extend the register-machine
#     language to include a stack by adding two kinds of instructions: Values are
#     placed on the stack using a @c(save) instruction and restored from the stack
#     using a @c(restore) instruction. After a sequence of values has been @c(save)d
#     on the stack, a sequence of @c(restore)s will retrieve these values in reverse
#     order.@n(288)
    Como no hay @e(un) límite a @e(priori) en la profundidad de las llamadas
    recursivas anidadas, es posible que necesitemos guardar un número arbitrario
    de valores de registro. Estos valores deben ser restaurados en el orden
    inverso al orden en que fueron guardados, ya que en un nido de recursiones
    el último subproblema que se va a introducir es el primero en ser
    terminado. Esto dicta el uso de una @e(pila), o la @"(última entrada, la
    primera) estructura de datos, para guardar los valores de registro. Podemos
    extender el lenguaje registro-máquina para incluir una pila añadiendo dos
    clases de instrucciones: Los valores se colocan en la pila usando una
    @c(save) instrucción y se restauran de la pila usando una @c(restore)
    instrucción. Después de que una secuencia de valores ha sido @c(save) d en
    la pila, una secuencia de @c(restore) s recuperará estos valores en orden
    inverso.@n(288)

#     With the aid of the stack, we can reuse a single copy of the factorial
#     machine's data paths for each factorial subproblem. There is a similar design
#     issue in reusing the controller sequence that operates the data paths. To
#     reexecute the factorial computation, the controller cannot simply loop back to
#     the beginning, as with an iterative process, because after solving the @m[(n -
#     1)!] subproblem the machine must still multiply the result by @m(n). The
#     controller must suspend its computation of @m(n!), solve the @m[(n - 1)!]
#     subproblem, then continue its computation of @m(n!). This view of the
#     factorial computation suggests the use of the subroutine mechanism described
#     in section @l(#5.1.3), which has the controller use a @c(continue) register to
#     transfer to the part of the sequence that solves a subproblem and then
#     continue where it left off on the main problem. We can thus make a factorial
#     subroutine that returns to the entry point stored in the @c(continue)
#     register. Around each subroutine call, we save and restore @c(continue) just
#     as we do the @c(n) register, since each @"(level) of the factorial computation
#     will use the same @c(continue) register. That is, the factorial subroutine
#     must put a new value in @c(continue) when it calls itself for a subproblem,
#     but it will need the old value in order to return to the place that called it
#     to solve a subproblem.
    Con la ayuda de la pila, podemos reutilizar una sola copia de las rutas de
    datos de la máquina factorial para cada subproblema factorial. Existe un
    problema de diseño similar al reutilizar la secuencia del controlador que
    opera las rutas de datos. Para volver a ejecutar la computación factorial,
    el controlador no puede simplemente volverse al principio, como con un
    proceso iterativo, porque después de resolver el @m[(n - 1)] ) Subproblema,
    la máquina debe multiplicar el resultado por @m(n). El controlador debe
    suspender su cálculo de @m(n! ), Resolver el @m[(n - 1)] ) Subproblema,
    entonces continúe su cómputo de @m(n! ). Esta visión del cálculo factorial
    sugiere el uso del mecanismo de subrutina descrito en la seccion @l(#5.1.3),
    @c(continue) Que tiene el controlador de utilizar un registro para
    transferir a la parte de la secuencia que resuelve un subproblema y luego
    continuar donde dejó en el problema principal. Podemos hacer una subrutina
    factorial que vuelve al punto de entrada almacenado en el @c(continue)
    registro. Alrededor de cada llamada de subrutina, guardamos y restauramos
    @c(continue) tal como hacemos el @c(n) registro, ya que cada @"(nivel) del
    cálculo factorial utilizará el mismo @c(continue) registro. Es decir, la
    subrutina factorial debe poner un nuevo valor @c(continue) cuando se llama a
    sí misma para un subproblema, pero necesitará el valor antiguo para volver
    al lugar que lo llamó para resolver un subproblema. Podemos hacer una
    subrutina factorial que vuelve al punto de entrada almacenado en el
    registro. Alrededor de cada llamada de subrutina, guardamos y restauramos
    tal como hacemos el registro, ya que cada @"(nivel) del cálculo factorial
    utilizará el mismo registro. Es decir, la subrutina factorial debe poner un
    nuevo valor cuando se llama a sí misma para un subproblema, pero necesitará
    el valor antiguo para volver al lugar que lo llamó para resolver un
    subproblema. Podemos hacer una subrutina factorial que vuelve al punto de
    entrada almacenado en el registro. Alrededor de cada llamada de subrutina,
    guardamos y restauramos tal como hacemos el registro, ya que cada @"(nivel)
    del cálculo factorial utilizará el mismo registro. Es decir, la subrutina
    factorial debe poner un nuevo valor cuando se llama a sí misma para un
    subproblema, pero necesitará el valor antiguo para volver al lugar que lo
    llamó para resolver un subproblema.

#     @l(#Figure 5.11) shows the data paths and controller for a machine that
#     implements the recursive @c(factorial) procedure. The machine has a stack and
#     three registers, called @c(n), @c(val), and @c(continue). To simplify the
#     data-path diagram, we have not named the register-assignment buttons, only the
#     stack-operation buttons (@c(sc) and @c(sn) to save registers, @c(rc) and
#     @c(rn) to restore registers). To operate the machine, we put in register @c(n)
#     the number whose factorial we wish to compute and start the machine. When the
#     machine reaches @c(fact-done), the computation is finished and the answer will
#     be found in the @c(val) register. In the controller sequence, @c(n) and
#     @c(continue) are saved before each recursive call and restored upon return
#     from the call. Returning from a call is accomplished by branching to the
#     location stored in @c(continue). @c(Continue) is initialized when the machine
#     starts so that the last return will go to @c(fact-done). The @c(val) register,
#     which holds the result of the factorial computation, is not saved before the
#     recursive call, because the old contents of @c(val) is not useful after the
#     subroutine returns. Only the new value, which is the value produced by the
#     subcomputation, is needed.
    @l(#Figura 5.11) muestra las rutas de datos y el controlador
    para una máquina que implementa el procedimiento @c(factorial) recursivo. La
    máquina dispone de una pila y tres registros, llamado @c(n), @c(val) y
    @c(continue). Para simplificar el diagrama de ruta de datos, no hemos
    nombrado los botones de asignación de registro, sólo los botones de
    operación de pila (@c(sc) y @c(sn) para guardar registros @c(rc) y @c(rn)
    restaurar registros). Para operar la máquina, ponemos en registro @c(n) el
    número cuyo factorial queremos calcular y arrancar la máquina. Cuando la
    máquina llega @c(fact-done), el cálculo termina y la respuesta se encuentra
    en el @c(val) registro. En la secuencia del controlador, @c(n) y
    @c(continue) se guardan antes de cada llamada recursiva y se restauran al
    regresar de la llamada. @c(continue) La devolución de una llamada se realiza
    mediante la ramificación a la ubicación almacenada en. @c(Continue) Se
    inicializa cuando la máquina se inicia de modo que el último retorno vaya a
    @c(fact-done). El @c(val) registro, que contiene el resultado del cálculo
    factorial, no se guarda antes de la llamada recursiva, porque el contenido
    antiguo de @c(val) no es útil después de que la subrutina regrese. Sólo se
    necesita el nuevo valor, que es el valor producido por la subcomputación.

#     ..figure > @t(Figure 5.11) A recursive factorial machine.
    ..figure > @t(Figura 5.11) Una máquina factorial recursiva.

#       ..art >
#                                      ___
#                                     ╱   ╲
#             ╭──────────●───────────(  =  )
#             │          │            ╲___╱
#            (X)         │              ▲
#             │          │              │
#             ▼          │          ╭───┴───╮    sn   ╭───────╮
#         ╭───────╮      │          │       ├───(X)──▶│       │
#         │  val  │◀─(X)─│──────────┤   n   │         │ stack │
#         ╰─────┬─╯      │          │       │◀──(X)───┤       │
#           ▲   │        │          ╰───────╯   rn    ╰─┬─────╯
#           │   │        │            │   ▲             │   ▲
#          (X)  │        │            │   │             │   │
#           │   │   ╭────┼────────────●  (X)            │  (X) sc
#           │   │   │    │            │   │         rc (X)  │
#           │   │   │    ●────────╮   │   │             │   │
#           │   ▼   ▼    │        ▼   ▼   │             ▼   │
#           │  ───────   │       ───────  │         ╭───────┴──╮
#           │  ╲  *  ╱   │       ╲  ─  ╱  │         │ continue ├──▶ controller
#           │   ──┬──    │        ──┬──   │         ╰──────────╯
#           │     │      │          │     │           ▲       ▲
#           ╰─────╯      │          ╰─────╯           │       │
#                        │                           (X)     (X)
#                        │                            │       │
#                       ╱ ╲                   after- ╱ ╲     ╱ ╲  fact-
#                      ╱ 1 ╲                  fact  ╱   ╲   ╱   ╲ done
#                     ╱_____╲                      ╱_____╲ ╱_____╲
#       < art..
      ..art >
                                     ___
                                    ╱   ╲
            ╭──────────●───────────(  =  )
            │          │            ╲___╱
           (X)         │              ▲
            │          │              │
            ▼          │          ╭───┴───╮    sn   ╭───────╮
        ╭───────╮      │          │       ├───(X)──▶│       │
        │  val  │◀─(X)─│──────────┤   n   │         │ stack │
        ╰─────┬─╯      │          │       │◀──(X)───┤       │
          ▲   │        │          ╰───────╯   rn    ╰─┬─────╯
          │   │        │            │   ▲             │   ▲
         (X)  │        │            │   │             │   │
          │   │   ╭────┼────────────●  (X)            │  (X) sc
          │   │   │    │            │   │         rc (X)  │
          │   │   │    ●────────╮   │   │             │   │
          │   ▼   ▼    │        ▼   ▼   │             ▼   │
          │  ───────   │       ───────  │         ╭───────┴──╮
          │  ╲  *  ╱   │       ╲  ─  ╱  │         │ continue ├──▶ controller
          │   ──┬──    │        ──┬──   │         ╰──────────╯
          │     │      │          │     │           ▲       ▲
          ╰─────╯      │          ╰─────╯           │       │
                       │                           (X)     (X)
                       │                            │       │
                      ╱ ╲                   after- ╱ ╲     ╱ ╲  fact-
                     ╱ 1 ╲                  fact  ╱   ╲   ╱   ╲ done
                    ╱_____╲                      ╱_____╲ ╱_____╲
      < art..

#       ..src > scheme
#         (controller
#            (assign continue (label fact-done))     ; set up final return address
#          fact-loop
#            (test (op =) (reg n) (const 1))
#            (branch (label base-case))
#            ;; Set up for the recursive call by saving n and continue.
#            ;; Set up continue so that the computation will continue
#            ;; at after-fact when the subroutine returns.
#            (save continue)
#            (save n)
#            (assign n (op -) (reg n) (const 1))
#            (assign continue (label after-fact))
#            (goto (label fact-loop))
#          after-fact
#            (restore n)
#            (restore continue)
#            (assign val (op *) (reg n) (reg val))   ; val now contains n(n − 1)!
#            (goto (reg continue))                   ; return to caller
#          base-case
#            (assign val (const 1))                  ; base case: 1! = 1
#            (goto (reg continue))                   ; return to caller
#          fact-done)
#       < src..
#     < figure..
      ..src > scheme
        (controller
           (assign continue (label fact-done))     ; set up final return address
         fact-loop
           (test (op =) (reg n) (const 1))
           (branch (label base-case))
           ;; Set up for the recursive call by saving n and continue.
           ;; Set up continue so that the computation will continue
           ;; at after-fact when the subroutine returns.
           (save continue)
           (save n)
           (assign n (op -) (reg n) (const 1))
           (assign continue (label after-fact))
           (goto (label fact-loop))
         after-fact
           (restore n)
           (restore continue)
           (assign val (op *) (reg n) (reg val))   ; val now contains n(n − 1)!
           (goto (reg continue))                   ; return to caller
         base-case
           (assign val (const 1))                  ; base case: 1! = 1
           (goto (reg continue))                   ; return to caller
         fact-done)
      < src..
    < figure..

# @   ..img > img/chap5/Fig5.11b.std.svg
@   ..img > img/chap5/Fig5.11b.std.svg

#     Although in principle the factorial computation requires an infinite machine,
#     the machine in @l(#Figure 5.11) is actually finite except for the stack, which
#     is potentially unbounded. Any particular physical implementation of a stack,
#     however, will be of finite size, and this will limit the depth of recursive
#     calls that can be handled by the machine. This implementation of factorial
#     illustrates the general strategy for realizing recursive algorithms as
#     ordinary register machines augmented by stacks. When a recursive subproblem is
#     encountered, we save on the stack the registers whose current values will be
#     required after the subproblem is solved, solve the recursive subproblem, then
#     restore the saved registers and continue execution on the main problem. The
#     @c(continue) register must always be saved. Whether there are other registers
#     that need to be saved depends on the particular machine, since not all
#     recursive computations need the original values of registers that are modified
#     during solution of the subproblem (see @l(#Exercise 5.4)).
    Aunque en principio la computación factorial requiere una máquina infinita,
    la máquina de la @l(#Figura 5.11) es en realidad finita,
    excepto para la pila, que es potencialmente ilimitada. Cualquier
    implementación física particular de una pila, sin embargo, será de tamaño
    finito, y esto limitará la profundidad de las llamadas recursivas que pueden
    ser manejadas por la máquina. Esta implementación factorial ilustra la
    estrategia general para la realización de algoritmos recursivos como
    máquinas registradoras ordinarias aumentadas por pilas. Cuando se encuentra
    un subproblema recursivo, guardamos en la pila los registros cuyos valores
    actuales serán necesarios después de resolver el subproblema, resolveremos
    el subproblema recursivo, restauraremos los registros guardados y
    continuaremos ejecutando el problema principal. El @c(continue) registro
    debe guardarse siempre. (ver @l(#Ejercicio 5.4))

# **** A double recursion
**** Una doble recursividad

#      Let us examine a more complex recursive process, the tree-recursive
#      computation of the Fibonacci numbers, which we introduced in section @l(#1.2.2):
     Examinemos un proceso recursivo más complejo, el cálculo recursivo-árbol de
     los números de Fibonacci, que introdujimos en la seccion @l(#1.2.2) :

#      ..src > scheme
#        (define (fib n)
#          (if (< n 2)
#              n
#              (+ (fib (- n 1)) (fib (- n 2)))))
#      < src..
     ..src > scheme
       (define (fib n)
         (if (< n 2)
             n
             (+ (fib (- n 1)) (fib (- n 2)))))
     < src..

#      Just as with factorial, we can implement the recursive Fibonacci computation
#      as a register machine with registers @c(n), @c(val), and @c(continue).  The
#      machine is more complex than the one for factorial, because there are two
#      places in the controller sequence where we need to perform recursive
#      calls––once to compute @m[Fib(n - 1)] and once to compute @m[Fib(n - 2)]. To
#      set up for each of these calls, we save the registers whose values will be
#      needed later, set the @c(n) register to the number whose Fib we need to
#      compute recursively (@m(n - 1) or @m(n - 2)), and assign to @c(continue) the
#      entry point in the main sequence to which to return (@c(afterfib-n-1) or
#      @c(afterfib-n-2), respectively). We then go to @c(fib-loop). When we return
#      from the recursive call, the answer is in @c(val). @l(#Figure 5.12) shows the
#      controller sequence for this machine.
     Al igual que con factorial, podemos implementar el cálculo recursivo de
     Fibonacci como una máquina registradora con registros @c(n), @c(val) y
     @c(continue). La máquina es más compleja que la factorial, ya que hay dos
     lugares en la secuencia del controlador donde necesitamos realizar llamadas
     recursivas: una para calcular @m(Fib (n - 1)) y otra para calcular @m(Fib
     (n - 2)). Para configurar cada una de estas llamadas, guardamos los
     registros cuyos valores serán necesarios más tarde, establecemos el @c(n)
     registro en el número cuyo Fib necesitamos calcular recursivamente (
     @m(n - 1) o @m(n - 2) ) y asignamos al @c(continue) punto de entrada en La
     secuencia principal a la que volver (@c(afterfib-n-1) o @c(afterfib-n-2),
     respectivamente). Entonces vamos a @c(fib-loop). Cuando volvemos de la
     llamada recursiva, @c(val) la respuesta está en. @l(#Figura
     5.12) muestra la secuencia del controlador para esta máquina.

#      ..figure > @t(Figure 5.12) Controller for a machine to compute Fibonacci
#        numbers.
     ..figure > @t(Figura 5.12) Controlador para una máquina para calcular
       números de Fibonacci.

#        ..src > scheme
#          (controller
#             (assign continue (label fib-done))
#           fib-loop
#             (test (op <) (reg n) (const 2))
#             (branch (label immediate-answer))
#             ;; set up to compute Fib(n − 1)
#             (save continue)
#             (assign continue (label afterfib-n-1))
#             (save n)           ; save old value of n
#             (assign n
#                     (op -)
#                     (reg n)
#                     (const 1)) ; clobber n to n-1
#             (goto
#              (label fib-loop)) ; perform recursive call
#           afterfib-n-1 ; upon return, val contains Fib(n − 1)
#             (restore n)
#             (restore continue)
#             ;; set up to compute Fib(n − 2)
#             (assign n (op -) (reg n) (const 2))
#             (save continue)
#             (assign continue (label afterfib-n-2))
#             (save val)         ; save Fib(n − 1)
#             (goto (label fib-loop))
#           afterfib-n-2 ; upon return, val contains Fib(n − 2)
#             (assign n
#                     (reg val)) ; n now contains Fib(n − 2)
#             (restore val)      ; val now contains Fib(n − 1)
#             (restore continue)
#             (assign val        ; Fib(n − 1) + Fib(n − 2)
#                     (op +)
#                     (reg val)
#                     (reg n))
#             (goto              ; return to caller,
#              (reg continue))   ; answer is in val
#           immediate-answer
#             (assign val
#                     (reg n))   ; base case: Fib(n) = n
#             (goto (reg continue))
#           fib-done)
#        < src..
       ..src > scheme
         (controller
            (assign continue (label fib-done))
          fib-loop
            (test (op <) (reg n) (const 2))
            (branch (label immediate-answer))
            ;; set up to compute Fib(n − 1)
            (save continue)
            (assign continue (label afterfib-n-1))
            (save n)           ; save old value of n
            (assign n
                    (op -)
                    (reg n)
                    (const 1)) ; clobber n to n-1
            (goto
             (label fib-loop)) ; perform recursive call
          afterfib-n-1 ; upon return, val contains Fib(n − 1)
            (restore n)
            (restore continue)
            ;; set up to compute Fib(n − 2)
            (assign n (op -) (reg n) (const 2))
            (save continue)
            (assign continue (label afterfib-n-2))
            (save val)         ; save Fib(n − 1)
            (goto (label fib-loop))
          afterfib-n-2 ; upon return, val contains Fib(n − 2)
            (assign n
                    (reg val)) ; n now contains Fib(n − 2)
            (restore val)      ; val now contains Fib(n − 1)
            (restore continue)
            (assign val        ; Fib(n − 1) + Fib(n − 2)
                    (op +)
                    (reg val)
                    (reg n))
            (goto              ; return to caller,
             (reg continue))   ; answer is in val
          immediate-answer
            (assign val
                    (reg n))   ; base case: Fib(n) = n
            (goto (reg continue))
          fib-done)
       < src..

#      :: @t(Exercise 5.4) :: Specify register machines that implement each of the
#         following procedures. For each machine, write a controller instruction
#         sequence and draw a diagram showing the data paths.
     :: @t(Ejercicio 5.4) :: Especifique las máquinas de registro que
        implementan cada uno de los procedimientos siguientes. Para cada
        máquina, escriba una secuencia de instrucciones del controlador y dibuje
        un diagrama que muestre las rutas de datos.

#         1. Recursive exponentiation:
        1. Exponenciación recursiva:

#            ..src > scheme
#              (define (expt b n)
#                (if (= n 0)
#                    1
#                    (* b (expt b (- n 1)))))
#            < src..
           ..src > scheme
             (define (expt b n)
               (if (= n 0)
                   1
                   (* b (expt b (- n 1)))))
           < src..

#         2. Iterative exponentiation:
        2. Exponenciación iterativa:

#            ..src > scheme
#              (define (expt b n)
#                (define (expt-iter counter product)
#                  (if (= counter 0)
#                      product
#                      (expt-iter (- counter 1)
#                                 (* b product))))
#                (expt-iter n 1))
#            < src..
           ..src > scheme
             (define (expt b n)
               (define (expt-iter counter product)
                 (if (= counter 0)
                     product
                     (expt-iter (- counter 1)
                                (* b product))))
               (expt-iter n 1))
           < src..

#      :: @t(Exercise 5.5) :: Hand-simulate the factorial and Fibonacci machines,
#         using some nontrivial input (requiring execution of at least one recursive
#         call). Show the contents of the stack at each significant point in the
#         execution.
     :: @t(Ejercicio 5.5) :: Simula a mano las máquinas factorial y Fibonacci,
        utilizando una entrada no trivial (que requiere la ejecución de al menos
        una llamada recursiva). Muestre el contenido de la pila en cada punto
        significativo de la ejecución.


#      :: @t(Exercise 5.6) :: Ben Bitdiddle observes that the Fibonacci machine's
#         controller sequence has an extra @c(save) and an extra @c(restore), which
#         can be removed to make a faster machine. Where are these instructions?
     :: @t(Ejercicio 5.6) :: Ben Bitdiddle observa que la secuencia del
        controlador de la máquina Fibonacci tiene un extra @c(save) y un extra
        @c(restore), que se puede quitar para hacer una máquina más
        rápida. ¿Dónde están estas instrucciones?

# *** 5.1.5 <> Instruction Summary
*** 5.1.5 <> Resumen de instrucciones

#     A controller instruction in our register-machine language has one of the
#     following forms, where each @m[⟨inputᵢ⟩] is either @c[(reg ⟨register-name⟩)]
#     or @c[(const ⟨constant-value⟩)].  These instructions were introduced in
#     @l(#5.1.1):
    Una instrucción de controlador en nuestro lenguaje de registro-máquina tiene
    uno de los siguientes formularios, donde cada @m(⟨inputᵢ⟩) es @c[(reg
    ⟨register-name⟩)] o bien @c[(const ⟨constant-value⟩)]. Estas instrucciones
    fueron introducidas en la seccion @l(#5.1.1) :

#     ..src > scheme
#       (assign ⟨register-name⟩ (reg ⟨register-name⟩))
#       (assign ⟨register-name⟩
#               (const ⟨constant-value⟩))
#       (assign ⟨register-name⟩
#               (op ⟨operation-name⟩)
#               ⟨input₁⟩ … ⟨inputₙ⟩)
#       (perform (op ⟨operation-name⟩)
#                ⟨input₁⟩
#                …
#                ⟨inputₙ⟩)
#       (test (op ⟨operation-name⟩)
#             ⟨input₁⟩
#             …
#             ⟨inputₙ⟩)
#       (branch (label ⟨label-name⟩))
#       (goto (label ⟨label-name⟩))
#     < src..
    ..src > scheme
      (assign ⟨register-name⟩ (reg ⟨register-name⟩))
      (assign ⟨register-name⟩
              (const ⟨constant-value⟩))
      (assign ⟨register-name⟩
              (op ⟨operation-name⟩)
              ⟨input₁⟩ … ⟨inputₙ⟩)
      (perform (op ⟨operation-name⟩)
               ⟨input₁⟩
               …
               ⟨inputₙ⟩)
      (test (op ⟨operation-name⟩)
            ⟨input₁⟩
            …
            ⟨inputₙ⟩)
      (branch (label ⟨label-name⟩))
      (goto (label ⟨label-name⟩))
    < src..

#     The use of registers to hold labels was introduced in section @l(#5.1.3):
    El uso de registros para mantener las etiquetas se introdujo en
    @l(#5.1.3) :

#     ..src > scheme
#       (assign ⟨register-name⟩ (label ⟨label-name⟩))
#       (goto (reg ⟨register-name⟩))
#     < src..
    ..src > scheme
      (assign ⟨register-name⟩ (label ⟨label-name⟩))
      (goto (reg ⟨register-name⟩))
    < src..

#     Instructions to use the stack were introduced in section @l(#5.1.4):
    Las instrucciones para usar la pila fueron introducidas en
    @l(#5.1.4) :

#     ..src > scheme
#       (save ⟨register-name⟩)
#       (restore ⟨register-name⟩)
#     < src..
    ..src > scheme
      (save ⟨register-name⟩)
      (restore ⟨register-name⟩)
    < src..

#     The only kind of @c[(constant-value)] we have seen so far is a number, but
#     later we will use strings, symbols, and lists.  For example,
    El único tipo de @c[(constant-value)] que hemos visto hasta ahora es un
    número, pero más tarde utilizaremos cadenas, símbolos y listas. Por ejemplo,

#     - @c[(const "abc")] is the string @c("abc"),
    - @c[(const "abc")] Es la cadena @c("abc"),

#     - @c[(const abc)] is the symbol @c(abc),
    - @c[(const abc)] Es el símbolo @c(abc),

#     - @c[(const (a b c))] is the list @c[(a b c)],
    - @c[(const (a b c))] Es la lista @c[(a b c)],

#     - and @c[(const ())] is the empty list.
    - Y @c[(const ())] es la lista vacía.

# ** 5.2 <> A Register-Machine Simulator
** 5.2 <> Un Simulador de Máquina de Registro

#    In order to gain a good understanding of the design of register machines, we
#    must test the machines we design to see if they perform as expected. One way
#    to test a design is to hand-simulate the operation of the controller, as in
#    @l(#Exercise 5.5). But this is extremely tedious for all but the simplest
#    machines. In this section we construct a simulator for machines described in
#    the register-machine language. The simulator is a Scheme program with four
#    interface procedures. The first uses a description of a register machine to
#    construct a model of the machine (a data structure whose parts correspond to
#    the parts of the machine to be simulated), and the other three allow us to
#    simulate the machine by manipulating the model:
   Con el fin de obtener una buena comprensión del diseño de las máquinas de
   registro, debemos probar las máquinas que diseñamos para ver si funcionan
   como se esperaba. Una forma de probar un diseño es simular a mano la
   operación del controlador, como en el @l(#Ejercicio 5.5). Pero
   esto es extremadamente tedioso para todas las máquinas, excepto las más
   simples. En esta sección se construye un simulador para máquinas descrito en
   el lenguaje registro-máquina. El simulador es un programa Scheme con cuatro
   procedimientos de interfaz. El primero utiliza una descripción de una máquina
   registradora para construir un modelo de la máquina (una estructura de datos
   cuyas partes corresponden a las partes de la máquina a simular), y los otros
   tres nos permiten simular la máquina manipulando el modelo:

#    ..tab >
   ..tab >
#      ..src > scheme
#        (make-machine ⟨register-names⟩
#                      ⟨operations⟩
#                      ⟨controller⟩)
#      < src..
     ..src > scheme
       (make-machine ⟨register-names⟩
                     ⟨operations⟩
                     ⟨controller⟩)
     < src..

#      constructs and returns a model of the machine with the given registers,
#      operations, and controller.
     Construye y devuelve un modelo de la máquina con los registros, las
     operaciones y el controlador dados.

#      ..src > scheme
#        (set-register-contents! ⟨machine-model⟩
#                                ⟨register-name⟩
#                                ⟨value⟩)
#      < src..
     ..src > scheme
       (set-register-contents! ⟨machine-model⟩
                               ⟨register-name⟩
                               ⟨value⟩)
     < src..

#      stores a value in a simulated register in the given machine.
     Almacena un valor en un registro simulado en la máquina dada.

#      ..src > scheme
#        (get-register-contents ⟨machine-model⟩
#                               ⟨register-name⟩)
#      < src..
     ..src > scheme
       (get-register-contents ⟨machine-model⟩
                              ⟨register-name⟩)
     < src..

#      returns the contents of a simulated register in the given machine.
     Devuelve el contenido de un registro simulado en la máquina dada.

#      ..src > scheme
#        (start ⟨machine-model⟩)
#      < src..
     ..src > scheme
       (start ⟨machine-model⟩)
     < src..

#      simulates the execution of the given machine, starting from the beginning of
#      the controller sequence and stopping when it reaches the end of the
#      sequence.
     Simula la ejecución de la máquina dada, comenzando desde el principio de la
     secuencia del controlador y deteniéndose cuando llega al final de la
     secuencia.
#    < tab..
   < tab..

#    As an example of how these procedures are used, we can define @c(gcd-machine)
#    to be a model of the @A(GCD) machine of section @l(#5.1.1) as follows:
   Como ejemplo de cómo se usan estos procedimientos, podemos definir
   @c(gcd-machine) para ser un modelo de la máquina @A(GCD) de la seccion @l(#5.1.1)
   como sigue:

#    ..src > scheme
#      (define gcd-machine
#        (make-machine
#         '(a b t)
#         (list (list 'rem remainder) (list '= =))
#         '(test-b
#             (test (op =) (reg b) (const 0))
#             (branch (label gcd-done))
#             (assign t (op rem) (reg a) (reg b))
#             (assign a (reg b))
#             (assign b (reg t))
#             (goto (label test-b))
#           gcd-done)))
#    < src..
   ..src > scheme
     (define gcd-machine
       (make-machine
        '(a b t)
        (list (list 'rem remainder) (list '= =))
        '(test-b
            (test (op =) (reg b) (const 0))
            (branch (label gcd-done))
            (assign t (op rem) (reg a) (reg b))
            (assign a (reg b))
            (assign b (reg t))
            (goto (label test-b))
          gcd-done)))
   < src..

#    The first argument to @c(make-machine) is a list of register names. The next
#    argument is a table (a list of two-element lists) that pairs each operation
#    name with a Scheme procedure that implements the operation (that is, produces
#    the same output value given the same input values). The last argument
#    specifies the controller as a list of labels and machine instructions, as in
#    @l(#5.1).
   El primer argumento a @c(make-machine) es una lista de nombres de
   registro. El siguiente argumento es una tabla (una lista de listas de dos
   elementos) que empareja cada nombre de operación con un procedimiento Scheme
   que implementa la operación (es decir, produce el mismo valor de salida dado
   los mismos valores de entrada). El último argumento especifica el controlador
   como una lista de etiquetas e instrucciones de máquina, como en
   @l(#5.1).

#    To compute @A(GCD)s with this machine, we set the input registers, start the
#    machine, and examine the result when the simulation terminates:
   Para calcular @A(GCD) s con esta máquina, ajustamos los registros de entrada,
   arrancamos la máquina y examinamos el resultado cuando termina la simulación:

#    ..srci > scheme
#      > (set-register-contents! gcd-machine 'a 206)
#      done
#      > (set-register-contents! gcd-machine 'b 40)
#      done
#      > (start gcd-machine)
#      done
#      > (get-register-contents gcd-machine 'a)
#      2
#    < srci..
   ..srci > scheme
     > (set-register-contents! gcd-machine 'a 206)
     done
     > (set-register-contents! gcd-machine 'b 40)
     done
     > (start gcd-machine)
     done
     > (get-register-contents gcd-machine 'a)
     2
   < srci..

#    This computation will run much more slowly than a @c(gcd) procedure written in
#    Scheme, because we will simulate low-level machine instructions, such as
#    @c(assign), by much more complex operations.
   Este cálculo se ejecutará mucho más lentamente que un procedimiento @c(gcd)
   escrito en Scheme, porque vamos a simular las instrucciones de máquina de
   bajo nivel, como @c(assign), por operaciones mucho más complejas.

#    :: @t(Exercise 5.7) :: Use the simulator to test the machines you designed in
#       @l(#Exercise 5.4).
   :: @t(Ejercicio 5.7) :: Utilice el simulador para probar las máquinas que
      diseñó en el @l(#Ejercicio 5.4).

# *** 5.2.1 <> The Machine Model
*** 5.2.1 <> El modelo de máquina

#     The machine model generated by @c(make-machine) is represented as a procedure
#     with local state using the message-passing techniques developed in @l(#Chapter
#     3). To build this model, @c(make-machine) begins by calling the procedure
#     @c(make-new-machine) to construct the parts of the machine model that are
#     common to all register machines. This basic machine model constructed by
#     @c(make-new-machine) is essentially a container for some registers and a
#     stack, together with an execution mechanism that processes the controller
#     instructions one by one.
    El modelo de máquina generado por @c(make-machine) se representa como un
    procedimiento con estado local utilizando las técnicas de paso de mensajes
    desarrolladas en el @l(#Capitulo 3). Para construir este modelo,
    @c(make-machine) comienza llamando al procedimiento @c(make-new-machine)
    para construir las partes del modelo de máquina que son comunes a todas las
    máquinas de registro. Este modelo básico de máquina construido por
    @c(make-new-machine) es esencialmente un contenedor para algunos registros y
    una pila, junto con un mecanismo de ejecución que procesa las instrucciones
    del controlador una por una.

#     @c(Make-machine) then extends this basic model (by sending it messages) to
#     include the registers, operations, and controller of the particular machine
#     being defined. First it allocates a register in the new machine for each of
#     the supplied register names and installs the designated operations in the
#     machine. Then it uses an @e(assembler) (described below in section @l(#5.2.2)) to
#     transform the controller list into instructions for the new machine and
#     installs these as the machine's instruction sequence.  @c(Make-machine)
#     returns as its value the modified machine model.
    @c(Make-machine) Luego extiende este modelo básico (enviándolo mensajes)
    para incluir los registros, operaciones y controlador de la máquina
    particular que está siendo definida. Primero asigna un registro en la nueva
    máquina para cada uno de los nombres de registro suministrados e instala las
    operaciones designadas en la máquina. A continuación, utiliza un
    @e(ensamblador) (descrito a continuación en la seccion @l(#5.2.2)) para
    transformar la lista de controladores en instrucciones para la nueva máquina
    e instala éstos como secuencia de instrucciones de la máquina.
    @c(Make-machine) Devuelve como su valor el modelo de máquina modificado.

#     ..src > scheme
#       (define (make-machine register-names
#                             ops
#                             controller-text)
#         (let ((machine (make-new-machine)))
#           (for-each (lambda (register-name)
#                       ((machine 'allocate-register)
#                        register-name))
#                     register-names)
#           ((machine 'install-operations) ops)
#           ((machine 'install-instruction-sequence)
#            (assemble controller-text machine))
#           machine))
#     < src..
    ..src > scheme
      (define (make-machine register-names
                            ops
                            controller-text)
        (let ((machine (make-new-machine)))
          (for-each (lambda (register-name)
                      ((machine 'allocate-register)
                       register-name))
                    register-names)
          ((machine 'install-operations) ops)
          ((machine 'install-instruction-sequence)
           (assemble controller-text machine))
          machine))
    < src..

# **** Registers
**** Registros

#      We will represent a register as a procedure with local state, as in
#      @l(#Chapter 3). The procedure @c(make-register) creates a register that holds
#      a value that can be accessed or changed:
     Representaremos un registro como un procedimiento con estado local, como en
     el @l(#Capitulo 3). El procedimiento @c(make-register) crea un
     registro que contiene un valor al que se puede acceder o cambiar:

#      ..src > scheme
#        (define (make-register name)
#          (let ((contents '*unassigned*))
#            (define (dispatch message)
#              (cond ((eq? message 'get) contents)
#                    ((eq? message 'set)
#                     (lambda (value)
#                       (set! contents value)))
#                    (else
#                     (error "Unknown request:
#                             REGISTER"
#                            message))))
#            dispatch))
#      < src..
     ..src > scheme
       (define (make-register name)
         (let ((contents '*unassigned*))
           (define (dispatch message)
             (cond ((eq? message 'get) contents)
                   ((eq? message 'set)
                    (lambda (value)
                      (set! contents value)))
                   (else
                    (error "Unknown request:
                            REGISTER"
                           message))))
           dispatch))
     < src..

#      The following procedures are used to access registers:
     Para acceder a los registros se utilizan los siguientes procedimientos:

#      ..src > scheme
#        (define (get-contents register)
#          (register 'get))
#
#        (define (set-contents! register value)
#          ((register 'set) value))
#      < src..
     ..src > scheme
       (define (get-contents register)
         (register 'get))

       (define (set-contents! register value)
         ((register 'set) value))
     < src..

# **** The stack
**** La pila

#      We can also represent a stack as a procedure with local state. The procedure
#      @c(make-stack) creates a stack whose local state consists of a list of the
#      items on the stack. A stack accepts requests to @c(push) an item onto the
#      stack, to @c(pop) the top item off the stack and return it, and to
#      @c(initialize) the stack to empty.
     También podemos representar una pila como un procedimiento con estado
     local. El procedimiento @c(make-stack) crea una pila cuyo estado local
     consiste en una lista de los elementos de la pila. Una pila acepta
     solicitudes a @c(push) un elemento en la pila, al @c(pop) elemento superior
     de la pila y devolverlo, y a @c(initialize) la pila para vaciar.

#      ..src > scheme
#        (define (make-stack)
#          (let ((s '()))
#            (define (push x)
#              (set! s (cons x s)))
#            (define (pop)
#              (if (null? s)
#                  (error "Empty stack: POP")
#                  (let ((top (car s)))
#                    (set! s (cdr s))
#                    top)))
#            (define (initialize)
#              (set! s '())
#              'done)
#            (define (dispatch message)
#              (cond ((eq? message 'push) push)
#                    ((eq? message 'pop) (pop))
#                    ((eq? message 'initialize)
#                     (initialize))
#                    (else
#                     (error "Unknown request: STACK"
#                            message))))
#            dispatch))
#      < src..
     ..src > scheme
       (define (make-stack)
         (let ((s '()))
           (define (push x)
             (set! s (cons x s)))
           (define (pop)
             (if (null? s)
                 (error "Empty stack: POP")
                 (let ((top (car s)))
                   (set! s (cdr s))
                   top)))
           (define (initialize)
             (set! s '())
             'done)
           (define (dispatch message)
             (cond ((eq? message 'push) push)
                   ((eq? message 'pop) (pop))
                   ((eq? message 'initialize)
                    (initialize))
                   (else
                    (error "Unknown request: STACK"
                           message))))
           dispatch))
     < src..

#      The following procedures are used to access stacks:
     Los siguientes procedimientos se utilizan para acceder a las pilas:

#      ..src > scheme
#        (define (pop stack) (stack 'pop))
#        (define (push stack value)
#          ((stack 'push) value))
#      < src..
     ..src > scheme
       (define (pop stack) (stack 'pop))
       (define (push stack value)
         ((stack 'push) value))
     < src..

# **** The basic machine
**** La máquina básica

#      The @c(make-new-machine) procedure, shown in @l(#Figure 5.13), constructs
#      an object whose local state consists of a stack, an initially empty
#      instruction sequence, a list of operations that initially contains an
#      operation to initialize the stack, and a @e(register table) that initially
#      contains two registers, named @c(flag) and @c(pc) (for @"(program
#      counter)). The internal procedure @c(allocate-register) adds new entries to
#      the register table, and the internal procedure @c(lookup-register) looks up
#      registers in the table.
     El procedimiento @c(make-new-machine), que se muestra en la
     @l(#Figura 5.13,) construye un objeto cuyo estado
     local consiste en una pila, una secuencia de instrucciones inicialmente
     vacía, una lista de operaciones que contiene inicialmente una operación
     para inicializar la pila y una @e(tabla de registro) que contiene
     inicialmente Dos registros, nombrados @c(flag) y @c(pc)(para el @"(contador
     del programa) ). El procedimiento interno @c(allocate-register) agrega
     nuevas entradas a la tabla de registro y el procedimiento interno
     @c(lookup-register) busca registros en la tabla.

#      ..figure > @t(Figure 5.13) The @c(make-new-machine) procedure, which
#        implements the basic machine model.
     ..figure > @t(Figura 5.13) El procedimiento @c(make-new-machine), que
       implementa el modelo básico de la máquina.

#        ..src > scheme
#          (define (make-new-machine)
#            (let ((pc (make-register 'pc))
#                  (flag (make-register 'flag))
#                  (stack (make-stack))
#                  (the-instruction-sequence '()))
#              (let ((the-ops
#                     (list
#                      (list 'initialize-stack
#                            (lambda ()
#                              (stack 'initialize)))))
#                    (register-table
#                     (list (list 'pc pc)
#                           (list 'flag flag))))
#                (define (allocate-register name)
#                  (if (assoc name register-table)
#                      (error
#                       "Multiply defined register: "
#                       name)
#                      (set! register-table
#                            (cons
#                             (list name
#                                   (make-register name))
#                             register-table)))
#                  'register-allocated)
#                (define (lookup-register name)
#                  (let ((val
#                         (assoc name register-table)))
#                    (if val
#                        (cadr val)
#                        (error "Unknown register:"
#                               name))))
#                (define (execute)
#                  (let ((insts (get-contents pc)))
#                    (if (null? insts)
#                        'done
#                        (begin
#                          ((instruction-execution-proc
#                            (car insts)))
#                          (execute)))))
#                (define (dispatch message)
#                  (cond ((eq? message 'start)
#                         (set-contents!
#                          pc
#                          the-instruction-sequence)
#                         (execute))
#                        ((eq?
#                          message
#                          'install-instruction-sequence)
#                         (lambda (seq)
#                           (set!
#                            the-instruction-sequence
#                            seq)))
#                        ((eq? message
#                              'allocate-register)
#                         allocate-register)
#                        ((eq? message 'get-register)
#                         lookup-register)
#                        ((eq? message
#                              'install-operations)
#                         (lambda (ops)
#                           (set! the-ops
#                                 (append the-ops ops))))
#                        ((eq? message 'stack) stack)
#                        ((eq? message 'operations)
#                         the-ops)
#                        (else (error "Unknown request:
#                                      MACHINE"
#                                     message))))
#                dispatch)))
#        < src..
       ..src > scheme
         (define (make-new-machine)
           (let ((pc (make-register 'pc))
                 (flag (make-register 'flag))
                 (stack (make-stack))
                 (the-instruction-sequence '()))
             (let ((the-ops
                    (list
                     (list 'initialize-stack
                           (lambda ()
                             (stack 'initialize)))))
                   (register-table
                    (list (list 'pc pc)
                          (list 'flag flag))))
               (define (allocate-register name)
                 (if (assoc name register-table)
                     (error
                      "Multiply defined register: "
                      name)
                     (set! register-table
                           (cons
                            (list name
                                  (make-register name))
                            register-table)))
                 'register-allocated)
               (define (lookup-register name)
                 (let ((val
                        (assoc name register-table)))
                   (if val
                       (cadr val)
                       (error "Unknown register:"
                              name))))
               (define (execute)
                 (let ((insts (get-contents pc)))
                   (if (null? insts)
                       'done
                       (begin
                         ((instruction-execution-proc
                           (car insts)))
                         (execute)))))
               (define (dispatch message)
                 (cond ((eq? message 'start)
                        (set-contents!
                         pc
                         the-instruction-sequence)
                        (execute))
                       ((eq?
                         message
                         'install-instruction-sequence)
                        (lambda (seq)
                          (set!
                           the-instruction-sequence
                           seq)))
                       ((eq? message
                             'allocate-register)
                        allocate-register)
                       ((eq? message 'get-register)
                        lookup-register)
                       ((eq? message
                             'install-operations)
                        (lambda (ops)
                          (set! the-ops
                                (append the-ops ops))))
                       ((eq? message 'stack) stack)
                       ((eq? message 'operations)
                        the-ops)
                       (else (error "Unknown request:
                                     MACHINE"
                                    message))))
               dispatch)))
       < src..

#      The @c(flag) register is used to control branching in the simulated machine.
#      @c(Test) instructions set the contents of @c(flag) to the result of the test
#      (true or false). @c(Branch) instructions decide whether or not to branch by
#      examining the contents of @c(flag).
     El @c(flag) registro se utiliza para controlar la ramificación en la
     máquina simulada. @c(Test) Instrucciones establecen el contenido del
     @c(flag) resultado de la prueba (verdadero o falso). @c(Branch)
     Instrucciones para decidir si procede o no a la sucursal examinando el
     contenido de @c(flag).

#      The @c(pc) register determines the sequencing of instructions as the machine
#      runs. This sequencing is implemented by the internal procedure @c(execute).
#      In the simulation model, each machine instruction is a data structure that
#      includes a procedure of no arguments, called the @e(instruction execution
#      procedure), such that calling this procedure simulates executing the
#      instruction. As the simulation runs, @c(pc) points to the place in the
#      instruction sequence beginning with the next instruction to be executed.
#      @c(Execute) gets that instruction, executes it by calling the instruction
#      execution procedure, and repeats this cycle until there are no more
#      instructions to execute (i.e., until @c(pc) points to the end of the
#      instruction sequence).
     El @c(pc) registro determina la secuencia de las instrucciones a medida que
     la máquina se ejecuta. Esta secuencia se implementa mediante el
     procedimiento interno @c(execute). En el modelo de simulación, cada
     instrucción de máquina es una estructura de datos que incluye un
     procedimiento sin argumentos, denominado @e(procedimiento de ejecución de
     instrucciones), de tal manera que al llamar a este procedimiento se simula
     la ejecución de la instrucción. A medida que se ejecuta la simulación, se
     @c(pc) señala el lugar en la secuencia de instrucciones que comienza con la
     siguiente instrucción a ejecutar. @c(Execute) Obtiene esa instrucción, la
     ejecuta llamando al procedimiento de ejecución de la instrucción, y repite
     este ciclo hasta que no haya más instrucciones de ejecutar (es decir, hasta
     los @c(pc) puntos al final de la secuencia de instrucciones).

#      As part of its operation, each instruction execution procedure modifies @c(pc)
#      to indicate the next instruction to be executed. @c(Branch) and @c(goto)
#      instructions change @c(pc) to point to the new destination. All other
#      instructions simply advance @c(pc), making it point to the next instruction in
#      the sequence. Observe that each call to @c(execute) calls @c(execute) again,
#      but this does not produce an infinite loop because running the instruction
#      execution procedure changes the contents of @c(pc).
     Como parte de su funcionamiento, cada procedimiento de ejecución de
     instrucciones se modifica @c(pc) para indicar la siguiente instrucción a
     ejecutar. @c(Branch) Y las @c(goto) instrucciones cambian @c(pc) para
     apuntar al nuevo destino. Todas las demás instrucciones simplemente avanzan
     @c(pc), haciendo que apunte a la siguiente instrucción en la
     secuencia. Observe que cada llamada a @c(execute) llamadas de @c(execute)
     nuevo, pero esto no produce un bucle infinito porque ejecutar el
     procedimiento de ejecución de instrucción cambia el contenido de @c(pc).

#      @c(Make-new-machine) returns a @c(dispatch) procedure that implements
#      message-passing access to the internal state. Notice that starting the machine
#      is accomplished by setting @c(pc) to the beginning of the instruction sequence
#      and calling @c(execute).
     @c(Make-new-machine) Devuelve un procedimiento @c(dispatch) que implementa
     el acceso de paso de mensajes al estado interno. Observe que el arranque de
     la máquina se realiza estableciendo @c(pc) el comienzo de la secuencia de
     instrucciones y la llamada @c(execute).

#      For convenience, we provide an alternate procedural interface to a machine's
#      @c(start) operation, as well as procedures to set and examine register
#      contents, as specified at the beginning of section @l(#5.2):
     Para mayor comodidad, ofrecemos una interfaz de procedimiento alternativa
     al @c(start) funcionamiento de la máquina, así como procedimientos para
     establecer y examinar el contenido del registro, tal como se especifica al
     principio de la seccion @l(#5.2) :

#      ..src > scheme
#        (define (start machine)
#          (machine 'start))
#
#        (define (get-register-contents
#                 machine register-name)
#          (get-contents
#           (get-register machine register-name)))
#
#        (define (set-register-contents!
#                 machine register-name value)
#          (set-contents!
#           (get-register machine register-name)
#           value)
#          'done)
#      < src..
     ..src > scheme
       (define (start machine)
         (machine 'start))

       (define (get-register-contents
                machine register-name)
         (get-contents
          (get-register machine register-name)))

       (define (set-register-contents!
                machine register-name value)
         (set-contents!
          (get-register machine register-name)
          value)
         'done)
     < src..

#      These procedures (and many procedures in section @l(#5.2.2) and @l(#5.2.3)) use the
#      following to look up the register with a given name in a given machine:
     Estos procedimientos (y muchos procedimientos en la seccion @l(#5.2.2) y
     @l(#5.2.3)) usan lo siguiente para buscar el registro con un nombre
     dado en una máquina dada:

#      ..src > scheme
#        (define (get-register machine reg-name)
#          ((machine 'get-register) reg-name))
#      < src..
     ..src > scheme
       (define (get-register machine reg-name)
         ((machine 'get-register) reg-name))
     < src..

# *** 5.2.2 <> The Assembler
*** 5.2.2 <> El ensamblador

#     The assembler transforms the sequence of controller expressions for a machine
#     into a corresponding list of machine instructions, each with its execution
#     procedure. Overall, the assembler is much like the evaluators we studied in
#     @l(#Chapter 4)––there is an input language (in this case, the register-machine
#     language) and we must perform an appropriate action for each type of
#     expression in the language.
    El ensamblador transforma la secuencia de expresiones del controlador para
    una máquina en una lista correspondiente de instrucciones de máquina, cada
    una con su procedimiento de ejecución. En general, el ensamblador es muy
    similar a los evaluadores que estudiamos en el @l(Capitulo 4 -)
    hay un lenguaje de entrada (en este caso, el lenguaje de registro-máquina) y
    debemos realizar una acción apropiada para cada tipo de expresión en el
    lenguaje.

#     The technique of producing an execution procedure for each instruction is just
#     what we used in section @l(#4.1.7) to speed up the evaluator by separating analysis
#     from runtime execution. As we saw in @l(#Chapter 4), much useful analysis of
#     Scheme expressions could be performed without knowing the actual values of
#     variables. Here, analogously, much useful analysis of register-machine-language
#     expressions can be performed without knowing the actual contents of machine
#     registers. For example, we can replace references to registers by pointers to
#     the register objects, and we can replace references to labels by pointers to
#     the place in the instruction sequence that the label designates.
    La técnica de producir un procedimiento de ejecución para cada instrucción
    es justamente lo que usamos en la seccion @l(#4.1.7) para acelerar el evaluador
    separando el análisis de la ejecución en tiempo de ejecución. Como vimos en
    el @l(Capitulo 4), mucho análisis útil de las expresiones de
    Scheme podría realizarse sin conocer los valores reales de las
    variables. Aquí, análogamente, se puede realizar un análisis muy útil de las
    expresiones del lenguaje de registro-máquina sin conocer el contenido real
    de los registros de la máquina. Por ejemplo, podemos sustituir referencias a
    registros por punteros a los objetos de registro, y podemos reemplazar
    referencias a etiquetas por punteros al lugar en la secuencia de
    instrucciones que designa la etiqueta.

#     Before it can generate the instruction execution procedures, the assembler
#     must know what all the labels refer to, so it begins by scanning the
#     controller text to separate the labels from the instructions. As it scans the
#     text, it constructs both a list of instructions and a table that associates
#     each label with a pointer into that list. Then the assembler augments the
#     instruction list by inserting the execution procedure for each instruction.
    Antes de poder generar los procedimientos de ejecución de la instrucción, el
    ensamblador debe saber a qué se refieren todas las etiquetas, por lo que
    comienza escaneando el texto del controlador para separar las etiquetas de
    las instrucciones. Al escanear el texto, construye una lista de
    instrucciones y una tabla que asocia cada etiqueta con un puntero en esa
    lista. A continuación, el ensamblador aumenta la lista de instrucciones
    insertando el procedimiento de ejecución para cada instrucción.

#     The @c(assemble) procedure is the main entry to the assembler. It takes the
#     controller text and the machine model as arguments and returns the instruction
#     sequence to be stored in the model. @c(Assemble) calls @c(extract-labels) to
#     build the initial instruction list and label table from the supplied
#     controller text. The second argument to @c(extract-labels) is a procedure to
#     be called to process these results: This procedure uses @c(update-insts!) to
#     generate the instruction execution procedures and insert them into the
#     instruction list, and returns the modified list.
    El procedimiento @c(assemble) es la entrada principal al ensamblador. Toma
    el texto del controlador y el modelo de la máquina como argumentos y
    devuelve la secuencia de instrucciones que se almacenará en el
    modelo. @c(Assemble) Llamadas @c(extract-labels) para crear la lista de
    instrucciones inicial y la tabla de etiquetas del texto del controlador
    suministrado. El segundo argumento a @c(extract-labels) es un procedimiento
    a ser llamado para procesar estos resultados: Este procedimiento utiliza
    @c(update-insts!) para generar los procedimientos de ejecución de
    instrucciones e insertarlos en la lista de instrucciones y devuelve la lista
    modificada.

#     ..src > scheme
#       (define (assemble controller-text machine)
#         (extract-labels controller-text
#           (lambda (insts labels)
#             (update-insts! insts labels machine)
#             insts)))
#     < src..
    ..src > scheme
      (define (assemble controller-text machine)
        (extract-labels controller-text
          (lambda (insts labels)
            (update-insts! insts labels machine)
            insts)))
    < src..

#     @c(Extract-labels) takes as arguments a list @c(text) (the sequence of
#     controller instruction expressions) and a @c(receive) procedure.  @c(Receive)
#     will be called with two values: (1) a list @c(insts) of instruction data
#     structures, each containing an instruction from @c(text); and (2) a table
#     called @c(labels), which associates each label from @c(text) with the position
#     in the list @c(insts) that the label designates.
    @c(Extract-labels) Toma como argumentos una lista @c(text)(la secuencia de
    las expresiones de instrucciones del controlador) y un procedimiento @c(receive).  @c(Receive) Se llamará con dos valores: (1) una lista
    @c(insts) de estructuras de datos de instrucciones, cada una de las cuales
    contiene una instrucción de @c(text); Y (2) una tabla llamada @c(labels),
    que asocia cada etiqueta de @c(text) la posición en la lista @c(insts) que
    la etiqueta designa.

#     ..src > scheme
#       (define (extract-labels text receive)
#         (if (null? text)
#             (receive '() '())
#             (extract-labels
#              (cdr text)
#              (lambda (insts labels)
#                (let ((next-inst (car text)))
#                  (if (symbol? next-inst)
#                      (receive
#                          insts
#                          (cons
#                           (make-label-entry
#                            next-inst
#                            insts)
#                           labels))
#                      (receive
#                          (cons (make-instruction
#                                 next-inst)
#                                insts)
#                          labels)))))))
#     < src..
    ..src > scheme
      (define (extract-labels text receive)
        (if (null? text)
            (receive '() '())
            (extract-labels
             (cdr text)
             (lambda (insts labels)
               (let ((next-inst (car text)))
                 (if (symbol? next-inst)
                     (receive
                         insts
                         (cons
                          (make-label-entry
                           next-inst
                           insts)
                          labels))
                     (receive
                         (cons (make-instruction
                                next-inst)
                               insts)
                         labels)))))))
    < src..

#     @c(Extract-labels) works by sequentially scanning the elements of the @c(text)
#     and accumulating the @c(insts) and the @c(labels). If an element is a symbol
#     (and thus a label) an appropriate entry is added to the @c(labels)
#     table. Otherwise the element is accumulated onto the @c(insts) list.@n(289)
    @c(Extract-labels) Trabaja escaneando secuencialmente los elementos del
    @c(text) y acumulando el @c(insts) y el @c(labels). Si un elemento es un
    símbolo (y por lo tanto una etiqueta), se agrega una entrada apropiada a la
    @c(labels) tabla. De lo contrario, el elemento se acumula en la @c(insts)
    lista.@n(289)

#     @c(Update-insts!) modifies the instruction list, which initially contains only
#     the text of the instructions, to include the corresponding execution
#     procedures:
    @c(Update-insts!) Modifica la lista de instrucciones, que inicialmente
    contiene sólo el texto de las instrucciones, para incluir los procedimientos
    de ejecución correspondientes:

#     ..src > scheme
#       (define (update-insts! insts labels machine)
#         (let ((pc (get-register machine 'pc))
#               (flag (get-register machine 'flag))
#               (stack (machine 'stack))
#               (ops (machine 'operations)))
#           (for-each
#            (lambda (inst)
#              (set-instruction-execution-proc!
#               inst
#               (make-execution-procedure
#                (instruction-text inst)
#                labels
#                machine
#                pc
#                flag
#                stack
#                ops)))
#            insts)))
#     < src..
    ..src > scheme
      (define (update-insts! insts labels machine)
        (let ((pc (get-register machine 'pc))
              (flag (get-register machine 'flag))
              (stack (machine 'stack))
              (ops (machine 'operations)))
          (for-each
           (lambda (inst)
             (set-instruction-execution-proc!
              inst
              (make-execution-procedure
               (instruction-text inst)
               labels
               machine
               pc
               flag
               stack
               ops)))
           insts)))
    < src..

#     The machine instruction data structure simply pairs the instruction text with
#     the corresponding execution procedure. The execution procedure is not yet
#     available when @c(extract-labels) constructs the instruction, and is inserted
#     later by @c(update-insts!).
    La estructura de datos de instrucción de máquina simplemente empareja el
    texto de instrucción con el procedimiento de ejecución correspondiente. El
    procedimiento de ejecución aún no está disponible cuando se
    @c(extract-labels) construye la instrucción, y se inserta posteriormente por
    @c(update-insts!).

#     ..src > scheme
#       (define (make-instruction text)
#         (cons text '()))
#       (define (instruction-text inst) (car inst))
#       (define (instruction-execution-proc inst)
#         (cdr inst))
#       (define (set-instruction-execution-proc!
#                inst
#                proc)
#         (set-cdr! inst proc))
#     < src..
    ..src > scheme
      (define (make-instruction text)
        (cons text '()))
      (define (instruction-text inst) (car inst))
      (define (instruction-execution-proc inst)
        (cdr inst))
      (define (set-instruction-execution-proc!
               inst
               proc)
        (set-cdr! inst proc))
    < src..

#     The instruction text is not used by our simulator, but it is handy to keep
#     around for debugging (see @l(#Exercise 5.16)).
    El texto de la instrucción no es utilizado por nuestro simulador, pero es
    útil mantenerlo para la depuración (ver el @l(#Ejercicio
    5.16) ).

#     Elements of the label table are pairs:
    Los elementos de la tabla de etiquetas son pares:

#     ..src > scheme
#       (define (make-label-entry label-name insts)
#         (cons label-name insts))
#     < src..
    ..src > scheme
      (define (make-label-entry label-name insts)
        (cons label-name insts))
    < src..

#     Entries will be looked up in the table with
    Las entradas se buscarán en la tabla con

#     ..src > scheme
#       (define (lookup-label labels label-name)
#         (let ((val (assoc label-name labels)))
#           (if val
#               (cdr val)
#               (error "Undefined label: ASSEMBLE"
#                      label-name))))
#     < src..
    ..src > scheme
      (define (lookup-label labels label-name)
        (let ((val (assoc label-name labels)))
          (if val
              (cdr val)
              (error "Undefined label: ASSEMBLE"
                     label-name))))
    < src..

#     :: @t(Exercise 5.8) :: The following register-machine code is ambiguous,
#        because the label @c(here) is defined more than once:
    :: @t(Ejercicio 5.8) :: El siguiente código registrador-máquina es ambiguo,
       porque la etiqueta @c(here) se define más de una vez:

#        ..src > scheme
#          start
#            (goto (label here))
#          here
#            (assign a (const 3))
#            (goto (label there))
#          here
#            (assign a (const 4))
#            (goto (label there))
#          there
#        < src..
       ..src > scheme
         start
           (goto (label here))
         here
           (assign a (const 3))
           (goto (label there))
         here
           (assign a (const 4))
           (goto (label there))
         there
       < src..

#        With the simulator as written, what will the contents of register @c(a) be
#        when control reaches @c(there)?  Modify the @c(extract-labels) procedure so
#        that the assembler will signal an error if the same label name is used to
#        indicate two different locations.
       Con el simulador escrito, ¿cuál será el contenido del registro @c(a)
       cuando el control alcance @c(there)? Modifique el procedimiento @c(extract-labels) para que el ensamblador indique un error si se utiliza el
       mismo nombre de etiqueta para indicar dos ubicaciones diferentes.

# *** 5.2.3 <> Generating Execution Procedures for Instructions
*** 5.2.3 <> Generación de procedimientos de ejecución para instrucciones

#     The assembler calls @c(make-execution-procedure) to generate the execution
#     procedure for an instruction. Like the @c(analyze) procedure in the evaluator
#     of section @l(#4.1.7), this dispatches on the type of instruction to generate the
#     appropriate execution procedure.
    El ensamblador llama @c(make-execution-procedure) para generar el
    procedimiento de ejecución de una instrucción. Al igual que el procedimiento
    @c(analyze) en el evaluador de la seccion @l(#4.1.7), éste distribuye el tipo
    de instrucción para generar el procedimiento de ejecución apropiado.

#     ..src > scheme
#       (define (make-execution-procedure
#                inst labels machine pc flag stack ops)
#         (cond ((eq? (car inst) 'assign)
#                (make-assign
#                 inst machine labels ops pc))
#               ((eq? (car inst) 'test)
#                (make-test
#                 inst machine labels ops flag pc))
#               ((eq? (car inst) 'branch)
#                (make-branch
#                 inst machine labels flag pc))
#               ((eq? (car inst) 'goto)
#                (make-goto inst machine labels pc))
#               ((eq? (car inst) 'save)
#                (make-save inst machine stack pc))
#               ((eq? (car inst) 'restore)
#                (make-restore inst machine stack pc))
#               ((eq? (car inst) 'perform)
#                (make-perform
#                 inst machine labels ops pc))
#               (else (error "Unknown instruction
#                             type: ASSEMBLE"
#                            inst))))
#     < src..
    ..src > scheme
      (define (make-execution-procedure
               inst labels machine pc flag stack ops)
        (cond ((eq? (car inst) 'assign)
               (make-assign
                inst machine labels ops pc))
              ((eq? (car inst) 'test)
               (make-test
                inst machine labels ops flag pc))
              ((eq? (car inst) 'branch)
               (make-branch
                inst machine labels flag pc))
              ((eq? (car inst) 'goto)
               (make-goto inst machine labels pc))
              ((eq? (car inst) 'save)
               (make-save inst machine stack pc))
              ((eq? (car inst) 'restore)
               (make-restore inst machine stack pc))
              ((eq? (car inst) 'perform)
               (make-perform
                inst machine labels ops pc))
              (else (error "Unknown instruction
                            type: ASSEMBLE"
                           inst))))
    < src..

#     For each type of instruction in the register-machine language, there is a
#     generator that builds an appropriate execution procedure. The details of these
#     procedures determine both the syntax and meaning of the individual
#     instructions in the register-machine language. We use data abstraction to
#     isolate the detailed syntax of register-machine expressions from the general
#     execution mechanism, as we did for evaluators in section @l(#4.1.2), by using syntax
#     procedures to extract and classify the parts of an instruction.
    Para cada tipo de instrucción en el lenguaje de registro-máquina, hay un
    generador que construye un procedimiento de ejecución apropiado. Los
    detalles de estos procedimientos determinan tanto la sintaxis como el
    significado de las instrucciones individuales en el lenguaje de
    registro-máquina. Utilizamos la abstracción de datos para aislar la sintaxis
    detallada de las expresiones máquina registradora del mecanismo de ejecución
    general, como lo hicimos con los evaluadores en la seccion @l(#4.1.2),
    utilizando procedimientos de sintaxis para extraer y clasificar las partes
    de una instrucción.

# **** @c(Assign) instructions
**** @c(Assign) instrucciones

#      The @c(make-assign) procedure handles @c(assign) instructions:
     El procedimiento @c(make-assign) se encarga de las @c(assign)
     instrucciones:

#      ..src > scheme
#        (define (make-assign
#                 inst machine labels operations pc)
#          (let ((target
#                 (get-register
#                  machine
#                  (assign-reg-name inst)))
#                (value-exp (assign-value-exp inst)))
#            (let ((value-proc
#                   (if (operation-exp? value-exp)
#                       (make-operation-exp
#                        value-exp
#                        machine
#                        labels
#                        operations)
#                       (make-primitive-exp
#                        (car value-exp)
#                        machine
#                        labels))))
#              (lambda ()   ; execution procedure
#                           ; for assign
#                (set-contents! target (value-proc))
#                (advance-pc pc)))))
#      < src..
     ..src > scheme
       (define (make-assign
                inst machine labels operations pc)
         (let ((target
                (get-register
                 machine
                 (assign-reg-name inst)))
               (value-exp (assign-value-exp inst)))
           (let ((value-proc
                  (if (operation-exp? value-exp)
                      (make-operation-exp
                       value-exp
                       machine
                       labels
                       operations)
                      (make-primitive-exp
                       (car value-exp)
                       machine
                       labels))))
             (lambda ()   ; execution procedure
                          ; for assign
               (set-contents! target (value-proc))
               (advance-pc pc)))))
     < src..

#      @c(Make-assign) extracts the target register name (the second element of the
#      instruction) and the value expression (the rest of the list that forms the
#      instruction) from the @c(assign) instruction using the selectors
     @c(Make-assign) Extrae el nombre de registro de destino (el segundo
     elemento de la instrucción) y la expresión de valor (el resto de la lista
     que forma la instrucción) de la @c(assign) instrucción utilizando los
     selectores

#      ..src > scheme
#        (define (assign-reg-name assign-instruction)
#          (cadr assign-instruction))
#        (define (assign-value-exp assign-instruction)
#          (cddr assign-instruction))
#      < src..
     ..src > scheme
       (define (assign-reg-name assign-instruction)
         (cadr assign-instruction))
       (define (assign-value-exp assign-instruction)
         (cddr assign-instruction))
     < src..

#      The register name is looked up with @c(get-register) to produce the target
#      register object. The value expression is passed to @c(make-operation-exp) if
#      the value is the result of an operation, and to @c(make-primitive-exp)
#      otherwise. These procedures (shown below) parse the value expression and
#      produce an execution procedure for the value. This is a procedure of no
#      arguments, called @c(value-proc), which will be evaluated during the
#      simulation to produce the actual value to be assigned to the register. Notice
#      that the work of looking up the register name and parsing the value expression
#      is performed just once, at assembly time, not every time the instruction is
#      simulated. This saving of work is the reason we use execution procedures, and
#      corresponds directly to the saving in work we obtained by separating program
#      analysis from execution in the evaluator of section @l(#4.1.7).
     Se busca el nombre del registro @c(get-register) para producir el objeto de
     registro de destino. La expresión de valor se pasa a @c(make-operation-exp)
     si el valor es el resultado de una operación y, de lo
     @c(make-primitive-exp) contrario. Estos procedimientos (mostrados a
     continuación) analizan la expresión de valor y producen un procedimiento de
     ejecución para el valor. Este es un procedimiento sin argumentos, llamado
     @c(value-proc), que será evaluado durante la simulación para producir el
     valor real que se asignará al registro. Observe que el trabajo de buscar el
     nombre de registro y analizar la expresión de valor se realiza una sola
     vez, en el momento del ensamblaje, no cada vez que se simula la
     instrucción. Este ahorro de trabajo es la razón por la que usamos los
     procedimientos de ejecución, y corresponde directamente al ahorro en el
     trabajo que obtuvimos al separar el análisis del programa de la ejecución
     en el evaluador de la seccion @l(#4.1.7<>4.)

#      The result returned by @c(make-assign) is the execution procedure for the
#      @c(assign) instruction. When this procedure is called (by the machine model's
#      @c(execute) procedure), it sets the contents of the target register to the
#      result obtained by executing @c(value-proc). Then it advances the @c(pc) to
#      the next instruction by running the procedure
     El resultado devuelto por @c(make-assign) es el procedimiento de ejecución
     de la @c(assign) instrucción. Cuando se llama a este procedimiento
     (mediante el procedimiento @c(execute) del modelo de máquina ), establece
     el contenido del registro de destino en el resultado obtenido ejecutando
     @c(value-proc). Luego avanza @c(pc) a la siguiente instrucción ejecutando
     el procedimiento

#      ..src > scheme
#        (define (advance-pc pc)
#          (set-contents! pc (cdr (get-contents pc))))
#      < src..
     ..src > scheme
       (define (advance-pc pc)
         (set-contents! pc (cdr (get-contents pc))))
     < src..

#      @c(Advance-pc) is the normal termination for all instructions except
#      @c(branch) and @c(goto).
     @c(Advance-pc) Es la terminación normal para todas las instrucciones
     excepto @c(branch) y @c(goto).

# **** @c(Test), @c(branch), and @c(goto) instructions
**** @c(Test), @c(branch) Y @c(goto) las instrucciones

#      @c(Make-test) handles @c(test) instructions in a similar way. It extracts the
#      expression that specifies the condition to be tested and generates an
#      execution procedure for it. At simulation time, the procedure for the
#      condition is called, the result is assigned to the @c(flag) register, and the
#      @c(pc) is advanced:
     @c(Make-test) Maneja las @c(test) instrucciones de una manera
     similar. Extrae la expresión que especifica la condición a probar y genera
     un procedimiento de ejecución para ella. En el momento de la simulación, se
     llama al procedimiento de la condición, el resultado se asigna al @c(flag)
     registro y @c(pc) se avanza:

#      ..src > scheme
#        (define
#          (make-test
#           inst machine labels operations flag pc)
#          (let ((condition (test-condition inst)))
#            (if (operation-exp? condition)
#                (let ((condition-proc
#                       (make-operation-exp
#                        condition
#                        machine
#                        labels
#                        operations)))
#                  (lambda ()
#                    (set-contents!
#                     flag (condition-proc))
#                    (advance-pc pc)))
#                (error "Bad TEST instruction:
#                        ASSEMBLE" inst))))
#
#        (define (test-condition test-instruction)
#          (cdr test-instruction))
#      < src..
     ..src > scheme
       (define
         (make-test
          inst machine labels operations flag pc)
         (let ((condition (test-condition inst)))
           (if (operation-exp? condition)
               (let ((condition-proc
                      (make-operation-exp
                       condition
                       machine
                       labels
                       operations)))
                 (lambda ()
                   (set-contents!
                    flag (condition-proc))
                   (advance-pc pc)))
               (error "Bad TEST instruction:
                       ASSEMBLE" inst))))

       (define (test-condition test-instruction)
         (cdr test-instruction))
     < src..

#      The execution procedure for a @c(branch) instruction checks the contents of
#      the @c(flag) register and either sets the contents of the @c(pc) to the branch
#      destination (if the branch is taken) or else just advances the @c(pc) (if the
#      branch is not taken). Notice that the indicated destination in a @c(branch)
#      instruction must be a label, and the @c(make-branch) procedure enforces
#      this. Notice also that the label is looked up at assembly time, not each time
#      the @c(branch) instruction is simulated.
     El procedimiento de ejecución de una @c(branch) instrucción comprueba el
     contenido del @c(flag) registro y establece el contenido del @c(pc) destino
     en la sucursal (si se toma la sucursal) o simplemente avanza @c(pc)(si no
     se toma la sucursal). Observe que el destino indicado en una @c(branch)
     instrucción debe ser una etiqueta, y el procedimiento @c(make-branch) lo
     hace cumplir. Observe también que la etiqueta se mira en el tiempo de
     montaje, no cada vez @c(branch) que se simula la instrucción.

#      ..src > scheme
#        (define
#          (make-branch
#           inst machine labels flag pc)
#          (let ((dest (branch-dest inst)))
#            (if (label-exp? dest)
#                (let ((insts
#                       (lookup-label
#                        labels
#                        (label-exp-label dest))))
#                  (lambda ()
#                    (if (get-contents flag)
#                        (set-contents! pc insts)
#                        (advance-pc pc))))
#                (error "Bad BRANCH instruction:
#                        ASSEMBLE"
#                       inst))))
#
#        (define (branch-dest branch-instruction)
#          (cadr branch-instruction))
#      < src..
     ..src > scheme
       (define
         (make-branch
          inst machine labels flag pc)
         (let ((dest (branch-dest inst)))
           (if (label-exp? dest)
               (let ((insts
                      (lookup-label
                       labels
                       (label-exp-label dest))))
                 (lambda ()
                   (if (get-contents flag)
                       (set-contents! pc insts)
                       (advance-pc pc))))
               (error "Bad BRANCH instruction:
                       ASSEMBLE"
                      inst))))

       (define (branch-dest branch-instruction)
         (cadr branch-instruction))
     < src..

#      A @c(goto) instruction is similar to a branch, except that the destination may
#      be specified either as a label or as a register, and there is no condition to
#      check––the @c(pc) is always set to the new destination.
     Una @c(goto) instrucción es similar a una sucursal, excepto que el destino
     se puede especificar como una etiqueta o como un registro, y no hay ninguna
     condición para comprobar - el @c(pc) siempre se establece en el nuevo
     destino.

#      ..src > scheme
#        (define (make-goto inst machine labels pc)
#          (let ((dest (goto-dest inst)))
#            (cond ((label-exp? dest)
#                   (let ((insts
#                          (lookup-label
#                           labels
#                           (label-exp-label dest))))
#                     (lambda ()
#                       (set-contents! pc insts))))
#                  ((register-exp? dest)
#                   (let ((reg
#                          (get-register
#                           machine
#                           (register-exp-reg dest))))
#                     (lambda ()
#                       (set-contents!
#                        pc
#                        (get-contents reg)))))
#                  (else (error "Bad GOTO instruction:
#                                ASSEMBLE"
#                               inst)))))
#
#        (define (goto-dest goto-instruction)
#          (cadr goto-instruction))
#      < src..
     ..src > scheme
       (define (make-goto inst machine labels pc)
         (let ((dest (goto-dest inst)))
           (cond ((label-exp? dest)
                  (let ((insts
                         (lookup-label
                          labels
                          (label-exp-label dest))))
                    (lambda ()
                      (set-contents! pc insts))))
                 ((register-exp? dest)
                  (let ((reg
                         (get-register
                          machine
                          (register-exp-reg dest))))
                    (lambda ()
                      (set-contents!
                       pc
                       (get-contents reg)))))
                 (else (error "Bad GOTO instruction:
                               ASSEMBLE"
                              inst)))))

       (define (goto-dest goto-instruction)
         (cadr goto-instruction))
     < src..

# **** Other instructions
**** Otras instrucciones

#      The stack instructions @c(save) and @c(restore) simply use the stack with the
#      designated register and advance the @c(pc):
     Las instrucciones de la pila @c(save) y @c(restore) simplemente utilizar la
     pila con el registro designado y avanzar el @c(pc):

#      ..src > scheme
#        (define (make-save inst machine stack pc)
#          (let ((reg (get-register
#                      machine
#                      (stack-inst-reg-name inst))))
#            (lambda ()
#              (push stack (get-contents reg))
#              (advance-pc pc))))
#
#        (define (make-restore inst machine stack pc)
#          (let ((reg (get-register
#                      machine
#                      (stack-inst-reg-name inst))))
#            (lambda ()
#              (set-contents! reg (pop stack))
#              (advance-pc pc))))
#
#        (define (stack-inst-reg-name
#                 stack-instruction)
#          (cadr stack-instruction))
#      < src..
     ..src > scheme
       (define (make-save inst machine stack pc)
         (let ((reg (get-register
                     machine
                     (stack-inst-reg-name inst))))
           (lambda ()
             (push stack (get-contents reg))
             (advance-pc pc))))

       (define (make-restore inst machine stack pc)
         (let ((reg (get-register
                     machine
                     (stack-inst-reg-name inst))))
           (lambda ()
             (set-contents! reg (pop stack))
             (advance-pc pc))))

       (define (stack-inst-reg-name
                stack-instruction)
         (cadr stack-instruction))
     < src..

#      The final instruction type, handled by @c(make-perform), generates an
#      execution procedure for the action to be performed. At simulation time, the
#      action procedure is executed and the @c(pc) advanced.
     El tipo de instrucción final, manejado por @c(make-perform), genera un
     procedimiento de ejecución para la acción a realizar. En el momento de la
     simulación, se ejecuta el procedimiento de acción y se @c(pc) avanza.

#      ..src > scheme
#        (define (make-perform
#                 inst machine labels operations pc)
#          (let ((action (perform-action inst)))
#            (if (operation-exp? action)
#                (let ((action-proc
#                       (make-operation-exp
#                        action
#                        machine
#                        labels
#                        operations)))
#                  (lambda ()
#                    (action-proc)
#                    (advance-pc pc)))
#                (error "Bad PERFORM instruction:
#                        ASSEMBLE"
#                       inst))))
#
#        (define (perform-action inst) (cdr inst))
#      < src..
     ..src > scheme
       (define (make-perform
                inst machine labels operations pc)
         (let ((action (perform-action inst)))
           (if (operation-exp? action)
               (let ((action-proc
                      (make-operation-exp
                       action
                       machine
                       labels
                       operations)))
                 (lambda ()
                   (action-proc)
                   (advance-pc pc)))
               (error "Bad PERFORM instruction:
                       ASSEMBLE"
                      inst))))

       (define (perform-action inst) (cdr inst))
     < src..

# **** Execution procedures for subexpressions
**** Procedimientos de ejecución para subexpresiones

#      The value of a @c(reg), @c(label), or @c(const) expression may be needed for
#      assignment to a register (@c(make-assign)) or for input to an operation
#      (@c(make-operation-exp), below). The following procedure generates execution
#      procedures to produce values for these expressions during the simulation:
     El valor de una @c(reg), @c(label) o @c(const) la expresión puede ser
     necesaria para la asignación a un registro (@c(make-assign)) o para la
     entrada a una operación (@c(make-operation-exp) a continuación). El
     siguiente procedimiento genera procedimientos de ejecución para producir
     valores para estas expresiones durante la simulación:

#      ..src > scheme
#        (define (make-primitive-exp exp machine labels)
#          (cond ((constant-exp? exp)
#                 (let ((c (constant-exp-value exp)))
#                   (lambda () c)))
#                ((label-exp? exp)
#                 (let ((insts
#                        (lookup-label
#                         labels
#                         (label-exp-label exp))))
#                   (lambda () insts)))
#                ((register-exp? exp)
#                 (let ((r (get-register
#                           machine
#                           (register-exp-reg exp))))
#                   (lambda () (get-contents r))))
#                (else (error "Unknown expression type:
#                              ASSEMBLE"
#                             exp))))
#      < src..
     ..src > scheme
       (define (make-primitive-exp exp machine labels)
         (cond ((constant-exp? exp)
                (let ((c (constant-exp-value exp)))
                  (lambda () c)))
               ((label-exp? exp)
                (let ((insts
                       (lookup-label
                        labels
                        (label-exp-label exp))))
                  (lambda () insts)))
               ((register-exp? exp)
                (let ((r (get-register
                          machine
                          (register-exp-reg exp))))
                  (lambda () (get-contents r))))
               (else (error "Unknown expression type:
                             ASSEMBLE"
                            exp))))
     < src..

#      The syntax of @c(reg), @c(label), and @c(const) expressions is determined by
     La sintaxis de @c(reg), @c(label) y @c(const) expresiones se determina por

#      ..src > scheme
#        (define (register-exp? exp)
#          (tagged-list? exp 'reg))
#        (define (register-exp-reg exp)
#          (cadr exp))
#        (define (constant-exp? exp)
#          (tagged-list? exp 'const))
#        (define (constant-exp-value exp)
#          (cadr exp))
#        (define (label-exp? exp)
#          (tagged-list? exp 'label))
#        (define (label-exp-label exp)
#          (cadr exp))
#      < src..
     ..src > scheme
       (define (register-exp? exp)
         (tagged-list? exp 'reg))
       (define (register-exp-reg exp)
         (cadr exp))
       (define (constant-exp? exp)
         (tagged-list? exp 'const))
       (define (constant-exp-value exp)
         (cadr exp))
       (define (label-exp? exp)
         (tagged-list? exp 'label))
       (define (label-exp-label exp)
         (cadr exp))
     < src..

#      @c(Assign), @c(perform), and @c(test) instructions may include the application
#      of a machine operation (specified by an @c(op) expression) to some operands
#      (specified by @c(reg) and @c(const) expressions). The following procedure
#      produces an execution procedure for an @"(operation expression)––a list
#      containing the operation and operand expressions from the instruction:
     @c(Assign), @c(perform) Y las @c(test) instrucciones pueden incluir la
     aplicación de una operación de máquina (especificada por una @c(op)
     expresión) a algunos operandos (especificados por @c(reg) y @c(const)
     expresiones). El procedimiento siguiente produce un procedimiento de
     ejecución para una @"(expresión de operación) --una lista que contiene las
     expresiones de operación y de operando de la instrucción:

#      ..src > scheme
#        (define (make-operation-exp
#                 exp machine labels operations)
#          (let ((op (lookup-prim
#                     (operation-exp-op exp)
#                     operations))
#                (aprocs
#                 (map (lambda (e)
#                        (make-primitive-exp
#                         e machine labels))
#                      (operation-exp-operands exp))))
#            (lambda () (apply op (map (lambda (p) (p))
#                                      aprocs)))))
#      < src..
     ..src > scheme
       (define (make-operation-exp
                exp machine labels operations)
         (let ((op (lookup-prim
                    (operation-exp-op exp)
                    operations))
               (aprocs
                (map (lambda (e)
                       (make-primitive-exp
                        e machine labels))
                     (operation-exp-operands exp))))
           (lambda () (apply op (map (lambda (p) (p))
                                     aprocs)))))
     < src..

#      The syntax of operation expressions is determined by
     La sintaxis de las expresiones de operación está determinada por

#      ..src > scheme
#        (define (operation-exp? exp)
#          (and (pair? exp)
#               (tagged-list? (car exp) 'op)))
#        (define (operation-exp-op operation-exp)
#          (cadr (car operation-exp)))
#        (define (operation-exp-operands operation-exp)
#          (cdr operation-exp))
#      < src..
     ..src > scheme
       (define (operation-exp? exp)
         (and (pair? exp)
              (tagged-list? (car exp) 'op)))
       (define (operation-exp-op operation-exp)
         (cadr (car operation-exp)))
       (define (operation-exp-operands operation-exp)
         (cdr operation-exp))
     < src..

#      Observe that the treatment of operation expressions is very much like the
#      treatment of procedure applications by the @c(analyze-application) procedure
#      in the evaluator of section @l(#4.1.7) in that we generate an execution procedure for
#      each operand. At simulation time, we call the operand procedures and apply the
#      Scheme procedure that simulates the operation to the resulting values. The
#      simulation procedure is found by looking up the operation name in the
#      operation table for the machine:
     Observe que el tratamiento de las expresiones de operación es muy similar
     al tratamiento de las aplicaciones de procedimiento por el
     procedimiento @c(analyze-application) en el evaluador de la seccion @l(#4.1.7)
     en que generamos un procedimiento de ejecución para cada operando. En el
     momento de la simulación, llamamos a los procedimientos de operando y
     aplicamos el procedimiento Scheme que simula la operación a los valores
     resultantes. El procedimiento de simulación se encuentra buscando el nombre
     de la operación en la tabla de operaciones de la máquina:

#      ..src > scheme
#        (define (lookup-prim symbol operations)
#          (let ((val (assoc symbol operations)))
#            (if val
#                (cadr val)
#                (error "Unknown operation: ASSEMBLE"
#                       symbol))))
#      < src..
     ..src > scheme
       (define (lookup-prim symbol operations)
         (let ((val (assoc symbol operations)))
           (if val
               (cadr val)
               (error "Unknown operation: ASSEMBLE"
                      symbol))))
     < src..

#      :: @t(Exercise 5.9) :: The treatment of machine operations above permits them
#         to operate on labels as well as on constants and the contents of
#         registers. Modify the expression-processing procedures to enforce the
#         condition that operations can be used only with registers and constants.
     :: @t(Ejercicio 5.9) :: El tratamiento de las operaciones de la máquina
        anteriores les permite operar sobre etiquetas así como sobre constantes
        y el contenido de registros. Modifique los procedimientos de
        procesamiento de expresiones para aplicar la condición de que las
        operaciones sólo se pueden utilizar con registros y constantes.

#      :: @t(Exercise 5.10) :: Design a new syntax for register-machine instructions
#         and modify the simulator to use your new syntax.  Can you implement your
#         new syntax without changing any part of the simulator except the syntax
#         procedures in this section?
     :: @t(Ejercicio 5.10) :: Diseñe una nueva sintaxis para las instrucciones
        register-machine y modifique el simulador para usar su nueva
        sintaxis. ¿Puede implementar su nueva sintaxis sin cambiar ninguna parte
        del simulador, excepto los procedimientos de sintaxis de esta sección?

#      :: @t(Exercise 5.11) :: When we introduced @c(save) and @c(restore) in
#         @l(#5.1.4), we didn't specify what would happen if you tried to restore a
#         register that was not the last one saved, as in the sequence
     :: @t(Ejercicio 5.11) :: Cuando introducimos @c(save) y @c(restore) en
        @l(#5.1.4), no especificamos qué pasaría si tratas de restaurar
        un registro que no fue el último salvo, como en la secuencia

#         ..src > scheme
#           (save y)
#           (save x)
#           (restore y)
#         < src..
        ..src > scheme
          (save y)
          (save x)
          (restore y)
        < src..

#         There are several reasonable possibilities for the meaning of @c(restore):
        Existen varias posibilidades razonables para el significado de
        @c(restore):

#         1. @c[(restore y)] puts into @c(y) the last value saved on the stack,
#            regardless of what register that value came from. This is the way our
#            simulator behaves. Show how to take advantage of this behavior to
#            eliminate one instruction from the Fibonacci machine of section @l(#5.1.4)
#            (@l(#Figure 5.12)).
        1. @c[(restore y)] Pone en @c(y) el último valor guardado en la pila,
           sin importar de qué registro provenía ese valor. Así es como se
           comporta nuestro simulador. Muestre cómo aprovechar este
           comportamiento para eliminar una instrucción de la máquina Fibonacci
           de la seccion @l(#5.1.4) (@l(#Figura 5.12) ).

#         2. @c[(restore y)] puts into @c(y) the last value saved on the stack, but
#            only if that value was saved from @c(y); otherwise, it signals an error.
#            Modify the simulator to behave this way. You will have to change
#            @c(save) to put the register name on the stack along with the value.
        2. @c[(restore y)] Pone en @c(y) el último valor guardado en la pila,
           pero sólo si se guardó ese valor @c(y); De lo contrario, indica un
           error. Modifique el simulador para que se comporte de esta
           manera. Tendrá que cambiar @c(save) para poner el nombre del registro
           en la pila junto con el valor.

#         3. @c[(restore y)] puts into @c(y) the last value saved from @c(y)
#            regardless of what other registers were saved after @c(y) and not
#            restored.  Modify the simulator to behave this way. You will have to
#            associate a separate stack with each register. You should make the
#            @c(initialize-stack) operation initialize all the register stacks.
        3. @c[(restore y)] Pone en @c(y) el último valor guardado de @c(y)
           independientemente de qué otros registros fueron guardados después
           @c(y) y no restaurados. Modifique el simulador para que se comporte
           de esta manera. Tendrá que asociar una pila separada con cada
           registro. Debe hacer que la @c(initialize-stack) operación inicialice
           todas las pilas de registro.

#      :: @t(Exercise 5.12) :: The simulator can be used to help determine the data
#         paths required for implementing a machine with a given controller. Extend
#         the assembler to store the following information in the machine model:
     :: @t(Ejercicio 5.12) :: El simulador puede usarse para ayudar a determinar
        las rutas de datos necesarias para implementar una máquina con un
        controlador dado. Extienda el ensamblador para almacenar la siguiente
        información en el modelo de la máquina:

#         - a list of all instructions, with duplicates removed, sorted by
#           instruction type (@c(assign), @c(goto), and so on);
        - una lista de todas las instrucciones, con duplicados eliminado,
          clasificadas por tipo de instrucción (@c(assign), @c(goto), etc.);

#         - a list (without duplicates) of the registers used to hold entry points
#           (these are the registers referenced by @c(goto) instructions);
        - Una lista (sin duplicados) de los registros utilizados para contener
          puntos de entrada (estos son los registros a los que se hace
          referencia en las @c(goto) instrucciones);

#         - a list (without duplicates) of the registers that are @c(save)d or
#           @c(restore)d;
        - Una lista (sin duplicados) de los registros que son @c(save) d o
          @c(restore) d;

#         - for each register, a list (without duplicates) of the sources from which
#           it is assigned (for example, the sources for register @c(val) in the
#           factorial machine of @l(#Figure 5.11) are @c[(const 1)] and @c[((op *)
#           (reg n) (reg val))]).
        - Para cada registro, una lista (sin duplicados) de las fuentes de las
          que está asignada (por ejemplo, las fuentes de registro @c(val) en la
          máquina factorial de la @l(#Figura 5.11) son @c[(const
          1)] y @c[((op *) (reg n) (reg val))]).


#         Extend the message-passing interface to the machine to provide access to
#         this new information. To test your analyzer, define the Fibonacci machine
#         from @l(#Figure 5.12) and examine the lists you constructed.
        Amplíe la interfaz de paso de mensajes a la máquina para proporcionar
        acceso a esta nueva información. Para probar su analizador, defina la
        máquina Fibonacci de la @l(#Figura 5.12) y examine las
        listas que ha construido.

#      :: @t(Exercise 5.13) :: Modify the simulator so that it uses the controller
#         sequence to determine what registers the machine has rather than requiring
#         a list of registers as an argument to @c(make-machine).  Instead of
#         pre-allocating the registers in @c(make-machine), you can allocate them one
#         at a time when they are first seen during assembly of the instructions.
     :: @t(Ejercicio 5.13) :: Modifique el simulador para que utilice la
        secuencia del controlador para determinar qué registros tiene la máquina
        en lugar de requerir una lista de registros como argumento
        @c(make-machine). En lugar de pre-asignar los registros en
        @c(make-machine), se pueden asignar uno a la vez cuando se ven por
        primera vez durante el montaje de las instrucciones.

# *** 5.2.4 <> Monitoring Machine Performance
*** 5.2.4 <> Supervisión del rendimiento de la máquina

#     Simulation is useful not only for verifying the correctness of a proposed
#     machine design but also for measuring the machine's performance. For example,
#     we can install in our simulation program a @"(meter) that measures the number
#     of stack operations used in a computation. To do this, we modify our simulated
#     stack to keep track of the number of times registers are saved on the stack
#     and the maximum depth reached by the stack, and add a message to the stack's
#     interface that prints the statistics, as shown below. We also add an operation
#     to the basic machine model to print the stack statistics, by initializing
#     @c(the-ops) in @c(make-new-machine) to
    La simulación es útil no sólo para verificar la corrección de un diseño de
    máquina propuesto, sino también para medir el rendimiento de la máquina. Por
    ejemplo, podemos instalar en nuestro programa de simulación un @"(medidor)
    que mide el número de operaciones de pila usadas en un cálculo. Para ello,
    modificamos nuestra pila simulada para realizar un seguimiento del número de
    veces que los registros se guardan en la pila y la profundidad máxima
    alcanzada por la pila, y agregar un mensaje a la interfaz de la pila que
    imprime las estadísticas, como se muestra a continuación. También añadimos
    una operación para el modelo básico de la máquina de imprimir las
    estadísticas de pilas, inicializando @c(the-ops) en @c(make-new-machine) a

#     ..src > scheme
#       (list (list 'initialize-stack
#                   (lambda ()
#                     (stack 'initialize)))
#             (list 'print-stack-statistics
#                   (lambda ()
#                     (stack 'print-statistics))))
#     < src..
    ..src > scheme
      (list (list 'initialize-stack
                  (lambda ()
                    (stack 'initialize)))
            (list 'print-stack-statistics
                  (lambda ()
                    (stack 'print-statistics))))
    < src..

#     Here is the new version of @c(make-stack):
    Aquí está la nueva versión de @c(make-stack):

#     ..src > scheme
#       (define (make-stack)
#         (let ((s '())
#               (number-pushes 0)
#               (max-depth 0)
#               (current-depth 0))
#           (define (push x)
#             (set! s (cons x s))
#             (set! number-pushes (+ 1 number-pushes))
#             (set! current-depth (+ 1 current-depth))
#             (set! max-depth
#                   (max current-depth max-depth)))
#           (define (pop)
#             (if (null? s)
#                 (error "Empty stack: POP")
#                 (let ((top (car s)))
#                   (set! s (cdr s))
#                   (set! current-depth
#                         (- current-depth 1))
#                   top)))
#           (define (initialize)
#             (set! s '())
#             (set! number-pushes 0)
#             (set! max-depth 0)
#             (set! current-depth 0)
#             'done)
#
#           (define (print-statistics)
#             (newline)
#             (display (list 'total-pushes
#                            '=
#                            number-pushes
#                            'maximum-depth
#                            '=
#                            max-depth)))
#           (define (dispatch message)
#             (cond ((eq? message 'push) push)
#                   ((eq? message 'pop) (pop))
#                   ((eq? message 'initialize)
#                    (initialize))
#                   ((eq? message 'print-statistics)
#                    (print-statistics))
#                   (else
#                    (error "Unknown request: STACK"
#                           message))))
#           dispatch))
#     < src..
    ..src > scheme
      (define (make-stack)
        (let ((s '())
              (number-pushes 0)
              (max-depth 0)
              (current-depth 0))
          (define (push x)
            (set! s (cons x s))
            (set! number-pushes (+ 1 number-pushes))
            (set! current-depth (+ 1 current-depth))
            (set! max-depth
                  (max current-depth max-depth)))
          (define (pop)
            (if (null? s)
                (error "Empty stack: POP")
                (let ((top (car s)))
                  (set! s (cdr s))
                  (set! current-depth
                        (- current-depth 1))
                  top)))
          (define (initialize)
            (set! s '())
            (set! number-pushes 0)
            (set! max-depth 0)
            (set! current-depth 0)
            'done)

          (define (print-statistics)
            (newline)
            (display (list 'total-pushes
                           '=
                           number-pushes
                           'maximum-depth
                           '=
                           max-depth)))
          (define (dispatch message)
            (cond ((eq? message 'push) push)
                  ((eq? message 'pop) (pop))
                  ((eq? message 'initialize)
                   (initialize))
                  ((eq? message 'print-statistics)
                   (print-statistics))
                  (else
                   (error "Unknown request: STACK"
                          message))))
          dispatch))
    < src..

#     @l(#Exercise 5.15) through @l(#Exercise 5.19) describe other useful monitoring
#     and debugging features that can be added to the register-machine simulator.
    @l(#Ejercicio 5.15) al @l(#Ejercicio 5.19)
    describe otras características útiles de monitoreo y depuración que se
    pueden agregar al simulador de registro-máquina.

#     :: @t(Exercise 5.14) :: Measure the number of pushes and the maximum stack
#        depth required to compute @m(n!) for various small values of @m(n) using
#        the factorial machine shown in @l(#Figure 5.11). From your data determine
#        formulas in terms of @m(n) for the total number of push operations and the
#        maximum stack depth used in computing @m(n!) for any @m(n > 1). Note that
#        each of these is a linear function of @m(n) and is thus determined by two
#        constants. In order to get the statistics printed, you will have to augment
#        the factorial machine with instructions to initialize the stack and print
#        the statistics. You may want to also modify the machine so that it
#        repeatedly reads a value for @m(n), computes the factorial, and prints the
#        result (as we did for the @A(GCD) machine in @l(#Figure 5.4)), so that you
#        will not have to repeatedly invoke @c(get-register-contents),
#        @c(set-register-contents!), and @c(start).
    :: @t(Ejercicio 5.14) :: Mida el número de empujes y la profundidad de pila
       máxima requerida para calcular @m(n! ) Para varios valores pequeños de
       @m(n) usando la máquina factorial mostrada en la @l(#Figura
       5.11). A partir de sus datos, determine fórmulas en términos de @m(n)
       para el número total de operaciones de empuje y la profundidad máxima de
       pila utilizada en la computación @m(n! ) Para cualquier @m(n>
       1). Obsérvese que cada una de ellas es una función lineal de @m(n) y, por
       tanto, está determinada por dos constantes. Con el fin de obtener las
       estadísticas impresas, tendrá que aumentar la máquina factorial con
       instrucciones para inicializar la pila e imprimir las
       estadísticas. También puede modificar la máquina para que lea
       repetidamente un valor para @m(n), calcule el factorial,@A()@l(#Figura 5.4)@c(get-register-contents)@c(set-register-contents!)@c(start)

#     :: @t(Exercise 5.15) :: Add @e(instruction counting) to the register machine
#        simulation. That is, have the machine model keep track of the number of
#        instructions executed. Extend the machine model's interface to accept a new
#        message that prints the value of the instruction count and resets the count
#        to zero.
    :: @t(Ejercicio 5.15) :: Agregue el @e(recuento de instrucciones) a la
       simulación de la máquina registradora. Es decir, que el modelo de la
       máquina siga el número de instrucciones ejecutadas. Extienda la interfaz
       del modelo de máquina para aceptar un nuevo mensaje que imprima el valor
       del recuento de instrucciones y restablezca el conteo a cero.

#     :: @t(Exercise 5.16) :: Augment the simulator to provide for @e(instruction
#        tracing). That is, before each instruction is executed, the simulator
#        should print the text of the instruction. Make the machine model accept
#        @c(trace-on) and @c(trace-off) messages to turn tracing on and off.
    :: @t(Ejercicio 5.16) :: Aumentar el simulador para proporcionar el
       @e(rastreo de instrucciones). Es decir, antes de que se ejecute cada
       instrucción, el simulador debe imprimir el texto de la instrucción. Haga
       aceptar el modelo de la máquina @c(trace-on) y los @c(trace-off) mensajes
       para activar y desactivar el seguimiento.

#     :: @t(Exercise 5.17) :: Extend the instruction tracing of @l(#Exercise 5.16)
#        so that before printing an instruction, the simulator prints any labels
#        that immediately precede that instruction in the controller sequence. Be
#        careful to do this in a way that does not interfere with instruction
#        counting (@l(#Exercise 5.15)). You will have to make the simulator retain
#        the necessary label information.
    :: @t(Ejercicio 5.17) :: Amplíe el trazado de instrucciones del
       @l(#Ejercicio 5.16) para que antes de imprimir una
       instrucción, el simulador imprima las etiquetas que preceden
       inmediatamente a esa instrucción en la secuencia del controlador. Tenga
       cuidado de hacer esto de una manera que no interfiera con el conteo de
       instrucciones (@l(#Ejercicio 5.15) ). Tendrá que hacer
       que el simulador conserve la información de la etiqueta necesaria.

#     :: @t(Exercise 5.18) :: Modify the @c(make-register) procedure of section @l(#5.2.1)
#        so that registers can be traced. Registers should accept messages that turn
#        tracing on and off. When a register is traced, assigning a value to the
#        register should print the name of the register, the old contents of the
#        register, and the new contents being assigned. Extend the interface to the
#        machine model to permit you to turn tracing on and off for designated
#        machine registers.
    :: @t(Ejercicio 5.18) :: Modifique el procedimiento @c(make-register) de
       @l(#5.2.1) para que los registros puedan ser rastreados. Los
       registros deben aceptar mensajes que activan y desactivan el
       seguimiento. Cuando se traza un registro, asignar un valor al registro
       debe imprimir el nombre del registro, el contenido antiguo del registro y
       el nuevo contenido que se asigna. Extienda la interfaz al modelo de la
       máquina para permitirle activar y desactivar el rastreo para los
       registros de máquina designados.

#     :: @t(Exercise 5.19) :: Alyssa P. Hacker wants a @e(breakpoint) feature in the
#        simulator to help her debug her machine designs. You have been hired to
#        install this feature for her. She wants to be able to specify a place in
#        the controller sequence where the simulator will stop and allow her to
#        examine the state of the machine. You are to implement a procedure
    :: @t(Ejercicio 5.19) :: Alyssa P. Hacker quiere una función de @e(punto de
       interrupción) en el simulador para ayudarla a depurar sus diseños de
       máquinas. Te han contratado para instalar esta función para ella. Ella
       quiere ser capaz de especificar un lugar en la secuencia del controlador
       donde el simulador se detendrá y le permitirá examinar el estado de la
       máquina. Usted debe implementar un procedimiento

#        ..src > scheme
#          (set-breakpoint ⟨machine⟩ ⟨label⟩ ⟨n⟩)
#        < src..
       ..src > scheme
         (set-breakpoint ⟨machine⟩ ⟨label⟩ ⟨n⟩)
       < src..

#        that sets a breakpoint just before the @m(nᵗʰ) instruction after the given
#        label. For example,
       que establece un punto de interrupción justo antes de la @m(nᵗʰ)
       instrucción después de la etiqueta dada. Por ejemplo,

#        ..src > scheme
#          (set-breakpoint gcd-machine 'test-b 4)
#        < src..
       ..src > scheme
         (set-breakpoint gcd-machine 'test-b 4)
       < src..

#        installs a breakpoint in @c(gcd-machine) just before the assignment to
#        register @c(a). When the simulator reaches the breakpoint it should print
#        the label and the offset of the breakpoint and stop executing instructions.
#        Alyssa can then use @c(get-register-contents) and
#        @c(set-register-contents!) to manipulate the state of the simulated
#        machine.  She should then be able to continue execution by saying
       Instala un punto de interrupción @c(gcd-machine) justo antes de la
       asignación para registrarse @c(a). Cuando el simulador alcanza el punto
       de ruptura, debe imprimir la etiqueta y el desplazamiento del punto de
       interrupción y dejar de ejecutar las instrucciones. Alyssa puede utilizar
       @c(get-register-contents) y @c(set-register-contents!) manipular el
       estado de la máquina simulada. Ella debería entonces poder continuar la
       ejecución diciendo

#        ..src > scheme
#          (proceed-machine ⟨machine⟩)
#        < src..
       ..src > scheme
         (proceed-machine ⟨machine⟩)
       < src..

#        She should also be able to remove a specific breakpoint by means of
       También debería ser capaz de eliminar un punto de interrupción específico
       mediante

#        ..src > scheme
#          (cancel-breakpoint ⟨machine⟩ ⟨label⟩ ⟨n⟩)
#        < src..
       ..src > scheme
         (cancel-breakpoint ⟨machine⟩ ⟨label⟩ ⟨n⟩)
       < src..

#        or to remove all breakpoints by means of
       O eliminar todos los puntos de interrupción mediante

#        ..src > scheme
#          (cancel-all-breakpoints ⟨machine⟩)
#        < src..
       ..src > scheme
         (cancel-all-breakpoints ⟨machine⟩)
       < src..

# ** 5.3 <> Storage Allocation and Garbage Collection
** 5.3 <> Asignación de almacenamiento y recolección de basura

#    In section @l(#5.4), we will show how to implement a Scheme evaluator as a
#    register machine. In order to simplify the discussion, we will assume that our
#    register machines can be equipped with a @e(list-structured memory), in which
#    the basic operations for manipulating list-structured data are primitive.
#    Postulating the existence of such a memory is a useful abstraction when one is
#    focusing on the mechanisms of control in a Scheme interpreter, but this does
#    not reflect a realistic view of the actual primitive data operations of
#    contemporary computers. To obtain a more complete picture of how a Lisp system
#    operates, we must investigate how list structure can be represented in a way
#    that is compatible with conventional computer memories.
   En la sección @l(#5.4), mostraremos cómo implementar un evaluador de
   Scheme como una máquina de registro. Con el fin de simplificar la discusión,
   asumiremos que nuestras máquinas registradoras pueden estar equipadas con una
   @e(memoria estructurada en lista), en la que las operaciones básicas para
   manipular datos estructurados por listas son primitivas. Postular la
   existencia de tal memoria es una abstracción útil cuando uno se está
   enfocando en los mecanismos de control en un intérprete Scheme, pero esto no
   refleja una visión realista de las operaciones reales de datos primitivos de
   las computadoras contemporáneas. Para obtener una imagen más completa de cómo
   funciona un sistema Lisp, debemos investigar cómo la estructura de la lista
   se puede representar de una manera que sea compatible con las memorias
   convencionales del ordenador.

#    There are two considerations in implementing list structure. The first is
#    purely an issue of representation: how to represent the @"(box-and-pointer)
#    structure of Lisp pairs, using only the storage and addressing capabilities of
#    typical computer memories. The second issue concerns the management of memory
#    as a computation proceeds. The operation of a Lisp system depends crucially on
#    the ability to continually create new data objects. These include objects that
#    are explicitly created by the Lisp procedures being interpreted as well as
#    structures created by the interpreter itself, such as environments and
#    argument lists. Although the constant creation of new data objects would pose
#    no problem on a computer with an infinite amount of rapidly addressable
#    memory, computer memories are available only in finite sizes (more's the
#    pity). Lisp systems thus provide an @e(automatic storage allocation) facility
#    to support the illusion of an infinite memory. When a data object is no longer
#    needed, the memory allocated to it is automatically recycled and used to
#    construct new data objects. There are various techniques for providing such
#    automatic storage allocation. The method we shall discuss in this section is
#    called @e(garbage collection).
   Hay dos consideraciones en la implementación de la estructura de lista. La
   primera es puramente una cuestión de representación: cómo representar la
   estructura de @"(cuadro y puntero) de los pares Lisp, utilizando sólo las
   capacidades de almacenamiento y direccionamiento de las memorias típicas del
   ordenador. La segunda cuestión se refiere a la gestión de la memoria a medida
   que avanza el cálculo. El funcionamiento de un sistema Lisp depende
   fundamentalmente de la capacidad de crear continuamente nuevos objetos de
   datos. Estos incluyen objetos que son explícitamente creados por los
   procedimientos Lisp que se interpretan, así como las estructuras creadas por
   el propio intérprete, tales como entornos y listas de argumentos. Aunque la
   creación constante de nuevos objetos de datos no plantearía ningún problema
   en una computadora con una cantidad infinita de memoria direccionable
   rápidamente, las memorias de la computadora están disponibles sólo en tamaños
   finitos (más " Es la lástima). Por lo tanto, los sistemas Lisp proporcionan
   una facilidad de @e(asignación automática de almacenamiento) para soportar la
   ilusión de una memoria infinita. Cuando ya no se necesita un objeto de datos,
   la memoria asignada a él se recicla automáticamente y se utiliza para
   construir nuevos objetos de datos. Existen varias técnicas para proporcionar
   dicha asignación automática de almacenamiento. El método que trataremos en
   esta sección se llama @e(recolección de basura).

# *** 5.3.1 <> Memory as Vectors
*** 5.3.1 <> La memoria como vectores

#     A conventional computer memory can be thought of as an array of cubbyholes,
#     each of which can contain a piece of information. Each cubbyhole has a unique
#     name, called its @e(address) or @e(location). Typical memory systems provide
#     two primitive operations: one that fetches the data stored in a specified
#     location and one that assigns new data to a specified location.  Memory
#     addresses can be incremented to support sequential access to some set of the
#     cubbyholes. More generally, many important data operations require that memory
#     addresses be treated as data, which can be stored in memory locations and
#     manipulated in machine registers. The representation of list structure is one
#     application of such @e(address arithmetic).
    Una memoria de ordenador convencional puede ser pensada como una matriz de
    cubículos, cada uno de los cuales puede contener una pieza de
    información. Cada cubículo tiene un nombre único, llamado su @e(dirección) o
    @e(ubicación). Los sistemas de memoria típicos proporcionan dos operaciones
    primitivas: una que obtiene los datos almacenados en una ubicación
    especificada y otra que asigna nuevos datos a una ubicación
    especificada. Las direcciones de memoria se pueden incrementar para dar
    soporte al acceso secuencial a algunos conjuntos de cubículos. De manera más
    general, muchas operaciones importantes de datos requieren que las
    direcciones de memoria sean tratadas como datos, los cuales pueden ser
    almacenados en posiciones de memoria y manipulados en registros de
    máquina. La representación de la estructura de lista es una aplicación de
    tal @e(aritmética de direcciones).

#     To model computer memory, we use a new kind of data structure called a
#     @e(vector). Abstractly, a vector is a compound data object whose individual
#     elements can be accessed by means of an integer index in an amount of time
#     that is independent of the index.@n(290) In order to describe memory
#     operations, we use two primitive Scheme procedures for manipulating vectors:
    Para modelar la memoria del ordenador, utilizamos un nuevo tipo de
    estructura de datos denominado @e(vector). Resumenmente, un vector es un
    objeto de datos compuesto cuyos elementos individuales se pueden acceder por
    medio de un índice entero en una cantidad de tiempo que es independiente del
    índice.@n(290) Con el fin de describir las operaciones de memoria,
    utilizamos dos procedimientos Scheme de primitivas para la manipulación de
    vectores:

#     - @c[(vector-ref ⟨vector⟩ ⟨n⟩)] returns the @m(nᵗʰ) element of the vector.
    - @c[(vector-ref ⟨vector⟩ ⟨n⟩)] Devuelve el elemento @m(nᵗʰ) del vector.

#     - @c[(vector-set! ⟨vector⟩ ⟨n⟩ ⟨value⟩)] sets the @m(nᵗʰ) element of the
#       vector to the designated value.
    - @c[(vector-set! ⟨vector⟩ ⟨n⟩ ⟨value⟩)] Establece el elemento @m(nᵗʰ) del
      vector en el valor designado.


#     For example, if @c(v) is a vector, then @c[(vector-ref v 5)] gets the fifth
#     entry in the vector @c(v) and @c[(vector-set! v 5 7)] changes the value of the
#     fifth entry of the vector @c(v) to 7.@n(291) For computer memory, this access
#     can be implemented through the use of address arithmetic to combine a @e(base
#     address) that specifies the beginning location of a vector in memory with an
#     @e(index) that specifies the offset of a particular element of the vector.
    Por ejemplo, si @c(v) es un vector, @c[(vector-ref v 5)] obtiene la quinta
    entrada en el vector @c(v) y @c[(vector-set! v 5 7)] cambia el valor de la
    quinta entrada del vector @c(v) a 7.@n(291) Para la memoria del
    ordenador, este acceso se puede implementar mediante el uso de aritmética de
    direcciones para combinar una @e(base Dirección) que especifica la ubicación
    inicial de un vector en la memoria con un @e(índice) que especifica el
    desplazamiento de un elemento particular del vector.

# **** Representing Lisp data
**** Representación de datos Lisp

#      We can use vectors to implement the basic pair structures required for a
#      list-structured memory. Let us imagine that computer memory is divided into
#      two vectors: @c(the-cars) and @c(the-cdrs). We will represent list structure
#      as follows: A pointer to a pair is an index into the two vectors.  The @c(car)
#      of the pair is the entry in @c(the-cars) with the designated index, and the
#      @c(cdr) of the pair is the entry in @c(the-cdrs) with the designated index. We
#      also need a representation for objects other than pairs (such as numbers and
#      symbols) and a way to distinguish one kind of data from another. There are
#      many methods of accomplishing this, but they all reduce to using @e(typed
#      pointers), that is, to extending the notion of @"(pointer) to include
#      information on data type.@n(292) The data type enables the system to
#      distinguish a pointer to a pair (which consists of the @"(pair) data type and
#      an index into the memory vectors) from pointers to other kinds of data (which
#      consist of some other data type and whatever is being used to represent data
#      of that type). Two data objects are considered to be the same (@c(eq?)) if
#      their pointers are identical.@n(293) @l(#Figure 5.14) illustrates the use of
#      this method to represent the list @c[((1 2) 3 4)], whose box-and-pointer
#      diagram is also shown. We use letter prefixes to denote the data-type
#      information. Thus, a pointer to the pair with index 5 is denoted @c(p5), the
#      empty list is denoted by the pointer @c(e0), and a pointer to the number 4 is
#      denoted @c(n4). In the box-and-pointer diagram, we have indicated at the lower
#      left of each pair the vector index that specifies where the @c(car) and
#      @c(cdr) of the pair are stored. The blank locations in @c(the-cars) and
#      @c(the-cdrs) may contain parts of other list structures (not of interest
#      here).
     Podemos usar vectores para implementar las estructuras de pares básicas
     requeridas para una memoria estructurada en lista. Imaginemos que la
     memoria del ordenador se divide en dos vectores: @c(the-cars) y
     @c(the-cdrs). Representaremos la estructura de lista como sigue: Un puntero
     a un par es un índice en los dos vectores. La @c(car) del par es la entrada
     @c(the-cars) con el índice designado, y la @c(cdr) del par es la entrada
     @c(the-cdrs) con el índice designado. También necesitamos una
     representación para objetos distintos de pares (como números y símbolos) y
     una manera de distinguir un tipo de datos de otro. Hay muchos métodos para
     lograr esto, pero todos ellos reducen el uso de @e(punteros tipados), es
     decir, ampliar la noción de @"(puntero) para incluir información sobre el
     tipo de datos.@n(292) El tipo de datos permite al sistema distinguir
     un puntero de un par (que consiste en el tipo de datos de @"(par) y un
     índice en los vectores de memoria) de punteros a otros tipos de datos (que
     consisten en algún otro tipo de datos y lo que se está utilizando Para
     representar datos de ese tipo). Dos objetos de datos se consideran iguales
     (@c(eq?)) si sus punteros son idénticos.@n(293)
     @l(#Figure-5.14<> figura 5.14) ilustra el uso de este método para
     representar la lista @c[((1 2) 3 4)], cuyo diagrama de cuadro y puntero
     también se muestra. Utilizamos prefijos de letras para denotar la
     información de tipo de datos. Por lo tanto, se indica un puntero al par con
     el índice 5 @c(p5), la lista vacía se indica con el puntero @c(e0), y se
     indica un puntero al número 4 @c(n4). En el diagrama de caja y puntero,
     Hemos indicado en la parte inferior izquierda de cada par el índice
     vectorial que especifica dónde se almacenan el @c(car) y @c(cdr) del
     par. Las ubicaciones en blanco en @c(the-cars) y @c(the-cdrs) puede
     contener partes de otras estructuras de lista (no de interés aquí).

#      ..figure > @t(Figure 5.14) Box-and-pointer and memory-vector representations
#        of the list @c[((1 2) 3 4)].
     ..figure > @t(Figura 5.14) Representaciones de caja y puntero y vector de
       memoria de la lista @c[((1 2) 3 4)].

#        ..art >
#                         ╭───┬───╮               ╭───┬───╮    ╭───┬───╮
#          ((1 2) 3 4) ──▶│ ◆ │ ◆ ┼──────────────▶│ ◆ │ ◆ ┼───▶│ ◆ │ ╱ │
#                         ╰─┼─┴───╯               ╰─┼─┴───╯    ╰─┼─┴───╯
#                        1  │                    2  │         4  │
#                           ▼                       ▼            ▼
#                         ╭───┬───╮    ╭───┬───╮  ╭───╮        ╭───╮
#                         │ ◆ │ ◆ ┼───▶│ ◆ │ ╱ │  │ 3 │        │ 4 │
#                         ╰─┼─┴───╯    ╰─┼─┴───╯  ╰───╯        ╰───╯
#                        5  │         7  │
#                           ▼            ▼
#                         ╭───╮        ╭───╮
#                         │ 1 │        │ 2 │
#                         ╰───╯        ╰───╯
#
#             Index   0    1    2    3    4    5    6    7    8    ⋯
#                   ╭────┬────┬────┬────┬────┬────┬────┬────┬────┬────
#          the-cars │    │ p5 │ n3 │    │ n4 │ n1 │    │ n2 │    │ ⋯
#                   ├────┼────┼────┼────┼────┼────┼────┼────┼────┼────
#          the-cdrs │    │ p2 │ p4 │    │ e0 │ p7 │    │ e0 │    │ ⋯
#                   ╰────┴────┴────┴────┴────┴────┴────┴────┴────┴────
#        < art..
       ..art >
                        ╭───┬───╮               ╭───┬───╮    ╭───┬───╮
         ((1 2) 3 4) ──▶│ ◆ │ ◆ ┼──────────────▶│ ◆ │ ◆ ┼───▶│ ◆ │ ╱ │
                        ╰─┼─┴───╯               ╰─┼─┴───╯    ╰─┼─┴───╯
                       1  │                    2  │         4  │
                          ▼                       ▼            ▼
                        ╭───┬───╮    ╭───┬───╮  ╭───╮        ╭───╮
                        │ ◆ │ ◆ ┼───▶│ ◆ │ ╱ │  │ 3 │        │ 4 │
                        ╰─┼─┴───╯    ╰─┼─┴───╯  ╰───╯        ╰───╯
                       5  │         7  │
                          ▼            ▼
                        ╭───╮        ╭───╮
                        │ 1 │        │ 2 │
                        ╰───╯        ╰───╯

            Index   0    1    2    3    4    5    6    7    8    ⋯
                  ╭────┬────┬────┬────┬────┬────┬────┬────┬────┬────
         the-cars │    │ p5 │ n3 │    │ n4 │ n1 │    │ n2 │    │ ⋯
                  ├────┼────┼────┼────┼────┼────┼────┼────┼────┼────
         the-cdrs │    │ p2 │ p4 │    │ e0 │ p7 │    │ e0 │    │ ⋯
                  ╰────┴────┴────┴────┴────┴────┴────┴────┴────┴────
       < art..

# @    ..img > img/chap5/Fig5.14b.std.svg
@    ..img > img/chap5/Fig5.14b.std.svg

#      A pointer to a number, such as @c(n4), might consist of a type indicating
#      numeric data together with the actual representation of the number 4.@n(294)
#      To deal with numbers that are too large to be represented in the fixed amount
#      of space allocated for a single pointer, we could use a distinct @e(bignum)
#      data type, for which the pointer designates a list in which the parts of the
#      number are stored.@n(295)
     Un puntero a un número, tal como @c(n4), puede consistir en un tipo que
     indica datos numéricos junto con la representación real del
     número 4.@n(294) Para tratar con números que son demasiado grandes
     para representarse en la cantidad fija de espacio asignada para un único
     puntero, Podríamos usar un tipo de datos @e(bignum) distinto, para el cual
     el puntero designa una lista en la que se almacenan las partes del
     número.@n(295)

#      A symbol might be represented as a typed pointer that designates a sequence of
#      the characters that form the symbol's printed representation. This sequence is
#      constructed by the Lisp reader when the character string is initially
#      encountered in input. Since we want two instances of a symbol to be recognized
#      as the @"(same) symbol by @c(eq?) and we want @c(eq?) to be a simple test for
#      equality of pointers, we must ensure that if the reader sees the same
#      character string twice, it will use the same pointer (to the same sequence of
#      characters) to represent both occurrences. To accomplish this, the reader
#      maintains a table, traditionally called the @e(obarray), of all the symbols it
#      has ever encountered. When the reader encounters a character string and is
#      about to construct a symbol, it checks the obarray to see if it has ever
#      before seen the same character string. If it has not, it uses the characters
#      to construct a new symbol (a typed pointer to a new character sequence) and
#      enters this pointer in the obarray. If the reader has seen the string before,
#      it returns the symbol pointer stored in the obarray. This process of replacing
#      character strings by unique pointers is called @e(interning) symbols.
     Un símbolo puede ser representado como un puntero tipificado que designa
     una secuencia de los caracteres que forman la representación impresa del
     símbolo. Esta secuencia es construida por el lector Lisp cuando la cadena
     de caracteres se encuentra inicialmente en la entrada. Puesto que queremos
     que dos instancias de un símbolo sean reconocidas como el @"(mismo) símbolo
     por @c(eq?) y queremos @c(eq?) ser una prueba simple para la igualdad de
     punteros, debemos asegurarnos de que si el lector ve la misma cadena de
     caracteres dos veces, utilizará el mismo puntero A la misma secuencia de
     caracteres) para representar ambas ocurrencias. Para lograr esto, el lector
     mantiene una tabla, tradicionalmente llamada el @e(obarray), de todos los
     símbolos que ha encontrado. Cuando el lector encuentra una cadena de
     caracteres y está a punto de construir un símbolo, Comprueba el obarray
     para ver si alguna vez ha visto la misma cadena de caracteres. Si no lo ha
     hecho, utiliza los caracteres para construir un nuevo símbolo (un puntero
     tipificado a una nueva secuencia de caracteres) e introduce este puntero en
     el obarray. Si el lector ha visto la cadena antes, devuelve el puntero de
     símbolo almacenado en el obarray. Este proceso de sustitución de cadenas de
     caracteres por punteros únicos se denomina símbolos de @e(internación).

# **** Implementing the primitive list operations
**** Implementación de las operaciones de lista primitiva

#      Given the above representation scheme, we can replace each @"(primitive) list
#      operation of a register machine with one or more primitive vector operations.
#      We will use two registers, @c(the-cars) and @c(the-cdrs), to identify the
#      memory vectors, and will assume that @c(vector-ref) and @c(vector-set!)  are
#      available as primitive operations. We also assume that numeric operations on
#      pointers (such as incrementing a pointer, using a pair pointer to index a
#      vector, or adding two numbers) use only the index portion of the typed
#      pointer.
     Dado el esquema de representación anterior, podemos reemplazar cada
     operación de lista @"(primitiva) de una máquina registradora con una o más
     operaciones vectoriales primitivas. Vamos a utilizar dos registros,
     @c(the-cars) y @c(the-cdrs), para identificar los vectores de memoria, y
     asumir que @c(vector-ref) y @c(vector-set!)  están disponibles como
     operaciones primitivas. También suponemos que las operaciones numéricas en
     punteros (como el incremento de un puntero, el uso de un puntero de par
     para indexar un vector o la adición de dos números) utilizan sólo la parte
     del índice del puntero de tipo.

#      For example, we can make a register machine support the instructions
     Por ejemplo, podemos hacer que una máquina de registro apoye las
     instrucciones

#      ..src > scheme
#        (assign ⟨reg₁⟩ (op car) (reg ⟨reg₂⟩))
#        (assign ⟨reg₁⟩ (op cdr) (reg ⟨reg₂⟩))
#      < src..
     ..src > scheme
       (assign ⟨reg₁⟩ (op car) (reg ⟨reg₂⟩))
       (assign ⟨reg₁⟩ (op cdr) (reg ⟨reg₂⟩))
     < src..

#      if we implement these, respectively, as
     Si los implementamos, respectivamente, como

#      ..src > scheme
#        (assign ⟨reg₁⟩
#                (op vector-ref)
#                (reg the-cars)
#                (reg ⟨reg₂⟩))
#        (assign ⟨reg₁⟩
#                (op vector-ref)
#                (reg the-cdrs)
#                (reg ⟨reg₂⟩))
#      < src..
     ..src > scheme
       (assign ⟨reg₁⟩
               (op vector-ref)
               (reg the-cars)
               (reg ⟨reg₂⟩))
       (assign ⟨reg₁⟩
               (op vector-ref)
               (reg the-cdrs)
               (reg ⟨reg₂⟩))
     < src..

#      The instructions
     Las instrucciones

#      ..src > scheme
#        (perform (op set-car!) (reg ⟨reg₁⟩) (reg ⟨reg₂⟩))
#        (perform (op set-cdr!) (reg ⟨reg₁⟩) (reg ⟨reg₂⟩))
#      < src..
     ..src > scheme
       (perform (op set-car!) (reg ⟨reg₁⟩) (reg ⟨reg₂⟩))
       (perform (op set-cdr!) (reg ⟨reg₁⟩) (reg ⟨reg₂⟩))
     < src..

#      are implemented as
     Se implementan como

#      ..src > scheme
#        (perform (op vector-set!)
#                 (reg the-cars)
#                 (reg ⟨reg₁⟩)
#                 (reg ⟨reg₂⟩))
#        (perform (op vector-set!)
#                 (reg the-cdrs)
#                 (reg ⟨reg₁⟩)
#                 (reg ⟨reg₂⟩))
#      < src..
     ..src > scheme
       (perform (op vector-set!)
                (reg the-cars)
                (reg ⟨reg₁⟩)
                (reg ⟨reg₂⟩))
       (perform (op vector-set!)
                (reg the-cdrs)
                (reg ⟨reg₁⟩)
                (reg ⟨reg₂⟩))
     < src..

#      @c(Cons) is performed by allocating an unused index and storing the arguments
#      to @c(cons) in @c(the-cars) and @c(the-cdrs) at that indexed vector
#      position. We presume that there is a special register, @c(free), that always
#      holds a pair pointer containing the next available index, and that we can
#      increment the index part of that pointer to find the next free
#      location.@n(296) For example, the instruction
     @c(Cons) Se realiza asignando un índice no utilizado y almacenando los
     argumentos @c(cons) en @c(the-cars) y @c(the-cdrs) en esa posición de
     vector indexada. Suponemos que hay un registro especial,, @c(free) que
     siempre tiene un puntero de par que contiene el siguiente índice
     disponible, y que podemos incrementar la parte del índice de ese puntero
     para encontrar la siguiente ubicación libre.@n(296) Por ejemplo, la
     instrucción

#      ..src > scheme
#        (assign ⟨reg₁⟩
#                (op cons)
#                (reg ⟨reg₂⟩)
#                (reg ⟨reg₃⟩))
#      < src..
     ..src > scheme
       (assign ⟨reg₁⟩
               (op cons)
               (reg ⟨reg₂⟩)
               (reg ⟨reg₃⟩))
     < src..

#      is implemented as the following sequence of vector operations:@n(297)
     Se implementa como la siguiente secuencia de operaciones vectoriales:
    @n(297)

#      ..src > scheme
#        (perform (op vector-set!)
#                 (reg the-cars)
#                 (reg free)
#                 (reg ⟨reg₂⟩))
#        (perform (op vector-set!)
#                 (reg the-cdrs)
#                 (reg free)
#                 (reg ⟨reg₃⟩))
#        (assign ⟨reg₁⟩ (reg free))
#        (assign free (op +) (reg free) (const 1))
#      < src..
     ..src > scheme
       (perform (op vector-set!)
                (reg the-cars)
                (reg free)
                (reg ⟨reg₂⟩))
       (perform (op vector-set!)
                (reg the-cdrs)
                (reg free)
                (reg ⟨reg₃⟩))
       (assign ⟨reg₁⟩ (reg free))
       (assign free (op +) (reg free) (const 1))
     < src..

#      The @c(eq?) operation
     La @c(eq?) operación

#      ..src > scheme
#        (op eq?) (reg ⟨reg₁⟩) (reg ⟨reg₂⟩)
#      < src..
     ..src > scheme
       (op eq?) (reg ⟨reg₁⟩) (reg ⟨reg₂⟩)
     < src..

#      simply tests the equality of all fields in the registers, and predicates such
#      as @c(pair?), @c(null?), @c(symbol?), and @c(number?) need only check the type
#      field.
     simplemente comprueba la igualdad de todos los campos en los registros, y
     los predicados tales como @c(pair?), @c(null?), @c(symbol?), y @c(number?)
     sólo tiene que comprobar el campo Tipo.

# **** Implementing stacks
**** Implementación de pilas

#      Although our register machines use stacks, we need do nothing special here,
#      since stacks can be modeled in terms of lists. The stack can be a list of the
#      saved values, pointed to by a special register @c(the-stack). Thus, @c[(save
#      ⟨reg⟩)] can be implemented as
     Aunque nuestras máquinas de registro utilizan pilas, no necesitamos hacer
     nada especial aquí, ya que las pilas pueden ser modeladas en términos de
     listas. La pila puede ser una lista de los valores guardados, señalada por
     un registro especial @c(the-stack). Así, @c[(save ⟨reg⟩)] se puede
     implementar como

#      ..src > scheme
#        (assign the-stack
#                (op cons)
#                (reg ⟨reg⟩)
#                (reg the-stack))
#      < src..
     ..src > scheme
       (assign the-stack
               (op cons)
               (reg ⟨reg⟩)
               (reg the-stack))
     < src..

#      Similarly, @c[(restore ⟨reg⟩)] can be implemented as
     Del mismo modo, @c[(restore ⟨reg⟩)] se puede implementar como

#      ..src > scheme
#        (assign ⟨reg⟩ (op car) (reg the-stack))
#        (assign the-stack (op cdr) (reg the-stack))
#      < src..
     ..src > scheme
       (assign ⟨reg⟩ (op car) (reg the-stack))
       (assign the-stack (op cdr) (reg the-stack))
     < src..

#      and @c[(perform (op initialize-stack))] can be implemented as
     Y @c[(perform (op initialize-stack))] puede ser implementado como

#      ..src > scheme
#        (assign the-stack (const ()))
#      < src..
     ..src > scheme
       (assign the-stack (const ()))
     < src..

#      These operations can be further expanded in terms of the vector operations
#      given above. In conventional computer architectures, however, it is usually
#      advantageous to allocate the stack as a separate vector. Then pushing and
#      popping the stack can be accomplished by incrementing or decrementing an index
#      into that vector.
     Estas operaciones pueden ampliarse adicionalmente en términos de las
     operaciones de vector dadas anteriormente. Sin embargo, en arquitecturas de
     ordenador convencionales, suele ser ventajoso asignar la pila como un
     vector separado. A continuación, empujar y hacer estallar la pila se puede
     lograr incrementando o disminuyendo un índice en ese vector.

#      :: @t(Exercise 5.20) :: Draw the box-and-pointer representation and the
#         memory-vector representation (as in @l(#Figure 5.14)) of the list structure
#         produced by
     :: @t(Ejercicio 5.20) :: Dibuje la representación de cuadro y puntero y la
        representación de vector de memoria (como en la @l(#Figura
        5.14) ) de la estructura de lista producida por

#         ..src > scheme
#           (define x (cons 1 2))
#           (define y (list x x))
#         < src..
        ..src > scheme
          (define x (cons 1 2))
          (define y (list x x))
        < src..

#         with the @c(free) pointer initially @c(p1). What is the final value of
#         @c(free)?  What pointers represent the values of @c(x) and @c(y)?
        Con el @c(free) puntero inicialmente @c(p1). ¿Cuál es el valor final de
        @c(free)? ¿Qué punteros representan los valores de @c(x) y @c(y)?

#      :: @t(Exercise 5.21) :: Implement register machines for the following
#         procedures. Assume that the list-structure memory operations are available
#         as machine primitives.
     :: @t(Ejercicio 5.21) :: Implementar máquinas registradoras para los
        siguientes procedimientos. Suponga que las operaciones de memoria de
        estructura de lista están disponibles como primitivas de máquina.

#         1. Recursive @c(count-leaves):
        1. Recursivo @c(count-leaves):

#            ..src > scheme
#              (define (count-leaves tree)
#                (cond ((null? tree) 0)
#                      ((not (pair? tree)) 1)
#                      (else
#                       (+ (count-leaves (car tree))
#                          (count-leaves (cdr tree))))))
#            < src..
           ..src > scheme
             (define (count-leaves tree)
               (cond ((null? tree) 0)
                     ((not (pair? tree)) 1)
                     (else
                      (+ (count-leaves (car tree))
                         (count-leaves (cdr tree))))))
           < src..

#         2. Recursive @c(count-leaves) with explicit counter:
        2. Recursivo @c(count-leaves) con contador explícito:

#            ..src > scheme
#              (define (count-leaves tree)
#                (define (count-iter tree n)
#                  (cond ((null? tree) n)
#                        ((not (pair? tree)) (+ n 1))
#                        (else
#                         (count-iter
#                          (cdr tree)
#                          (count-iter (car tree)
#                                      n)))))
#                (count-iter tree 0))
#            < src..
           ..src > scheme
             (define (count-leaves tree)
               (define (count-iter tree n)
                 (cond ((null? tree) n)
                       ((not (pair? tree)) (+ n 1))
                       (else
                        (count-iter
                         (cdr tree)
                         (count-iter (car tree)
                                     n)))))
               (count-iter tree 0))
           < src..

#      :: @t(Exercise 5.22) :: @l(#Exercise 3.12) of section @l(#3.3.1) presented an
#         @c(append) procedure that appends two lists to form a new list and an
#         @c(append!) procedure that splices two lists together.  Design a register
#         machine to implement each of these procedures. Assume that the
#         list-structure memory operations are available as primitive operations.
     :: @t(Ejercicio 5.22) :: @l(#Ejercicio 3.12) de
        @l(#3.3.1) presentó un procedimiento @c(append) que agrega dos
        listas para formar una nueva lista y un procedimiento @c(append!) que
        empalma dos listas juntas. Diseñar una máquina de registro para
        implementar cada uno de estos procedimientos. Suponga que las
        operaciones de memoria de estructura de lista están disponibles como
        operaciones primitivas.

# *** 5.3.2 <> Maintaining the Illusion of Infinite Memory
*** 5.3.2 <> Mantener la ilusión de la memoria infinita

#     The representation method outlined in section @l(#5.3.1) solves the problem of
#     implementing list structure, provided that we have an infinite amount of
#     memory. With a real computer we will eventually run out of free space in which
#     to construct new pairs.@n(298) However, most of the pairs generated in a
#     typical computation are used only to hold intermediate results. After these
#     results are accessed, the pairs are no longer needed––they are
#     @e(garbage). For instance, the computation
    El método de representación descrito en la seccion @l(#5.3.1) resuelve el
    problema de implementar la estructura de lista, siempre que tengamos una
    cantidad infinita de memoria. Con una computadora real, eventualmente nos
    quedaremos sin espacio libre para construir pares nuevos.@n(298) Sin
    embargo, la mayoría de los pares generados en un cálculo típico sólo se
    utilizan para mantener los resultados intermedios. Después de acceder a
    estos resultados, los pares ya no son necesarios - son @e(basura). Por
    ejemplo, el cálculo

#     ..src > scheme
#       (accumulate
#        +
#        0
#        (filter odd? (enumerate-interval 0 n)))
#     < src..
    ..src > scheme
      (accumulate
       +
       0
       (filter odd? (enumerate-interval 0 n)))
    < src..

#     constructs two lists: the enumeration and the result of filtering the
#     enumeration. When the accumulation is complete, these lists are no longer
#     needed, and the allocated memory can be reclaimed. If we can arrange to
#     collect all the garbage periodically, and if this turns out to recycle memory
#     at about the same rate at which we construct new pairs, we will have preserved
#     the illusion that there is an infinite amount of memory.
    Construye dos listas: la enumeración y el resultado de filtrar la
    enumeración. Cuando se completa la acumulación, estas listas ya no son
    necesarias, y la memoria asignada puede ser recuperada. Si podemos arreglar
    para recoger toda la basura periódicamente, y si esto resulta para reciclar
    la memoria en la misma proporción en la que construimos nuevos pares,
    habremos conservado la ilusión de que hay una cantidad infinita de memoria.

#     In order to recycle pairs, we must have a way to determine which allocated
#     pairs are not needed (in the sense that their contents can no longer influence
#     the future of the computation). The method we shall examine for accomplishing
#     this is known as @e(garbage collection). Garbage collection is based on the
#     observation that, at any moment in a Lisp interpretation, the only objects
#     that can affect the future of the computation are those that can be reached by
#     some succession of @c(car) and @c(cdr) operations starting from the pointers
#     that are currently in the machine registers.@n(299) Any memory cell that is
#     not so accessible may be recycled.
    Para reciclar pares, debemos tener una manera de determinar qué pares
    asignados no son necesarios (en el sentido de que su contenido ya no puede
    influir en el futuro del cálculo). El método que examinaremos para lograr
    esto se conoce como @e(recolección de basura). La recolección de basura se
    basa en la observación de que, en cualquier momento en una interpretación
    Lisp, los únicos objetos que pueden afectar el futuro de la computación son
    las que se puede llegar en alguna sucesión de @c(car) y @c(cdr) operaciones
    a partir de los punteros que están actualmente en la máquina Registros
   @n(299) Cualquier celda de memoria que no esté tan accesible puede ser
    reciclada.

#     There are many ways to perform garbage collection. The method we shall examine
#     here is called @e(stop-and-copy). The basic idea is to divide memory into two
#     halves: @"(working memory) and @"(free memory.)  When @c(cons) constructs
#     pairs, it allocates these in working memory. When working memory is full, we
#     perform garbage collection by locating all the useful pairs in working memory
#     and copying these into consecutive locations in free memory. (The useful pairs
#     are located by tracing all the @c(car) and @c(cdr) pointers, starting with the
#     machine registers.)  Since we do not copy the garbage, there will presumably
#     be additional free memory that we can use to allocate new pairs. In addition,
#     nothing in the working memory is needed, since all the useful pairs in it have
#     been copied. Thus, if we interchange the roles of working memory and free
#     memory, we can continue processing; new pairs will be allocated in the new
#     working memory (which was the old free memory). When this is full, we can copy
#     the useful pairs into the new free memory (which was the old working
#     memory).@n(300)
    Hay muchas maneras de realizar la recolección de basura. El método que
    examinaremos aquí se llama @e(detener y copiar). La idea básica es dividir
    la memoria en dos mitades: @"(memoria de trabajo) y @"(memoria libre. )
    Cuando se @c(cons) construye pares, los asigna en la memoria de
    trabajo. Cuando la memoria de trabajo está llena, realizamos la recolección
    de basura localizando todos los pares útiles en la memoria de trabajo y
    copiándolos en ubicaciones consecutivas en la memoria libre. (Los pares
    útiles se localizan trazando todos los @c(car) y @c(cdr) punteros,
    comenzando con los registros de la máquina.) Puesto que no copiamos la
    basura, probablemente habrá memoria libre adicional que podamos usar para
    asignar nuevos pares. Además, no se necesita nada en la memoria de trabajo,
    Ya que todos los pares útiles en él han sido copiados. Por lo tanto, si
    intercambiamos los roles de memoria de trabajo y memoria libre, podemos
    continuar procesando; Se asignarán nuevos pares en la nueva memoria de
    trabajo (que era la antigua memoria libre). Cuando está lleno, podemos
    copiar los pares útiles en la nueva memoria libre (que era la memoria de
    trabajo antigua).@n(300)

# **** Implementation of a stop-and-copy garbage collector
**** Implementación de un recolector de basura stop-and-copy

#      We now use our register-machine language to describe the stop-and-copy
#      algorithm in more detail. We will assume that there is a register called
#      @c(root) that contains a pointer to a structure that eventually points at all
#      accessible data. This can be arranged by storing the contents of all the
#      machine registers in a pre-allocated list pointed at by @c(root) just before
#      starting garbage collection.@n(301) We also assume that, in addition to the
#      current working memory, there is free memory available into which we can copy
#      the useful data. The current working memory consists of vectors whose base
#      addresses are in registers called @c(the-cars) and @c(the-cdrs), and the free
#      memory is in registers called @c(new-cars) and @c(new-cdrs).
     Ahora usamos nuestro lenguaje de registro-máquina para describir el
     algoritmo de detener y copiar con más detalle. Asumiremos que hay un
     registro llamado @c(root) que contiene un puntero a una estructura que
     eventualmente apunta a todos los datos accesibles. Esto se puede arreglar
     almacenando el contenido de todos los registros de máquina en una lista
     previamente asignada apuntada en @c(root) justo antes de comenzar la
     recolección de basura.@n(301) También suponemos que, además de la
     memoria de trabajo actual, hay memoria disponible en la que podemos copiar
     los datos útiles. La memoria de trabajo actual consiste en vectores cuyas
     direcciones de base están en registros llamados @c(the-cars) y
     @c(the-cdrs), y la memoria libre está en registros llamados @c(new-cars) y
     @c(new-cdrs).

#      Garbage collection is triggered when we exhaust the free cells in the current
#      working memory, that is, when a @c(cons) operation attempts to increment the
#      @c(free) pointer beyond the end of the memory vector. When the
#      garbage-collection process is complete, the @c(root) pointer will point into
#      the new memory, all objects accessible from the @c(root) will have been moved
#      to the new memory, and the @c(free) pointer will indicate the next place in
#      the new memory where a new pair can be allocated. In addition, the roles of
#      working memory and new memory will have been interchanged––new pairs will be
#      constructed in the new memory, beginning at the place indicated by @c(free),
#      and the (previous) working memory will be available as the new memory for the
#      next garbage collection. @l(#Figure 5.15) shows the arrangement of memory just
#      before and just after garbage collection.
     La recolección de basura se activa cuando se agotan las celdas libres en la
     memoria de trabajo actual, es decir, cuando una @c(cons) operación intenta
     incrementar el @c(free) puntero más allá del final del vector de
     memoria. Cuando el proceso de recolección de basura se ha completado, el
     @c(root) puntero apuntará a la nueva memoria, todos los objetos accesibles
     desde la @c(root) voluntad se han movido a la nueva memoria, y el @c(free)
     puntero indicará el siguiente lugar en la nueva memoria donde un nuevo par
     puede ser asignado. Además, se habrán intercambiado los papeles de memoria
     de trabajo y nueva memoria - se construirán nuevos pares en la nueva
     memoria, comenzando en el lugar indicado por @c(free), y la memoria de
     trabajo (previa) estará disponible como nueva memoria para el Próxima
     recolección de basura. @l(#Figura 5.)

#      ..figure > @t(Figure 5.15) Reconfiguration of memory by the garbage-collection
#        process.
     ..figure > @t(Figura 5.15) Reconfiguración de memoria por el proceso de
       recolección de basura.

#        ..art >
#                       Just before garbage collection
#
#                   ╭────────────────────────────────────╮
#          the-cars │                                    │ working
#                   │ mixture of useful data and garbage │ memory
#          the-cdrs │                                    │
#                   ╰────────────────────────────────────╯
#                                                      ▲
#                                                      │ free
#
#                   ╭────────────────────────────────────╮
#          new-cars │                                    │ free
#                   │            free memory             │ memory
#          new-cdrs │                                    │
#                   ╰────────────────────────────────────╯
#
#                       Just after garbage collection
#
#                   ╭────────────────────────────────────╮
#          new-cars │                                    │ new
#                   │          discarded memory          │ free
#          new-cdrs │                                    │ memory
#                   ╰────────────────────────────────────╯
#
#                   ╭──────────────────┬─────────────────╮
#          the-cars │                  │                 │ new
#                   │   useful data    │    free area    │ working
#          the-cdrs │                  │                 │ memory
#                   ╰──────────────────┴─────────────────╯
#                                        ▲
#                                        | free
#        < art..
       ..art >
                      Just before garbage collection

                  ╭────────────────────────────────────╮
         the-cars │                                    │ working
                  │ mixture of useful data and garbage │ memory
         the-cdrs │                                    │
                  ╰────────────────────────────────────╯
                                                     ▲
                                                     │ free

                  ╭────────────────────────────────────╮
         new-cars │                                    │ free
                  │            free memory             │ memory
         new-cdrs │                                    │
                  ╰────────────────────────────────────╯

                      Just after garbage collection

                  ╭────────────────────────────────────╮
         new-cars │                                    │ new
                  │          discarded memory          │ free
         new-cdrs │                                    │ memory
                  ╰────────────────────────────────────╯

                  ╭──────────────────┬─────────────────╮
         the-cars │                  │                 │ new
                  │   useful data    │    free area    │ working
         the-cdrs │                  │                 │ memory
                  ╰──────────────────┴─────────────────╯
                                       ▲
                                       | free
       < art..

# @    ..img > img/chap5/Fig5.15c.std.svg
@    ..img > img/chap5/Fig5.15c.std.svg

#      The state of the garbage-collection process is controlled by maintaining two
#      pointers: @c(free) and @c(scan). These are initialized to point to the
#      beginning of the new memory. The algorithm begins by relocating the pair
#      pointed at by @c(root) to the beginning of the new memory. The pair is copied,
#      the @c(root) pointer is adjusted to point to the new location, and the
#      @c(free) pointer is incremented. In addition, the old location of the pair is
#      marked to show that its contents have been moved. This marking is done as
#      follows: In the @c(car) position, we place a special tag that signals that
#      this is an already-moved object. (Such an object is traditionally called a
#      @e(broken heart).)@n(302) In the @c(cdr) position we place a @e(forwarding
#      address) that points at the location to which the object has been moved.
     El estado del proceso de recolección de basura se controla manteniendo dos
     punteros: @c(free) y @c(scan). Éstos se inicializan para señalar el
     comienzo de la nueva memoria. El algoritmo comienza relocalizando el par
     apuntado en @c(root) al comienzo de la nueva memoria. El par se copia, el
     @c(root) puntero se ajusta para apuntar a la nueva ubicación y el @c(free)
     puntero se incrementa. Además, la antigua ubicación del par está marcada
     para mostrar que su contenido ha sido movido. Esta marca se realiza de la
     siguiente manera: En la @c(car) posición, colocamos una etiqueta especial
     que indica que se trata de un objeto ya movido. (Este objeto es
     tradicionalmente llamado un @e(corazón roto) .@n(302) @c(cdr)@e()

#      After relocating the root, the garbage collector enters its basic cycle. At
#      each step in the algorithm, the @c(scan) pointer (initially pointing at the
#      relocated root) points at a pair that has been moved to the new memory but
#      whose @c(car) and @c(cdr) pointers still refer to objects in the old
#      memory. These objects are each relocated, and the @c(scan) pointer is
#      incremented. To relocate an object (for example, the object indicated by the
#      @c(car) pointer of the pair we are scanning) we check to see if the object has
#      already been moved (as indicated by the presence of a broken-heart tag in the
#      @c(car) position of the object). If the object has not already been moved, we
#      copy it to the place indicated by @c(free), update @c(free), set up a broken
#      heart at the object's old location, and update the pointer to the object (in
#      this example, the @c(car) pointer of the pair we are scanning) to point to the
#      new location. If the object has already been moved, its forwarding address
#      (found in the @c(cdr) position of the broken heart) is substituted for the
#      pointer in the pair being scanned. Eventually, all accessible objects will
#      have been moved and scanned, at which point the @c(scan) pointer will overtake
#      the @c(free) pointer and the process will terminate.
     Después de reubicar la raíz, el recolector de basura entra en su ciclo
     básico. En cada paso del algoritmo, el @c(scan) puntero (inicialmente
     apunta a la raíz reubicado) puntos en un par que se ha movido a la nueva
     memoria, pero cuyos @c(car) y @c(cdr) punteros todavía se refieren a los
     objetos en la memoria antigua. Estos objetos se reasignan cada uno, y el
     @c(scan) puntero se incrementa. Para reubicar un objeto (por ejemplo, el
     objeto indicado por el @c(car) puntero del par que estamos escaneando)
     verificamos si el objeto ya se ha movido (como lo indica la presencia de
     una etiqueta de corazón roto en la @c(car) posición del objeto ). Si el
     objeto aún no ha sido movido, lo copiamos al lugar indicado por @c(free),
     actualizamos @c(free), configuramos un corazón roto en la ubicación antigua
     del objeto, @c(car) Y actualizar el puntero al objeto (en este ejemplo, el
     puntero del par que estamos escaneando) para apuntar a la nueva
     ubicación. Si el objeto ya se ha movido, su dirección de reenvío (que se
     encuentra en la @c(cdr) posición del corazón roto) se sustituye por el
     puntero en el par que se está escaneando. Finalmente, todos los objetos
     accesibles se habrán movido y escaneado, en cuyo punto el @c(scan) puntero
     superará el @c(free) puntero y el proceso terminará.

#      We can specify the stop-and-copy algorithm as a sequence of instructions for a
#      register machine. The basic step of relocating an object is accomplished by a
#      subroutine called @c(relocate-old-result-in-new). This subroutine gets its
#      argument, a pointer to the object to be relocated, from a register named
#      @c(old). It relocates the designated object (incrementing @c(free) in the
#      process), puts a pointer to the relocated object into a register called
#      @c(new), and returns by branching to the entry point stored in the register
#      @c(relocate-continue). To begin garbage collection, we invoke this subroutine
#      to relocate the @c(root) pointer, after initializing @c(free) and
#      @c(scan). When the relocation of @c(root) has been accomplished, we install
#      the new pointer as the new @c(root) and enter the main loop of the garbage
#      collector.
     Podemos especificar el algoritmo stop-and-copy como una secuencia de
     instrucciones para una máquina registradora. El paso básico de reubicar un
     objeto se realiza mediante una subrutina llamada
     @c(relocate-old-result-in-new). Esta subrutina obtiene su argumento, un
     puntero al objeto a reubicar, de un registro llamado @c(old). Reubica el
     objeto designado (incrementando @c(free) en el proceso), pone un puntero al
     objeto reubicado en un registro llamado @c(new) y retorna por ramificación
     al punto de entrada almacenado en el registro @c(relocate-continue). Para
     comenzar la recolección de basura, invocamos esta subrutina para reubicar
     el @c(root) puntero, después de inicializar @c(free) y @c(scan). Cuando
     @c(root) se ha realizado la reubicación, instalamos el nuevo puntero como
     nuevo @c(root) e ingresamos al bucle principal del recolector de basura.

#      ..src > scheme
#        begin-garbage-collection
#          (assign free (const 0))
#          (assign scan (const 0))
#          (assign old (reg root))
#          (assign relocate-continue
#                  (label reassign-root))
#          (goto (label relocate-old-result-in-new))
#        reassign-root
#          (assign root (reg new))
#          (goto (label gc-loop))
#      < src..
     ..src > scheme
       begin-garbage-collection
         (assign free (const 0))
         (assign scan (const 0))
         (assign old (reg root))
         (assign relocate-continue
                 (label reassign-root))
         (goto (label relocate-old-result-in-new))
       reassign-root
         (assign root (reg new))
         (goto (label gc-loop))
     < src..

#      In the main loop of the garbage collector we must determine whether there are
#      any more objects to be scanned. We do this by testing whether the @c(scan)
#      pointer is coincident with the @c(free) pointer. If the pointers are equal,
#      then all accessible objects have been relocated, and we branch to @c(gc-flip),
#      which cleans things up so that we can continue the interrupted computation. If
#      there are still pairs to be scanned, we call the relocate subroutine to
#      relocate the @c(car) of the next pair (by placing the @c(car) pointer in
#      @c(old)). The @c(relocate-continue) register is set up so that the subroutine
#      will return to update the @c(car) pointer.
     En el bucle principal del recolector de basura debemos determinar si hay
     más objetos que deben ser escaneados. Hacemos esto comprobando si el
     @c(scan) puntero es coincidente con el @c(free) puntero. Si los punteros
     son iguales, entonces todos los objetos accesibles han sido reubicados, y
     nos ramificamos a @c(gc-flip), lo que limpia las cosas para que podamos
     continuar el cálculo interrumpido. Si aún hay parejas que se van a
     escanear, llamamos a la subrutina de reubicación para reubicar la @c(car)
     del siguiente par (colocando el @c(car) puntero en @c(old)). El
     @c(relocate-continue) registro se configura para que la subrutina regrese
     para actualizar el @c(car) puntero.

#      ..src > scheme
#        gc-loop
#          (test (op =) (reg scan) (reg free))
#          (branch (label gc-flip))
#          (assign old
#                  (op vector-ref)
#                  (reg new-cars)
#                  (reg scan))
#          (assign relocate-continue
#                  (label update-car))
#          (goto (label relocate-old-result-in-new))
#      < src..
     ..src > scheme
       gc-loop
         (test (op =) (reg scan) (reg free))
         (branch (label gc-flip))
         (assign old
                 (op vector-ref)
                 (reg new-cars)
                 (reg scan))
         (assign relocate-continue
                 (label update-car))
         (goto (label relocate-old-result-in-new))
     < src..

#      At @c(update-car), we modify the @c(car) pointer of the pair being scanned,
#      then proceed to relocate the @c(cdr) of the pair. We return to @c(update-cdr)
#      when that relocation has been accomplished. After relocating and updating the
#      @c(cdr), we are finished scanning that pair, so we continue with the main
#      loop.
     En @c(update-car), modificamos el @c(car) puntero del par que se está
     escaneando, luego procedemos a reubicar el @c(cdr) del par. Volvemos al
     @c(update-cdr) momento en que se ha realizado la reubicación. Después de
     reubicar y actualizar el @c(cdr), hemos terminado de escanear ese par, así
     que continuamos con el bucle principal.

#      ..src > scheme
#        update-car
#          (perform (op vector-set!)
#                   (reg new-cars)
#                   (reg scan)
#                   (reg new))
#          (assign  old
#                   (op vector-ref)
#                   (reg new-cdrs)
#                   (reg scan))
#          (assign  relocate-continue
#                   (label update-cdr))
#          (goto (label relocate-old-result-in-new))
#        update-cdr
#          (perform (op vector-set!)
#                   (reg new-cdrs)
#                   (reg scan)
#                   (reg new))
#          (assign  scan (op +) (reg scan) (const 1))
#          (goto (label gc-loop))
#      < src..
     ..src > scheme
       update-car
         (perform (op vector-set!)
                  (reg new-cars)
                  (reg scan)
                  (reg new))
         (assign  old
                  (op vector-ref)
                  (reg new-cdrs)
                  (reg scan))
         (assign  relocate-continue
                  (label update-cdr))
         (goto (label relocate-old-result-in-new))
       update-cdr
         (perform (op vector-set!)
                  (reg new-cdrs)
                  (reg scan)
                  (reg new))
         (assign  scan (op +) (reg scan) (const 1))
         (goto (label gc-loop))
     < src..

#      The subroutine @c(relocate-old-result-in-new) relocates objects as follows: If
#      the object to be relocated (pointed at by @c(old)) is not a pair, then we
#      return the same pointer to the object unchanged (in @c(new)). (For example, we
#      may be scanning a pair whose @c(car) is the number 4. If we represent the
#      @c(car) by @c(n4), as described in section @l(#5.3.1), then we want the @"(relocated)
#      @c(car) pointer to still be @c(n4).)  Otherwise, we must perform the
#      relocation. If the @c(car) position of the pair to be relocated contains a
#      broken-heart tag, then the pair has in fact already been moved, so we retrieve
#      the forwarding address (from the @c(cdr) position of the broken heart) and
#      return this in @c(new). If the pointer in @c(old) points at a yet-unmoved
#      pair, then we move the pair to the first free cell in new memory (pointed at
#      by @c(free)) and set up the broken heart by storing a broken-heart tag and
#      forwarding address at the old location.  @c(Relocate-old-result-in-new) uses a
#      register @c(oldcr) to hold the @c(car) or the @c(cdr) of the object pointed at
#      by @c(old).@n(303)
     La subrutina @c(relocate-old-result-in-new) reubica los objetos de la
     siguiente manera: Si el objeto a reubicar (apuntado por @c(old)) no es un
     par, entonces devuelve el mismo puntero al objeto sin cambios (in
     @c(new)). (Por ejemplo, podemos escanear un par cuyo @c(car) número
     es 4. Si representamos el @c(car) by @c(n4), como se describe en
     @l(#5.3.1), entonces queremos que el puntero @"(reubicado) @c(car)
     siga siendo @c(n4)). De lo contrario, debemos realizar la reubicación. Si
     la @c(car) posición del par a ser reubicado contiene una etiqueta de
     corazón roto, entonces el par de hecho ya se ha movido, por lo que
     recuperar la dirección de reenvío (desde la @c(cdr) posición del corazón
     roto) y devolver esto @c(new). Si el puntero en @c(old) puntos en un par
     aún no modificado, @c(free) Entonces moveremos el par a la primera célula
     libre en la nueva memoria (señalada por ) y estableceremos el corazón roto
     almacenando una etiqueta de corazón roto y dirección de reenvío en la
     ubicación antigua.  @c(Relocate-old-result-in-new) Usa un registro
     @c(oldcr) para sostener el @c(car) o el @c(cdr) del objeto señalado por
     @c(old).@n(303)

#      ..src > scheme
#        relocate-old-result-in-new
#          (test (op pointer-to-pair?) (reg old))
#          (branch (label pair))
#          (assign new (reg old))
#          (goto (reg relocate-continue))
#        pair
#          (assign  oldcr
#                   (op vector-ref)
#                   (reg the-cars)
#                   (reg old))
#          (test (op broken-heart?) (reg oldcr))
#          (branch  (label already-moved))
#          (assign  new (reg free)) ; new location for pair
#          ;; Update free pointer.
#          (assign free (op +) (reg free) (const 1))
#          ;; Copy the car and cdr to new memory.
#          (perform (op vector-set!)
#                   (reg new-cars)
#                   (reg new)
#                   (reg oldcr))
#          (assign  oldcr
#                   (op vector-ref)
#                   (reg the-cdrs)
#                   (reg old))
#          (perform (op vector-set!)
#                   (reg new-cdrs)
#                   (reg new)
#                   (reg oldcr))
#          ;; Construct the broken heart.
#          (perform (op vector-set!)
#                   (reg the-cars)
#                   (reg old)
#                   (const broken-heart))
#          (perform (op vector-set!)
#                   (reg the-cdrs)
#                   (reg old)
#                   (reg new))
#          (goto (reg relocate-continue))
#        already-moved
#          (assign  new
#                   (op vector-ref)
#                   (reg the-cdrs)
#                   (reg old))
#          (goto (reg relocate-continue))
#      < src..
     ..src > scheme
       relocate-old-result-in-new
         (test (op pointer-to-pair?) (reg old))
         (branch (label pair))
         (assign new (reg old))
         (goto (reg relocate-continue))
       pair
         (assign  oldcr
                  (op vector-ref)
                  (reg the-cars)
                  (reg old))
         (test (op broken-heart?) (reg oldcr))
         (branch  (label already-moved))
         (assign  new (reg free)) ; new location for pair
         ;; Update free pointer.
         (assign free (op +) (reg free) (const 1))
         ;; Copy the car and cdr to new memory.
         (perform (op vector-set!)
                  (reg new-cars)
                  (reg new)
                  (reg oldcr))
         (assign  oldcr
                  (op vector-ref)
                  (reg the-cdrs)
                  (reg old))
         (perform (op vector-set!)
                  (reg new-cdrs)
                  (reg new)
                  (reg oldcr))
         ;; Construct the broken heart.
         (perform (op vector-set!)
                  (reg the-cars)
                  (reg old)
                  (const broken-heart))
         (perform (op vector-set!)
                  (reg the-cdrs)
                  (reg old)
                  (reg new))
         (goto (reg relocate-continue))
       already-moved
         (assign  new
                  (op vector-ref)
                  (reg the-cdrs)
                  (reg old))
         (goto (reg relocate-continue))
     < src..

#      At the very end of the garbage-collection process, we interchange the role of
#      old and new memories by interchanging pointers: interchanging @c(the-cars)
#      with @c(new-cars), and @c(the-cdrs) with @c(new-cdrs). We will then be ready
#      to perform another garbage collection the next time memory runs out.
     Al final del proceso de recolección de basura, intercambiamos el papel de
     recuerdos antiguos y nuevos intercambiando punteros: intercambiando
     @c(the-cars) con @c(new-cars), y @c(the-cdrs) con @c(new-cdrs). A
     continuación, estaremos listos para realizar otra recolección de basura la
     próxima vez que se agota la memoria.

#      ..src > scheme
#        gc-flip
#          (assign temp (reg the-cdrs))
#          (assign the-cdrs (reg new-cdrs))
#          (assign new-cdrs (reg temp))
#          (assign temp (reg the-cars))
#          (assign the-cars (reg new-cars))
#          (assign new-cars (reg temp))
#      < src..
     ..src > scheme
       gc-flip
         (assign temp (reg the-cdrs))
         (assign the-cdrs (reg new-cdrs))
         (assign new-cdrs (reg temp))
         (assign temp (reg the-cars))
         (assign the-cars (reg new-cars))
         (assign new-cars (reg temp))
     < src..

# ** 5.4 <> The Explicit-Control Evaluator
** 5.4 <> El Evaluador de Control Explicito

#    in section @l(#5.1) we saw how to transform simple Scheme programs into descriptions
#    of register machines. We will now perform this transformation on a more
#    complex program, the metacircular evaluator of section @l(#4.1.1)--@l(#4.1.4), which
#    shows how the behavior of a Scheme interpreter can be described in terms of
#    the procedures @c(eval) and @c(apply). The @e(explicit-control evaluator) that
#    we develop in this section shows how the underlying procedure-calling and
#    argument-passing mechanisms used in the evaluation process can be described in
#    terms of operations on registers and stacks. In addition, the explicit-control
#    evaluator can serve as an implementation of a Scheme interpreter, written in a
#    language that is very similar to the native machine language of conventional
#    computers. The evaluator can be executed by the register-machine simulator of
#    @l(#5.2). Alternatively, it can be used as a starting point for building a
#    machine-language implementation of a Scheme evaluator, or even a
#    special-purpose machine for evaluating Scheme expressions. @l(#Figure 5.16)
#    shows such a hardware implementation: a silicon chip that acts as an evaluator
#    for Scheme. The chip designers started with the data-path and controller
#    specifications for a register machine similar to the evaluator described in
#    this section and used design automation programs to construct the
#    integrated-circuit layout.@n(304)
   en la seccion @l(#5.1) vimos cómo transformar programas Scheme simples en
   descripciones de máquinas registradoras. Ahora realizaremos esta
   transformación en un programa más complejo, el evaluador metacircular de
   @l(#4.1.1) - @l(#4.1.4), que muestra cómo el comportamiento de
   un intérprete Scheme puede ser descrito en términos de los procedimientos
   @c(eval) y @c(apply). El @e(evaluador de control explícito) que desarrollamos
   en esta sección muestra cómo se pueden describir los mecanismos subyacentes
   de la llamada a procedimientos y el argumento que se usan en el proceso de
   evaluación en términos de operaciones en registros y pilas. Además, el
   evaluador de control explícito puede servir como una implementación de un
   intérprete Scheme, Escrito en un lenguaje que es muy similar al lenguaje de
   máquina nativo de los ordenadores convencionales. @l(#5.2<>El evaluador puede
   ser ejecutado por el simulador registrador-máquina de 5.2). Alternativamente,
   puede utilizarse como punto de partida para construir una implementación de
   lenguaje de máquina de un evaluador de Scheme, o incluso una máquina de
   propósito especial para evaluar expresiones de Scheme. @l(#Figura 5.16) muestra tal implementación de hardware: un chip de silicio que
   actúa como un evaluador para Scheme. Los diseñadores de chips comenzaron con
   las especificaciones de ruta de datos y controlador para una máquina de
   registro similar al evaluador descrito en esta sección y usaron programas de
   automatización de diseño para construir la disposición de circuitos
   integrados.@n(304) Alternativamente, puede utilizarse como punto de
   partida para construir una implementación de lenguaje de máquina de un
   evaluador de Scheme, o incluso una máquina de propósito especial para evaluar
   expresiones de Scheme. @l(#Figura 5.16) muestra tal
   implementación de hardware: un chip de silicio que actúa como un evaluador
   para Scheme. Los diseñadores de chips comenzaron con las especificaciones de
   ruta de datos y controlador para una máquina de registro similar al evaluador
   descrito en esta sección y usaron programas de automatización de diseño para
   construir la disposición de circuitos integrados.@n(304)
   Alternativamente, puede utilizarse como punto de partida para construir una
   implementación de lenguaje de máquina de un evaluador de Scheme, o incluso
   una máquina de propósito especial para evaluar expresiones de
   Scheme. @l(#Figura 5.16) muestra tal implementación de
   hardware: un chip de silicio que actúa como un evaluador para Scheme. Los
   diseñadores de chips comenzaron con las especificaciones de ruta de datos y
   controlador para una máquina de registro similar al evaluador descrito en
   esta sección y usaron programas de automatización de diseño para construir la
   disposición de circuitos integrados.@n(304) Un chip de silicio que
   actúa como evaluador de Scheme. Los diseñadores de chips comenzaron con las
   especificaciones de ruta de datos y controlador para una máquina de registro
   similar al evaluador descrito en esta sección y usaron programas de
   automatización de diseño para construir la disposición de circuitos
   integrados.@n(304) Un chip de silicio que actúa como evaluador de
   Scheme. Los diseñadores de chips comenzaron con las especificaciones de ruta
   de datos y controlador para una máquina de registro similar al evaluador
   descrito en esta sección y usaron programas de automatización de diseño para
   construir la disposición de circuitos integrados.@n(304)

#    ..figure > @t(Figure 5.16) A silicon-chip implementation of an evaluator for
#      Scheme.
   ..figure > @t(Figura 5.16) Una implementación de chip de silicio de un
     evaluador para Scheme.

#      ..img > img/chap5/chip.std.svg
     ..img > img/chap5/chip.std.svg

# *** Registers and operations
*** Registros y operaciones

#     In designing the explicit-control evaluator, we must specify the operations to
#     be used in our register machine. We described the metacircular evaluator in
#     terms of abstract syntax, using procedures such as @c(quoted?) and
#     @c(make-procedure). In implementing the register machine, we could expand
#     these procedures into sequences of elementary list-structure memory
#     operations, and implement these operations on our register machine. However,
#     this would make our evaluator very long, obscuring the basic structure with
#     details. To clarify the presentation, we will include as primitive operations
#     of the register machine the syntax procedures given in section @l(#4.1.2) and the
#     procedures for representing environments and other run-time data given in
#     sections @l(#4.1.3) and @l(#4.1.4). In order to completely specify an
#     evaluator that could be programmed in a low-level machine language or
#     implemented in hardware, we would replace these operations by more elementary
#     operations, using the list-structure implementation we described in section @l(#5.3).
    Al diseñar el evaluador de control explícito, debemos especificar las
    operaciones que se utilizarán en nuestra máquina registradora. Describimos
    el evaluador metacircular en términos de sintaxis abstracta, utilizando
    procedimientos como @c(quoted?) y @c(make-procedure). Al implementar la
    máquina de registro, podríamos expandir estos procedimientos en secuencias
    de operaciones elementales de memoria de estructura de lista, e implementar
    estas operaciones en nuestra máquina registradora. Sin embargo, esto haría
    que nuestro evaluador muy largo, oscureciendo la estructura básica con
    detalles. Para aclarar la presentación, incluiremos como operaciones
    primitivas de la máquina de registro los procedimientos de sintaxis dados en
    @l(#4.1.2) y los procedimientos para representar entornos y otros
    datos de tiempo de ejecución dados en las secciones @l(#4.1.3) y
    @l(#4.1.4) . @l(#5.3)

#     Our Scheme evaluator register machine includes a stack and seven registers:
#     @c(exp), @c(env), @c(val), @c(continue), @c(proc), @c(argl), and
#     @c(unev). @c(Exp) is used to hold the expression to be evaluated, and @c(env)
#     contains the environment in which the evaluation is to be performed. At the
#     end of an evaluation, @c(val) contains the value obtained by evaluating the
#     expression in the designated environment. The @c(continue) register is used to
#     implement recursion, as explained in section @l(#5.1.4). (The evaluator needs to call
#     itself recursively, since evaluating an expression requires evaluating its
#     subexpressions.)  The registers @c(proc), @c(argl), and @c(unev) are used in
#     evaluating combinations.
    Nuestra máquina registradora Scheme evaluador incluye una pila y siete
    registros: @c(exp), @c(env), @c(val), @c(continue), @c(proc), @c(argl), y
    @c(unev). @c(Exp) Se utiliza para contener la expresión a evaluar, y @c(env)
    contiene el entorno en el que se va a realizar la evaluación. Al final de
    una evaluación, @c(val) contiene el valor obtenido evaluando la expresión en
    el entorno designado. El @c(continue) registro se utiliza para implementar
    la recursión, como se explica en la seccion @l(#5.1.4). (El evaluador necesita
    llamar a sí mismo de forma recursiva, ya que la evaluación de una expresión
    requiere la evaluación de sus subexpresiones.) Los registros @c(proc),
    @c(argl) y @c(unev) se utilizan en la evaluación de combinaciones.

#     We will not provide a data-path diagram to show how the registers and
#     operations of the evaluator are connected, nor will we give the complete list
#     of machine operations. These are implicit in the evaluator's controller, which
#     will be presented in detail.
    No proporcionamos un diagrama de ruta de datos para mostrar cómo están
    conectados los registros y operaciones del evaluador, ni daremos la lista
    completa de operaciones de la máquina. Estos están implícitos en el
    controlador del evaluador, que se presentarán en detalle.

# *** 5.4.1 <> The Core of the Explicit-Control Evaluator
*** 5.4.1 <> El núcleo del evaluador de control explícito

#     The central element in the evaluator is the sequence of instructions beginning
#     at @c(eval-dispatch). This corresponds to the @c(eval) procedure of the
#     metacircular evaluator described in section @l(#4.1.1). When the controller starts at
#     @c(eval-dispatch), it evaluates the expression specified by @c(exp) in the
#     environment specified by @c(env). When evaluation is complete, the controller
#     will go to the entry point stored in @c(continue), and the @c(val) register
#     will hold the value of the expression. As with the metacircular @c(eval), the
#     structure of @c(eval-dispatch) is a case analysis on the syntactic type of the
#     expression to be evaluated.@n(305)
    El elemento central en el evaluador es la secuencia de instrucciones que
    comienza en @c(eval-dispatch). Esto corresponde al procedimiento @c(eval)
    del evaluador metacircular descrito en la seccion @l(#4.1.1). Cuando el
    controlador comienza en @c(eval-dispatch), evalúa la expresión especificada
    @c(exp) en el entorno especificado por @c(env). Una vez finalizada la
    evaluación, el controlador se dirigirá al punto de entrada almacenado
    @c(continue) y el @c(val) registro mantendrá el valor de la expresión. Al
    igual que con el metacircular @c(eval), la estructura de @c(eval-dispatch)
    es un análisis de caso sobre el tipo sintáctico de la expresión que se va a
    evaluar.@n(305)

#     ..src > scheme
#       eval-dispatch
#         (test (op self-evaluating?) (reg exp))
#         (branch (label ev-self-eval))
#         (test (op variable?) (reg exp))
#         (branch (label ev-variable))
#         (test (op quoted?) (reg exp))
#         (branch (label ev-quoted))
#         (test (op assignment?) (reg exp))
#         (branch (label ev-assignment))
#         (test (op definition?) (reg exp))
#         (branch (label ev-definition))
#         (test (op if?) (reg exp))
#         (branch (label ev-if))
#         (test (op lambda?) (reg exp))
#         (branch (label ev-lambda))
#         (test (op begin?) (reg exp))
#         (branch (label ev-begin))
#         (test (op application?) (reg exp))
#         (branch (label ev-application))
#         (goto (label unknown-expression-type))
#     < src..
    ..src > scheme
      eval-dispatch
        (test (op self-evaluating?) (reg exp))
        (branch (label ev-self-eval))
        (test (op variable?) (reg exp))
        (branch (label ev-variable))
        (test (op quoted?) (reg exp))
        (branch (label ev-quoted))
        (test (op assignment?) (reg exp))
        (branch (label ev-assignment))
        (test (op definition?) (reg exp))
        (branch (label ev-definition))
        (test (op if?) (reg exp))
        (branch (label ev-if))
        (test (op lambda?) (reg exp))
        (branch (label ev-lambda))
        (test (op begin?) (reg exp))
        (branch (label ev-begin))
        (test (op application?) (reg exp))
        (branch (label ev-application))
        (goto (label unknown-expression-type))
    < src..

# **** Evaluating simple expressions
**** Evaluación de expresiones sencillas

#      Numbers and strings (which are self-evaluating), variables, quotations, and
#      @c(lambda) expressions have no subexpressions to be evaluated. For these, the
#      evaluator simply places the correct value in the @c(val) register and
#      continues execution at the entry point specified by @c(continue).  Evaluation
#      of simple expressions is performed by the following controller code:
     Los números y las cadenas (que se autoevaluan), las variables, las citas y
     las @c(lambda) expresiones no tienen subexpresiones a evaluar. Para estos,
     el evaluador simplemente coloca el valor correcto en el @c(val) registro y
     continúa la ejecución en el punto de entrada especificado por
     @c(continue). La evaluación de expresiones simples se realiza mediante el
     siguiente código de controlador:

#      ..src > scheme
#        ev-self-eval
#          (assign val (reg exp))
#          (goto (reg continue))
#        ev-variable
#          (assign val
#                  (op lookup-variable-value)
#                  (reg exp)
#                  (reg env))
#          (goto (reg continue))
#        ev-quoted
#          (assign val
#                  (op text-of-quotation)
#                  (reg exp))
#          (goto (reg continue))
#        ev-lambda
#          (assign unev
#                  (op lambda-parameters)
#                  (reg exp))
#          (assign exp
#                  (op lambda-body)
#                  (reg exp))
#          (assign val
#                  (op make-procedure)
#                  (reg unev)
#                  (reg exp)
#                  (reg env))
#          (goto (reg continue))
#      < src..
     ..src > scheme
       ev-self-eval
         (assign val (reg exp))
         (goto (reg continue))
       ev-variable
         (assign val
                 (op lookup-variable-value)
                 (reg exp)
                 (reg env))
         (goto (reg continue))
       ev-quoted
         (assign val
                 (op text-of-quotation)
                 (reg exp))
         (goto (reg continue))
       ev-lambda
         (assign unev
                 (op lambda-parameters)
                 (reg exp))
         (assign exp
                 (op lambda-body)
                 (reg exp))
         (assign val
                 (op make-procedure)
                 (reg unev)
                 (reg exp)
                 (reg env))
         (goto (reg continue))
     < src..

#      Observe how @c(ev-lambda) uses the @c(unev) and @c(exp) registers to hold the
#      parameters and body of the lambda expression so that they can be passed to the
#      @c(make-procedure) operation, along with the environment in @c(env).
     Observe cómo @c(ev-lambda) utiliza los registros @c(unev) y @c(exp) para
     mantener los parámetros y el cuerpo de la expresión lambda para que puedan
     ser pasados a la @c(make-procedure) operación, junto con el entorno en
     @c(env).

# **** Evaluating procedure applications
**** Evaluación de las solicitudes de procedimiento

#      A procedure application is specified by a combination containing an operator
#      and operands. The operator is a subexpression whose value is a procedure, and
#      the operands are subexpressions whose values are the arguments to which the
#      procedure should be applied. The metacircular @c(eval) handles applications by
#      calling itself recursively to evaluate each element of the combination, and
#      then passing the results to @c(apply), which performs the actual procedure
#      application. The explicit-control evaluator does the same thing; these
#      recursive calls are implemented by @c(goto) instructions, together with use of
#      the stack to save registers that will be restored after the recursive call
#      returns. Before each call we will be careful to identify which registers must
#      be saved (because their values will be needed later).@n(306)
     Una aplicación de procedimiento se especifica mediante una combinación que
     contiene un operador y los operandos. El operador es una subexpresión cuyo
     valor es un procedimiento y los operandos son subexpresiones cuyos valores
     son los argumentos a los que se debe aplicar el procedimiento. El
     metacircular @c(eval) maneja aplicaciones llamándose de manera recursiva
     para evaluar cada elemento de la combinación, y luego pasar los resultados
     a @c(apply), que realiza la aplicación de procedimiento real. El evaluador
     de control explícito hace lo mismo; Estas llamadas recursivas se
     implementan mediante @c(goto) instrucciones, junto con el uso de la pila
     para guardar los registros que se restaurarán después de que la llamada
     recursiva regrese. Antes de cada llamada vamos a tener cuidado de
     identificar qué registros deben ser guardados (porque sus valores serán
     necesarios más tarde).@n(306)

#      We begin the evaluation of an application by evaluating the operator to
#      produce a procedure, which will later be applied to the evaluated operands. To
#      evaluate the operator, we move it to the @c(exp) register and go to
#      @c(eval-dispatch). The environment in the @c(env) register is already the
#      correct one in which to evaluate the operator. However, we save @c(env)
#      because we will need it later to evaluate the operands. We also extract the
#      operands into @c(unev) and save this on the stack. We set up @c(continue) so
#      that @c(eval-dispatch) will resume at @c(ev-appl-did-operator) after the
#      operator has been evaluated. First, however, we save the old value of
#      @c(continue), which tells the controller where to continue after the
#      application.
     Comenzamos la evaluación de una aplicación evaluando al operador para
     producir un procedimiento, que posteriormente se aplicará a los operandos
     evaluados. Para evaluar al operador, lo movemos al @c(exp) registro y vamos
     a @c(eval-dispatch). El entorno en el @c(env) registro es ya el correcto en
     el que evaluar al operador. Sin embargo, ahorramos @c(env) porque lo
     necesitamos más tarde para evaluar los operandos. También extraemos los
     operandos @c(unev) y los guardamos en la pila. Nos configuramos
     @c(continue) para que @c(eval-dispatch) se reanude en
     @c(ev-appl-did-operator) después de que el operador ha sido evaluado. En
     primer lugar, sin embargo, guardamos el valor antiguo de @c(continue), que
     indica al controlador dónde continuar después de la aplicación.

#      ..src > scheme
#        ev-application
#          (save continue)
#          (save env)
#          (assign unev (op operands) (reg exp))
#          (save unev)
#          (assign exp (op operator) (reg exp))
#          (assign
#           continue (label ev-appl-did-operator))
#          (goto (label eval-dispatch))
#      < src..
     ..src > scheme
       ev-application
         (save continue)
         (save env)
         (assign unev (op operands) (reg exp))
         (save unev)
         (assign exp (op operator) (reg exp))
         (assign
          continue (label ev-appl-did-operator))
         (goto (label eval-dispatch))
     < src..

#      Upon returning from evaluating the operator subexpression, we proceed to
#      evaluate the operands of the combination and to accumulate the resulting
#      arguments in a list, held in @c(argl). First we restore the unevaluated
#      operands and the environment. We initialize @c(argl) to an empty list.  Then
#      we assign to the @c(proc) register the procedure that was produced by
#      evaluating the operator. If there are no operands, we go directly to
#      @c(apply-dispatch). Otherwise we save @c(proc) on the stack and start the
#      argument-evaluation loop:@n(307)
     Al regresar de la evaluación de la subexpresión del operador, procedemos a
     evaluar los operandos de la combinación ya acumular los argumentos
     resultantes en una lista, mantenida en @c(argl). Primero restauramos los
     operandos no evaluados y el ambiente. Nos inicializamos @c(argl) a una
     lista vacía. Entonces asignamos al @c(proc) registro el procedimiento que
     se produjo evaluando al operador. Si no hay operandos, vamos directamente a
     @c(apply-dispatch). De lo contrario, guardamos @c(proc) en la pila e
     iniciamos el bucle de evaluación de argumentos:@n(307)

#      ..src > scheme
#        ev-appl-did-operator
#          (restore unev)             ; the operands
#          (restore env)
#          (assign argl (op empty-arglist))
#          (assign proc (reg val))    ; the operator
#          (test (op no-operands?) (reg unev))
#          (branch (label apply-dispatch))
#          (save proc)
#      < src..
     ..src > scheme
       ev-appl-did-operator
         (restore unev)             ; the operands
         (restore env)
         (assign argl (op empty-arglist))
         (assign proc (reg val))    ; the operator
         (test (op no-operands?) (reg unev))
         (branch (label apply-dispatch))
         (save proc)
     < src..

#      Each cycle of the argument-evaluation loop evaluates an operand from the list
#      in @c(unev) and accumulates the result into @c(argl). To evaluate an operand,
#      we place it in the @c(exp) register and go to @c(eval-dispatch), after setting
#      @c(continue) so that execution will resume with the argument-accumulation
#      phase. But first we save the arguments accumulated so far (held in @c(argl)),
#      the environment (held in @c(env)), and the remaining operands to be evaluated
#      (held in @c(unev)). A special case is made for the evaluation of the last
#      operand, which is handled at @c(ev-appl-last-arg).
     Cada ciclo del bucle de evaluación de argumentos evalúa un operando de la
     lista @c(unev) y acumula el resultado en @c(argl). Para evaluar un
     operando, lo colocamos en el @c(exp) registro e iremos a @c(eval-dispatch),
     después de configurar @c(continue) para que la ejecución se reanude con la
     fase de acumulación de argumentos. Pero primero guardamos los argumentos
     acumulados hasta ahora (retenidos @c(argl)), el ambiente (mantenido en
     @c(env)), y los operandos restantes para ser evaluados (retenidos
     @c(unev)). Se hace un caso especial para la evaluación del último operando,
     que se maneja en @c(ev-appl-last-arg).

#      ..src > scheme
#        ev-appl-operand-loop
#          (save argl)
#          (assign exp
#                  (op first-operand)
#                  (reg unev))
#          (test (op last-operand?) (reg unev))
#          (branch (label ev-appl-last-arg))
#          (save env)
#          (save unev)
#          (assign continue
#                  (label ev-appl-accumulate-arg))
#          (goto (label eval-dispatch))
#      < src..
     ..src > scheme
       ev-appl-operand-loop
         (save argl)
         (assign exp
                 (op first-operand)
                 (reg unev))
         (test (op last-operand?) (reg unev))
         (branch (label ev-appl-last-arg))
         (save env)
         (save unev)
         (assign continue
                 (label ev-appl-accumulate-arg))
         (goto (label eval-dispatch))
     < src..

#      When an operand has been evaluated, the value is accumulated into the list
#      held in @c(argl). The operand is then removed from the list of unevaluated
#      operands in @c(unev), and the argument-evaluation continues.
     Cuando se ha evaluado un operando, el valor se acumula en la lista
     contenida en @c(argl). El operando se elimina de la lista de operandos no
     evaluados @c(unev) y la evaluación de argumentos continúa.

#      ..src > scheme
#        ev-appl-accumulate-arg
#          (restore unev)
#          (restore env)
#          (restore argl)
#          (assign argl
#                  (op adjoin-arg)
#                  (reg val)
#                  (reg argl))
#          (assign unev
#                  (op rest-operands)
#                  (reg unev))
#          (goto (label ev-appl-operand-loop))
#      < src..
     ..src > scheme
       ev-appl-accumulate-arg
         (restore unev)
         (restore env)
         (restore argl)
         (assign argl
                 (op adjoin-arg)
                 (reg val)
                 (reg argl))
         (assign unev
                 (op rest-operands)
                 (reg unev))
         (goto (label ev-appl-operand-loop))
     < src..

#      Evaluation of the last argument is handled differently. There is no need to
#      save the environment or the list of unevaluated operands before going to
#      @c(eval-dispatch), since they will not be required after the last operand is
#      evaluated. Thus, we return from the evaluation to a special entry point
#      @c(ev-appl-accum-last-arg), which restores the argument list, accumulates the
#      new argument, restores the saved procedure, and goes off to perform the
#      application.@n(308)
     La evaluación del último argumento se maneja de manera diferente. No hay
     necesidad de guardar el entorno o la lista de operandos no evaluados antes
     de ir a @c(eval-dispatch), ya que no será necesario después de que el
     último operando se evalúa. Por lo tanto, regresamos de la evaluación a un
     punto de entrada especial @c(ev-appl-accum-last-arg), que restaura la lista
     de argumentos, acumula el nuevo argumento, restaura el procedimiento
     guardado y se apaga para realizar la aplicación.@n(308)

#      ..src > scheme
#        ev-appl-last-arg
#          (assign continue
#                  (label ev-appl-accum-last-arg))
#          (goto (label eval-dispatch))
#        ev-appl-accum-last-arg
#          (restore argl)
#          (assign argl
#                  (op adjoin-arg)
#                  (reg val)
#                  (reg argl))
#          (restore proc)
#          (goto (label apply-dispatch))
#      < src..
     ..src > scheme
       ev-appl-last-arg
         (assign continue
                 (label ev-appl-accum-last-arg))
         (goto (label eval-dispatch))
       ev-appl-accum-last-arg
         (restore argl)
         (assign argl
                 (op adjoin-arg)
                 (reg val)
                 (reg argl))
         (restore proc)
         (goto (label apply-dispatch))
     < src..

#      The details of the argument-evaluation loop determine the order in which the
#      interpreter evaluates the operands of a combination (e.g., left to right or
#      right to left––see @l(#Exercise 3.8)). This order is not determined by the
#      metacircular evaluator, which inherits its control structure from the
#      underlying Scheme in which it is implemented.@n(309) Because the
#      @c(first-operand) selector (used in @c(ev-appl-operand-loop) to extract
#      successive operands from @c(unev)) is implemented as @c(car) and the
#      @c(rest-operands) selector is implemented as @c(cdr), the explicit-control
#      evaluator will evaluate the operands of a combination in left-to-right order.
     Los detalles del ciclo de evaluación de argumentos determinan el orden en
     que el intérprete evalúa los operandos de una combinación (por ejemplo, de
     izquierda a derecha o de derecha a izquierda, véase el
     @l(#Ejercicio 3.8) ). Este orden no está determinado por el
     evaluador metacircular, que hereda su estructura de control del Scheme
     subyacente en el que se implementa.@n(309) Como el @c(first-operand)
     selector (utilizado @c(ev-appl-operand-loop) para extraer sucesivos
     operandos de @c(unev)) se implementa como @c(car) y el @c(rest-operands)
     selector se implementa como @c(cdr), el evaluador de control explícito
     evaluará los operandos de una combinación en orden de izquierda a derecha.

# **** Procedure application
**** Solicitud de procedimiento

#      The entry point @c(apply-dispatch) corresponds to the @c(apply) procedure of
#      the metacircular evaluator. By the time we get to @c(apply-dispatch), the
#      @c(proc) register contains the procedure to apply and @c(argl) contains the
#      list of evaluated arguments to which it must be applied. The saved value of
#      @c(continue) (originally passed to @c(eval-dispatch) and saved at
#      @c(ev-application)), which tells where to return with the result of the
#      procedure application, is on the stack. When the application is complete, the
#      controller transfers to the entry point specified by the saved @c(continue),
#      with the result of the application in @c(val). As with the metacircular
#      @c(apply), there are two cases to consider. Either the procedure to be applied
#      is a primitive or it is a compound procedure.
     El punto de entrada @c(apply-dispatch) corresponde al procedimiento @c(apply) del evaluador metacircular. En el momento en que llegamos
     @c(apply-dispatch), el @c(proc) registro contiene el procedimiento para
     aplicar y @c(argl) contiene la lista de argumentos evaluados a los que debe
     aplicarse. El valor guardado de @c(continue)(originalmente pasado
     @c(eval-dispatch) y guardado en @c(ev-application)), que indica dónde
     volver con el resultado de la aplicación de procedimiento, está en la
     pila. Cuando la aplicación se ha completado, el controlador se transfiere
     al punto de entrada especificado por el salvado @c(continue), con el
     resultado de la aplicación en @c(val). Como con el metacircular @c(apply),
     hay dos casos a considerar. O el procedimiento a ser aplicado es un
     procedimiento primitivo o es un procedimiento compuesto.

#      ..src > scheme
#        apply-dispatch
#          (test (op primitive-procedure?) (reg proc))
#          (branch (label primitive-apply))
#          (test (op compound-procedure?) (reg proc))
#          (branch (label compound-apply))
#          (goto (label unknown-procedure-type))
#      < src..
     ..src > scheme
       apply-dispatch
         (test (op primitive-procedure?) (reg proc))
         (branch (label primitive-apply))
         (test (op compound-procedure?) (reg proc))
         (branch (label compound-apply))
         (goto (label unknown-procedure-type))
     < src..

#      We assume that each primitive is implemented so as to obtain its arguments
#      from @c(argl) and place its result in @c(val). To specify how the machine
#      handles primitives, we would have to provide a sequence of controller
#      instructions to implement each primitive and arrange for @c(primitive-apply)
#      to dispatch to the instructions for the primitive identified by the contents
#      of @c(proc). Since we are interested in the structure of the evaluation
#      process rather than the details of the primitives, we will instead just use an
#      @c(apply-primitive-procedure) operation that applies the procedure in @c(proc)
#      to the arguments in @c(argl). For the purpose of simulating the evaluator with
#      the simulator of section @l(#5.2) we use the procedure @c(apply-primitive-procedure),
#      which calls on the underlying Scheme system to perform the application, just
#      as we did for the metacircular evaluator in section @l(#4.1.4). After computing the
#      value of the primitive application, we restore @c(continue) and go to the
#      designated entry point.
     Suponemos que cada primitiva se implementa para obtener sus argumentos
     @c(argl) y colocar su resultado en @c(val). Para especificar cómo la
     máquina maneja las primitivas, tendríamos que proporcionar una secuencia de
     instrucciones del controlador para implementar cada primitiva y disponer
     para @c(primitive-apply) enviar a las instrucciones para la primitiva
     identificada por los contenidos de @c(proc). Puesto que estamos interesados
     en la estructura del proceso de evaluación en lugar de los detalles de los
     primitivos, en lugar de eso usaremos una @c(apply-primitive-procedure)
     operación que aplica el procedimiento @c(proc) a los argumentos en
     @c(argl). Con el fin de simular al evaluador con el simulador de
     @l(#5.2) utilizamos el procedimiento @c(apply-primitive-procedure),
     que invita al sistema Scheme subyacente a realizar la aplicación,
     @l(#4.1.4<>Tal como lo hicimos para el evaluador metacircular en
     4.1.4). Después de calcular el valor de la aplicación primitiva,
     restauramos @c(continue) y vamos al punto de entrada designado.

#      ..src > scheme
#        primitive-apply
#          (assign val (op apply-primitive-procedure)
#                      (reg proc)
#                      (reg argl))
#          (restore continue)
#          (goto (reg continue))
#      < src..
     ..src > scheme
       primitive-apply
         (assign val (op apply-primitive-procedure)
                     (reg proc)
                     (reg argl))
         (restore continue)
         (goto (reg continue))
     < src..

#      To apply a compound procedure, we proceed just as with the metacircular
#      evaluator. We construct a frame that binds the procedure's parameters to the
#      arguments, use this frame to extend the environment carried by the procedure,
#      and evaluate in this extended environment the sequence of expressions that
#      forms the body of the procedure. @c(Ev-sequence), described below in
#      @l(#5.4.2), handles the evaluation of the sequence.
     Para aplicar un procedimiento compuesto, procedemos igual que con el
     evaluador metacircular. Construimos un marco que enlaza los parámetros del
     procedimiento con los argumentos, utilizamos este marco para extender el
     entorno llevado por el procedimiento y evaluamos en este entorno extendido
     la secuencia de expresiones que forma el cuerpo del
     procedimiento. @c(Ev-sequence), Descrito a continuación en
     @l(#5.4.2), se encarga de la evaluación de la secuencia.

#      ..src > scheme
#        compound-apply
#          (assign unev
#                  (op procedure-parameters)
#                  (reg proc))
#          (assign env
#                  (op procedure-environment)
#                  (reg proc))
#          (assign env
#                  (op extend-environment)
#                  (reg unev)
#                  (reg argl)
#                  (reg env))
#          (assign unev
#                  (op procedure-body)
#                  (reg proc))
#          (goto (label ev-sequence))
#      < src..
     ..src > scheme
       compound-apply
         (assign unev
                 (op procedure-parameters)
                 (reg proc))
         (assign env
                 (op procedure-environment)
                 (reg proc))
         (assign env
                 (op extend-environment)
                 (reg unev)
                 (reg argl)
                 (reg env))
         (assign unev
                 (op procedure-body)
                 (reg proc))
         (goto (label ev-sequence))
     < src..

#      @c(Compound-apply) is the only place in the interpreter where the @c(env)
#      register is ever assigned a new value. Just as in the metacircular evaluator,
#      the new environment is constructed from the environment carried by the
#      procedure, together with the argument list and the corresponding list of
#      variables to be bound.
     @c(Compound-apply) Es el único lugar en el intérprete donde al @c(env)
     registro se le asigna un nuevo valor. Al igual que en el evaluador
     metacircular, el nuevo entorno se construye a partir del entorno
     transportado por el procedimiento, junto con la lista de argumentos y la
     lista correspondiente de variables a enlazar.

# *** 5.4.2 <> Sequence Evaluation and Tail Recursion
*** 5.4.2 <> Evaluación de secuencia y recursión de cola

#     The portion of the explicit-control evaluator at @c(ev-sequence) is analogous
#     to the metacircular evaluator's @c(eval-sequence) procedure. It handles
#     sequences of expressions in procedure bodies or in explicit @c(begin)
#     expressions.
    La porción del evaluador de control explícito en @c(ev-sequence) es análoga
    al procedimiento @c(eval-sequence) del evaluador metacircular. Maneja
    secuencias de expresiones en cuerpos de procedimiento o en @c(begin)
    expresiones explícitas.

#     Explicit @c(begin) expressions are evaluated by placing the sequence of
#     expressions to be evaluated in @c(unev), saving @c(continue) on the stack, and
#     jumping to @c(ev-sequence).
    Las @c(begin) expresiones explícitas se evalúan colocando la secuencia de
    expresiones a ser evaluadas @c(unev), guardando @c(continue) en la pila y
    saltando a @c(ev-sequence).

#     ..src > scheme
#       ev-begin
#         (assign unev
#                 (op begin-actions)
#                 (reg exp))
#         (save continue)
#         (goto (label ev-sequence))
#     < src..
    ..src > scheme
      ev-begin
        (assign unev
                (op begin-actions)
                (reg exp))
        (save continue)
        (goto (label ev-sequence))
    < src..

#     The implicit sequences in procedure bodies are handled by jumping to
#     @c(ev-sequence) from @c(compound-apply), at which point @c(continue) is
#     already on the stack, having been saved at @c(ev-application).
    Las secuencias implícitas en los cuerpos de procedimiento se manejan
    saltando a @c(ev-sequence) desde @c(compound-apply), momento en el que
    @c(continue) ya está en la pila, habiéndose guardado en @c(ev-application).

#     The entries at @c(ev-sequence) and @c(ev-sequence-continue) form a loop that
#     successively evaluates each expression in a sequence. The list of unevaluated
#     expressions is kept in @c(unev). Before evaluating each expression, we check
#     to see if there are additional expressions to be evaluated in the sequence. If
#     so, we save the rest of the unevaluated expressions (held in @c(unev)) and the
#     environment in which these must be evaluated (held in @c(env)) and call
#     @c(eval-dispatch) to evaluate the expression. The two saved registers are
#     restored upon the return from this evaluation, at @c(ev-sequence-continue).
    Las entradas @c(ev-sequence) y @c(ev-sequence-continue) forman un bucle que
    evalúa sucesivamente cada expresión en una secuencia. Se mantiene la lista
    de expresiones no evaluadas @c(unev). Antes de evaluar cada expresión,
    verificamos si hay expresiones adicionales que se van a evaluar en la
    secuencia. Si es así, ahorramos el resto de las expresiones no evaluadas
    (retenidas @c(unev)) y el entorno en el que éstas deben ser evaluadas
    (mantenidas en @c(env)) y convocadas @c(eval-dispatch) para evaluar la
    expresión. Los dos registros guardados se restauran al regresar de esta
    evaluación, en @c(ev-sequence-continue).

#     The final expression in the sequence is handled differently, at the entry
#     point @c(ev-sequence-last-exp). Since there are no more expressions to be
#     evaluated after this one, we need not save @c(unev) or @c(env) before going to
#     @c(eval-dispatch). The value of the whole sequence is the value of the last
#     expression, so after the evaluation of the last expression there is nothing
#     left to do except continue at the entry point currently held on the stack
#     (which was saved by @c(ev-application) or @c(ev-begin).)  Rather than setting
#     up @c(continue) to arrange for @c(eval-dispatch) to return here and then
#     restoring @c(continue) from the stack and continuing at that entry point, we
#     restore @c(continue) from the stack before going to @c(eval-dispatch), so that
#     @c(eval-dispatch) will continue at that entry point after evaluating the
#     expression.
    La expresión final en la secuencia se maneja de manera diferente, en el
    punto de entrada @c(ev-sequence-last-exp). Dado que no hay más expresiones
    para ser evaluadas después de ésta, no necesitamos guardar @c(unev) o
    @c(env) antes de ir @c(eval-dispatch). El valor de toda la secuencia es el
    valor de la última expresión, así que después de la evaluación de la última
    expresión no queda nada más que hacer, excepto continuar en el punto de
    entrada que se encuentra actualmente en la pila (que fue guardado por
    @c(ev-application) o @c(ev-begin).) Up @c(continue) para arreglar para
    @c(eval-dispatch) regresar aquí y luego restaurar @c(continue) de la pila y
    continuar en ese punto de entrada, restaurar @c(continue) de la pila antes
    de ir a @c(eval-dispatch), por lo que @c(eval-dispatch) continuará en ese
    punto de entrada después de evaluar la expresión.

#     ..src > scheme
#       ev-sequence
#         (assign exp (op first-exp) (reg unev))
#         (test (op last-exp?) (reg unev))
#         (branch (label ev-sequence-last-exp))
#         (save unev)
#         (save env)
#         (assign continue
#                 (label ev-sequence-continue))
#         (goto (label eval-dispatch))
#       ev-sequence-continue
#         (restore env)
#         (restore unev)
#         (assign unev
#                 (op rest-exps)
#                 (reg unev))
#         (goto (label ev-sequence))
#       ev-sequence-last-exp
#         (restore continue)
#         (goto (label eval-dispatch))
#     < src..
    ..src > scheme
      ev-sequence
        (assign exp (op first-exp) (reg unev))
        (test (op last-exp?) (reg unev))
        (branch (label ev-sequence-last-exp))
        (save unev)
        (save env)
        (assign continue
                (label ev-sequence-continue))
        (goto (label eval-dispatch))
      ev-sequence-continue
        (restore env)
        (restore unev)
        (assign unev
                (op rest-exps)
                (reg unev))
        (goto (label ev-sequence))
      ev-sequence-last-exp
        (restore continue)
        (goto (label eval-dispatch))
    < src..

# **** Tail recursion
**** Recursión de la cola

#      In @l(#Chapter 1) we said that the process described by a procedure such as
     En el @l(#Capitulo 1) dijimos que el proceso descrito por un
     procedimiento como

#      ..src > scheme
#        (define (sqrt-iter guess x)
#          (if (good-enough? guess x)
#              guess
#              (sqrt-iter (improve guess x) x)))
#      < src..
     ..src > scheme
       (define (sqrt-iter guess x)
         (if (good-enough? guess x)
             guess
             (sqrt-iter (improve guess x) x)))
     < src..

#      is an iterative process. Even though the procedure is syntactically recursive
#      (defined in terms of itself), it is not logically necessary for an evaluator
#      to save information in passing from one call to @c(sqrt-iter) to the
#      next.@n(310) An evaluator that can execute a procedure such as @c(sqrt-iter)
#      without requiring increasing storage as the procedure continues to call itself
#      is called a @e(tail-recursive) evaluator. The metacircular implementation of
#      the evaluator in @l(#Chapter 4) does not specify whether the evaluator is
#      tail-recursive, because that evaluator inherits its mechanism for saving state
#      from the underlying Scheme. With the explicit-control evaluator, however, we
#      can trace through the evaluation process to see when procedure calls cause a
#      net accumulation of information on the stack.
     Es un proceso iterativo. Aunque el procedimiento es sintácticamente
     recursivo (definido en términos de sí mismo), no es lógicamente necesario
     que un evaluador guarde información pasando de una llamada @c(sqrt-iter) a
     la siguiente.@n(310) Un evaluador que puede ejecutar un
     procedimiento como @c(sqrt-iter) sin necesidad de aumentar el
     almacenamiento como el procedimiento continúa para llamar a sí mismo se
     llama una @e(cola recursiva) evaluador. La implementación metacircular del
     evaluador en el @l(#Capitulo 4) no especifica si el evaluador es
     recursivo de cola, porque ese evaluador hereda su mecanismo para guardar el
     estado del Scheme subyacente. Sin embargo, con el evaluador de control
     explícito,

#      Our evaluator is tail-recursive, because in order to evaluate the final
#      expression of a sequence we transfer directly to @c(eval-dispatch) without
#      saving any information on the stack. Hence, evaluating the final expression in
#      a sequence––even if it is a procedure call (as in @c(sqrt-iter), where the
#      @c(if) expression, which is the last expression in the procedure body, reduces
#      to a call to @c(sqrt-iter))––will not cause any information to be accumulated
#      on the stack.@n(311)
     Nuestro evaluador es recursivo de cola, porque para evaluar la expresión
     final de una secuencia se transfiere directamente a @c(eval-dispatch) sin
     guardar ninguna información en la pila. Por lo tanto, la evaluación de la
     expresión final en una secuencia - incluso si se trata de una llamada de
     procedimiento (como en @c(sqrt-iter), donde la @c(if) expresión, que es la
     última expresión en el cuerpo del procedimiento, se reduce a una llamada a
     @c(sqrt-iter)) - no causará ninguna información Se acumulan en la
     pila.@n(311)

#      If we did not think to take advantage of the fact that it was unnecessary to
#      save information in this case, we might have implemented @c(eval-sequence) by
#      treating all the expressions in a sequence in the same way––saving the
#      registers, evaluating the expression, returning to restore the registers, and
#      repeating this until all the expressions have been evaluated:@n(312)
     Si no pensamos aprovechar el hecho de que no era necesario guardar la
     información en este caso, podríamos haber implementado @c(eval-sequence)
     tratando todas las expresiones en una secuencia de la misma manera -
     guardar los registros, evaluar la expresión, volver a Restaurar los
     registros y repetir esto hasta que se hayan evaluado todas las expresiones:
    @n(312)

#      ..src > scheme
#        ev-sequence
#          (test (op no-more-exps?) (reg unev))
#          (branch (label ev-sequence-end))
#          (assign exp (op first-exp) (reg unev))
#          (save unev)
#          (save env)
#          (assign continue
#                  (label ev-sequence-continue))
#          (goto (label eval-dispatch))
#        ev-sequence-continue
#          (restore env)
#          (restore unev)
#          (assign unev (op rest-exps) (reg unev))
#          (goto (label ev-sequence))
#        ev-sequence-end
#          (restore continue)
#          (goto (reg continue))
#      < src..
     ..src > scheme
       ev-sequence
         (test (op no-more-exps?) (reg unev))
         (branch (label ev-sequence-end))
         (assign exp (op first-exp) (reg unev))
         (save unev)
         (save env)
         (assign continue
                 (label ev-sequence-continue))
         (goto (label eval-dispatch))
       ev-sequence-continue
         (restore env)
         (restore unev)
         (assign unev (op rest-exps) (reg unev))
         (goto (label ev-sequence))
       ev-sequence-end
         (restore continue)
         (goto (reg continue))
     < src..

#      This may seem like a minor change to our previous code for evaluation of a
#      sequence: The only difference is that we go through the save-restore cycle for
#      the last expression in a sequence as well as for the others. The interpreter
#      will still give the same value for any expression. But this change is fatal to
#      the tail-recursive implementation, because we must now return after evaluating
#      the final expression in a sequence in order to undo the (useless) register
#      saves. These extra saves will accumulate during a nest of procedure calls.
#      Consequently, processes such as @c(sqrt-iter) will require space proportional
#      to the number of iterations rather than requiring constant space.  This
#      difference can be significant. For example, with tail recursion, an infinite
#      loop can be expressed using only the procedure-call mechanism:
     Esto puede parecer un cambio menor a nuestro código anterior para la
     evaluación de una secuencia: La única diferencia es que pasamos por el
     ciclo de salvar-restaurar para la última expresión en una secuencia, así
     como para los demás. El intérprete seguirá dando el mismo valor para
     cualquier expresión. Pero este cambio es fatal para la implementación
     recursiva de la cola, porque ahora debemos regresar después de evaluar la
     expresión final en una secuencia para deshacer el registro (inútil)
     guarda. Estos ahorros adicionales se acumularán durante un nido de llamadas
     de procedimiento. En consecuencia, procesos tales como @c(sqrt-iter)
     requerirán espacio proporcional al número de iteraciones en lugar de
     requerir espacio constante. Esta diferencia puede ser significativa. Por
     ejemplo, con la recursividad de la cola, se puede expresar un bucle
     infinito utilizando sólo el mecanismo de llamada a procedimiento:

#      ..src > scheme
#        (define (count n)
#          (newline)
#          (display n)
#          (count (+ n 1)))
#      < src..
     ..src > scheme
       (define (count n)
         (newline)
         (display n)
         (count (+ n 1)))
     < src..

#      Without tail recursion, such a procedure would eventually run out of stack
#      space, and expressing a true iteration would require some control mechanism
#      other than procedure call.
     Sin recursión de cola, tal procedimiento eventualmente se quedaría sin
     espacio de pila y expresar una iteración verdadera requeriría algún
     mecanismo de control distinto de la llamada a procedimiento.

# *** 5.4.3 <> Conditionals, Assignments, and Definitions
*** 5.4.3 <> Condicionales, asignaciones y definiciones

#     As with the metacircular evaluator, special forms are handled by selectively
#     evaluating fragments of the expression. For an @c(if) expression, we must
#     evaluate the predicate and decide, based on the value of predicate, whether to
#     evaluate the consequent or the alternative.
    Al igual que con el evaluador metacircular, las formas especiales se manejan
    mediante la evaluación selectiva de fragmentos de la expresión. Para una
    @c(if) expresión, debemos evaluar el predicado y decidir, basado en el valor
    del predicado, si evaluar el consecuente o la alternativa.

#     Before evaluating the predicate, we save the @c(if) expression itself so that
#     we can later extract the consequent or alternative. We also save the
#     environment, which we will need later in order to evaluate the consequent or
#     the alternative, and we save @c(continue), which we will need later in order
#     to return to the evaluation of the expression that is waiting for the value of
#     the @c(if).
    Antes de evaluar el predicado, guardamos la @c(if) expresión misma para
    poder extraer posteriormente el consecuente o alternativo. También ahorramos
    el medio ambiente, que necesitaremos más tarde para evaluar el consecuente o
    la alternativa, y ahorrar @c(continue), que necesitaremos más tarde para
    volver a la evaluación de la expresión que está a la espera del valor de la
    @c(if).

#     ..src > scheme
#       ev-if
#         (save exp)   ; save expression for later
#         (save env)
#         (save continue)
#         (assign continue (label ev-if-decide))
#         (assign exp (op if-predicate) (reg exp))
#         ; evaluate the predicate:
#         (goto (label eval-dispatch))
#     < src..
    ..src > scheme
      ev-if
        (save exp)   ; save expression for later
        (save env)
        (save continue)
        (assign continue (label ev-if-decide))
        (assign exp (op if-predicate) (reg exp))
        ; evaluate the predicate:
        (goto (label eval-dispatch))
    < src..

#     When we return from evaluating the predicate, we test whether it was true or
#     false and, depending on the result, place either the consequent or the
#     alternative in @c(exp) before going to @c(eval-dispatch). Notice that
#     restoring @c(env) and @c(continue) here sets up @c(eval-dispatch) to have the
#     correct environment and to continue at the right place to receive the value of
#     the @c(if) expression.
    Cuando volvemos de la evaluación del predicado, probamos si era verdadero o
    falso y, dependiendo del resultado, colocamos el consecuente o la
    alternativa @c(exp) antes de ir a @c(eval-dispatch). Tenga en cuenta que la
    restauración @c(env) y @c(continue) aquí se establece @c(eval-dispatch) para
    tener el entorno correcto y para continuar en el lugar correcto para recibir
    el valor de la @c(if) expresión.

#     ..src > scheme
#       ev-if-decide
#         (restore continue)
#         (restore env)
#         (restore exp)
#         (test (op true?) (reg val))
#         (branch (label ev-if-consequent))
#       ev-if-alternative
#         (assign exp (op if-alternative) (reg exp))
#         (goto (label eval-dispatch))
#       ev-if-consequent
#         (assign exp (op if-consequent) (reg exp))
#         (goto (label eval-dispatch))
#     < src..
    ..src > scheme
      ev-if-decide
        (restore continue)
        (restore env)
        (restore exp)
        (test (op true?) (reg val))
        (branch (label ev-if-consequent))
      ev-if-alternative
        (assign exp (op if-alternative) (reg exp))
        (goto (label eval-dispatch))
      ev-if-consequent
        (assign exp (op if-consequent) (reg exp))
        (goto (label eval-dispatch))
    < src..

# **** Assignments and definitions
**** Asignaciones y definiciones

#      Assignments are handled by @c(ev-assignment), which is reached from
#      @c(eval-dispatch) with the assignment expression in @c(exp). The code at
#      @c(ev-assignment) first evaluates the value part of the expression and then
#      installs the new value in the environment. @c(Set-variable-value!) is assumed
#      to be available as a machine operation.
     Las asignaciones son manejadas por @c(ev-assignment), que se alcanza desde
     @c(eval-dispatch) con la expresión de asignación en @c(exp). El código
     @c(ev-assignment) primero evalúa la parte de valor de la expresión y luego
     instala el nuevo valor en el entorno. @c(Set-variable-value!) Se supone que
     está disponible como una operación de máquina.

#      ..src > scheme
#        ev-assignment
#          (assign unev
#                  (op assignment-variable)
#                  (reg exp))
#          (save unev)   ; save variable for later
#          (assign exp
#                  (op assignment-value)
#                  (reg exp))
#          (save env)
#          (save continue)
#          (assign continue
#                  (label ev-assignment-1))
#          ; evaluate the assignment value:
#          (goto (label eval-dispatch))
#        ev-assignment-1
#          (restore continue)
#          (restore env)
#          (restore unev)
#          (perform (op set-variable-value!)
#                   (reg unev)
#                   (reg val)
#                   (reg env))
#          (assign val
#                  (const ok))
#          (goto (reg continue))
#      < src..
     ..src > scheme
       ev-assignment
         (assign unev
                 (op assignment-variable)
                 (reg exp))
         (save unev)   ; save variable for later
         (assign exp
                 (op assignment-value)
                 (reg exp))
         (save env)
         (save continue)
         (assign continue
                 (label ev-assignment-1))
         ; evaluate the assignment value:
         (goto (label eval-dispatch))
       ev-assignment-1
         (restore continue)
         (restore env)
         (restore unev)
         (perform (op set-variable-value!)
                  (reg unev)
                  (reg val)
                  (reg env))
         (assign val
                 (const ok))
         (goto (reg continue))
     < src..

#      Definitions are handled in a similar way:
     Las definiciones se manejan de manera similar:

#      ..src > scheme
#        ev-definition
#          (assign unev
#                  (op definition-variable)
#                  (reg exp))
#          (save unev)   ; save variable for later
#          (assign exp
#                  (op definition-value)
#                  (reg exp))
#          (save env)
#          (save continue)
#          (assign continue (label ev-definition-1))
#          ; evaluate the definition value:
#          (goto (label eval-dispatch))
#        ev-definition-1
#          (restore continue)
#          (restore env)
#          (restore unev)
#          (perform (op define-variable!)
#                   (reg unev)
#                   (reg val)
#                   (reg env))
#          (assign val (const ok))
#          (goto (reg continue))
#      < src..
     ..src > scheme
       ev-definition
         (assign unev
                 (op definition-variable)
                 (reg exp))
         (save unev)   ; save variable for later
         (assign exp
                 (op definition-value)
                 (reg exp))
         (save env)
         (save continue)
         (assign continue (label ev-definition-1))
         ; evaluate the definition value:
         (goto (label eval-dispatch))
       ev-definition-1
         (restore continue)
         (restore env)
         (restore unev)
         (perform (op define-variable!)
                  (reg unev)
                  (reg val)
                  (reg env))
         (assign val (const ok))
         (goto (reg continue))
     < src..

#      :: @t(Exercise 5.23) :: Extend the evaluator to handle derived expressions
#         such as @c(cond), @c(let), and so on (section @l(#4.1.2)). You may @"(cheat) and
#         assume that the syntax transformers such as @c(cond->if) are available as
#         machine operations.@n(313)
     :: @t(Ejercicio 5.23) :: Extender el evaluador de manejar expresiones
        derivadas tales como @c(cond), @c(let), y así sucesivamente (
        @l(#4.1.2)). Usted puede @"(engañar) y asumir que los
        transformadores sintácticos, tales como @c(cond->if) están
        disponibles como operaciones de la máquina.@n(313)

#      :: @t(Exercise 5.24) :: Implement @c(cond) as a new basic special form without
#         reducing it to @c(if). You will have to construct a loop that tests the
#         predicates of successive @c(cond) clauses until you find one that is true,
#         and then use @c(ev-sequence) to evaluate the actions of the clause.
     :: @t(Ejercicio 5.24) :: Implementar @c(cond) como una nueva forma especial
        básica sin reducirla a @c(if). Tendrás que construir un bucle que pruebe
        los predicados de las @c(cond) cláusulas sucesivas hasta que encuentres
        una que sea verdadera, y luego usar @c(ev-sequence) para evaluar las
        acciones de la cláusula.

#      :: @t(Exercise 5.25) :: Modify the evaluator so that it uses normal-order
#         evaluation, based on the lazy evaluator of section @l(#4.2).
     :: @t(Ejercicio 5.25) :: Modifique el evaluador para que utilice la
        evaluación de orden normal, basada en el evaluador perezoso de
        @l(#4.2).

# *** 5.4.4 <> Running the Evaluator
*** 5.4.4 <> Ejecución del evaluador

#     With the implementation of the explicit-control evaluator we come to the end
#     of a development, begun in @l(#Chapter 1), in which we have explored
#     successively more precise models of the evaluation process. We started with
#     the relatively informal substitution model, then extended this in
#     @l(#Chapter 3) to the environment model, which enabled us to deal with state
#     and change. In the metacircular evaluator of @l(#Chapter 4), we used Scheme
#     itself as a language for making more explicit the environment structure
#     constructed during evaluation of an expression. Now, with register machines,
#     we have taken a close look at the evaluator's mechanisms for storage
#     management, argument passing, and control. At each new level of description,
#     we have had to raise issues and resolve ambiguities that were not apparent at
#     the previous, less precise treatment of evaluation. To understand the behavior
#     of the explicit-control evaluator, we can simulate it and monitor its
#     performance.
    Con la implementación del evaluador de control explícito llegamos al final
    de un desarrollo, iniciado en el @l(Capitulo 1), en el que hemos
    explorado sucesivamente modelos más precisos del proceso de
    evaluación. Empezamos con el modelo de sustitución relativamente informal,
    luego lo extendimos en el @l(#Capitulo 3) al modelo ambiental, lo
    que nos permitió lidiar con el estado y el cambio. En el evaluador
    metacircular del @l(#Capitulo 4), utilizamos Scheme como un
    lenguaje para hacer más explícita la estructura del entorno construida
    durante la evaluación de una expresión. Ahora, con las máquinas de registro,
    hemos examinado de cerca los mecanismos del evaluador para la gestión del
    almacenamiento, el control de los argumentos y el control. En cada nuevo
    nivel de descripción, Hemos tenido que plantear cuestiones y resolver
    ambigüedades que no eran evidentes en el tratamiento previo, menos preciso
    de la evaluación. Para entender el comportamiento del evaluador de control
    explícito, podemos simularlo y monitorear su desempeño.

#     We will install a driver loop in our evaluator machine. This plays the role of
#     the @c(driver-loop) procedure of section @l(#4.1.4). The evaluator will repeatedly
#     print a prompt, read an expression, evaluate the expression by going to
#     @c(eval-dispatch), and print the result. The following instructions form the
#     beginning of the explicit-control evaluator's controller sequence:@n(314)
    Instalaremos un bucle de control en nuestra máquina evaluadora. Esto
    desempeña el papel del procedimiento @c(driver-loop) de
    @l(#4.1.4). El evaluador imprimirá repetidamente un mensaje, leerá
    una expresión, evaluará la expresión @c(eval-dispatch) y se imprimirá el
    resultado. Las siguientes instrucciones forman el comienzo de la secuencia
    de control del evaluador de control explícito:@n(314)

#     ..src > scheme
#       read-eval-print-loop
#         (perform (op initialize-stack))
#         (perform (op prompt-for-input)
#                  (const ";;; EC-Eval input:"))
#         (assign exp (op read))
#         (assign env (op get-global-environment))
#         (assign continue (label print-result))
#         (goto (label eval-dispatch))
#       print-result
#         (perform (op announce-output)
#                  (const ";;; EC-Eval value:"))
#         (perform (op user-print) (reg val))
#         (goto (label read-eval-print-loop))
#     < src..
    ..src > scheme
      read-eval-print-loop
        (perform (op initialize-stack))
        (perform (op prompt-for-input)
                 (const ";;; EC-Eval input:"))
        (assign exp (op read))
        (assign env (op get-global-environment))
        (assign continue (label print-result))
        (goto (label eval-dispatch))
      print-result
        (perform (op announce-output)
                 (const ";;; EC-Eval value:"))
        (perform (op user-print) (reg val))
        (goto (label read-eval-print-loop))
    < src..

#     When we encounter an error in a procedure (such as the @"(unknown procedure
#     type error) indicated at @c(apply-dispatch)), we print an error message and
#     return to the driver loop.@n(315)
    Cuando encontramos un error en un procedimiento (como el @"(error de tipo de
    procedimiento desconocido) indicado en @c(apply-dispatch)), imprimimos un
    mensaje de error y volvemos al bucle del controlador.@n(315)

#     ..src > scheme
#       unknown-expression-type
#         (assign
#          val
#          (const unknown-expression-type-error))
#         (goto (label signal-error))
#       unknown-procedure-type
#         ; clean up stack (from apply-dispatch):
#         (restore continue)
#         (assign
#          val
#          (const unknown-procedure-type-error))
#         (goto (label signal-error))
#       signal-error
#         (perform (op user-print) (reg val))
#         (goto (label read-eval-print-loop))
#     < src..
    ..src > scheme
      unknown-expression-type
        (assign
         val
         (const unknown-expression-type-error))
        (goto (label signal-error))
      unknown-procedure-type
        ; clean up stack (from apply-dispatch):
        (restore continue)
        (assign
         val
         (const unknown-procedure-type-error))
        (goto (label signal-error))
      signal-error
        (perform (op user-print) (reg val))
        (goto (label read-eval-print-loop))
    < src..

#     For the purposes of the simulation, we initialize the stack each time through
#     the driver loop, since it might not be empty after an error (such as an
#     undefined variable) interrupts an evaluation.@n(316)
    Para los propósitos de la simulación, inicializamos la pila cada vez a
    través del bucle de controlador, ya que puede no estar vacía después de un
    error (como una variable indefinida) interrumpe una
    evaluación.@n(316)

#     If we combine all the code fragments presented in section @l(#5.4.1)--@l(#5.4.4), we
#     can create an evaluator machine model that we can run using the
#     register-machine simulator of section @l(#5.2).
    Si combinamos todos los fragmentos de código presentados en
    @l(#5.4.1) - @l(#5.4.4), podemos crear un modelo de máquina
    evaluadora que podemos ejecutar usando el simulador de máquina registradora
    de la seccion @l(#5.2).

#     ..src > scheme
#       (define eceval
#         (make-machine
#          '(exp env val proc argl continue unev)
#          eceval-operations
#          '(read-eval-print-loop
#            ⟨entire machine controller
#             as given above⟩)))
#     < src..
    ..src > scheme
      (define eceval
        (make-machine
         '(exp env val proc argl continue unev)
         eceval-operations
         '(read-eval-print-loop
           ⟨entire machine controller
            as given above⟩)))
    < src..

#     We must define Scheme procedures to simulate the operations used as primitives
#     by the evaluator. These are the same procedures we used for the metacircular
#     evaluator in section @l(#4.1), together with the few additional ones defined in
#     footnotes throughout @l(#5.4).
    Debemos definir los procedimientos del Scheme para simular las operaciones
    utilizadas como primitivas por el evaluador. Estos son los mismos
    procedimientos que utilizamos para el evaluador metacircular en
    @l(#4.1), junto con los pocos adicionales definidos en las notas a pie
    de página en la seccion @l(#5.4).

#     ..src > scheme
#       (define eceval-operations
#         (list (list 'self-evaluating?
#                     self-evaluating)
#               ⟨@e(complete list of operations)
#                @e(for eceval machine)⟩))
#     < src..
    ..src > scheme
      (define eceval-operations
        (list (list 'self-evaluating?
                    self-evaluating)
              ⟨@e(complete list of operations)
               @e(for eceval machine)⟩))
    < src..

#     Finally, we can initialize the global environment and run the evaluator:
    Finalmente, podemos inicializar el entorno global y ejecutar el evaluador:

#     ..srci > scheme
#       > (define the-global-environment
#       ^   (setup-environment))
#       > (start eceval)
#
#       ;;; EC-Eval input:
#       > (define (append x y)
#       ^   (if (null? x)
#       ^       y
#       ^       (cons (car x) (append (cdr x) y))))
#       ;;; EC-Eval value:
#       ok
#
#       ;;; EC-Eval input:
#       > (append '(a b c) '(d e f))
#       ;;; EC-Eval value:
#       (a b c d e f)
#     < srci..
    ..srci > scheme
      > (define the-global-environment
      ^   (setup-environment))
      > (start eceval)

      ;;; EC-Eval input:
      > (define (append x y)
      ^   (if (null? x)
      ^       y
      ^       (cons (car x) (append (cdr x) y))))
      ;;; EC-Eval value:
      ok

      ;;; EC-Eval input:
      > (append '(a b c) '(d e f))
      ;;; EC-Eval value:
      (a b c d e f)
    < srci..

#     Of course, evaluating expressions in this way will take much longer than if we
#     had directly typed them into Scheme, because of the multiple levels of
#     simulation involved. Our expressions are evaluated by the
#     explicit-control-evaluator machine, which is being simulated by a Scheme
#     program, which is itself being evaluated by the Scheme interpreter.
    Por supuesto, evaluar las expresiones de esta manera tomará mucho más tiempo
    que si las hubiéramos escrito directamente en Scheme, debido a los múltiples
    niveles de simulación involucrados. Nuestras expresiones son evaluadas por
    la máquina explícita de control-evaluador, que está siendo simulada por un
    programa Scheme, el cual está siendo evaluado por el intérprete de Scheme.

# **** Monitoring the performance of the evaluator
**** Seguimiento del desempeño del evaluador

#      Simulation can be a powerful tool to guide the implementation of evaluators.
#      Simulations make it easy not only to explore variations of the
#      register-machine design but also to monitor the performance of the simulated
#      evaluator. For example, one important factor in performance is how efficiently
#      the evaluator uses the stack. We can observe the number of stack operations
#      required to evaluate various expressions by defining the evaluator register
#      machine with the version of the simulator that collects statistics on stack
#      use (section @l(#5.2.4)), and adding an instruction at the evaluator's
#      @c(print-result) entry point to print the statistics:
     La simulación puede ser una herramienta poderosa para guiar la
     implementación de los evaluadores. Las simulaciones facilitan no sólo la
     exploración de las variaciones del diseño registrador-máquina, sino también
     el seguimiento del rendimiento del evaluador simulado. Por ejemplo, un
     factor importante en el rendimiento es la eficiencia con la que el
     evaluador utiliza la pila. Podemos observar el número de operaciones de la
     pila requeridas para evaluar diversas expresiones definiendo la máquina del
     registrador del evaluador con la versión del simulador que recoge las
     estadísticas sobre el uso de la pila (seccion @l(#5.2.4)) y agregando una
     instrucción en el @c(print-result) punto de entrada del evaluador para
     imprimir las estadísticas :

#      ..src > scheme
#        print-result
#          ; added instruction:
#          (perform (op print-stack-statistics))
#          (perform (op announce-output)
#                   (const ";;; EC-Eval value:"))
#          … ; same as before
#      < src..
     ..src > scheme
       print-result
         ; added instruction:
         (perform (op print-stack-statistics))
         (perform (op announce-output)
                  (const ";;; EC-Eval value:"))
         … ; same as before
     < src..

#      Interactions with the evaluator now look like this:
     Las interacciones con el evaluador ahora se parecen a esto:

#      ..srci > scheme
#        ;;; EC-Eval input:
#        > (define (factorial n)
#        ^   (if (= n 1) 1 (* (factorial (- n 1)) n)))
#        (total-pushes = 3, maximum-depth = 3)
#
#        ;;; EC-Eval value:
#        ok
#
#        ;;; EC-Eval input:
#        > (factorial 5)
#        (total-pushes = 144, maximum-depth = 28)
#
#        ;;; EC-Eval value:
#        120
#      < srci..
     ..srci > scheme
       ;;; EC-Eval input:
       > (define (factorial n)
       ^   (if (= n 1) 1 (* (factorial (- n 1)) n)))
       (total-pushes = 3, maximum-depth = 3)

       ;;; EC-Eval value:
       ok

       ;;; EC-Eval input:
       > (factorial 5)
       (total-pushes = 144, maximum-depth = 28)

       ;;; EC-Eval value:
       120
     < srci..

#      Note that the driver loop of the evaluator reinitializes the stack at the
#      start of each interaction, so that the statistics printed will refer only to
#      stack operations used to evaluate the previous expression.
     Tenga en cuenta que el bucle del controlador del evaluador reinicializa la
     pila al inicio de cada interacción, de modo que las estadísticas impresas
     sólo se refieren a las operaciones de pila utilizadas para evaluar la
     expresión anterior.

#      :: @t(Exercise 5.26) :: Use the monitored stack to explore the tail-recursive
#         property of the evaluator (section @l(#5.4.2)).  Start the evaluator and define the
#         iterative @c(factorial) procedure from @l(#1.2.1):
     :: @t(Ejercicio 5.26) :: Utilice la pila supervisada para explorar la
        propiedad recursiva de cola del evaluador (seccion @l(#5.4.2)). Iniciar
        el evaluador y definir el procedimiento @c(factorial) iterativo de
        @l(#1.2.1) :

#         ..src > scheme
#           (define (factorial n)
#             (define (iter product counter)
#               (if (> counter n)
#                   product
#                   (iter (* counter product)
#                         (+ counter 1))))
#             (iter 1 1))
#         < src..
        ..src > scheme
          (define (factorial n)
            (define (iter product counter)
              (if (> counter n)
                  product
                  (iter (* counter product)
                        (+ counter 1))))
            (iter 1 1))
        < src..

#         Run the procedure with some small values of @m(n). Record the maximum stack
#         depth and the number of pushes required to compute @m(n!) for each of these
#         values.
        Ejecute el procedimiento con algunos valores pequeños de @m(n). Registre
        la profundidad máxima de la pila y el número de empujes necesarios para
        calcular @m(n! ) Para cada uno de estos valores.

#         1. You will find that the maximum depth required to evaluate @m(n!) is
#            independent of @m(n). What is that depth?
        1. ¡Usted encontrará que la profundidad máxima requerida para evaluar
           @m(n! ) Es independiente de @m(n). ¿Qué es esa profundidad?

#         2. Determine from your data a formula in terms of @m(n) for the total
#            number of push operations used in evaluating @m(n!) for any @m(n ≥
#            1). Note that the number of operations used is a linear function of
#            @m(n) and is thus determined by two constants.
        2. Determine a partir de sus datos una fórmula en términos de @m(n) para
           el número total de operaciones de empuje utilizadas en la evaluación
           de @m(n! ) Para cualquier @m(n ≥ 1). Obsérvese que el número de
           operaciones utilizadas es una función lineal de @m(n) y se determina
           así por dos constantes.

#      :: @t(Exercise 5.27) :: For comparison with @l(#Exercise 5.26), explore the
#         behavior of the following procedure for computing factorials recursively:
     :: @t(Ejercicio 5.27) :: Para la comparación con el
        @l(#Ejercicio 5.26), explorar el comportamiento del
        siguiente procedimiento para el cálculo factorials recursivamente:

#         ..src > scheme
#           (define (factorial n)
#             (if (= n 1)
#                 1
#                 (* (factorial (- n 1)) n)))
#         < src..
        ..src > scheme
          (define (factorial n)
            (if (= n 1)
                1
                (* (factorial (- n 1)) n)))
        < src..

#         By running this procedure with the monitored stack, determine, as a
#         function of @m(n), the maximum depth of the stack and the total number of
#         pushes used in evaluating @m(n!) for @m(n ≥ 1). (Again, these functions
#         will be linear.)  Summarize your experiments by filling in the following
#         table with the appropriate expressions in terms of @m(n):
        Ejecutando este procedimiento con la pila supervisada, determine, en
        función de @m(n), la profundidad máxima de la pila y el número total de
        empujes utilizados para evaluar @m(n! ) Para @m(n ≥ 1). (Nuevamente,
        estas funciones serán lineales). Resuma sus experimentos rellenando la
        siguiente tabla con las expresiones apropiadas en términos de @m(n) :

#         ..example >
#                          Maximum depth       Number of pushes
#
#           Recursive
#           factorial
#
#           Iterative
#           factorial
#         < example..
        ..example >
                         Maximum depth       Number of pushes

          Recursive
          factorial

          Iterative
          factorial
        < example..

#         The maximum depth is a measure of the amount of space used by the evaluator
#         in carrying out the computation, and the number of pushes correlates well
#         with the time required.
        La profundidad máxima es una medida de la cantidad de espacio utilizado
        por el evaluador para llevar a cabo el cálculo, y el número de empujes
        se correlaciona bien con el tiempo requerido.

#      :: @t(Exercise 5.28) :: Modify the definition of the evaluator by changing
#         @c(eval-sequence) as described in section @l(#5.4.2) so that the evaluator is no
#         longer tail-recursive. Rerun your experiments from @l(#Exercise 5.26) and
#         @l(#Exercise 5.27) to demonstrate that both versions of the @c(factorial)
#         procedure now require space that grows linearly with their input.
     :: @t(Ejercicio 5.28) :: Modifique la definición del evaluador cambiando
        @c(eval-sequence) como se describe en la seccion @l(#5.4.2) para que el
        evaluador ya no sea recursivo de cola. Vuelva a ejecutar sus
        experimentos a partir del @l(#Ejercicio 5.26) y el
        @l(#Ejercicio 5.27) para demostrar que ambas versiones
        del procedimiento @c(factorial) ahora requieren espacio que crece
        linealmente con su entrada.

#      :: @t(Exercise 5.29) :: Monitor the stack operations in the tree-recursive
#         Fibonacci computation:
     :: @t(Ejercicio 5.29) :: Supervisar las operaciones de la pila en el
        cálculo recursivo de Fibonacci:

#         ..src > scheme
#           (define (fib n)
#             (if (< n 2)
#                 n
#                 (+ (fib (- n 1)) (fib (- n 2)))))
#         < src..
        ..src > scheme
          (define (fib n)
            (if (< n 2)
                n
                (+ (fib (- n 1)) (fib (- n 2)))))
        < src..

#         1. Give a formula in terms of @m(n) for the maximum depth of the stack
#            required to compute @m[Fib(n)] for @m(n ≥ 2). Hint: in section @l(#1.2.2) we
#            argued that the space used by this process grows linearly with @m(n).
        1. Proporcione una fórmula en términos de @m(n) para la profundidad
           máxima de la pila requerida para calcular @m(Fib (n)) para @m(n ≥
           2). Sugerencia: en la seccion @l(#1.2.2) argumentamos que el espacio
           utilizado por este proceso crece linealmente con @m(n).

#         2. Give a formula for the total number of pushes used to compute @m[Fib(n)]
#            for @m(n ≥ 2). You should find that the number of pushes (which
#            correlates well with the time used) grows exponentially with
#            @m(n). Hint: Let @m[S(n)] be the number of pushes used in computing
#            @m[Fib(n)]. You should be able to argue that there is a formula that
#            expresses @m[S(n)] in terms of @m[S(n - 1)], @m[S(n - 2)], and some
#            fixed @"(overhead) constant @m(k) that is independent of @m(n). Give the
#            formula, and say what @m(k) is. Then show that @m[S(n)] can be expressed
#            as @m[a⋅Fib(n + 1) + b] and give the values of @m(a) and @m(b).
        2. Dé una fórmula para el número total de empujes utilizados para
           calcular @m(Fib (n)) para @m(n ≥ 2). Usted debe encontrar que el
           número de empujes (que se correlaciona bien con el tiempo utilizado)
           crece exponencialmente con @m(n). Sugerencia: Sea @m(S (n)) el número
           de empujes utilizados en el cálculo de @m(Fib (n)). Debe ser capaz de
           argumentar que no hay una fórmula que expresa @m(S (n)) en términos
           de @m(S (n - 1)), @m(S (n - 2)), y algunos fijo @"(sobrecarga)
           constante @m(k) que es independiente de @m(n). Dar la fórmula, y
           decir lo que @m(k) es.@m()@m()@m()@m()

#      :: @t(Exercise 5.30) :: Our evaluator currently catches and signals only two
#         kinds of errors––unknown expression types and unknown procedure
#         types. Other errors will take us out of the evaluator read-eval-print
#         loop. When we run the evaluator using the register-machine simulator, these
#         errors are caught by the underlying Scheme system. This is analogous to the
#         computer crashing when a user program makes an error.@n(317) It is a large
#         project to make a real error system work, but it is well worth the effort
#         to understand what is involved here.
     :: @t(Ejercicio 5.30) :: Actualmente, nuestro evaluador captura y señala
        sólo dos tipos de errores: tipos de expresión desconocidos y tipos de
        procedimientos desconocidos. Otros errores nos sacarán del ciclo de
        lectura-eval-print del evaluador. Cuando ejecutamos el evaluador
        utilizando el simulador registrador-máquina, estos errores son
        capturados por el sistema Scheme subyacente. Esto es análogo a la caída
        del ordenador cuando un programa de usuario comete un
        error.@n(317) Es un gran proyecto hacer un verdadero sistema de
        errores funcionar, pero vale la pena el esfuerzo de entender lo que está
        involucrado aquí.

#         1. Errors that occur in the evaluation process, such as an attempt to
#            access an unbound variable, could be caught by changing the lookup
#            operation to make it return a distinguished condition code, which cannot
#            be a possible value of any user variable. The evaluator can test for
#            this condition code and then do what is necessary to go to
#            @c(signal-error). Find all of the places in the evaluator where such a
#            change is necessary and fix them. This is lots of work.
        1. Los errores que se producen en el proceso de evaluación, como un
           intento de acceder a una variable no enlazada, podrían detectarse
           cambiando la operación de búsqueda para que devuelva un código de
           condición distinguido, que no puede ser un valor posible de ninguna
           variable de usuario. El evaluador puede probar para este código de
           condición y luego hacer lo necesario para ir a
           @c(signal-error). Encontrar todos los lugares en el evaluador donde
           tal cambio es necesario y corregirlos. Esto es mucho trabajo.

#         2. Much worse is the problem of handling errors that are signaled by
#            applying primitive procedures, such as an attempt to divide by zero or
#            an attempt to extract the @c(car) of a symbol. In a professionally
#            written high-quality system, each primitive application is checked for
#            safety as part of the primitive. For example, every call to @c(car)
#            could first check that the argument is a pair. If the argument is not a
#            pair, the application would return a distinguished condition code to the
#            evaluator, which would then report the failure. We could arrange for
#            this in our register-machine simulator by making each primitive
#            procedure check for applicability and returning an appropriate
#            distinguished condition code on failure. Then the @c(primitive-apply)
#            code in the evaluator can check for the condition code and go to
#            @c(signal-error) if necessary. Build this structure and make it
#            work. This is a major project.
        2. Mucho peor es el problema de manejar errores que son señalados
           aplicando procedimientos primitivos, como un intento de dividir por
           cero o un intento de extraer el @c(car) de un símbolo. En un sistema
           de alta calidad profesionalmente escrito, cada aplicación primitiva
           se comprueba para la seguridad como parte del primitivo. Por ejemplo,
           cada llamada a @c(car) podría primero comprobar que el argumento es
           un par. Si el argumento no es un par, la aplicación devolverá un
           código de condición distinguido al evaluador, que luego informaría
           del fallo. Podríamos arreglar esto en nuestro simulador de
           registro-máquina haciendo que cada procedimiento primitivo compruebe
           su aplicabilidad y devolviendo un código de condición distinguido
           apropiado al fallar. A continuación, el @c(primitive-apply) código en
           el evaluador puede comprobar el código de condición y vaya a
           @c(signal-error) si es necesario. Construir esta estructura y hacer
           que funcione. Este es un gran proyecto.

# ** 5.5 <> Compilation
** 5.5 <> Compilacion

#    The explicit-control evaluator of section @l(#5.4) is a register machine whose
#    controller interprets Scheme programs. In this section we will see how to run
#    Scheme programs on a register machine whose controller is not a Scheme
#    interpreter.
   El evaluador de control explícito de la seccion @l(#5.4) es una máquina
   registradora cuyo controlador interpreta programas Scheme. En esta sección
   veremos cómo ejecutar programas Scheme en una máquina de registro cuyo
   controlador no es un intérprete Scheme.

#    The explicit-control evaluator machine is universal––it can carry out any
#    computational process that can be described in Scheme. The evaluator's
#    controller orchestrates the use of its data paths to perform the desired
#    computation. Thus, the evaluator's data paths are universal: They are
#    sufficient to perform any computation we desire, given an appropriate
#    controller.@n(318)
   La máquina evaluadora de control explícito es universal - puede llevar a cabo
   cualquier proceso computacional que pueda describirse en Scheme. El
   controlador del evaluador orquesta el uso de sus rutas de datos para realizar
   el cálculo deseado. Por lo tanto, las trayectorias de datos del evaluador son
   universales: son suficientes para realizar cualquier cálculo que deseemos,
   dado un controlador apropiado.@n(318)

#    Commercial general-purpose computers are register machines organized around a
#    collection of registers and operations that constitute an efficient and
#    convenient universal set of data paths. The controller for a general-purpose
#    machine is an interpreter for a register-machine language like the one we have
#    been using. This language is called the @e(native language) of the machine, or
#    simply @e(machine language). Programs written in machine language are
#    sequences of instructions that use the machine's data paths. For example, the
#    explicit-control evaluator's instruction sequence can be thought of as a
#    machine-language program for a general-purpose computer rather than as the
#    controller for a specialized interpreter machine.
   Las computadoras comerciales de uso general son máquinas de registro
   organizadas en torno a una colección de registros y operaciones que
   constituyen un conjunto universal y eficiente de rutas de datos. El
   controlador para una máquina de propósito general es un intérprete para un
   lenguaje de registro-máquina como el que hemos estado usando. Este lenguaje
   se denomina @e(idioma nativo) de la máquina, o simplemente @e(lenguaje de
   máquina). Los programas escritos en lenguaje de máquina son secuencias de
   instrucciones que usan las rutas de datos de la máquina. Por ejemplo, la
   secuencia de instrucciones del evaluador de control explícito puede
   considerarse como un programa en lenguaje de máquina para una computadora de
   uso general en lugar de como el controlador para una máquina de intérprete
   especializada.

#    There are two common strategies for bridging the gap between higher-level
#    languages and register-machine languages. The explicit-control evaluator
#    illustrates the strategy of interpretation. An interpreter written in the
#    native language of a machine configures the machine to execute programs
#    written in a language (called the @e(source language)) that may differ from
#    the native language of the machine performing the evaluation. The primitive
#    procedures of the source language are implemented as a library of subroutines
#    written in the native language of the given machine. A program to be
#    interpreted (called the @e(source program)) is represented as a data
#    structure. The interpreter traverses this data structure, analyzing the source
#    program. As it does so, it simulates the intended behavior of the source
#    program by calling appropriate primitive subroutines from the library.
   Hay dos estrategias comunes para salvar la brecha entre lenguajes de alto
   nivel y lenguajes de registro-máquina. El evaluador de control explícito
   ilustra la estrategia de interpretación. Un intérprete escrito en el idioma
   nativo de una máquina configura la máquina para ejecutar programas escritos
   en un idioma (llamado el @e(idioma de origen) ) que pueden diferir del idioma
   nativo de la máquina que realiza la evaluación. Los procedimientos primitivos
   del lenguaje fuente se implementan como una libreria de subrutinas escritas
   en el lenguaje nativo de la máquina dada. Un programa a interpretar (llamado
   el @e(programa fuente) ) se representa como una estructura de datos. El
   intérprete atraviesa esta estructura de datos, analizando el programa
   fuente. Al hacerlo,

#    In this section, we explore the alternative strategy of @e(compilation).  A
#    compiler for a given source language and machine translates a source program
#    into an equivalent program (called the @e(object program)) written in the
#    machine's native language. The compiler that we implement in this section
#    translates programs written in Scheme into sequences of instructions to be
#    executed using the explicit-control evaluator machine's data paths.@n(319)
   En esta sección, exploramos la estrategia alternativa de @e(compilación). Un
   compilador para un lenguaje fuente y una máquina traduce un programa fuente
   en un programa equivalente (llamado el @e(programa objeto) ) escrito en el
   idioma nativo de la máquina. El compilador que implementamos en esta sección
   traduce los programas escritos en Scheme en secuencias de instrucciones a
   ejecutar utilizando las rutas de datos de la máquina evaluadora de control
   explícito.@n(319)

#    Compared with interpretation, compilation can provide a great increase in the
#    efficiency of program execution, as we will explain below in the overview of
#    the compiler. On the other hand, an interpreter provides a more powerful
#    environment for interactive program development and debugging, because the
#    source program being executed is available at run time to be examined and
#    modified. In addition, because the entire library of primitives is present,
#    new programs can be constructed and added to the system during debugging.
   En comparación con la interpretación, la compilación puede proporcionar un
   gran aumento en la eficiencia de la ejecución del programa, como explicaremos
   a continuación en la visión general del compilador. Por otro lado, un
   intérprete proporciona un entorno más potente para el desarrollo y depuración
   interactivos de programas, ya que el programa fuente que se está ejecutando
   está disponible en tiempo de ejecución para ser examinado y
   modificado. Además, como toda la libreria de primitivas está presente, se
   pueden construir y agregar nuevos programas al sistema durante la depuración.

#    In view of the complementary advantages of compilation and interpretation,
#    modern program-development environments pursue a mixed strategy. Lisp
#    interpreters are generally organized so that interpreted procedures and
#    compiled procedures can call each other. This enables a programmer to compile
#    those parts of a program that are assumed to be debugged, thus gaining the
#    efficiency advantage of compilation, while retaining the interpretive mode of
#    execution for those parts of the program that are in the flux of interactive
#    development and debugging. in section @l(#5.5.7), after we have implemented the
#    compiler, we will show how to interface it with our interpreter to produce an
#    integrated interpreter-compiler development system.
   En vista de las ventajas complementarias de la compilación y la
   interpretación, los ambientes modernos de desarrollo de programas persiguen
   una estrategia mixta. Los intérpretes de Lisp se organizan generalmente de
   modo que los procedimientos interpretados y los procedimientos compilados
   puedan llamarse. Esto permite a un programador compilar aquellas partes de un
   programa que se supone que son depuradas, obteniendo así la ventaja de
   eficiencia de la compilación, conservando el modo interpretativo de ejecución
   para aquellas partes del programa que están en el flujo de desarrollo
   interactivo y depuración. en la seccion @l(#5.5.7), después de haber implementado
   el compilador, mostraremos cómo interconectarlo con nuestro intérprete para
   producir un sistema integrado de desarrollo de intérprete-compilador.

# *** An overview of the compiler
*** Una visión general del compilador

#     Our compiler is much like our interpreter, both in its structure and in the
#     function it performs. Accordingly, the mechanisms used by the compiler for
#     analyzing expressions will be similar to those used by the interpreter.
#     Moreover, to make it easy to interface compiled and interpreted code, we will
#     design the compiler to generate code that obeys the same conventions of
#     register usage as the interpreter: The environment will be kept in the @c(env)
#     register, argument lists will be accumulated in @c(argl), a procedure to be
#     applied will be in @c(proc), procedures will return their answers in @c(val),
#     and the location to which a procedure should return will be kept in
#     @c(continue). In general, the compiler translates a source program into an
#     object program that performs essentially the same register operations as would
#     the interpreter in evaluating the same source program.
    Nuestro compilador es muy similar a nuestro intérprete, tanto en su
    estructura como en la función que realiza. En consecuencia, los mecanismos
    utilizados por el compilador para analizar expresiones serán similares a los
    utilizados por el intérprete. Además, para facilitar la interfaz de código
    compilado e interpretado, diseñaremos el compilador para generar código que
    obedezca las mismas convenciones de uso de registro que el intérprete: El
    entorno se guardará en el @c(env) registro, las listas de argumentos se
    acumulan en @c(argl), El procedimiento a ser aplicado será en @c(proc), los
    procedimientos devolverán sus respuestas en @c(val), y la ubicación a la que
    un procedimiento debe devolver se mantendrá en @c(continue). En general,

#     This description suggests a strategy for implementing a rudimentary compiler:
#     We traverse the expression in the same way the interpreter does. When we
#     encounter a register instruction that the interpreter would perform in
#     evaluating the expression, we do not execute the instruction but instead
#     accumulate it into a sequence. The resulting sequence of instructions will be
#     the object code. Observe the efficiency advantage of compilation over
#     interpretation. Each time the interpreter evaluates an expression––for
#     example, @c[(f 84 96)]––it performs the work of classifying the expression
#     (discovering that this is a procedure application) and testing for the end of
#     the operand list (discovering that there are two operands). With a compiler,
#     the expression is analyzed only once, when the instruction sequence is
#     generated at compile time. The object code produced by the compiler contains
#     only the instructions that evaluate the operator and the two operands,
#     assemble the argument list, and apply the procedure (in @c(proc)) to the
#     arguments (in @c(argl)).
    Esta descripción sugiere una estrategia para implementar un compilador
    rudimentario: Recorremos la expresión de la misma manera que hace el
    intérprete. Cuando encontramos una instrucción de registro que el intérprete
    realizará al evaluar la expresión, no ejecutaremos la instrucción sino que
    la acumularemos en una secuencia. La secuencia resultante de instrucciones
    será el código objeto. Observe la ventaja de la eficiencia de la compilación
    sobre la interpretación. Cada vez que el intérprete evalúa una expresión -
    por ejemplo, @c[(f 84 96)]- realiza el trabajo de clasificar la expresión
    (descubriendo que se trata de una aplicación de procedimiento) y probar el
    final de la lista de operandos (descubriendo que hay dos operandos). Con un
    compilador, la expresión se analiza sólo una vez, cuando la secuencia de
    instrucciones se genera en tiempo de compilación.@c(proc)@c(argl)

#     This is the same kind of optimization we implemented in the analyzing
#     evaluator of section @l(#4.1.7). But there are further opportunities to gain
#     efficiency in compiled code. As the interpreter runs, it follows a process
#     that must be applicable to any expression in the language. In contrast, a
#     given segment of compiled code is meant to execute some particular
#     expression. This can make a big difference, for example in the use of the
#     stack to save registers. When the interpreter evaluates an expression, it must
#     be prepared for any contingency. Before evaluating a subexpression, the
#     interpreter saves all registers that will be needed later, because the
#     subexpression might require an arbitrary evaluation. A compiler, on the other
#     hand, can exploit the structure of the particular expression it is processing
#     to generate code that avoids unnecessary stack operations.
    Este es el mismo tipo de optimización que implementamos en el evaluador de
    análisis de la seccion @l(#4.1.7). Pero hay otras oportunidades para ganar
    eficiencia en el código compilado. A medida que el intérprete se ejecuta,
    sigue un proceso que debe ser aplicable a cualquier expresión en el
    lenguaje. En contraste, un determinado segmento de código compilado está
    destinado a ejecutar alguna expresión particular. Esto puede hacer una gran
    diferencia, por ejemplo en el uso de la pila para guardar registros. Cuando
    el intérprete evalúa una expresión, debe estar preparado para cualquier
    contingencia. Antes de evaluar una subexpresión, el intérprete guarda todos
    los registros que se necesitarán más tarde, porque la subexpresión puede
    requerir una evaluación arbitraria. Un compilador, por otro lado,

#     As a case in point, consider the combination @c[(f 84 96)]. Before the
#     interpreter evaluates the operator of the combination, it prepares for this
#     evaluation by saving the registers containing the operands and the
#     environment, whose values will be needed later. The interpreter then evaluates
#     the operator to obtain the result in @c(val), restores the saved registers,
#     and finally moves the result from @c(val) to @c(proc). However, in the
#     particular expression we are dealing with, the operator is the symbol @c(f),
#     whose evaluation is accomplished by the machine operation
#     @c(lookup-variable-value), which does not alter any registers. The compiler
#     that we implement in this section will take advantage of this fact and
#     generate code that evaluates the operator using the instruction
    Como ejemplo, considere la combinación @c[(f 84 96)]. Antes de que el
    intérprete evalúe al operador de la combinación, se prepara para esta
    evaluación guardando los registros que contienen los operandos y el entorno,
    cuyos valores serán necesarios más tarde. El intérprete entonces evalúa al
    operador para obtener el resultado @c(val), restablece los registros
    guardados y, finalmente, mueve el resultado desde @c(val) hacia
    @c(proc). Sin embargo, en la expresión particular que estamos tratando, el
    operador es el símbolo @c(f), cuya evaluación se realiza por la operación de
    la máquina @c(lookup-variable-value), que no altera ningún registro. El
    compilador que implementamos en esta sección aprovechará este hecho y
    generará un código que evalúa al operador usando la instrucción

#     ..src > scheme
#       (assign proc
#               (op lookup-variable-value)
#               (const f)
#               (reg env))
#     < src..
    ..src > scheme
      (assign proc
              (op lookup-variable-value)
              (const f)
              (reg env))
    < src..

#     This code not only avoids the unnecessary saves and restores but also assigns
#     the value of the lookup directly to @c(proc), whereas the interpreter would
#     obtain the result in @c(val) and then move this to @c(proc).
    Este código no sólo evita las salvaguardias y restauraciones innecesarias,
    sino que también asigna directamente el valor de la búsqueda @c(proc),
    mientras que el intérprete obtendría el resultado @c(val) y luego lo movería
    a @c(proc).

#     A compiler can also optimize access to the environment. Having analyzed the
#     code, the compiler can in many cases know in which frame a particular variable
#     will be located and access that frame directly, rather than performing the
#     @c(lookup-variable-value) search. We will discuss how to implement such
#     variable access in section @l(#5.5.6). Until then, however, we will focus on the kind
#     of register and stack optimizations described above. There are many other
#     optimizations that can be performed by a compiler, such as coding primitive
#     operations @"(in line) instead of using a general @c(apply) mechanism (see
#     @l(#Exercise 5.38)); but we will not emphasize these here. Our main goal in
#     this section is to illustrate the compilation process in a simplified (but
#     still interesting) context.
    Un compilador también puede optimizar el acceso al entorno. Después de
    analizar el código, el compilador puede en muchos casos saber en qué marco
    se localizará una variable en particular y acceder a ese marco directamente,
    en lugar de realizar la @c(lookup-variable-value) búsqueda. Discutiremos
    cómo implementar tal acceso variable en la seccion @l(#5.5.6). Hasta entonces,
    sin embargo, nos centraremos en el tipo de registro y optimizaciones de pila
    descritas anteriormente. Hay muchas otras optimizaciones que pueden ser
    realizadas por un compilador, como la codificación de operaciones primitivas
    @"(en línea en) lugar de usar un @c(apply) mecanismo general (véase el
    @l(#Ejercicio 5.38) ); Pero no enfatizaremos esto
    aquí. Nuestro objetivo principal en esta sección es ilustrar el proceso de
    compilación en un contexto simplificado (pero aún interesante).

# *** 5.5.1 <> Structure of the Compiler
*** 5.5.1 <> Estructura del compilador

#     in section @l(#4.1.7) we modified our original metacircular interpreter to separate
#     analysis from execution. We analyzed each expression to produce an execution
#     procedure that took an environment as argument and performed the required
#     operations. In our compiler, we will do essentially the same analysis. Instead
#     of producing execution procedures, however, we will generate sequences of
#     instructions to be run by our register machine.
    en la seccion @l(#4.1.7) modificamos nuestro intérprete metacircular original
    para separar el análisis de la ejecución. Analizamos cada expresión para
    producir un procedimiento de ejecución que tomó un entorno como argumento y
    realizó las operaciones requeridas. En nuestro compilador, haremos
    esencialmente el mismo análisis. En lugar de producir los procedimientos de
    ejecución, sin embargo, vamos a generar secuencias de instrucciones para ser
    ejecutado por nuestra máquina de registro.

#     The procedure @c(compile) is the top-level dispatch in the compiler. It
#     corresponds to the @c(eval) procedure of section @l(#4.1.1), the @c(analyze) procedure
#     of section @l(#4.1.7), and the @c(eval-dispatch) entry point of the
#     explicit-control-evaluator in section @l(#5.4.1). The compiler, like the interpreters,
#     uses the expression-syntax procedures defined in section @l(#4.1.2).@n(320)
#     @c(Compile) performs a case analysis on the syntactic type of the expression
#     to be compiled. For each type of expression, it dispatches to a specialized
#     @e(code generator):
    El procedimiento @c(compile) es el envío de nivel superior en el
    compilador. Corresponde al procedimiento @c(eval) de la seccion @l(#4.1.1), al
    procedimiento @c(analyze) de la seccion @l(#4.1.7) y al @c(eval-dispatch) punto
    de entrada del evaluador explícito de control en la seccion @l(#5.4.1). El
    compilador, al igual que los intérpretes, utiliza los procedimientos de
    expresión y sintaxis definidos en la seccion @l(#4.1.2).@n(320)
    @c(Compile) realiza un análisis de caso sobre el tipo sintáctico de la
    expresión a compilar. Para cada tipo de expresión, envía a un @e(generador
    de código) especializado :

#     ..src > scheme
#       (define (compile exp target linkage)
#         (cond ((self-evaluating? exp)
#                (compile-self-evaluating
#                 exp target linkage))
#               ((quoted? exp)
#                (compile-quoted exp target linkage))
#               ((variable? exp)
#                (compile-variable
#                 exp target linkage))
#               ((assignment? exp)
#                (compile-assignment
#                 exp target linkage))
#               ((definition? exp)
#                (compile-definition
#                 exp target linkage))
#               ((if? exp)
#                (compile-if exp target linkage))
#               ((lambda? exp)
#                (compile-lambda exp target linkage))
#               ((begin? exp)
#                (compile-sequence
#                 (begin-actions exp) target linkage))
#               ((cond? exp)
#                (compile
#                 (cond->if exp) target linkage))
#               ((application? exp)
#                (compile-application
#                 exp target linkage))
#               (else
#                (error "Unknown expression type:
#                        COMPILE"
#                       exp))))
#     < src..
    ..src > scheme
      (define (compile exp target linkage)
        (cond ((self-evaluating? exp)
               (compile-self-evaluating
                exp target linkage))
              ((quoted? exp)
               (compile-quoted exp target linkage))
              ((variable? exp)
               (compile-variable
                exp target linkage))
              ((assignment? exp)
               (compile-assignment
                exp target linkage))
              ((definition? exp)
               (compile-definition
                exp target linkage))
              ((if? exp)
               (compile-if exp target linkage))
              ((lambda? exp)
               (compile-lambda exp target linkage))
              ((begin? exp)
               (compile-sequence
                (begin-actions exp) target linkage))
              ((cond? exp)
               (compile
                (cond->if exp) target linkage))
              ((application? exp)
               (compile-application
                exp target linkage))
              (else
               (error "Unknown expression type:
                       COMPILE"
                      exp))))
    < src..

# **** Targets and linkages
**** Objetivos y vínculos

#      @c(Compile) and the code generators that it calls take two arguments in
#      addition to the expression to compile. There is a @e(target), which specifies
#      the register in which the compiled code is to return the value of the
#      expression. There is also a @e(linkage descriptor), which describes how the
#      code resulting from the compilation of the expression should proceed when it
#      has finished its execution. The linkage descriptor can require that the code
#      do one of the following three things:
     @c(Compile) Y los generadores de código que llama toman dos argumentos
     además de la expresión a compilar. Hay un @e(destino), que especifica el
     registro en el que el código compilado es devolver el valor de la
     expresión. También hay un @e(descriptor de enlace), que describe cómo debe
     proceder el código resultante de la compilación de la expresión cuando ha
     terminado su ejecución. El descriptor de vinculación puede requerir que el
     código realice una de las siguientes tres cosas:

#      - continue at the next instruction in sequence (this is specified by the
#        linkage descriptor @c(next)),
     - Continúe en la siguiente instrucción en secuencia (esto es especificado
       por el descriptor de vinculación @c(next)),

#      - return from the procedure being compiled (this is specified by the linkage
#        descriptor @c(return)), or
     - Retorno del procedimiento que se está compilando (esto es especificado
       por el descriptor de vinculación @c(return)), o

#      - jump to a named entry point (this is specified by using the designated label
#        as the linkage descriptor).
     - Saltar a un punto de entrada con nombre (esto se especifica utilizando la
       etiqueta designada como el descriptor de vinculación).


#      For example, compiling the expression @c(5) (which is self-evaluating) with a
#      target of the @c(val) register and a linkage of @c(next) should produce the
#      instruction
     Por ejemplo, compilar la expresión @c(5)(que se autoevalúa) con un objetivo
     del @c(val) registro y un enlace de @c(next) debe producir la instrucción

#      ..src > scheme
#        (assign val (const 5))
#      < src..
     ..src > scheme
       (assign val (const 5))
     < src..

#      Compiling the same expression with a linkage of @c(return) should produce the
#      instructions
     La compilación de la misma expresión con un enlace de @c(return) debe
     producir las instrucciones

#      ..src > scheme
#        (assign val (const 5))
#        (goto (reg continue))
#      < src..
     ..src > scheme
       (assign val (const 5))
       (goto (reg continue))
     < src..

#      In the first case, execution will continue with the next instruction in the
#      sequence. In the second case, we will return from a procedure call. In both
#      cases, the value of the expression will be placed into the target @c(val)
#      register.
     En el primer caso, la ejecución continuará con la siguiente instrucción en
     la secuencia. En el segundo caso, volveremos de una llamada de
     procedimiento. En ambos casos, el valor de la expresión se colocará en el
     @c(val) registro de destino.

# **** Instruction sequences and stack usage
**** Secuencias de instrucciones y uso de pilas

#      Each code generator returns an @e(instruction sequence) containing the object
#      code it has generated for the expression. Code generation for a compound
#      expression is accomplished by combining the output from simpler code
#      generators for component expressions, just as evaluation of a compound
#      expression is accomplished by evaluating the component expressions.
     Cada generador de código devuelve una @e(secuencia de instrucciones que)
     contiene el código objeto que ha generado para la expresión. La generación
     de código para una expresión compuesta se logra combinando la salida de los
     generadores de código más simples para las expresiones de los componentes,
     así como la evaluación de una expresión compuesta se logra evaluando las
     expresiones de los componentes.

#      The simplest method for combining instruction sequences is a procedure called
#      @c(append-instruction-sequences). It takes as arguments any number of
#      instruction sequences that are to be executed sequentially; it appends them
#      and returns the combined sequence. That is, if @m[⟨seq₁⟩] and @m[⟨seq₂⟩] are
#      sequences of instructions, then evaluating
     El método más sencillo para combinar secuencias de instrucciones es un
     procedimiento llamado @c(append-instruction-sequences). Toma como
     argumentos cualquier número de secuencias de instrucciones que se van a
     ejecutar secuencialmente; Los anexa y devuelve la secuencia combinada. Es
     decir, si @m(⟨seq₁⟩) y @m(⟨seq₂⟩) son secuencias de instrucciones, entonces
     se evalúa

#      ..src > scheme
#        (append-instruction-sequences ⟨seq₁⟩ ⟨seq₂⟩)
#      < src..
     ..src > scheme
       (append-instruction-sequences ⟨seq₁⟩ ⟨seq₂⟩)
     < src..

#      produces the sequence
     Produce la secuencia

#      ..src > scheme
#        ⟨seq₁⟩
#        ⟨seq₂⟩
#      < src..
     ..src > scheme
       ⟨seq₁⟩
       ⟨seq₂⟩
     < src..

#      Whenever registers might need to be saved, the compiler's code generators use
#      @c(preserving), which is a more subtle method for combining instruction
#      sequences. @c(Preserving) takes three arguments: a set of registers and two
#      instruction sequences that are to be executed sequentially. It appends the
#      sequences in such a way that the contents of each register in the set is
#      preserved over the execution of the first sequence, if this is needed for the
#      execution of the second sequence. That is, if the first sequence modifies the
#      register and the second sequence actually needs the register's original
#      contents, then @c(preserving) wraps a @c(save) and a @c(restore) of the
#      register around the first sequence before appending the sequences.  Otherwise,
#      @c(preserving) simply returns the appended instruction sequences.  Thus, for
#      example, @c[(preserving (list ⟨reg₁⟩ ⟨reg₂⟩) ⟨seg₁⟩ ⟨seg₂⟩)] produces one of
#      the following four sequences of instructions, depending on how @m[⟨seq₁⟩] and
#      @m[⟨seq₂⟩] use @m[⟨reg₁⟩] and @m[⟨reg₂⟩]:
     Siempre que sea necesario guardar los registros, los generadores de código
     del compilador utilizan @c(preserving), que es un método más sutil para
     combinar secuencias de instrucciones. @c(Preserving) Toma tres argumentos:
     un conjunto de registros y dos secuencias de instrucciones que se van a
     ejecutar secuencialmente. Añade las secuencias de tal manera que el
     contenido de cada registro en el conjunto se conserva durante la ejecución
     de la primera secuencia, si esto es necesario para la ejecución de la
     segunda secuencia. Es decir, si la primera secuencia modifica el registro y
     la segunda secuencia realmente necesita el contenido original del registro,
     entonces @c(preserving) envuelve a @c(save) y a @c(restore) del registro
     alrededor de la primera secuencia antes de añadir las secuencias. De lo
     contrario, @c(preserving) simplemente devuelve las secuencias de
     instrucciones añadidas. Así, por ejemplo,@c[(preserving (list ⟨reg₁⟩
     ⟨reg₂⟩) ⟨seg₁⟩ ⟨seg₂⟩)]@m()@m()@m()@m()

#      ..example >
#        <seq₁> | (save <reg₁>)    | (save <reg₂>)    | (save <reg₂>)
#        <seq₂> | <seq₁>           | <seq₁>           | (save <reg₁>)
#               | (restore <reg₁>) | (restore <reg₂>) | <seq₁>
#               | <seq₂>           | <seq₂>           | (restore <reg₁>)
#               |                  |                  | (restore <reg₂>)
#               |                  |                  | <seq₂>
#      < example..
     ..example >
       <seq₁> | (save <reg₁>)    | (save <reg₂>)    | (save <reg₂>)
       <seq₂> | <seq₁>           | <seq₁>           | (save <reg₁>)
              | (restore <reg₁>) | (restore <reg₂>) | <seq₁>
              | <seq₂>           | <seq₂>           | (restore <reg₁>)
              |                  |                  | (restore <reg₂>)
              |                  |                  | <seq₂>
     < example..

#      By using @c(preserving) to combine instruction sequences the compiler avoids
#      unnecessary stack operations. This also isolates the details of whether or not
#      to generate @c(save) and @c(restore) instructions within the @c(preserving)
#      procedure, separating them from the concerns that arise in writing each of the
#      individual code generators. In fact no @c(save) or @c(restore) instructions
#      are explicitly produced by the code generators.
     Utilizando @c(preserving) para combinar secuencias de instrucciones el
     compilador evita operaciones de pila innecesarias. Esto también aísla los
     detalles de si o no para generar @c(save) y @c(restore) las instrucciones
     dentro del procedimiento @c(preserving), separándolas de las preocupaciones
     que surgen por escrito a cada uno de los generadores de código
     individuales. De hecho no, @c(save) ni las @c(restore) instrucciones son
     producidas explícitamente por los generadores de código.

#      In principle, we could represent an instruction sequence simply as a list of
#      instructions. @c(Append-instruction-sequences) could then combine instruction
#      sequences by performing an ordinary list @c(append). However, @c(preserving)
#      would then be a complex operation, because it would have to analyze each
#      instruction sequence to determine how the sequence uses its
#      registers. @c(Preserving) would be inefficient as well as complex, because it
#      would have to analyze each of its instruction sequence arguments, even though
#      these sequences might themselves have been constructed by calls to
#      @c(preserving), in which case their parts would have already been analyzed.
#      To avoid such repetitious analysis we will associate with each instruction
#      sequence some information about its register use. When we construct a basic
#      instruction sequence we will provide this information explicitly, and the
#      procedures that combine instruction sequences will derive register-use
#      information for the combined sequence from the information associated with the
#      component sequences.
     En principio, podríamos representar una secuencia de instrucciones
     simplemente como una lista de
     instrucciones. @c(Append-instruction-sequences) Podría entonces combinar
     secuencias de instrucciones realizando una lista ordinaria @c(append). Sin
     embargo, @c(preserving) sería una operación compleja, ya que tendría que
     analizar cada secuencia de instrucciones para determinar cómo la secuencia
     utiliza sus registros. @c(Preserving) Sería ineficiente y complejo, porque
     tendría que analizar cada uno de sus argumentos de secuencia de
     instrucciones, aunque estas secuencias pudieran haberse construido por
     medio de llamadas @c(preserving), en cuyo caso sus partes ya habrían sido
     analizadas. Para evitar este análisis repetitivo asociaremos con cada
     secuencia de instrucciones alguna información sobre su uso en el
     registro. Cuando construimos una secuencia de instrucciones básicas,
     proporcionaremos esta información explícitamente,

#      An instruction sequence will contain three pieces of information:
     Una secuencia de instrucciones contendrá tres partes de información:

#      - the set of registers that must be initialized before the instructions in the
#        sequence are executed (these registers are said to be @e(needed) by the
#        sequence),
     - El conjunto de registros que debe ser inicializado antes de ejecutar las
       instrucciones en la secuencia (se dice que estos registros son
       @e(necesarios) por la secuencia),

#      - the set of registers whose values are modified by the instructions in the
#        sequence, and
     - El conjunto de registros cuyos valores son modificados por las
       instrucciones de la secuencia, y

#      - the actual instructions (also called @e(statements)) in the sequence.
     - Las instrucciones reales (también llamadas @e(declaraciones) ) en la
       secuencia.


#      We will represent an instruction sequence as a list of its three parts. The
#      constructor for instruction sequences is thus
     Representaremos una secuencia de instrucciones como una lista de sus tres
     partes. El constructor de secuencias de instrucciones es

#      ..src > scheme
#        (define (make-instruction-sequence
#                 needs modifies statements)
#          (list needs modifies statements))
#      < src..
     ..src > scheme
       (define (make-instruction-sequence
                needs modifies statements)
         (list needs modifies statements))
     < src..

#      For example, the two-instruction sequence that looks up the value of the
#      variable @c(x) in the current environment, assigns the result to @c(val), and
#      then returns, requires registers @c(env) and @c(continue) to have been
#      initialized, and modifies register @c(val). This sequence would therefore be
#      constructed as
     Por ejemplo, la secuencia de dos instrucciones que busca el valor de la
     variable @c(x) en el entorno actual, asigna el resultado a @c(val), y luego
     devuelve, requiere registros @c(env) y @c(continue) se ha inicializado, y
     modifica el registro @c(val). Esta secuencia se construiría

#      ..src > scheme
#        (make-instruction-sequence
#         '(env continue)
#         '(val)
#         '((assign val
#                   (op lookup-variable-value)
#                   (const x)
#                   (reg env))
#           (goto (reg continue))))
#      < src..
     ..src > scheme
       (make-instruction-sequence
        '(env continue)
        '(val)
        '((assign val
                  (op lookup-variable-value)
                  (const x)
                  (reg env))
          (goto (reg continue))))
     < src..

#      We sometimes need to construct an instruction sequence with no statements:
     A veces necesitamos construir una secuencia de instrucciones sin
     declaraciones:

#      ..src > scheme
#        (define (empty-instruction-sequence)
#          (make-instruction-sequence '() '() '()))
#      < src..
     ..src > scheme
       (define (empty-instruction-sequence)
         (make-instruction-sequence '() '() '()))
     < src..

#      The procedures for combining instruction sequences are shown in section @l(#5.5.4).
     Los procedimientos para combinar secuencias de instrucciones se muestran en
     @l(#5.5.4).

#      :: @t(Exercise 5.31) :: In evaluating a procedure application, the
#         explicit-control evaluator always saves and restores the @c(env) register
#         around the evaluation of the operator, saves and restores @c(env) around
#         the evaluation of each operand (except the final one), saves and restores
#         @c(argl) around the evaluation of each operand, and saves and restores
#         @c(proc) around the evaluation of the operand sequence. For each of the
#         following combinations, say which of these @c(save) and @c(restore)
#         operations are superfluous and thus could be eliminated by the compiler's
#         @c(preserving) mechanism:
     :: @t(Ejercicio 5.31) :: Al evaluar una aplicación de procedimiento, el
        evaluador de control explícito siempre guarda y restaura el @c(env)
        registro alrededor de la evaluación del operador, guarda y restaura
        @c(env) alrededor de la evaluación de cada operando (excepto el último),
        guarda y restaura @c(argl) alrededor de la evaluación de cada operando,
        Y guarda y restaura @c(proc) alrededor de la evaluación de la secuencia
        de operandos. Para cada una de las siguientes combinaciones, digamos
        cuáles de éstas @c(save) y @c(restore) operaciones son superfluas y por
        lo tanto podrían ser eliminadas por el @c(preserving) mecanismo del
        compilador :

#         ..src > scheme
#           (f 'x 'y)
#           ((f) 'x 'y)
#           (f (g 'x) y)
#           (f (g 'x) 'y)
#         < src..
        ..src > scheme
          (f 'x 'y)
          ((f) 'x 'y)
          (f (g 'x) y)
          (f (g 'x) 'y)
        < src..

#      :: @t(Exercise 5.32) :: Using the @c(preserving) mechanism, the compiler will
#         avoid saving and restoring @c(env) around the evaluation of the operator of
#         a combination in the case where the operator is a symbol. We could also
#         build such optimizations into the evaluator. Indeed, the explicit-control
#         evaluator of section @l(#5.4) already performs a similar optimization, by treating
#         combinations with no operands as a special case.
     :: @t(Ejercicio 5.32) :: Utilizando el @c(preserving) mecanismo, el
        compilador evitará guardar y restaurar @c(env) alrededor de la
        evaluación del operador de una combinación en el caso en que el operador
        sea un símbolo. También podríamos construir estas optimizaciones en el
        evaluador. De hecho, el evaluador de control explícito de la seccion @l(#5.4)
        ya realiza una optimización similar, al tratar combinaciones sin
        operandos como un caso especial.

#         1. Extend the explicit-control evaluator to recognize as a separate class
#            of expressions combinations whose operator is a symbol, and to take
#            advantage of this fact in evaluating such expressions.
        1. Extender el evaluador de control explícito para reconocer como una
           clase separada de combinaciones de expresiones cuyo operador es un
           símbolo y aprovechar este hecho para evaluar dichas expresiones.

#         2. Alyssa P. Hacker suggests that by extending the evaluator to recognize
#            more and more special cases we could incorporate all the compiler's
#            optimizations, and that this would eliminate the advantage of
#            compilation altogether. What do you think of this idea?
        2. Alyssa P. Hacker sugiere que al ampliar el evaluador para reconocer
           cada vez más casos especiales, podríamos incorporar todas las
           optimizaciones del compilador, y que esto eliminaría la ventaja de la
           compilación en conjunto. ¿Qué piensas de esta idea?

# *** 5.5.2 <> Compiling Expressions
*** 5.5.2 <> Compilación de expresiones

#     In this section and the next we implement the code generators to which the
#     @c(compile) procedure dispatches.
    En esta sección y la siguiente implementamos los generadores de código a los
    que el procedimiento @c(compile) envía.

# **** Compiling linkage code
**** Compilación de código de enlace

#      In general, the output of each code generator will end with
#      instructions––generated by the procedure @c(compile-linkage)––that implement
#      the required linkage. If the linkage is @c(return) then we must generate the
#      instruction @c[(goto (reg continue))]. This needs the @c(continue) register
#      and does not modify any registers. If the linkage is @c(next), then we needn't
#      include any additional instructions. Otherwise, the linkage is a label, and we
#      generate a @c(goto) to that label, an instruction that does not need or modify
#      any registers.@n(321)
     En general, la salida de cada generador de código terminará con
     instrucciones - generadas por el procedimiento @c(compile-linkage)- que
     implementan la vinculación requerida. Si el enlace es @c(return) entonces
     debemos generar la instrucción @c[(goto (reg continue))]. Esto necesita el
     @c(continue) registro y no modifica ningún registro. Si el vínculo es
     @c(next), entonces no necesitamos incluir ninguna instrucción adicional. De
     lo contrario, la vinculación es una etiqueta, y generamos una @c(goto)
     etiqueta a esa, una instrucción que no necesita o modificar ningún
     registro.@n(321)

#      ..src > scheme
#        (define (compile-linkage linkage)
#          (cond ((eq? linkage 'return)
#                 (make-instruction-sequence
#                  '(continue)
#                  '()
#                  '((goto (reg continue)))))
#                ((eq? linkage 'next)
#                 (empty-instruction-sequence))
#                (else
#                 (make-instruction-sequence '() '()
#                  `((goto (label ,linkage)))))))
#      < src..
     ..src > scheme
       (define (compile-linkage linkage)
         (cond ((eq? linkage 'return)
                (make-instruction-sequence
                 '(continue)
                 '()
                 '((goto (reg continue)))))
               ((eq? linkage 'next)
                (empty-instruction-sequence))
               (else
                (make-instruction-sequence '() '()
                 `((goto (label ,linkage)))))))
     < src..

#      The linkage code is appended to an instruction sequence by @c(preserving) the
#      @c(continue) register, since a @c(return) linkage will require the
#      @c(continue) register: If the given instruction sequence modifies @c(continue)
#      and the linkage code needs it, @c(continue) will be saved and restored.
     El código de enlace se anexa a una secuencia de instrucciones por
     @c(preserving) el @c(continue) registro, ya que un @c(return) enlace
     requerirá el @c(continue) registro: Si la secuencia de instrucción dada
     modifica @c(continue) y el código de enlace lo necesita, @c(continue) se
     guardará y restaurará.

#      ..src > scheme
#        (define (end-with-linkage
#                 linkage instruction-sequence)
#          (preserving '(continue)
#           instruction-sequence
#           (compile-linkage linkage)))
#      < src..
     ..src > scheme
       (define (end-with-linkage
                linkage instruction-sequence)
         (preserving '(continue)
          instruction-sequence
          (compile-linkage linkage)))
     < src..

# **** Compiling simple expressions
**** Compilación de expresiones sencillas

#      The code generators for self-evaluating expressions, quotations, and variables
#      construct instruction sequences that assign the required value to the target
#      register and then proceed as specified by the linkage descriptor.
     Los generadores de código para expresiones, citas y variables de
     autoevaluación construyen secuencias de instrucciones que asignan el valor
     requerido al registro de destino y luego proceden según lo especificado por
     el descriptor de vinculación.

#      ..src > scheme
#        (define (compile-self-evaluating
#                 exp target linkage)
#          (end-with-linkage
#           linkage (make-instruction-sequence
#                    '()
#                    (list target)
#                    `((assign ,target (const ,exp))))))
#
#        (define (compile-quoted exp target linkage)
#          (end-with-linkage
#           linkage
#           (make-instruction-sequence
#            '()
#            (list target)
#            `((assign
#               ,target
#               (const ,(text-of-quotation exp)))))))
#
#        (define (compile-variable
#                 exp target linkage)
#          (end-with-linkage
#           linkage
#           (make-instruction-sequence
#            '(env)
#            (list target)
#            `((assign ,target
#                      (op lookup-variable-value)
#                      (const ,exp)
#                      (reg env))))))
#      < src..
     ..src > scheme
       (define (compile-self-evaluating
                exp target linkage)
         (end-with-linkage
          linkage (make-instruction-sequence
                   '()
                   (list target)
                   `((assign ,target (const ,exp))))))

       (define (compile-quoted exp target linkage)
         (end-with-linkage
          linkage
          (make-instruction-sequence
           '()
           (list target)
           `((assign
              ,target
              (const ,(text-of-quotation exp)))))))

       (define (compile-variable
                exp target linkage)
         (end-with-linkage
          linkage
          (make-instruction-sequence
           '(env)
           (list target)
           `((assign ,target
                     (op lookup-variable-value)
                     (const ,exp)
                     (reg env))))))
     < src..

#      All these assignment instructions modify the target register, and the one that
#      looks up a variable needs the @c(env) register.
     Todas estas instrucciones de asignación modifican el registro de destino, y
     el que busca una variable necesita el @c(env) registro.

#      Assignments and definitions are handled much as they are in the interpreter.
#      We recursively generate code that computes the value to be assigned to the
#      variable, and append to it a two-instruction sequence that actually sets or
#      defines the variable and assigns the value of the whole expression (the symbol
#      @c(ok)) to the target register. The recursive compilation has target @c(val)
#      and linkage @c(next) so that the code will put its result into @c(val) and
#      continue with the code that is appended after it. The appending is done
#      preserving @c(env), since the environment is needed for setting or defining
#      the variable and the code for the variable value could be the compilation of a
#      complex expression that might modify the registers in arbitrary ways.
     Las asignaciones y definiciones se manejan de la misma manera que lo son en
     el intérprete. Generamos recursivamente un código que calcula el valor que
     se va a asignar a la variable y le añadimos una secuencia de dos
     instrucciones que realmente establece o define la variable y asigna el
     valor de toda la expresión (el símbolo @c(ok)) al registro de destino. La
     recursiva compilación tiene destino @c(val) y vinculación @c(next) para que
     el código pondrá su resultado en @c(val) y continuar con el código que se
     anexa después de él. El agregado se realiza preservando @c(env), ya que el
     entorno es necesario para establecer o definir la variable y el código para
     el valor de la variable podría ser la compilación de una expresión compleja
     que podría modificar los registros de manera arbitraria.

#      ..src > scheme
#        (define (compile-assignment
#                 exp target linkage)
#          (let ((var (assignment-variable exp))
#                (get-value-code
#                 (compile (assignment-value exp)
#                          'val
#                          'next)))
#            (end-with-linkage
#             linkage
#             (preserving
#              '(env)
#              get-value-code
#              (make-instruction-sequence
#               '(env val)
#               (list target)
#               `((perform (op set-variable-value!)
#                          (const ,var)
#                          (reg val)
#                          (reg env))
#                 (assign ,target (const ok))))))))
#
#        (define (compile-definition
#                 exp target linkage)
#          (let ((var (definition-variable exp))
#                (get-value-code
#                 (compile (definition-value exp)
#                          'val
#                          'next)))
#            (end-with-linkage
#             linkage
#             (preserving
#              '(env)
#              get-value-code
#              (make-instruction-sequence
#               '(env val)
#               (list target)
#               `((perform (op define-variable!)
#                          (const ,var)
#                          (reg val)
#                          (reg env))
#                 (assign ,target (const ok))))))))
#      < src..
     ..src > scheme
       (define (compile-assignment
                exp target linkage)
         (let ((var (assignment-variable exp))
               (get-value-code
                (compile (assignment-value exp)
                         'val
                         'next)))
           (end-with-linkage
            linkage
            (preserving
             '(env)
             get-value-code
             (make-instruction-sequence
              '(env val)
              (list target)
              `((perform (op set-variable-value!)
                         (const ,var)
                         (reg val)
                         (reg env))
                (assign ,target (const ok))))))))

       (define (compile-definition
                exp target linkage)
         (let ((var (definition-variable exp))
               (get-value-code
                (compile (definition-value exp)
                         'val
                         'next)))
           (end-with-linkage
            linkage
            (preserving
             '(env)
             get-value-code
             (make-instruction-sequence
              '(env val)
              (list target)
              `((perform (op define-variable!)
                         (const ,var)
                         (reg val)
                         (reg env))
                (assign ,target (const ok))))))))
     < src..

#      The appended two-instruction sequence requires @c(env) and @c(val) and
#      modifies the target. Note that although we preserve @c(env) for this sequence,
#      we do not preserve @c(val), because the @c(get-value-code) is designed to
#      explicitly place its result in @c(val) for use by this sequence.  (In fact, if
#      we did preserve @c(val), we would have a bug, because this would cause the
#      previous contents of @c(val) to be restored right after the @c(get-value-code)
#      is run.)
     La secuencia de dos de instrucciones adjunto requiere @c(env) y @c(val) y
     modifica el objetivo. Tenga en cuenta que a pesar de que preservar @c(env)
     para esta secuencia, no preservar @c(val), porque @c(get-value-code) está
     diseñado para colocar explícitamente su resultado en el @c(val) uso de esta
     secuencia. (De hecho, si lo hicimos preservar @c(val), tendríamos un error,
     porque esto haría que el contenido anterior de @c(val) ser restaurado justo
     después de que @c(get-value-code) se ejecute.)

# **** Compiling conditional expressions
**** Compilación de expresiones condicionales

#      The code for an @c(if) expression compiled with a given target and linkage has
#      the form
     El código para una @c(if) expresión compilada con un objetivo y una
     vinculación dada tiene la forma

#      ..src > scheme
#        ⟨compilation of predicate,
#         target val, linkage next⟩
#         (test (op false?) (reg val))
#         (branch (label false-branch))
#        true-branch
#         ⟨compilation of consequent with given
#          target and given linkage or after-if⟩
#        false-branch
#         ⟨compilation of alternative
#          with given target and linkage⟩
#        after-if
#      < src..
     ..src > scheme
       ⟨compilation of predicate,
        target val, linkage next⟩
        (test (op false?) (reg val))
        (branch (label false-branch))
       true-branch
        ⟨compilation of consequent with given
         target and given linkage or after-if⟩
       false-branch
        ⟨compilation of alternative
         with given target and linkage⟩
       after-if
     < src..

#      To generate this code, we compile the predicate, consequent, and alternative,
#      and combine the resulting code with instructions to test the predicate result
#      and with newly generated labels to mark the true and false branches and the
#      end of the conditional.@n(322) In this arrangement of code, we must branch
#      around the true branch if the test is false. The only slight complication is
#      in how the linkage for the true branch should be handled. If the linkage for
#      the conditional is @c(return) or a label, then the true and false branches
#      will both use this same linkage.  If the linkage is @c(next), the true branch
#      ends with a jump around the code for the false branch to the label at the end
#      of the conditional.
     Para generar este código, compilamos el predicado, consecuente y
     alternativo y combinamos el código resultante con instrucciones para probar
     el resultado del predicado y con etiquetas recién generadas para marcar las
     ramas verdaderas y falsas y el final del condicional.@n(322) En esta
     disposición de código, debemos derivar alrededor de la rama verdadera si la
     prueba es falsa. La única complicación leve es en cómo se debe manejar el
     enlace para la rama verdadera. Si el enlace para el condicional es
     @c(return) o una etiqueta, entonces las ramas verdaderas y falsas usarán el
     mismo enlace. Si el enlace es @c(next), la rama verdadera termina con un
     salto alrededor del código para la rama falsa a la etiqueta al final del
     condicional.

#      ..src > scheme
#        (define (compile-if exp target linkage)
#          (let ((t-branch (make-label 'true-branch))
#                (f-branch (make-label 'false-branch))
#                (after-if (make-label 'after-if)))
#            (let ((consequent-linkage
#                   (if (eq? linkage 'next)
#                       after-if
#                       linkage)))
#              (let ((p-code
#                     (compile (if-predicate exp)
#                              'val
#                              'next))
#                    (c-code
#                     (compile (if-consequent exp)
#                              target
#                              consequent-linkage))
#                    (a-code
#                     (compile (if-alternative exp)
#                              target
#                              linkage)))
#                (preserving
#                 '(env continue)
#                 p-code
#                 (append-instruction-sequences
#                  (make-instruction-sequence
#                   '(val)
#                   '()
#                   `((test (op false?) (reg val))
#                     (branch (label ,f-branch))))
#                  (parallel-instruction-sequences
#                   (append-instruction-sequences
#                    t-branch c-code)
#                   (append-instruction-sequences
#                    f-branch a-code))
#                  after-if))))))
#      < src..
     ..src > scheme
       (define (compile-if exp target linkage)
         (let ((t-branch (make-label 'true-branch))
               (f-branch (make-label 'false-branch))
               (after-if (make-label 'after-if)))
           (let ((consequent-linkage
                  (if (eq? linkage 'next)
                      after-if
                      linkage)))
             (let ((p-code
                    (compile (if-predicate exp)
                             'val
                             'next))
                   (c-code
                    (compile (if-consequent exp)
                             target
                             consequent-linkage))
                   (a-code
                    (compile (if-alternative exp)
                             target
                             linkage)))
               (preserving
                '(env continue)
                p-code
                (append-instruction-sequences
                 (make-instruction-sequence
                  '(val)
                  '()
                  `((test (op false?) (reg val))
                    (branch (label ,f-branch))))
                 (parallel-instruction-sequences
                  (append-instruction-sequences
                   t-branch c-code)
                  (append-instruction-sequences
                   f-branch a-code))
                 after-if))))))
     < src..

#      @c(Env) is preserved around the predicate code because it could be needed by
#      the true and false branches, and @c(continue) is preserved because it could be
#      needed by the linkage code in those branches. The code for the true and false
#      branches (which are not executed sequentially) is appended using a special
#      combiner @c(parallel-instruction-sequences) described in section @l(#5.5.4).
     @c(Env) Se conserva alrededor del código predicado porque podría ser
     necesario por las ramas verdaderas y falsas, y @c(continue) se conserva
     porque podría ser necesario por el código de vinculación en esas ramas. El
     código de las ramas verdadera y falsa (que no se ejecutan secuencialmente)
     se anexa utilizando un combinador especial
     @c(parallel-instruction-sequences) descrito en la seccion @l(#5.5.4).

#      Note that @c(cond) is a derived expression, so all that the compiler needs to
#      do handle it is to apply the @c(cond->if) transformer (from @l(#4.1.2)) and
#      compile the resulting @c(if) expression.
     Tenga en cuenta que @c(cond) es una expresión derivada, por lo que todo lo
     que el compilador debe hacer manejar es aplicar el @c(cond->if)
     transformador (desde la seccion @l(#4.1.2)) y compilar la @c(if) expresión
     resultante.

# **** Compiling sequences
**** Secuencias de compilación

#      The compilation of sequences (from procedure bodies or explicit @c(begin)
#      expressions) parallels their evaluation. Each expression of the sequence is
#      compiled––the last expression with the linkage specified for the sequence, and
#      the other expressions with linkage @c(next) (to execute the rest of the
#      sequence). The instruction sequences for the individual expressions are
#      appended to form a single instruction sequence, such that @c(env) (needed for
#      the rest of the sequence) and @c(continue) (possibly needed for the linkage at
#      the end of the sequence) are preserved.
     La compilación de secuencias (de cuerpos de procedimiento o @c(begin)
     expresiones explícitas ) es paralela a su evaluación. Cada expresión de la
     secuencia se compila - la última expresión con el enlace especificado para
     la secuencia, y las otras expresiones con vinculación @c(next)(para
     ejecutar el resto de la secuencia). Las secuencias de instrucciones para
     las expresiones individuales se añaden para formar una secuencia de
     instrucciones única, de tal forma que @c(env)(necesaria para el resto de la
     secuencia) y @c(continue)(posiblemente necesaria para el enlace al final de
     la secuencia) se conservan.

#      ..src > scheme
#        (define (compile-sequence seq target linkage)
#          (if (last-exp? seq)
#              (compile (first-exp seq) target linkage)
#              (preserving '(env continue)
#               (compile (first-exp seq) target 'next)
#               (compile-sequence (rest-exps seq)
#                                 target
#                                 linkage))))
#      < src..
     ..src > scheme
       (define (compile-sequence seq target linkage)
         (if (last-exp? seq)
             (compile (first-exp seq) target linkage)
             (preserving '(env continue)
              (compile (first-exp seq) target 'next)
              (compile-sequence (rest-exps seq)
                                target
                                linkage))))
     < src..

# **** Compiling @c(lambda) expressions
**** Compilación de @c(lambda) expresiones

#      @c(Lambda) expressions construct procedures. The object code for a @c(lambda)
#      expression must have the form
     procedimiento @c(Lambda)s de construcción de expresiones. El código objeto
     de una expresión @c(lambda) debe tener el formato

#      ..src > scheme
#        ⟨construct procedure object
#         and assign it to target register⟩
#        ⟨linkage⟩
#      < src..
     ..src > scheme
       ⟨construct procedure object
        and assign it to target register⟩
       ⟨linkage⟩
     < src..

#      When we compile the @c(lambda) expression, we also generate the code for the
#      procedure body. Although the body won't be executed at the time of procedure
#      construction, it is convenient to insert it into the object code right after
#      the code for the @c(lambda). If the linkage for the @c(lambda) expression is a
#      label or @c(return), this is fine. But if the linkage is @c(next), we will
#      need to skip around the code for the procedure body by using a linkage that
#      jumps to a label that is inserted after the body. The object code thus has the
#      form
     Cuando compila la expresión @c(lambda), también generamos el código para el
     cuerpo del procedimiento. Aunque el cuerpo no se ejecutará en el momento de
     la construcción del procedimiento, es conveniente insertarlo en el código
     objeto justo después del código para el @c(lambda). Si el enlace para la
     expresión @c(lambda) es una etiqueta o @c(return), esto está bien. Pero si
     el enlace es @c(next), tendremos que saltar alrededor del código para el
     cuerpo de procedimiento mediante un enlace que salta a una etiqueta que se
     inserta después del cuerpo. El código objeto tiene así la forma

#      ..src > scheme
#        ⟨construct procedure object
#         and assign it to target register⟩
#         ⟨code for given linkage⟩ or
#          (goto (label after-lambda))
#         ⟨compilation of procedure body⟩
#        after-lambda
#      < src..
     ..src > scheme
       ⟨construct procedure object
        and assign it to target register⟩
        ⟨code for given linkage⟩ or
         (goto (label after-lambda))
        ⟨compilation of procedure body⟩
       after-lambda
     < src..

#      @c(Compile-lambda) generates the code for constructing the procedure object
#      followed by the code for the procedure body. The procedure object will be
#      constructed at run time by combining the current environment (the environment
#      at the point of definition) with the entry point to the compiled procedure
#      body (a newly generated label).@n(323)
     @c(Compile-lambda) Genera el código para construir el objeto de
     procedimiento seguido por el código para el cuerpo de procedimiento. El
     objeto de procedimiento se construirá en tiempo de ejecución combinando el
     entorno actual (el entorno en el punto de definición) con el punto de
     entrada al cuerpo de procedimiento compilado (una etiqueta generada
     recientemente).@n(323)

#      ..src > scheme
#        (define (compile-lambda exp target linkage)
#          (let ((proc-entry
#                 (make-label 'entry))
#                (after-lambda
#                 (make-label 'after-lambda)))
#            (let ((lambda-linkage
#                   (if (eq? linkage 'next)
#                       after-lambda
#                       linkage)))
#              (append-instruction-sequences
#               (tack-on-instruction-sequence
#                (end-with-linkage
#                 lambda-linkage
#                 (make-instruction-sequence
#                  '(env)
#                  (list target)
#                  `((assign
#                     ,target
#                     (op make-compiled-procedure)
#                     (label ,proc-entry)
#                     (reg env)))))
#                (compile-lambda-body exp proc-entry))
#               after-lambda))))
#      < src..
     ..src > scheme
       (define (compile-lambda exp target linkage)
         (let ((proc-entry
                (make-label 'entry))
               (after-lambda
                (make-label 'after-lambda)))
           (let ((lambda-linkage
                  (if (eq? linkage 'next)
                      after-lambda
                      linkage)))
             (append-instruction-sequences
              (tack-on-instruction-sequence
               (end-with-linkage
                lambda-linkage
                (make-instruction-sequence
                 '(env)
                 (list target)
                 `((assign
                    ,target
                    (op make-compiled-procedure)
                    (label ,proc-entry)
                    (reg env)))))
               (compile-lambda-body exp proc-entry))
              after-lambda))))
     < src..

#      @c(Compile-lambda) uses the special combiner @c(tack-on-instruction-sequence)
#      rather than @c(append-instruction-sequences) (section @l(#5.5.4)) to append the
#      procedure body to the @c(lambda) expression code, because the body is not part
#      of the sequence of instructions that will be executed when the combined
#      sequence is entered; rather, it is in the sequence only because that was a
#      convenient place to put it.
     @c(Compile-lambda) Utiliza el combinador especial en
     @c(tack-on-instruction-sequence) lugar de @c(append-instruction-sequences)(
     @l(#5.5.4)) para añadir el cuerpo del procedimiento al @c(lambda)
     código de expresión, porque el cuerpo no forma parte de la secuencia de
     instrucciones que se ejecutará cuando se introduce la secuencia combinada;
     Más bien, está en la secuencia sólo porque era un lugar conveniente para
     ponerlo.

#      @c(Compile-lambda-body) constructs the code for the body of the procedure.
#      This code begins with a label for the entry point. Next come instructions that
#      will cause the run-time evaluation environment to switch to the correct
#      environment for evaluating the procedure body––namely, the definition
#      environment of the procedure, extended to include the bindings of the formal
#      parameters to the arguments with which the procedure is called. After this
#      comes the code for the sequence of expressions that makes up the procedure
#      body. The sequence is compiled with linkage @c(return) and target @c(val) so
#      that it will end by returning from the procedure with the procedure result in
#      @c(val).
     @c(Compile-lambda-body) Construye el código para el cuerpo del
     procedimiento. Este código comienza con una etiqueta para el punto de
     entrada. A continuación vienen las instrucciones que harán que el entorno
     de evaluación de tiempo de ejecución cambie al entorno correcto para
     evaluar el cuerpo del procedimiento, es decir, el entorno de definición del
     procedimiento, extendido para incluir los enlaces de los parámetros
     formales a los argumentos con los cuales el procedimiento se llama. Después
     de esto viene el código para la secuencia de expresiones que compone el
     cuerpo del procedimiento. La secuencia se compila con la vinculación
     @c(return) y el objetivo de @c(val) modo que terminará volviendo del
     procedimiento con el resultado del procedimiento adentro @c(val).

#      ..src > scheme
#        (define (compile-lambda-body exp proc-entry)
#          (let ((formals (lambda-parameters exp)))
#            (append-instruction-sequences
#             (make-instruction-sequence
#              '(env proc argl)
#              '(env)
#              `(,proc-entry
#                (assign env
#                        (op compiled-procedure-env)
#                        (reg proc))
#                (assign env
#                        (op extend-environment)
#                        (const ,formals)
#                        (reg argl)
#                        (reg env))))
#             (compile-sequence (lambda-body exp)
#                               'val
#                               'return))))
#      < src..
     ..src > scheme
       (define (compile-lambda-body exp proc-entry)
         (let ((formals (lambda-parameters exp)))
           (append-instruction-sequences
            (make-instruction-sequence
             '(env proc argl)
             '(env)
             `(,proc-entry
               (assign env
                       (op compiled-procedure-env)
                       (reg proc))
               (assign env
                       (op extend-environment)
                       (const ,formals)
                       (reg argl)
                       (reg env))))
            (compile-sequence (lambda-body exp)
                              'val
                              'return))))
     < src..

# *** 5.5.3 <> Compiling Combinations
*** 5.5.3 <> Combinaciones de compilación

#     The essence of the compilation process is the compilation of procedure
#     applications. The code for a combination compiled with a given target and
#     linkage has the form
    La esencia del proceso de compilación es la compilación de las solicitudes
    de procedimiento. El código para una combinación compilada con un objetivo y
    enlace determinado tiene la forma

#     ..src > scheme
#       ⟨compilation of operator,
#        target proc, linkage next⟩
#       ⟨evaluate operands and construct
#        argument list in argl⟩
#       ⟨compilation of procedure call
#        with given target and linkage⟩
#     < src..
    ..src > scheme
      ⟨compilation of operator,
       target proc, linkage next⟩
      ⟨evaluate operands and construct
       argument list in argl⟩
      ⟨compilation of procedure call
       with given target and linkage⟩
    < src..

#     The registers @c(env), @c(proc), and @c(argl) may have to be saved and
#     restored during evaluation of the operator and operands. Note that this is the
#     only place in the compiler where a target other than @c(val) is specified.
    Los registros @c(env), @c(proc) y @c(argl) pueden tener que ser salvados y
    restaurados durante la evaluación del operador y operandos. Tenga en cuenta
    que este es el único lugar en el compilador donde @c(val) se especifica un
    destino distinto.

#     The required code is generated by @c(compile-application). This recursively
#     compiles the operator, to produce code that puts the procedure to be applied
#     into @c(proc), and compiles the operands, to produce code that evaluates the
#     individual operands of the application. The instruction sequences for the
#     operands are combined (by @c(construct-arglist)) with code that constructs the
#     list of arguments in @c(argl), and the resulting argument-list code is
#     combined with the procedure code and the code that performs the procedure call
#     (produced by @c(compile-procedure-call)). In appending the code sequences, the
#     @c(env) register must be preserved around the evaluation of the operator
#     (since evaluating the operator might modify @c(env), which will be needed to
#     evaluate the operands), and the @c(proc) register must be preserved around the
#     construction of the argument list (since evaluating the operands might modify
#     @c(proc), which will be needed for the actual procedure application).
#     @c(Continue) must also be preserved throughout, since it is needed for the
#     linkage in the procedure call.
    El código requerido es generado por @c(compile-application). Este
    recursivamente compila el operador, para producir el código que pone el
    procedimiento a ser aplicado en @c(proc), y compila los operandos, para
    producir el código que evalúa los operandos individuales de la
    aplicación. Las secuencias de instrucciones para los operandos se combinan
    @c(construct-arglist) con un código que construye la lista de argumentos
    @c(argl) y el código resultante de la lista de argumentos se combina con el
    código de procedimiento y el código que realiza la llamada al procedimiento
    @c(compile-procedure-call). Al adjuntar las secuencias de código, el @c(env)
    registro debe ser preservado alrededor de la evaluación del operador (ya que
    la evaluación del operador puede modificar @c(env), lo que será necesario
    para evaluar los operandos), @c(proc) Y el registro debe ser preservado
    alrededor de la construcción de la lista de argumentos (ya que la evaluación
    de los operandos podría modificar @c(proc), que será necesaria para la
    aplicación del procedimiento real). @c(Continue) También debe ser preservado
    en todo, ya que es necesario para la vinculación en la llamada de
    procedimiento.

#     ..src > scheme
#       (define (compile-application
#                exp target linkage)
#         (let ((proc-code
#                (compile (operator exp) 'proc 'next))
#               (operand-codes
#                (map (lambda (operand)
#                       (compile operand 'val 'next))
#                     (operands exp))))
#           (preserving
#            '(env continue)
#            proc-code
#            (preserving
#             '(proc continue)
#             (construct-arglist operand-codes)
#             (compile-procedure-call
#              target
#              linkage)))))
#     < src..
    ..src > scheme
      (define (compile-application
               exp target linkage)
        (let ((proc-code
               (compile (operator exp) 'proc 'next))
              (operand-codes
               (map (lambda (operand)
                      (compile operand 'val 'next))
                    (operands exp))))
          (preserving
           '(env continue)
           proc-code
           (preserving
            '(proc continue)
            (construct-arglist operand-codes)
            (compile-procedure-call
             target
             linkage)))))
    < src..

#     The code to construct the argument list will evaluate each operand into
#     @c(val) and then @c(cons) that value onto the argument list being accumulated
#     in @c(argl). Since we @c(cons) the arguments onto @c(argl) in sequence, we
#     must start with the last argument and end with the first, so that the
#     arguments will appear in order from first to last in the resulting
#     list. Rather than waste an instruction by initializing @c(argl) to the empty
#     list to set up for this sequence of evaluations, we make the first code
#     sequence construct the initial @c(argl). The general form of the argument-list
#     construction is thus as follows:
    El código para construir la lista de argumentos evaluará cada operando
    @c(val) y luego @c(cons) ese valor en la lista de argumentos que se está
    acumulando @c(argl). Puesto que @c(cons) los argumentos sobre @c(argl) en la
    secuencia, debemos comenzar con el último argumento y terminar con el
    primero, de modo que los argumentos aparecerán en orden del primero al
    último en la lista resultante. En lugar de desperdiciar una instrucción
    inicializando @c(argl) a la lista vacía para establecer esta secuencia de
    evaluaciones, hacemos que la primera secuencia de código sea la construcción
    inicial @c(argl). La forma general de la construcción de la lista de
    argumentos es así:

#     ..src > scheme
#       ⟨compilation of last operand, targeted to val⟩
#       (assign argl (op list) (reg val))
#       ⟨compilation of next operand, targeted to val⟩
#       (assign argl (op cons) (reg val) (reg argl))
#       …
#       ⟨compilation of first operand, targeted to val⟩
#       (assign argl (op cons) (reg val) (reg argl))
#     < src..
    ..src > scheme
      ⟨compilation of last operand, targeted to val⟩
      (assign argl (op list) (reg val))
      ⟨compilation of next operand, targeted to val⟩
      (assign argl (op cons) (reg val) (reg argl))
      …
      ⟨compilation of first operand, targeted to val⟩
      (assign argl (op cons) (reg val) (reg argl))
    < src..

#     @c(Argl) must be preserved around each operand evaluation except the first (so
#     that arguments accumulated so far won't be lost), and @c(env) must be
#     preserved around each operand evaluation except the last (for use by
#     subsequent operand evaluations).
    @c(Argl) Debe mantenerse alrededor de cada evaluación de operando excepto la
    primera (de modo que los argumentos acumulados hasta ahora no se perderán),
    y @c(env) debe ser preservado alrededor de cada evaluación de operando,
    excepto el último (para su uso por evaluaciones de operandos posteriores).

#     Compiling this argument code is a bit tricky, because of the special treatment
#     of the first operand to be evaluated and the need to preserve @c(argl) and
#     @c(env) in different places. The @c(construct-arglist) procedure takes as
#     arguments the code that evaluates the individual operands. If there are no
#     operands at all, it simply emits the instruction
    La compilación de este código de argumento es un poco complicado, debido al
    tratamiento especial del primer operando a ser evaluado y la necesidad de
    preservar @c(argl) y @c(env) en diferentes lugares. El procedimiento @c(construct-arglist) toma como argumentos el código que evalúa los distintos
    operandos. Si no hay ningún operando en absoluto, simplemente emite la
    instrucción

#     ..src > scheme
#       (assign argl (const ()))
#     < src..
    ..src > scheme
      (assign argl (const ()))
    < src..

#     Otherwise, @c(construct-arglist) creates code that initializes @c(argl) with
#     the last argument, and appends code that evaluates the rest of the arguments
#     and adjoins them to @c(argl) in succession. In order to process the arguments
#     from last to first, we must reverse the list of operand code sequences from
#     the order supplied by @c(compile-application).
    De lo contrario, @c(construct-arglist) crea un código que se inicializa
    @c(argl) con el último argumento y agrega el código que evalúa el resto de
    los argumentos y los limita @c(argl) sucesivamente. Para procesar los
    argumentos de último a primero, debemos invertir la lista de secuencias de
    código de operando del orden proporcionado por @c(compile-application).

#     ..src > scheme
#       (define (construct-arglist operand-codes)
#         (let ((operand-codes
#                (reverse operand-codes)))
#           (if (null? operand-codes)
#               (make-instruction-sequence
#                '()
#                '(argl)
#                '((assign argl (const ()))))
#               (let ((code-to-get-last-arg
#                      (append-instruction-sequences
#                       (car operand-codes)
#                       (make-instruction-sequence
#                        '(val)
#                        '(argl)
#                        '((assign argl
#                                  (op list)
#                                  (reg val)))))))
#                 (if (null? (cdr operand-codes))
#                     code-to-get-last-arg
#                     (preserving
#                      '(env)
#                      code-to-get-last-arg
#                      (code-to-get-rest-args
#                       (cdr operand-codes))))))))
#
#       (define (code-to-get-rest-args operand-codes)
#         (let ((code-for-next-arg
#                (preserving
#                 '(argl)
#                 (car operand-codes)
#                 (make-instruction-sequence
#                  '(val argl)
#                  '(argl)
#                  '((assign argl
#                            (op cons)
#                            (reg val)
#                            (reg argl)))))))
#           (if (null? (cdr operand-codes))
#               code-for-next-arg
#               (preserving
#                '(env)
#                code-for-next-arg
#                (code-to-get-rest-args
#                 (cdr operand-codes))))))
#     < src..
    ..src > scheme
      (define (construct-arglist operand-codes)
        (let ((operand-codes
               (reverse operand-codes)))
          (if (null? operand-codes)
              (make-instruction-sequence
               '()
               '(argl)
               '((assign argl (const ()))))
              (let ((code-to-get-last-arg
                     (append-instruction-sequences
                      (car operand-codes)
                      (make-instruction-sequence
                       '(val)
                       '(argl)
                       '((assign argl
                                 (op list)
                                 (reg val)))))))
                (if (null? (cdr operand-codes))
                    code-to-get-last-arg
                    (preserving
                     '(env)
                     code-to-get-last-arg
                     (code-to-get-rest-args
                      (cdr operand-codes))))))))

      (define (code-to-get-rest-args operand-codes)
        (let ((code-for-next-arg
               (preserving
                '(argl)
                (car operand-codes)
                (make-instruction-sequence
                 '(val argl)
                 '(argl)
                 '((assign argl
                           (op cons)
                           (reg val)
                           (reg argl)))))))
          (if (null? (cdr operand-codes))
              code-for-next-arg
              (preserving
               '(env)
               code-for-next-arg
               (code-to-get-rest-args
                (cdr operand-codes))))))
    < src..

# **** Applying procedures
**** Aplicación de procedimientos

#      After evaluating the elements of a combination, the compiled code must apply
#      the procedure in @c(proc) to the arguments in @c(argl). The code performs
#      essentially the same dispatch as the @c(apply) procedure in the metacircular
#      evaluator of section @l(#4.1.1) or the @c(apply-dispatch) entry point in the
#      explicit-control evaluator of section @l(#5.4.1). It checks whether the procedure to
#      be applied is a primitive procedure or a compiled procedure. For a primitive
#      procedure, it uses @c(apply-primitive-procedure); we will see shortly how it
#      handles compiled procedures. The procedure-application code has the following
#      form:
     Después de evaluar los elementos de una combinación, el código compilado
     debe aplicar el procedimiento en @c(proc) los argumentos en @c(argl). El
     código realiza esencialmente el mismo despacho que el procedimiento @c(apply) en el evaluador metacircular de la seccion @l(#4.1.1) o el
     @c(apply-dispatch) punto de entrada en el evaluador de control explícito de
     @l(#5.4.1). Comprueba si el procedimiento a aplicar es un
     procedimiento primitivo o un procedimiento compilado. Para un procedimiento
     primitivo, utiliza @c(apply-primitive-procedure); Veremos en breve cómo
     maneja los procedimientos compilados. El código de aplicación del
     procedimiento tiene el siguiente formato:

#      ..src > scheme
#        (test (op primitive-procedure?) (reg proc))
#         (branch (label primitive-branch))
#        compiled-branch
#         ⟨code to apply compiled procedure
#          with given target and appropriate linkage⟩
#        primitive-branch
#         (assign ⟨target⟩
#                 (op apply-primitive-procedure)
#                 (reg proc)
#                 (reg argl))
#         ⟨linkage⟩
#        after-call
#      < src..
     ..src > scheme
       (test (op primitive-procedure?) (reg proc))
        (branch (label primitive-branch))
       compiled-branch
        ⟨code to apply compiled procedure
         with given target and appropriate linkage⟩
       primitive-branch
        (assign ⟨target⟩
                (op apply-primitive-procedure)
                (reg proc)
                (reg argl))
        ⟨linkage⟩
       after-call
     < src..

#      Observe that the compiled branch must skip around the primitive branch.
#      Therefore, if the linkage for the original procedure call was @c(next), the
#      compound branch must use a linkage that jumps to a label that is inserted
#      after the primitive branch. (This is similar to the linkage used for the true
#      branch in @c(compile-if).)
     Observe que la rama compilada debe saltar alrededor de la rama
     primitiva. Por lo tanto, si el enlace para la llamada de procedimiento
     original era @c(next), la rama compuesta debe utilizar un enlace que salta
     a una etiqueta que se inserta después de la rama primitiva. (Esto es
     similar al enlace utilizado para la rama verdadera en @c(compile-if).)

#      ..src > scheme
#        (define (compile-procedure-call
#                 target linkage)
#          (let ((primitive-branch
#                 (make-label 'primitive-branch))
#                (compiled-branch
#                 (make-label 'compiled-branch))
#                (after-call
#                 (make-label 'after-call)))
#            (let ((compiled-linkage
#                   (if (eq? linkage 'next)
#                       after-call
#                       linkage)))
#              (append-instruction-sequences
#               (make-instruction-sequence
#                '(proc)
#                '()
#                `((test
#                   (op primitive-procedure?)
#                   (reg proc))
#                  (branch
#                   (label ,primitive-branch))))
#               (parallel-instruction-sequences
#                (append-instruction-sequences
#                 compiled-branch
#                 (compile-proc-appl
#                  target
#                  compiled-linkage))
#                (append-instruction-sequences
#                 primitive-branch
#                 (end-with-linkage
#                  linkage
#                  (make-instruction-sequence
#                   '(proc argl)
#                   (list target)
#                   `((assign
#                      ,target
#                      (op apply-primitive-procedure)
#                      (reg proc)
#                      (reg argl)))))))
#               after-call))))
#      < src..
     ..src > scheme
       (define (compile-procedure-call
                target linkage)
         (let ((primitive-branch
                (make-label 'primitive-branch))
               (compiled-branch
                (make-label 'compiled-branch))
               (after-call
                (make-label 'after-call)))
           (let ((compiled-linkage
                  (if (eq? linkage 'next)
                      after-call
                      linkage)))
             (append-instruction-sequences
              (make-instruction-sequence
               '(proc)
               '()
               `((test
                  (op primitive-procedure?)
                  (reg proc))
                 (branch
                  (label ,primitive-branch))))
              (parallel-instruction-sequences
               (append-instruction-sequences
                compiled-branch
                (compile-proc-appl
                 target
                 compiled-linkage))
               (append-instruction-sequences
                primitive-branch
                (end-with-linkage
                 linkage
                 (make-instruction-sequence
                  '(proc argl)
                  (list target)
                  `((assign
                     ,target
                     (op apply-primitive-procedure)
                     (reg proc)
                     (reg argl)))))))
              after-call))))
     < src..

#      The primitive and compound branches, like the true and false branches in
#      @c(compile-if), are appended using @c(parallel-instruction-sequences) rather
#      than the ordinary @c(append-instruction-sequences), because they will not be
#      executed sequentially.
     Las ramas primitivas y compuestas, como las ramas verdaderas y falsas en
     @c(compile-if), se añaden usando @c(parallel-instruction-sequences) más
     bien que el ordinario @c(append-instruction-sequences), porque no serán
     ejecutadas secuencialmente.

# **** Applying compiled procedures
**** Aplicación de procedimientos compilados

#      The code that handles procedure application is the most subtle part of the
#      compiler, even though the instruction sequences it generates are very short. A
#      compiled procedure (as constructed by @c(compile-lambda)) has an entry point,
#      which is a label that designates where the code for the procedure starts. The
#      code at this entry point computes a result in @c(val) and returns by executing
#      the instruction @c[(goto (reg continue))]. Thus, we might expect the code for
#      a compiled-procedure application (to be generated by @c(compile-proc-appl))
#      with a given target and linkage to look like this if the linkage is a label
     El código que maneja la aplicación de procedimiento es la parte más sutil
     del compilador, aunque las secuencias de instrucciones que genera son muy
     cortas. Un procedimiento compilado (como construido por @c(compile-lambda))
     tiene un punto de entrada, que es una etiqueta que designa donde se inicia
     el código para el procedimiento. El código en este punto de entrada calcula
     un resultado @c(val) y devuelve ejecutando la instrucción @c[(goto (reg
     continue))]. Por lo tanto, podríamos esperar que el código para una
     aplicación de procedimiento compilado (para ser generado por
     @c(compile-proc-appl)) con un objetivo y vinculación dada se vea así si el
     vínculo es una etiqueta

#      ..src > scheme
#        (assign continue
#                (label proc-return))
#         (assign val
#                 (op compiled-procedure-entry)
#                 (reg proc))
#         (goto (reg val))
#        proc-return
#         (assign ⟨target⟩
#                 (reg val))   ; included if target is not val
#         (goto (label ⟨linkage⟩))   ; linkage code
#      < src..
     ..src > scheme
       (assign continue
               (label proc-return))
        (assign val
                (op compiled-procedure-entry)
                (reg proc))
        (goto (reg val))
       proc-return
        (assign ⟨target⟩
                (reg val))   ; included if target is not val
        (goto (label ⟨linkage⟩))   ; linkage code
     < src..

#      or like this if the linkage is return.
     O como esto si la vinculación es el retorno.

#      ..src > scheme
#        (save continue)
#         (assign continue
#                 (label proc-return))
#         (assign val
#                 (op compiled-procedure-entry)
#                 (reg proc))
#         (goto (reg val))
#        proc-return
#         (assign ⟨target⟩
#                 (reg val))   ; included if target is not val
#         (restore continue)
#         (goto (reg continue))   ; linkage code
#      < src..
     ..src > scheme
       (save continue)
        (assign continue
                (label proc-return))
        (assign val
                (op compiled-procedure-entry)
                (reg proc))
        (goto (reg val))
       proc-return
        (assign ⟨target⟩
                (reg val))   ; included if target is not val
        (restore continue)
        (goto (reg continue))   ; linkage code
     < src..

#      This code sets up @c(continue) so that the procedure will return to a label
#      @c(proc-return) and jumps to the procedure's entry point. The code at
#      @c(proc-return) transfers the procedure's result from @c(val) to the target
#      register (if necessary) and then jumps to the location specified by the
#      linkage. (The linkage is always @c(return) or a label, because
#      @c(compile-procedure-call) replaces a @c(next) linkage for the
#      compound-procedure branch by an @c(after-call) label.)
     Este código se configura de @c(continue) modo que el procedimiento volverá
     a una etiqueta @c(proc-return) y saltará al punto de entrada del
     procedimiento. El código @c(proc-return) transfiere el resultado del
     procedimiento @c(val) al registro de destino (si es necesario) y luego
     salta a la ubicación especificada por el enlace. (El vínculo es siempre
     @c(return) o una etiqueta, porque @c(compile-procedure-call) reemplaza un
     @c(next) enlace para la rama de procedimiento compuesto por una
     @c(after-call) etiqueta.)

#      In fact, if the target is not @c(val), that is exactly the code our compiler
#      will generate.@n(324) Usually, however, the target is @c(val) (the only time
#      the compiler specifies a different register is when targeting the evaluation
#      of an operator to @c(proc)), so the procedure result is put directly into the
#      target register and there is no need to return to a special location that
#      copies it. Instead, we simplify the code by setting up @c(continue) so that
#      the procedure will @"(return) directly to the place specified by the caller's
#      linkage:
     De hecho, si el objetivo no es @c(val), ese es exactamente el código
     generador de nuestro compilador.@n(324) Normalmente, sin embargo, el
     objetivo es @c(val)(la única vez que el compilador especifica un registro
     diferente cuando se dirige la evaluación de un operador a @c(proc)), por lo
     que el resultado del procedimiento se pone directamente en el registro de
     destino y no hay necesidad de volver a un especial Ubicación que lo
     copia. En su lugar, simplificamos el código estableciéndolo @c(continue)
     para que el procedimiento @"(regrese) directamente al lugar especificado
     por el enlace de la persona que llama:

#      ..src > scheme
#        ⟨set up continue for linkage⟩
#        (assign val
#                (op compiled-procedure-entry)
#                (reg proc))
#        (goto (reg val))
#      < src..
     ..src > scheme
       ⟨set up continue for linkage⟩
       (assign val
               (op compiled-procedure-entry)
               (reg proc))
       (goto (reg val))
     < src..

#      If the linkage is a label, we set up @c(continue) so that the procedure will
#      return to that label. (That is, the @c[(goto (reg continue))] the procedure
#      ends with becomes equivalent to the @c[(goto (label ⟨linkage⟩))] at
#      @c(proc-return) above.)
     Si el enlace es una etiqueta, lo configuramos @c(continue) para que el
     procedimiento vuelva a esa etiqueta. (Es decir, el @c[(goto (reg
     continue))] procedimiento termina con vuelve equivalente a la @c[(goto
     (label ⟨linkage⟩))] de @c(proc-return) más arriba).

#      ..src > scheme
#        (assign continue
#                (label ⟨linkage⟩))
#        (assign val
#                (op compiled-procedure-entry)
#                (reg proc))
#        (goto (reg val))
#      < src..
     ..src > scheme
       (assign continue
               (label ⟨linkage⟩))
       (assign val
               (op compiled-procedure-entry)
               (reg proc))
       (goto (reg val))
     < src..

#      If the linkage is @c(return), we don't need to set up @c(continue) at all: It
#      already holds the desired location. (That is, the @c[(goto (reg continue))]
#      the procedure ends with goes directly to the place where the @c[(goto (reg
#      continue))] at @c(proc-return) would have gone.)
     Si el enlace es @c(return), no tenemos que configurar @c(continue) en
     absoluto: Ya tiene la ubicación deseada. (Es decir, el @c[(goto (reg
     continue))] procedimiento termina con va directamente al lugar donde el
     @c[(goto (reg continue))] en @c(proc-return) habría ido.)

#      ..src > scheme
#        (assign val
#                (op compiled-procedure-entry)
#                (reg proc))
#        (goto (reg val))
#      < src..
     ..src > scheme
       (assign val
               (op compiled-procedure-entry)
               (reg proc))
       (goto (reg val))
     < src..

#      With this implementation of the @c(return) linkage, the compiler generates
#      tail-recursive code. Calling a procedure as the final step in a procedure body
#      does a direct transfer, without saving any information on the stack.
     Con esta implementación del @c(return) enlace, el compilador genera código
     recursivo de cola. Llamar a un procedimiento como el paso final en un
     cuerpo de procedimiento hace una transferencia directa, sin guardar ninguna
     información en la pila.

#      Suppose instead that we had handled the case of a procedure call with a
#      linkage of @c(return) and a target of @c(val) as shown above for a non-@c(val)
#      target. This would destroy tail recursion. Our system would still give the
#      same value for any expression. But each time we called a procedure, we would
#      save @c(continue) and return after the call to undo the (useless) save.  These
#      extra saves would accumulate during a nest of procedure calls.@n(325)
     Supongamos, en cambio, que hemos manejado el caso de una llamada de
     procedimiento con un enlace @c(return) y un objetivo de @c(val) como se
     muestra arriba para un no @c(val) objetivo. Esto destruiría la recursión de
     la cola. Nuestro sistema todavía daría el mismo valor para cualquier
     expresión. Pero cada vez que llamamos a un procedimiento, nos gustaría
     guardar @c(continue) y volver después de la llamada para deshacer la
     (inútil) guardar. Estos ahorros adicionales se acumularían durante un nido
     de llamadas de procedimiento.@n(325)

#      @c(Compile-proc-appl) generates the above procedure-application code by
#      considering four cases, depending on whether the target for the call is
#      @c(val) and whether the linkage is @c(return). Observe that the instruction
#      sequences are declared to modify all the registers, since executing the
#      procedure body can change the registers in arbitrary ways.@n(326) Also note
#      that the code sequence for the case with target @c(val) and linkage @c(return)
#      is declared to need @c(continue): Even though @c(continue) is not explicitly
#      used in the two-instruction sequence, we must be sure that @c(continue) will
#      have the correct value when we enter the compiled procedure.
     @c(Compile-proc-appl) Genera el código de aplicación de procedimiento
     anterior considerando cuatro casos, dependiendo de si el objetivo de la
     llamada es @c(val) y si el enlace es @c(return). Observe que las secuencias
     de instrucción se declaran para modificar todos los registros, ya que
     ejecutar el cuerpo del procedimiento puede cambiar los registros de manera
     arbitraria.@n(326) Tenga en cuenta también que la secuencia de
     código para el caso con destino @c(val) y vinculación @c(return) se declara
     necesario @c(continue): Aunque @c(continue) no se utiliza explícitamente en
     la secuencia de dos instrucciones, debemos estar seguros de que
     @c(continue) tendrá el valor correcto cuando entramos en el procedimiento
     compilado.

#      ..src > scheme
#        (define (compile-proc-appl target linkage)
#          (cond ((and (eq? target 'val)
#                      (not (eq? linkage 'return)))
#                 (make-instruction-sequence
#                  '(proc)
#                  all-regs
#                  `((assign continue (label ,linkage))
#                    (assign
#                     val
#                     (op compiled-procedure-entry)
#                     (reg proc))
#                    (goto (reg val)))))
#                ((and (not (eq? target 'val))
#                      (not (eq? linkage 'return)))
#                 (let ((proc-return
#                        (make-label 'proc-return)))
#                   (make-instruction-sequence
#                    '(proc)
#                    all-regs
#                    `((assign continue
#                              (label ,proc-return))
#                      (assign
#                       val
#                       (op compiled-procedure-entry)
#                       (reg proc))
#                      (goto (reg val))
#                      ,proc-return
#                      (assign ,target (reg val))
#                      (goto (label ,linkage))))))
#                ((and (eq? target 'val)
#                      (eq? linkage 'return))
#                 (make-instruction-sequence
#                  '(proc continue)
#                  all-regs
#                  '((assign
#                     val
#                     (op compiled-procedure-entry)
#                     (reg proc))
#                    (goto (reg val)))))
#                ((and (not (eq? target 'val))
#                      (eq? linkage 'return))
#                 (error "return linkage,
#                         target not val: COMPILE"
#                        target))))
#      < src..
     ..src > scheme
       (define (compile-proc-appl target linkage)
         (cond ((and (eq? target 'val)
                     (not (eq? linkage 'return)))
                (make-instruction-sequence
                 '(proc)
                 all-regs
                 `((assign continue (label ,linkage))
                   (assign
                    val
                    (op compiled-procedure-entry)
                    (reg proc))
                   (goto (reg val)))))
               ((and (not (eq? target 'val))
                     (not (eq? linkage 'return)))
                (let ((proc-return
                       (make-label 'proc-return)))
                  (make-instruction-sequence
                   '(proc)
                   all-regs
                   `((assign continue
                             (label ,proc-return))
                     (assign
                      val
                      (op compiled-procedure-entry)
                      (reg proc))
                     (goto (reg val))
                     ,proc-return
                     (assign ,target (reg val))
                     (goto (label ,linkage))))))
               ((and (eq? target 'val)
                     (eq? linkage 'return))
                (make-instruction-sequence
                 '(proc continue)
                 all-regs
                 '((assign
                    val
                    (op compiled-procedure-entry)
                    (reg proc))
                   (goto (reg val)))))
               ((and (not (eq? target 'val))
                     (eq? linkage 'return))
                (error "return linkage,
                        target not val: COMPILE"
                       target))))
     < src..

# *** 5.5.4 <> Combining Instruction Sequences
*** 5.5.4 <> Combinación de Secuencias de Instrucción

#     This section describes the details on how instruction sequences are
#     represented and combined. Recall from @l(#5.5.1) that an instruction sequence
#     is represented as a list of the registers needed, the registers modified, and
#     the actual instructions. We will also consider a label (symbol) to be a
#     degenerate case of an instruction sequence, which doesn't need or modify any
#     registers.  So to determine the registers needed and modified by instruction
#     sequences we use the selectors
    Esta sección describe los detalles sobre cómo se representan y combinan las
    secuencias de instrucciones. Recuerde desde la seccion @l(#5.5.1) que una
    secuencia de instrucciones se representa como una lista de los registros
    necesarios, los registros modificados y las instrucciones reales. También
    consideraremos que una etiqueta (símbolo) es un caso degenerado de una
    secuencia de instrucciones, que no necesita ni modifica ningún registro. Así
    pues, para determinar los registros necesarios y modificados por secuencias
    de instrucciones utilizamos los selectores

#     ..src > scheme
#       (define (registers-needed s)
#         (if (symbol? s) '() (car s)))
#       (define (registers-modified s)
#         (if (symbol? s) '() (cadr s)))
#       (define (statements s)
#         (if (symbol? s) (list s) (caddr s)))
#     < src..
    ..src > scheme
      (define (registers-needed s)
        (if (symbol? s) '() (car s)))
      (define (registers-modified s)
        (if (symbol? s) '() (cadr s)))
      (define (statements s)
        (if (symbol? s) (list s) (caddr s)))
    < src..

#     and to determine whether a given sequence needs or modifies a given register
#     we use the predicates
    Y para determinar si una secuencia dada necesita o modifica un registro dado
    usamos los predicados

#     ..src > scheme
#       (define (needs-register? seq reg)
#         (memq reg (registers-needed seq)))
#       (define (modifies-register? seq reg)
#         (memq reg (registers-modified seq)))
#     < src..
    ..src > scheme
      (define (needs-register? seq reg)
        (memq reg (registers-needed seq)))
      (define (modifies-register? seq reg)
        (memq reg (registers-modified seq)))
    < src..

#     In terms of these predicates and selectors, we can implement the various
#     instruction sequence combiners used throughout the compiler.
    En términos de estos predicados y selectores, podemos implementar los
    diversos combinadores de secuencia de instrucciones utilizados en todo el
    compilador.

#     The basic combiner is @c(append-instruction-sequences). This takes as
#     arguments an arbitrary number of instruction sequences that are to be executed
#     sequentially and returns an instruction sequence whose statements are the
#     statements of all the sequences appended together. The subtle point is to
#     determine the registers that are needed and modified by the resulting
#     sequence.  It modifies those registers that are modified by any of the
#     sequences; it needs those registers that must be initialized before the first
#     sequence can be run (the registers needed by the first sequence), together
#     with those registers needed by any of the other sequences that are not
#     initialized (modified) by sequences preceding it.
    El combinador básico es @c(append-instruction-sequences). Esto toma como
    argumentos un número arbitrario de secuencias de instrucciones que se han de
    ejecutar secuencialmente y devuelve una secuencia de instrucciones cuyas
    sentencias son las sentencias de todas las secuencias adjuntas entre sí. El
    punto sutil es determinar los registros que son necesarios y modificados por
    la secuencia resultante. Modifica aquellos registros que son modificados por
    cualquiera de las secuencias; Necesita aquellos registros que deben ser
    inicializados antes de que se pueda ejecutar la primera secuencia (los
    registros necesarios para la primera secuencia), junto con aquellos
    registros necesarios para cualquiera de las otras secuencias que no son
    inicializadas (modificadas) por secuencias que la preceden.

#     The sequences are appended two at a time by @c(append-2-sequences). This takes
#     two instruction sequences @c(seq1) and @c(seq2) and returns the instruction
#     sequence whose statements are the statements of @c(seq1) followed by the
#     statements of @c(seq2), whose modified registers are those registers that are
#     modified by either @c(seq1) or @c(seq2), and whose needed registers are the
#     registers needed by @c(seq1) together with those registers needed by @c(seq2)
#     that are not modified by @c(seq1). (In terms of set operations, the new set of
#     needed registers is the union of the set of registers needed by @c(seq1) with
#     the set difference of the registers needed by @c(seq2) and the registers
#     modified by @c(seq1).)  Thus, @c(append-instruction-sequences) is implemented
#     as follows:
    Las secuencias se añaden dos a la vez por @c(append-2-sequences). Esto toma
    dos secuencias de instrucciones @c(seq1) y @c(seq2) y devuelve la secuencia
    de instrucciones cuyos estados son los estados de @c(seq1) seguidas por las
    declaraciones de @c(seq2), cuyos registros modificados son aquellos
    registros que están modificados por cualquiera de @c(seq1) o @c(seq2), y
    cuyos registros necesarios son los registros necesarios por @c(seq1) junto
    con los registros necesarios Por @c(seq2) que no se modifican por
    @c(seq1). (En términos de operaciones de conjunto, el nuevo conjunto de
    registros necesarios es la unión del conjunto de registros necesarios
    @c(seq1) con la diferencia de conjunto de los registros necesarios @c(seq2)
    y los registros modificados por @c(seq1)). Así,
    @c(append-instruction-sequences) se implementa de la siguiente manera:

#     ..src > scheme
#       (define (append-instruction-sequences . seqs)
#         (define (append-2-sequences seq1 seq2)
#           (make-instruction-sequence
#            (list-union
#             (registers-needed seq1)
#             (list-difference
#              (registers-needed seq2)
#              (registers-modified seq1)))
#            (list-union
#             (registers-modified seq1)
#             (registers-modified seq2))
#            (append (statements seq1)
#                    (statements seq2))))
#         (define (append-seq-list seqs)
#           (if (null? seqs)
#               (empty-instruction-sequence)
#               (append-2-sequences
#                (car seqs)
#                (append-seq-list (cdr seqs)))))
#         (append-seq-list seqs))
#     < src..
    ..src > scheme
      (define (append-instruction-sequences . seqs)
        (define (append-2-sequences seq1 seq2)
          (make-instruction-sequence
           (list-union
            (registers-needed seq1)
            (list-difference
             (registers-needed seq2)
             (registers-modified seq1)))
           (list-union
            (registers-modified seq1)
            (registers-modified seq2))
           (append (statements seq1)
                   (statements seq2))))
        (define (append-seq-list seqs)
          (if (null? seqs)
              (empty-instruction-sequence)
              (append-2-sequences
               (car seqs)
               (append-seq-list (cdr seqs)))))
        (append-seq-list seqs))
    < src..

#     This procedure uses some simple operations for manipulating sets represented
#     as lists, similar to the (unordered) set representation described in
#     @l(#2.3.3):
    Este procedimiento utiliza algunas operaciones simples para manipular
    conjuntos representados como listas, similar a la representación de conjunto
    (no ordenada) descrita en la seccion @l(#2.3.3) :

#     ..src > scheme
#       (define (list-union s1 s2)
#         (cond ((null? s1) s2)
#               ((memq (car s1) s2)
#                (list-union (cdr s1) s2))
#               (else
#                (cons (car s1)
#                      (list-union (cdr s1) s2)))))
#
#       (define (list-difference s1 s2)
#         (cond ((null? s1) '())
#               ((memq (car s1) s2)
#                (list-difference (cdr s1) s2))
#               (else
#                (cons (car s1)
#                      (list-difference (cdr s1)
#                                       s2)))))
#     < src..
    ..src > scheme
      (define (list-union s1 s2)
        (cond ((null? s1) s2)
              ((memq (car s1) s2)
               (list-union (cdr s1) s2))
              (else
               (cons (car s1)
                     (list-union (cdr s1) s2)))))

      (define (list-difference s1 s2)
        (cond ((null? s1) '())
              ((memq (car s1) s2)
               (list-difference (cdr s1) s2))
              (else
               (cons (car s1)
                     (list-difference (cdr s1)
                                      s2)))))
    < src..

#     @c(Preserving), the second major instruction sequence combiner, takes a list
#     of registers @c(regs) and two instruction sequences @c(seq1) and @c(seq2) that
#     are to be executed sequentially. It returns an instruction sequence whose
#     statements are the statements of @c(seq1) followed by the statements of
#     @c(seq2), with appropriate @c(save) and @c(restore) instructions around
#     @c(seq1) to protect the registers in @c(regs) that are modified by @c(seq1)
#     but needed by @c(seq2). To accomplish this, @c(preserving) first creates a
#     sequence that has the required @c(save)s followed by the statements of
#     @c(seq1) followed by the required @c(restore)s. This sequence needs the
#     registers being saved and restored in addition to the registers needed by
#     @c(seq1), and modifies the registers modified by @c(seq1) except for the ones
#     being saved and restored. This augmented sequence and @c(seq2) are then
#     appended in the usual way. The following procedure implements this strategy
#     recursively, walking down the list of registers to be preserved:@n(327)
    @c(Preserving), El segundo combinador de secuencias de instrucción
    principal, toma una lista de registros @c(regs) y dos secuencias de
    instrucciones @c(seq1) y @c(seq2) que se han de ejecutar
    secuencialmente. Devuelve una secuencia de instrucciones cuyas sentencias
    son las declaraciones de @c(seq1) seguido por las sentencias de @c(seq2),
    con las instrucciones apropiadas @c(save) y @c(restore) alrededor @c(seq1)
    para proteger los registros en @c(regs) que son modificados por @c(seq1)
    pero necesarios @c(seq2). Para lograr esto, @c(preserving) primero crea una
    secuencia que tiene los @c(save) s requeridos seguidos por las declaraciones
    de @c(seq1) seguido por la @c(restore) s requerida. Esta secuencia requiere
    que los registros sean guardados y restaurados además de los registros
    necesarios @c(seq1), @c(seq1) Y modifica los registros modificados excepto
    por los que se guardan y restauran. Esta secuencia aumentada y @c(seq2)
    luego se añaden de la manera habitual. El siguiente procedimiento implementa
    esta estrategia de forma recursiva, recorriendo la lista de registros a
    preservar:@n(327)

#     ..src > scheme
#       (define (preserving regs seq1 seq2)
#         (if (null? regs)
#             (append-instruction-sequences seq1 seq2)
#             (let ((first-reg (car regs)))
#               (if (and
#                    (needs-register? seq2 first-reg)
#                    (modifies-register? seq1
#                                        first-reg))
#                   (preserving
#                    (cdr regs)
#                    (make-instruction-sequence
#                     (list-union
#                      (list first-reg)
#                      (registers-needed seq1))
#                     (list-difference
#                      (registers-modified seq1)
#                      (list first-reg))
#                     (append `((save ,first-reg))
#                             (statements seq1)
#                             `((restore ,first-reg))))
#                    seq2)
#                   (preserving
#                    (cdr regs)
#                    seq1
#                    seq2)))))
#     < src..
    ..src > scheme
      (define (preserving regs seq1 seq2)
        (if (null? regs)
            (append-instruction-sequences seq1 seq2)
            (let ((first-reg (car regs)))
              (if (and
                   (needs-register? seq2 first-reg)
                   (modifies-register? seq1
                                       first-reg))
                  (preserving
                   (cdr regs)
                   (make-instruction-sequence
                    (list-union
                     (list first-reg)
                     (registers-needed seq1))
                    (list-difference
                     (registers-modified seq1)
                     (list first-reg))
                    (append `((save ,first-reg))
                            (statements seq1)
                            `((restore ,first-reg))))
                   seq2)
                  (preserving
                   (cdr regs)
                   seq1
                   seq2)))))
    < src..

#     Another sequence combiner, @c(tack-on-instruction-sequence), is used by
#     @c(compile-lambda) to append a procedure body to another sequence. Because the
#     procedure body is not @"(in line) to be executed as part of the combined
#     sequence, its register use has no impact on the register use of the sequence
#     in which it is embedded. We thus ignore the procedure body's sets of needed
#     and modified registers when we tack it onto the other sequence.
    Otro combinador de secuencias,, @c(tack-on-instruction-sequence) se utiliza
    @c(compile-lambda) para añadir un cuerpo de procedimiento a otra
    secuencia. Debido a que el cuerpo del procedimiento no está @"(alineado)
    para ser ejecutado como parte de la secuencia combinada, su uso de registro
    no tiene impacto en el uso de registro de la secuencia en la que está
    incrustado. De este modo ignoramos los conjuntos del cuerpo del
    procedimiento de los registros necesarios y modificados cuando lo pegamos en
    la otra secuencia.

#     ..src > scheme
#       (define (tack-on-instruction-sequence
#                seq body-seq)
#         (make-instruction-sequence
#          (registers-needed seq)
#          (registers-modified seq)
#          (append (statements seq)
#                  (statements body-seq))))
#     < src..
    ..src > scheme
      (define (tack-on-instruction-sequence
               seq body-seq)
        (make-instruction-sequence
         (registers-needed seq)
         (registers-modified seq)
         (append (statements seq)
                 (statements body-seq))))
    < src..

#     @c(Compile-if) and @c(compile-procedure-call) use a special combiner called
#     @c(parallel-instruction-sequences) to append the two alternative branches that
#     follow a test. The two branches will never be executed sequentially; for any
#     particular evaluation of the test, one branch or the other will be
#     entered. Because of this, the registers needed by the second branch are still
#     needed by the combined sequence, even if these are modified by the first
#     branch.
    @c(Compile-if) Y @c(compile-procedure-call) utilizar un combinador especial
    llamado @c(parallel-instruction-sequences) para añadir las dos ramas
    alternativas que siguen una prueba. Las dos ramas nunca se ejecutarán
    secuencialmente; Para cualquier evaluación particular de la prueba, se
    ingresará una rama o la otra. Debido a esto, los registros necesarios para
    la segunda rama son todavía necesarios por la secuencia combinada, incluso
    si éstos son modificados por la primera rama.

#     ..src > scheme
#       (define (parallel-instruction-sequences
#                seq1 seq2)
#         (make-instruction-sequence
#          (list-union (registers-needed seq1)
#                      (registers-needed seq2))
#          (list-union (registers-modified seq1)
#                      (registers-modified seq2))
#          (append (statements seq1)
#                  (statements seq2))))
#     < src..
    ..src > scheme
      (define (parallel-instruction-sequences
               seq1 seq2)
        (make-instruction-sequence
         (list-union (registers-needed seq1)
                     (registers-needed seq2))
         (list-union (registers-modified seq1)
                     (registers-modified seq2))
         (append (statements seq1)
                 (statements seq2))))
    < src..

# *** 5.5.5 <> An Example of Compiled Code
*** 5.5.5 <> Ejemplo de código compilado

#     Now that we have seen all the elements of the compiler, let us examine an
#     example of compiled code to see how things fit together. We will compile the
#     definition of a recursive @c(factorial) procedure by calling @c(compile):
    Ahora que hemos visto todos los elementos del compilador, examinemos un
    ejemplo de código compilado para ver cómo encajan las cosas. Vamos a
    compilar la definición de un procedimiento @c(factorial) recursivo llamando
    a @c(compile):

#     ..src > scheme
#       (compile
#        '(define (factorial n)
#           (if (= n 1)
#               1
#               (* (factorial (- n 1)) n)))
#        'val
#        'next)
#     < src..
    ..src > scheme
      (compile
       '(define (factorial n)
          (if (= n 1)
              1
              (* (factorial (- n 1)) n)))
       'val
       'next)
    < src..

#     We have specified that the value of the @c(define) expression should be placed
#     in the @c(val) register. We don't care what the compiled code does after
#     executing the @c(define), so our choice of @c(next) as the linkage descriptor
#     is arbitrary.
    Hemos especificado que el valor de la @c(define) expresión debe ser colocado
    en el @c(val) registro. No nos importa lo que hace el código compilado
    después de ejecutar el @c(define), por lo que nuestra elección de @c(next)
    como el descriptor de vinculación es arbitraria.

#     @c(Compile) determines that the expression is a definition, so it calls
#     @c(compile-definition) to compile code to compute the value to be assigned
#     (targeted to @c(val)), followed by code to install the definition, followed by
#     code to put the value of the @c(define) (which is the symbol @c(ok)) into the
#     target register, followed finally by the linkage code. @c(Env) is preserved
#     around the computation of the value, because it is needed in order to install
#     the definition. Because the linkage is @c(next), there is no linkage code in
#     this case. The skeleton of the compiled code is thus
    @c(Compile) Determina que la expresión es una definición, por lo que llama
    @c(compile-definition) a compilar código para calcular el valor a asignar
    (dirigido a @c(val)), seguido de código para instalar la definición, seguido
    de código para poner el valor de @c(define)(que es el símbolo @c(ok)) en El
    registro de destino, seguido finalmente por el código de enlace. @c(Env) Se
    conserva alrededor del cálculo del valor, porque se necesita para instalar
    la definición. Debido a que el enlace es @c(next), no hay ningún código de
    vinculación en este caso. El esqueleto del código compilado es así

#     ..src > scheme
#       ⟨save env if modified by code to compute value⟩
#         ⟨compilation of definition value,
#          target val, linkage next⟩
#         ⟨restore env if saved above⟩
#         (perform (op define-variable!)
#                  (const factorial)
#                  (reg val)
#                  (reg env))
#         (assign val (const ok))
#     < src..
    ..src > scheme
      ⟨save env if modified by code to compute value⟩
        ⟨compilation of definition value,
         target val, linkage next⟩
        ⟨restore env if saved above⟩
        (perform (op define-variable!)
                 (const factorial)
                 (reg val)
                 (reg env))
        (assign val (const ok))
    < src..

#     The expression that is to be compiled to produce the value for the variable
#     @c(factorial) is a @c(lambda) expression whose value is the procedure that
#     computes factorials. @c(Compile) handles this by calling @c(compile-lambda),
#     which compiles the procedure body, labels it as a new entry point, and
#     generates the instruction that will combine the procedure body at the new
#     entry point with the run-time environment and assign the result to
#     @c(val). The sequence then skips around the compiled procedure code, which is
#     inserted at this point. The procedure code itself begins by extending the
#     procedure's definition environment by a frame that binds the formal parameter
#     @c(n) to the procedure argument. Then comes the actual procedure body.  Since
#     this code for the value of the variable doesn't modify the @c(env) register,
#     the optional @c(save) and @c(restore) shown above aren't generated. (The
#     procedure code at @c(entry2) isn't executed at this point, so its use of
#     @c(env) is irrelevant.)  Therefore, the skeleton for the compiled code becomes
    La expresión que se va a compilar para producir el valor de la variable
    @c(factorial) es una expresión @c(lambda) cuyo valor es el procedimiento que
    calcula factorials. @c(Compile) Maneja esto llamando @c(compile-lambda), que
    compila el cuerpo del procedimiento, lo etiqueta como un nuevo punto de
    entrada y genera la instrucción que combinará el cuerpo del procedimiento en
    el nuevo punto de entrada con el entorno de ejecución y asignará el
    resultado a @c(val). La secuencia luego se salta alrededor del código de
    procedimiento compilado, que se inserta en este punto. El propio código de
    procedimiento comienza extendiendo el entorno de definición del
    procedimiento mediante un marco que une el parámetro formal @c(n) al
    argumento del procedimiento. Luego viene el cuerpo del procedimiento
    real. Puesto que este código para el valor de la variable no modifica el
    @c(env) registro, @c(save) Los opcionales y @c(restore) mostrados arriba no
    se generan. (El código de procedimiento en @c(entry2) no se ejecuta en este
    punto, por lo que su uso de @c(env) es irrelevante). Por lo tanto, el
    esqueleto para el código compilado se convierte en

#     ..src > scheme
#         (assign val (op make-compiled-procedure)
#                     (label entry2)
#                     (reg env))
#         (goto (label after-lambda1))
#       entry2
#         (assign env (op compiled-procedure-env)
#                     (reg proc))
#         (assign env (op extend-environment)
#                     (const (n))
#                     (reg argl)
#                     (reg env))
#         ⟨compilation of procedure body⟩
#       after-lambda1
#         (perform (op define-variable!)
#                  (const factorial)
#                  (reg val) (reg env))
#         (assign val (const ok))
#     < src..
    ..src > scheme
        (assign val (op make-compiled-procedure)
                    (label entry2)
                    (reg env))
        (goto (label after-lambda1))
      entry2
        (assign env (op compiled-procedure-env)
                    (reg proc))
        (assign env (op extend-environment)
                    (const (n))
                    (reg argl)
                    (reg env))
        ⟨compilation of procedure body⟩
      after-lambda1
        (perform (op define-variable!)
                 (const factorial)
                 (reg val) (reg env))
        (assign val (const ok))
    < src..

#     A procedure body is always compiled (by @c(compile-lambda-body)) as a sequence
#     with target @c(val) and linkage @c(return). The sequence in this case consists
#     of a single @c(if) expression:
    Un cuerpo de procedimiento siempre se compila (por @c(compile-lambda-body))
    como una secuencia con destino @c(val) y vinculación @c(return). La
    secuencia en este caso consiste en una sola @c(if) expresión:

#     ..src > scheme
#       (if (= n 1)
#           1
#           (* (factorial (- n 1)) n))
#     < src..
    ..src > scheme
      (if (= n 1)
          1
          (* (factorial (- n 1)) n))
    < src..

#     @c(Compile-if) generates code that first computes the predicate (targeted to
#     @c(val)), then checks the result and branches around the true branch if the
#     predicate is false. @c(Env) and @c(continue) are preserved around the
#     predicate code, since they may be needed for the rest of the @c(if)
#     expression. Since the @c(if) expression is the final expression (and only
#     expression) in the sequence making up the procedure body, its target is
#     @c(val) and its linkage is @c(return), so the true and false branches are both
#     compiled with target @c(val) and linkage @c(return). (That is, the value of
#     the conditional, which is the value computed by either of its branches, is the
#     value of the procedure.)
    @c(Compile-if) Genera un código que primero calcula el predicado (dirigido a
    @c(val)), luego comprueba el resultado y las ramas alrededor de la rama
    verdadera si el predicado es falso. @c(Env) Y @c(continue) se conservan
    alrededor del código predicado, ya que pueden ser necesarios para el resto
    de la @c(if) expresión. Dado que la @c(if) expresión es la expresión final
    (y sólo expresión) en la secuencia que compone el cuerpo del procedimiento,
    su objetivo es @c(val) y su vinculación es @c(return), por lo que las ramas
    verdadera y falsa se compilan con el objetivo @c(val) y la vinculación
    @c(return). (Es decir, el valor del condicional, que es el valor calculado
    por cualquiera de sus ramas, es el valor del procedimiento.)

#     ..src > scheme
#       ⟨save continue, env if modified by
#        predicate and needed by branches⟩
#         ⟨compilation of predicate,
#          target val, linkage next⟩
#         ⟨restore continue, env if saved above⟩
#         (test (op false?) (reg val))
#         (branch (label false-branch4))
#       true-branch5
#         ⟨compilation of true branch,
#          target val, linkage return⟩
#       false-branch4
#         ⟨compilation of false branch,
#          target val, linkage return⟩
#       after-if3
#     < src..
    ..src > scheme
      ⟨save continue, env if modified by
       predicate and needed by branches⟩
        ⟨compilation of predicate,
         target val, linkage next⟩
        ⟨restore continue, env if saved above⟩
        (test (op false?) (reg val))
        (branch (label false-branch4))
      true-branch5
        ⟨compilation of true branch,
         target val, linkage return⟩
      false-branch4
        ⟨compilation of false branch,
         target val, linkage return⟩
      after-if3
    < src..

#     The predicate @c[(= n 1)] is a procedure call. This looks up the operator (the
#     symbol @c(=)) and places this value in @c(proc). It then assembles the
#     arguments @c(1) and the value of @c(n) into @c(argl). Then it tests whether
#     @c(proc) contains a primitive or a compound procedure, and dispatches to a
#     primitive branch or a compound branch accordingly. Both branches resume at the
#     @c(after-call) label. The requirements to preserve registers around the
#     evaluation of the operator and operands don't result in any saving of
#     registers, because in this case those evaluations don't modify the registers
#     in question.
    El predicado @c[(= n 1)] es una llamada de procedimiento. Esto busca el
    operador (el símbolo @c(=)) y coloca este valor en @c(proc). A continuación,
    reúne los argumentos @c(1) y el valor de @c(n) en @c(argl). Luego prueba si
    @c(proc) contiene un procedimiento primitivo o compuesto, y despacha a una
    rama primitiva o una rama compuesta de acuerdo con ello. Ambas ramas se
    reanudan en la @c(after-call) etiqueta. Los requisitos para preservar los
    registros alrededor de la evaluación del operador y los operandos no dan
    lugar a ningún ahorro de registros, porque en este caso esas evaluaciones no
    modifican los registros en cuestión.

#     ..src > scheme
#         (assign proc (op lookup-variable-value)
#                      (const =)
#                      (reg env))
#         (assign val (const 1))
#         (assign argl (op list) (reg val))
#         (assign val (op lookup-variable-value)
#                     (const n)
#                     (reg env))
#         (assign argl (op cons) (reg val) (reg argl))
#         (test (op primitive-procedure?) (reg proc))
#         (branch (label primitive-branch17))
#       compiled-branch16
#         (assign continue (label after-call15))
#         (assign val (op compiled-procedure-entry)
#                     (reg proc))
#         (goto (reg val))
#       primitive-branch17
#         (assign val (op apply-primitive-procedure)
#                     (reg proc)
#                     (reg argl))
#       after-call15
#     < src..
    ..src > scheme
        (assign proc (op lookup-variable-value)
                     (const =)
                     (reg env))
        (assign val (const 1))
        (assign argl (op list) (reg val))
        (assign val (op lookup-variable-value)
                    (const n)
                    (reg env))
        (assign argl (op cons) (reg val) (reg argl))
        (test (op primitive-procedure?) (reg proc))
        (branch (label primitive-branch17))
      compiled-branch16
        (assign continue (label after-call15))
        (assign val (op compiled-procedure-entry)
                    (reg proc))
        (goto (reg val))
      primitive-branch17
        (assign val (op apply-primitive-procedure)
                    (reg proc)
                    (reg argl))
      after-call15
    < src..

#     The true branch, which is the constant 1, compiles (with target @c(val) and
#     linkage @c(return)) to
    La rama verdadera, que es la constante 1, compila (con el objetivo @c(val) y
    la vinculación @c(return)) a

#     ..src > scheme
#       (assign val (const 1))
#       (goto (reg continue))
#     < src..
    ..src > scheme
      (assign val (const 1))
      (goto (reg continue))
    < src..

#     The code for the false branch is another procedure call, where the procedure
#     is the value of the symbol @c(*), and the arguments are @c(n) and the result
#     of another procedure call (a call to @c(factorial)). Each of these calls sets
#     up @c(proc) and @c(argl) and its own primitive and compound
#     branches. @l(#Figure 5.17) shows the complete compilation of the definition of
#     the @c(factorial) procedure. Notice that the possible @c(save) and @c(restore)
#     of @c(continue) and @c(env) around the predicate, shown above, are in fact
#     generated, because these registers are modified by the procedure call in the
#     predicate and needed for the procedure call and the @c(return) linkage in the
#     branches.
    El código para la rama falsa es otra llamada de procedimiento, donde el
    procedimiento es el valor del símbolo @c(*), y los argumentos son @c(n) y el
    resultado de otra llamada de procedimiento (una llamada a
    @c(factorial)). Cada una de estas llamadas pone en marcha @c(proc) y
    @c(argl) ya sus propias ramas primitivas y compuestas. @l(#Figura 5.17) muestra la compilación completa de la definición del
    procedimiento @c(factorial). Obsérvese que los posibles @c(save) y
    @c(restore) de @c(continue) y @c(env) alrededor del predicado, mostrados
    anteriormente, son de hecho generados, porque estos registros son
    modificados por la llamada de procedimiento en el predicado y necesarios
    para la llamada a procedimiento y la @c(return) vinculación en las ramas.

#     ..figure > @t(Figure 5.17) Compilation of the definition of the @c(factorial)
#       procedure.
    ..figure > @t(Figura 5.17) Recopilación de la definición del procedimiento @c(factorial).

#       ..src > scheme
#         ;; construct the procedure and skip over code
#         ;; for the procedure body
#           (assign val
#                   (op make-compiled-procedure)
#                   (label entry2)
#                   (reg env))
#           (goto (label after-lambda1))
#         entry2     ; calls to factorial will enter here
#           (assign env
#                   (op compiled-procedure-env)
#                   (reg proc))
#           (assign env
#                   (op extend-environment)
#                   (const (n))
#                   (reg argl)
#                   (reg env))
#         ;; begin actual procedure body
#           (save continue)
#           (save env)
#         ;; compute (= n 1)
#           (assign proc
#                   (op lookup-variable-value)
#                   (const =)
#                   (reg env))
#           (assign val (const 1))
#           (assign argl (op list) (reg val))
#           (assign val
#                   (op lookup-variable-value)
#                   (const n)
#                   (reg env))
#           (assign argl (op cons) (reg val) (reg argl))
#           (test (op primitive-procedure?) (reg proc))
#           (branch (label primitive-branch17))
#         compiled-branch16
#           (assign continue (label after-call15))
#           (assign val
#                   (op compiled-procedure-entry)
#                   (reg proc))
#           (goto (reg val))
#         primitive-branch17
#           (assign val
#                   (op apply-primitive-procedure)
#                   (reg proc)
#                   (reg argl))
#         after-call15   ; val now contains result of (= n 1)
#           (restore env)
#           (restore continue)
#           (test (op false?) (reg val))
#           (branch (label false-branch4))
#         true-branch5  ; return 1
#           (assign val (const 1))
#           (goto (reg continue))
#
#         false-branch4
#         ;; compute and return (* (factorial (- n 1)) n)
#           (assign proc
#                   (op lookup-variable-value)
#                   (const *)
#                   (reg env))
#           (save continue)
#           (save proc)   ; save * procedure
#           (assign val
#                   (op lookup-variable-value)
#                   (const n)
#                   (reg env))
#           (assign argl (op list) (reg val))
#           (save argl)   ; save partial argument list for *
#         ;; compute (factorial (- n 1)),
#         ;; which is the other argument for *
#           (assign proc
#                   (op lookup-variable-value)
#                   (const factorial)
#                   (reg env))
#           (save proc)  ; save factorial procedure
#         ;; compute (- n 1), which is the argument for factorial
#           (assign proc
#                   (op lookup-variable-value)
#                   (const -)
#                   (reg env))
#           (assign val (const 1))
#           (assign argl (op list) (reg val))
#           (assign val
#                   (op lookup-variable-value)
#                   (const n)
#                   (reg env))
#           (assign argl (op cons) (reg val) (reg argl))
#           (test (op primitive-procedure?) (reg proc))
#           (branch (label primitive-branch8))
#         compiled-branch7
#           (assign continue (label after-call6))
#           (assign val
#                   (op compiled-procedure-entry)
#                   (reg proc))
#           (goto (reg val))
#         primitive-branch8
#           (assign val
#                   (op apply-primitive-procedure)
#                   (reg proc)
#                   (reg argl))
#
#         after-call6   ; val now contains result of (- n 1)
#           (assign argl (op list) (reg val))
#           (restore proc) ; restore factorial
#         ;; apply factorial
#           (test (op primitive-procedure?) (reg proc))
#           (branch (label primitive-branch11))
#         compiled-branch10
#           (assign continue (label after-call9))
#           (assign val
#                   (op compiled-procedure-entry)
#                   (reg proc))
#           (goto (reg val))
#         primitive-branch11
#           (assign val
#                   (op apply-primitive-procedure)
#                   (reg proc)
#                   (reg argl))
#         after-call9      ; val now contains result
#                          ; of (factorial (- n 1))
#           (restore argl) ; restore partial argument list for *
#           (assign argl (op cons) (reg val) (reg argl))
#           (restore proc) ; restore *
#           (restore continue)
#         ;; apply * and return its value
#           (test (op primitive-procedure?) (reg proc))
#           (branch (label primitive-branch14))
#         compiled-branch13
#         ;; note that a compound procedure here
#         ;; is called tail-recursively
#           (assign val
#                   (op compiled-procedure-entry)
#                   (reg proc))
#           (goto (reg val))
#         primitive-branch14
#           (assign val
#                   (op apply-primitive-procedure)
#                   (reg proc)
#                   (reg argl))
#           (goto (reg continue))
#         after-call12
#         after-if3
#         after-lambda1
#         ;; assign the procedure to the variable factorial
#           (perform (op define-variable!)
#                    (const factorial)
#                    (reg val)
#                    (reg env))
#           (assign val (const ok))
#       < src..
      ..src > scheme
        ;; construct the procedure and skip over code
        ;; for the procedure body
          (assign val
                  (op make-compiled-procedure)
                  (label entry2)
                  (reg env))
          (goto (label after-lambda1))
        entry2     ; calls to factorial will enter here
          (assign env
                  (op compiled-procedure-env)
                  (reg proc))
          (assign env
                  (op extend-environment)
                  (const (n))
                  (reg argl)
                  (reg env))
        ;; begin actual procedure body
          (save continue)
          (save env)
        ;; compute (= n 1)
          (assign proc
                  (op lookup-variable-value)
                  (const =)
                  (reg env))
          (assign val (const 1))
          (assign argl (op list) (reg val))
          (assign val
                  (op lookup-variable-value)
                  (const n)
                  (reg env))
          (assign argl (op cons) (reg val) (reg argl))
          (test (op primitive-procedure?) (reg proc))
          (branch (label primitive-branch17))
        compiled-branch16
          (assign continue (label after-call15))
          (assign val
                  (op compiled-procedure-entry)
                  (reg proc))
          (goto (reg val))
        primitive-branch17
          (assign val
                  (op apply-primitive-procedure)
                  (reg proc)
                  (reg argl))
        after-call15   ; val now contains result of (= n 1)
          (restore env)
          (restore continue)
          (test (op false?) (reg val))
          (branch (label false-branch4))
        true-branch5  ; return 1
          (assign val (const 1))
          (goto (reg continue))

        false-branch4
        ;; compute and return (* (factorial (- n 1)) n)
          (assign proc
                  (op lookup-variable-value)
                  (const *)
                  (reg env))
          (save continue)
          (save proc)   ; save * procedure
          (assign val
                  (op lookup-variable-value)
                  (const n)
                  (reg env))
          (assign argl (op list) (reg val))
          (save argl)   ; save partial argument list for *
        ;; compute (factorial (- n 1)),
        ;; which is the other argument for *
          (assign proc
                  (op lookup-variable-value)
                  (const factorial)
                  (reg env))
          (save proc)  ; save factorial procedure
        ;; compute (- n 1), which is the argument for factorial
          (assign proc
                  (op lookup-variable-value)
                  (const -)
                  (reg env))
          (assign val (const 1))
          (assign argl (op list) (reg val))
          (assign val
                  (op lookup-variable-value)
                  (const n)
                  (reg env))
          (assign argl (op cons) (reg val) (reg argl))
          (test (op primitive-procedure?) (reg proc))
          (branch (label primitive-branch8))
        compiled-branch7
          (assign continue (label after-call6))
          (assign val
                  (op compiled-procedure-entry)
                  (reg proc))
          (goto (reg val))
        primitive-branch8
          (assign val
                  (op apply-primitive-procedure)
                  (reg proc)
                  (reg argl))

        after-call6   ; val now contains result of (- n 1)
          (assign argl (op list) (reg val))
          (restore proc) ; restore factorial
        ;; apply factorial
          (test (op primitive-procedure?) (reg proc))
          (branch (label primitive-branch11))
        compiled-branch10
          (assign continue (label after-call9))
          (assign val
                  (op compiled-procedure-entry)
                  (reg proc))
          (goto (reg val))
        primitive-branch11
          (assign val
                  (op apply-primitive-procedure)
                  (reg proc)
                  (reg argl))
        after-call9      ; val now contains result
                         ; of (factorial (- n 1))
          (restore argl) ; restore partial argument list for *
          (assign argl (op cons) (reg val) (reg argl))
          (restore proc) ; restore *
          (restore continue)
        ;; apply * and return its value
          (test (op primitive-procedure?) (reg proc))
          (branch (label primitive-branch14))
        compiled-branch13
        ;; note that a compound procedure here
        ;; is called tail-recursively
          (assign val
                  (op compiled-procedure-entry)
                  (reg proc))
          (goto (reg val))
        primitive-branch14
          (assign val
                  (op apply-primitive-procedure)
                  (reg proc)
                  (reg argl))
          (goto (reg continue))
        after-call12
        after-if3
        after-lambda1
        ;; assign the procedure to the variable factorial
          (perform (op define-variable!)
                   (const factorial)
                   (reg val)
                   (reg env))
          (assign val (const ok))
      < src..


#     :: @t(Exercise 5.33) :: Consider the following definition of a factorial
#        procedure, which is slightly different from the one given above:
    :: @t(Ejercicio 5.33) :: Consideremos la siguiente definición de un
       procedimiento factorial, que es ligeramente diferente de la anterior:

#        ..src > scheme
#          (define (factorial-alt n)
#            (if (= n 1)
#                1
#                (* n (factorial-alt (- n 1)))))
#        < src..
       ..src > scheme
         (define (factorial-alt n)
           (if (= n 1)
               1
               (* n (factorial-alt (- n 1)))))
       < src..

#        Compile this procedure and compare the resulting code with that produced
#        for @c(factorial). Explain any differences you find. Does either program
#        execute more efficiently than the other?
       Compile este procedimiento y compare el código resultante con el
       producido @c(factorial). Explique las diferencias que encuentre. ¿Ejecuta
       cualquiera de los programas de manera más eficiente que la otra?

#     :: @t(Exercise 5.34) :: Compile the iterative factorial procedure
    :: @t(Ejercicio 5.34) :: Compilar el procedimiento factorial iterativo

#        ..src > scheme
#          (define (factorial n)
#            (define (iter product counter)
#              (if (> counter n)
#                  product
#                  (iter (* counter product)
#                        (+ counter 1))))
#            (iter 1 1))
#        < src..
       ..src > scheme
         (define (factorial n)
           (define (iter product counter)
             (if (> counter n)
                 product
                 (iter (* counter product)
                       (+ counter 1))))
           (iter 1 1))
       < src..

#        Annotate the resulting code, showing the essential difference between the
#        code for iterative and recursive versions of @c(factorial) that makes one
#        process build up stack space and the other run in constant stack space.
       Anote el código resultante, mostrando la diferencia esencial entre el
       código para las versiones iterativas y recursivas de @c(factorial) que
       hace que un proceso acumule espacio en la pila y el otro se ejecute en un
       espacio de pila constante.

#     :: @t(Exercise 5.35) :: What expression was compiled to produce the code shown
#        in @l(#Figure 5.18)?
    :: @t(Ejercicio 5.35) :: ¿Qué expresión se compiló para producir el código
       mostrado en la @l(#Figura 5.18) ?

#     ..figure > @t(Figure 5.18) An example of compiler output. See @l(#Exercise 5.35).
    ..figure > @t(Figura 5.18) Un ejemplo de salida del compilador. Véase el
    @l(#Ejercicio 5.35).

#       ..src > scheme
#         (assign val (op make-compiled-procedure)
#                     (label entry16)
#                     (reg env))
#           (goto (label after-lambda15))
#         entry16
#           (assign env (op compiled-procedure-env)
#                       (reg proc))
#           (assign env (op extend-environment)
#                       (const (x))
#                       (reg argl)
#                       (reg env))
#           (assign proc (op lookup-variable-value)
#                        (const +)
#                        (reg env))
#           (save continue) (save proc) (save env)
#           (assign proc (op lookup-variable-value)
#                        (const g)
#                        (reg env))
#           (save proc)
#           (assign proc (op lookup-variable-value)
#                        (const +)
#                        (reg env))
#           (assign val (const 2))
#           (assign argl (op list) (reg val))
#           (assign val (op lookup-variable-value)
#                       (const x)
#                       (reg env))
#           (assign argl (op cons)
#                        (reg val)
#                        (reg argl))
#           (test (op primitive-procedure?)
#                 (reg proc))
#           (branch (label primitive-branch19))
#         compiled-branch18
#           (assign continue (label after-call17))
#           (assign val
#                   (op compiled-procedure-entry)
#                   (reg proc))
#           (goto (reg val))
#         primitive-branch19
#           (assign val
#                   (op apply-primitive-procedure)
#                   (reg proc)
#                   (reg argl))
#         after-call17
#           (assign argl (op list) (reg val))
#           (restore proc)
#           (test (op primitive-procedure?)
#                 (reg proc))
#           (branch (label primitive-branch22))
#         compiled-branch21
#           (assign continue (label after-call20))
#           (assign val
#                   (op compiled-procedure-entry)
#                   (reg proc))
#           (goto (reg val))
#         primitive-branch22
#           (assign val
#                   (op apply-primitive-procedure)
#                   (reg proc)
#                   (reg argl))
#         after-call20
#           (assign argl (op list) (reg val))
#           (restore env)
#           (assign val
#                   (op lookup-variable-value)
#                   (const x)
#                   (reg env))
#           (assign argl
#                   (op cons)
#                   (reg val)
#                   (reg argl))
#           (restore proc)
#           (restore continue)
#           (test (op primitive-procedure?)
#                 (reg proc))
#           (branch (label primitive-branch25))
#         compiled-branch24
#           (assign val (op compiled-procedure-entry)
#                       (reg proc))
#           (goto (reg val))
#         primitive-branch25
#           (assign val
#                   (op apply-primitive-procedure)
#                   (reg proc)
#                   (reg argl))
#           (goto (reg continue))
#         after-call23
#         after-lambda15
#           (perform (op define-variable!)
#                    (const f)
#                    (reg val)
#                    (reg env))
#           (assign val (const ok))
#       < src..
      ..src > scheme
        (assign val (op make-compiled-procedure)
                    (label entry16)
                    (reg env))
          (goto (label after-lambda15))
        entry16
          (assign env (op compiled-procedure-env)
                      (reg proc))
          (assign env (op extend-environment)
                      (const (x))
                      (reg argl)
                      (reg env))
          (assign proc (op lookup-variable-value)
                       (const +)
                       (reg env))
          (save continue) (save proc) (save env)
          (assign proc (op lookup-variable-value)
                       (const g)
                       (reg env))
          (save proc)
          (assign proc (op lookup-variable-value)
                       (const +)
                       (reg env))
          (assign val (const 2))
          (assign argl (op list) (reg val))
          (assign val (op lookup-variable-value)
                      (const x)
                      (reg env))
          (assign argl (op cons)
                       (reg val)
                       (reg argl))
          (test (op primitive-procedure?)
                (reg proc))
          (branch (label primitive-branch19))
        compiled-branch18
          (assign continue (label after-call17))
          (assign val
                  (op compiled-procedure-entry)
                  (reg proc))
          (goto (reg val))
        primitive-branch19
          (assign val
                  (op apply-primitive-procedure)
                  (reg proc)
                  (reg argl))
        after-call17
          (assign argl (op list) (reg val))
          (restore proc)
          (test (op primitive-procedure?)
                (reg proc))
          (branch (label primitive-branch22))
        compiled-branch21
          (assign continue (label after-call20))
          (assign val
                  (op compiled-procedure-entry)
                  (reg proc))
          (goto (reg val))
        primitive-branch22
          (assign val
                  (op apply-primitive-procedure)
                  (reg proc)
                  (reg argl))
        after-call20
          (assign argl (op list) (reg val))
          (restore env)
          (assign val
                  (op lookup-variable-value)
                  (const x)
                  (reg env))
          (assign argl
                  (op cons)
                  (reg val)
                  (reg argl))
          (restore proc)
          (restore continue)
          (test (op primitive-procedure?)
                (reg proc))
          (branch (label primitive-branch25))
        compiled-branch24
          (assign val (op compiled-procedure-entry)
                      (reg proc))
          (goto (reg val))
        primitive-branch25
          (assign val
                  (op apply-primitive-procedure)
                  (reg proc)
                  (reg argl))
          (goto (reg continue))
        after-call23
        after-lambda15
          (perform (op define-variable!)
                   (const f)
                   (reg val)
                   (reg env))
          (assign val (const ok))
      < src..


#     :: @t(Exercise 5.36) :: What order of evaluation does our compiler produce for
#        operands of a combination?  Is it left-to-right, right-to-left, or some
#        other order?  Where in the compiler is this order determined?  Modify the
#        compiler so that it produces some other order of evaluation. (See the
#        discussion of order of evaluation for the explicit-control evaluator in
#        @l(#5.4.1).)  How does changing the order of operand evaluation affect the
#        efficiency of the code that constructs the argument list?
    :: @t(Ejercicio 5.36) :: ¿Qué orden de evaluación produce nuestro compilador
       para los operandos de una combinación? ¿Es de izquierda a derecha, de
       derecha a izquierda, o algún otro orden? ¿Dónde está el orden en el
       compilador? Modifique el compilador para que produzca algún otro orden de
       evaluación. (Ver la discusión del orden de evaluación para el evaluador
       de control explícito en la seccion @l(#5.4.1) .) ¿De qué manera el cambio del
       orden de la evaluación del operando afecta la eficiencia del código que
       construye la lista de argumentos?

#     :: @t(Exercise 5.37) :: One way to understand the compiler's @c(preserving)
#        mechanism for optimizing stack usage is to see what extra operations would
#        be generated if we did not use this idea. Modify @c(preserving) so that it
#        always generates the @c(save) and @c(restore) operations. Compile some
#        simple expressions and identify the unnecessary stack operations that are
#        generated. Compare the code to that generated with the @c(preserving)
#        mechanism intact.
    :: @t(Ejercicio 5.37) :: Una forma de entender el @c(preserving) mecanismo
       del compilador para optimizar el uso de la pila es ver qué operaciones
       adicionales se generarán si no usamos esta idea. Modifique @c(preserving)
       para que siempre genere las operaciones @c(save) y @c(restore). Compile
       algunas expresiones simples e identifique las operaciones de pila
       innecesarias que se generan. Comparar el código con el generado con el
       @c(preserving) mecanismo intacto.

#     :: @t(Exercise 5.38) :: Our compiler is clever about avoiding unnecessary
#        stack operations, but it is not clever at all when it comes to compiling
#        calls to the primitive procedures of the language in terms of the primitive
#        operations supplied by the machine. For example, consider how much code is
#        compiled to compute @c[(+ a 1)]: The code sets up an argument list in
#        @c(argl), puts the primitive addition procedure (which it finds by looking
#        up the symbol @c(+) in the environment) into @c(proc), and tests whether
#        the procedure is primitive or compound. The compiler always generates code
#        to perform the test, as well as code for primitive and compound branches
#        (only one of which will be executed). We have not shown the part of the
#        controller that implements primitives, but we presume that these
#        instructions make use of primitive arithmetic operations in the machine's
#        data paths.  Consider how much less code would be generated if the compiler
#        could @e(open-code) primitives––that is, if it could generate code to
#        directly use these primitive machine operations. The expression @c[(+ a 1)]
#        might be compiled into something as simple as@n(328)
    :: @t(Ejercicio 5.38) :: Nuestro compilador es inteligente para evitar las
       operaciones de pila innecesarias, pero no es inteligente en absoluto
       cuando se trata de compilar las llamadas a los procedimientos primitivos
       del lenguaje en términos de las operaciones primitivas suministradas por
       la máquina. Por ejemplo, considere cuánto código se compila para calcular
       @c[(+ a 1)]: El código establece una lista de argumentos en @c(argl),
       pone el procedimiento de adición primitiva (que encuentra al buscar el
       símbolo @c(+) en el entorno) @c(proc) y prueba si el procedimiento es
       primitivo o compuesto. El compilador siempre genera código para realizar
       la prueba, así como código para las ramas primitivas y compuestas (sólo
       una de ellas se ejecutará). No hemos mostrado la parte del controlador
       que implementa primitivas, Pero suponemos que estas instrucciones hacen
       uso de operaciones aritméticas primitivas en las trayectorias de datos de
       la máquina. @e(Considere cuánto menos código se generaría si el
       compilador podría código abierto) primitivas - es decir, si podría
       generar código para utilizar directamente estas operaciones de la máquina
       primitiva. La expresión @c[(+ a 1)] podría ser compilada en algo tan
       simple como@n(328)

#        ..src > scheme
#          (assign val (op lookup-variable-value)
#                      (const a)
#                      (reg env))
#          (assign val (op +)
#                      (reg val)
#                      (const 1))
#        < src..
       ..src > scheme
         (assign val (op lookup-variable-value)
                     (const a)
                     (reg env))
         (assign val (op +)
                     (reg val)
                     (const 1))
       < src..

#        In this exercise we will extend our compiler to support open coding of
#        selected primitives. Special-purpose code will be generated for calls to
#        these primitive procedures instead of the general procedure-application
#        code. In order to support this, we will augment our machine with special
#        argument registers @c(arg1) and @c(arg2). The primitive arithmetic
#        operations of the machine will take their inputs from @c(arg1) and
#        @c(arg2). The results may be put into @c(val), @c(arg1), or @c(arg2).
       En este ejercicio extenderemos nuestro compilador para apoyar la
       codificación abierta de primitivas seleccionadas. Se generará un código
       de propósito especial para llamadas a estos procedimientos primitivos en
       lugar del código de aplicación de procedimiento general. Con el fin de
       apoyar esto, vamos a aumentar nuestra máquina con registros de argumento
       especial @c(arg1) y @c(arg2). Las operaciones aritméticas primitivas de
       la máquina tomarán sus entradas de @c(arg1) y @c(arg2). Los resultados se
       pueden poner en @c(val), @c(arg1) o @c(arg2).

#        The compiler must be able to recognize the application of an open-coded
#        primitive in the source program. We will augment the dispatch in the
#        @c(compile) procedure to recognize the names of these primitives in
#        addition to the reserved words (the special forms) it currently
#        recognizes.@n(329) For each special form our compiler has a code
#        generator. In this exercise we will construct a family of code generators
#        for the open-coded primitives.
       El compilador debe ser capaz de reconocer la aplicación de una primitiva
       de codificación abierta en el programa de origen. Aumentaremos el envío
       en el procedimiento @c(compile) para reconocer los nombres de estos
       primitivos además de las palabras reservadas (los formularios especiales)
       que actualmente reconoce.@n(329) Para cada formulario especial
       nuestro compilador tiene un generador de código. En este ejercicio
       construiremos una familia de generadores de código para los primitivos de
       codificación abierta.

#        1. The open-coded primitives, unlike the special forms, all need their
#           operands evaluated. Write a code generator @c(spread-arguments) for use
#           by all the open-coding code generators. @c(Spread-arguments) should take
#           an operand list and compile the given operands targeted to successive
#           argument registers.  Note that an operand may contain a call to an
#           open-coded primitive, so argument registers will have to be preserved
#           during operand evaluation.
       1. Los primitivos de codificación abierta, a diferencia de las formas
          especiales, necesitan todos sus operandos evaluados. Escriba un
          generador de código @c(spread-arguments) para su uso por todos los
          generadores de código abierto. @c(Spread-arguments) Debe tomar una
          lista de operandos y compilar los operandos dados a los sucesivos
          registros de argumentos. Obsérvese que un operando puede contener una
          llamada a una primitiva de código abierto, por lo que los registros de
          argumento tendrán que ser preservados durante la evaluación del
          operando.

#        2. For each of the primitive procedures @c(=), @c(*), @c(-), and @c(+),
#           write a code generator that takes a combination with that operator,
#           together with a target and a linkage descriptor, and produces code to
#           spread the arguments into the registers and then perform the operation
#           targeted to the given target with the given linkage. You need only
#           handle expressions with two operands. Make @c(compile) dispatch to these
#           code generators.
       2. Para cada uno de los procedimientos primitivos @c(=), @c(*), @c(-), y
          @c(+), escribir un generador de código que tiene una combinación con
          ese operador, junto con un objetivo y un descriptor de vinculación, y
          produce código para difundir los argumentos en los registros y luego
          realizar la operación deseada a la Dado el objetivo con el enlace
          dado. Sólo necesita manejar expresiones con dos operandos. Haga el
          @c(compile) envío a estos generadores de código.

#        3. Try your new compiler on the @c(factorial) example. Compare the
#           resulting code with the result produced without open coding.
       3. Pruebe su nuevo compilador en el @c(factorial) ejemplo. Compare el
          código resultante con el resultado producido sin codificación abierta.

#        4. Extend your code generators for @c(+) and @c(*) so that they can handle
#           expressions with arbitrary numbers of operands. An expression with more
#           than two operands will have to be compiled into a sequence of
#           operations, each with only two inputs.
       4. Extienda sus generadores de código @c(+) y @c(*) para que puedan
          manejar expresiones con números arbitrarios de operandos. Una
          expresión con más de dos operandos tendrá que ser compilada en una
          secuencia de operaciones, cada una con sólo dos entradas.

# *** 5.5.6 <> Lexical Addressing
*** 5.5.6 <> Direccionamiento Lexical

#     One of the most common optimizations performed by compilers is the
#     optimization of variable lookup. Our compiler, as we have implemented it so
#     far, generates code that uses the @c(lookup-variable-value) operation of the
#     evaluator machine. This searches for a variable by comparing it with each
#     variable that is currently bound, working frame by frame outward through the
#     run-time environment. This search can be expensive if the frames are deeply
#     nested or if there are many variables. For example, consider the problem of
#     looking up the value of @c(x) while evaluating the expression @c[(* x y z)] in
#     an application of the procedure that is returned by
    Una de las optimizaciones más comunes realizadas por los compiladores es la
    optimización de la búsqueda de variables. Nuestro compilador, como lo hemos
    implementado hasta ahora, genera código que utiliza la
    @c(lookup-variable-value) operación de la máquina evaluadora. Esto busca una
    variable comparándola con cada variable que está enlazada actualmente,
    trabajando marco por cuadro hacia fuera a través del entorno de
    ejecución. Esta búsqueda puede ser costosa si los marcos están profundamente
    anidados o si hay muchas variables. Por ejemplo, considere el problema de
    buscar el valor de @c(x) mientras se evalúa la expresión @c[(* x y z)] en
    una aplicación del procedimiento que es devuelta por

#     ..src > scheme
#       (let ((x 3) (y 4))
#         (lambda (a b c d e)
#           (let ((y (* a b x))
#                 (z (+ c d x)))
#             (* x y z))))
#     < src..
    ..src > scheme
      (let ((x 3) (y 4))
        (lambda (a b c d e)
          (let ((y (* a b x))
                (z (+ c d x)))
            (* x y z))))
    < src..

#     Since a @c(let) expression is just syntactic sugar for a @c(lambda)
#     combination, this expression is equivalent to
    Dado que una expresión @c(let) es simplemente azúcar sintáctico para una
    @c(lambda) combinación, esta expresión es equivalente a

#     ..src > scheme
#       ((lambda (x y)
#          (lambda (a b c d e)
#            ((lambda (y z) (* x y z))
#             (* a b x)
#             (+ c d x))))
#        3
#        4)
#     < src..
    ..src > scheme
      ((lambda (x y)
         (lambda (a b c d e)
           ((lambda (y z) (* x y z))
            (* a b x)
            (+ c d x))))
       3
       4)
    < src..

#     Each time @c(lookup-variable-value) searches for @c(x), it must determine that
#     the symbol @c(x) is not @c(eq?) to @c(y) or @c(z) (in the first frame), nor to
#     @c(a), @c(b), @c(c), @c(d), or @c(e) (in the second frame). We will assume,
#     for the moment, that our programs do not use @c(define)––that variables are
#     bound only with @c(lambda). Because our language is lexically scoped, the
#     run-time environment for any expression will have a structure that parallels
#     the lexical structure of the program in which the expression appears.@n(330)
#     Thus, the compiler can know, when it analyzes the above expression, that each
#     time the procedure is applied the variable @c(x) in @c[(* x y z)] will be
#     found two frames out from the current frame and will be the first variable in
#     that frame.
    Cada vez que @c(lookup-variable-value) busca @c(x), se debe determinar que
    el símbolo @c(x) no es @c(eq?) de @c(y) o @c(z)(en el primer cuadro), ni a
    @c(a), @c(b), @c(c), @c(d), o @c(e)(en el segundo cuadro). Asumiremos, por
    el momento, que nuestros programas no usan @c(define)- que las variables
    sólo están vinculadas con @c(lambda). Debido a que nuestro lenguaje tiene un
    alcance léxico, el entorno de ejecución para cualquier expresión tendrá una
    estructura paralela a la estructura léxica del programa en el que aparece la
    expresión.@n(330) Así, el compilador puede saber, al analizar la
    expresión anterior,@c(x)@c[(* x y z)]

#     We can exploit this fact by inventing a new kind of variable-lookup operation,
#     @c(lexical-address-lookup), that takes as arguments an environment and a
#     @e(lexical address) that consists of two numbers: a @e(frame number), which
#     specifies how many frames to pass over, and a @e(displacement number), which
#     specifies how many variables to pass over in that frame.
#     @c(Lexical-address-lookup) will produce the value of the variable stored at
#     that lexical address relative to the current environment.  If we add the
#     @c(lexical-address-lookup) operation to our machine, we can make the compiler
#     generate code that references variables using this operation, rather than
#     @c(lookup-variable-value). Similarly, our compiled code can use a new
#     @c(lexical-address-set!)  operation instead of @c(set-variable-value!).
    Podemos explotar este hecho inventando un nuevo tipo de operación de
    búsqueda de variables @c(lexical-address-lookup), que toma como argumentos
    un entorno y una @e(dirección léxica) que consta de dos números: un
    @e(número de fotograma), que especifica cuántos fotogramas pasan y un
    @e(número de desplazamiento), Que especifica el número de variables a pasar
    en ese marco. @c(Lexical-address-lookup) Producirá el valor de la variable
    almacenada en esa dirección léxica relativa al entorno actual. Si añadimos
    la @c(lexical-address-lookup) operación a nuestra máquina, podemos hacer que
    el compilador genere un código que haga referencia a variables usando esta
    operación, en lugar de @c(lookup-variable-value). Del mismo modo, nuestro
    código compilado puede utilizar una nueva @c(lexical-address-set!)
    operación en lugar de @c(set-variable-value!).

#     In order to generate such code, the compiler must be able to determine the
#     lexical address of a variable it is about to compile a reference to. The
#     lexical address of a variable in a program depends on where one is in the
#     code.  For example, in the following program, the address of @c(x) in
#     expression @c[(e1)] is (2, 0)––two frames back and the first variable in the
#     frame. At that point @c(y) is at address (0, 0) and @c(c) is at address (1,
#     2). In expression @c[(e2)], @c(x) is at (1, 0), @c(y) is at (1, 1), and @c(c)
#     is at (0, 2).
    Con el fin de generar dicho código, el compilador debe ser capaz de
    determinar la dirección léxica de una variable sobre la que está a punto de
    compilar una referencia. La dirección léxica de una variable en un programa
    depende de donde esté uno en el código. Por ejemplo, en el siguiente
    programa, la dirección de @c(x) en expresión @c[(e1)] es (2, 0) - dos tramas
    de nuevo y la primera variable en el marco. En ese punto @c(y) está en la
    dirección (0, 0) y @c(c) está en la dirección (1, 2). En la expresión
    @c[(e2)], @c(x) está en (1, 0), @c(y) está en (1, 1), y @c(c) está en (0,
    2).

#     ..src > scheme
#       ((lambda (x y)
#          (lambda (a b c d e)
#            ((lambda (y z) ⟨e1⟩)
#             ⟨e2⟩
#             (+ c d x))))
#        3
#        4)
#     < src..
    ..src > scheme
      ((lambda (x y)
         (lambda (a b c d e)
           ((lambda (y z) ⟨e1⟩)
            ⟨e2⟩
            (+ c d x))))
       3
       4)
    < src..

#     One way for the compiler to produce code that uses lexical addressing is to
#     maintain a data structure called a @e(compile-time environment). This keeps
#     track of which variables will be at which positions in which frames in the
#     run-time environment when a particular variable-access operation is
#     executed. The compile-time environment is a list of frames, each containing a
#     list of variables. (There will of course be no values bound to the variables,
#     since values are not computed at compile time.)  The compile-time environment
#     becomes an additional argument to @c(compile) and is passed along to each code
#     generator. The top-level call to @c(compile) uses an empty compile-time
#     environment. When a @c(lambda) body is compiled, @c(compile-lambda-body)
#     extends the compile-time environment by a frame containing the procedure's
#     parameters, so that the sequence making up the body is compiled with that
#     extended environment. At each point in the compilation, @c(compile-variable)
#     and @c(compile-assignment) use the compile-time environment in order to
#     generate the appropriate lexical addresses.
    Una manera para que el compilador produzca código que usa el
    direccionamiento léxico es mantener una estructura de datos llamada
    @e(entorno de compilación). Esto hace un seguimiento de qué variables serán
    en qué posiciones en qué marcos en el entorno de tiempo de ejecución cuando
    se ejecuta una determinada operación de acceso a variables. El entorno de
    tiempo de compilación es una lista de marcos, cada uno contiene una lista de
    variables. (Por supuesto, no habrá valores vinculados a las variables, ya
    que los valores no se computan en tiempo de compilación). El entorno de
    compilación se convierte en un argumento adicional @c(compile) y se pasa a
    cada generador de código. La llamada de nivel superior @c(compile) utiliza
    un entorno de compilación vacío. Cuando @c(lambda) se compila un cuerpo, se
    @c(compile-lambda-body) extiende el entorno de tiempo de compilación por un
    marco que contiene los parámetros del procedimiento, De modo que la
    secuencia que compone el cuerpo se compila con ese entorno
    extendido. @c(compile-variable) En cada punto de la compilación, y
    @c(compile-assignment) utilizar el entorno de compilación para generar las
    direcciones léxicas apropiadas.

#     @l(#Exercise 5.39) through @l(#Exercise 5.43) describe how to complete this
#     sketch of the lexical-addressing strategy in order to incorporate lexical
#     lookup into the compiler. @l(#Exercise 5.44) describes another use for the
#     compile-time environment.
    @l(#Ejercicio 5.39) al @l(#Ejercicio 5.43)
    describe cómo completar este bosquejo de la estrategia de direccionamiento
    léxico para incorporar la búsqueda léxica al
    compilador. @l(#Ejercicio 5.44) describe otro uso para el
    entorno de compilación.

#     :: @t(Exercise 5.39) :: Write a procedure @c(lexical-address-lookup) that
#        implements the new lookup operation. It should take two arguments––a
#        lexical address and a run-time environment––and return the value of the
#        variable stored at the specified lexical address.
#        @c(Lexical-address-lookup) should signal an error if the value of the
#        variable is the symbol @c(*unassigned*).@n(331) Also write a procedure
#        @c(lexical-address-set!) that implements the operation that changes the
#        value of the variable at a specified lexical address.
    :: @t(Ejercicio 5.39) :: Escriba un procedimiento @c(lexical-address-lookup)
       que implemente la nueva operación de búsqueda. Debe tomar dos
       argumentos - una dirección léxica y un entorno de tiempo de ejecución - y
       devolver el valor de la variable almacenada en la dirección léxica
       especificada. @c(Lexical-address-lookup) Debe indicar un error si el
       valor de la variable es el símbolo @c(*unassigned*).@n(331)
       Escriba también un procedimiento @c(lexical-address-set!) que implemente
       la operación que cambia el valor de la variable en una dirección léxica
       especificada.

#     :: @t(Exercise 5.40) :: Modify the compiler to maintain the compile-time
#        environment as described above. That is, add a compile-time-environment
#        argument to @c(compile) and the various code generators, and extend it in
#        @c(compile-lambda-body).
    :: @t(Ejercicio 5.40) :: Modifique el compilador para mantener el entorno de
       tiempo de compilación como se describe anteriormente. Es decir, agregue
       un argumento de tiempo de compilación en el entorno a @c(compile) los
       generadores de código y los ampliará @c(compile-lambda-body).

#     :: @t(Exercise 5.41) :: Write a procedure @c(find-variable) that takes as
#        arguments a variable and a compile-time environment and returns the lexical
#        address of the variable with respect to that environment. For example, in
#        the program fragment that is shown above, the compile-time environment
#        during the compilation of expression @c[(e1)] is @c[((y z) (a b c d e) (x
#        y))]. @c(Find-variable) should produce
    :: @t(Ejercicio 5.41) :: Escriba un procedimiento @c(find-variable) que toma
       como argumentos una variable y un entorno de compilación y devuelve la
       dirección léxica de la variable con respecto a ese entorno. Por ejemplo,
       en el fragmento de programa que se muestra anteriormente, el entorno de
       compilación durante la compilación de la expresión @c[(e1)] es @c[((y z)
       (a b c d e) (x y))]. @c(Find-variable) Debería producir

#        ..srci > scheme
#          > (find-variable
#          ^  'c '((y z) (a b c d e) (x y)))
#          (1 2)
#          > (find-variable
#          ^  'x '((y z) (a b c d e) (x y)))
#          (2 0)
#          > (find-variable
#          ^  'w '((y z) (a b c d e) (x y)))
#          not-found
#        < srci..
       ..srci > scheme
         > (find-variable
         ^  'c '((y z) (a b c d e) (x y)))
         (1 2)
         > (find-variable
         ^  'x '((y z) (a b c d e) (x y)))
         (2 0)
         > (find-variable
         ^  'w '((y z) (a b c d e) (x y)))
         not-found
       < srci..

#     :: @t(Exercise 5.42) :: Using @c(find-variable) from @l(#Exercise 5.41),
#        rewrite @c(compile-variable) and @c(compile-assignment) to output
#        lexical-address instructions. In cases where @c(find-variable) returns
#        @c(not-found) (that is, where the variable is not in the compile-time
#        environment), you should have the code generators use the evaluator
#        operations, as before, to search for the binding.  (The only place a
#        variable that is not found at compile time can be is in the global
#        environment, which is part of the run-time environment but is not part of
#        the compile-time environment.@n(332) Thus, if you wish, you may have the
#        evaluator operations look directly in the global environment, which can be
#        obtained with the operation @c[(op get-global-environment)], instead of
#        having them search the whole run-time environment found in @c(env).)  Test
#        the modified compiler on a few simple cases, such as the nested @c(lambda)
#        combination at the beginning of this section.
    :: @t(Ejercicio 5.42) :: Usando @c(find-variable) desde el
       @l(#Ejercicio 5.41), reescribir @c(compile-variable) y
       @c(compile-assignment) dar salida a las instrucciones de dirección
       léxica. En los casos en que las @c(find-variable) devoluciones
       @c(not-found)(es decir, donde la variable no está en el entorno de tiempo
       de compilación), debería hacer que los generadores de código usen las
       operaciones del evaluador, como antes, para buscar la vinculación. (El
       único lugar una variable que no se encuentra en tiempo de compilación
       puede ser es en el entorno global, el cual es parte del entorno de tiempo
       de ejecución, pero no es parte del entorno de tiempo de
       compilación.@n(332) Por lo tanto, si se desea, puede Hacer que las
       operaciones del evaluador miren directamente en el entorno global, que se
       puede obtener con la operación @c[(op get-global-environment)], en lugar
       de hacer que busquen todo el entorno de ejecución encontrado en
       @c(env).@c(lambda)

#     :: @t(Exercise 5.43) :: We argued in section @l(#4.1.6) that internal definitions for
#        block structure should not be considered @"(real) @c(define)s. Rather, a
#        procedure body should be interpreted as if the internal variables being
#        defined were installed as ordinary @c(lambda) variables initialized to
#        their correct values using @c(set!).  @l(#4.1.6) and @l(#Exercise 4.16)
#        showed how to modify the metacircular interpreter to accomplish this by
#        scanning out internal definitions. Modify the compiler to perform the same
#        transformation before it compiles a procedure body.
    :: @t(Ejercicio 5.43) :: Argumentamos en la seccion @l(#4.1.6) que las
       definiciones internas para la estructura de bloques no deben ser
       consideradas como @"(reales) @c(define). Más bien, un cuerpo de
       procedimiento debe interpretarse como si las variables internas que se
       estaban definiendo se instalaran como @c(lambda) variables ordinarias
       inicializadas a sus valores correctos usando @c(set!).  @l(#4.1.6)
       y el @l(#Ejercicio 4.16) mostraron cómo modificar el
       intérprete metacircular para lograr esto mediante la exploración de
       definiciones internas. Modifique el compilador para realizar la misma
       transformación antes de compilar un cuerpo de procedimiento.

#     :: @t(Exercise 5.44) :: In this section we have focused on the use of the
#        compile-time environment to produce lexical addresses. But there are other
#        uses for compile-time environments. For instance, in @l(#Exercise 5.38) we
#        increased the efficiency of compiled code by open-coding primitive
#        procedures. Our implementation treated the names of open-coded procedures
#        as reserved words. If a program were to rebind such a name, the mechanism
#        described in @l(#Exercise 5.38) would still open-code it as a primitive,
#        ignoring the new binding. For example, consider the procedure
    :: @t(Ejercicio 5.44) :: En esta sección nos hemos centrado en el uso del
       entorno de compilación para producir direcciones léxicas. Pero hay otros
       usos para los entornos de tiempo de compilación. Por ejemplo, en el
       @l(#Ejercicio 5.38) aumentamos la eficiencia del código
       compilado mediante procedimientos primitivos de codificación
       abierta. Nuestra implementación trató los nombres de procedimientos
       codificados como palabras reservadas. Si un programa debía volver a unir
       tal nombre, el mecanismo descrito en el @l(#Ejercicio
       5.38) aún lo codificaría como un primitivo, ignorando el nuevo
       enlace. Por ejemplo, considere el procedimiento

#        ..src > scheme
#          (lambda (+ * a b x y)
#            (+ (* a x) (* b y)))
#        < src..
       ..src > scheme
         (lambda (+ * a b x y)
           (+ (* a x) (* b y)))
       < src..

#        which computes a linear combination of @c(x) and @c(y). We might call it
#        with arguments @c(+matrix), @c(*matrix), and four matrices, but the
#        open-coding compiler would still open-code the @c(+) and the @c(*) in @c[(+
#        (* a x) (* b y))] as primitive @c(+) and @c(*). Modify the open-coding
#        compiler to consult the compile-time environment in order to compile the
#        correct code for expressions involving the names of primitive
#        procedures. (The code will work correctly as long as the program does not
#        @c(define) or @c(set!) these names.)
       Que calcula una combinación lineal de @c(x) y @c(y). Podríamos llamarlo
       con argumentos @c(+matrix), @c(*matrix) y cuatro matrices, pero el
       compilador de codificación abierta todavía abriría el código @c(+) y el
       @c(*) in @c[(+ (* a x) (* b y))] como primitivo @c(+) y @c(*). Modifique
       el compilador de código abierto para consultar el entorno de compilación
       para compilar el código correcto para las expresiones que implican los
       nombres de los procedimientos primitivos. (El código funcionará
       correctamente siempre y cuando el programa no lo haga @c(define) o
       @c(set!) estos nombres.)

# *** 5.5.7 <> Interfacing Compiled Code to the Evaluator
*** 5.5.7 <> Interfaz del código compilado con el evaluador

#     We have not yet explained how to load compiled code into the evaluator machine
#     or how to run it. We will assume that the explicit-control-evaluator machine
#     has been defined as in section @l(#5.4.4), with the additional operations specified in
#    @n(323<>Footnote 323). We will implement a procedure @c(compile-and-go) that
#     compiles a Scheme expression, loads the resulting object code into the
#     evaluator machine, and causes the machine to run the code in the evaluator
#     global environment, print the result, and enter the evaluator's driver
#     loop. We will also modify the evaluator so that interpreted expressions can
#     call compiled procedures as well as interpreted ones. We can then put a
#     compiled procedure into the machine and use the evaluator to call it:
    Aún no hemos explicado cómo cargar código compilado en la máquina evaluadora
    o cómo ejecutarla. Supondremos que la máquina explícita de control-evaluador
    se ha definido como en la seccion @l(#5.4.4), con las operaciones adicionales
    especificadas en la@n(323<>Nota 323). Implementaremos un procedimiento
    @c(compile-and-go) que compile una expresión Scheme, cargue el código objeto
    resultante en la máquina evaluadora y haga que la máquina ejecute el código
    en el entorno global del evaluador, imprima el resultado e ingrese el bucle
    del controlador del evaluador. También modificaremos el evaluador para que
    las expresiones interpretadas puedan llamar procedimientos compilados e
    interpretados. Podemos entonces poner un procedimiento compilado en la
    máquina y utilizar el evaluador para llamarla:

#     ..srci > scheme
#       > (compile-and-go
#       ^  '(define (factorial n)
#       ^     (if (= n 1)
#       ^         1
#       ^         (* (factorial (- n 1)) n))))
#       ;;; EC-Eval value:
#       ok
#       ;;; EC-Eval input:
#       > (factorial 5)
#       ;;; EC-Eval value:
#       120
#     < srci..
    ..srci > scheme
      > (compile-and-go
      ^  '(define (factorial n)
      ^     (if (= n 1)
      ^         1
      ^         (* (factorial (- n 1)) n))))
      ;;; EC-Eval value:
      ok
      ;;; EC-Eval input:
      > (factorial 5)
      ;;; EC-Eval value:
      120
    < srci..

#     To allow the evaluator to handle compiled procedures (for example, to evaluate
#     the call to @c(factorial) above), we need to change the code at
#     @c(apply-dispatch) (section @l(#5.4.1)) so that it recognizes compiled procedures (as
#     distinct from compound or primitive procedures) and transfers control directly
#     to the entry point of the compiled code:@n(333)
    Para permitir que el evaluador maneje los procedimientos compilados (por
    ejemplo, para evaluar la llamada @c(factorial) anterior), necesitamos
    cambiar el código en @c(apply-dispatch)(seccion @l(#5.4.1)) para que
    reconozca procedimientos compilados (distintos de procedimientos compuestos
    o primitivos) y control de transferencias Directamente al punto de entrada
    del código compilado:@n(333)

#     ..src > scheme
#       apply-dispatch
#         (test (op primitive-procedure?) (reg proc))
#         (branch (label primitive-apply))
#         (test (op compound-procedure?) (reg proc))
#         (branch (label compound-apply))
#         (test (op compiled-procedure?) (reg proc))
#         (branch (label compiled-apply))
#         (goto (label unknown-procedure-type))
#
#       compiled-apply
#         (restore continue)
#         (assign val
#                 (op compiled-procedure-entry)
#                 (reg proc))
#         (goto (reg val))
#     < src..
    ..src > scheme
      apply-dispatch
        (test (op primitive-procedure?) (reg proc))
        (branch (label primitive-apply))
        (test (op compound-procedure?) (reg proc))
        (branch (label compound-apply))
        (test (op compiled-procedure?) (reg proc))
        (branch (label compiled-apply))
        (goto (label unknown-procedure-type))

      compiled-apply
        (restore continue)
        (assign val
                (op compiled-procedure-entry)
                (reg proc))
        (goto (reg val))
    < src..

#     Note the restore of @c(continue) at @c(compiled-apply). Recall that the
#     evaluator was arranged so that at @c(apply-dispatch), the continuation would
#     be at the top of the stack. The compiled code entry point, on the other hand,
#     expects the continuation to be in @c(continue), so @c(continue) must be
#     restored before the compiled code is executed.
    Tenga en cuenta la restauración de @c(continue) en
    @c(compiled-apply). Recuerde que el evaluador fue arreglado de modo que en
    @c(apply-dispatch), la continuación sería en la parte superior de la
    pila. El punto de entrada de código compilado, por otro lado, espera que la
    continuación esté en @c(continue), por lo que @c(continue) debe restaurarse
    antes de ejecutar el código compilado.

#     To enable us to run some compiled code when we start the evaluator machine, we
#     add a @c(branch) instruction at the beginning of the evaluator machine, which
#     causes the machine to go to a new entry point if the @c(flag) register is
#     set.@n(334)
    Para poder ejecutar algún código compilado al iniciar la máquina evaluadora,
    añadimos una @c(branch) instrucción al principio de la máquina evaluadora,
    lo que hace que la máquina vaya a un nuevo punto de entrada si el @c(flag)
    registro está establecido.@n(334)

#     ..src > scheme
#       ;; branches if @c(flag) is set:
#       (branch (label external-entry))
#       read-eval-print-loop
#         (perform (op initialize-stack))
#         …
#     < src..
    ..src > scheme
      ;; branches if @c(flag) is set:
      (branch (label external-entry))
      read-eval-print-loop
        (perform (op initialize-stack))
        …
    < src..

#     @c(External-entry) assumes that the machine is started with @c(val) containing
#     the location of an instruction sequence that puts a result into @c(val) and
#     ends with @c[(goto (reg continue))]. Starting at this entry point jumps to the
#     location designated by @c(val), but first assigns @c(continue) so that
#     execution will return to @c(print-result), which prints the value in @c(val)
#     and then goes to the beginning of the evaluator's read-eval-print loop.@n(335)
    @c(External-entry) Supone que la máquina se inicia con el @c(val) contenido
    de la ubicación de una secuencia de instrucciones que pone un resultado en
    @c(val) y termina con @c[(goto (reg continue))]. Comenzando en este punto de
    entrada salta a la ubicación designada por @c(val), pero primero asigna
    @c(continue) para que la ejecución regrese a @c(print-result), que imprime
    el valor en @c(val) y luego va al comienzo del lazo de lectura-eval-print
    del evaluador.@n(335)

#     ..src > scheme
#       external-entry
#         (perform (op initialize-stack))
#         (assign env (op get-global-environment))
#         (assign continue (label print-result))
#         (goto (reg val))
#     < src..
    ..src > scheme
      external-entry
        (perform (op initialize-stack))
        (assign env (op get-global-environment))
        (assign continue (label print-result))
        (goto (reg val))
    < src..

#     Now we can use the following procedure to compile a procedure definition,
#     execute the compiled code, and run the read-eval-print loop so we can try the
#     procedure. Because we want the compiled code to return to the location in
#     @c(continue) with its result in @c(val), we compile the expression with a
#     target of @c(val) and a linkage of @c(return). In order to transform the
#     object code produced by the compiler into executable instructions for the
#     evaluator register machine, we use the procedure @c(assemble) from the
#     register-machine simulator (section @l(#5.2.2)). We then initialize the @c(val)
#     register to point to the list of instructions, set the @c(flag) so that the
#     evaluator will go to @c(external-entry), and start the evaluator.
    Ahora podemos usar el siguiente procedimiento para compilar una definición
    de procedimiento, ejecutar el código compilado y ejecutar el bucle
    read-eval-print para poder probar el procedimiento. Debido a que queremos
    que el código compilado regrese a la ubicación @c(continue) con su resultado
    @c(val), compilamos la expresión con un objetivo @c(val) y un enlace de
    @c(return). Para transformar el código objeto producido por el compilador en
    instrucciones ejecutables para la máquina registradora evaluadora,
    utilizamos el procedimiento @c(assemble) del simulador registrador-máquina (
    @l(#5.2.2)). A continuación, inicializar el @c(val) registro para
    apuntar a la lista de instrucciones, establecer el @c(flag) para que el
    evaluador irá a @c(external-entry), e iniciar el evaluador.

#     ..src > scheme
#       (define (compile-and-go expression)
#         (let ((instructions
#                (assemble
#                 (statements
#                  (compile
#                   expression 'val 'return))
#                 eceval)))
#           (set! the-global-environment
#                 (setup-environment))
#           (set-register-contents!
#            eceval 'val instructions)
#           (set-register-contents!
#            eceval 'flag true)
#           (start eceval)))
#     < src..
    ..src > scheme
      (define (compile-and-go expression)
        (let ((instructions
               (assemble
                (statements
                 (compile
                  expression 'val 'return))
                eceval)))
          (set! the-global-environment
                (setup-environment))
          (set-register-contents!
           eceval 'val instructions)
          (set-register-contents!
           eceval 'flag true)
          (start eceval)))
    < src..

#     If we have set up stack monitoring, as at the end of section @l(#5.4.4), we can
#     examine the stack usage of compiled code:
    Si hemos configurado el monitoreo de la pila, como al final de
    @l(#5.4.4), podemos examinar el uso de la pila de código compilado:

#     ..srci > scheme
#       > (compile-and-go
#       ^  '(define (factorial n)
#       ^     (if (= n 1)
#       ^         1
#       ^         (* (factorial (- n 1)) n))))
#       (total-pushes = 0, maximum-depth = 0)
#       ;;; EC-Eval value:
#       ok
#       ;;; EC-Eval input:
#       > (factorial 5)
#       (total-pushes = 31, maximum-depth = 14)
#       ;;; EC-Eval value:
#       120
#     < srci..
    ..srci > scheme
      > (compile-and-go
      ^  '(define (factorial n)
      ^     (if (= n 1)
      ^         1
      ^         (* (factorial (- n 1)) n))))
      (total-pushes = 0, maximum-depth = 0)
      ;;; EC-Eval value:
      ok
      ;;; EC-Eval input:
      > (factorial 5)
      (total-pushes = 31, maximum-depth = 14)
      ;;; EC-Eval value:
      120
    < srci..

#     Compare this example with the evaluation of @c[(factorial 5)] using the
#     interpreted version of the same procedure, shown at the end of
#     @l(#5.4.4). The interpreted version required 144 pushes and a maximum stack
#     depth of 28. This illustrates the optimization that results from our
#     compilation strategy.
    Compare este ejemplo con la evaluación de @c[(factorial 5)] usar la versión
    interpretada del mismo procedimiento, que se muestra al final de
    @l(#5.4.4). La versión interpretada requiere 144 empujes y una
    profundidad de pila máxima de 28. Esto ilustra la optimización que resulta
    de nuestra estrategia de compilación.

# **** Interpretation and compilation
**** Interpretación y compilación

#      With the programs in this section, we can now experiment with the alternative
#      execution strategies of interpretation and compilation.@n(336) An interpreter
#      raises the machine to the level of the user program; a compiler lowers the
#      user program to the level of the machine language. We can regard the Scheme
#      language (or any programming language) as a coherent family of abstractions
#      erected on the machine language.  Interpreters are good for interactive
#      program development and debugging because the steps of program execution are
#      organized in terms of these abstractions, and are therefore more intelligible
#      to the programmer. Compiled code can execute faster, because the steps of
#      program execution are organized in terms of the machine language, and the
#      compiler is free to make optimizations that cut across the higher-level
#      abstractions.@n(337)
     Con los programas de esta sección, ahora podemos experimentar con las
     estrategias de ejecución alternativas de interpretación y
     compilación.@n(336) Un intérprete eleva la máquina al nivel del
     programa de usuario; Un compilador reduce el programa de usuario al nivel
     del lenguaje de máquina. Podemos considerar el lenguaje Scheme (o cualquier
     lenguaje de programación) como una familia coherente de abstracciones
     erigidas en el lenguaje máquina. Los intérpretes son buenos para el
     desarrollo y depuración interactivos del programa porque los pasos de la
     ejecución del programa están organizados en términos de estas abstracciones
     y, por lo tanto, son más inteligibles para el programador. El código
     compilado puede ejecutarse más rápido, ya que los pasos de la ejecución del
     programa están organizados en términos del lenguaje de la máquina, Y el
     compilador es libre de hacer optimizaciones que atraviesan las
     abstracciones de nivel superior.@n(337)

#      The alternatives of interpretation and compilation also lead to different
#      strategies for porting languages to new computers. Suppose that we wish to
#      implement Lisp for a new machine. One strategy is to begin with the
#      explicit-control evaluator of section @l(#5.4) and translate its instructions to
#      instructions for the new machine. A different strategy is to begin with the
#      compiler and change the code generators so that they generate code for the new
#      machine. The second strategy allows us to run any Lisp program on the new
#      machine by first compiling it with the compiler running on our original Lisp
#      system, and linking it with a compiled version of the run-time library.@n(338)
#      Better yet, we can compile the compiler itself, and run this on the new
#      machine to compile other Lisp programs.@n(339) Or we can compile one of the
#      interpreters of section @l(#4.1) to produce an interpreter that runs on the new
#      machine.
     Las alternativas de interpretación y compilación también llevan a
     diferentes estrategias para portar lenguajes a nuevas
     computadoras. Supongamos que deseamos implementar Lisp para una nueva
     máquina. Una estrategia es comenzar con el evaluador de control explícito
     de la seccion @l(#5.4) y traducir sus instrucciones a instrucciones para la nueva
     máquina. Una estrategia diferente es comenzar con el compilador y cambiar
     los generadores de código para que generen código para la nueva máquina. La
     segunda estrategia nos permite ejecutar cualquier programa Lisp en la nueva
     máquina compilándolo primero con el compilador que se ejecuta en nuestro
     sistema Lisp original y enlazándolo con una versión compilada de la
     libreria en tiempo de ejecución.@n(338) Mejor aún, podemos
     compilar el propio compilador y ejecutar esto en la nueva máquina para
     compilar otros programas Lisp.@n(339) @l(#4.1)

#      :: @t(Exercise 5.45) :: By comparing the stack operations used by compiled
#         code to the stack operations used by the evaluator for the same
#         computation, we can determine the extent to which the compiler optimizes
#         use of the stack, both in speed (reducing the total number of stack
#         operations) and in space (reducing the maximum stack depth). Comparing this
#         optimized stack use to the performance of a special-purpose machine for the
#         same computation gives some indication of the quality of the compiler.
     :: @t(Ejercicio 5.45) :: Al comparar las operaciones de pila utilizadas por
        el código compilado con las operaciones de pila utilizadas por el
        evaluador para el mismo cálculo, podemos determinar hasta qué punto el
        compilador optimiza el uso de la pila, tanto en velocidad (reduciendo el
        número total de operaciones de pila) como En el espacio (reduciendo la
        profundidad máxima de la pila). La comparación de este uso optimizado de
        la pila con el rendimiento de una máquina de propósito especial para el
        mismo cálculo da alguna indicación de la calidad del compilador.

#         1. @l(#Exercise 5.27) asked you to determine, as a function of @m(n), the
#            number of pushes and the maximum stack depth needed by the evaluator to
#            compute @m(n!)  using the recursive factorial procedure given
#            above. @l(#Exercise 5.14) asked you to do the same measurements for the
#            special-purpose factorial machine shown in @l(#Figure 5.11). Now perform
#            the same analysis using the compiled @c(factorial) procedure.
        1. @l(#Ejercicio 5.27) le pidió que determinara, como
           una función de @m(n), el número de empujes y la profundidad máxima de
           la pila que necesita el evaluador para calcular @m(n! )  Utilizando
           el procedimiento factorial recursivo dado
           anteriormente. @l(#Ejercicio 5.14) le pidió que
           hiciera las mismas mediciones para la máquina factorial de propósito
           especial que se muestra en la @l(#Figura 5.11). Ahora
           realice el mismo análisis utilizando el procedimiento @c(factorial)
           compilado.

#            Take the ratio of the number of pushes in the compiled version to the
#            number of pushes in the interpreted version, and do the same for the
#            maximum stack depth.  Since the number of operations and the stack depth
#            used to compute @m(n!)  are linear in @m(n), these ratios should
#            approach constants as @m(n) becomes large.  What are these constants?
#            Similarly, find the ratios of the stack usage in the special-purpose
#            machine to the usage in the interpreted version.
           Tome la proporción del número de empujes en la versión compilada con
           el número de empujes en la versión interpretada y haga lo mismo con
           la profundidad máxima de la pila. Dado que el número de operaciones y
           la profundidad de la pila utilizada para calcular @m(n! )  Son
           lineales en @m(n), estas relaciones deben acercarse a las constantes
           cuando @m(n se) hace grande. ¿Cuáles son estas constantes? Del mismo
           modo, encuentre las relaciones del uso de la pila en la máquina de
           propósito especial con el uso en la versión interpretada.

#            Compare the ratios for special-purpose versus interpreted code to the
#            ratios for compiled versus interpreted code. You should find that the
#            special-purpose machine does much better than the compiled code, since
#            the hand-tailored controller code should be much better than what is
#            produced by our rudimentary general-purpose compiler.
           Compare las relaciones entre el código de propósito especial y el
           interpretado a las relaciones entre código compilado y código
           interpretado. Usted debe encontrar que la máquina de propósito
           especial hace mucho mejor que el código compilado, ya que el código
           de controlador a mano a medida debe ser mucho mejor que lo que es
           producido por nuestro compilador rudimentario de propósito general.

#         2. Can you suggest improvements to the compiler that would help it generate
#            code that would come closer in performance to the hand-tailored version?
        2. ¿Puedes sugerir mejoras al compilador que ayudarían a generar código
           que se acercaría más en rendimiento a la versión a mano?

#      :: @t(Exercise 5.46) :: Carry out an analysis like the one in @l(#Exercise
#         5.45) to determine the effectiveness of compiling the tree-recursive
#         Fibonacci procedure
     :: @t(Ejercicio 5.46) :: Realizar un análisis como el del
        @l(#Ejercicio 5.45) para determinar la efectividad de la
        compilación del procedimiento arbóreo-recursivo de Fibonacci

#         ..src > scheme
#           (define (fib n)
#             (if (< n 2)
#                 n
#                 (+ (fib (- n 1)) (fib (- n 2)))))
#         < src..
        ..src > scheme
          (define (fib n)
            (if (< n 2)
                n
                (+ (fib (- n 1)) (fib (- n 2)))))
        < src..

#         compared to the effectiveness of using the special-purpose Fibonacci
#         machine of @l(#Figure 5.12). (For measurement of the interpreted
#         performance, see @l(#Exercise 5.29).)  For Fibonacci, the time resource
#         used is not linear in @m(n); hence the ratios of stack operations will not
#         approach a limiting value that is independent of @m(n).
        En comparación con la efectividad del uso de la máquina Fibonacci de
        propósito especial de la @l(#Figura 5.12). (Para la medida
        del rendimiento interpretado, véase el @l(#Ejercicio
        5.29) .) Para Fibonacci, el recurso de tiempo utilizado no es lineal en
        @m(n) ; Por lo tanto, las relaciones de las operaciones de la pila no se
        aproximarán a un valor límite que sea independiente de @m(n).

#      :: @t(Exercise 5.47) :: This section described how to modify the
#         explicit-control evaluator so that interpreted code can call compiled
#         procedures. Show how to modify the compiler so that compiled procedures can
#         call not only primitive procedures and compiled procedures, but interpreted
#         procedures as well. This requires modifying @c(compile-procedure-call) to
#         handle the case of compound (interpreted) procedures. Be sure to handle all
#         the same @c(target) and @c(linkage) combinations as in
#         @c(compile-proc-appl). To do the actual procedure application, the code
#         needs to jump to the evaluator's @c(compound-apply) entry point. This label
#         cannot be directly referenced in object code (since the assembler requires
#         that all labels referenced by the code it is assembling be defined there),
#         so we will add a register called @c(compapp) to the evaluator machine to
#         hold this entry point, and add an instruction to initialize it:
     :: @t(Ejercicio 5.47) :: En esta sección se describe cómo modificar el
        evaluador de control explícito para que el código interpretado pueda
        llamar a procedimientos compilados. Muestre cómo modificar el compilador
        para que los procedimientos compilados puedan llamar no sólo
        procedimientos primitivos y procedimientos compilados, sino también
        procedimientos interpretados. Esto requiere modificación
        @c(compile-procedure-call) para manejar el caso de los procedimientos
        compuestos (interpretados). Asegúrese de manejar todo igual @c(target) y
        @c(linkage) combinaciones como en @c(compile-proc-appl). Para hacer la
        aplicación de procedimiento real, el código necesita saltar al
        @c(compound-apply) punto de entrada del evaluador. Esta etiqueta no se
        puede referenciar directamente en el código de objeto (ya que el
        ensamblador requiere que todas las etiquetas referenciadas por el código
        que se está ensamblando se definen allí), por lo que agregará un
        registro llamado @c(compapp) a la máquina evaluadora para mantener este
        punto de entrada,

#         ..src > scheme
#             (assign compapp (label compound-apply))
#             ;; branches if @c(flag) is set:
#             (branch (label external-entry))
#           read-eval-print-loop …
#         < src..
        ..src > scheme
            (assign compapp (label compound-apply))
            ;; branches if @c(flag) is set:
            (branch (label external-entry))
          read-eval-print-loop …
        < src..

#         To test your code, start by defining a procedure @c(f) that calls a
#         procedure @c(g). Use @c(compile-and-go) to compile the definition of @c(f)
#         and start the evaluator. Now, typing at the evaluator, define @c(g) and try
#         to call @c(f).
        Para probar su código, comience definiendo un procedimiento @c(f) que
        llama a un procedimiento @c(g). Utilice @c(compile-and-go) para compilar
        la definición de @c(f) e iniciar el evaluador. Ahora, escribiendo en el
        evaluador, defina @c(g) e intente llamar @c(f).

#      :: @t(Exercise 5.48) :: The @c(compile-and-go) interface implemented in this
#         section is awkward, since the compiler can be called only once (when the
#         evaluator machine is started). Augment the compiler-interpreter interface
#         by providing a @c(compile-and-run) primitive that can be called from within
#         the explicit-control evaluator as follows:
     :: @t(Ejercicio 5.48) :: La @c(compile-and-go) interfaz implementada en
        esta sección es difícil, ya que el compilador sólo se puede llamar una
        vez (cuando se inicia la máquina evaluadora). Aumente la interfaz
        compilador-intérprete proporcionando una @c(compile-and-run) primitiva
        que se puede llamar desde el evaluador de control explícito de la
        siguiente manera:

#         ..srci > scheme
#           ;;; EC-Eval input:
#           > (compile-and-run
#           ^  '(define (factorial n)
#           ^     (if (= n 1)
#           ^         1
#           ^         (* (factorial (- n 1)) n))))
#           ;;; EC-Eval value:
#           ok
#           ;;; EC-Eval input:
#           > (factorial 5)
#           ;;; EC-Eval value:
#           120
#         < srci..
        ..srci > scheme
          ;;; EC-Eval input:
          > (compile-and-run
          ^  '(define (factorial n)
          ^     (if (= n 1)
          ^         1
          ^         (* (factorial (- n 1)) n))))
          ;;; EC-Eval value:
          ok
          ;;; EC-Eval input:
          > (factorial 5)
          ;;; EC-Eval value:
          120
        < srci..

#      :: @t(Exercise 5.49) :: As an alternative to using the explicit-control
#         evaluator's read-eval-print loop, design a register machine that performs a
#         read-compile-execute-print loop. That is, the machine should run a loop
#         that reads an expression, compiles it, assembles and executes the resulting
#         code, and prints the result. This is easy to run in our simulated setup,
#         since we can arrange to call the procedures @c(compile) and @c(assemble) as
#         @"(register-machine operations.)
     :: @t(Ejercicio 5.49) :: Como alternativa al uso del bucle de
        lectura-eval-print del evaluador de control explícito, diseñe una
        máquina de registro que realice un bucle read-compile-execute-print. Es
        decir, la máquina debe ejecutar un bucle que lee una expresión, compila,
        ensambla y ejecuta el código resultante, e imprime el resultado. Esto es
        fácil de ejecutar en nuestra configuración simulada, ya que podemos
        organizar para llamar a los procedimientos @c(compile) y @c(assemble)
        como @"(operaciones de máquina de registro.)

#      :: @t(Exercise 5.50) :: Use the compiler to compile the metacircular evaluator
#         of section @l(#4.1) and run this program using the register-machine simulator. (To
#         compile more than one definition at a time, you can package the definitions
#         in a @c(begin).)  The resulting interpreter will run very slowly because of
#         the multiple levels of interpretation, but getting all the details to work
#         is an instructive exercise.
     :: @t(Ejercicio 5.50) :: Utilice el compilador para compilar el evaluador
        metacircular de la seccion @l(#4.1) y ejecute este programa utilizando el
        simulador de registro-máquina. (Para compilar más de una definición a la
        vez, puede empaquetar las definiciones en a @c(begin).) El intérprete
        resultante se ejecutará muy lentamente debido a los múltiples niveles de
        interpretación, pero obtener todos los detalles para trabajar es un
        ejercicio instructivo.

#      :: @t(Exercise 5.51) :: Develop a rudimentary implementation of Scheme in C
#         (or some other low-level language of your choice) by translating the
#         explicit-control evaluator of section @l(#5.4) into C. In order to run this code
#         you will need to also provide appropriate storage-allocation routines and
#         other run-time support.
     :: @t(Ejercicio 5.51) :: Desarrolle una implementación rudimentaria de
        Scheme en C (o algún otro lenguaje de bajo nivel de su elección)
        traduciendo el evaluador de control explícito de la seccion @l(#5.4) en
        C. Para ejecutar este código, también deberá proporcionar rutinas de
        asignación de almacenamiento apropiadas y Otro soporte de tiempo de
        ejecución.

#      :: @t(Exercise 5.52) :: As a counterpoint to @l(#Exercise 5.51), modify the
#         compiler so that it compiles Scheme procedures into sequences of C
#         instructions. Compile the metacircular evaluator of section @l(#4.1) to produce a
#         Scheme interpreter written in C.
     :: @t(Ejercicio 5.52) :: Como contrapunto al @l(#Ejercicio
        5.51), modifique el compilador para que compile procedimientos Scheme en
        secuencias de instrucciones C. Compilar el evaluador metacircular de
        @l(#4.1) para producir un intérprete Scheme escrito en C.

# * References
* Referencias

#   @t(Abelson et al. 1992) Abelson, Harold, Andrew Berlin, Jacob Katzenelson,
#   William McAllister, Guillermo Rozas, Gerald Jay Sussman, and Jack
#   Wisdom. 1992. The Supercomputer Toolkit: A general framework for
#   special-purpose computing.  @q(International Journal of High-Speed
#   Electronics) 3(3): 337-361. @l(http://www.hpl.hp.com/techreports/94/HPL-94-30.html<>–›)
  @t(Abelson et al. 1992) Abelson, Harold, Andrew Berlín, Jacob Katzenelson,
  William McAllister, Guillermo Rozas, Gerald Jay Sussman y Jack
  Wisdom. 1992. The Supercomputer Toolkit: Un marco general para la computación
  de propósito especial.  @"(Revista Internacional de Electrónica de Alta
  Velocidad) 3 (3):
  337-361. @l(http://www.hpl.hp.com/techreports/94/HPL-94-30.html<>->)

#   @t(Allen 1978) Allen, John. 1978. @q(Anatomy of Lisp). New York: McGraw-Hill.
  @t(Allen 1978) Allen, John. 1978. @"(Anatomía de Lisp). Nueva York:
  McGraw-Hill.

#   @t(ANSI 1994) @A(ANSI) @A(X)3.226-1994. @q(American National Standard for
#   Information Systems––Programming Language––Common Lisp).
  @t(ANSI 1994 ) @A(ANSI ) @A(X) 3.226 - <span
  id="ANSI-1994">1994</span>. @"(Estándar Nacional Americano para Sistemas de
  Información - Lenguaje de Programación - Common Lisp).

#   @t(Appel 1987) Appel, Andrew W. 1987. Garbage collection can be faster than
#   stack allocation. @q(Information Processing Letters) 25(4): 275-279.
#   @l(https://www.cs.princeton.edu/~appel/papers/45.ps<>–›)
  @t(Appel 1987) Appel, Andrew W. 1987. La recolección de basura puede ser más
  rápida que la asignación de pila. @"(Cartas de procesamiento de información)
  25 (4): 275-279. @l(https://www.cs.princeton.edu/~appel/papers/45.ps<>->)

#   @t(Backus 1978) Backus, John. 1978. Can programming be liberated from the von
#   Neumann style?  @q(Communications of the @A(ACM)) 21(8): 613-641.
#   @l(http://worrydream.com/refs/Backus-CanProgrammingBeLiberated.pdf<>–›)
  @t(Backus 1978) Backus, John. 1978. ¿Se puede liberar la programación del
  estilo von Neumann?  @"(Comunicaciones de la @A(ACM)) 21 (8):
  613-641. @l(http://worrydream.com/refs/Backus-CanProgrammingBeLiberated.pdf<>->)

#   @t[Baker (1978)] Baker, Henry G., Jr. 1978. List processing in real time on a
#   serial computer.  @q(Communications of the @A(ACM)) 21(4): 280-293.
#   @l(http://dspace.mit.edu/handle/1721.1/41976<>–›)
  @t(Baker (1978)) Baker, Henry G., Jr. 1978. Enumerar el procesamiento en
  tiempo real en una computadora en serie.  @"(Comunicaciones de la @A(ACM)) 21
  (4): 280-293. @l(http://dspace.mit.edu/handle/1721.1/41976<>->)

#   @t(Batali et al. 1982) Batali, John, Neil Mayle, Howard Shrobe, Gerald Jay
#   Sussman, and Daniel Weise.
#   1982. The Scheme-81 architecture––System and chip. In @q(Proceedings of
#   the @A(MIT) Conference on Advanced Research in @A(VLSI)), edited by Paul
#   Penfield, Jr. Dedham, @A(MA): Artech House.
  @t(Batali et al. 1982) Batali, John, Neil Mayle, Howard Shrobe, Gerald Jay
  Sussman y Daniel Weise. 1982. La arquitectura Scheme-81 - Sistema y chip. En
  @"(Actas de la Conferencia del @A(MIT) sobre Investigación Avanzada en
  @A(VLSI)), editado por Paul Penfield, Jr. Dedham, @A(MA) : Artech House.

#   @t[Borning (1977)] Borning, Alan. 1977. ThingLab––An object-oriented system
#   for building simulations using constraints. In @q(Proceedings of the 5th
#   International Joint Conference on Artificial Intelligence).
#   @l(http://ijcai.org/Past%20Proceedings/IJCAI-77-VOL1/PDF/085.pdf<>–›)
  @t(Borning (1977)) Borning, Alan. 1977. ThingLab - Un sistema orientado a
  objetos para construir simulaciones usando limitaciones. En @"(Actas de la V
  Conferencia Internacional Conjunta sobre Inteligencia
  Artificial). @l(http://ijcai.org/Past%20Proceedings/IJCAI-77-VOL1/PDF/085.pdf<>->)

#   @t[Borodin and Munro (1975)] Borodin, Alan, and Ian Munro. 1975. @q(The
#   Computational Complexity of Algebraic and Numeric Problems). New York:
#   American Elsevier.
  @t(Borodin y Munro (1975)) Borodin, Alan y Ian Munro. 1975. @"(La complejidad
  computacional de los problemas algebraicos y numéricos). Nueva York: American
  Elsevier.

#   @t(Chaitin 1975) Chaitin, Gregory J. 1975. Randomness and mathematical proof.
#   @q(Scientific American) 232(5): 47-52.
#   @l(https://www.cs.auckland.ac.nz/~chaitin/sciamer.html<>–›)
  @t(Chaitin 1975) Chaitin, Gregory J. 1975. Aleatoriedad y prueba
  matemática. @"(Scientific American) 232 (5):
  47-52. @l(https://www.cs.auckland.ac.nz/~chaitin/sciamer.html<>->)

#   @t[Church (1941)] Church, Alonzo. 1941. @q(The Calculi of
#   Lambda-Conversion). Princeton, N.J.: Princeton University Press.
  @t(Iglesia (1941)) Iglesia, Alonzo. 1941. @"(Los Cálculos de
  Lambda-Conversión). Princeton, Nueva Jersey: Princeton University Press.

#   @t[Clark (1978)] Clark, Keith L. 1978. Negation as failure. In @q(Logic and
#   Data Bases).  New York: Plenum Press, pp. 293-322.
#   @l(http://www.doc.ic.ac.uk/~klc/neg.html<>–›)
  @t(Clark (1978)) Clark, Keith L. 1978. La negación como fracaso. En @"(Lógica
  y Bases de Datos). Nueva York: Plenum Press,
  pp. 293-322. @l(http://www.doc.ic.ac.uk/~klc/neg.html<>->)

#   @t[Clinger (1982)] Clinger, William. 1982. Nondeterministic call by need is
#   neither lazy nor by name. In @q(Proceedings of the @A(ACM) Symposium on Lisp
#   and Functional Programming), pp. 226-234.
  @t(Clinger (1982)) Clinger, William. 1982. La llamada no determinística por
  necesidad no es ni perezosa ni por nombre. En @"(Proceedings of the @A(ACM)
  Symposium on Lisp and Functional Programming), pp. 226-234.

#   @t(Clinger and Rees 1991) Clinger, William, and Jonathan Rees. 1991. Macros
#   that work. In @q(Proceedings of the 1991 @A(ACM) Conference on Principles of
#   Programming Languages), pp. 155-162.
#   @l(http://mumble.net/~jar/pubs/macros_that_work.ps<>–›)
  @t(Clinger y Rees 1991) Clinger, William y Jonathan Rees. 1991. Macros que
  funcionan. En @"(Actas de la Conferencia @A(ACM de) 1991 sobre Principios de
  Lenguajes de Programación),
  pp. 155-162. @l(http://mumble.net/~jar/pubs/macros_that_work.ps<>->)

#   @t(Colmerauer et al. 1973) Colmerauer A., H. Kanoui, R. Pasero, and
#   P. Roussel. 1973. Un système de communication homme-machine en
#   français. Technical report, Groupe Intelligence Artificielle, Université d'Aix
#   Marseille, Luminy.
#   @l(http://alain.colmerauer.free.fr/alcol/ArchivesPublications/HommeMachineFr/HoMa.pdf<>–›)
  @t(Colmerauer et al. 1973) Colmerauer A., H. Kanoui, R. Pasero y
  P. Roussel. 1973. Un syst

#   @t(Cormen et al. 1990) Cormen, Thomas, Charles Leiserson, and Ronald
#   Rivest. 1990. @q(Introduction to Algorithms). Cambridge, @A(MA): @A(MIT)
#   Press.
  @t(Cormen et al. 1990) Cormen, Thomas, Charles Leiserson y Ronald
  Rivest. 1990. @"(Introducción a los algoritmos). Cambridge, @A(MA) : Prensa
  del @A(MIT).

#   @t(Darlington et al. 1982) Darlington, John, Peter Henderson, and David
#   Turner. 1982. @q(Functional Programming and Its Applications). New York:
#   Cambridge University Press.
  @t(Darlington et al. 1982) Darlington, John, Peter Henderson y David
  Turner. 1982. @"(Programación funcional y sus aplicaciones). Nueva York:
  Cambridge University Press.

#   @t(Dijkstra 1968a) Dijkstra, Edsger W. 1968a. The structure of the @"(@A(THE))
#   multiprogramming system. @q(Communications of the @A(ACM)) 11(5): 341-346.
#   @l(http://www.cs.utexas.edu/users/EWD/ewd01xx/EWD196.PDF<>–›)
  @t(Dijkstra 1968a) Dijkstra, Edsger W. 1968a. La estructura de la @"(@A(EL))
  sistema de multiprogramación. @"(Comunicaciones de la @A(ACM)) 11 (5):
  341-346. @l(http://www.cs.utexas.edu/users/EWD/ewd01xx/EWD196.PDF<>->)

#   @t(1968b) Dijkstra, Edsger W. 1968b. Cooperating sequential processes. In
#   @q(Programming Languages), edited by F. Genuys. New York: Academic Press,
#   pp. 43-112.  @l(http://www.cs.utexas.edu/users/EWD/ewd01xx/EWD123.PDF<>–›)
  @t(1968b) Dijkstra, Edsger W. 1968b. Cooperación de procesos secuenciales. En
  @"(Lenguajes de Programación), editado por F. Genuys. Nueva York: Academic
  Press, pp. 43 - 112.
  @l(http://www.cs.utexas.edu/users/EWD/ewd01xx/EWD123.PDF<>->)

#   @t(Dinesman 1968) Dinesman, Howard P. 1968. @q(Superior Mathematical
#   Puzzles). New York: Simon and Schuster.
  @t(Dinesman 1968) Dinesman, Howard P. 1968. @"(Puzzles Matemáticos
  Superiores). Nueva York: Simon y Schuster.

#   @t(deKleer et al. 1977) deKleer, Johan, Jon Doyle, Guy Steele, and Gerald
#   J. Sussman. 1977.  @A(AMORD): Explicit control of reasoning. In @q(Proceedings
#   of the @A(ACM) Symposium on Artificial Intelligence and Programming
#   Languages), pp. 116-125.  @l(http://dspace.mit.edu/handle/1721.1/5750<>–›)
  @t(DeKleer et al. 1977) deKleer, Johan, Jon Doyle, Guy Steele y Gerald
  J. Sussman. 1977.  @A(AMORD) : Control explícito del razonamiento. En @"(Actas
  del Simposio @A(ACM) sobre Inteligencia Artificial y Lenguajes de
  Programación), pp. 116-125.
  @l(http://dspace.mit.edu/handle/1721.1/5750<>->)

#   @t[Doyle (1979)] Doyle, Jon. 1979. A truth maintenance system. @q(Artificial
#   Intelligence) 12: 231-272.  @l(http://dspace.mit.edu/handle/1721.1/5733<>–›)
  @t(Doyle (1979)) Doyle, Jon. 1979. Un sistema de mantenimiento de la
  verdad. @"(Inteligencia Artificial) 12: 231-272.
  @l(http://dspace.mit.edu/handle/1721.1/5733<>->)

#   @t(Feigenbaum and Shrobe 1993) Feigenbaum, Edward, and Howard
#   Shrobe. 1993. The Japanese National Fifth Generation Project: Introduction,
#   survey, and evaluation. In @q(Future Generation Computer Systems), vol. 9,
#   pp. 105-117.  @l(https://saltworks.stanford.edu/assets/kv359wz9060.pdf<>–›)
  @t(Feigenbaum y Shrobe 1993) Feigenbaum, Edward y Howard Shrobe. 1993. El
  Proyecto Nacional de la Quinta Generación de Japón: Introducción, encuesta y
  evaluación. En @"(Future Generation Computer Systems), vol. 9, págs. 105-117.
  @l(https://saltworks.stanford.edu/assets/kv359wz9060.pdf<>->)

#   @t[Feeley (1986)] Feeley, Marc. 1986. Deux approches à l'implantation du
#   language Scheme. Masters thesis, Université de Montréal.
#   @l(http://www.iro.umontreal.ca/~feeley/papers/FeeleyMSc.pdf<>–›)
  @t(Feeley (1986)) Feeley, Marc. 1986. Deux approches

#   @t(Feeley and Lapalme 1987) Feeley, Marc and Guy Lapalme. 1987. Using closures
#   for code generation.  @q(Journal of Computer Languages) 12(1): 47-66.
#   @l(http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.90.6978<>–›)
  @t(Feeley y Lapalme 1987) Feeley, Marc y Guy Lapalme. 1987. Uso de cierres
  para la generación de código.  @"(Journal of Computer Languages) 12 (1):
  47-66. @l(http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.90.6978<>->)

#   Feller, William. 1957. @q(An Introduction to Probability Theory and Its
#   Applications), volume 1. New York: John Wiley & Sons.
  Feller, William. 1957. @"(Introducción a la teoría de la probabilidad y sus
  aplicaciones), volumen 1. Nueva York: John Wiley & Sons.

#   @t[Fenichel and Yochelson (1969)] Fenichel, R., and J. Yochelson. 1969. A Lisp
#   garbage collector for virtual memory computer systems. @q(Communications of
#   the @A(ACM)) 12(11): 611-612.
#   @l(https://www.cs.purdue.edu/homes/hosking/690M/p611-fenichel.pdf<>–›)
  @t(Fenichel y Yochelson (1969)) Fenichel, R., y J. Yochelson. 1969. Un
  recolector de basura Lisp para sistemas de computadora de memoria
  virtual. @"(Comunicaciones de la @A(ACM)) 12 (11):
  611-612. @l(https://www.cs.purdue.edu/homes/hosking/690M/p611-fenichel.pdf<>->)

#   @t[Floyd (1967)] Floyd, Robert. 1967. Nondeterministic
#   algorithms. @q(@A(JACM)), 14(4): 636-644.
#   @l(http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.332.36<>–›)
  @t(Floyd (1967)) Floyd, Robert. 1967. Algoritmos no
  determinísticos. @"(@A(JACM)), 14 (4):
  636 - 644. @l(http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.332.36<>->)

#   @t(Forbus and deKleer 1993) Forbus, Kenneth D., and Johan
#   deKleer. 1993. @q(Building Problem Solvers). Cambridge, @A(MA): @A(MIT) Press.
  @t(Forbus y DeKleer 1993) Forbus, Kenneth D. y Johan de
  Kleer. 1993. @"(Construyendo Solucionadores de Problemas). Cambridge, @A(MA) :
  Prensa del @A(MIT).

#   @t[Friedman and Wise (1976)] Friedman, Daniel P., and David
#   S. Wise. 1976. @A(CONS) should not evaluate its arguments. In @q(Automata,
#   Languages, and Programming: Third International Colloquium), edited by
#   S. Michaelson and R. Milner, pp. 257-284.
#   @l(https://www.cs.indiana.edu/cgi-bin/techreports/TRNNN.cgi?trnum=TR44<>–›)
  @t(Friedman y Wise (1976)) Friedman, Daniel P. y David S. Wise. 1976. @A(CONS)
  no debe evaluar sus argumentos. En @"(Autómatas, Idiomas y Programación:
  Tercer Coloquio Internacional), editado por S. Michaelson y R. Milner,
  págs. 257-284. @l(https://www.cs.indiana.edu/cgi-bin/techreports/TRNNN.cgi?trnum=TR44<>->)

#   @t(Friedman et al. 1992) Friedman, Daniel P., Mitchell Wand, and Christopher
#   T. Haynes. 1992.  @q(Essentials of Programming Languages). Cambridge, @A(MA):
#   @A(MIT) Press/McGraw-Hill.
  @t(Friedman et al. 1992) Friedman, Daniel P., varita de Mitchell, y
  Christopher T. Haynes. 1992.  @"(Fundamentos de las lenguajes de
  programación). Cambridge, @A(MA) : Prensa del @A(MIT) / McGraw-Hill.

#   @t(Gabriel 1988) Gabriel, Richard P. 1988. The Why of @e(Y). @q(Lisp Pointers)
#   2(2): 15-25.  @l(http://www.dreamsongs.com/Files/WhyOfY.pdf<>–›)
  @t(Gabriel 1988) Gabriel, Richard P. 1988. El por qué de @e(Y). @"(Lisp
  Indicadores) 2 (2): 15-25.
  @l(http://www.dreamsongs.com/Files/WhyOfY.pdf<>->)

#   Goldberg, Adele, and David Robson. 1983. @q(Smalltalk-80: The Language and Its
#   Implementation). Reading, @A(MA): Addison-Wesley.
#   @l(http://stephane.ducasse.free.fr/FreeBooks/BlueBook/Bluebook.pdf<>–›)
  Goldberg, Adele y David Robson. 1983. @"(Smalltalk-80: El lenguaje y su
  implementación). Lectura, @A(MA) :
  Addison-Wesley. @l(http://stephane.ducasse.free.fr/FreeBooks/BlueBook/Bluebook.pdf<>->)

#   @t(Gordon et al. 1979) Gordon, Michael, Robin Milner, and Christopher
#   Wadsworth. 1979.  @q(Edinburgh @A(LCF)). Lecture Notes in Computer Science,
#   volume 78. New York: Springer-Verlag.
  @t(Gordon et al. 1979) Gordon, Michael, Robin Milner y Christopher
  Wadsworth. 1979.  @"(Edimburgo @A(LCF)). Notas de conferencia en Ciencias de
  la Computación, volumen 78. Nueva York: Springer-Verlag.

#   @t(Gray and Reuter 1993) Gray, Jim, and Andreas Reuter. 1993. @q(Transaction
#   Processing: Concepts and Models). San Mateo, @A(CA): Morgan-Kaufman.
  @t(Gray y Reuter 1993) Gray, Jim y Andreas Reuter. 1993. @"(Procesamiento de
  Transacciones: Conceptos y Modelos). San Mateo, @A(CA) : Morgan-Kaufman.

#   @t(Green 1969) Green, Cordell. 1969. Application of theorem proving to problem
#   solving. In @q(Proceedings of the International Joint Conference on Artificial
#   Intelligence), pp. 219-240.
#   @l(http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.81.9820<>–›)
  @t(Verde 1969) Verde, Cordell. 1969. Aplicación del teorema probando a la
  resolución de problemas. En @"(Actas de la Conferencia Internacional Conjunta
  sobre Inteligencia Artificial),
  pp. 219-240. @l(http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.81.9820<>->)

#   @t[Green and Raphael (1968)] Green, Cordell, and Bertram Raphael. 1968. The
#   use of theorem-proving techniques in question-answering systems. In
#   @q(Proceedings of the @A(ACM) National Conference), pp. 169-181.
#   @l(http://www.kestrel.edu/home/people/green/publications/green-raphael.pdf<>–›)
  @t(Verde y Raphael (1968)) Verde, Cordell, y Bertram Raphael. 1968. El uso de
  técnicas de prueba de teoremas en sistemas de respuesta a preguntas. En
  @"(Actas de la Conferencia Nacional @A(ACM)),
  pp. 169-181. @l(http://www.kestrel.edu/home/people/green/publications/green-raphael.pdf<>->)

#   @t(Griss 1981) Griss, Martin L. 1981. Portable Standard Lisp, a brief
#   overview. Utah Symbolic Computation Group Operating Note 58, University of
#   Utah.
  @t(Griss 1981) Griss, Martin L. 1981. Portable Lisp estándar, un breve
  resumen. Utah Symbolic Computation Group Nota de funcionamiento 58,
  Universidad de Utah.

#   @t(Guttag 1977) Guttag, John V. 1977. Abstract data types and the development
#   of data structures. @q(Communications of the @A(ACM)) 20(6): 396-404.
#   @l(http://www.unc.edu/~stotts/comp723/guttagADT77.pdf<>–›)
  @t(Guttag 1977) Guttag, John V. 1977. Tipos de datos abstractos y desarrollo
  de estructuras de datos. @"(Comunicaciones de la @A(ACM)) 20 (6):
  396-404. @l(http://www.unc.edu/~stotts/comp723/guttagADT77.pdf<>->)

#   @t(Hamming 1980) Hamming, Richard W. 1980. @q(Coding and Information
#   Theory). Englewood Cliffs, N.J.: Prentice-Hall.
  @t(Hamming 1980) Hamming, Richard W. 1980. @"(Codificación y teoría de la
  información). Englewood Cliffs, Nueva Jersey: Prentice-Hall.

#   @t(Hanson 1990) Hanson, Christopher P. 1990. Efficient stack allocation for
#   tail-recursive languages. In @q(Proceedings of @A(ACM) Conference on Lisp and
#   Functional Programming), pp. 106-118.
#   @l(https://groups.csail.mit.edu/mac/ftpdir/users/cph/links.ps.gz<>–›)
  @t(Hanson 1990) Hanson, Christopher P. 1990. Eficiente asignación de pila para
  los idiomas de cola-recursiva. En @"(Proceedings of @A(ACM) Conference on Lisp
  and Functional Programming),
  pp. 106-118. @l(https://groups.csail.mit.edu/mac/ftpdir/users/cph/links.ps.gz<>->)

#   @t(Hanson 1991) Hanson, Christopher P. 1991. A syntactic closures macro
#   facility. @q(Lisp Pointers), 4(3).
#   @l(http://groups.csail.mit.edu/mac/ftpdir/scheme-reports/synclo.ps<>–›)
  @t(Hanson 1991) Hanson, Christopher P. 1991. Una facilidad sintáctica de
  cierre macro. @"(Lisp Pointers), 4
  (3). @l(http://groups.csail.mit.edu/mac/ftpdir/scheme-reports/synclo.ps<>->)

#   @t(Hardy 1921) Hardy, Godfrey H. 1921. Srinivasa Ramanujan. @q(Proceedings of
#   the London Mathematical Society) @A(XIX)(2).
  @t(Hardy 1921) Hardy, Godfrey H. 1921. Srinivasa Ramanujan. @"(Actas de la
  Sociedad Matemática de Londres ) @A(XIX) (2).

#   @t(Hardy and Wright 1960) Hardy, Godfrey H., and E. M. Wright. 1960. @q(An
#   Introduction to the Theory of Numbers). 4th edition. New York: Oxford
#   University Press.
#   @l(https://archive.org/details/AnIntroductionToTheTheoryOfNumbers-4thEd-G.h.HardyE.m.Wright<>–›)
  @t(Hardy y Wright 1960) Hardy, Godfrey H. y EM Wright. 1960. @"(Introducción a
  la teoría de los números). 4ª edición. Nueva York: Oxford University
  Press. @l(https://archive.org/details/AnIntroductionToTheTheoryOfNumbers-4thEd-G.h.HardyE.m.Wright<>->)

#   @t[Havender (1968)] Havender, J. 1968. Avoiding deadlocks in multi-tasking
#   systems. @q(IBM Systems Journal) 7(2): 74-84.
  @t(Havender (1968)) Havender, J. 1968. Evitar los interbloqueos en los
  sistemas multitarea. @"(IBM Systems Journal) 7 (2): 74-84.

#   @t(Hearn 1969) Hearn, Anthony C. 1969. Standard Lisp. Technical report
#   @A(AIM)-90, Artificial Intelligence Project, Stanford University.
#   @l(http://www.softwarepreservation.org/projects/LISP/stanford/Hearn-StandardLisp-AIM-90.pdf<>–›)
  @t(Hearn 1969) Hearn, Anthony C. 1969. Lisp estándar. Informe técnico @A(AIM)
  -90, Proyecto de Inteligencia Artificial, Universidad de
  Stanford. @l(http://www.softwarepreservation.org/projects/LISP/stanford/Hearn-StandardLisp-AIM-90.pdf<>->)

#   @t(Henderson 1980) Henderson, Peter. 1980. @q(Functional Programming:
#   Application and Implementation). Englewood Cliffs, N.J.: Prentice-Hall.
  @t(Henderson 1980) Henderson, Peter. 1980. @"(Programación Funcional:
  Aplicación e Implementación). Englewood Cliffs, Nueva Jersey: Prentice-Hall.

#   @t(Henderson 1982) Henderson. Peter. 1982. Functional Geometry. In
#   @q(Conference Record of the 1982 @A(ACM) Symposium on Lisp and Functional
#   Programming), pp. 179-187.
#   @l(http://pmh-systems.co.uk/phAcademic/papers/funcgeo.pdf<>–›),
#   @l(http://eprints.soton.ac.uk/257577/1/funcgeo2.pdf<>2002 version –›)
  @t(Henderson 1982) Henderson. Peter. 1982. Geometría Funcional. En la
  @"(Conferencia de Registro del Simposio de @A(ACM) 1982 sobre Lisp y
  Programación Funcional),
  pp. 179-187. @l(http://pmh-systems.co.uk/phAcademic/papers/funcgeo.pdf<>->),
  @l(http://eprints.soton.ac.uk/257577/1/funcgeo2.pdf<>versión 2002 ->)

#   @t[Hewitt (1969)] Hewitt, Carl E. 1969. @A(PLANNER): A language for proving
#   theorems in robots. In @q(Proceedings of the International Joint Conference on
#   Artificial Intelligence), pp. 295-301.
#   @l(http://dspace.mit.edu/handle/1721.1/6171<>–›)
  @t(Hewitt (1969)) Hewitt, Carl E. 1969. @A(PLANIFICADOR) : Un lenguaje para
  probar teoremas en robots. En @"(Actas de la Conferencia Internacional
  Conjunta sobre Inteligencia Artificial),
  pp. 295-301. @l(http://dspace.mit.edu/handle/1721.1/6171<>->)

#   @t[Hewitt (1977)] Hewitt, Carl E. 1977. Viewing control structures as patterns
#   of passing messages. @q(Journal of Artificial Intelligence) 8(3): 323-364.
#   @l(http://dspace.mit.edu/handle/1721.1/6272<>–›)
  @t(Hewitt (1977)) Hewitt, Carl E. 1977. Visualización de estructuras de
  control como patrones de transmisión de mensajes. @"(Diario de Inteligencia
  Artificial) 8 (3):
  323-364. @l(http://dspace.mit.edu/handle/1721.1/6272<>->)

#   @t[Hoare (1972)] Hoare, C. A. R. 1972. Proof of correctness of data
#   representations.  @q(Acta Informatica) 1(1).
  @t(Hoare (1972)) Hoare, CAR 1972. Prueba de corrección de las representaciones
  de datos.  @"(Acta Informatica) 1 (1).

#   @t(Hodges 1983) Hodges, Andrew. 1983. @q(Alan Turing: The Enigma). New York:
#   Simon and Schuster.
  @t(Hodges 1983) Hodges, Andrew. 1983. @"(Alan Turing: El Enigma). Nueva York:
  Simon y Schuster.

#   @t(Hofstadter 1979) Hofstadter, Douglas R. 1979. @q(G@@"odel, Escher, Bach: An
#   Eternal Golden Braid). New York: Basic Books.
  @t(Hofstadter 1979) Hofstadter, Douglas R. 1979.

#   @t(Hughes 1990) Hughes, R. J. M. 1990. Why functional programming matters. In
#   @q(Research Topics in Functional Programming), edited by David
#   Turner. Reading, @A(MA): Addison-Wesley, pp. 17-42.
#   @l(http://www.cs.kent.ac.uk/people/staff/dat/miranda/whyfp90.pdf<>–›)
  @t(Hughes 1990) Hughes, RJM 1990. Por qué la programación funcional
  importa. En @"(Temas de Investigación en Programación Funcional), editado por
  David Turner. Reading, @A(MA) : Addison-Wesley, páginas
  17-42. @l(http://www.cs.kent.ac.uk/people/staff/dat/miranda/whyfp90.pdf<>->)

#   @t(IEEE 1990) @A(IEEE) Std 1178-1990. 1990. @q(@A(IEEE) Standard for the
#   Scheme Programming Language).
  @t(IEEE 1990 ) @A(IEEE) Std 1178-1990. 1990. @"(Norma )@"(@A(IEEE) para el
  Lenguaje de Programación del Scheme).

#   @t(Ingerman et al. 1960) Ingerman, Peter, Edgar Irons, Kirk Sattley, and
#   Wallace Feurzeig; assisted by M. Lind, Herbert Kanner, and Robert
#   Floyd. 1960. @A(THUNKS): A way of compiling procedure statements, with some
#   comments on procedure declarations.  Unpublished manuscript. (Also, private
#   communication from Wallace Feurzeig.)
  @t(Ingerman et al. 1960) Ingerman, Peter, Edgar Irons, Kirk Sattley y Wallace
  Feurzeig; Asistido por M. Lind, Herbert Kanner y Robert
  Floyd. 1960. @A(THUNKS) : Una manera de compilar las declaraciones del
  procedimiento, con algunos comentarios sobre las declaraciones de
  procedimiento. Manuscrito no publicado. (También, comunicación privada de
  Wallace Feurzeig.)

#   @t(Kaldewaij 1990) Kaldewaij, Anne. 1990. @q(Programming: The Derivation of
#   Algorithms). New York: Prentice-Hall.
  @t(Kaldewaij 1990) Kaldewaij, Anne. 1990. @"(Programación: Derivación de
  Algoritmos). Nueva York: Prentice-Hall.

#   @t[Knuth (1973)] Knuth, Donald E. 1973. @q(Fundamental Algorithms). Volume 1
#   of @q(The Art of Computer Programming). 2nd edition. Reading, @A(MA):
#   Addison-Wesley.
  @t(Knuth (1973)) Knuth, Donald E. 1973. @"(Algoritmos Fundamentales). Volumen
  1 de @"(El arte de la programación informática). 2ª edición. Lectura, @A(MA) :
  Addison-Wesley.

#   @t(Knuth 1981) Knuth, Donald E. 1981. @q(Seminumerical Algorithms). Volume 2
#   of @q(The Art of Computer Programming). 2nd edition. Reading, @A(MA):
#   Addison-Wesley.
  @t(Knuth 1981) Knuth, Donald E. 1981. @"(Algoritmos Seminuméricos). Volumen 2
  de @"(El arte de la programación informática). 2ª edición. Lectura, @A(MA) :
  Addison-Wesley.

#   @t(Kohlbecker 1986) Kohlbecker, Eugene Edmund, Jr. 1986. Syntactic extensions
#   in the programming language Lisp. Ph.D. thesis, Indiana University.
#   @l(http://www.ccs.neu.edu/scheme/pubs/dissertation-kohlbecker.pdf<>–›)
  @t(Kohlbecker 1986) Kohlbecker, Eugene Edmund, Jr. 1986. Extensiones
  sintácticas en el lenguaje de programación Lisp. Doctor en Filosofía. Tesis,
  Universidad de
  Indiana. @l(http://www.ccs.neu.edu/scheme/pubs/dissertation-kohlbecker.pdf<>->)

#   @t(Konopasek and Jayaraman 1984) Konopasek, Milos, and Sundaresan
#   Jayaraman. 1984. @q(The TK!Solver Book: A Guide to Problem-Solving in Science,
#   Engineering, Business, and Education). Berkeley, @A(CA): Osborne/McGraw-Hill.
  @t(Konopasek y Jayaraman 1984) Konopasek, Milos y Sundaresan
  Jayaraman. 1984. @"(The TK! Solver Book: Guía para la resolución de problemas
  en ciencias, ingeniería, negocios y educación). Berkeley, @A(CA) : Osborne /
  McGraw-Hill.

#   @t[Kowalski (1973; 1979)] Kowalski, Robert. 1973. Predicate logic as a
#   programming language. Technical report 70, Department of Computational Logic,
#   School of Artificial Intelligence, University of Edinburgh.
#   @l(http://www.doc.ic.ac.uk/~rak/papers/IFIP%2074.pdf<>–›)
  @t(Kowalski (1973, 1979)) Kowalski, Robert. 1973. Predicar la lógica como un
  lenguaje de programación. Informe técnico 70, Departamento de Lógica
  Computacional, Escuela de Inteligencia Artificial, Universidad de
  Edimburgo. @l(http://www.doc.ic.ac.uk/~rak/papers/IFIP%2074.pdf<>->)

#   Kowalski, Robert. 1979. @q(Logic for Problem Solving). New York:
#   North-Holland.
#   @l(http://www.doc.ic.ac.uk/%7Erak/papers/LogicForProblemSolving.pdf<>–›)
  Kowalski, Robert. 1979. @"(Lógica para la resolución de problemas). Nueva
  York: Norte de
  Holanda. @l(http://www.doc.ic.ac.uk/~rak/papers/LogicForProblemSolving.pdf<>->)

#   @t[Lamport (1978)] Lamport, Leslie. 1978. Time, clocks, and the ordering of
#   events in a distributed system. @q(Communications of the @A(ACM)) 21(7):
#   558-565.
#   @l(http://research.microsoft.com/en-us/um/people/lamport/pubs/time-clocks.pdf<>–›)
  @t(Lamport (1978)) Lamport, Leslie. 1978. Tiempo, relojes y el orden de los
  acontecimientos en un sistema distribuido. @"(Comunicaciones de la @A(ACM)) 21
  (7):
  558-565. @l(http://research.microsoft.com/en-us/um/people/lamport/pubs/time-clocks.pdf<>->)

#   @t(Lampson et al. 1981) Lampson, Butler, J. J. Horning, R. London,
#   J. G. Mitchell, and G. K. Popek.
#   1981. Report on the programming language Euclid. Technical report, Computer
#   Systems Research Group, University of Toronto.
#   @l(http://www.bitsavers.org/pdf/xerox/parc/techReports/CSL-81-12_Report_On_The_Programming_Language_Euclid.pdf<>–›)
  @t(Lampson et al. 1981) Lampson, Butler, JJ Horning, R. Londres, JG Mitchell,
  y GK Popek. 1981. Informe sobre el lenguaje de programación Euclid. Informe
  técnico, Computer Systems Research Group, Universidad de
  Toronto. @l(http://www.bitsavers.org/pdf/xerox/parc/techReports/CSL-81-12_Report_On_The_Programming_Language_Euclid.pdf<>->)

#   @t[Landin (1965)] Landin, Peter. 1965. A correspondence between Algol 60 and
#   Church's lambda notation: Part I. @q(Communications of the @A(ACM)) 8(2):
#   89-101.
  @t(Landin (1965)) Landin, Peter. 1965. Una correspondencia entre Algol 60 y la
  notación lambda de la Iglesia: Parte I. @"(Comunicaciones de la @A(ACM)) 8
  (2): 89-101.

#   @t(Lieberman and Hewitt 1983) Lieberman, Henry, and Carl E. Hewitt. 1983. A
#   real-time garbage collector based on the lifetimes of
#   objects. @q(Communications of the @A(ACM)) 26(6): 419-429.
#   @l(http://dspace.mit.edu/handle/1721.1/6335<>–›)
  @t(Lieberman y Hewitt 1983) Lieberman, Henry y Carl E. Hewitt. 1983. Un
  recolector de basura en tiempo real basado en la vida de
  objetos. @"(Comunicaciones de la @A(ACM)) 26 (6):
  419-429. @l(http://dspace.mit.edu/handle/1721.1/6335<>->)

#   @t[Liskov and Zilles (1975)] Liskov, Barbara H., and Stephen
#   N. Zilles. 1975. Specification techniques for data abstractions. @q(@A(IEEE)
#   Transactions on Software Engineering) 1(1): 7-19.
#   @l(http://csg.csail.mit.edu/CSGArchives/memos/Memo-117.pdf<>–›)
  @t(Liskov y Zilles (1975)) Liskov, Barbara H. y Stephen
  N. Zilles. 1975. Técnicas de especificación para abstracciones de
  datos. @"(@A(IEEE) Transacciones en Ingeniería de Software) 1 (1):
  7-19. @l(http://csg.csail.mit.edu/CSGArchives/memos/Memo-117.pdf<>->)

#   @t[McAllester (1978; 1980)] McAllester, David Allen. 1978. A three-valued
#   truth-maintenance system. Memo 473, @A(MIT) Artificial Intelligence
#   Laboratory.  @l(http://dspace.mit.edu/handle/1721.1/6296<>–›)
  @t(McAllester (1978, 1980)) McAllester, David Allen. 1978. Un sistema de
  mantenimiento de la verdad de tres valores. Memo 473, @A(Laboratorio de)
  Inteligencia Artificial del MIT.
  @l(http://dspace.mit.edu/handle/1721.1/6296<>->)

#   McAllester, David Allen. 1980. An outlook on truth maintenance. Memo 551,
#   @A(MIT) Artificial Intelligence Laboratory.
#   @l(http://dspace.mit.edu/handle/1721.1/6327<>–›)
  McAllester, David Allen. 1980. Una perspectiva sobre el mantenimiento de la
  verdad. Memo 551, @A(Laboratorio de) Inteligencia Artificial del
  MIT. @l(http://dspace.mit.edu/handle/1721.1/6327<>->)

#   @t(McCarthy 1960) McCarthy, John. 1960. Recursive functions of symbolic
#   expressions and their computation by machine. @q(Communications of the
#   @A(ACM)) 3(4): 184-195.
#   @l(http://www-formal.stanford.edu/jmc/recursive.pdf<>–›)
  @t(McCarthy 1960) McCarthy, John. 1960. Funciones recursivas de las
  expresiones simbólicas y su computación por máquina. @"(Comunicaciones de la
  @A(ACM)) 3 (4):
  184-195. @l(http://www-formal.stanford.edu/jmc/recursive.pdf<>->)

#   @t(McCarthy 1963) McCarthy, John. 1963. A basis for a mathematical theory of
#   computation. In @q(Computer Programming and Formal Systems), edited by
#   P. Braffort and D. Hirschberg. North-Holland.
#   @l(http://www-formal.stanford.edu/jmc/basis.html<>–›)
  @t(McCarthy 1963) McCarthy, John. 1963. Una base para una teoría matemática de
  la computación. En @"(Computer Programming and Formal Systems), editado por
  P. Braffort y D. Hirschberg. Norte de
  Holanda. @l(http://www-formal.stanford.edu/jmc/basis.html<>->)

#   @t(McCarthy 1978) McCarthy, John. 1978. The history of Lisp. In @q(Proceedings
#   of the @A(ACM) @A(SIGPLAN) Conference on the History of Programming
#   Languages).  @l(http://www-formal.stanford.edu/jmc/history/lisp/lisp.html<>–›)
  @t(McCarthy 1978) McCarthy, John. 1978. La historia de Lisp. En @"(Actas de la
  @A(Conferencia )@A(ACM ) @A(SIGPLAN) sobre Historia de los Lenguajes de
  Programación).
  @l(http://www-formal.stanford.edu/jmc/history/lisp/lisp.html<>->)

#   @t(McCarthy et al. 1965) McCarthy, John, P. W. Abrahams, D. J. Edwards,
#   T. P. Hart, and M. I. Levin.
#   1965. @q(Lisp 1.5 Programmer's Manual). 2nd edition. Cambridge, @A(MA):
#   @A(MIT) Press.
#   @l(http://www.softwarepreservation.org/projects/LISP/book/LISP%201.5%20Programmers%20Manual.pdf/view<>–›)
  @t(McCarthy et al. 1965) McCarthy, John, PW Abrahams, DJ Edwards, TP Hart y MI
  Levin. 1965. @"(Lisp 1.5 Manual del programador). 2ª edición. Cambridge,
  @A(MA) : Prensa del
  @A(MIT). @l(http://www.softwarepreservation.org/projects/LISP/book/LISP%201.5%20Programmers%20Manual.pdf/view<>->)

#   @t[McDermott and Sussman (1972)] McDermott, Drew, and Gerald Jay
#   Sussman. 1972. Conniver reference manual.  Memo 259, @A(MIT) Artificial
#   Intelligence Laboratory.  @l(http://dspace.mit.edu/handle/1721.1/6203<>–›)
  @t(McDermott y Sussman (1972)) McDermott, Drew, y Gerald Jay
  Sussman. 1972. Manual de referencia de Conniver. Memo 259, @A(Laboratorio de)
  Inteligencia Artificial del MIT.
  @l(http://dspace.mit.edu/handle/1721.1/6203<>->)

#   @t(Miller 1976) Miller, Gary L. 1976. Riemann's Hypothesis and tests for
#   primality.  @q(Journal of Computer and System Sciences) 13(3): 300-317.
#   @l(http://www.cs.cmu.edu/~glmiller/Publications/b2hd-Mi76.html<>–›)
  @t(Miller 1976) Miller, Gary L. 1976. Hipótesis de Riemann y pruebas de
  primalidad.  @"(Journal of Computer and System Sciences) 13 (3):
  300 - 317. @l(http://www.cs.cmu.edu/~glmiller/Publications/b2hd-Mi76.html<>->)

#   @t(Miller and Rozas 1994) Miller, James S., and Guillermo
#   J. Rozas. 1994. Garbage collection is fast, but a stack is faster. Memo 1462,
#   @A(MIT) Artificial Intelligence Laboratory.
#   @l(http://dspace.mit.edu/handle/1721.1/6622<>–›)
  @t(Miller y Rozas 1994) Miller, James S. y Guillermo J. Rozas. 1994. La
  recolección de basura es rápida, pero una pila es más rápida. Memo 1462,
  @A(Laboratorio de) Inteligencia Artificial del
  MIT. @l(http://dspace.mit.edu/handle/1721.1/6622<>->)

#   @t(Moon 1978) Moon, David. 1978. MacLisp reference manual,
#   Version 0. Technical report, @A(MIT) Laboratory for Computer Science.
#   @l(http://www.softwarepreservation.org/projects/LISP/MIT/Moon-MACLISP_Reference_Manual-Apr_08_1974.pdf/view<>–›)
  @t(Luna 1978) Luna, David. 1978. Manual de referencia de MacLisp,
  Versión 0. Informe técnico, @A(MIT) Laboratory for Computer
  Science. @l(http://www.softwarepreservation.org/projects/LISP/MIT/Moon-MACLISP_Reference_Manual-Apr_08_1974.pdf/view<>->)

#   @t(Moon and Weinreb 1981) Moon, David, and Daniel Weinreb. 1981. Lisp machine
#   manual. Technical report, @A(MIT) Artificial Intelligence Laboratory.
#   @l(http://www.unlambda.com/lmman/index.html<>–›)
  @t(Luna y Weinreb 1981) Luna, David y Daniel Weinreb. 1981. Manual de la
  máquina Lisp. Informe técnico, @A(Laboratorio de) Inteligencia Artificial del
  MIT. @l(http://www.unlambda.com/lmman/index.html<>->)

#   @t(Morris et al. 1980) Morris, J. H., Eric Schmidt, and Philip
#   Wadler. 1980. Experience with an applicative string processing language. In
#   @q(Proceedings of the 7th Annual @A(ACM) @A(SIGACT)/@A(SIGPLAN) Symposium on
#   the Principles of Programming Languages).
  @t(Morris et al. 1980) Morris, JH, Eric Schmidt y Philip
  Wadler. 1980. Experiencia con un lenguaje de procesamiento de cadenas
  aplicacional. En @"(Actas del VII Simposio Anual @A(ACM ) @A(SIGACT) /
  @A(SIGPLAN) sobre los Principios de las Lenguajes de Programación).

#   @t(Phillips 1934) Phillips, Hubert. 1934. @q(The Sphinx Problem Book). London:
#   Faber and Faber.
  @t(Phillips 1934) Phillips, Hubert. 1934. @"(El libro del problema de la
  esfinge). Londres: Faber y Faber.

#   @t(Pitman 1983) Pitman, Kent. 1983. The revised MacLisp Manual (Saturday
#   evening edition).  Technical report 295, @A(MIT) Laboratory for Computer
#   Science.  @l(http://maclisp.info/pitmanual<>–›)
  @t(Pitman 1983) Pitman, Kent. 1983. El manual revisado de MacLisp (edición de
  sábado por la tarde). Informe técnico 295, @A(MIT) Laboratorio de Informática.
  @l(http://maclisp.info/pitmanual<>->)

#   @t(Rabin 1980) Rabin, Michael O. 1980. Probabilistic algorithm for testing
#   primality.  @q(Journal of Number Theory) 12: 128-138.
  @t(Rabin 1980) Rabin, Michael O. 1980. Algoritmo probabilístico para probar
  primalidad.  @"(Journal of Number Theory) 12: 128-138.

#   @t(Raymond 1993) Raymond, Eric. 1993. @q(The New Hacker's Dictionary). 2nd
#   edition.  Cambridge, @A(MA): @A(MIT) Press.
#   @l(http://www.catb.org/jargon/<>–›)
  @t(Raymond 1993) Raymond, Eric. 1993. @"(El Nuevo Diccionario Hacker). 2ª
  edición. Cambridge, @A(MA) : Prensa del
  @A(MIT). @l(http://www.catb.org/jargon/<>->)

#   Raynal, Michel. 1986. @q(Algorithms for Mutual Exclusion). Cambridge, @A(MA):
#   @A(MIT) Press.
  Raynal, Michel. 1986. @"(Algoritmos para la Exclusión Mutua). Cambridge,
  @A(MA) : Prensa del @A(MIT).

#   @t(Rees and Adams 1982) Rees, Jonathan A., and Norman I. Adams IV. 1982. T: A
#   dialect of Lisp or, lambda: The ultimate software tool. In @q(Conference
#   Record of the 1982 @A(ACM) Symposium on Lisp and Functional Programming),
#   pp. 114-122.  @l(http://people.csail.mit.edu/riastradh/t/adams82t.pdf<>–›)
  @t(Rees y Adams 1982) Rees, Jonathan A. y Norman I. Adams IV. 1982. T: Un
  dialecto de Lisp o, lambda: La última herramienta de software. En el
  @"(Registro de Conferencia del Simposio @A(ACM de) 1982 sobre Lisp y
  Programación Funcional), pp. 114-122.
  @l(http://people.csail.mit.edu/riastradh/t/adams82t.pdf<>->)

#   Rees, Jonathan, and William Clinger (eds). 1991. The revised⁴ report on the
#   algorithmic language Scheme. @q(Lisp Pointers), 4(3).
#   @l(http://people.csail.mit.edu/jaffer/r4rs.pdf<>–›)
  Rees, Jonathan y William Clinger (eds). 1991. El informe revisado4 sobre el
  Scheme del lenguaje algorítmico. @"(Lisp Pointers), 4
  (3). @l(http://people.csail.mit.edu/jaffer/r4rs.pdf<>->)

#   @t[Rivest et al. (1977)] Rivest, Ronald, Adi Shamir, and Leonard
#   Adleman. 1977. A method for obtaining digital signatures and public-key
#   cryptosystems. Technical memo @A(LCS)/@A(TM82), @A(MIT) Laboratory for
#   Computer Science.  @l(http://people.csail.mit.edu/rivest/Rsapaper.pdf<>–›)
  @t(Rivest et al. (1977)) Rivest, Ronald, Adi Shamir y Leonard
  Adleman. 1977. Método para obtener firmas digitales y criptosistemas de clave
  pública. Nota técnica @A(LCS) / @A(TM82), @A(MIT) Laboratorio de Informática.
  @l(http://people.csail.mit.edu/rivest/Rsapaper.pdf<>->)

#   @t(Robinson 1965) Robinson, J. A. 1965. A machine-oriented logic based on the
#   resolution principle. @q(Journal of the @A(ACM)) 12(1): 23.
  @t(Robinson 1965) Robinson, JA 1965. Una lógica orientada a la máquina basada
  en el principio de resolución. @"(Diario de la @A(ACM)) 12 (1): 23.

#   @t(Robinson 1983) Robinson, J. A. 1983. Logic programming––Past, present, and
#   future.  @q(New Generation Computing) 1: 107-124.
  @t(Robinson 1983) Robinson, JA 1983. Programación lógica - pasado, presente y
  futuro.  @"(Computación de Nueva Generación) 1: 107-124.

#   @t(Spafford 1989) Spafford, Eugene H. 1989. The Internet Worm: Crisis and
#   aftermath.  @q(Communications of the @A(ACM)) 32(6): 678-688.
#   @l(http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.123.8503&rep=rep1&type=pdf<>–›)
  @t(Spafford 1989) Spafford, Eugene H. 1989. El Gusano de Internet: Crisis y
  consecuencias.  @"(Comunicaciones de la @A(ACM)) 32 (6):
  678-688. @l(http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.123.8503&rep=rep1&type=pdf<>->)

#   @t(Steele 1977) Steele, Guy Lewis, Jr. 1977. Debunking the @"(expensive
#   procedure call) myth.  In @q(Proceedings of the National Conference of the
#   @A(ACM)), pp. 153-62.  @l(http://dspace.mit.edu/handle/1721.1/5753<>–›)
  @t(Steele 1977) Steele, Guy Lewis, Jr. 1977. Desmantelando el @"(costoso
  procedimiento llamado) mito. En @"(Actas de la Conferencia Nacional de la
  @A(ACM)), pp. 153-62.  @l(http://dspace.mit.edu/handle/1721.1/5753<>->)

#   @t(Steele 1982) Steele, Guy Lewis, Jr. 1982. An overview of Common Lisp. In
#   @q(Proceedings of the @A(ACM) Symposium on Lisp and Functional Programming),
#   pp. 98-107.
  @t(Steele 1982) Steele, Guy Lewis, Jr. 1982. Una visión general de Common
  Lisp. En @"(Proceedings of the @A(ACM) Symposium on Lisp and Functional
  Programming), pp. 98-107.

#   @t(Steele 1990) Steele, Guy Lewis, Jr. 1990. @q(Common Lisp: The
#   Language). 2nd edition.  Digital Press.
#   @l(http://www.cs.cmu.edu/Groups/AI/html/cltl/cltl2.html<>–›)
  @t(Steele 1990) Steele, Guy Lewis, Jr. 1990. @"(Common Lisp: El lenguaje). 2ª
  edición. Prensa
  digital. @l(http://www.cs.cmu.edu/Groups/AI/html/cltl/cltl2.html<>->)

#   @t(Steele and Sussman 1975) Steele, Guy Lewis, Jr., and Gerald Jay
#   Sussman. 1975. Scheme: An interpreter for the extended lambda calculus. Memo
#   349, @A(MIT) Artificial Intelligence Laboratory.
#   @l(http://dspace.mit.edu/handle/1721.1/5794<>–›)
  @t(Steele y Sussman 1975) Steele, Guy Lewis, Jr., y Gerald Jay
  Sussman. 1975. Scheme: Un intérprete para el cálculo lambda extendido. Memo
  349, @A(Laboratorio de) Inteligencia Artificial del
  MIT. @l(http://dspace.mit.edu/handle/1721.1/5794<>->)

#   @t(Steele et al. 1983) Steele, Guy Lewis, Jr., Donald R. Woods, Raphael
#   A. Finkel, Mark R. Crispin, Richard M. Stallman, and Geoffrey
#   S. Goodfellow. 1983. @q(The Hacker's Dictionary). New York: Harper & Row.
#   @l(http://www.dourish.com/goodies/jargon.html<>–›)
  @t(Steele et al. 1983) Steele, Guy Lewis, Jr., Donald R. Woods, Raphael
  A. Finkel, Mark R. Crispin, Richard M. Stallman y Geoffrey
  S. Goodfellow. 1983. @"(El Diccionario del Hacker). Nueva York: Harper &
  Row. @l(http://www.dourish.com/goodies/jargon.html<>->)

#   @t(Stoy 1977) Stoy, Joseph E. 1977. @q(Denotational Semantics). Cambridge,
#   @A(MA): @A(MIT) Press.
  @t(Stoy 1977) Stoy, Joseph E. 1977. @"(Semántica Denotational). Cambridge,
  @A(MA) : Prensa del @A(MIT).

#   @t(Sussman and Stallman 1975) Sussman, Gerald Jay, and Richard
#   M. Stallman. 1975. Heuristic techniques in computer-aided circuit
#   analysis. @q(@A(IEEE) Transactions on Circuits and Systems) @A(CAS)-22(11):
#   857-865.  @l(http://dspace.mit.edu/handle/1721.1/5803<>–›)
  @t(Sussman y Stallman 1975) Sussman, Gerald Jay y Richard
  M. Stallman. 1975. Técnicas heurísticas en el análisis de circuitos asistidos
  por ordenador. @"(@A(IEEE) Transacciones en Circuitos y Sistemas ) @A(CAS-) 22
  (11): 857-865.  @l(http://dspace.mit.edu/handle/1721.1/5803<>->)

#   @t(Sussman and Steele 1980) Sussman, Gerald Jay, and Guy Lewis Steele
#   Jr. 1980. Constraints––A language for expressing almost-hierachical
#   descriptions. @q(AI Journal) 14: 1-39.
#   @l(http://dspace.mit.edu/handle/1721.1/6312<>–›)
  @t(Sussman y Steele 1980) Sussman, Gerald Jay y Guy Lewis Steele
  Jr. 1980. Restricciones - Un lenguaje para expresar descripciones casi
  jerárquicas. @"(AI Journal) 14:
  1-39. @l(http://dspace.mit.edu/handle/1721.1/6312<>->)

#   @t(Sussman and Wisdom 1992) Sussman, Gerald Jay, and Jack
#   Wisdom. 1992. Chaotic evolution of the solar system. @q(Science) 257: 256-262.
#   @l(http://groups.csail.mit.edu/mac/users/wisdom/ss-chaos.pdf<>–›)
  @t(Sussman y Wisdom 1992) Sussman, Gerald Jay y Jack
  Wisdom. 1992. Evolución caótica del sistema solar. @"(Science) 257:
  256 - 262. @l(http://groups.csail.mit.edu/mac/users/wisdom/ss-chaos.pdf<>->)

#   @t[Sussman et al. (1971)] Sussman, Gerald Jay, Terry Winograd, and Eugene
#   Charniak. 1971. Microplanner reference manual. Memo 203@A(A), @A(MIT)
#   Artificial Intelligence Laboratory.
#   @l(http://dspace.mit.edu/handle/1721.1/6184<>–›)
  @t(Sussman et al. (1971)) Sussman, Gerald Jay, Terry Winograd y Eugene
  Charniak. 1971. Manual de referencia de Microplanner. Memo 203 @A(A),
  @A(Laboratorio de) Inteligencia Artificial del
  MIT. @l(http://dspace.mit.edu/handle/1721.1/6184<>->)

#   @t[Sutherland (1963)] Sutherland, Ivan E. 1963. @A(SKETCHPAD): A man-machine
#   graphical communication system. Technical report 296, @A(MIT) Lincoln
#   Laboratory.  @l(https://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-574.pdf<>–›)
  @t(Sutherland (1963)) Sutherland, Ivan E. 1963. @A(SKETCHPAD) : Un sistema de
  comunicación gráfica hombre-máquina. Informe técnico 296, @A(MIT) Lincoln
  Laboratory.
  @l(https://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-574.pdf<>->)

#   @t(Teitelman 1974) Teitelman, Warren. 1974. Interlisp reference
#   manual. Technical report, Xerox Palo Alto Research Center.
#   @l(http://www.softwarepreservation.org/projects/LISP/interlisp/Interlisp-Oct_1974.pdf/view<>–›)
  @t(Teitelman 1974) Teitelman, Warren. 1974. Manual de referencia
  Interlisp. Informe técnico, Centro de Investigación Xerox Palo
  Alto. @l(http://www.softwarepreservation.org/projects/LISP/interlisp/Interlisp-Oct_1974.pdf/view<>->)

#   @t(Thatcher et al. 1978) Thatcher, James W., Eric G. Wagner, and Jesse
#   B. Wright. 1978. Data type specification: Parameterization and the power of
#   specification techniques. In @q(Conference Record of the Tenth Annual @A(ACM)
#   Symposium on Theory of Computing), pp. 119-132.
  @t(Thatcher et al. 1978) Thatcher, James W., Eric G. Wagner y Jesse
  B. Wright. 1978. Especificación del tipo de datos: Parametrización y la
  potencia de las técnicas de especificación. En el @"(Registro de Conferencia
  del Décimo Simposio Anual @A(ACM) sobre Teoría de la Computación),
  pp. 119-132.

#   @t(Turner 1981) Turner, David. 1981. The future of applicative languages. In
#   @q(Proceedings of the 3rd European Conference on Informatics), Lecture Notes
#   in Computer Science, volume 123. New York: Springer-Verlag, pp. 334-348.
  @t(Turner 1981) Turner, David. 1981. El futuro de los lenguajes aplicables. En
  @"(Actas de la III Conferencia Europea de Informática), Notas de Ponencia en
  Ciencias de la Computación, volumen 123. Nueva York: Springer-Verlag,
  pp. 334-348.

#   @t(Wand 1980) Wand, Mitchell. 1980. Continuation-based program transformation
#   strategies.  @q(Journal of the @A(ACM)) 27(1): 164-180.
#   @l(http://www.diku.dk/OLD/undervisning/2005e/224/papers/Wand80.pdf<>–›)
  @t(Wand 1980) Wand, Mitchell. 1980. Estrategias de transformación de programas
  basadas en la continuidad.  @"(Diario de la @A(ACM)) 27 (1):
  164-180. @l(http://www.diku.dk/OLD/undervisning/2005e/224/papers/Wand80.pdf<>->)

#   @t[Waters (1979)] Waters, Richard C. 1979. A method for analyzing loop
#   programs.  @q(@A(IEEE) Transactions on Software Engineering) 5(3): 237-247.
  @t(Waters (1979)) Waters, Richard C. 1979. Un método para analizar programas
  de bucle.  @"(@A(IEEE) Transacciones en Ingeniería de Software) 5 (3):
  237-247.

#   Winograd, Terry. 1971. Procedures as a representation for data in a computer
#   program for understanding natural language. Technical report @A(AI TR)-17,
#   @A(MIT) Artificial Intelligence Laboratory.
#   @l(http://dspace.mit.edu/handle/1721.1/7095<>–›)
  Winograd, Terry. 1971. Procedimientos como representación de datos en un
  programa informático para comprender el lenguaje natural. Informe técnico
  @A(AI TR-) 17, @A(MIT) Laboratorio de Inteligencia
  Artificial. @l(http://dspace.mit.edu/handle/1721.1/7095<>->)

#   @t(Winston 1992) Winston, Patrick. 1992. @q(Artificial Intelligence). 3rd
#   edition. Reading, @A(MA): Addison-Wesley.
  @t(Winston 1992) Winston, Patrick. 1992. @"(Inteligencia Artificial). 3ª
  edición. Lectura, @A(MA) : Addison-Wesley.

#   @t(Zabih et al. 1987) Zabih, Ramin, David McAllester, and David
#   Chapman. 1987. Non-deterministic Lisp with dependency-directed
#   backtracking. @q(@A(AAAI)-87), pp. 59-64.
#   @l(http://www.aaai.org/Papers/AAAI/1987/AAAI87-011.pdf<>–›)
  @t(Zabih et al. 1987) Zabih, Ramin, David McAllester y David
  Chapman. 1987. Lisp no determinista con backtracking dirigido por
  dependencia. @"(@A(AAAI -) 87), páginas
  59 - 64. @l(http://www.aaai.org/Papers/AAAI/1987/AAAI87-011.pdf<>->)

#   @t[Zippel (1979)] Zippel, Richard. 1979. Probabilistic algorithms for sparse
#   polynomials.  Ph.D. dissertation, Department of Electrical Engineering and
#   Computer Science, @A(MIT).
  @t(Zippel (1979)) Zippel, Richard. 1979. Algoritmos probabilísticos para
  polinomios escasos. Doctor en Filosofía. Disertación, Departamento de
  Ingeniería Eléctrica y Ciencias de la Computación, @A(MIT).

#   @t(Zippel 1993) Zippel, Richard. 1993. @q(Effective Polynomial
#   Computation). Boston, @A(MA): Kluwer Academic Publishers.
  @t(Zippel 1993) Zippel, Richard. 1993. @"(Computación Polinómica
  Efectiva). Boston, @A(MA) : Editores académicos de Kluwer.

# * Colophon
* Colofón

#   On the cover page is Agostino Ramelli's bookwheel mechanism from 1588. It
#   could be seen as an early hypertext navigation aid. This image of the
#   engraving is hosted by J. E. Johnson of
#   @l(http://newgottland.com/2012/02/09/before-the-ereader-there-was-the-wheelreader/ramelli_bookwheel_1032px/<>New
#   Gottland).
  En la portada está el mecanismo del libro de Agostino Ramelli de 1588. Podría
  ser visto como una ayuda temprana de la navegación del hipertexto. Esta imagen
  del grabado está organizada por JE Johnson de
  @l(http://newgottland.com/2012/02/09/before-the-ereader-there-was-the-wheelreader/ramelli_bookwheel_1032px/<>New
  Gottland).

#   The typefaces are Linux Libertine for body text and Linux Biolinum for
#   headings, both by Philipp H. Poll. Typewriter face is Inconsolata created by
#   Raph Levien and supplemented by Dimosthenis Kaponis and Takashi Tanigawa in
#   the form of Inconsolata LGC.
  Los tipos de letra son Linux Libertine para texto de cuerpo y Linux Biolinum
  para encabezamientos, ambos de Philipp H. Poll. La cara de la máquina de
  escribir es Inconsolata creado por Raph Levien y suplementado por Dimosthenis
  Kaponis y Takashi Tanigawa en la forma de Inconsolata LGC.

#   Graphic design and typography are done by Andres Raba. Texinfo source is
#   converted to @A(HTML) using a customized version of @c(texi2any) utility in
#   Texinfo 5.1 package. Diagrams are drawn with Inkscape and mathematics is
#   typeset with the help of MathJax and MathML.
  El diseño gráfico y la tipografía son realizados por Andrés Raba. La fuente de
  Texinfo se convierte al @A(HTML) usando una versión modificada para requisitos
  particulares de la @c(texi2any) utilidad en el paquete de Texinfo 5.1. Los
  diagramas se dibujan con Inkscape y las matemáticas se componen con la ayuda
  de MathJax y MathML.

# * Notes
* Notas

#   :: @N(1) :: The @q(Lisp 1 Programmer's Manual) appeared in 1960 and the
#      @q(Lisp 1.5 Programmer's Manual) (@l(#McCarthy et al. 1965)) was published
#      in 1962. The early history of Lisp is described in @l(#McCarthy 1978).
  :: @N(1) :: El @q(Manual del Programador Lisp 1) apareció en 1960 y el
     @q(Manual del Programador Lisp 1.5) (@l(#McCarthy et al. 1965)) fue
     publicado en 1962. La historia temprana de Lisp se describe en
     @l(#McCarthy 1978).

#   :: @N(2) :: The two dialects in which most major Lisp programs of the 1970s
#      were written are MacLisp (@l(#Moon 1978); @l(#Pitman 1983)), developed at
#      the @A(MIT) Project @A(MAC), and Interlisp (@l(#Teitelman 1974)), developed
#      at Bolt Beranek and Newman Inc. and the Xerox Palo Alto Research Center.
#      Portable Standard Lisp (@l(#Hearn 1969); @l(#Griss 1981)) was a Lisp
#      dialect designed to be easily portable between different machines. MacLisp
#      spawned a number of subdialects, such as Franz Lisp, which was developed at
#      the University of California at Berkeley, and Zetalisp (@l(#Moon and
#      Weinreb 1981)), which was based on a special-purpose processor designed at
#      the @A(MIT) Artificial Intelligence Laboratory to run Lisp very
#      efficiently. The Lisp dialect used in this book, called Scheme (@l(#Steele
#      and Sussman 1975)), was invented in 1975 by Guy Lewis Steele Jr. and Gerald
#      Jay Sussman of the @A(MIT) Artificial Intelligence Laboratory and later
#      reimplemented for instructional use at @A(MIT). Scheme became an @A(IEEE)
#      standard in 1990 (@l(#IEEE 1990)). The Common Lisp dialect (@l(#Steele
#      1982), @l(#Steele 1990)) was developed by the Lisp community to combine
#      features from the earlier Lisp dialects to make an industrial standard for
#      Lisp. Common Lisp became an @A(ANSI) standard in 1994 (@l(#ANSI 1994)).
  :: @N(2) :: En los 1970s los dos dialectos en los que la mayoria de los
     principales programas Lisp estaban escritos fueron MacLisp (@l(#Moon 1978),
     @l(#Pitman 1983)), desarrollado en el @A(MIT) Project @A(MAC), e Interlisp
     (@l(#Teitelman 1974)), desarrollado en Bolt Beranek y Newman Inc. y el
     Xerox Palo Alto Research Center. Portable Standard Lisp (@l(#Hearn 1969),
     @l(#Griss 1981)) era un dialecto Lisp diseñado para ser fácilmente portátil
     entre diferentes máquinas. MacLisp generó una serie de subdialectos, como
     Franz Lisp, que se desarrolló en la Universidad de California en Berkeley,
     y Zetalisp (@l(#Moon y Weinreb 1981)), Que se basó en un procesador de
     propósito especial diseñado en el Laboratorio de Inteligencia Artificial
     del @A(MIT) para ejecutar Lisp de manera muy eficiente. El dialecto Lisp
     utilizado en este libro, llamado Scheme (@l(#Steele y Sussman 1975)), fue
     inventado en 1975 por Guy Lewis Steele Jr. y Gerald Jay Sussman del
     Laboratorio de Inteligencia Artificial del @A(MIT) y más tarde
     reimplementada para uso didactico en el @A(MIT). Scheme se convirtió en un
     estándar @A(IEEE) en 1990 (@l(#IEEE 1990)). El dialecto común de Lisp
     (@l(#Steele 1982), @l(#Steele 1990) ) fue desarrollado por la comunidad
     Lisp para combinar características de los primeros dialectos Lisp para
     hacer un estándar industrial para Lisp. Common Lisp se convirtio en un
     estandar @A(ANSI) en 1994 (@l(#ANSI 1994)).

#   :: @N(3) :: One such special application was a breakthrough computation of
#      scientific importance––an integration of the motion of the Solar System
#      that extended previous results by nearly two orders of magnitude, and
#      demonstrated that the dynamics of the Solar System is chaotic. This
#      computation was made possible by new integration algorithms, a
#      special-purpose compiler, and a special-purpose computer all implemented
#      with the aid of software tools written in Lisp (@l(#Abelson et al. 1992);
#      @l(#Sussman and Wisdom 1992)).
  :: @N(3) :: Una aplicación especial de este tipo fue un descubrimiento de
     importancia científica––una integración del movimiento del Sistema Solar
     que amplió los resultados anteriores en casi dos órdenes de magnitud y
     demostró que la dinámica del Sistema Solar es caótica. Este cálculo fue
     posible gracias a nuevos algoritmos de integración, un compilador de
     propósito especial, y un ordenador de propósito especial todos
     implementados con la ayuda de herramientas de software escrito en Lisp
     (@l(#Abelson et al. 1992); @l(#Sussman y Wisdom 1992)).

#   :: @N(4) :: The characterization of numbers as @"(simple data) is a barefaced
#      bluff. In fact, the treatment of numbers is one of the trickiest and most
#      confusing aspects of any programming language. Some typical issues involved
#      are these: Some computer systems distinguish @e(integers), such as 2, from
#      @e(real numbers), such as 2.71. Is the real number 2.00 different from the
#      integer 2?  Are the arithmetic operations used for integers the same as the
#      operations used for real numbers?  Does 6 divided by 2 produce 3, or 3.0?
#      How large a number can we represent?  How many decimal places of accuracy
#      can we represent?  Is the range of integers the same as the range of real
#      numbers?  Above and beyond these questions, of course, lies a collection of
#      issues concerning roundoff and truncation errors––the entire science of
#      numerical analysis. Since our focus in this book is on large-scale program
#      design rather than on numerical techniques, we are going to ignore these
#      problems. The numerical examples in this chapter will exhibit the usual
#      roundoff behavior that one observes when using arithmetic operations that
#      preserve a limited number of decimal places of accuracy in noninteger
#      operations.
  :: @N(4) :: La caracterización de los números como @"(datos simples) es un
     engaño descarado. De hecho, el tratamiento de los números es uno de los
     aspectos más complicados y confusos de cualquier lenguaje de programación.
     Algunos problemas típicos involucrados son los siguientes: Algunos sistemas
     informáticos distinguen @e(números enteros), como 2, de @e(números reales),
     como 2.71. ¿Es el número real 2.00 diferente del entero 2? ¿Son las
     operaciones aritméticas utilizadas para enteros iguales a las operaciones
     utilizadas para los números reales? ¿6 dividido por 2 produce 3, o 3,0?
     ¿Cuán grande podemos representar un numero? ¿Cuántas posiciones decimales
     de exactitud podemos representar? ¿El rango de números enteros es el mismo
     que el rango de números reales? Por encima y más allá de estas preguntas,
     por supuesto, Se encuentra una colección de cuestiones relativas a errores
     de redondeo y truncamiento––la ciencia entera del análisis numérico. Dado
     que nuestro enfoque en este libro está en el diseño de programas a gran
     escala en lugar de en técnicas numéricas, vamos a ignorar estos
     problemas. Los ejemplos numéricos en este capítulo exhibirán el
     comportamiento de redondeo usual que se observa al utulizar operaciones
     aritméticas que preservan un número limitado de posiciones decimales de
     precisión en operaciones no enteras.

#   :: @N(5) :: Throughout this book, when we wish to emphasize the distinction
#      between the input typed by the user and the response printed by the
#      interpreter, we will show the latter in slanted characters.
  :: @N(5) :: A lo largo de este libro, cuando queremos enfatizar la distinción
     entre la entrada escrita por el usuario y la respuesta impresa por el
     intérprete, mostraremos esta última en caracteres resaltados uniformemente.

#   :: @N(6) :: Lisp systems typically provide features to aid the user in
#      formatting expressions. Two especially useful features are one that
#      automatically indents to the proper pretty-print position whenever a new
#      line is started and one that highlights the matching left parenthesis
#      whenever a right parenthesis is typed.
  :: @N(6) :: Los sistemas Lisp normalmente proporcionan características para
     ayudar al usuario a formatear expresiones. Dos características
     especialmente útiles son aquellas que introducen automáticamente la
     posición de impresión apropiada siempre que se inicia una nueva línea y
     otra es resaltar el paréntesis izquierdo coincidente siempre que se escribe
     un paréntesis derecho.

#   :: @N(7) :: Lisp obeys the convention that every expression has a value. This
#      convention, together with the old reputation of Lisp as an inefficient
#      language, is the source of the quip by Alan Perlis (paraphrasing Oscar
#      Wilde) that @"(Lisp programmers know the value of everything but the cost
#      of nothing.)
  :: @N(7) :: Lisp obedece la convención de que cada expresión tiene un
     valor. Esta convención, junto con la vieja reputación de Lisp como un
     lenguaje ineficiente, es la fuente de la burla de Alan Perlis
     (parafraseando a Oscar Wilde) de que @"(los programadores de Lisp saben el
     valor de todo menos el costo de nada.)

#   :: @N(8) :: In this book, we do not show the interpreter's response to
#      evaluating definitions, since this is highly implementation-dependent.
  :: @N(8) :: En este libro, no mostramos la respuesta del intérprete a la
     evaluación de definiciones, ya que esto depende altamente de la
     implementación.

#   :: @N(9) :: @l(#Chapter 3) will show that this notion of environment is
#      crucial, both for understanding how the interpreter works and for
#      implementing interpreters.
  :: @N(9) :: El @l(#Capitulo 3) mostrará que esta noción de entorno es crucial,
     tanto para entender cómo funciona el intérprete como para implementar
     intérpretes.

#   :: @N(10) :: It may seem strange that the evaluation rule says, as part of the
#      first step, that we should evaluate the leftmost element of a combination,
#      since at this point that can only be an operator such as @c(+) or @c(*)
#      representing a built-in primitive procedure such as addition or
#      multiplication. We will see later that it is useful to be able to work with
#      combinations whose operators are themselves compound expressions.
  :: @N(10) :: Puede parecer extraño que la regla de evaluación diga, como parte
     del primer paso, que debemos evaluar el elemento más a la izquierda de una
     combinación, ya que en este punto que sólo puede ser un operador como @c(+)
     o @c(*) que representa un procedimiento primitivo nativo como suma
     o multiplicación. Más adelante veremos que es útil poder trabajar con
     combinaciones cuyos operadores son expresiones compuestas.

#   :: @N(11) :: Special syntactic forms that are simply convenient alternative
#      surface structures for things that can be written in more uniform ways are
#      sometimes called @e(syntactic sugar), to use a phrase coined by Peter
#      Landin. In comparison with users of other languages, Lisp programmers, as a
#      rule, are less concerned with matters of syntax. (By contrast, examine any
#      Pascal manual and notice how much of it is devoted to descriptions of
#      syntax.)  This disdain for syntax is due partly to the flexibility of Lisp,
#      which makes it easy to change surface syntax, and partly to the observation
#      that many @"(convenient) syntactic constructs, which make the language less
#      uniform, end up causing more trouble than they are worth when programs
#      become large and complex. In the words of Alan Perlis, @"(Syntactic sugar
#      causes cancer of the semicolon.)
  :: @N(11) :: Las formas sintácticas especiales simplemente son convenientes
     estructuras superficiales alternativas para las cosas que se pueden
     escribir de manera más uniforme a veces se denominan @e(azúcar sintáctico),
     para usar una frase acuñada por Peter Landin. En comparación con los
     usuarios de otros lenguajes, los programadores de Lisp, por regla general,
     están menos preocupados por cuestiones de sintaxis. Este desdén por la
     sintaxis se debe en parte a la flexibilidad de Lisp, que facilita el cambio
     de la sintaxis superficial, y en parte a la observación de que muchas
     construcciones sintácticas @"(convenientes), hacen que el lenguaje sea
     menos uniforme, terminan causando más problemas de los que valen cuando los
     programas se hacen grandes y complejos. En palabras de Alan Perlis,@"(El
     azúcar sintáctico causa el cáncer del punto y coma.)

#   :: @N(12) :: Observe that there are two different operations being combined
#      here: we are creating the procedure, and we are giving it the name
#      @c(square). It is possible, indeed important, to be able to separate these
#      two notions––to create procedures without naming them, and to give names to
#      procedures that have already been created. We will see how to do this in
#      @l(#1.3.2).
  :: @N(12) :: Observe que hay dos operaciones diferentes que se combinan aquí:
     estamos creando el procedimiento, y le estamos dando el nombre @c(square).
     Es posible, de hecho importante, poder separar estas dos nociones: crear
     procedimientos sin nombrarlos y dar nombres a los procedimientos que ya se
     han creado. Veremos cómo hacerlo en la seccion @l(#1.3.2).

#   :: @N(13) :: Throughout this book, we will describe the general syntax of
#      expressions by using italic symbols delimited by angle brackets––e.g.,
#      @c[(name)]––to denote the @"(slots) in the expression to be filled in when
#      such an expression is actually used.
  :: @N(13) :: A lo largo de este libro, describiremos la sintaxis general de
     las expresiones delimitadas por paréntesis angulares––por ejemplo,
     @c[⟨nombre⟩]––para indicar las @"(espacios) en la expresión que se llenaran
     cuando la expresión se use realmente.

#   :: @N(14) :: More generally, the body of the procedure can be a sequence of
#      expressions. In this case, the interpreter evaluates each expression in the
#      sequence in turn and returns the value of the final expression as the value
#      of the procedure application.
  :: @N(14) :: Generalmente, el cuerpo del procedimiento puede ser una secuencia
     de expresiones. En este caso, el intérprete evalúa cada expresión en la
     secuencia sucesivamente y devuelve el valor de la expresión final como el
     valor de la aplicación de procedimiento.

#   :: @N(15) :: Despite the simplicity of the substitution idea, it turns out to
#      be surprisingly complicated to give a rigorous mathematical definition of
#      the substitution process. The problem arises from the possibility of
#      confusion between the names used for the formal parameters of a procedure
#      and the (possibly identical) names used in the expressions to which the
#      procedure may be applied. Indeed, there is a long history of erroneous
#      definitions of @e(substitution) in the literature of logic and programming
#      semantics.  See @l(#Stoy 1977) for a careful discussion of substitution.
  :: @N(15) :: A pesar de la simplicidad de la idea de sustitución, resulta
     sorprendentemente complicado dar una definición matemática rigurosa del
     proceso de sustitución. El problema surge de la posibilidad de confusión
     entre los nombres utilizados para los parámetros formales de un
     procedimiento y los nombres (posiblemente idénticos) utilizados en las
     expresiones a las que puede aplicarse el procedimiento. De hecho, existe
     una larga historia de definiciones erróneas de @e(sustitución) en la
     literatura de la lógica y la semántica en programación. Ver @l(#Stoy 1977)
     para una cuidadosa discusión de la sustitución.

#   :: @N(16) :: In @l(#Chapter 3) we will introduce @e(stream processing), which
#      is a way of handling apparently @"(infinite) data structures by
#      incorporating a limited form of normal-order evaluation. in section @l(#4.2) we
#      will modify the Scheme interpreter to produce a normal-order variant of
#      Scheme.
  :: @N(16) :: En el @l(#Capitulo 3) introduciremos el @e(procesamiento de
     flujos), que es una manera de manejar estructuras de datos aparentemente
     @"(infinitas) incorporando una forma limitada de evaluación de orden
     normal. En la seccion @l(#4.2) modificaremos el intérprete Scheme para
     producir una variante de orden normal de Scheme.

#   :: @N(17) :: @"(Interpreted as either true or false) means this: In Scheme,
#      there are two distinguished values that are denoted by the constants @c(#t)
#      and @c(#f). When the interpreter checks a predicate's value, it interprets
#      @c(#f) as false. Any other value is treated as true.  (Thus, providing
#      @c(#t) is logically unnecessary, but it is convenient.)  In this book we
#      will use names @c(true) and @c(false), which are associated with the values
#      @c(#t) and @c(#f) respectively.
  :: @N(17) :: @"(Interpretado como verdadero o falso) significa esto: En
     Scheme, hay dos valores distinguidos denotados por las constantes @c(#t) y
     @c(#f). Cuando el intérprete comprueba el valor de un predicado, interpreta
     @c(#f) como falso. Cualquier otro valor es tratado como verdadero. (Por lo
     tanto, proveer @c(#t) es lógicamente innecesario, pero es conveniente.) En
     este libro usaremos nombres @c(true) y @c(false), que están asociados con
     los valores @c(#t) y @c(#f) respectivamente.

#   :: @N(18) :: @c(abs) also uses the @"(minus) operator @c(-), which, when used
#      with a single operand, as in @c[(- x)], indicates negation.
  :: @N(18) :: @c(abs) También utiliza el operador @"(menos) @c(-), que, cuando
     se utiliza con un solo operando, como en @c[(- x)], indica negación.

#   :: @N(19) :: A minor difference between @c(if) and @c(cond) is that the
#      @c[⟨e⟩] part of each @c(cond) clause may be a sequence of expressions. If
#      the corresponding @c[⟨p⟩] is found to be true, the expressions @c[⟨e⟩] are
#      evaluated in sequence and the value of the final expression in the sequence
#      is returned as the value of the @c(cond). In an @c(if) expression, however,
#      the @c[⟨consequent⟩] and @c[⟨alternative⟩] must be single expressions.
  :: @N(19) :: Una pequeña diferencia entre @c(if) y @c(cond) es que la parte
     @c[⟨e⟩] de cada clausula @c(cond) puede ser una secuencia de
     expresiones. Si se comprueba que el valor @c[⟨p⟩] correspondiente es
     verdadero, se evalúan las expresiones @c[⟨e⟩] en secuencia y el valor de la
     expresión final en la secuencia se devuelve como el valor de @c(cond). En
     una expresión @c(if), sin embargo, @c[⟨consecuente⟩] y @c[⟨alternativo⟩]
     debe ser expresiones individuales.

#   :: @N(20) :: Declarative and imperative descriptions are intimately related,
#      as indeed are mathematics and computer science. For instance, to say that
#      the answer produced by a program is @"(correct) is to make a declarative
#      statement about the program.  There is a large amount of research aimed at
#      establishing techniques for proving that programs are correct, and much of
#      the technical difficulty of this subject has to do with negotiating the
#      transition between imperative statements (from which programs are
#      constructed) and declarative statements (which can be used to deduce
#      things).  In a related vein, an important current area in
#      programming-language design is the exploration of so-called very high-level
#      languages, in which one actually programs in terms of declarative
#      statements.  The idea is to make interpreters sophisticated enough so that,
#      given @"(what is) knowledge specified by the programmer, they can generate
#      @"(how to) knowledge automatically. This cannot be done in general, but
#      there are important areas where progress has been made. We shall revisit
#      this idea in @l(#Chapter 4).
  :: @N(20) :: Las descripciones declarativas e imperativas están íntimamente
     relacionadas, al igual que las matemáticas y la informática. Por ejemplo,
     decir que la respuesta producida por un programa es @"(correcta) es hacer
     una declaración declarativa sobre el programa. Existe una gran cantidad de
     investigaciones destinadas a establecer técnicas para probar que los
     programas son correctos y gran parte de la dificultad técnica de este tema
     tiene que ver con la negociación de la transición entre declaraciones
     imperativas (de las que se construyen los programas) y declaraciones
     declarativas (que se pueden utilizar para deducir las cosas). En una línea
     relacionada, una importante área actual en el diseño de lenguajes de
     programación es la exploración de los llamados lenguajes de muy alto nivel,
     en los cuales uno realmente programa en términos de declaraciones
     declarativas. La idea es hacer que los intérpretes sean lo suficientemente
     sofisticados para que, dado @"(lo que es) el conocimiento especificado por
     el programador, pueda generar el conocimiento de @"(como) de forma
     automática. Esto no se puede hacer en general, pero hay áreas importantes
     donde se han hecho progresos. Revisaremos esta idea en el @l(#Capitulo 4).

#   :: @N(21) :: This square-root algorithm is actually a special case of Newton's
#      method, which is a general technique for finding roots of equations. The
#      square-root algorithm itself was developed by Heron of Alexandria in the
#      first century A.D. We will see how to express the general Newton's
#      method as a Lisp procedure in section @l(#1.3.4).
  :: @N(21) :: Este algoritmo de raíz cuadrada es en realidad un caso especial
     del método Newton, que es una técnica general para encontrar raíces de
     ecuaciones. El algoritmo de raíz cuadrada en sí mismo fue desarrollado por
     Heron of Alexandria en el primer siglo D.C. Veremos cómo expresar el método
     general de Newton como un procedimiento Lisp en la seccion @l(#1.3.4).

#   :: @N(22) :: We will usually give predicates names ending with question marks,
#      to help us remember that they are predicates.  This is just a stylistic
#      convention. As far as the interpreter is concerned, the question mark is
#      just an ordinary character.
  :: @N(22) :: Por lo general, daremos a los predicados nombres que terminen con
     signos de interrogación, para ayudarnos a recordar que son predicados. Esto
     es sólo una convención estilística. En cuanto al intérprete, el signo de
     interrogación es simplemente un carácter ordinario.

#   :: @N(23) :: Observe that we express our initial guess as 1.0 rather
#      than 1. This would not make any difference in many Lisp
#      implementations. @A(MIT) Scheme, however, distinguishes between exact
#      integers and decimal values, and dividing two integers produces a rational
#      number rather than a decimal. For example, dividing 10 by 6 yields 5/3,
#      while dividing 10.0 by 6.0 yields 1.6666666666666667. (We will learn how to
#      implement arithmetic on rational numbers in section @l(#2.1.1).)  If we start with
#      an initial guess of 1 in our square-root program, and @m(x) is an exact
#      integer, all subsequent values produced in the square-root computation will
#      be rational numbers rather than decimals. Mixed operations on rational
#      numbers and decimals always yield decimals, so starting with an initial
#      guess of 1.0 forces all subsequent values to be decimals.
  :: @N(23) :: Observe que expresamos nuestra conjetura inicial como 1,0 en
     lugar de 1. Esto no haría ninguna diferencia en muchas implementaciones de
     Lisp. @A(MIT) Scheme, sin embargo, distingue entre enteros exactos y
     valores decimales, y dividir dos enteros produce un número racional en
     lugar de un decimal. Por ejemplo, la división de 10 por 6 produce 5/3,
     mientras que la división de 10,0 por 6,0 produce 1,6666666666666667. (Vamos
     a aprender cómo implementar la aritmética de números racionales en la
     seccion @l(#2.1.1).) Si en nuestro programa de raíz cuadrada partimos de un
     valor inicial de 1, y @m(x) es un número entero exacto, todos los valores
     posteriores producidos en el cálculo de la raíz cuadrada serán números
     racionales en lugar de decimales. Operaciones mixtas en números racionales
     y decimales siempre dan decimales, de modo que comenzamos con una
     estimación inicial de 1.0.

#   :: @N(24) :: Readers who are worried about the efficiency issues involved in
#      using procedure calls to implement iteration should note the remarks on
#      @"(tail recursion) in section @l(#1.2.1).
  :: @N(24) :: Los lectores que están preocupados por los problemas de
     eficiencia involucrados en el uso de llamadas de procedimiento para
     implementar la iteración deben tener en cuenta las observaciones sobre la
     @"(recursión de cola) en la seccion @l(#1.2.1).

#   :: @N(25) :: It is not even clear which of these procedures is a more
#      efficient implementation. This depends upon the hardware available. There
#      are machines for which the @"(obvious) implementation is the less efficient
#      one. Consider a machine that has extensive tables of logarithms and
#      antilogarithms stored in a very efficient manner.
  :: @N(25) :: Ni siquiera está claro cuál de estos procedimientos es la
     implementación más eficiente. Esto depende del hardware disponible. Hay
     máquinas para las cuales la implementación @"(obvia) es la menos
     eficiente. Considere una máquina que tiene extensas tablas de logaritmos y
     antilogaritmos almacenados de una manera muy eficiente.

#   :: @N(26) :: The concept of consistent renaming is actually subtle and
#      difficult to define formally. Famous logicians have made embarrassing
#      errors here.
  :: @N(26) :: El concepto de cambio de nombre consistente es en realidad sutil
     y difícil de definir formalmente. Famosos lógicos han cometido errores
     embarazosos aquí.

#   :: @N(27) :: Lexical scoping dictates that free variables in a procedure are
#      taken to refer to bindings made by enclosing procedure definitions; that
#      is, they are looked up in the environment in which the procedure was
#      defined. We will see how this works in detail in chapter 3 when we study
#      environments and the detailed behavior of the interpreter.
  :: @N(27) :: El ámbito léxico dicta que las variables libres en un
     procedimiento se toman para referirse a los enlaces que se hacen al incluir
     las definiciones del procedimiento; es decir, se buscan en el entorno en el
     que se definió el procedimiento. Veremos cómo esto funciona en detalle en
     el capítulo 3 cuando estudiamos los entornos y el comportamiento detallado
     del intérprete.

#   :: @N(28) :: Embedded definitions must come first in a procedure body. The
#      management is not responsible for the consequences of running programs that
#      intertwine definition and use.
  :: @N(28) :: Las definiciones incrustadas deben aparecer al pricipio en el
     cuerpo del procedimiento. El administrador no es responsable de las
     consecuencias de ejecutar programas que entrelazan la definición y el uso.

#   :: @N(29) :: In a real program we would probably use the block structure
#      introduced in the last section to hide the definition of @c(fact-iter):
  :: @N(29) :: En un programa real probablemente usaríamos la estructura de
     bloques introducida en la última sección para ocultar la definición de
     @c(fact-iter):

#      ..src > scheme
#        (define (factorial n)
#          (define (iter product counter)
#            (if (> counter n)
#                product
#                (iter (* counter product)
#                      (+ counter 1))))
#          (iter 1 1))
#      < src..
     ..src > scheme
       (define (factorial n)
         (define (iter product counter)
           (if (> counter n)
               product
               (iter (* counter product)
                     (+ counter 1))))
         (iter 1 1))
     < src..

#      We avoided doing this here so as to minimize the number of things to think
#      about at once.
     Evitamos hacer esto aquí para minimizar el número de cosas en las que
     pensar al mismo tiempo.

#   :: @N(30) :: When we discuss the implementation of procedures on register
#      machines in @l(#Chapter 5), we will see that any iterative process can be
#      realized @"(in hardware) as a machine that has a fixed set of registers and
#      no auxiliary memory. In contrast, realizing a recursive process requires a
#      machine that uses an auxiliary data structure known as a @e(stack).
  :: @N(30) :: Cuando discutamos la implementación de procedimientos en máquinas
     de registro en el @l(#Capitulo 5), veremos que cualquier proceso iterativo
     puede ser realizado @"(en hardware) como una máquina que tiene un conjunto
     fijo de registros y ninguna memoria auxiliar. Por el contrario, realizar un
     proceso recursivo requiere una máquina que utiliza una estructura de datos
     auxiliares conocida como @e(pila).

#   :: @N(31) :: Tail recursion has long been known as a compiler optimization
#      trick. A coherent semantic basis for tail recursion was provided by Carl
#      @l[#Hewitt (1977)], who explained it in terms of the @"(message-passing)
#      model of computation that we shall discuss in @l(#Chapter 3). Inspired by
#      this, Gerald Jay Sussman and Guy Lewis Steele Jr. (see @l(#Steele and
#      Sussman 1975)) constructed a tail-recursive interpreter for Scheme. Steele
#      later showed how tail recursion is a consequence of the natural way to
#      compile procedure calls (@l(#Steele 1977)). The @A(IEEE) standard for
#      Scheme requires that Scheme implementations be tail-recursive.
  :: @N(31) :: La recursión de cola se conoce desde hace mucho tiempo como un
     truco de optimización del compilador. Carl @l[#Hewitt (1977)] proporcionó
     una base semántica coherente para la recursión de cola, que explicó en
     términos del modelo de cálculo del @"(paso de mensajes) que discutiremos en
     el @l(#Capitulo 3). Inspirado en esto, Gerald Jay Sussman y Guy Lewis
     Steele Jr. (véa @l(#Steele y Sussman, 1975)) construyeron un intérprete
     recursivo de cola para Scheme. Steele demostró más adelante cómo la
     recursión de cola es una consecuencia de la manera natural de compilar las
     llamadas del procedimiento (@l(#Steele 1977)). El estándar @A(IEEE) para
     Scheme requiere que las implementaciones Scheme sean recursivas de cola.

#   :: @N(32) :: An example of this was hinted at in section @l(#1.1.3). The interpreter
#      itself evaluates expressions using a tree-recursive process.
  :: @N(32) :: Un ejemplo de esto fue sugerido en la seccion @l(#1.1.3). El
     propio intérprete evalúa expresiones usando un proceso de arbol recursivo.

#   :: @N(33) :: For example, work through in detail how the reduction rule
#      applies to the problem of making change for 10 cents using pennies and
#      nickels.
  :: @N(33) :: Por ejemplo, trate en detalle cómo se aplica la regla de
     reducción al problema de hacer cambios por 10 centavos usando monedas de
     uno y 5 centavos.

#   :: @N(34) :: One approach to coping with redundant computations is to arrange
#      matters so that we automatically construct a table of values as they are
#      computed. Each time we are asked to apply the procedure to some argument,
#      we first look to see if the value is already stored in the table, in which
#      case we avoid performing the redundant computation.  This strategy, known
#      as @e(tabulation) or @e(memoization), can be implemented in a
#      straightforward way. Tabulation can sometimes be used to transform
#      processes that require an exponential number of steps (such as
#      @c(count-change)) into processes whose space and time requirements grow
#      linearly with the input. See @l(#Exercise 3.27).
  :: @N(34) :: Un enfoque para hacer frente a los cálculos redundantes es
     organizar los asuntos para que construyamos automáticamente una tabla de
     valores a medida que se calculan. Cada vez que se nos pide que apliquemos
     el procedimiento a algún argumento, primero veremos si el valor ya está
     almacenado en la tabla, en cuyo caso evitamos realizar el cálculo
     redundante. Esta estrategia, conocida como @e(tabulación) o
     @e(memorización), puede implementarse de una manera directa. A veces, la
     tabulación puede usarse para transformar procesos que requieren un número
     exponencial de pasos (como @c(count-change)) en procesos cuyos
     requerimientos de espacio y tiempo crecen linealmente con la entrada. Véa
     el @l(#Ejercicio 3.27).

#   :: @N(35) :: The elements of Pascal's triangle are called the @e(binomial
#      coefficients), because the @m(nᵗʰ) row consists of the coefficients of the
#      terms in the expansion of @m[(x + y)ⁿ]. This pattern for computing the
#      coefficients appeared in Blaise Pascal's 1653 seminal work on probability
#      theory, @q(Traité du triangle arithmétique). According to @l[#Knuth
#      (1973)], the same pattern appears in the @q(Szu-yuen Yü-chien) (@"(The
#      Precious Mirror of the Four Elements)), published by the Chinese
#      mathematician Chu Shih-chieh in 1303, in the works of the twelfth-century
#      Persian poet and mathematician Omar Khayyam, and in the works of the
#      twelfth-century Hindu mathematician Bháscara Áchárya.
  :: @N(35) :: Los elementos del triángulo de Pascal se llaman @e(coeficientes
     binomiales), porque la @m(n) fila consiste en los coeficientes de los
     términos en la expansión de @m[(x + y)]ⁿ]. Este patrón para calcular los
     coeficientes, apareció en el trabajo seminal de Blaise Pascal de 1653 sobre
     la teoría de la probabilidad, @q(Traité du triangle arithmétique). De
     acuerdo con @l[#Knuth (1973)], el mismo patrón aparece en el @"(Si-Yuen
     Yu-Chien) (@"(El espejo precioso de los cuatro elementos)), publicado por
     el matemático chino Chu Shih-Chieh en 1303, en las obras del siglo XII
     poeta y matemático persa Omar Khayyam, y en las obras del matemático hindú
     Bháscara Áchárya del siglo XII.

#   :: @N(36) :: These statements mask a great deal of oversimplification.  For
#      instance, if we count process steps as @"(machine operations) we are making
#      the assumption that the number of machine operations needed to perform,
#      say, a multiplication is independent of the size of the numbers to be
#      multiplied, which is false if the numbers are sufficiently large. Similar
#      remarks hold for the estimates of space. Like the design and description of
#      a process, the analysis of a process can be carried out at various levels
#      of abstraction.}
  :: @N(36) :: Estas afirmaciones enmascaran una gran cantidad de
     simplificaciones excesivas. Por ejemplo, si contamos los pasos del proceso
     como @"(operaciones máquina), estamos haciendo la suposición de que el
     número de operaciones de la máquina necesarias para realizar, digamos, una
     multiplicación es independiente del tamaño de los números a multiplicar, lo
     cual es falso si los números son suficientemente grandes. Observaciones
     similares se aplican a las estimaciones del espacio. Al igual que el diseño
     y la descripción de un proceso, el análisis de un proceso puede llevarse a
     cabo en varios niveles de abstracción.

#   :: @N(37) :: More precisely, the number of multiplications required is equal
#      to 1 less than the log base 2 of @m(n) plus the number of ones in the
#      binary representation of @m(n). This total is always less than twice the
#      log base 2 of @m(n). The arbitrary constants @m(k₁) and @m(k₂) in the
#      definition of order notation imply that, for a logarithmic process, the
#      base to which logarithms are taken does not matter, so all such processes
#      are described as @m[Θ(log n)].
  :: @N(37) :: Más precisamente, el número de multiplicaciones requeridas es
     igual a 1 menos que la base log 2 de @m(n) más el número de unidades en la
     representación binaria de @m(n). Este total es siempre menor que el doble
     de la base logarítmica 2 de @m(n). Las constantes arbitrarias @m(k₁) y
     @m(k₂) en la definición de notación de orden implican que, para un proceso
     logarítmico, la base a la que se toman los logaritmos no importa, por lo
     que todos estos procesos se describen como @m[Θ(log n)].

#   :: @N(38) :: You may wonder why anyone would care about raising numbers to the
#      1000th power. See section @l(#1.2.6).
  :: @N(38) :: Usted puede preguntarse por qué alguien se preocuparía por
     aumentar los números a la potencia 1000. Ver seccion @l(#1.2.6).

#   :: @N(39) :: This iterative algorithm is ancient. It appears in the
#      @q(Chandah-sutra) by Áchárya Pingala, written before 200 B.C. See
#      @l(#Knuth 1981), section 4.6.3, for a full discussion and analysis of this
#      and other methods of exponentiation.
  :: @N(39) :: Este algoritmo iterativo es antiguo. Aparece en @"(Chandah-sutra)
     por Áchárya Pingala, escrito antes del año 200 A.C. Ver @l(#Knuth 1981),
     sección 4.6.3, para una discusión y análisis completo de este y otros
     métodos de exponenciación.

#   :: @N(40) :: This algorithm, which is sometimes known as the @"(Russian
#      peasant method) of multiplication, is ancient. Examples of its use are
#      found in the Rhind Papyrus, one of the two oldest mathematical documents in
#      existence, written about 1700 B.C.  (and copied from an even older
#      document) by an Egyptian scribe named A'h-mose.
  :: @N(40) :: Este algoritmo, que a veces se conoce como el @"(método campesino
     ruso) de multiplicación, es antiguo. Ejemplos de su uso se encuentran en el
     Papiro Rhind, uno de los dos documentos matemáticos más antiguos en
     existencia, escrito alrededor de 1700 A.C. (y copiado de un documento aún
     más antiguo) por un escribano egipcio llamado A'h-mose.

#   :: @N(41) :: This exercise was suggested to us by Joe Stoy, based on an
#      example in @l(#Kaldewaij 1990).
  :: @N(41) :: Este ejercicio nos fue sugerido por Joe Stoy, basado en un
     ejemplo en @l(#Kaldewaij 1990).

#   :: @N(42) :: Euclid's Algorithm is so called because it appears in Euclid's
#      @q(Elements) (Book 7, ca. 300 @A(B.C.)).  According to @l(#Knuth (1973)),
#      it can be considered the oldest known nontrivial algorithm. The ancient
#      Egyptian method of multiplication (@l(#Exercise 1.18)) is surely older,
#      but, as Knuth explains, Euclid's algorithm is the oldest known to have been
#      presented as a general algorithm, rather than as a set of illustrative
#      examples.
  :: @N(42) :: El Algoritmo de Euclides se llama así porque aparece en los
     @"(Elementos) de Euclides (Libro 7, aproximadamente 300 A.C). De acuerdo
     con @l[#Knuth (1973)], puede ser considerado el algoritmo no trivial
     conocido más antiguo. El antiguo método egipcio de multiplicación
     (@l(#Ejercicio 1.18)) es seguramente más antiguo, pero, como Knuth explica,
     el algoritmo de Euclides es el más antiguo que se sabe que se ha presentado
     como un algoritmo general, más que como un conjunto de ejemplos
     ilustrativos.

#   :: @N(43) :: This theorem was proved in 1845 by Gabriel Lamé, a French
#      mathematician and engineer known chiefly for his contributions to
#      mathematical physics. To prove the theorem, we consider pairs @m[(aₙ, bₙ)],
#      where @m(aₙ ≥ bₙ), for which Euclid's Algorithm terminates in @m(k)
#      steps. The proof is based on the claim that, if @m[(aₖ₊₁, bₖ₊₁) → (aₙ, bₙ)
#      → (aₖ₋₁, bₖ₋₁)] are three successive pairs in the reduction process, then
#      we must have @m(bₖ₊₁ ≥ bₙ + bₖ₋₁). To verify the claim, consider that a
#      reduction step is defined by applying the transformation @m(aₖ₋₁ = bₙ),
#      @m(bₖ₋₁ =) remainder of @m(aₙ) divided by @m(bₙ). The second equation means
#      that @m(aₙ = qbₙ + bₖ₋₁) for some positive integer @m(q). And since @m(q)
#      must be at least 1 we have @m(aₙ = qbₙ + bₖ₋₁ ≥ bₙ + bₖ₋₁). But in the
#      previous reduction step we have @m(bₖ₊₁ = aₙ). Therefore, @m(bₖ₊₁ = aₙ ≥
#      bₙ + bₖ₋₁). This verifies the claim. Now we can prove the theorem by
#      induction on @m(k), the number of steps that the algorithm requires to
#      terminate. The result is true for @m(k = 1), since this merely requires
#      that @m(b) be at least as large as @m[Fib(1) = 1]. Now, assume that the
#      result is true for all integers less than or equal to @m(k) and establish
#      the result for @m(k + 1). Let @m[(aₖ₊₁, bₖ₊₁) → (aₙ, bₙ) → (aₖ₋₁, bₖ₋₁)] be
#      successive pairs in the reduction process. By our induction hypotheses, we
#      have @m[bₖ₋₁ ≥ Fib(k - 1)] and @m[bₙ ≥ Fib(k)]. Thus, applying the claim we
#      just proved together with the definition of the Fibonacci numbers gives
#      @m[bₖ₊₁ ≥ bₙ + bₖ₋₁ ≥ Fib(k) + Fib(k-1) = Fib(k+1)], which completes the
#      proof of Lamé's Theorem.
  :: @N(43) :: Este teorema fue probado en 1845 por Gabriel Lamé, matemático e
     ingeniero francés conocido principalmente por sus contribuciones a la
     física matemática. Para probar el teorema, consideramos pares @m[(aₙ, bₙ)],
     donde @m(aₙ ≥ bₙ), para el cual el Algoritmo de Euclides termina en @m(k)
     pasos. La prueba se basa en la afirmación de que, si @m[(aₖ₊₁, bₖ₊₁) → (aₙ,
     bₙ) → (aₖ₋₁, bₖ₋₁)] son tres pares sucesivos en el proceso de reducción,
     entonces debemos tener @m(bₖ₊₁ ≥ bₙ + bₖ₋₁). Para verificar la
     reivindicación, considere que un paso de reducción se define aplicando la
     transformación @m(aₖ₋₁ = bₙ), @m(bₖ₋₁ =) resto de @m(aₙ) dividido por
     @m(bₙ). @m(La segunda ecuación significa que @m(aₙ = qbₙ + bₖ₋₁) para un
     cierto entero positivo @m(q). Y como @m(q) debe ser al menos 1 tenemos
     @m(aₙ = qbₙ + bₖ₋₁ ≥ bₙ + bₖ₋₁). Pero en el paso de reducción anterior
     tenemos @m(bₖ₊₁ = aₙ). Por lo tanto, @m(bₖ₊₁ = aₙ ≥ bₙ + bₖ₋₁). Esto
     verifica la exposicion. Ahora podemos probar el teorema por inducción en
     @m(k), el número de pasos que el algoritmo requiere para terminar. El
     resultado es verdadero para @m(k = 1), ya que esto requiere simplemente que
     @m(b) sea al menos tan grande como @m[Fib(1) = 1]. Ahora, @m(Suponga que el
     resultado es verdadero para todos los enteros inferiores o iguales a @m(k)
     y establece el resultado para @m(k + 1). Sea @m[(aₖ₊₁, bₖ₊₁) → (aₙ, bₙ) →
     (aₖ₋₁, bₖ₋₁)] ser pares sucesivos en el proceso de reducción. Por nuestras
     hipótesis de inducción, tenemos @m[bₖ₋₁ ≥ Fib (k - 1)] y @m(bₙ ≥
     Fib(k)]. Por lo tanto, aplicando la afirmación que acabamos de demostrar
     junto con la definición de los números de Fibonacci, se obtiene @m[bₖ₊₁ ≥
     bₙ + bₖ₋₁ ≥ Fib(k) + Fib (k-1) = Fib(k + 1)], que completa la prueba Del
     teorema de Lamé.

#   :: @N(44) :: If @m(d) is a divisor of @m(n), then so is @m(n/d). But @m(d)
#      and @m(n/d) cannot both be greater than @m(√n).
  :: @N(44) :: Si @m(d) es un divisor de @m(n), entonces es @m(n/d). Pero
     @m(d) y @m(n/d) no pueden ser ambos mayores que @m(√n).

#   :: @N(45) :: Pierre de Fermat (1601-1665) is considered to be the founder of
#      modern number theory. He obtained many important number-theoretic results,
#      but he usually announced just the results, without providing his
#      proofs. Fermat's Little Theorem was stated in a letter he wrote
#      in 1640. The first published proof was given by Euler in 1736 (and an
#      earlier, identical proof was discovered in the unpublished manuscripts of
#      Leibniz). The most famous of Fermat's results––known as Fermat's Last
#      Theorem––was jotted down in 1637 in his copy of the book @q(Arithmetic) (by
#      the third-century Greek mathematician Diophantus) with the remark @"(I have
#      discovered a truly remarkable proof, but this margin is too small to
#      contain it). Finding a proof of Fermat's Last Theorem became one of the
#      most famous challenges in number theory. A complete solution was finally
#      given in 1995 by Andrew Wiles of Princeton University.
  :: @N(45) :: Pierre de Fermat (1601-1665) es considerado como el fundador de
     la teoría numérica moderna. Obtuvo muchos resultados importantes de teoría
     numérica, pero usualmente anunció los resultados, sin dar sus pruebas. El
     pequeño teorema de Fermat se expresó en una carta que escribió en 1640. La
     primera prueba publicada fue dada por Euler en 1736 (y una prueba anterior,
     idéntica se descubrió en los manuscritos inéditos de Leibniz). El más
     famoso de los resultados de Fermat––conocido como último teorema de
     Fermat––fue anotado en 1637 en su copia del libro @q(Aritmética) (por el
     matemático griego Diophantus del siglo III) con la observación @"(he
     descubierto una prueba verdaderamente notable, pero este margen es
     demasiado pequeño para contenerlo). Encontrar una prueba del ultimo teorema
     de Fermat se convirtió en uno de los desafíos más famosos en la teoría
     numérica. Una solución completa finalmente fue dada en 1995 por Andrew
     Wiles de la Universidad de Princeton.

#   :: @N(46) :: The reduction steps in the cases where the exponent @m(e) is
#      greater than 1 are based on the fact that, for any integers @m(x), @m(y),
#      and @m(m), we can find the remainder of @m(x) times @m(y) modulo @m(m) by
#      computing separately the remainders of @m(x) modulo @m(m) and @m(y) modulo
#      @m(m), multiplying these, and then taking the remainder of the result
#      modulo @m(m). For instance, in the case where @m(e) is even, we compute the
#      remainder of @M(b^{e / 2}) modulo @m(m), square this, and take the
#      remainder modulo @m(m). This technique is useful because it means we can
#      perform our computation without ever having to deal with numbers much
#      larger than @m(m).  (Compare @l(#Exercise 1.25).)
  :: @N(46) :: Las etapas de reducción en los casos en que el exponente @m(e) es
     mayor que 1 se basan en el hecho de que, para cualquier entero @m(x),
     @m(y), y @m(m), podemos encontrar el resto de @m(x) veces @m(y) módulo
     @m(m) calculando por separado los restos de @m(x) módulo @m(m) y @m(y)
     modulo @m(m), multiplicando estos, y luego tomando el resto del resultado
     de módulo @m(m). Por ejemplo, en el caso donde @m(e) es par, calculamos el
     resto de @M(b^{e / 2}) módulo @m(m), optenemos su cuadrado, y tomamos el
     resto módulo @m(m). Esta técnica es útil porque significa que podemos
     realizar nuestro cálculo sin tener que tratar nunca con números mucho más
     grandes que @m(m). (Compare el @l(#Ejercicio 1.25) .)

#   :: @N(47) :: Numbers that fool the Fermat test are called @e(Carmichael
#      numbers), and little is known about them other than that they are extremely
#      rare. There are 255 Carmichael numbers below 100,000,000. The smallest few
#      are 561, 1105, 1729, 2465, 2821, and 6601. In testing primality of very
#      large numbers chosen at random, the chance of stumbling upon a value that
#      fools the Fermat test is less than the chance that cosmic radiation will
#      cause the computer to make an error in carrying out a @"(correct)
#      algorithm. Considering an algorithm to be inadequate for the first reason
#      but not for the second illustrates the difference between mathematics and
#      engineering.
  :: @N(47) :: Los números que engañan a la prueba de Fermat se llaman
     @e(números de Carmichael), y poco se sabe sobre ellos aparte de que son
     extremadamente raros. Hay 255 números de Carmichael por debajo de
     100.000.000. Los más pequeños son 561, 1105, 1729, 2465, 2821 y 6601. Al
     probar la primalidad de números muy grandes elegidos al azar, la
     probabilidad de tropezar con un valor que engañe la prueba de Fermat es
     menor que la probabilidad de que la radiación cósmica cause que el
     cumputador comenta un error en un algoritmo @"(correcto). Considerar un
     algoritmo inadecuado por la primera razón, pero no por la segunda, ilustra
     la diferencia entre la matemática y la ingeniería.

#   :: @N(48) :: One of the most striking applications of probabilistic prime
#      testing has been to the field of cryptography. Although it is now
#      computationally infeasible to factor an arbitrary 200-digit number, the
#      primality of such a number can be checked in a few seconds with the Fermat
#      test. This fact forms the basis of a technique for constructing
#      @"(unbreakable codes) suggested by @l[#Rivest et al. (1977)].  The
#      resulting @e(RSA algorithm) has become a widely used technique for
#      enhancing the security of electronic communications. Because of this and
#      related developments, the study of prime numbers, once considered the
#      epitome of a topic in @"(pure) mathematics to be studied only for its own
#      sake, now turns out to have important practical applications to
#      cryptography, electronic funds transfer, and information retrieval.
  :: @N(48) :: Una de las aplicaciones más sorprendentes de la prueba prima
     probabilística ha sido el campo de la criptografía. Aunque ahora es
     computacionalmente imposible factorizar un número arbitrario de 200
     dígitos, la primalidad de tal número puede comprobarse en pocos segundos
     con la prueba de Fermat. Este hecho constituye la base de una técnica para
     construir @"(códigos irrompibles) sugeridos por @l[#Rivest et
     al. (1977)]. El @e(algoritmo RSA) resultante se ha convertido en una
     técnica ampliamente utilizada para mejorar la seguridad de las
     comunicaciones electrónicas. Debido a esto y los desarrollos relacionados,
     el estudio de los números primos, una vez considerado el epítome de un tema
     en matemáticas @"(puras) para ser estudiado sólo por si mismo, ahora
     resulta tener importantes aplicaciones prácticas a la criptografía, la
     transferencia de fondos y recuperacion de informacion.

#   :: @N(49) :: This series, usually written in the equivalent form
#      @m(π/4 = 1 − ⅓ + ⅕ − ⅐ + …), is due to Leibniz. We'll see how to use this as
#      the basis for some fancy numerical tricks in section @l(#3.5.3).
  :: @N(49) :: Esta serie, usualmente escrita en la forma equivalente
     @m(π/4 = 1 − ⅓ + ⅕ − ⅐ + …), se debe a Leibniz. Veremos cómo
     utilizar esto como base para algunos trucos numéricos fantasticos en la
     seccion @l(#3.5.3).

#   :: @N(50) :: Notice that we have used block structure (section @l(#1.1.8)) to embed
#      the definitions of @c(pi-next) and @c(pi-term) within @c(pi-sum), since
#      these procedures are unlikely to be useful for any other purpose. We will
#      see how to get rid of them altogether in section @l(#1.3.2).
  :: @N(50) :: Obsérvese que hemos utilizado la estructura de bloques (seccion
     @l(#1.1.8)) para incorporar las definiciones de @c(pi-next) y
     @c(pi-term) dentro @c(pi-sum), ya que es poco probable que estos
     procedimientos sean útiles para cualquier otro propósito. Veremos cómo
     deshacernos de ellos por completo en la seccion @l(#1.3.2).

#   :: @N(51) :: The intent of @l(#Exercise 1.31) through @l(#Exercise 1.33) is to
#      demonstrate the expressive power that is attained by using an appropriate
#      abstraction to consolidate many seemingly disparate operations. However,
#      though accumulation and filtering are elegant ideas, our hands are somewhat
#      tied in using them at this point since we do not yet have data structures
#      to provide suitable means of combination for these abstractions. We will
#      return to these ideas in section @l(#2.2.3) when we show how to use @e(sequences)
#      as interfaces for combining filters and accumulators to build even more
#      powerful abstractions. We will see there how these methods really come into
#      their own as a powerful and elegant approach to designing programs.
  :: @N(51) :: La intención del los ejercicios @l(#Ejercicio 1.31<>1.31) al
     @l(#Ejercicio 1.33<>1.33) es demostrar el poder expresivo que se logra
     mediante el uso de una abstracción apropiada para consolidar muchas
     operaciones aparentemente dispares. Sin embargo, aunque la acumulación y el
     filtrado son ideas elegantes, nuestras manos están un tanto atadas en su
     uso en este punto ya que todavía no tenemos estructuras de datos para
     proporcionar medios adecuados de combinación para estas abstracciones.
     Volveremos a estas ideas en la seccion @l(#2.2.3) cuando demostraremos cómo
     usar las @e(secuencias) como interfaces para combinar filtros y
     acumuladores para crear abstracciones aún más poderosas. Veremos cómo estos
     métodos son realmente un enfoque poderoso y elegante para el diseño de
     programas.

#   :: @N(52) :: This formula was discovered by the seventeenth-century English
#      mathematician John Wallis.
  :: @N(52) :: Esta fórmula fue descubierta por el matemático inglés del siglo
     XVII John Wallis.

#   :: @N(53) :: It would be clearer and less intimidating to people learning Lisp
#      if a name more obvious than @c(lambda), such as @c(make-procedure), were
#      used. But the convention is firmly entrenched. The notation is adopted from
#      the λ-calculus, a mathematical formalism introduced by the mathematical
#      logician Alonzo @l(#Church (1941)). Church developed the λ-calculus to
#      provide a rigorous foundation for studying the notions of function and
#      function application. The λ-calculus has become a basic tool for
#      mathematical investigations of the semantics of programming languages.
  :: @N(53) :: Sería más claro y menos intimidante para las personas que
     aprenden Lisp con un nombre más obvio que @c(lambda), por ejemplo
     utilizando @c(hacer-procedimiento). Pero la convención está firmemente
     arraigada. La notación se adopta desde el cálculo-λ, un formalismo
     matemático introducido por el matemático lógico Alonzo @l[#Church
     (1941)]. Church desarrolló el cálculo-λ para proporcionar una base rigurosa
     para estudiar las nociones de función y aplicación de la función. El
     cálculo-λ se ha convertido en una herramienta básica para las
     investigaciones matemáticas de la semántica de los lenguajes de
     programación.

#   :: @N(54) :: Understanding internal definitions well enough to be sure a
#      program means what we intend it to mean requires a more elaborate model of
#      the evaluation process than we have presented in this chapter. The
#      subtleties do not arise with internal definitions of procedures,
#      however. We will return to this issue in section @l(#4.1.6), after we learn more
#      about evaluation.
  :: @N(54) :: La comprensión de las definiciones internas lo suficientemente
     bien como para asegurarse que un programa significa lo que pretendemos que
     signifique requiere un modelo más elaborado del proceso de evaluación de lo
     que hemos presentado en este capítulo. Sin embargo, las sutilezas no surgen
     con definiciones internas de los procedimientos. Volveremos a este tema en
     la seccion @l(#4.1.6), después de aprender más sobre la evaluación.

#   :: @N(55) :: We have used 0.001 as a representative @"(small) number to
#      indicate a tolerance for the acceptable error in a calculation. The
#      appropriate tolerance for a real calculation depends upon the problem to be
#      solved and the limitations of the computer and the algorithm. This is often
#      a very subtle consideration, requiring help from a numerical analyst or
#      some other kind of magician.
  :: @N(55) :: Hemos utilizado 0.001 como un número @"(pequeño) representativo
     para indicar una tolerancia para el error aceptable en un cálculo. La
     tolerancia apropiada para un cálculo real depende del problema a resolver y
     de las limitaciones de la computadora y del algoritmo. Esto es a menudo una
     consideración muy sutil, que requiere la ayuda de un analista numérico o
     algún otro tipo de mago.

#   :: @N(56) :: This can be accomplished using @c(error), which takes as
#      arguments a number of items that are printed as error messages.
  :: @N(56) :: Esto se puede lograr utilizando @c(error), que toma como
     argumentos una serie de elementos que se imprimen como mensajes de error.

#   :: @N(57) :: Try this during a boring lecture: Set your calculator to radians
#      mode and then repeatedly press the @c(cos) button until you obtain the
#      fixed point.
  :: @N(57) :: Intente esto durante una conferencia aburrida: Ajuste su
     calculadora al modo de los radianes y presione repetidamente el botón
     @c(cos) hasta que obtenga el punto fijo.

#   :: @N(58) :: @m(↦) (pronounced @"(maps to)) is the mathematician's way of
#      writing @c(lambda). @m(y ↦ x/y) means @c[(lambda (y) (/ x y))], that is,
#      the function whose value at @m(y) is @m(x/y).
  :: @N(58) :: @m(↦) (pronunciado @"(mapas a)) es la forma matematica de escribir
     @c(lambda). @m(Y ↦ x/y) significa @c[(lambda (y) (/ x y))], es decir, la
     función cuyo valor en @m(y) es @m(x/y).

#   :: @N(59) :: Observe that this is a combination whose operator is itself a
#      combination. @l(#Exercise 1.4) already demonstrated the ability to form
#      such combinations, but that was only a toy example. Here we begin to see
#      the real need for such combinations––when applying a procedure that is
#      obtained as the value returned by a higher-order procedure.
  :: @N(59) :: Observe que se trata de una combinación cuyo operador es en sí
     mismo una combinación. El @l(#Ejercicio 1.4) ya demostró la capacidad de
     formar tales combinaciones, pero eso era sólo un ejemplo de juguete. Aquí
     comenzamos a ver la necesidad real de tales combinaciones––al aplicar un
     procedimiento que se obtiene como el valor devuelto por un procedimiento de
     orden superior.

#   :: @N(60) :: See @l(#Exercise 1.45) for a further generalization.
  :: @N(60) :: Véa el @l(#Ejercicio 1.45) para una generalización adicional.

#   :: @N(61) :: Elementary calculus books usually describe Newton's method in
#      terms of the sequence of approximations @m[xₙ₊₁ = xₙ − g(xₙ)/Dg(xₙ)].
#      Having language for talking about processes and using the idea of fixed
#      points simplifies the description of the method.
  :: @N(61) :: Los libros de cálculo elementales usualmente describen el método
     de Newton en términos de la secuencia de aproximaciones @m[xₙ₊₁ = xₙ −
     g(xₙ)/Dg(xₙ)]. Tener un lenguaje para hablar de procesos y usar la idea de
     puntos fijos simplifica la descripción del método.

#   :: @N(62) :: Newton's method does not always converge to an answer, but it can
#      be shown that in favorable cases each iteration doubles the
#      number-of-digits accuracy of the approximation to the solution. In such
#      cases, Newton's method will converge much more rapidly than the
#      half-interval method.
  :: @N(62) :: El método Newton no siempre converge en una respuesta, pero se
     puede demostrar que en casos favorables cada repetición duplica la
     precisión del número de dígitos de la aproximación a la solución. En tales
     casos, el método Newton convergerá mucho más rápidamente que el método
     de medio intervalo.

#   :: @N(63) :: For finding square roots, Newton's method converges rapidly to
#      the correct solution from any starting point.
  :: @N(63) :: Para encontrar raíces cuadradas, el método Newton converge
     rápidamente a la solución correcta desde cualquier punto de partida.

#   :: @N(64) :: The notion of first-class status of programming-language elements
#      is due to the British computer scientist Christopher Strachey (1916-1975).
  :: @N(64) :: La noción del estado de primera clase de los elementos del
     lenguaje de programación se debe al científico británico Christopher
     Strachey (1916-1975).

#   :: @N(65) :: We'll see examples of this after we introduce data structures in
#      @l(#Chapter 2).
  :: @N(65) :: Veremos ejemplos de esto después de introducir estructuras de
     datos en el @l(#Capitulo 2).

#   :: @N(66) :: The major implementation cost of first-class procedures is that
#      allowing procedures to be returned as values requires reserving storage for
#      a procedure's free variables even while the procedure is not executing. In
#      the Scheme implementation we will study in section @l(#4.1), these variables are
#      stored in the procedure's environment.
  :: @N(66) :: El principal costo de implementación de los procedimientos de
     primera clase es que permitir que los procedimientos sean devueltos como
     valores requiere reservar el almacenamiento para las variables libres de un
     procedimiento incluso cuando el procedimiento no se está ejecutando. En la
     implementación de Scheme que estudiaremos en la seccion @l(#4.1), estas
     variables se almacenan en el entorno del procedimiento.

#   :: @N(67) :: The ability to directly manipulate procedures provides an
#      analogous increase in the expressive power of a programming language. For
#      example, in section @l(#1.3.1) we introduced the @c(sum) procedure, which takes a
#      procedure @c(term) as an argument and computes the sum of the values of
#      @c(term) over some specified interval. In order to define @c(sum), it is
#      crucial that we be able to speak of a procedure such as @c(term) as an
#      entity in its own right, without regard for how @c(term) might be expressed
#      with more primitive operations. Indeed, if we did not have the notion of
#      @"(a procedure,) it is doubtful that we would ever even think of the
#      possibility of defining an operation such as @c(sum). Moreover, insofar as
#      performing the summation is concerned, the details of how @c(term) may be
#      constructed from more primitive operations are irrelevant.
  :: @N(67) :: La capacidad de manipular directamente procedimientos proporciona
     un aumento análogo en el poder expresivo de un lenguaje de
     programación. Por ejemplo, en la seccion @l(#1.3.1) presentamos el
     procedimiento @c(sum), que toma un procedimiento @c(term) como un argumento y
     calcula la suma de los valores de @c(term) más de un cierto intervalo
     especificado. Para definir @c(sum), es crucial que podamos hablar de un
     procedimiento @c(term) como una entidad por derecho propio, sin tener en
     cuenta cómo @c(term) podría expresarse con operaciones más primitivas. De
     hecho, si no tuviéramos la noción de @"(un procedimiento,) es dudoso que
     jamás pensemos en la posibilidad de definir una operación como
     @c(sum). Además, en lo que respecta a la realización de la suma,@c(term)

#   :: @N(68) :: The name @c(cons) stands for @"(construct.) The names @c(car) and
#      @c(cdr) derive from the original implementation of Lisp on the
#      IBM 704. That machine had an addressing scheme that allowed one to
#      reference the @"(address) and @"(decrement) parts of a memory
#      location. @c(Car) stands for @"(Contents of Address part of Register) and
#      @c(cdr) (pronounced @"(could-er) stands for @"(Contents of Decrement part
#      of Register.)
  :: @N(68) :: El nombre @c(cons) representa la @"(construcción. ) Los nombres
     @c(car) y @c(cdr) derivan de la implementación original de Lisp en la
     IBM 704. Esta máquina tenía un esquema de direccionamiento que permitía
     referenciar la @"(dirección) y @"(decrementar) partes de una ubicación de
     memoria. @c(Car) Significa @"(Contenido de la parte de Dirección del
     Registro) y @c(cdr)(pronunciado @"(podría-er) significa @"(Contenido de
     Decremento parte del Registro.)

#   :: @N(69) :: Another way to define the selectors and constructor is
  :: @N(69) :: Otra forma de definir los selectores y el constructor es

#      ..src > scheme
#        (define make-rat cons)
#        (define numer car)
#        (define denom cdr)
#      < src..
     ..src > scheme
       (define make-rat cons)
       (define numer car)
       (define denom cdr)
     < src..

#      The first definition associates the name @c(make-rat) with the value of the
#      expression @c(cons), which is the primitive procedure that constructs
#      pairs. Thus @c(make-rat) and @c(cons) are names for the same primitive
#      constructor.
    La primera definición asocia el nombre @c(make-rat) al valor de la expresión
    @c(cons), que es el procedimiento primitivo que construye pares. Así
    @c(make-rat) y @c(cons) son nombres para el mismo constructor primitivo.

#      Defining selectors and constructors in this way is efficient: Instead of
#      @c(make-rat) @e(calling) @c(cons), @c(make-rat) @e(is) @c(cons), so there
#      is only one procedure called, not two, when @c(make-rat) is called. On the
#      other hand, doing this defeats debugging aids that trace procedure calls or
#      put breakpoints on procedure calls: You may want to watch @c(make-rat)
#      being called, but you certainly don't want to watch every call to @c(cons).
    Definir selectores y constructores de esta manera es eficiente: En lugar de
    @c(make-rat) @e(llamar) @c(cons), @c(make-rat) @e(es) @c(cons), por lo que
    sólo hay un procedimiento llamado, no dos, cuando @c(make-rat) se llama. Por
    otro lado, al hacer esto derrota las ayudas de depuración que rastrean
    llamadas de procedimiento o ponen puntos de interrupción en las llamadas de
    procedimiento: es posible que desee ver @c(make-rat) ser llamado, pero
    ciertamente no desea ver todas las llamadas a @c(cons).

#      We have chosen not to use this style of definition in this book.
    Hemos decidido no utilizar este estilo de definición en este libro.

#   :: @N(70) :: @c(Display) is the Scheme primitive for printing data.  The
#      Scheme primitive @c(newline) starts a new line for printing. Neither of
#      these procedures returns a useful value, so in the uses of @c(print-rat)
#      below, we show only what @c(print-rat) prints, not what the interpreter
#      prints as the value returned by @c(print-rat).
  :: @N(70) :: @c(Display) Es la primitiva Scheme para imprimir datos. La
     primitiva Scheme @c(newline) inicia una nueva línea para imprimir. Ninguno
     de estos procedimientos devuelve un valor útil, por lo que en los usos de
     @c(print-rat) abajo, mostramos sólo lo que @c(print-rat) imprime, no lo que
     el intérprete imprime como el valor devuelto por @c(print-rat).

#   :: @N(71) :: Surprisingly, this idea is very difficult to formulate
#      rigorously. There are two approaches to giving such a formulation. One,
#      pioneered by C. A. R. @l[#Hoare (1972)], is known as the method of
#      @e(abstract models). It formalizes the @"(procedures plus conditions)
#      specification as outlined in the rational-number example above. Note that
#      the condition on the rational-number representation was stated in terms of
#      facts about integers (equality and division). In general, abstract models
#      define new kinds of data objects in terms of previously defined types of
#      data objects. Assertions about data objects can therefore be checked by
#      reducing them to assertions about previously defined data objects. Another
#      approach, introduced by Zilles at @A(MIT), by Goguen, Thatcher, Wagner, and
#      Wright at IBM (see @l(#Thatcher et al. 1978)), and by Guttag at Toronto
#      (see @l(#Guttag 1977)), is called @e(algebraic specification). It regards
#      the @"(procedures) as elements of an abstract algebraic system whose
#      behavior is specified by axioms that correspond to our @"(conditions,) and
#      uses the techniques of abstract algebra to check assertions about data
#      objects. Both methods are surveyed in the paper by @l(#Liskov and Zilles
#      (1975)).
  :: @N(71) :: Sorprendentemente, esta idea es muy difícil de formular con
     rigor. Hay dos enfoques para dar tal formulación. Uno, iniciado por CAR
     @l(#Hoare-(1972)<>Hoare (1972)), es conocido como el método de los
     @e(modelos abstractos). Formaliza la especificación de @"(procedimientos
     más condiciones) como se describe en el ejemplo de número racional
     arriba. Obsérvese que la condición en la representación del número racional
     se expresó en términos de hechos sobre enteros (igualdad y división). En
     general, los modelos abstractos definen nuevos tipos de objetos de datos en
     términos de tipos de objetos de datos previamente definidos. Por lo tanto,
     las afirmaciones sobre objetos de datos pueden comprobarse reduciéndolas a
     afirmaciones sobre objetos de datos previamente definidos. Otro enfoque,
     introducido por Zilles en el @A(MIT), por Goguen, Thatcher, Wagner,
     @l(#Thatcher-et-al.-1978<>Y Wright en IBM (ver Thatcher et al., 1978) ), y
     por Guttag en Toronto (véase @l(#Guttag-1977<>Guttag 1977) ), se denomina
     @e(especificación algebraica). Considera los @"(procedimientos) como
     elementos de un sistema algebraico abstracto cuyo comportamiento es
     especificado por axiomas que corresponden a nuestras @"(condiciones,) y
     utiliza las técnicas del álgebra abstracta para verificar afirmaciones
     sobre objetos de datos. Ambos métodos son examinados en el trabajo por
     @l(#Liskov-and-Zilles-(1975<>Liskov y Zilles (1975) ). @"(Considera los
     procedimientos) como elementos de un sistema algebraico abstracto cuyo
     comportamiento es especificado por axiomas que corresponden a nuestras
     @"(condiciones,) y utiliza las técnicas del álgebra abstracta para
     verificar afirmaciones sobre objetos de datos. Ambos métodos son examinados
     en el trabajo por @l(#Liskov-and-Zilles-(1975<>Liskov y Zilles (1975)
     ). @"(Considera los procedimientos) como elementos de un sistema algebraico
     abstracto cuyo comportamiento es especificado por axiomas que corresponden
     a nuestras @"(condiciones,) y utiliza las técnicas del álgebra abstracta
     para verificar afirmaciones sobre objetos de datos. Ambos métodos son
     examinados en el trabajo por @l(#Liskov-and-Zilles-(1975<>Liskov y Zilles
     (1975) ).

#   :: @N(72) :: The use of the word @"(closure) here comes from abstract algebra,
#      where a set of elements is said to be closed under an operation if applying
#      the operation to elements in the set produces an element that is again an
#      element of the set. The Lisp community also (unfortunately) uses the word
#      @"(closure) to describe a totally unrelated concept: A closure is an
#      implementation technique for representing procedures with free
#      variables. We do not use the word @"(closure) in this second sense in this
#      book.
  :: @N(72) :: El uso de la palabra @"(cierre) aquí proviene de álgebra
     abstracta, donde un conjunto de elementos se dice que se cierra en una
     operación si la aplicación de la operación a los elementos en el conjunto
     produce un elemento que es de nuevo un elemento del conjunto. La comunidad
     Lisp también (desafortunadamente) usa la palabra @"(cierre) para describir
     un concepto totalmente no relacionado: Un cierre es una técnica de
     implementación para representar procedimientos con variables libres. No
     usamos la palabra " @"(cierre") en este segundo sentido en este libro.

#   :: @N(73) ::The notion that a means of combination should satisfy closure is a
#      straightforward idea. Unfortunately, the data combiners provided in many
#      popular programming languages do not satisfy closure, or make closure
#      cumbersome to exploit. In Fortran or Basic, one typically combines data
#      elements by assembling them into arrays––but one cannot form arrays whose
#      elements are themselves arrays. Pascal and C admit structures whose
#      elements are structures. However, this requires that the programmer
#      manipulate pointers explicitly, and adhere to the restriction that each
#      field of a structure can contain only elements of a prespecified
#      form. Unlike Lisp with its pairs, these languages have no built-in
#      general-purpose glue that makes it easy to manipulate compound data in a
#      uniform way. This limitation lies behind Alan Perlis's comment in his
#      foreword to this book: @"(In Pascal the plethora of declarable data
#      structures induces a specialization within functions that inhibits and
#      penalizes casual cooperation. It is better to have 100 functions operate on
#      one data structure than to have 10 functions operate on 10 data
#      structures.)
  :: @N(73) :: La noción de que un medio de combinación debe satisfacer el
     cierre es una idea directa. Desafortunadamente, los combinadores de datos
     proporcionados en muchos lenguajes de programación populares no satisfacen
     el cierre, o hacen que el cierre resulte engorroso para explotar. En
     Fortran o Basic, normalmente se combinan elementos de datos ensamblándolos
     en arrays, pero no se pueden formar matrices cuyos elementos sean
     arrays. Pascal y C admiten estructuras cuyos elementos son estructuras. Sin
     embargo, esto requiere que el programador manipule punteros explícitamente
     y se adhiera a la restricción de que cada campo de una estructura puede
     contener sólo elementos de una forma preespecificada. A diferencia de Lisp
     con sus pares, estos lenguajes no tienen pegamento de uso general
     incorporado que hace que sea fácil manipular datos compuestos de una manera
     uniforme. Esta limitación se encuentra detrás de Alan Perlis ' @"(En
     Pascal, la plétora de estructuras de datos declarables induce una
     especialización dentro de las funciones que inhibe y penaliza la
     cooperación casual. Es mejor tener 100 funciones funcionan en una
     estructura de datos que tener 10 funciones funcionan en 10 estructuras de
     datos.)

#   :: @N(74) :: In this book, we use @e(list) to mean a chain of pairs terminated
#      by the end-of-list marker. In contrast, the term @e(list structure) refers
#      to any data structure made out of pairs, not just to lists.
  :: @N(74) :: En este libro, usamos @e(lista) para significar una cadena de
     pares terminada por el marcador de fin de lista. En cambio, el término
     @e(estructura de lista se) refiere a cualquier estructura de datos hecha de
     pares, no sólo a listas.

#   :: @N(75) :: Since nested applications of @c(car) and @c(cdr) are cumbersome
#      to write, Lisp dialects provide abbreviations for them––for instance,
  :: @N(75) :: Dado que las aplicaciones anidadas de @c(car) y @c(cdr) son
     engorrosas para escribir, dialectos Lisp proporcionar abreviaturas para
     ellos - por ejemplo,

#      ..src > scheme
#        (cadr ⟨arg⟩) = (car (cdr ⟨arg⟩))
#      < src..
     ..src > scheme
       (cadr ⟨arg⟩) = (car (cdr ⟨arg⟩))
     < src..

#      The names of all such procedures start with @c(c) and end with @c(r). Each
#      @c(a) between them stands for a @c(car) operation and each @c(d) for a
#      @c(cdr) operation, to be applied in the same order in which they appear in
#      the name. The names @c(car) and @c(cdr) persist because simple combinations
#      like @c(cadr) are pronounceable.
    Los nombres de todos estos procedimientos comienzan @c(c) y terminan con
    @c(r). Cada @c(a) entre ellos representa una @c(car) operación y cada uno
    @c(d) para una @c(cdr) operación, que debe aplicarse en el mismo orden en el
    que aparecen en el nombre. Los nombres @c(car) y @c(cdr) persisten porque
    las combinaciones simples como @c(cadr) son pronunciables.

#   :: @N(76) :: It's remarkable how much energy in the standardization of Lisp
#      dialects has been dissipated in arguments that are literally over nothing:
#      Should @c(nil) be an ordinary name?  Should the value of @c(nil) be a
#      symbol?  Should it be a list?  Should it be a pair?  In Scheme, @c(nil) is
#      an ordinary name, which we use in this section as a variable whose value is
#      the end-of-list marker (just as @c(true) is an ordinary variable that has a
#      true value). Other dialects of Lisp, including Common Lisp, treat @c(nil)
#      as a special symbol. The authors of this book, who have endured too many
#      language standardization brawls, would like to avoid the entire issue. Once
#      we have introduced quotation in section @l(#2.3), we will denote the empty list as
#      @c['()] and dispense with the variable @c(nil) entirely.
  :: @N(76) :: Es notable cuánta energía en la estandarización de los dialectos
     Lisp se ha disipado en argumentos que literalmente están sobre nada: ¿Debe
     @c(nil) ser un nombre ordinario? ¿Debe el valor de @c(nil) ser un símbolo?
     ¿Debe ser una lista? ¿Debe ser un par? En Scheme, @c(nil) es un nombre
     ordinario, que usamos en esta sección como una variable cuyo valor es el
     marcador de fin de lista (al igual @c(true) que una variable ordinaria que
     tiene un valor verdadero). Otros dialectos de Lisp, incluyendo Common Lisp,
     tratan @c(nil) como un símbolo especial. Los autores de este libro, que han
     soportado demasiadas peleas de estandarización lingüística, quisieran
     evitar todo el asunto. Una vez que hemos introducido la cita en
     @l(#2.3), vamos a denotar la lista vacía como @c('()) y prescindir de
     la variable en su @c(nil) totalidad.

#   :: @N(77) :: To define @c(f) and @c(g) using @c(lambda) we would write
  :: @N(77) :: Definir @c(f) y @c(g) usar @c(lambda) escribiríamos

#      ..src > scheme
#        (define f (lambda (x y . z) ⟨body⟩))
#        (define g (lambda w ⟨body⟩))
#      < src..
     ..src > scheme
       (define f (lambda (x y . z) ⟨body⟩))
       (define g (lambda w ⟨body⟩))
     < src..

#   :: @N(78) :: Scheme standardly provides a @c(map) procedure
#      that is more general than the one described here. This more general @c(map)
#      takes a procedure of @m(n) arguments, together with @m(n) lists, and
#      applies the procedure to all the first elements of the lists, all the
#      second elements of the lists, and so on, returning a list of the
#      results. For example:
  :: @N(78) :: Scheme
     proporciona de forma estándar un procedimiento @c(map) que es más general
     que el descrito aquí. Esto más general @c(map) toma un procedimiento de
     @m(n) argumentos, junto con @m(n) listas, y aplica el procedimiento a todos
     los primeros elementos de las listas, todos los segundos elementos de las
     listas, y así sucesivamente, devolviendo una lista de los resultados. Por
     ejemplo:

#      ..srci > scheme
#        > (map +
#        ^      (list 1 2 3)
#        ^      (list 40 50 60)
#        ^      (list 700 800 900))
#        (741 852 963)
#        > (map (lambda (x y) (+ x (* 2 y)))
#        ^      (list 1 2 3)
#        ^      (list 4 5 6))
#        (9 12 15)
#      < srci..
     ..srci > scheme
       > (map +
       ^      (list 1 2 3)
       ^      (list 40 50 60)
       ^      (list 700 800 900))
       (741 852 963)
       > (map (lambda (x y) (+ x (* 2 y)))
       ^      (list 1 2 3)
       ^      (list 4 5 6))
       (9 12 15)
     < srci..

#   :: @N(79) :: The order of the first two clauses in the @c(cond) matters, since
#      the empty list satisfies @c(null?) and also is not a pair.
  :: @N(79) :: El orden de las dos primeras cláusulas en los @c(cond) asuntos,
     ya que la lista vacía satisface @c(null?) y tampoco es un par.

#   :: @N(80) :: This is, in fact, precisely the @c(fringe) procedure from
#      @l(#Exercise 2.28). Here we've renamed it to emphasize that it is part of a
#      family of general sequence-manipulation procedures.
  :: @N(80) :: Este es, de hecho, precisamente el procedimiento @c(fringe) del
     @l(#Ejercicio 2.28). Aquí lo hemos renombrado para enfatizar
     que es parte de una familia de procedimientos generales de manipulación de
     secuencias.

#   :: @N(81) :: Richard @l[#Waters (1979)] developed a program that automatically
#      analyzes traditional Fortran programs, viewing them in terms of maps,
#      filters, and accumulations. He found that fully 90 percent of the code in
#      the Fortran Scientific Subroutine Package fits neatly into this
#      paradigm. One of the reasons for the success of Lisp as a programming
#      language is that lists provide a standard medium for expressing ordered
#      collections so that they can be manipulated using higher-order
#      operations. The programming language APL owes much of its power and appeal
#      to a similar choice. In APL all data are represented as arrays, and there
#      is a universal and convenient set of generic operators for all sorts of
#      array operations.
  :: @N(81) :: Richard @l(#Waters-(1979)<>Waters (1979)) desarrolló un programa
     que analiza automáticamente los programas tradicionales de Fortran,
     visualizándolos en términos de mapas, filtros y acumulaciones. Encontró que
     el 90 por ciento del código en el Paquete de Subrutina Científica de
     Fortran encaja perfectamente en este paradigma. Una de las razones del
     éxito de Lisp como lenguaje de programación es que las listas proporcionan
     un medio estándar para expresar colecciones ordenadas para que puedan ser
     manipuladas usando operaciones de orden superior. El lenguaje de
     programación APL debe gran parte de su poder y apela a una elección
     similar. En APL todos los datos se representan como arrays, y hay un
     conjunto universal y conveniente de operadores genéricos para todo tipo de
     operaciones de matrices.

#   :: @N(82) :: According to @l(#Knuth 1981), this rule was formulated by
#      W. G. Horner early in the nineteenth century, but the method was actually
#      used by Newton over a hundred years earlier. Horner's rule evaluates the
#      polynomial using fewer additions and multiplications than does the
#      straightforward method of first computing @m(aₙ xⁿ), then adding
#      @m(aₙ₋₁xⁿ⁻¹), and so on. In fact, it is possible to prove that any
#      algorithm for evaluating arbitrary polynomials must use at least as many
#      additions and multiplications as does Horner's rule, and thus Horner's rule
#      is an optimal algorithm for polynomial evaluation. This was proved (for the
#      number of additions) by A. M. Ostrowski in a 1954 paper that essentially
#      founded the modern study of optimal algorithms. The analogous statement for
#      multiplications was proved by V. Y. Pan in 1966. The book by @l[#Borodin
#      and Munro (1975)] provides an overview of these and other results about
#      optimal algorithms.
  :: @N(82) :: Según @l(#Knuth-1981<>Knuth 1981), esta regla fue formulada por
     WG Horner a principios del siglo XIX, pero el método fue utilizado
     realmente por Newton más de cien años antes. La regla de Horner evalúa el
     polinomio usando menos adiciones y multiplicaciones que el método sencillo
     de calcular primero @m(aₙ xⁿ), a @m(~) nadiendo entonces @m(aₙ₋₁xⁿ⁻¹), y
     así sucesivamente. De hecho, es posible probar que cualquier algoritmo para
     evaluar polinomios arbitrarios debe utilizar al menos tantas adiciones y
     multiplicaciones como la regla de Horner, y por lo tanto la regla de Horner
     es un algoritmo óptimo para la evaluación polinomial. Esto fue probado (por
     el número de adiciones) por AM Ostrowski en un artículo de 1954 que
     esencialmente fundó el estudio moderno de algoritmos óptimos.@l[##Borodin
     and Munro (1975)]

#   :: @N(83) :: This definition uses the extended version of @c(map) described in
#     @n(78<>Footnote 78).
  :: @N(83) :: Esta definición utiliza la versión ampliada de la @c(map)
     descrita en la@n(78<>Nota 78).

#   :: @N(84) :: This approach to nested mappings was shown to us by David Turner,
#      whose languages KRC and Miranda provide elegant formalisms for dealing with
#      these constructs. The examples in this section (see also @l(#Exercise
#      2.42)) are adapted from @l(#Turner 1981). in section @l(#3.5.3), we'll see how this
#      approach generalizes to infinite sequences.
  :: @N(84) :: Esta aproximación a las asignaciones anidadas nos fue mostrada
     por David Turner, cuyas lenguas KRC y Miranda proporcionan formalismos
     elegantes para tratar con estos constructos. Los ejemplos de esta sección
     (véase también el @l(#Ejercicio 2.42) ) están adaptados de
     @l(#Turner-1981<>Turner 1981). en la seccion @l(#3.5.3), veremos cómo este
     enfoque se generaliza a secuencias infinitas.

#   :: @N(85) :: We're representing a pair here as a list of two elements rather
#      than as a Lisp pair. Thus, the @"(pair) @m[(i, j)] is represented as
#      @c[(list i j)], not @c[(cons i j)].
  :: @N(85) :: Estamos representando a un par aquí como una lista de dos
     elementos en lugar de como un par Lisp. Por lo tanto, el @"(par ) @m[(i,
     j)] se representa como @c[(list i j)], no @c[(cons i j)].

#   :: @N(86) :: The set @m(S - x) is the set of all elements of @m(S), excluding
#      @m(x).
  :: @N(86) :: El conjunto @m(S - x) es el conjunto de todos los elementos de
     @m(S), excluyendo @m(x).

#   :: @N(87) :: Semicolons in Scheme code are used to introduce @e(comments).
#      Everything from the semicolon to the end of the line is ignored by the
#      interpreter. In this book we don't use many comments; we try to make our
#      programs self-documenting by using descriptive names.
  :: @N(87) :: Se utilizan puntos y comas en el código del Scheme para
     introducir @e(comentarios). Todo desde el punto y coma hasta el final de la
     línea es ignorado por el intérprete. En este libro no usamos muchos
     comentarios; Tratamos de hacer que nuestros programas se auto-documenten
     usando nombres descriptivos.

#   :: @N(88) :: The picture language is based on the language Peter Henderson
#      created to construct images like M.C. Escher's @"(Square Limit) woodcut
#      (see @l(#Henderson 1982)). The woodcut incorporates a repeated scaled
#      pattern, similar to the arrangements drawn using the @c(square-limit)
#      procedure in this section.
  :: @N(88) :: El lenguaje de la imagen se basa en el lenguaje que Peter
     Henderson creó para construir imágenes como el grabado en madera de MC
     Escher @"(Square Limit) (véase @l(#Henderson-1982<>Henderson, 1982) ). El
     grabar en madera incorpora un patrón escalado repetido, similar a los
     arreglos dibujados usando el procedimiento @c(square-limit) en esta
     sección.

#   :: @N(89) :: William Barton Rogers (1804-1882) was the founder and first
#      president of @A(MIT). A geologist and talented teacher, he taught at
#      William and Mary College and at the University of Virginia. In 1859 he
#      moved to Boston, where he had more time for research, worked on a plan for
#      establishing a @"(polytechnic institute,) and served as Massachusetts's
#      first State Inspector of Gas Meters.
  :: @N(89) :: William Barton Rogers (1804-1882) fue el fundador y primer
     presidente del @A(MIT). Geólogo y talentoso maestro, enseñó en William and
     Mary College y en la Universidad de Virginia. En 1859 se trasladó a Boston,
     donde tuvo más tiempo para la investigación, trabajó en un plan para
     establecer un @"(instituto politécnico,) y sirvió como el primer inspector
     del estado de Massachusetts de los contadores de gas.

#      When @A(MIT) was established in 1861, Rogers was elected its first
#      president. Rogers espoused an ideal of @"(useful learning) that was
#      different from the university education of the time, with its overemphasis
#      on the classics, which, as he wrote, @"(stand in the way of the broader,
#      higher and more practical instruction and discipline of the natural and
#      social sciences.)  This education was likewise to be different from narrow
#      trade-school education.  In Rogers's words:
    Cuando el @A(MIT) fue establecido en 1861, Rogers fue elegido su primer
    presidente. Rogers adoptó un ideal de @"(aprendizaje útil) que era diferente
    de la educación universitaria de la época, con su énfasis excesivo en los
    clásicos, que, como él escribió, se @"(interponían en el camino de la
    instrucción y disciplina más amplia, más alta y más práctica de lo natural y
    lo Ciencias Sociales. )  Esta educación también debía ser diferente de la
    estrecha educación comercial-escolar. En palabras de Rogers:

#      ..tab >
    ..tab >
#        The world-enforced distinction between the practical and the scientific
#        worker is utterly futile, and the whole experience of modern times has
#        demonstrated its utter worthlessness.
       La distinción impuesta por el mundo entre el trabajador práctico y el
       científico es totalmente inútil, y toda la experiencia de los tiempos
       modernos ha demostrado su absoluta inutilidad.

#      Rogers served as president of @A(MIT) until 1870, when he resigned due to
#      ill health. In 1878 the second president of @A(MIT), John Runkle, resigned
#      under the pressure of a financial crisis brought on by the Panic of 1873
#      and strain of fighting off attempts by Harvard to take over @A(MIT).
#      Rogers returned to hold the office of president until 1881.
     Rogers sirvió como presidente del @A(MIT) hasta 1870, cuando renunció
     debido a la mala salud. En 1878, el segundo presidente del @A(MIT), John
     Runkle, renunció bajo la presión de una crisis financiera provocada por el
     pánico de 1873 y la tensión de los intentos de lucha de Harvard para
     hacerse con el @A(MIT). Rogers volvió a ocupar el cargo de presidente
     hasta 1881.

#      Rogers collapsed and died while addressing @A(MIT)'s graduating class at
#      the commencement exercises of 1882. Runkle quoted Rogers's last words
#      in a memorial address delivered that same year:
     Rogers se derrumbó y murió mientras se dirigía a la clase graduada del
     @A(MIT) en los ejercicios de inicio de 1882. Runkle citó las últimas
     palabras de Rogers en un discurso conmemorativo pronunciado ese mismo año:

#      ..tab >
    ..tab >
#        @"(As I stand here today and see what the Institute is, … I call to mind
#        the beginnings of science. I remember one hundred and fifty years ago
#        Stephen Hales published a pamphlet on the subject of illuminating gas, in
#        which he stated that his researches had demonstrated that 128 grains of
#        bituminous coal--) @"(Bituminous coal,) these were his last words on
#        earth. Here he bent forward, as if consulting some notes on the table
#        before him, then slowly regaining an erect position, threw up his hands,
#        and was translated from the scene of his earthly labors and triumphs to
#        @"(the tomorrow of death,) where the mysteries of life are solved, and
#        the disembodied spirit finds unending satisfaction in contemplating the
#        new and still unfathomable mysteries of the infinite future.
     @"(Mientras estoy aquí hoy y veo lo que es el Instituto ... Recuerdo los
     comienzos de la ciencia. Recuerdo que hace ciento cincuenta años Stephen
     Hales publicó un folleto sobre el tema de la iluminación del gas, en el que
     afirmó que sus investigaciones habían demostrado que 128 granos de carbón )
     @"(bituminoso - carbón bituminoso,) estas fueron sus últimas palabras en la
     tierra. Aquí se inclinó hacia adelante, como si consultara algunas notas
     sobre la mesa que tenía ante sí, luego lentamente recuperó una posición
     erguida, levantó las manos y fue trasladado de la escena de sus trabajos
     terrenales y triunfos al @"(mañana de la muerte,) donde los misterios de La
     vida se resuelve y el espíritu desencarnado encuentra satisfacción sin fin
     en contemplar los nuevos y todavía insondables misterios del futuro
     infinito.

#      In the words of Francis A. Walker (@A(MIT)'s third president):
     En palabras de Francis A. Walker ( tercer presidente del @A(MIT) ):

#      ..tab >
     ..tab >
#        All his life he had borne himself most faithfully and heroically, and he
#        died as so good a knight would surely have wished, in harness, at his
#        post, and in the very part and act of public duty.
       Durante toda su vida se había portado a sí mismo de una manera fiel y
       heroica, y murió como un caballero tan bueno que seguramente habría
       deseado, en arneses, en su puesto y en la parte y acto del deber público.

#   :: @N(90) :: Equivalently, we could write
  :: @N(90) :: Equivalentemente, podríamos escribir

#      ..src > scheme
#        (define flipped-pairs
#          (square-of-four
#           identity flip-vert identity flip-vert))
#      < src..
     ..src > scheme
       (define flipped-pairs
         (square-of-four
          identity flip-vert identity flip-vert))
     < src..

#   :: @N(91) :: @c(Rotate180) rotates a painter by 180 degrees (see @l(#Exercise
#      2.50)). Instead of @c(rotate180) we could say @c[(compose flip-vert
#      flip-horiz)], using the @c(compose) procedure from @l(#Exercise 1.42).
  :: @N(91) :: @c(Rotate180) Gira un pintor 180 grados (véase el
     @l(#Ejercicio 2.50) ). En lugar de @c(rotate180) podríamos
     decir @c[(compose flip-vert flip-horiz)], usando el procedimiento @c(compose) del @l(#Ejercicio 1.42).

#   :: @N(92) :: @c(Frame-coord-map) uses the vector operations described in
#      @l(#Exercise 2.46) below, which we assume have been implemented using some
#      representation for vectors. Because of data abstraction, it doesn't matter
#      what this vector representation is, so long as the vector operations behave
#      correctly.
  :: @N(92) :: @c(Frame-coord-map) Utiliza las operaciones de vector descritas
     en el @l(#Ejercicio 2.46 a) continuación, que asumimos han
     sido implementadas usando alguna representación para vectores. Debido a la
     abstracción de datos, no importa cuál sea esta representación vectorial,
     siempre y cuando las operaciones vectoriales se comporten correctamente.

#   :: @N(93) :: @c(Segments->painter) uses the representation for line segments
#      described in @l(#Exercise 2.48) below. It also uses the @c(for-each)
#      procedure described in @l(#Exercise 2.23).
  :: @N(93) :: @c(Segments->painter) Utiliza la representación para segmentos
     de línea descritos en el @l(#Ejercicio 2.48 a)
     continuación. También utiliza el procedimiento @c(for-each) descrito en el
     @l(#Ejercicio 2.23).

#   :: @N(94) :: For example, the @c(rogers) painter of @l(#Figure 2.11) was
#      constructed from a gray-level image. For each point in a given frame, the
#      @c(rogers) painter determines the point in the image that is mapped to it
#      under the frame coordinate map, and shades it accordingly. By allowing
#      different types of painters, we are capitalizing on the abstract data idea
#      discussed in section @l(#2.1.3), where we argued that a rational-number
#      representation could be anything at all that satisfies an appropriate
#      condition. Here we're using the fact that a painter can be implemented in
#      any way at all, so long as it draws something in the designated frame.
#      @l(#2.1.3) also showed how pairs could be implemented as procedures.
#      Painters are our second example of a procedural representation for data.
  :: @N(94) :: Por ejemplo, el @c(rogers) pintor de la @l(#Figura
     2.11) se construyó a partir de una imagen de nivel de gris. Para cada punto
     en un marco dado, el @c(rogers) pintor determina el punto en la imagen que
     se asigna a él bajo el mapa de coordenadas del marco, y sombrea en
     consecuencia. Al permitir diferentes tipos de pintores, estamos
     capitalizando la idea de datos abstractos discutida en la seccion @l(#2.1.3),
     donde argumentamos que una representación de números racionales podría ser
     cualquier cosa que satisfaga una condición apropiada. Aquí estamos usando
     el hecho de que un pintor puede ser implementado de cualquier manera en
     absoluto, siempre y cuando dibuje algo en el marco
     designado. @l(#2.1.3) también mostró cómo los pares podrían ser
     implementados como procedimientos. Los pintores son nuestro segundo ejemplo
     de representación procesal para los datos.

#   :: @N(95) :: @c(Rotate90) is a pure rotation only for square frames, because
#      it also stretches and shrinks the image to fit into the rotated frame.
  :: @N(95) :: @c(Rotate90) Es una rotación pura sólo para cuadros cuadrados,
     porque también estira y encoge la imagen para encajar en el marco girado.

#   :: @N(96) :: The diamond-shaped images in @l(#Figure 2.10) and @l(#Figure
#      2.11) were created with @c(squash-inwards) applied to @c(wave) and
#      @c(rogers).
  :: @N(96) :: Las imágenes en forma de diamante en la @l(#Figura
     2.10) y la @l(#Figura 2.11) se crearon con @c(squash-inwards)
     aplicación a @c(wave) y @c(rogers).

#   :: @N(97) :: Section @l(#3.3.4) describes one such language.
  :: @N(97) :: La sección @l(#3.3.4) describe uno de esos idiomas.

#   :: @N(98) :: Allowing quotation in a language wreaks havoc with the ability to
#      reason about the language in simple terms, because it destroys the notion
#      that equals can be substituted for equals. For example, three is one plus
#      two, but the word @"(three) is not the phrase @"(one plus two). Quotation
#      is powerful because it gives us a way to build expressions that manipulate
#      other expressions (as we will see when we write an interpreter in
#      @l(#Chapter 4)). But allowing statements in a language that talk about
#      other statements in that language makes it very difficult to maintain any
#      coherent principle of what @"(equals can be substituted for equals) should
#      mean. For example, if we know that the evening star is the morning star,
#      then from the statement @"(the evening star is Venus) we can deduce @"(the
#      morning star is Venus.)  However, given that @"(John knows that the evening
#      star is Venus) we cannot infer that @"(John knows that the morning star is
#      Venus.)
  :: @N(98) :: Permitir que la cita en un idioma cause estragos con la capacidad
     de razonar sobre el lenguaje en términos simples, porque destruye la noción
     de que iguales pueden ser sustituidos por iguales. Por ejemplo, tres es uno
     más dos, pero la palabra @"(tres) no es la frase @"(uno más dos). La cita
     es poderosa porque nos da una forma de construir expresiones que manipulan
     otras expresiones (como veremos cuando escribimos un intérprete en el
     @l(Capitulo 4) ). Pero permitir declaraciones en un lenguaje
     que habla de otras declaraciones en ese idioma hace que sea muy difícil
     mantener un principio coherente de lo que los @"(iguales pueden ser
     sustituidos por iguales). Por ejemplo, si sabemos que la estrella de la
     tarde es la estrella de la mañana, @"(Entonces de la declaración la
     estrella de la tarde es Venus) podemos deducir que @"(la estrella de la
     mañana es Venus. )  Sin embargo, dado que @"(Juan sabe que la estrella de
     la tarde es Venus,) no podemos inferir que @"(Juan sabe que la estrella de
     la mañana es Venus.)

#   :: @N(99) :: The single quote is different from the double quote we have been
#      using to enclose character strings to be printed. Whereas the single quote
#      can be used to denote lists or symbols, the double quote is used only with
#      character strings.  In this book, the only use for character strings is as
#      items to be printed.
  :: @N(99) :: La cita simple es diferente de la cita doble que hemos estado
     utilizando para incluir cadenas de caracteres que se van a
     imprimir. Mientras que la comilla simple se puede utilizar para denotar
     listas o símbolos, la comilla doble se utiliza sólo con cadenas de
     caracteres. En este libro, el único uso para cadenas de caracteres es como
     elementos que se van a imprimir.

#   :: @N(100) :: Strictly, our use of the quotation mark violates the general
#      rule that all compound expressions in our language should be delimited by
#      parentheses and look like lists. We can recover this consistency by
#      introducing a special form @c(quote), which serves the same purpose as the
#      quotation mark. Thus, we would type @c[(quote a)] instead of @c('a), and we
#      would type @c[(quote (a b c))] instead of @c['(a b c)].  This is precisely
#      how the interpreter works. The quotation mark is just a single-character
#      abbreviation for wrapping the next complete expression with @c(quote) to
#      form @c[(quote ⟨expression⟩)]. This is important because it maintains
#      the principle that any expression seen by the interpreter can be
#      manipulated as a data object. For instance, we could construct the
#      expression @c[(car '(a b c))], which is the same as @c[(car (quote (a b
#      c)))], by evaluating @c[(list 'car (list 'quote '(a b c)))].
  :: @N(100) :: Estrictamente, nuestro uso de las comillas viola la regla
     general de que todas las expresiones compuestas en nuestro lenguaje deben
     ser delimitadas por paréntesis y parecen listas. Podemos recuperar esta
     consistencia introduciendo un formulario especial @c(quote), que tiene el
     mismo propósito que la comilla. Por lo tanto, escribiríamos en @c[(quote
     a)] lugar de @c('a), y escribiríamos en @c[(quote (a b c))] lugar de @c('(a
     b c)). Así es como funciona el intérprete. La comilla es sólo una
     abreviatura de un solo carácter para envolver la siguiente expresión
     completa con @c(quote) forma @c[(quote ⟨expression⟩)]. Esto es importante
     porque mantiene el principio de que cualquier expresión vista por el
     intérprete puede ser manipulada como un objeto de datos. Por ejemplo,
     podríamos construir la expresión @c[(car '(a b c))], que es lo mismo
     @c[(car (quote (a b c)))], evaluando @c[(list 'car (list 'quote '(a b
     c)))].

#   :: @N(101) :: We can consider two symbols to be @"(the same) if they consist
#      of the same characters in the same order. Such a definition skirts a deep
#      issue that we are not yet ready to address: the meaning of @"(sameness) in
#      a programming language. We will return to this in @l(#Chapter 3)
#      (section @l(#3.1.3)).
  :: @N(101) :: Podemos considerar que dos símbolos son @"(iguales) si consisten
     en los mismos caracteres en el mismo orden. Tal definición bordea una
     cuestión profunda que todavía no estamos listos para abordar: el
     significado de @"(igualdad) en un lenguaje de programación. Volveremos a
     esto en el @l(#Capitulo 3) (seccion @l(#3.1.3)).

#   :: @N(102) :: In practice, programmers use @c(equal?) to compare lists that
#      contain numbers as well as symbols. Numbers are not considered to be
#      symbols. The question of whether two numerically equal numbers (as tested
#      by @c(=)) are also @c(eq?) is highly implementation-dependent. A better
#      definition of @c(equal?) (such as the one that comes as a primitive in
#      Scheme) would also stipulate that if @c(a) and @c(b) are both numbers, then
#      @c(a) and @c(b) are @c(equal?) if they are numerically equal.
  :: @N(102) :: En la práctica, los programadores utilizan @c(equal?) para
     comparar listas que contienen números, así como símbolos. Los números no se
     consideran símbolos. La cuestión de si dos números numéricamente iguales
     (como probado por @c(=)) también @c(eq?) es altamente dependiente de la
     implementación. Una mejor definición de @c(equal?)(como la que viene como
     primitiva en Scheme) también estipularía que si @c(a) y @c(b) son ambos
     números, entonces @c(a) y @c(b) son @c(equal?) si son numéricamente
     iguales.

#   :: @N(103) :: If we want to be more formal, we can specify @"(consistent with
#      the interpretations given above) to mean that the operations satisfy a
#      collection of rules such as these:
  :: @N(103) :: Si queremos ser más formales, podemos especificar, de @"(acuerdo
     con las interpretaciones dadas anteriormente,) que las operaciones
     satisfacen una colección de reglas como estas:

#      - For any set @c(S) and any object @c(x), @c[(element-of-set? x (adjoin-set
#        x S))] is true (informally: @"(Adjoining an object to a set produces a
#        set that contains the object)).
     - Para cualquier conjunto @c(S) y cualquier objeto @c(x),
       @c[(element-of-set? x (adjoin-set x S))] es true (informalmente:
       @"(Adjuntar un objeto a un conjunto produce un conjunto que contiene el
       objeto) ).

#      - For any sets @c(S) and @c(T) and any object @c(x), @c[(element-of-set? x
#        (union-set S T))] is equal to @c[(or (element-of-set? x S)
#        (element-of-set? x T))] (informally: @"(The elements of @c[(union S T)]
#        are the elements that are in @c(S) or in @c(T)).
     - Para cualquier conjunto de @c(S) y @c(T) y cualquier objeto @c(x),
       @c[(element-of-set? x (union-set S T))] es igual a @c[(or
       (element-of-set? x S) (element-of-set? x T))](informalmente: @"(Los
       elementos de @c[(union S T)] son los elementos que se encuentran en @c(S)
       o en@c(T)).

#      - For any object @c(x), @c[(element-of-set? x '())] is false (informally:
#        @"(No object is an element of the empty set).
     - Para cualquier objeto @c(x), @c[(element-of-set? x '())] es falso
       (informalmente: @"(Ningún objeto es un elemento del conjunto vacío).

#   :: @N(104) :: Halving the size of the problem at each step is the
#      distinguishing characteristic of logarithmic growth, as we saw with the
#      fast-exponentiation algorithm of section @l(#1.2.4) and the half-interval search
#      method of section @l(#1.3.3).
  :: @N(104) :: Reducir a la mitad el tamaño del problema en cada paso es la
     característica distintiva del crecimiento logarítmico, como vimos con el
     algoritmo de rápida exponenciación de la seccion @l(#1.2.4) y el método de
     búsqueda de medio intervalo de la seccion @l(#1.3.3).

#   :: @N(105) :: We are representing sets in terms of trees, and trees in terms
#      of lists––in effect, a data abstraction built upon a data abstraction. We
#      can regard the procedures @c(entry), @c(left-branch), @c(right-branch), and
#      @c(make-tree) as a way of isolating the abstraction of a @"(binary tree)
#      from the particular way we might wish to represent such a tree in terms of
#      list structure.
  :: @N(105) :: Estamos representando conjuntos en términos de árboles y árboles
     en términos de listas - en efecto, una abstracción de datos basada en una
     abstracción de datos. Podemos considerar los procedimientos @c(entry),
     @c(left-branch), @c(right-branch), y @c(make-tree) como una manera de
     aislar la abstracción de un @"(árbol binario) de la forma particular en que
     podríamos desear para representar un árbol de este tipo en términos de
     estructura de lista.

#   :: @N(106) :: Examples of such structures include @e(B-trees) and @e(red-black
#      trees). There is a large literature on data structures devoted to this
#      problem. See @l(#Cormen et al. 1990).
  :: @N(106) :: Ejemplos de tales estructuras incluyen @e(árboles B) y
     @e(árboles rojo-negro). Existe una gran literatura sobre estructuras de
     datos dedicadas a este problema. Véase @l(#Cormen-et-al.-1990<>Cormen et
     al. 1990).

#   :: @N(107) :: @l(#Exercise 2.63) through @l(#Exercise 2.65) are due to Paul
#      Hilfinger.
  :: @N(107) :: @l(#Ejercicio 2.63) hasta el
     @l(#Ejercicio 2.65) se debe a Paul Hilfinger.

#   :: @N(108) :: See @l(#Hamming 1980) for a discussion of the mathematical
#      properties of Huffman codes.
  :: @N(108) :: Ver @l(#Hamming-1980<>Hamming 1980) para una discusión de las
     propiedades matemáticas de los códigos de Huffman.

#   :: @N(109) :: In actual computational systems, rectangular form is preferable
#      to polar form most of the time because of roundoff errors in conversion
#      between rectangular and polar form. This is why the complex-number example
#      is unrealistic. Nevertheless, it provides a clear illustration of the
#      design of a system using generic operations and a good introduction to the
#      more substantial systems to be developed later in this chapter.
  :: @N(109) :: En sistemas computacionales reales, la forma rectangular es
     preferible a la forma polar la mayor parte del tiempo debido a errores de
     redondeo en la conversión entre forma rectangular y polar. Es por eso que
     el ejemplo del número complejo es poco realista. Sin embargo, proporciona
     una clara ilustración del diseño de un sistema que utiliza operaciones
     genéricas y una buena introducción a los sistemas más sustanciales que se
     desarrollarán más adelante en este capítulo.

#   :: @N(110) :: The arctangent function referred to here, computed by Scheme's
#      @c(atan) procedure, is defined so as to take two arguments @m(y) and @m(x)
#      and to return the angle whose tangent is @m(y / x).  The signs of the
#      arguments determine the quadrant of the angle.
  :: @N(110) :: La función arco tangente se hace referencia aquí, calculada por
     del Scheme procedimiento @c(atan), se define a fin de tener dos argumentos
     @m(y) y @m(x) y para devolver el ángulo cuya tangente es @m(y / x). Los
     signos de los argumentos determinan el cuadrante del ángulo.

#   :: @N(111) :: We use the list @c[(rectangular)] rather than the symbol
#      @c(rectangular) to allow for the possibility of operations with multiple
#      arguments, not all of the same type.
  :: @N(111) :: Utilizamos la lista en @c[(rectangular)] lugar del símbolo
     @c(rectangular) para permitir la posibilidad de operaciones con múltiples
     argumentos, no todos del mismo tipo.

#   :: @N(112) :: The type the constructors are installed under needn't be a list
#      because a constructor is always used to make an object of one particular
#      type.
  :: @N(112) :: El tipo en el que se instalan los constructores no necesita ser
     una lista porque siempre se utiliza un constructor para crear un objeto de
     un tipo concreto.

#   :: @N(113) :: @c(Apply-generic) uses the dotted-tail notation described in
#      @l(#Exercise 2.20), because different generic operations may take different
#      numbers of arguments. In @c(apply-generic), @c(op) has as its value the
#      first argument to @c(apply-generic) and @c(args) has as its value a list of
#      the remaining arguments.
  :: @N(113) :: @c(Apply-generic) Utiliza la notación de punteado-cola descrita
     en el @l(#Ejercicio 2.20), porque diferentes operaciones
     genéricas pueden tomar diferentes números de argumentos. In
     @c(apply-generic), @c(op) tiene como valor el primer argumento
     @c(apply-generic) y @c(args) tiene como valor una lista de los argumentos
     restantes.

#      @c(Apply-generic) also uses the primitive procedure @c(apply), which takes
#      two arguments, a procedure and a list. @c(Apply) applies the procedure,
#      using the elements in the list as arguments. For example,
    @c(Apply-generic) También utiliza el procedimiento primitivo @c(apply), que
    toma dos argumentos, un procedimiento y una lista. @c(Apply) Aplica el
    procedimiento, utilizando los elementos de la lista como argumentos. Por
    ejemplo,

#      ..src > scheme
#        (apply + (list 1 2 3 4))
#      < src..
     ..src > scheme
       (apply + (list 1 2 3 4))
     < src..

#      returns 10.
     Devuelve 10.

#   :: @N(114) :: One limitation of this organization is it permits only generic
#      procedures of one argument.
  :: @N(114) :: Una limitación de esta organización es que sólo permite
     procedimientos genéricos de un argumento.

#   :: @N(115) :: We also have to supply an almost identical procedure to handle
#      the types @c[(scheme-number complex)].
  :: @N(115) :: También tenemos que proporcionar un procedimiento casi idéntico
     para manejar los tipos @c[(scheme-number complex)].

#   :: @N(116) :: See @l(#Exercise 2.82) for generalizations.
  :: @N(116) :: Ver @l(#Ejercicio 2.82) para generalizaciones.

#   :: @N(117) :: If we are clever, we can usually get by with fewer than @m(n²)
#      coercion procedures. For instance, if we know how to convert from type 1 to
#      type 2 and from type 2 to type 3, then we can use this knowledge to convert
#      from type 1 to type 3. This can greatly decrease the number of coercion
#      procedures we need to supply explicitly when we add a new type to the
#      system. If we are willing to build the required amount of sophistication
#      into our system, we can have it search the @"(graph) of relations among
#      types and automatically generate those coercion procedures that can be
#      inferred from the ones that are supplied explicitly.
  :: @N(117) :: Si somos inteligentes, por lo general podemos pasar con menos de
     @m(n²) procedimientos de coerción. Por ejemplo, si sabemos cómo convertir
     de tipo 1 a tipo 2 y de tipo 2 a tipo 3, podemos utilizar este conocimiento
     para convertir de tipo 1 a tipo 3. Esto puede disminuir considerablemente
     el número de procedimientos de coerción que necesitamos Suministrar
     explícitamente cuando agregamos un nuevo tipo al sistema. Si estamos
     dispuestos a construir la cantidad requerida de sofisticación en nuestro
     sistema, podemos hacer que busque en el @"(gráfico) de relaciones entre
     tipos y genere automáticamente aquellos procedimientos de coerción que se
     pueden deducir de los que se proporcionan explícitamente.

#   :: @N(118) :: This statement, which also appears in the first edition of this
#      book, is just as true now as it was when we wrote it twelve years
#      ago. Developing a useful, general framework for expressing the relations
#      among different types of entities (what philosophers call @"(ontology))
#      seems intractably difficult. The main difference between the confusion
#      that existed ten years ago and the confusion that exists now is that now a
#      variety of inadequate ontological theories have been embodied in a
#      plethora of correspondingly inadequate programming languages. For
#      example, much of the complexity of object-oriented programming
#      languages––and the subtle and confusing differences among contemporary
#      object-oriented languages––centers on the treatment of generic operations
#      on interrelated types. Our own discussion of computational objects in
#      @l(#Chapter 3) avoids these issues entirely. Readers familiar with
#      object-oriented programming will notice that we have much to say in chapter
#      3 about local state, but we do not even mention @"(classes) or
#      @"(inheritance.)  In fact, we suspect that these problems cannot be
#      adequately addressed in terms of computer-language design alone, without
#      also drawing on work in knowledge representation and automated reasoning.
  :: @N(118) :: Esta declaración, que también aparece en la primera edición de
     este libro, es tan verdadera ahora como lo fue cuando la escribimos hace
     doce años. Desarrollar un marco general útil para expresar las relaciones
     entre los diferentes tipos de entidades (lo que los filósofos llaman
     @"(ontología) ) parece intratable difícil. La principal diferencia entre la
     confusión que existía hace diez años y la confusión que existe ahora es que
     ahora una variedad de teorías ontológicas inadecuadas se han incorporado en
     una plétora de lenguajes de programación adecuadamente inadecuados. Por
     ejemplo, gran parte de la complejidad de los lenguajes de programación
     orientados a objetos -y las sutiles y confusas diferencias entre lenguajes
     orientados a objetos contemporáneos- se centra en el tratamiento de
     operaciones genéricas en tipos interrelacionados. @l(#Chapter-3<>Nuestra
     propia discusión de los objetos computacionales en el Capitulo 3) evita
     estas cuestiones por completo. Los lectores familiarizados con la
     programación orientada a objetos notarán que tenemos mucho que decir en el
     capítulo 3 sobre el estado local, pero ni siquiera mencionamos las
     @"(clases) o la @"(herencia. )  De hecho, sospechamos que estos problemas
     no se pueden abordar adecuadamente en términos de diseño de lenguaje
     computacional por sí solo, sin también basarse en el trabajo en la
     representación del conocimiento y el razonamiento automatizado.

#   :: @N(119) :: A real number can be projected to an integer using the @c(round)
#      primitive, which returns the closest integer to its argument.
  :: @N(119) :: Un número real puede ser proyectado a un entero usando el
     @c(round) primitivo, que devuelve el entero más cercano a su argumento.

#   :: @N(120) :: On the other hand, we will allow polynomials whose coefficients
#      are themselves polynomials in other variables. This will give us
#      essentially the same representational power as a full multivariate system,
#      although it does lead to coercion problems, as discussed below.
  :: @N(120) :: Por otro lado, vamos a permitir que los polinomios cuyos
     coeficientes son ellos mismos polinomios en otras variables. Esto nos dará
     esencialmente el mismo poder de representación que un sistema multivariado
     completo, aunque sí conduce a problemas de coerción, como se analiza más
     adelante.

#   :: @N(121) :: For univariate polynomials, giving the value of a polynomial at
#      a given set of points can be a particularly good representation. This makes
#      polynomial arithmetic extremely simple. To obtain, for example, the sum of
#      two polynomials represented in this way, we need only add the values of the
#      polynomials at corresponding points. To transform back to a more familiar
#      representation, we can use the Lagrange interpolation formula, which shows
#      how to recover the coefficients of a polynomial of degree @m(n) given the
#      values of the polynomial at @m(n + 1) points.
  :: @N(121) :: Para los polinomios univariados, dar el valor de un polinomio en
     un conjunto dado de puntos puede ser una representación particularmente
     buena. Esto hace que la aritmética polinómica sea extremadamente
     simple. Para obtener, por ejemplo, la suma de dos polinomios representados
     de esta manera, sólo necesitamos añadir los valores de los polinomios en
     los puntos correspondientes. Para transformar de nuevo a una representación
     más familiar, podemos usar la fórmula de interpolación de Lagrange, que
     muestra cómo recuperar los coeficientes de un polinomio de grado @m(n)
     dados los valores del polinomio en @m(n + 1) puntos.

#   :: @N(122) :: This operation is very much like the ordered @c(union-set)
#      operation we developed in @l(#Exercise 2.62). In fact, if we think of the
#      terms of the polynomial as a set ordered according to the power of the
#      indeterminate, then the program that produces the term list for a sum is
#      almost identical to @c(union-set).
  :: @N(122) :: Esta operación se parece mucho a la @c(union-set) operación
     ordenada que desarrollamos en el @l(#Ejercicio 2.62). De
     hecho, si pensamos en los términos del polinomio como un conjunto ordenado
     de acuerdo con el poder de lo indeterminado, entonces el programa que
     produce la lista de términos para una suma es casi idéntico a
     @c(union-set).

#   :: @N(123) :: To make this work completely smoothly, we should also add to our
#      generic arithmetic system the ability to coerce a @"(number) to a
#      polynomial by regarding it as a polynomial of degree zero whose coefficient
#      is the number. This is necessary if we are going to perform operations such
#      as
  :: @N(123) :: Para hacer este trabajo completamente sin problemas, también
     debemos añadir a nuestro sistema aritmético genérico la capacidad de
     coaccionar un @"(número) a un polinomio al considerarlo como un polinomio
     de grado cero cuyo coeficiente es el número. Esto es necesario si vamos a
     realizar operaciones como

#      ..example >
#        [x² + (y + 1)x + 5] + [x² + 2x + 1]
#      < example..
     ..example >
       [x² + (y + 1)x + 5] + [x² + 2x + 1]
     < example..

#      which requires adding the coefficient @m(y + 1) to the coefficient 2.
    Que requiere añadir el coeficiente @m(y + 1) al coeficiente 2.

#   :: @N(124) :: In these polynomial examples, we assume that we have implemented
#      the generic arithmetic system using the type mechanism suggested in
#      @l(#Exercise 2.78). Thus, coefficients that are ordinary numbers will be
#      represented as the numbers themselves rather than as pairs whose @c(car) is
#      the symbol @c(scheme-number).
  :: @N(124) :: En estos ejemplos polinómicos, suponemos que hemos implementado
     el sistema aritmético genérico utilizando el mecanismo tipo sugerido en el
     @l(#Ejercicio 2.78). Así, los coeficientes que son números
     ordinarios serán representados como los números ellos mismos más bien que
     como los pares cuyo @c(car) es el símbolo @c(scheme-number).

#   :: @N(125) :: Although we are assuming that term lists are ordered, we have
#      implemented @c(adjoin-term) to simply @c(cons) the new term onto the
#      existing term list. We can get away with this so long as we guarantee that
#      the procedures (such as @c(add-terms)) that use @c(adjoin-term) always call
#      it with a higher-order term than appears in the list. If we did not want to
#      make such a guarantee, we could have implemented @c(adjoin-term) to be
#      similar to the @c(adjoin-set) constructor for the ordered-list
#      representation of sets (@l(#Exercise 2.61)).
  :: @N(125) :: Aunque asumimos que las listas de términos están ordenadas,
     hemos implementado @c(adjoin-term) simplemente @c(cons) el nuevo término en
     la lista de términos existente. Podemos salirse con la suya siempre y
     cuando garanticemos que los procedimientos (por ejemplo @c(add-terms)) que
     usamos @c(adjoin-term) siempre lo llaman con un término de orden superior
     al que aparece en la lista. Si no queríamos hacer tal garantía, podríamos
     haber implementado @c(adjoin-term) para ser similar al @c(adjoin-set)
     constructor para la lista ordenada de representación de conjuntos (
     @l(#Ejercicio 2.61) ).

#   :: @N(126) :: The fact that Euclid's Algorithm works for polynomials is
#      formalized in algebra by saying that polynomials form a kind of algebraic
#      domain called a @e(Euclidean ring). A Euclidean ring is a domain that
#      admits addition, subtraction, and commutative multiplication, together with
#      a way of assigning to each element @m(x) of the ring a positive integer
#      @"(measure) @m[m(x)] with the properties that @m[m(xy) ≥ m(x)] for any
#      nonzero @m(x) and @m(y) and that, given any @m(x) and @m(y), there exists a
#      @m(q) such that @m(y = qx + r) and either @m(r = 0) or @m[m(r) < m(x)].
#      From an abstract point of view, this is what is needed to prove that
#      Euclid's Algorithm works. For the domain of integers, the measure @m(m) of
#      an integer is the absolute value of the integer itself. For the domain of
#      polynomials, the measure of a polynomial is its degree.
  :: @N(126) :: El hecho de que el Algoritmo de Euclides funcione para
     polinomios se formaliza en álgebra diciendo que los polinomios forman una
     especie de dominio algebraico llamado @e(anillo euclidiano). Un anillo
     euclidiano es un dominio que admite la suma, resta y multiplicación
     conmutativa, junto con una forma de asignar a cada elemento @m(x) del
     anillo una @"(medida) entera positiva @m(m (x)) con las propiedades que
     @m(m (xy) ≥ m (x)) para cualquier distinto de cero @m(x) y @m(y) y que,
     dado cualquier @m(x) y @m(y), existe una @m(q) tal que @m(y = qx + r) y, o
     bien @m(r = 0) o @m(m (r) <m (x)). Desde un punto de vista abstracto,
     Esto es lo que se necesita para probar que el Algoritmo de Euclides
     funciona. @m(Para el dominio de enteros, la medida m) de un entero es el
     valor absoluto del entero mismo. Para el dominio de polinomios, la medida
     de un polinomio es su grado.

#   :: @N(127) :: In an implementation like @A(MIT) Scheme, this produces a
#      polynomial that is indeed a divisor of @m(Q₁) and @m(Q₂), but with rational
#      coefficients. In many other Scheme systems, in which division of integers
#      can produce limited-precision decimal numbers, we may fail to get a valid
#      divisor.
  :: @N(127) :: En una implementación como @A(MIT) Scheme, esto produce un
     polinomio que es de hecho un divisor de @m(Q $ )@m(₁ )@m($) y @m(Q $ ₂ $),
     pero con coeficientes racionales. En muchos otros sistemas Scheme, en los
     que la división de números enteros puede producir números decimales de
     precisión limitada, es posible que no obtengamos un divisor válido.

#   :: @N(128) :: One extremely efficient and elegant method for computing
#      polynomial @A(GCD)s was discovered by Richard @l[#Zippel (1979)]. The
#      method is a probabilistic algorithm, as is the fast test for primality that
#      we discussed in @l(#Chapter 1). Zippel's book (@l(#Zippel 1993)) describes
#      this method, together with other ways to compute polynomial @A(GCD)s.
  :: @N(128) :: Richard @l(#Zippel-(1979)<>Zippel) descubrió un método
     extremadamente eficiente y elegante para calcular polinomios @A(GCD) s
     @l(#Zippel-(1979)<>(1979)). El método es un algoritmo probabilístico, al
     igual que la prueba rápida para primality que discutimos en el
     @l(Capitulo 1). El libro de @l(#Zippel-1993<>Zippel) (
     @l(#Zippel-1993<>Zippel 1993) ) describe este método, junto con otras
     formas de calcular el @A(GCD) s polinomial.

#   :: @N(129) :: Actually, this is not quite true. One exception was the
#      random-number generator in section @l(#1.2.6). Another exception involved the
#      operation/type tables we introduced in section @l(#2.4.3), where the values of two
#      calls to @c(get) with the same arguments depended on intervening calls to
#      @c(put). On the other hand, until we introduce assignment, we have no way
#      to create such procedures ourselves.
  :: @N(129) :: En realidad, esto no es del todo cierto. Una excepción fue el
     generador de números aleatorios en la seccion @l(#1.2.6). Otra excepción
     incluía las tablas de operación / tipo que introdujimos en
     @l(#2.4.3), donde los valores de dos llamadas a @c(get) con los
     mismos argumentos dependían de las llamadas intermedias a @c(put). Por otro
     lado, hasta que introduzcamos la asignación, no tenemos manera de crear
     tales procedimientos nosotros mismos.

#   :: @N(130) :: The value of a @c(set!) expression is implementation-dependent.
#      @c(Set!) should be used only for its effect, not for its value.
  :: @N(130) :: El valor de una @c(set!) expresión depende de la
     implementación. @c(Set!) Debe ser utilizado sólo para su efecto, no para su
     valor.

#      The name @c(set!) reflects a naming convention used in Scheme: Operations
#      that change the values of variables (or that change data structures, as we
#      will see in section @l(#3.3)) are given names that end with an exclamation point.
#      This is similar to the convention of designating predicates by names that
#      end with a question mark.
     El nombre @c(set!) refleja una convención de nomenclatura utilizada en el
     Scheme: Las operaciones que cambian los valores de las variables (o que
     cambian las estructuras de datos, como veremos en la seccion @l(#3.3)) reciben
     nombres que terminan con un signo de exclamación. Esto es similar a la
     convención de designar predicados por nombres que terminan con un signo de
     interrogación.

#   :: @N(131) :: We have already used @c(begin) implicitly in our programs,
#      because in Scheme the body of a procedure can be a sequence of
#      expressions. Also, the @c[(consequent)] part of each clause in a @c(cond)
#      expression can be a sequence of expressions rather than a single
#      expression.
  :: @N(131) :: Ya hemos utilizado @c(begin) implícitamente en nuestros
     programas, porque en Scheme el cuerpo de un procedimiento puede ser una
     secuencia de expresiones. Además, la @c[(consequent)] parte de cada
     cláusula en una @c(cond) expresión puede ser una secuencia de expresiones
     en lugar de una sola expresión.

#   :: @N(132) :: In programming-language jargon, the variable @c(balance) is said
#      to be @e(encapsulated) within the @c(new-withdraw) procedure. Encapsulation
#      reflects the general system-design principle known as the @e(hiding
#      principle): One can make a system more modular and robust by protecting
#      parts of the system from each other; that is, by providing information
#      access only to those parts of the system that have a @"(need to know.)
  :: @N(132) :: En la jerga del lenguaje de programación, @c(balance) se dice
     que la variable está @e(encapsulada) dentro del procedimiento @c(new-withdraw). La encapsulación refleja el principio general del diseño del
     sistema conocido como @e(principio de ocultación) : se puede hacer un
     sistema más modular y robusto protegiendo partes del sistema entre sí; Es
     decir, proporcionando acceso a la información sólo a las partes del sistema
     que tienen una @"(necesidad de saber.)

#   :: @N(133) :: In contrast with @c(new-withdraw) above, we do not have to use
#      @c(let) to make @c(balance) a local variable, since formal parameters are
#      already local.  This will be clearer after the discussion of the
#      environment model of evaluation in section @l(#3.2). (See also @l(#Exercise 3.10).)
  :: @N(133) :: En contraste con lo @c(new-withdraw) anterior, no tenemos que
     usar @c(let) para hacer @c(balance) una variable local, ya que los
     parámetros formales ya son locales. Esto será más claro después de la
     discusión del modelo de evaluación ambiental en la seccion @l(#3.2). (Véase
     también el @l(#Ejercicio 3.10) .)

#   :: @N(134) :: One common way to implement @c(rand-update) is to use the rule
#      that @m(x) is updated to @m(ax + b) modulo @m(m), where @m(a), @m(b), and
#      @m(m) are appropriately chosen integers. Chapter 3 of @l(#Knuth 1981)
#      includes an extensive discussion of techniques for generating sequences of
#      random numbers and establishing their statistical properties. Notice that
#      the @c(rand-update) procedure computes a mathematical function: Given the
#      same input twice, it produces the same output. Therefore, the number
#      sequence produced by @c(rand-update) certainly is not @"(random,) if by
#      @"(random) we insist that each number in the sequence is unrelated to the
#      preceding number. The relation between @"(real randomness) and so-called
#      @e(pseudo-random) sequences, which are produced by well-determined
#      computations and yet have suitable statistical properties, is a complex
#      question involving difficult issues in mathematics and philosophy.
#      Kolmogorov, Solomonoff, and Chaitin have made great progress in clarifying
#      these issues; a discussion can be found in @l(#Chaitin 1975).
  :: @N(134) :: Una forma común de implementar @c(rand-update) es el uso de la
     regla de que @m(x) se actualiza para @m(ax + b) módulo @m(m), donde @m(a),
     @m(b) y @m(m) son números enteros elegidos apropiadamente. El capítulo 3 de
     @l(#Knuth-1981<>Knuth 1981) incluye una extensa discusión de técnicas para
     generar secuencias de números aleatorios y establecer sus propiedades
     estadísticas. Observe que el procedimiento @c(rand-update) calcula una
     función matemática: Dada la misma entrada dos veces, produce la misma
     salida. Por lo tanto, la secuencia numérica producida por @c(rand-update)
     ciertamente no es @"(aleatoria,) si por @"(azar) insistimos en que cada
     número en la secuencia no está relacionado con el número anterior. @"(La
     relación entre la aleatoriedad real) y las llamadas secuencias
     @e(pseudo-aleatorias), que son producidas por cálculos bien determinados y
     tienen propiedades estadísticas adecuadas, es una cuestión compleja que
     involucra cuestiones difíciles en matemáticas y filosofía. Kolmogorov,
     Solomonoff y Chaitin han hecho grandes progresos en la aclaración de estas
     cuestiones; Una discusión se puede encontrar en @l(#Chaitin-1975<>Chaitin
     1975).

#   :: @N(135) :: This theorem is due to E. Cesàro. See section 4.5.2 of
#      @l(#Knuth 1981) for a discussion and a proof.
  :: @N(135) :: Este teorema se debe a E. Ces

#   :: @N(136) :: @A(MIT) Scheme provides such a procedure. If @c(random) is given
#      an exact integer (as in section @l(#1.2.6)) it returns an exact integer, but if it
#      is given a decimal value (as in this exercise) it returns a decimal value.
  :: @N(136) :: @A(MIT) Scheme proporciona tal procedimiento. Si @c(random) se
     le da un entero exacto (como en la seccion @l(#1.2.6)), devuelve un entero
     exacto, pero si se le da un valor decimal (como en este ejercicio) devuelve
     un valor decimal.

#   :: @N(137) :: We don't substitute for the occurrence of @c(balance) in the
#      @c(set!) expression because the @c[(name)] in a @c(set!) is not
#      evaluated. If we did substitute for it, we would get @c[(set! 25 (- 25
#      amount))], which makes no sense.
  :: @N(137) :: No sustituir a la aparición de @c(balance) la @c(set!) expresión
     debido a que el @c[(name)] de una @c(set!) no se evalúa. Si lo
     sustituyéramos, lo conseguiríamos @c[(set! 25 (- 25 amount))], lo cual no
     tiene sentido.

#   :: @N(138) :: The phenomenon of a single computational object being accessed
#      by more than one name is known as @e(aliasing). The joint bank account
#      situation illustrates a very simple example of an alias. in section @l(#3.3) we
#      will see much more complex examples, such as @"(distinct) compound data
#      structures that share parts. Bugs can occur in our programs if we forget
#      that a change to an object may also, as a @"(side effect,) change a
#      @"(different) object because the two @"(different) objects are actually a
#      single object appearing under different aliases. These so-called
#      @e(side-effect bugs) are so difficult to locate and to analyze that some
#      people have proposed that programming languages be designed in such a way
#      as to not allow side effects or aliasing (@l(#Lampson et al. 1981);
#      @l(#Morris et al. 1980)).
  :: @N(138) :: El fenómeno de un único objeto computacional al que se accede
     por más de un nombre se conoce como @e(aliasing). La situación conjunta de
     la cuenta bancaria ilustra un ejemplo muy simple de un alias. En
     @l(#3.3) veremos ejemplos mucho más complejos, como estructuras de
     datos compuestos @"(diferentes) que comparten partes. Los errores pueden
     ocurrir en nuestros programas si olvidamos que un cambio en un objeto
     también puede, como un @"(efecto secundario,) cambiar un objeto
     @"(diferente) porque los dos objetos @"(diferentes) son en realidad un solo
     objeto que aparece bajo diferentes alias.@e() (@l(#Lampson et al. 1981);
     @l(#Morris et al. 1980)).

#   :: @N(139) :: In view of this, it is ironic that introductory programming is
#      most often taught in a highly imperative style. This may be a vestige of a
#      belief, common throughout the 1960s and 1970s, that programs that call
#      procedures must inherently be less efficient than programs that perform
#      assignments. (@l(#Steele 1977) debunks this argument.)  Alternatively it
#      may reflect a view that step-by-step assignment is easier for beginners to
#      visualize than procedure call. Whatever the reason, it often saddles
#      beginning programmers with @"(should I set this variable before or after
#      that one) concerns that can complicate programming and obscure the
#      important ideas.
  :: @N(139) :: En vista de esto, es irónico que la programación introductoria
     se enseña más a menudo en un estilo altamente imperativo. Esto puede ser un
     vestigio de una creencia común a lo largo de los años sesenta y setenta de
     que los programas que llaman a procedimientos deben ser intrínsecamente
     menos eficientes que los programas que realizan tareas. (
     @l(#Steele-1977<>Steele 1977) desactiva este argumento). Alternativamente,
     puede reflejar una vista de que la asignación paso a paso es más fácil para
     los principiantes de visualizar que la llamada de procedimiento. Cualquiera
     que sea la razón, a menudo selle programadores de inicio con @"(debería
     establecer esta variable antes o después de que uno se) refiere que puede
     complicar la programación y oscurecer las ideas importantes.

#   :: @N(140) :: Assignment introduces a subtlety into step 1 of the evaluation
#      rule. As shown in @l(#Exercise 3.8), the presence of assignment allows us
#      to write expressions that will produce different values depending on the
#      order in which the subexpressions in a combination are evaluated. Thus, to
#      be precise, we should specify an evaluation order in step 1 (e.g., left to
#      right or right to left). However, this order should always be considered to
#      be an implementation detail, and one should never write programs that
#      depend on some particular order. For instance, a sophisticated compiler
#      might optimize a program by varying the order in which subexpressions are
#      evaluated.
  :: @N(140) :: La asignación introduce una sutileza en el paso 1 de la regla de
     evaluación. Como se muestra en el @l(#Ejercicio 3.8), la
     presencia de asignación nos permite escribir expresiones que producirán
     diferentes valores dependiendo del orden en que se evalúen las
     subexpresiones en una combinación. Así, para ser exactos, deberíamos
     especificar un orden de evaluación en el paso 1 (por ejemplo, de izquierda
     a derecha o de derecha a izquierda). Sin embargo, este orden siempre debe
     considerarse como un detalle de implementación, y uno nunca debe escribir
     programas que dependen de un orden en particular. Por ejemplo, un
     compilador sofisticado puede optimizar un programa variando el orden en que
     se evalúan las subexpresiones.

#   :: @N(141) :: If there is already a binding for the variable in the current
#      frame, then the binding is changed. This is convenient because it allows
#      redefinition of symbols; however, it also means that @c(define) can be used
#      to change values, and this brings up the issues of assignment without
#      explicitly using @c(set!). Because of this, some people prefer
#      redefinitions of existing symbols to signal errors or warnings.
  :: @N(141) :: Si ya hay un enlace para la variable en el marco actual, se
     cambia el enlace. Esto es conveniente porque permite la redefinición de
     símbolos; Sin embargo, también significa que @c(define) se puede utilizar
     para cambiar los valores, y esto trae a colación los problemas de
     asignación sin utilizar explícitamente @c(set!). Debido a esto, algunas
     personas prefieren la redefinición de símbolos existentes para señalar
     errores o advertencias.

#   :: @N(142) :: The environment model will not clarify our claim in section @l(#1.2.1)
#      that the interpreter can execute a procedure such as @c(fact-iter) in a
#      constant amount of space using tail recursion. We will discuss tail
#      recursion when we deal with the control structure of the interpreter in
#      @l(#5.4).
  :: @N(142) :: El modelo de entorno no aclarará nuestra afirmación en
     @l(#1.2.1<>1.2.1 de) que el intérprete puede ejecutar un procedimiento tal
     como @c(fact-iter) en una cantidad constante de espacio usando la recursión
     de cola. Discutiremos la recursividad de la cola cuando tratamos con la
     estructura de control del intérprete en la seccion @l(#5.4).

#   :: @N(143) :: Whether @c(W1) and @c(W2) share the same physical code stored in
#      the computer, or whether they each keep a copy of the code, is a detail of
#      the implementation. For the interpreter we implement in @l(#Chapter 4), the
#      code is in fact shared.
  :: @N(143) :: Si se comparte @c(W1) o @c(W2) comparte el mismo código físico
     almacenado en el equipo, o si cada uno guarda una copia del código, es un
     detalle de la implementación. Para el intérprete que implementamos en el
     @l(Capitulo 4), el código es de hecho compartido.

#   :: @N(144) :: @c(Set-car!) and @c(set-cdr!) return implementation-dependent
#      values. Like @c(set!), they should be used only for their effect.
  :: @N(144) :: @c(Set-car!) Y @c(set-cdr!) devuelven valores dependientes de la
     implementación. Al igual que @c(set!), deben ser utilizados sólo para su
     efecto.

#   :: @N(145) :: We see from this that mutation operations on lists can create
#      @"(garbage) that is not part of any accessible structure. We will see in
#      @l(#5.3.2) that Lisp memory-management systems include a @e(garbage
#      collector), which identifies and recycles the memory space used by unneeded
#      pairs.
  :: @N(145) :: Vemos de esto que las operaciones de mutación en las listas
     pueden crear @"(basura) que no forma parte de ninguna estructura
     accesible. Veremos en la seccion @l(#5.3.2) que los sistemas de gestión de
     memoria Lisp incluyen un @e(recolector de basura), que identifica y recicla
     el espacio de memoria utilizado por parejas innecesarias.

#   :: @N(146) :: @c(Get-new-pair) is one of the operations that must be
#      implemented as part of the memory management required by a Lisp
#      implementation. We will discuss this in section @l(#5.3.1).
  :: @N(146) :: @c(Get-new-pair) Es una de las operaciones que debe
     implementarse como parte de la gestión de memoria requerida por una
     implementación Lisp. Discutiremos esto en la seccion @l(#5.3.1).

#   :: @N(147) :: The two pairs are distinct because each call to @c(cons) returns
#      a new pair. The symbols are shared; in Scheme there is a unique symbol with
#      any given name. Since Scheme provides no way to mutate a symbol, this
#      sharing is undetectable. Note also that the sharing is what enables us to
#      compare symbols using @c(eq?), which simply checks equality of pointers.
  :: @N(147) :: Los dos pares son distintos porque cada llamada @c(cons)
     devuelve un nuevo par. Los símbolos son compartidos; En Scheme hay un
     símbolo único con cualquier nombre dado. Dado que Scheme no proporciona
     ninguna manera de mutar un símbolo, este compartir es indetectable. Tenga
     en cuenta también que el intercambio es lo que nos permite comparar
     símbolos utilizando @c(eq?), que simplemente verifica la igualdad de
     punteros.

#   :: @N(148) :: The subtleties of dealing with sharing of mutable data objects
#      reflect the underlying issues of @"(sameness) and @"(change) that were
#      raised in section @l(#3.1.3). We mentioned there that admitting change to our
#      language requires that a compound object must have an @"(identity) that is
#      something different from the pieces from which it is composed. In Lisp, we
#      consider this @"(identity) to be the quality that is tested by @c(eq?),
#      i.e., by equality of pointers. Since in most Lisp implementations a pointer
#      is essentially a memory address, we are @"(solving the problem) of defining
#      the identity of objects by stipulating that a data object @"(itself) is the
#      information stored in some particular set of memory locations in the
#      computer. This suffices for simple Lisp programs, but is hardly a general
#      way to resolve the issue of @"(sameness) in computational models.}
  :: @N(148) :: Las sutilezas de tratar con el intercambio de objetos de datos
     mutables reflejan las cuestiones subyacentes de @"(igualdad) y @"(cambio)
     que se plantearon en la seccion @l(#3.1.3). Hemos mencionado que admitir el
     cambio a nuestro lenguaje requiere que un objeto compuesto tenga una
     @"(identidad) que sea algo diferente de las piezas de las que está
     compuesta. En Lisp, consideramos que esta @"(identidad) es la calidad que
     se prueba por @c(eq?), es decir, por igualdad de punteros. Dado que en la
     mayoría de las implementaciones Lisp un puntero es esencialmente una
     dirección de memoria, @"(Estamos resolviendo el problema) de definir la
     identidad de objetos estipulando que un objeto de datos en @"(sí mismo) es
     la información almacenada en un determinado conjunto de ubicaciones de
     memoria en el ordenador. Esto es suficiente para los programas Lisp
     simples, pero no es una manera general de resolver el problema de la
     @"(uniformidad) en los modelos computacionales.

#   :: @N(149) :: On the other hand, from the viewpoint of implementation,
#      assignment requires us to modify the environment, which is itself a mutable
#      data structure. Thus, assignment and mutation are equipotent: Each can be
#      implemented in terms of the other.
  :: @N(149) :: Por otra parte, desde el punto de vista de la implementación, la
     asignación nos obliga a modificar el entorno, que es en sí mismo una
     estructura de datos mutable. Por lo tanto, asignación y mutación son
     equipotentes: cada uno puede ser implementado en términos de la otra.

#   :: @N(150) :: If the first item is the final item in the queue, the front
#      pointer will be the empty list after the deletion, which will mark the
#      queue as empty; we needn't worry about updating the rear pointer, which
#      will still point to the deleted item, because @c(empty-queue?) looks only
#      at the front pointer.
  :: @N(150) :: Si el primer elemento es el último elemento de la cola, el
     puntero frontal será la lista vacía después de la eliminación, que marcará
     la cola como vacía; No necesitamos preocuparnos por la actualización del
     puntero posterior, que seguirá apuntando al elemento eliminado, ya que
     @c(empty-queue?) sólo se mira en el puntero frontal.

#   :: @N(151) :: Be careful not to make the interpreter try to print a structure
#      that contains cycles. (See @l(#Exercise 3.13).)
  :: @N(151) :: Tenga cuidado de no hacer que el intérprete intente imprimir una
     estructura que contenga ciclos. (Véase el @l(#Ejercicio
     3.13) .)

#   :: @N(152) :: Because @c(assoc) uses @c(equal?), it can recognize keys that
#      are symbols, numbers, or list structure.
  :: @N(152) :: Porque @c(assoc) utiliza @c(equal?), puede reconocer las llaves
     que son símbolos, números, o estructura de la lista.

#   :: @N(153) :: Thus, the first backbone pair is the object that represents the
#      table @"(itself); that is, a pointer to the table is a pointer to this
#      pair. This same backbone pair always starts the table. If we did not
#      arrange things in this way, @c(insert!)  would have to return a new value
#      for the start of the table when it added a new record.
  :: @N(153) :: Por lo tanto, el primer par de backbone es el objeto que
     representa la tabla @"(misma) ; Es decir, un puntero a la tabla es un
     puntero a este par. Este mismo par de backbone siempre inicia la tabla. Si
     no organizamos las cosas de esta manera, @c(insert!)  tendríamos que
     devolver un nuevo valor para el inicio de la tabla cuando agregamos un
     nuevo registro.

#   :: @N(154) :: A full-adder is a basic circuit element used in adding two
#      binary numbers. Here A and B are the bits at corresponding positions in the
#      two numbers to be added, and @m(Cᵢₙ) is the carry bit from the addition one
#      place to the right. The circuit generates SUM, which is the sum bit in the
#      corresponding position, and @m(Cₒᵤₜ), which is the carry bit to be
#      propagated to the left.
  :: @N(154) :: Un sumador completo es un elemento de circuito básico utilizado
     para agregar dos números binarios. Aquí A y B son los bits en las
     posiciones correspondientes en los dos números que se añadirán, y @m(Cᵢₙ)
     es el bit de transporte de la adición de un lugar a la derecha. El circuito
     genera SUM, que es el bit de suma en la posición correspondiente, y
     @m(Cₒᵤₜ), que es el bit de transporte que se propagará a la izquierda.

#   :: @N(155) :: @t(Footnote 155) These procedures are simply syntactic sugar
#      that allow us to use ordinary procedural syntax to access the local
#      procedures of objects. It is striking that we can interchange the role of
#      @"(procedures) and @"(data) in such a simple way. For example, if we write
#      @c[(wire 'get-signal)] we think of @c(wire) as a procedure that is called
#      with the message @c(get-signal) as input. Alternatively, writing
#      @c[(get-signal wire)] encourages us to think of @c(wire) as a data object
#      that is the input to a procedure @c(get-signal). The truth of the matter is
#      that, in a language in which we can deal with procedures as objects, there
#      is no fundamental difference between @"(procedures) and @"(data,) and we
#      can choose our syntactic sugar to allow us to program in whatever style we
#      choose.
  :: @N(155) :: <span id="Footnote-155">Footnote 155</span> Estos procedimientos
     son simplemente azúcar sintáctico que nos permite usar sintaxis procesal
     ordinaria para acceder a los procedimientos locales de los objetos. Es
     sorprendente que podamos intercambiar el papel de @"(procedimientos) y
     @"(datos) de una manera tan simple. Por ejemplo, si escribimos @c[(wire
     'get-signal)] pensamos @c(wire) en un procedimiento que se llama con el
     mensaje @c(get-signal) como entrada. Alternativamente, la escritura
     @c[(get-signal wire)] nos anima a pensar @c(wire) como un objeto de datos
     que es la entrada a un procedimiento @c(get-signal). La verdad del asunto
     es que, en un lenguaje en el que podemos tratar los procedimientos como
     objetos, no hay diferencia fundamental entre los @"(procedimientos) y los
     @"(datos,)

#   :: @N(156) :: The agenda is a headed list, like the tables in section @l(#3.3.3), but
#      since the list is headed by the time, we do not need an additional dummy
#      header (such as the @c(*table*) symbol used with tables).
  :: @N(156) :: La agenda es una lista de encabezados, como las tablas en
     @l(#3.3.3), pero como la lista está encabezada por el tiempo, no
     necesitamos un encabezado ficticio adicional (como el @c(*table*) símbolo
     utilizado con las tablas).

#   :: @N(157) :: Observe that the @c(if) expression in this procedure has no
#      @c[(alternative)] expression. Such a @"(one-armed @c(if) statement) is used
#      to decide whether to do something, rather than to select between two
#      expressions. An @c(if) expression returns an unspecified value if the
#      predicate is false and there is no @c[(alternative)].
  :: @N(157) :: Observe que la @c(if) expresión en este procedimiento no tiene
     @c[(alternative)] expresión. Tal @"(declaración de) un @"(solo brazo@c(if))
     se utiliza para decidir si hacer algo, en lugar de seleccionar entre dos
     expresiones. Una @c(if) expresión devuelve un valor no especificado si el
     predicado es falso y no hay @c[(alternative)].

#   :: @N(158) :: In this way, the current time will always be the time of the
#      action most recently processed. Storing this time at the head of the agenda
#      ensures that it will still be available even if the associated time segment
#      has been deleted.
  :: @N(158) :: De esta manera, el tiempo actual será siempre el tiempo de la
     acción más recientemente procesada. Almacenar este tiempo a la cabeza de la
     agenda asegura que seguirá estando disponible incluso si se ha eliminado el
     segmento de tiempo asociado.

#   :: @N(159) :: Constraint propagation first appeared in the incredibly
#      forward-looking @A(SKETCHPAD) system of Ivan @l(#Sutherland (1963)). A
#      beautiful constraint-propagation system based on the Smalltalk language was
#      developed by Alan @l(#Borning (1977)) at Xerox Palo Alto Research
#      Center. Sussman, Stallman, and Steele applied constraint propagation to
#      electrical circuit analysis (@l(#Sussman and Stallman 1975); @l(#Sussman
#      and Steele 1980)). TK!Solver (@l(#Konopasek and Jayaraman 1984)) is an
#      extensive modeling environment based on constraints.
  :: @N(159) :: La propagación de restricciones apareció por primera vez en el
     increíble sistema @A(SKETCHPAD) de Ivan @l(#Sutherland-(1963<>Sutherland
     (1963) ). Un sistema hermoso de la restricción-propagación basado en el
     lenguaje de Smalltalk fue desarrollado por Alan @l(#Borning-(1977<>Borning
     (1977) ) en el centro de investigación de Xerox Palo Alto. Sussman,
     Stallman y Steele aplicaron la propagación de restricciones al análisis de
     circuitos eléctricos (@l(#Sussman-and-Stallman-1975<>Sussman y Stallman
     1975), @l(#Sussman-and-Steele-1980<>Sussman y Steele 1980) ). TK! Solver (
     @l(#Konopasek-and-Jayaraman-1984<>Konopasek y Jayaraman 1984) ) es un
     entorno de modelado extensivo basado en restricciones.

#   :: @N(160) :: The @c(setter) might not be a constraint. In our temperature
#      example, we used @c(user) as the @c(setter).
  :: @N(160) :: El @c(setter) no puede ser una limitación. En nuestro ejemplo de
     temperatura, usamos @c(user) como el @c(setter).

#   :: @N(161) :: The expression-oriented format is convenient because it avoids
#      the need to name the intermediate expressions in a computation. Our
#      original formulation of the constraint language is cumbersome in the same
#      way that many languages are cumbersome when dealing with operations on
#      compound data. For example, if we wanted to compute the product @m[(a + b)
#      ⋅ (c + d)], where the variables represent vectors, we could work in
#      @"(imperative style,) using procedures that set the values of designated
#      vector arguments but do not themselves return vectors as values:
  :: @N(161) :: El formato orientado a la expresión es conveniente porque evita
     la necesidad de nombrar las expresiones intermedias en un cálculo. Nuestra
     formulación original del lenguaje de restricciones es engorrosa de la misma
     manera que muchos lenguajes son engorrosos cuando se trata de operaciones
     sobre datos compuestos. Por ejemplo, si queremos calcular el producto
     @m[(a + b)]⋅ (c + d)), donde las variables representan vectores, podríamos
     trabajar en @"(estilo imperativo,) usando procedimientos que establezcan
     los valores de los argumentos vectoriales designados pero no regresen
     Vectores como valores:

#      ..src > scheme
#        (v-sum a b temp1)
#        (v-sum c d temp2)
#        (v-prod temp1 temp2 answer)
#      < src..
     ..src > scheme
       (v-sum a b temp1)
       (v-sum c d temp2)
       (v-prod temp1 temp2 answer)
     < src..

#      Alternatively, we could deal with expressions, using procedures that return
#      vectors as values, and thus avoid explicitly mentioning @c(temp1) and
#      @c(temp2):
     Alternativamente, podríamos tratar las expresiones, usando procedimientos
     que devuelven los vectores como valores, evitando así mencionar
     explícitamente @c(temp1) y @c(temp2):

#      ..src > scheme
#        (define answer
#          (v-prod (v-sum a b) (v-sum c d)))
#      < src..
     ..src > scheme
       (define answer
         (v-prod (v-sum a b) (v-sum c d)))
     < src..

#      Since Lisp allows us to return compound objects as values of procedures, we
#      can transform our imperative-style constraint language into an
#      expression-oriented style as shown in this exercise. In languages that are
#      impoverished in handling compound objects, such as Algol, Basic, and Pascal
#      (unless one explicitly uses Pascal pointer variables), one is usually stuck
#      with the imperative style when manipulating compound objects. Given the
#      advantage of the expression-oriented format, one might ask if there is any
#      reason to have implemented the system in imperative style, as we did in
#      this section. One reason is that the non-expression-oriented constraint
#      language provides a handle on constraint objects (e.g., the value of the
#      @c(adder) procedure) as well as on connector objects. This is useful if we
#      wish to extend the system with new operations that communicate with
#      constraints directly rather than only indirectly via operations on
#      connectors. Although it is easy to implement the expression-oriented style
#      in terms of the imperative implementation, it is very difficult to do the
#      converse.
     Puesto que Lisp nos permite devolver objetos compuestos como valores de
     procedimientos, podemos transformar nuestro lenguaje de restricción de
     estilo imperativo en un estilo orientado a la expresión como se muestra en
     este ejercicio. En lenguas que se empobrecen en el manejo de objetos
     compuestos, como Algol, Basic y Pascal (a menos que se utilicen
     explícitamente variables de puntero Pascal), uno suele estar atascado con
     el estilo imperativo al manipular objetos compuestos. Dada la ventaja del
     formato orientado a la expresión, se podría preguntar si hay alguna razón
     para implementar el sistema en un estilo imperativo, como lo hicimos en
     esta sección. Una de las razones es que el lenguaje de restricción no
     orientado a la expresión proporciona un identificador de objetos de
     restricción (por ejemplo, el valor del procedimiento @c(adder)), así como
     sobre los objetos de conector. Esto es útil si queremos extender el sistema
     con nuevas operaciones que se comunican directamente con restricciones, y
     no sólo indirectamente a través de operaciones en conectores. Aunque es
     fácil implementar el estilo orientado a la expresión en términos de la
     implementación imperativa, es muy difícil hacer lo contrario.

#   :: @N(162) :: Most real processors actually execute a few operations at a
#      time, following a strategy called @e(pipelining). Although this technique
#      greatly improves the effective utilization of the hardware, it is used only
#      to speed up the execution of a sequential instruction stream, while
#      retaining the behavior of the sequential program.
  :: @N(162) :: La mayoría de los procesadores reales ejecutan realmente algunas
     operaciones a la vez, siguiendo una estrategia llamada
     @e(pipelining). Aunque esta técnica mejora en gran medida la utilización
     eficaz del hardware, se utiliza sólo para acelerar la ejecución de un flujo
     de instrucciones secuenciales, al tiempo que se mantiene el comportamiento
     del programa secuencial.

#   :: @N(163) :: To quote some graffiti seen on a Cambridge building wall:
#      @"(Time is a device that was invented to keep everything from happening at
#      once.)
  :: @N(163) :: Para citar algunos graffiti visto en una pared del edificio de
     Cambridge: El @"(tiempo es un dispositivo que fue inventado para evitar que
     todo suceda a la vez.)

#   :: @N(164) :: An even worse failure for this system could occur if the two
#      @c(set!) operations attempt to change the balance simultaneously, in which
#      case the actual data appearing in memory might end up being a random
#      combination of the information being written by the two processes. Most
#      computers have interlocks on the primitive memory-write operations, which
#      protect against such simultaneous access. Even this seemingly simple kind
#      of protection, however, raises implementation challenges in the design of
#      multiprocessing computers, where elaborate @e(cache-coherence) protocols
#      are required to ensure that the various processors will maintain a
#      consistent view of memory contents, despite the fact that data may be
#      replicated (@"(cached) among the different processors to increase the speed
#      of memory access
  :: @N(164) :: Un fallo aún peor para este sistema podría ocurrir si las dos
     @c(set!) operaciones intentan cambiar el balance simultáneamente, en cuyo
     caso los datos reales que aparecen en la memoria podrían terminar siendo
     una combinación aleatoria de la información que está siendo escrita por los
     dos procesos. La mayoría de las computadoras tienen enclavamientos en las
     operaciones primitivas de escritura de memoria, que protegen contra dicho
     acceso simultáneo. Sin embargo, incluso este tipo de protección
     aparentemente simple plantea retos de implementación en el diseño de
     equipos multiprocesamiento, en los que se requieren protocolos elaborados
     @e(de coherencia de caché) para asegurar que los diversos procesadores
     mantendrán una visión coherente del contenido de la memoria, Replicado (en
     @"(caché) entre los diferentes procesadores para aumentar la velocidad de
     acceso a la memoria

#   :: @N(165) :: The factorial program in section @l(#3.1.3) illustrates this for a
#      single sequential process.
  :: @N(165) :: El programa factorial en la seccion @l(#3.1.3) ilustra esto para un
     solo proceso secuencial.

#   :: @N(166) :: The columns show the contents of Peter's wallet, the joint
#      account (in Bank1), Paul's wallet, and Paul's private account (in Bank2),
#      before and after each withdrawal (W) and deposit (D). Peter withdraws $10
#      from Bank1; Paul deposits $5 in Bank2, then withdraws $25 from Bank1.
  :: @N(166) :: Las columnas muestran el contenido de la cartera de Peter, la
     cuenta conjunta (en el Banco1), la cartera de Paul y la cuenta privada de
     Paul (en el Banco2), antes y después de cada retiro (W) y depósito
     (D). Peter retira $ 10 del Banco1; Paul deposita $ 5 en Bank2, luego retira
     $ 25 de Bank1.

#   :: @N(167) :: @t(Footnote 167) A more formal way to express this idea is to
#      say that concurrent programs are inherently @e(nondeterministic). That is,
#      they are described not by single-valued functions, but by functions whose
#      results are sets of possible values. in section @l(#4.3) we will study a language
#      for expressing nondeterministic computations.
  :: @N(167) :: <span id="Footnote-167">Nota 167</span> Una manera más formal
     para expresar esta idea es decir que los programas concurrentes son
     inherentemente @e(no determinista). Es decir, se describen no por funciones
     de un solo valor, sino por funciones cuyos resultados son conjuntos de
     valores posibles. en la seccion @l(#4.3) estudiaremos un lenguaje para expresar
     cálculos no determinísticos.

#   :: @N(168) :: @c(Parallel-execute) is not part of standard Scheme, but it can
#      be implemented in @A(MIT) Scheme. In our implementation, the new concurrent
#      processes also run concurrently with the original Scheme process. Also, in
#      our implementation, the value returned by @c(parallel-execute) is a special
#      control object that can be used to halt the newly created processes.
  :: @N(168) :: @c(Parallel-execute) No es parte del Scheme estándar, pero
     puede implementarse en @A(el) Scheme del @A(MIT). En nuestra
     implementación, los nuevos procesos simultáneos también se ejecutan
     simultáneamente con el proceso Scheme original. Además, en nuestra
     implementación, el valor devuelto por @c(parallel-execute) es un objeto de
     control especial que se puede utilizar para detener los procesos recién
     creados.

#   :: @N(169) :: We have simplified @c(exchange) by exploiting the fact that our
#      @c(deposit) message accepts negative amounts. (This is a serious bug in our
#      banking system!)
  :: @N(169) :: Hemos simplificado @c(exchange) explotando el hecho de que
     nuestro @c(deposit) mensaje acepta cantidades negativas. (¡Este es un error
     grave en nuestro sistema bancario!)

#   :: @N(170) :: If the account balances start out as $10, $20, and $30, then
#      after any number of concurrent exchanges, the balances should still be $10,
#      $20, and $30 in some order.  Serializing the deposits to individual
#      accounts is not sufficient to guarantee this. See @l(#Exercise 3.43).
  :: @N(170) :: Si los saldos de la cuenta comienzan como $ 10, $ 20 y $ 30,
     después de cualquier número de intercambios simultáneos, los saldos deben
     seguir siendo $ 10, $ 20 y $ 30 en algún orden. Serializar los depósitos a
     cuentas individuales no es suficiente para garantizar esto. Véase el
     @l(#Ejercicio 3.43).

#   :: @N(171) :: @l(#Exercise 3.45) investigates why deposits and withdrawals are
#      no longer automatically serialized by the account.
  :: @N(171) :: @l(#Ejercicio 3.45) investiga por qué los
     depósitos y retiros ya no son serializados automáticamente por la cuenta.

#   :: @N(172) :: The term @"(mutex) is an abbreviation for @e(mutual
#      exclusion). The general problem of arranging a mechanism that permits
#      concurrent processes to safely share resources is called the mutual
#      exclusion problem. Our mutex is a simple variant of the @e(semaphore)
#      mechanism (see @l(#Exercise 3.47)), which was introduced in the @"(THE)
#      Multiprogramming System developed at the Technological University of
#      Eindhoven and named for the university's initials in Dutch (@l(#Dijkstra
#      1968a)). The acquire and release operations were originally called P and V,
#      from the Dutch words @e(passeren) (to pass) and @e(vrijgeven) (to release),
#      in reference to the semaphores used on railroad systems. Dijkstra's classic
#      exposition (@l(#1968b)) was one of the first to clearly present the issues
#      of concurrency control, and showed how to use semaphores to handle a
#      variety of concurrency problems.
  :: @N(172) :: El término @"(mutex) es una abreviatura para @e(la exclusión
     mutua). El problema general de organizar un mecanismo que permite que los
     procesos concurrentes compartan recursos de forma segura se denomina
     problema de exclusión mutua. Nuestra mutex es una simple variante del
     @e(semáforo) mecanismo (véase el @l(#Ejercicio 3.47) ), que
     fue presentado en el @"(LA) sistema de multiprogramación desarrollado en la
     Universidad Tecnológica de Eindhoven y llamado así por las iniciales de la
     universidad en Holandés (@l(#Dijkstra-1968a<>Dijkstra 1968a) ). Las
     operaciones de adquisición y liberación se denominaron inicialmente P y V,
     de las palabras holandesas @e(passeren) (pasar) y @e(vrijgeven) (liberar),
     en referencia a los semáforos utilizados en los sistemas
     ferroviarios. Dijkstra (@l(#1968b))

#   :: @N(173) :: {In most time-shared operating systems, processes that
#      are blocked by a mutex do not waste time @"(busy-waiting) as above. Instead,
#      the system schedules another process to run while the first is waiting, and the
#      blocked process is awakened when the mutex becomes available.}
  :: @N(173) :: {En la mayoría de los sistemas operativos compartidos a tiempo,
     los procesos que están bloqueados por un mutex no pierden el tiempo
     @"(ocupado, esperando) como se ha indicado anteriormente. En su lugar, el
     sistema programa otro proceso para ejecutarse mientras el primero está
     esperando, y el proceso bloqueado se despierta cuando el mutex está
     disponible.}

#   :: @N(174) ::{In @A(MIT) Scheme for a single processor, which uses a
#      time-slicing model, @c(test-and-set!) can be implemented as follows:
  :: @N(174) :: {En @A(MIT) Scheme para un solo procesador, que utiliza un
     modelo de corte temporal, @c(test-and-set!) se puede implementar de la
     siguiente manera:

#      ..src > scheme
#        (define (test-and-set! cell)
#          (without-interrupts
#           (lambda ()
#             (if (car cell)
#                 true
#                 (begin (set-car! cell true)
#                        false)))))
#      < src..
     ..src > scheme
       (define (test-and-set! cell)
         (without-interrupts
          (lambda ()
            (if (car cell)
                true
                (begin (set-car! cell true)
                       false)))))
     < src..

#      @c(Without-interrupts) disables time-slicing interrupts while its procedure
#      argument is being executed.}
     @c(Without-interrupts) Deshabilita interrupciones de corte de tiempo
     mientras se ejecuta su argumento de procedimiento.}

#   :: @N(175) :: There are many variants of such instructions––including
#      test-and-set, test-and-clear, swap, compare-and-exchange, load-reserve, and
#      store-conditional––whose design must be carefully matched to the machine's
#      processor-memory interface. One issue that arises here is to determine what
#      happens if two processes attempt to acquire the same resource at exactly
#      the same time by using such an instruction. This requires some mechanism
#      for making a decision about which process gets control. Such a mechanism is
#      called an @e(arbiter). Arbiters usually boil down to some sort of hardware
#      device. Unfortunately, it is possible to prove that one cannot physically
#      construct a fair arbiter that works 100% of the time unless one allows the
#      arbiter an arbitrarily long time to make its decision. The fundamental
#      phenomenon here was originally observed by the fourteenth-century French
#      philosopher Jean Buridan in his commentary on Aristotle's @i(De caelo).
#      Buridan argued that a perfectly rational dog placed between two equally
#      attractive sources of food will starve to death, because it is incapable of
#      deciding which to go to first.
  :: @N(175) :: Hay muchas variantes de tales instrucciones - incluyendo
     test-and-set, test-and-clear, intercambio, comparación-y-intercambio,
     reserva de carga y almacenamiento condicional - cuyo diseño debe ser
     cuidadosamente adaptado al procesador de la máquina -interfaz de
     memoria. Un problema que surge aquí es determinar qué sucede si dos
     procesos intentan adquirir el mismo recurso exactamente al mismo tiempo
     usando tal instrucción. Esto requiere algún mecanismo para tomar una
     decisión sobre qué proceso obtiene el control. Tal mecanismo se llama un
     @e(árbitro). Arbitros generalmente se reducen a algún tipo de dispositivo
     de hardware. Desafortunadamente, es posible demostrar que uno no puede
     construir físicamente un árbitro justo que funcione el 100% del tiempo a
     menos que uno permita al árbitro arbitrariamente mucho tiempo tomar su
     decisión. @i(El fenómeno fundamental aquí fue observado originalmente por
     el filósofo francés del siglo XIV, Jean Buridan, en su comentario al De
     caelo de) Aristóteles. Buridan sostuvo que un perro perfectamente racional
     colocado entre dos fuentes igualmente atractivas de alimento morirá de
     hambre, porque es incapaz de decidir a qué ir a la primera.

#   :: @N(176) :: The general technique for avoiding deadlock by numbering the
#      shared resources and acquiring them in order is due to @l(#Havender
#      (1968)). Situations where deadlock cannot be avoided require
#      @e(deadlock-recovery) methods, which entail having processes @"(back out)
#      of the deadlocked state and try again. Deadlock-recovery mechanisms are
#      widely used in database management systems, a topic that is treated in
#      detail in @l(#Gray and Reuter 1993).
  :: @N(176) :: La técnica general para evitar el estancamiento al numerar los
     recursos compartidos y adquirirlos en orden se debe a
     @l(#Havender-(1968<>Havender (1968) ). Las situaciones en las que no se
     puede evitar el @e(interbloqueo) requieren métodos de @e(recuperación de
     interbloqueo), lo que implica que los procesos @"(vuelvan a salir) del
     estado de punto muerto y vuelva a intentarlo. Los mecanismos de
     recuperación de deadlock son ampliamente utilizados en sistemas de gestión
     de bases de datos, un tema que se trata en detalle en
     @l(#Gray-and-Reuter-1993<>Gray y Reuter 1993).

#   :: @N(177) :: One such alternative to serialization is called @e(barrier
#      synchronization). The programmer permits concurrent processes to execute as
#      they please, but establishes certain synchronization points (@"(barriers)
#      through which no process can proceed until all the processes have reached
#      the barrier. Modern processors provide machine instructions that permit
#      programmers to establish synchronization points at places where consistency
#      is required. The @A(PowerPC), for example, includes for this purpose two
#      instructions called @A(SYNC) and @A(EIEIO) (Enforced In-order Execution of
#      Input/Output).
  :: @N(177) :: Una de estas alternativas a la serialización se llama
     @e(sincronización de barrera). El programador permite que los procesos
     concurrentes se ejecuten como les plazca, pero establece ciertos puntos de
     sincronización (@"(barreras a) través de las cuales ningún proceso puede
     continuar hasta que todos los procesos han alcanzado la barrera). Los
     procesadores modernos proporcionan instrucciones de máquina que permiten a
     los programadores establecer puntos de sincronización en lugares donde la
     consistencia es El @A(PowerPC), por ejemplo, incluye para este propósito
     dos instrucciones llamadas @A(SYNC) y @A(EIEIO) (Ejecución Forzada en Orden
     de Entrada / Salida).

#   :: @N(178) :: This may seem like a strange point of view, but there are
#      systems that work this way. International charges to credit-card accounts,
#      for example, are normally cleared on a per-country basis, and the charges
#      made in different countries are periodically reconciled. Thus the account
#      balance may be different in different countries.
  :: @N(178) :: Esto puede parecer un punto de vista extraño, pero hay sistemas
     que funcionan de esta manera. Los cargos internacionales a las cuentas de
     tarjetas de crédito, por ejemplo, normalmente se compensan por país, y los
     cargos hechos en diferentes países se reconcilian periódicamente. Por lo
     tanto, el saldo de la cuenta puede ser diferente en los diferentes países.

#   :: @N(179) :: For distributed systems, this perspective was pursued by
#      @l[#Lamport (1978)], who showed how to use communication to establish
#      @"(global clocks) that can be used to establish orderings on events in
#      distributed systems.
  :: @N(179) :: Para los sistemas distribuidos, esta perspectiva fue perseguida
     por @l(#Lamport-(1978)<>Lamport (1978)), quien mostró cómo usar la
     comunicación para establecer @"(relojes globales) que pueden usarse para
     establecer órdenes sobre eventos en sistemas distribuidos.

#   :: @N(180) :: Physicists sometimes adopt this view by introducing the @"(world
#      lines) of particles as a device for reasoning about motion. We've also
#      already mentioned (section @l(#2.2.3)) that this is the natural way to think about
#      signal-processing systems. We will explore applications of streams to
#      signal processing in section @l(#3.5.3).
  :: @N(180) :: Los físicos adoptan a veces este punto de vista introduciendo
     las @"(líneas mundiales) de las partículas como un dispositivo para razonar
     sobre el movimiento. También hemos mencionado (seccion @l(#2.2.3)) que
     esta es la manera natural de pensar en los sistemas de procesamiento de
     señales. Exploraremos las aplicaciones de los flujos para procesar señales
     en la seccion @l(#3.5.3).

#   :: @N(181) :: Assume that we have a predicate @c(prime?) (e.g., as in
#      @l(#1.2.6)) that tests for primality.
  :: @N(181) :: Supongamos que tenemos un predicado @c(prime?)(por ejemplo, como
     en la seccion @l(#1.2.6)) que las pruebas de primalidad.

#   :: @N(182) :: In the @A(MIT) implementation, @c(the-empty-stream) is the same
#      as the empty list @c['()!], and @c(stream-null?) is the same as @c(null?).
  :: @N(182) :: En la implementación @A(MIT), @c(the-empty-stream) es la misma
     que la lista vacía@c['()!], and @c(stream-null?) is the same as @c(null?).)

#   :: @N(183) :: This should bother you. The fact that we are defining such
#      similar procedures for streams and lists indicates that we are missing some
#      underlying abstraction.  Unfortunately, in order to exploit this
#      abstraction, we will need to exert finer control over the process of
#      evaluation than we can at present. We will discuss this point further at
#      the end of section @l(#3.5.4). in section @l(#4.2), we'll develop a framework that unifies
#      lists and streams.
  :: @N(183) :: Esto debería molestarte. El hecho de que definamos
     procedimientos similares para los flujos y las listas indica que nos falta
     alguna abstracción subyacente. Desafortunadamente, para explotar esta
     abstracción, tendremos que ejercer un control más fino sobre el proceso de
     evaluación de lo que podemos en la actualidad. Discutiremos este punto más
     adelante al final de la seccion @l(#3.5.4). en la seccion @l(#4.2), desarrollaremos
     un marco que unifique listas y flujos.

#   :: @N(184) :: Although @c(stream-car) and @c(stream-cdr) can be defined as
#      procedures, @c(cons-stream) must be a special form. If @c(cons-stream) were
#      a procedure, then, according to our model of evaluation, evaluating
#      @c[(cons-stream ⟨a⟩ ⟨b⟩)] would automatically cause @c[(b)] to be
#      evaluated, which is precisely what we do not want to happen. For the same
#      reason, @c(delay) must be a special form, though @c(force) can be an
#      ordinary procedure.
  :: @N(184) :: Si bien @c(stream-car) y @c(stream-cdr) se puede definir como
     procedimientos, @c(cons-stream) debe ser una forma especial. Si se
     @c(cons-stream) tratara de un procedimiento, entonces, de acuerdo con
     nuestro modelo de evaluación, la evaluación @c[(cons-stream ⟨a⟩ ⟨b⟩)]
     automáticamente haría @c[(b)] que se evaluara, que es precisamente lo que
     no queremos que suceda. Por la misma razón, @c(delay) debe ser una forma
     especial, aunque @c(force) puede ser un procedimiento ordinario.

#   :: @N(185) :: The numbers shown here do not really appear in the delayed
#      expression. What actually appears is the original expression, in an
#      environment in which the variables are bound to the appropriate numbers.
#      For example, @c[(+ low 1)] with @c(low) bound to 10,000 actually appears
#      where @c(10001) is shown.
  :: @N(185) :: Los números mostrados aquí realmente no aparecen en la expresión
     retrasada. Lo que realmente aparece es la expresión original, en un entorno
     en el que las variables están enlazadas a los números apropiados. Por
     ejemplo, @c[(+ low 1)] con un @c(low) límite de 10.000 aparece realmente
     donde @c(10001) se muestra.

#   :: @N(186) :: There are many possible implementations of streams other than
#      the one described in this section.  Delayed evaluation, which is the key to
#      making streams practical, was inherent in Algol 60's @e(call-by-name)
#      parameter-passing method. The use of this mechanism to implement streams
#      was first described by @l(#Landin (1965)). Delayed evaluation for streams
#      was introduced into Lisp by @l[#Friedman and Wise (1976)]. In their
#      implementation, @c(cons) always delays evaluating its arguments, so that
#      lists automatically behave as streams. The memoizing optimization is also
#      known as @e(call-by-need). The Algol community would refer to our original
#      delayed objects as @e(call-by-name thunks) and to the optimized versions as
#      @e(call-by-need thunks).
  :: @N(186) :: Hay muchas implementaciones posibles de corrientes distintas a
     la descrita en esta sección. La evaluación retardada, que es la clave para
     que los flujos resulten prácticos, era inherente al método de paso de
     parámetros de @e(llamada por nombre de) Algol 60. El uso de este mecanismo
     para implementar corrientes fue descrito por primera vez por
     @l(#Landin-(1965<>Landin (1965) ). La evaluación tardía de corrientes fue
     introducida en Lisp por @l(#Friedman-and-Wise-(1976)<>Friedman y Wise
     (1976)). En su implementación, @c(cons) siempre demora la evaluación de sus
     argumentos, de modo que las listas se comportan automáticamente como
     flujos. La optimización memoizing también se conoce como @e(llamada por
     necesidad) .@e()@e()

#   :: @N(187) :: Exercises such as @l(#Exercise 3.51) and @l(#Exercise 3.52) are
#      valuable for testing our understanding of how @c(delay) works. On the other
#      hand, intermixing delayed evaluation with printing––and, even worse, with
#      assignment––is extremely confusing, and instructors of courses on computer
#      languages have traditionally tormented their students with examination
#      questions such as the ones in this section. Needless to say, writing
#      programs that depend on such subtleties is odious programming style. Part
#      of the power of stream processing is that it lets us ignore the order in
#      which events actually happen in our programs. Unfortunately, this is
#      precisely what we cannot afford to do in the presence of assignment, which
#      forces us to be concerned with time and change.
  :: @N(187) :: Ejercicios como el @l(#Ejercicio 3.51) y el
     @l(#Ejercicio 3.52) son valiosos para probar nuestra
     comprensión de cómo @c(delay) funciona. Por otro lado, el entremezclado de
     la evaluación tardía con la impresión -y, peor aún, con la asignación- es
     extremadamente confuso, y los instructores de los cursos sobre lenguajes
     informáticos han atormentado tradicionalmente a sus estudiantes con
     preguntas de examen como las de esta sección. Huelga decir que escribir
     programas que dependen de tales sutilezas es un estilo de programación
     odioso. Parte del poder del procesamiento de secuencias es que nos permite
     ignorar el orden en que suceden los eventos en nuestros
     programas. Desafortunadamente, esto es precisamente lo que no podemos
     permitirnos hacer en presencia de asignación, lo que nos obliga a
     preocuparnos por el tiempo y el cambio.

#   :: @N(188) :: Eratosthenes, a third-century @A(B.C.)  Alexandrian Greek
#      philosopher, is famous for giving the first accurate estimate of the
#      circumference of the Earth, which he computed by observing shadows cast at
#      noon on the day of the summer solstice. Eratosthenes's sieve method,
#      although ancient, has formed the basis for special-purpose hardware
#      @"(sieves) that, until recently, were the most powerful tools in existence
#      for locating large primes. Since the 70s, however, these methods have been
#      superseded by outgrowths of the probabilistic techniques discussed in
#      @l(#1.2.6).
  :: @N(188) :: Eratóstenes, filósofo griego alejandrino del siglo @A(III aC),
     es famoso por dar la primera estimación exacta de la circunferencia de la
     Tierra, que calculó observando las sombras proyectadas al mediodía del día
     del solsticio de verano. El método del tamiz de Eratosthenes, aunque
     antiguo, ha formado la base para los @"(tamices de) hardware de propósito
     especial que hasta hace poco eran las herramientas más poderosas existentes
     para localizar grandes primos. Sin embargo, desde los años 70, estos
     métodos han sido reemplazados por desarrollos de las técnicas
     probabilísticas discutidas en la seccion @l(#1.2.6).

#   :: @N(189) :: We have named these figures after Peter Henderson, who was the
#      first person to show us diagrams of this sort as a way of thinking about
#      stream processing. Each solid line represents a stream of values being
#      transmitted.  The dashed line from the @c(car) to the @c(cons) and the
#      @c(filter) indicates that this is a single value rather than a stream.
  :: @N(189) :: Hemos nombrado estas figuras después de Peter Henderson, quien
     fue la primera persona que nos mostró diagramas de este tipo como una forma
     de pensar sobre el procesamiento de la corriente. Cada línea continua
     representa una corriente de valores que se transmiten. La línea punteada de
     la @c(car) a la @c(cons) y la @c(filter) indica que se trata de un solo
     valor en lugar de una secuencia.

#   :: @N(190) :: This uses the generalized version of @c(stream-map) from
#      @l(#Exercise 3.50).
  :: @N(190) :: Este sistema utiliza la versión generalizada @c(stream-map) del
     @l(#Ejercicio 3.50).

#   :: @N(191) :: This last point is very subtle and relies on the fact that
#      @m(pₙ₊₁ ≤ pₙ²). (Here, @m(pₙ) denotes the @m(kᵗʰ) prime.)  Estimates such
#      as these are very difficult to establish. The ancient proof by Euclid that
#      there are an infinite number of primes shows that @m(pₙ₊₁ ≤ p₁ p₂ ⋯ pₙ +
#      1), and no substantially better result was proved until 1851, when the
#      Russian mathematician P. L. Chebyshev established that @m(pₙ₊₁ ≤ 2pₙ) for
#      all @m(n).  This result, originally conjectured in 1845, is known as
#      @e(Bertrand's hypothesis).  A proof can be found in section 22.3 of
#      @l(#Hardy and Wright 1960).
  :: @N(191) :: Este último punto es muy sutil y se basa en el hecho de que
     @m(pₙ₊₁ ≤ pₙ²). (Aquí, @m(pₙ) denota el @m(kᵗʰ) primo.) Estimaciones como
     estas son muy difíciles de establecer. La antigua prueba de Euclides de que
     hay un número infinito de números primos muestra que @m(pₙ₊₁ ≤ p₁ p₂ ⋯ pₙ +
     1), y ningún resultado sustancialmente mejor se demostró hasta 1851, cuando
     el matemático ruso PL Chebyshev estableció que @m(pₙ₊₁ ≤ 2pₙ) para Todos
     los @m(n). Este resultado, originalmente conjeturado en 1845, es conocido
     como @e(la hipótesis de Bertrand). Una prueba se puede encontrar en la
     sección 22.3 de @l(#Hardy-and-Wright-1960<>Hardy y Wright 1960).

#   :: @N(192) :: This exercise shows how call-by-need is closely related to
#      ordinary memoization as described in @l(#Exercise 3.27). In that exercise,
#      we used assignment to explicitly construct a local table. Our call-by-need
#      stream optimization effectively constructs such a table automatically,
#      storing values in the previously forced parts of the stream.
  :: @N(192) :: Este ejercicio muestra cómo la llamada por la necesidad está
     estrechamente relacionada con la memorización ordinaria como se describe en
     el @l(#Ejercicio 3.27). En ese ejercicio, utilizamos la
     asignación para construir explícitamente una tabla local. Nuestra
     optimización de flujo de llamada por necesidad construye de manera efectiva
     tal tabla automáticamente, almacenando valores en las partes previamente
     forzadas de la secuencia.

#   :: @N(193) :: We can't use @c(let) to bind the local variable @c(guesses),
#      because the value of @c(guesses) depends on @c(guesses)
#      itself. @l(#Exercise 3.63) addresses why we want a local variable here.
  :: @N(193) :: No podemos usar @c(let) para enlazar la variable local
     @c(guesses), porque el valor de @c(guesses) depende de @c(guesses) sí
     mismo. @l(#Ejercicio 3.63) explica por qué queremos una
     variable local aquí.

#   :: @N(194) :: As in section @l(#2.2.3), we represent a pair of integers as a list
#      rather than a Lisp pair.
  :: @N(194) :: Como en la seccion @l(#2.2.3), representamos un par de números
     enteros como una lista en lugar de un par Lisp.

#   :: @N(195) :: See @l(#Exercise 3.68) for some insight into why we chose this
#      decomposition.
  :: @N(195) :: Vea el @l(#Ejercicio 3.68) para una idea de por
     qué elegimos esta descomposición.

#   :: @N(196) :: The precise statement of the required property on the order of
#      combination is as follows: There should be a function @m(ƒ) of two
#      arguments such that the pair corresponding to element @m(i) of the first
#      stream and element @m(j) of the second stream will appear as element number
#      @m[ƒ(i, j)] of the output stream. The trick of using @c(interleave) to
#      accomplish this was shown to us by David Turner, who employed it in the
#      language KRC (@l(#Turner 1981)).
  :: @N(196) :: La declaración exacta de la propiedad requerida en el orden de
     combinación es la siguiente: Debería haber una función @m(ƒ) de dos
     argumentos de tal manera que el par que corresponde al elemento @m(i) de la
     primera corriente y el elemento @m(j) de la segunda corriente aparecerá
     como número de elemento @m(f (I, j)) de la corriente de salida. El truco de
     usar @c(interleave) para lograr esto nos fue mostrado por David Turner,
     quien lo empleó en el lenguaje KRC (@l(#Turner-1981<>Turner 1981) ).

#   :: @N(197) :: We will require that the weighting function be such that the
#      weight of a pair increases as we move out along a row or down along a
#      column of the array of pairs.
  :: @N(197) :: Requeriremos que la función de ponderación sea tal que el peso
     de un par aumente a medida que avanzamos a lo largo de una fila o hacia
     abajo a lo largo de una columna de la matriz de pares.

#   :: @N(198) :: To quote from G. H. Hardy's obituary of Ramanujan (@l(#Hardy
#      1921)): @"(It was Mr. Littlewood (I believe) who remarked that `every
#      positive integer was one of his friends.'  I remember once going to see him
#      when he was lying ill at Putney. I had ridden in taxi-cab No. 1729, and
#      remarked that the number seemed to me a rather dull one, and that I hoped
#      it was not an unfavorable omen. `No,' he replied, `it is a very interesting
#      number; it is the smallest number expressible as the sum of two cubes in
#      two different ways.'  ) The trick of using weighted pairs to generate the
#      Ramanujan numbers was shown to us by Charles Leiserson.
  :: @N(198) :: Para citar el obituario de GH Hardy de Ramanujan (
     @l(#Hardy-1921<>Hardy, 1921) ): @"(Era el señor Littlewood (creo) que
     comentó que "todo entero positivo era uno de sus amigos.") Recuerdo haber
     ido a verlo cuando estaba enfermo en Putney. Había montado en la cabina de
     taxi número 1729, y observé que el número me parecía un poco aburrido, y
     que esperaba que no fuera un presagio desfavorable. "No", respondió, "es un
     número muy interesante; Es el número más pequeño expresable como la suma de
     dos cubos de dos maneras diferentes.) El truco de usar pares ponderados
     para generar los números de Ramanujan nos fue mostrado por Charles
     Leiserson.

#   :: @N(199) :: This procedure is not guaranteed to work in all Scheme
#      implementations, although for any implementation there is a simple
#      variation that will work. The problem has to do with subtle differences in
#      the ways that Scheme implementations handle internal definitions. (See
#      @l(#4.1.6).)
  :: @N(199) :: Este procedimiento no está garantizado para trabajar en todas
     las implementaciones Scheme, aunque para cualquier implementación existe
     una simple variación que funcionará. El problema tiene que ver con sutiles
     diferencias en las formas en que las implementaciones de Scheme manejan
     definiciones internas. (ver seccion @l(#4.1.6) .)

#   :: @N(200) :: This is a small reflection, in Lisp, of the difficulties that
#      conventional strongly typed languages such as Pascal have in coping with
#      higher-order procedures. In such languages, the programmer must specify the
#      data types of the arguments and the result of each procedure: number,
#      logical value, sequence, and so on. Consequently, we could not express an
#      abstraction such as @"(map a given procedure @c(proc) over all the elements
#      in a sequence) by a single higher-order procedure such as @c(stream-map).
#      Rather, we would need a different mapping procedure for each different
#      combination of argument and result data types that might be specified for a
#      @c(proc). Maintaining a practical notion of @"(data type) in the presence
#      of higher-order procedures raises many difficult issues. One way of dealing
#      with this problem is illustrated by the language ML (@l(#Gordon et
#      al. 1979)), whose @"(polymorphic data types) include templates for
#      higher-order transformations between data types. Moreover, data types for
#      most procedures in ML are never explicitly declared by the
#      programmer. Instead, ML includes a @e(type-inferencing) mechanism that uses
#      information in the environment to deduce the data types for newly defined
#      procedures.
  :: @N(200) :: Esta es una pequeña reflexión, en Lisp, de las dificultades que
     los lenguajes convencionales de fuerte mecanografía como Pascal tienen en
     el manejo de los procedimientos de orden superior. En dichos idiomas, el
     programador debe especificar los tipos de datos de los argumentos y el
     resultado de cada procedimiento: número, valor lógico, secuencia, etc. En
     consecuencia, no podríamos expresar una abstracción como @"(mapear un
     procedimiento dado @c(proc) sobre todos los elementos de una secuencia)
     mediante un único procedimiento de orden superior como @c(stream-map). Más
     bien, necesitaríamos un procedimiento de asignación diferente para cada
     combinación diferente de tipos de datos de argumentos y resultados que
     pudieran especificarse para a @c(proc). Mantener una noción práctica de
     @"(tipo) de @"(datos) en presencia de procedimientos de orden superior
     plantea muchos problemas difíciles. @l(#Gordon-et-al.-1979<>Una forma de
     abordar este problema es ilustrada por el lenguaje ML ( Gordon et
     al., 1979) ), cuyos @"(tipos de datos polimórficos) incluyen plantillas
     para transformaciones de orden superior entre tipos de datos. Además, los
     tipos de datos para la mayoría de los procedimientos en ML nunca son
     declarados explícitamente por el programador. En su lugar, ML incluye un
     mecanismo de @e(inferencia de tipos) que utiliza información en el entorno
     para deducir los tipos de datos para procedimientos recién definidos.

#   :: @N(201) :: Similarly in physics, when we observe a moving particle, we say
#      that the position (state) of the particle is changing. However, from the
#      perspective of the particle's world line in space-time there is no change
#      involved.
  :: @N(201) :: Similarmente en la física, cuando observamos una partícula en
     movimiento, decimos que la posición (estado) de la partícula está
     cambiando. Sin embargo, desde la perspectiva de la línea de mundo de la
     partícula en el espacio-tiempo no hay ningún cambio implicado.

#   :: @N(202) :: John Backus, the inventor of Fortran, gave high visibility to
#      functional programming when he was awarded the @A(ACM) Turing award
#      in 1978. His acceptance speech (@l(#Backus 1978)) strongly advocated the
#      functional approach. A good overview of functional programming is given in
#      @l(#Henderson 1980) and in @l(#Darlington et al. 1982).
  :: @N(202) :: John Backus, el inventor de Fortran, dio una gran visibilidad a
     la programación funcional cuando se le otorgó el premio @A(ACM) Turing
     en 1978. Su discurso de aceptación (@l(#Backus-1978<>Backus 1978) ) abogó
     fuertemente por el enfoque funcional. Una buena visión general de la
     programación funcional se da en @l(#Henderson-1980<>Henderson 1980) y en
     @l(#Darlington-et-al.-1982<>Darlington et al. 1982).

#   :: @N(203) :: Observe that, for any two streams, there is in general more than
#      one acceptable order of interleaving. Thus, technically, @"(merge) is a
#      relation rather than a function––the answer is not a deterministic function
#      of the inputs. We already mentioned (@n(167<>Footnote 167)) that
#      nondeterminism is essential when dealing with concurrency. The merge
#      relation illustrates the same essential nondeterminism, from the functional
#      perspective. in section @l(#4.3), we will look at nondeterminism from yet another
#      point of view.
  :: @N(203) :: Observe que, para dos corrientes, hay en general más de un orden
     aceptable de entrelazado. Así, técnicamente, la @"(fusión) es una relación
     más que una función - la respuesta no es una función determinista de los
     insumos. Ya hemos mencionado (@n(167<>Nota 167)) que el
     no determinismo es esencial cuando se trata de concurrencia. La relación de
     fusión ilustra el mismo no determinismo esencial, desde la perspectiva
     funcional. en la seccion @l(#4.3), examinaremos el no determinismo desde otro
     punto de vista.

#   :: @N(204) :: The object model approximates the world by dividing it into
#      separate pieces. The functional model does not modularize along object
#      boundaries. The object model is useful when the unshared state of the
#      @"(objects) is much larger than the state that they share. An example of a
#      place where the object viewpoint fails is quantum mechanics, where thinking
#      of things as individual particles leads to paradoxes and confusions.
#      Unifying the object view with the functional view may have little to do
#      with programming, but rather with fundamental epistemological issues.
  :: @N(204) :: El modelo objeto se aproxima al mundo dividiéndolo en piezas
     separadas. El modelo funcional no modulariza a lo largo de los límites del
     objeto. El modelo de objeto es útil cuando el estado no compartido de los
     @"(objetos) es mucho mayor que el estado que comparten. Un ejemplo de un
     lugar donde el punto de vista del objeto falla es la mecánica cuántica,
     donde pensar en cosas como partículas individuales conduce a paradojas y
     confusiones. Unificar la vista del objeto con la visión funcional puede
     tener poco que ver con la programación, pero más bien con cuestiones
     epistemológicas fundamentales.

#   :: @N(205) :: The same idea is pervasive throughout all of engineering. For
#      example, electrical engineers use many different languages for describing
#      circuits. Two of these are the language of electrical @e(networks) and the
#      language of electrical @e(systems). The network language emphasizes the
#      physical modeling of devices in terms of discrete electrical elements. The
#      primitive objects of the network language are primitive electrical
#      components such as resistors, capacitors, inductors, and transistors, which
#      are characterized in terms of physical variables called voltage and
#      current. When describing circuits in the network language, the engineer is
#      concerned with the physical characteristics of a design. In contrast, the
#      primitive objects of the system language are signal-processing modules such
#      as filters and amplifiers. Only the functional behavior of the modules is
#      relevant, and signals are manipulated without concern for their physical
#      realization as voltages and currents. The system language is erected on the
#      network language, in the sense that the elements of signal-processing
#      systems are constructed from electrical networks. Here, however, the
#      concerns are with the large-scale organization of electrical devices to
#      solve a given application problem; the physical feasibility of the parts is
#      assumed. This layered collection of languages is another example of the
#      stratified design technique illustrated by the picture language of
#      @l(#2.2.4).
  :: @N(205) :: La misma idea es omnipresente a lo largo de toda la
     ingeniería. Por ejemplo, los ingenieros eléctricos usan muchos idiomas
     diferentes para describir los circuitos. Dos de ellos son el lenguaje de
     las @e(redes) eléctricas y el lenguaje de los @e(sistemas) eléctricos. El
     lenguaje de red enfatiza el modelado físico de los dispositivos en términos
     de elementos eléctricos discretos. Los objetos primitivos del lenguaje de
     red son componentes eléctricos primitivos tales como resistencias,
     condensadores, inductores y transistores, que se caracterizan en términos
     de variables físicas llamadas tensión y corriente. Cuando se describen
     circuitos en el lenguaje de red, el ingeniero se ocupa de las
     características físicas de un diseño. A diferencia de, Los objetos
     primitivos del lenguaje del sistema son módulos de procesamiento de señales
     tales como filtros y amplificadores. Sólo el comportamiento funcional de
     los módulos es relevante, y las señales se manipulan sin preocuparse por su
     realización física como voltajes y corrientes. El lenguaje del sistema se
     erige en el lenguaje de red, en el sentido de que los elementos de los
     sistemas de procesamiento de señales están construidos a partir de redes
     eléctricas. Aquí, sin embargo, las preocupaciones son con la organización a
     gran escala de dispositivos eléctricos para resolver un problema de
     aplicación dado; Se asume la factibilidad física de las
     partes. @l(#2.2.4<>Esta colección de lenguajes en capas es otro ejemplo de
     la técnica de diseño estratificado ilustrada por el lenguaje de imagen de
     2.2.4). Y las señales son manipuladas sin preocupación por su realización
     física como voltajes y corrientes. El lenguaje del sistema se erige en el
     lenguaje de red, en el sentido de que los elementos de los sistemas de
     procesamiento de señales están construidos a partir de redes
     eléctricas. Aquí, sin embargo, las preocupaciones son con la organización a
     gran escala de dispositivos eléctricos para resolver un problema de
     aplicación dado; Se asume la factibilidad física de las
     partes. @l(#2.2.4<>Esta colección de lenguajes en capas es otro ejemplo de
     la técnica de diseño estratificado ilustrada por el lenguaje de imagen de
     2.2.4). Y las señales son manipuladas sin preocupación por su realización
     física como voltajes y corrientes. El lenguaje del sistema se erige en el
     lenguaje de red, en el sentido de que los elementos de los sistemas de
     procesamiento de señales están construidos a partir de redes
     eléctricas. Aquí, sin embargo, las preocupaciones son con la organización a
     gran escala de dispositivos eléctricos para resolver un problema de
     aplicación dado; Se asume la factibilidad física de las
     partes. @l(#2.2.4<>Esta colección de lenguajes en capas es otro ejemplo de
     la técnica de diseño estratificado ilustrada por el lenguaje de imagen de
     2.2.4). Las preocupaciones son con la organización a gran escala de
     dispositivos eléctricos para resolver un problema de aplicación dado; Se
     asume la factibilidad física de las partes. @l(#2.2.4<>Esta colección de
     lenguajes en capas es otro ejemplo de la técnica de diseño estratificado
     ilustrada por el lenguaje de imagen de 2.2.4). Las preocupaciones son con
     la organización a gran escala de dispositivos eléctricos para resolver un
     problema de aplicación dado; Se asume la factibilidad física de las
     partes. @l(#2.2.4<>Esta colección de lenguajes en capas es otro ejemplo de
     la técnica de diseño estratificado ilustrada por el lenguaje de imagen de
     2.2.4).

#   :: @N(206) :: The most important features that our evaluator leaves out are
#      mechanisms for handling errors and supporting debugging. For a more
#      extensive discussion of evaluators, see @l(#Friedman et al. 1992), which
#      gives an exposition of programming languages that proceeds via a sequence
#      of evaluators written in Scheme.
  :: @N(206) :: Las características más importantes que nuestro evaluador deja
     de lado son los mecanismos para manejar errores y apoyar la
     depuración. Para un análisis más extenso de los evaluadores, véase
     @l(#Friedman-et-al.-1992<>Friedman et al. 1992), que da una exposición de
     los lenguajes de programación que procede a través de una secuencia de
     evaluadores escrita en Scheme.

#   :: @N(207) :: Even so, there will remain important aspects of the evaluation
#      process that are not elucidated by our evaluator. The most important of
#      these are the detailed mechanisms by which procedures call other procedures
#      and return values to their callers. We will address these issues in
#      @l(#Chapter 5), where we take a closer look at the evaluation process by
#      implementing the evaluator as a simple register machine.
  :: @N(207) :: Aún así, seguirán existiendo aspectos importantes del proceso de
     evaluación que nuestro evaluador no aclara. Los más importantes son los
     mecanismos detallados por los cuales los procedimientos llaman a otros
     procedimientos y devuelven valores a sus llamantes. Abordaremos estas
     cuestiones en el @l(Capitulo 5), donde examinaremos de cerca el
     proceso de evaluación mediante la implementación del evaluador como una
     simple máquina de registro.

#   :: @N(208) :: If we grant ourselves the ability to apply primitives, then what
#      remains for us to implement in the evaluator?  The job of the evaluator is
#      not to specify the primitives of the language, but rather to provide the
#      connective tissue––the means of combination and the means of
#      abstraction––that binds a collection of primitives to form a
#      language. Specifically:
  :: @N(208) :: Si nos concedemos la habilidad de aplicar primitivos, ¿qué nos
     queda por implementar en el evaluador? El trabajo del evaluador no es
     especificar los primitivos del lenguaje, sino más bien proporcionar el
     tejido conectivo -los medios de combinación y los medios de abstracción-
     que une una colección de primitivas para formar un
     lenguaje. Específicamente:

#      - The evaluator enables us to deal with nested expressions. For example,
#        although simply applying primitives would suffice for evaluating the
#        expression @c[(+ 1 6)], it is not adequate for handling @c[(+ 1 (* 2
#        3))]. As far as the primitive procedure @c(+) is concerned, its arguments
#        must be numbers, and it would choke if we passed it the expression @c[(*
#        2 3)] as an argument. One important role of the evaluator is to
#        choreograph procedure composition so that @c[(* 2 3)] is reduced to 6
#        before being passed as an argument to @c(+).
     - El evaluador nos permite tratar con expresiones anidadas. Por ejemplo,
       aunque la simple aplicación de primitivas bastaría para evaluar la
       expresión @c[(+ 1 6)], no es adecuada para el manejo @c[(+ 1 (* 2
       3))]. En lo que se refiere al procedimiento primitivo @c(+), sus
       argumentos deben ser números, y se ahoga si lo pasamos la expresión @c[(*
       2 3)] como un argumento. Un papel importante del evaluador es
       coreografiar la composición del procedimiento de modo que @c[(* 2 3)] se
       reduzca a 6 antes de pasar como argumento a @c(+).

#      - The evaluator allows us to use variables. For example, the primitive
#        procedure for addition has no way to deal with expressions such as @c[(+
#        x 1)]. We need an evaluator to keep track of variables and obtain their
#        values before invoking the primitive procedures.
     - El evaluador nos permite usar variables. Por ejemplo, el procedimiento
       primitivo para la adición no tiene forma de tratar con expresiones tales
       como @c[(+ x 1)]. Necesitamos un evaluador para realizar un seguimiento
       de las variables y obtener sus valores antes de invocar los
       procedimientos primitivos.

#      - The evaluator allows us to define compound procedures. This involves
#        keeping track of procedure definitions, knowing how to use these
#        definitions in evaluating expressions, and providing a mechanism that
#        enables procedures to accept arguments.
     - El evaluador nos permite definir procedimientos compuestos. Esto implica
       mantener un registro de las definiciones de procedimientos, saber cómo
       utilizar estas definiciones en la evaluación de expresiones y
       proporcionar un mecanismo que permita a los procedimientos aceptar
       argumentos.

#      - The evaluator provides the special forms, which must be evaluated
#        differently from procedure calls.
     - El evaluador proporciona los formularios especiales, que deben ser
       evaluados de forma diferente a las llamadas de procedimiento.

#   :: @N(209) :: We could have simplified the @c(application?)  clause in
#      @c(eval) by using @c(map) (and stipulating that @c(operands) returns a
#      list) rather than writing an explicit @c(list-of-values) procedure. We
#      chose not to use @c(map) here to emphasize the fact that the evaluator can
#      be implemented without any use of higher-order procedures (and thus could
#      be written in a language that doesn't have higher-order procedures), even
#      though the language that it supports will include higher-order procedures.
  :: @N(209) :: Podríamos haber simplificado la @c(application?)  cláusula en
     @c(eval) usando @c(map)(y estipulando que @c(operands) devuelve una lista)
     en lugar de escribir un procedimiento @c(list-of-values) explícito. Optamos
     por no utilizar @c(map) aquí para enfatizar el hecho de que el evaluador
     puede ser implementado sin ningún uso de procedimientos de orden superior
     (y por lo tanto podría ser escrito en un lenguaje que no tiene
     procedimientos de orden superior), a pesar de que el lenguaje que Los
     apoyos incluirán procedimientos de orden superior.

#   :: @N(210) :: In this case, the language being implemented and the
#      implementation language are the same. Contemplation of the meaning of
#      @c(true?) here yields expansion of consciousness without the abuse of
#      substance.
  :: @N(210) :: En este caso, el lenguaje implementado y el lenguaje de
     implementación son los mismos. La contemplación del significado de
     @c(true?) aquí produce la expansión de la conciencia sin el abuso de la
     sustancia.

#   :: @N(211) :: This implementation of @c(define) ignores a subtle issue in the
#      handling of internal definitions, although it works correctly in most
#      cases. We will see what the problem is and how to solve it in section @l(#4.1.6).
  :: @N(211) :: Esta implementación @c(define) ignora una cuestión sutil en el
     manejo de definiciones internas, aunque funciona correctamente en la
     mayoría de los casos. Veremos cuál es el problema y cómo resolverlo en
     @l(#4.1.6).

#   :: @N(212) :: As we said when we introduced @c(define) and @c(set!), these
#      values are implementation-dependent in Scheme––that is, the implementor can
#      choose what value to return.
  :: @N(212) :: Como dijimos cuando introdujimos @c(define) y @c(set!), estos
     valores son dependientes de la implementación en Scheme, es decir, el
     implementador puede elegir qué valor devolver.

#   :: @N(213) :: As mentioned in section @l(#2.3.1), the evaluator sees a quoted
#      expression as a list beginning with @c(quote), even if the expression is
#      typed with the quotation mark. For example, the expression @c('a) would be
#      seen by the evaluator as @c[(quote a)]. See @l(#Exercise 2.55).
  :: @N(213) :: Como se mencionó en la seccion @l(#2.3.1), el evaluador ve una
     expresión entre comillas como una lista que comienza con @c(quote), incluso
     si la expresión se escribe con las comillas. Por ejemplo, la expresión
     @c('a) sería vista por el evaluador como @c[(quote a)]. Véase el
     @l(#Ejercicio 2.55).

#   :: @N(214) :: The value of an @c(if) expression when the predicate is false
#      and there is no alternative is unspecified in Scheme; we have chosen here
#      to make it false. We will support the use of the variables @c(true) and
#      @c(false) in expressions to be evaluated by binding them in the global
#      environment. See section @l(#4.1.4).
  :: @N(214) :: El valor de una @c(if) expresión cuando el predicado es falso y
     no hay alternativa no está especificado en Scheme; Hemos elegido aquí para
     hacerlo falso. Apoyaremos el uso de las variables @c(true) y @c(false) en
     las expresiones a ser evaluadas vinculándolas en el entorno global. Véase
     @l(#4.1.4).

#   :: @N(215) :: These selectors for a list of expressions––and the corresponding
#      ones for a list of operands––are not intended as a data abstraction. They
#      are introduced as mnemonic names for the basic list operations in order to
#      make it easier to understand the explicit-control evaluator in section @l(#5.4).
  :: @N(215) :: Estos selectores para una lista de expresiones - y los
     correspondientes para una lista de operandos - no están destinados a una
     abstracción de datos. Se introducen como nombres mnemónicos para las
     operaciones de la lista básica para facilitar la comprensión del evaluador
     de control explícito en la seccion @l(#5.4).

#   :: @N(216) :: The value of a @c(cond) expression when all the predicates are
#      false and there is no @c(else) clause is unspecified in Scheme; we have
#      chosen here to make it false.
  :: @N(216) :: El valor de una @c(cond) expresión cuando todos los predicados
     son falsos y no hay ninguna @c(else) cláusula no se especifica en Scheme;
     Hemos elegido aquí para hacerlo falso.

#   :: @N(217) :: Practical Lisp systems provide a mechanism that allows a user to
#      add new derived expressions and specify their implementation as syntactic
#      transformations without modifying the evaluator. Such a user-defined
#      transformation is called a @e(macro). Although it is easy to add an
#      elementary mechanism for defining macros, the resulting language has subtle
#      name-conflict problems. There has been much research on mechanisms for
#      macro definition that do not cause these difficulties. See, for example,
#      @l(#Kohlbecker 1986), @l(#Clinger and Rees 1991), and @l(#Hanson 1991).
  :: @N(217) :: Los sistemas Lisp prácticos proporcionan un mecanismo que
     permite al usuario agregar nuevas expresiones derivadas y especificar su
     implementación como transformaciones sintácticas sin modificar el
     evaluador. Esta transformación definida por el usuario se denomina
     @e(macro). Aunque es fácil agregar un mecanismo elemental para definir
     macros, el lenguaje resultante tiene problemas sutiles de conflicto de
     nombres. Ha habido mucha investigación sobre los mecanismos para la
     definición de macro que no causan estas dificultades. Véase, por ejemplo,
     @l(#Kohlbecker-1986<>Kohlbecker 1986), @l(#Clinger-and-Rees-1991<>Clinger y
     Rees 1991), y @l(#Hanson-1991<>Hanson 1991).

#   :: @N(218) :: Frames are not really a data abstraction in the following code:
#      @c(Set-variable-value!) and @c(define-variable!) use @c(set-car!)  to
#      directly modify the values in a frame. The purpose of the frame procedures
#      is to make the environment-manipulation procedures easy to read.
  :: @N(218) :: Los cuadros no son realmente una abstracción de datos en el
     código siguiente: @c(Set-variable-value!) y @c(define-variable!) utilizar
     @c(set-car!)  para modificar directamente los valores en un marco. El
     propósito de los procedimientos de trama es hacer que los procedimientos de
     manipulación del entorno sean fáciles de leer.

#   :: @N(219) :: The drawback of this representation (as well as the variant in
#      @l(#Exercise 4.11)) is that the evaluator may have to search through many
#      frames in order to find the binding for a given variable. (Such an approach
#      is referred to as @e(deep binding).)  One way to avoid this inefficiency is
#      to make use of a strategy called @e(lexical addressing), which will be
#      discussed in section @l(#5.5.6).
  :: @N(219) :: El inconveniente de esta representación (así como la variante en
     el @l(#Ejercicio 4.11) ) es que el evaluador puede tener que
     buscar a través de muchos marcos para encontrar el enlace para una variable
     dada. (Tal enfoque se conoce como @e(unión profunda) .) Una forma de evitar
     esta ineficiencia es hacer uso de una estrategia llamada @e(léxica
     direccionamiento), que será discutido en la seccion @l(#5.5.6).

#   :: @N(220) :: Any procedure defined in the underlying Lisp can be used as a
#      primitive for the metacircular evaluator. The name of a primitive installed
#      in the evaluator need not be the same as the name of its implementation in
#      the underlying Lisp; the names are the same here because the metacircular
#      evaluator implements Scheme itself. Thus, for example, we could put
#      @c[(list 'first car)] or @c[(list 'square (lambda (x) (* x x)))] in the
#      list of @c(primitive-procedures).
  :: @N(220) :: Cualquier procedimiento definido en el Lisp subyacente puede ser
     utilizado como una primitiva para el evaluador metacircular. El nombre de
     una primitiva instalada en el evaluador no tiene que ser el mismo que el
     nombre de su implementación en el Lisp subyacente; Los nombres son los
     mismos aquí porque el evaluador metacircular implementa Scheme sí
     mismo. Así, por ejemplo, podríamos poner @c[(list 'first car)] o @c[(list
     'square (lambda (x) (* x x)))] en la lista de @c(primitive-procedures).

#   :: @N(221) :: @c(Apply-in-underlying-scheme) is the @c(apply) procedure we
#      have used in earlier chapters. The metacircular evaluator's @c(apply)
#      procedure (section @l(#4.1.1)) models the working of this primitive. Having two
#      different things called @c(apply) leads to a technical problem in running
#      the metacircular evaluator, because defining the metacircular evaluator's
#      @c(apply) will mask the definition of the primitive. One way around this is
#      to rename the metacircular @c(apply) to avoid conflict with the name of the
#      primitive procedure. We have assumed instead that we have saved a reference
#      to the underlying @c(apply) by doing
  :: @N(221) :: @c(Apply-in-underlying-scheme) Es el procedimiento @c(apply) que
     hemos utilizado en los capítulos anteriores. El procedimiento @c(apply) del
     evaluador metacircular (seccion @l(#4.1.1)) modela el funcionamiento de
     esta primitiva. Tener dos cosas diferentes llamadas @c(apply) conduce a un
     problema técnico al ejecutar el evaluador metacircular, porque la
     definición del evaluador metacircular @c(apply) enmascarará la definición
     del primitivo. Una manera alrededor de esto es cambiar el nombre de la
     metacircular @c(apply) para evitar conflictos con el nombre del
     procedimiento primitivo. En cambio, hemos asumido que hemos guardado una
     referencia al subyacente @c(apply) haciendo

#      ..src > scheme
#        (define apply-in-underlying-scheme apply)
#      < src..
     ..src > scheme
       (define apply-in-underlying-scheme apply)
     < src..

#      before defining the metacircular @c(apply). This allows us to access the
#      original version of @c(apply) under a different name.
     Antes de definir el metacircular @c(apply). Esto nos permite acceder a la
     versión original de @c(apply) bajo un nombre diferente.

#   :: @N(222) :: The primitive procedure @c(read) waits for input from the user,
#      and returns the next complete expression that is typed. For example, if the
#      user types @c[(+ 23 x)], @c(read) returns a three-element list containing
#      the symbol @c(+), the number 23, and the symbol @c(x). If the user types
#      @c('x), @c(read) returns a two-element list containing the symbol @c(quote)
#      and the symbol @c(x).
  :: @N(222) :: El procedimiento primitivo @c(read) espera la entrada del
     usuario y devuelve la siguiente expresión completa que se escribe. Por
     ejemplo, si el usuario escribe @c[(+ 23 x)], @c(read) devuelve una lista de
     tres elementos que contiene el símbolo @c(+), el número 23 y el símbolo
     @c(x). Si el usuario escribe @c('x), @c(read) devuelve una lista de dos
     elementos que contiene el símbolo @c(quote) y el símbolo @c(x).

#   :: @N(223) :: The fact that the machines are described in Lisp is
#      inessential. If we give our evaluator a Lisp program that behaves as an
#      evaluator for some other language, say C, the Lisp evaluator will emulate
#      the C evaluator, which in turn can emulate any machine described as a C
#      program.  Similarly, writing a Lisp evaluator in C produces a C program
#      that can execute any Lisp program. The deep idea here is that any evaluator
#      can emulate any other. Thus, the notion of @"(what can in principle be
#      computed) (ignoring practicalities of time and memory required) is
#      independent of the language or the computer, and instead reflects an
#      underlying notion of @e(computability). This was first demonstrated in a
#      clear way by Alan M. Turing (1912-1954), whose 1936 paper laid the
#      foundations for theoretical computer science. In the paper, Turing
#      presented a simple computational model––now known as a @e(Turing
#      machine)––and argued that any @"(effective process) can be formulated as a
#      program for such a machine. (This argument is known as the @e(Church-Turing
#      thesis).)  Turing then implemented a universal machine, i.e., a Turing
#      machine that behaves as an evaluator for Turing-machine programs. He used
#      this framework to demonstrate that there are well-posed problems that
#      cannot be computed by Turing machines (see @l(#Exercise 4.15)), and so by
#      implication cannot be formulated as @"(effective processes.)  Turing went
#      on to make fundamental contributions to practical computer science as
#      well. For example, he invented the idea of structuring programs using
#      general-purpose subroutines. See @l(#Hodges 1983) for a biography of
#      Turing.
  :: @N(223) :: El hecho de que las máquinas se describen en Lisp es
     inesencial. Si damos a nuestro evaluador un programa Lisp que se comporta
     como un evaluador para otro lenguaje, digamos C, el evaluador de Lisp
     emulará el evaluador C, que a su vez puede emular cualquier máquina
     descrita como un programa C. De manera similar, escribir un evaluador Lisp
     en C produce un programa C que puede ejecutar cualquier programa Lisp. La
     idea profunda aquí es que cualquier evaluador puede emular cualquier
     otro. Por lo tanto, la noción de @"(lo que en principio puede ser
     computado) (ignorando los aspectos prácticos del tiempo y la memoria
     requeridos) es independiente del lenguaje o la computadora, y en su lugar
     refleja una noción subyacente de @e(computabilidad). Esto fue demostrado
     primero en una manera clara por Alan M. Turing (1912-1954), cuyo 1936 el
     papel sentó las bases para la ciencia informática teórica. @e(En el
     documento, Turing presentó un modelo computacional simple - ahora conocido
     como una máquina de Turing) - y argumentó que cualquier @"(proceso
     efectivo) puede ser formulado como un programa para tal máquina. (Este
     argumento se conoce como la @e(tesis de Church-Turing) .) Turing entonces
     implementó una máquina universal, es decir, una máquina de Turing que se
     comporta como un evaluador para programas de máquina de Turing. Utilizó
     este marco para demostrar que existen problemas bien planteados que no
     pueden ser computados por las máquinas de Turing (ver el
     @l(#Ejercicio 4.15) ), por lo que, por implicación, no
     pueden ser formulados como @"(procesos efectivos. )  Turing continuó a
     hacer contribuciones fundamentales a la informática práctica también. Por
     ejemplo, Inventó la idea de estructurar programas usando subrutinas de
     propósito general. @l(#Hodges-1983<>Ver Hodges 1983) para una biografía de
     Turing.

#   :: @N(224) :: Some people find it counterintuitive that an evaluator, which is
#      implemented by a relatively simple procedure, can emulate programs that are
#      more complex than the evaluator itself. The existence of a universal
#      evaluator machine is a deep and wonderful property of computation.
#      @e(Recursion theory), a branch of mathematical logic, is concerned with
#      logical limits of computation. Douglas Hofstadter's beautiful book
#      @q(G@"odel, Escher, Bach) explores some of these ideas (@l(#Hofstadter
#      1979)).
  :: @N(224) :: Algunas personas encuentran que es contraintuitivo que un
     evaluador, que es implementado por un procedimiento relativamente simple,
     puede emular programas que son más complejos que el propio evaluador. La
     existencia de una máquina evaluadora universal es una propiedad profunda y
     maravillosa de la computación. @e(La teoría de la recursión), una rama de
     la lógica matemática, se ocupa de los límites lógicos de la
     computación. Hermoso libro de Douglas Hofstadter

#   :: @N(225) :: Warning: This @c(eval) primitive is not identical to the
#      @c(eval) procedure we implemented in section @l(#4.1.1), because it uses @e(actual)
#      Scheme environments rather than the sample environment structures we built
#      in section @l(#4.1.3). These actual environments cannot be manipulated by the user
#      as ordinary lists; they must be accessed via @c(eval) or other special
#      operations. Similarly, the @c(apply) primitive we saw earlier is not
#      identical to the metacircular @c(apply), because it uses actual Scheme
#      procedures rather than the procedure objects we constructed in section @l(#4.1.3)
#      and @l(#4.1.4).
  :: @N(225) :: Advertencia: Esta @c(eval) primitiva no es idéntica al
     procedimiento @c(eval) que implementamos en la seccion @l(#4.1.1), ya que utiliza
     @e(los) entornos Scheme @e(reales en) lugar de las estructuras de entorno
     de muestra que construimos en la seccion @l(#4.1.3). Estos entornos reales no
     pueden ser manipulados por el usuario como listas ordinarias; Se debe tener
     acceso a través de @c(eval) u otras operaciones especiales. De manera
     similar, la @c(apply) primitiva que vimos anteriormente no es idéntica a la
     metacircular @c(apply), porque utiliza los procedimientos Scheme reales más
     que los objetos de procedimiento que construimos en la seccion @l(#4.1.3) y
     @l(#4.1.4).

#   :: @N(226) :: The @A(MIT) implementation of Scheme includes @c(eval), as well
#      as a symbol @c(user-initial-environment) that is bound to the initial
#      environment in which the user's input expressions are evaluated.
  :: @N(226) :: La implementación @A(MIT) de Scheme incluye @c(eval), así como
     un símbolo @c(user-initial-environment) que está vinculado al entorno
     inicial en el que se evalúan las expresiones de entrada del usuario.

#   :: @N(227) :: Although we stipulated that @c(halts?)  is given a procedure
#      object, notice that this reasoning still applies even if @c(halts?) can
#      gain access to the procedure's text and its environment.  This is Turing's
#      celebrated @e(Halting Theorem), which gave the first clear example of a
#      @e(non-computable) problem, i.e., a well-posed task that cannot be carried
#      out as a computational procedure.
  :: @N(227) :: Aunque estipulamos que @c(halts?)  se le da un objeto de
     procedimiento, observe que este razonamiento sigue siendo válido incluso si
     @c(halts?) puede obtener acceso al texto del procedimiento y su
     entorno. Este es el célebre @e(teorema de) Turing, que dio el primer
     ejemplo claro de un problema @e(no computable), es decir, una tarea bien
     planteada que no puede llevarse a cabo como un procedimiento computacional.

#   :: @N(228) :: Wanting programs to not depend on this evaluation mechanism is
#      the reason for the @"(management is not responsible) remark in
#     @n(28<>Footnote 28) of @l(#Chapter 1). By insisting that internal
#      definitions come first and do not use each other while the definitions are
#      being evaluated, the @A(IEEE) standard for Scheme leaves implementors some
#      choice in the mechanism used to evaluate these definitions. The choice of
#      one evaluation rule rather than another here may seem like a small issue,
#      affecting only the interpretation of @"(badly formed) programs. However, we
#      will see in section @l(#5.5.6) that moving to a model of simultaneous scoping for
#      internal definitions avoids some nasty difficulties that would otherwise
#      arise in implementing a compiler.
  :: @N(228) :: Deseando programas para no depender de este mecanismo de
     evaluación es la razón de la @"(gestión no es responsable) en la
    @n(28<>Nota 28) del @l(Capitulo 1). Al insistir en que las
     definiciones internas vienen primero y no se utilizan entre sí mientras se
     están evaluando las definiciones, el estándar @A(IEEE) para Scheme deja a
     los implementadores alguna opción en el mecanismo usado para evaluar estas
     definiciones. La elección de una regla de evaluación en lugar de otra aquí
     puede parecer una cuestión pequeña, que afecta sólo a la interpretación de
     los programas @"(mal formados). Sin embargo, veremos en la seccion @l(#5.5.6)
     que pasar a un modelo de alcance simultáneo para definiciones internas
     evita algunas dificultades desagradables que de otra manera surgirían al
     implementar un compilador.

#   :: @N(229) :: The @A(IEEE) standard for Scheme allows for different
#      implementation strategies by specifying that it is up to the programmer to
#      obey this restriction, not up to the implementation to enforce it. Some
#      Scheme implementations, including @A(MIT) Scheme, use the transformation
#      shown above. Thus, some programs that don't obey this restriction will in
#      fact run in such implementations.
  :: @N(229) :: El estándar @A(IEEE) para Scheme permite diferentes estrategias
     de implementación especificando que corresponde al programador obedecer
     esta restricción, no a la implementación para aplicarla. Algunas
     implementaciones de Scheme, incluyendo @A(MIT) Scheme, usan la
     transformación mostrada anteriormente. Por lo tanto, algunos programas que
     no obedecen esta restricción de hecho correrán en tales implementaciones.

#   :: @N(230) :: The @A(MIT) implementors of Scheme support Alyssa on the
#      following grounds: Eva is in principle correct––the definitions should be
#      regarded as simultaneous. But it seems difficult to implement a general,
#      efficient mechanism that does what Eva requires. In the absence of such a
#      mechanism, it is better to generate an error in the difficult cases of
#      simultaneous definitions (Alyssa's notion) than to produce an incorrect
#      answer (as Ben would have it).
  :: @N(230) :: Los ejecutores del @A(MIT) del Scheme apoyan a Alyssa por los
     siguientes motivos: Eva es en principio correcta - las definiciones deben
     considerarse simultáneas. Pero parece difícil implementar un mecanismo
     general y eficiente que haga lo que Eva requiere. En ausencia de tal
     mecanismo, es mejor generar un error en los casos difíciles de definiciones
     simultáneas (noción de Alyssa) que producir una respuesta incorrecta (como
     Ben lo tendría).

#   :: @N(231) :: This example illustrates a programming trick for formulating
#      recursive procedures without using @c(define). The most general trick of
#      this sort is the @m(Y) @e(operator), which can be used to give a @"(pure
#      λ-calculus) implementation of recursion. (See @l(#Stoy 1977) for details on
#      the λ-calculus, and @l(#Gabriel 1988) for an exposition of the @m(Y)
#      operator in Scheme.)
  :: @N(231) :: Este ejemplo ilustra un truco de programación para formular
     procedimientos recursivos sin utilizar @c(define). El truco más general de
     este tipo es el @e(operador )@m(Y), !que puede usarse para dar una
     implementación de recursión de @"(cálculo-λ pura). (Ver
     @l(#Stoy-1977<>Stoy 1977) para detalles sobre el cálculo-λ, y
     @l(#Gabriel-1988<>Gabriel 1988) para una exposición del operador @m(Y) en
     Scheme.)@e()@"()@l(#Stoy 1977) @l(#Gabriel-1988)

#   :: @N(232) :: This technique is an integral part of the compilation process,
#      which we shall discuss in @l(#Chapter 5). Jonathan Rees wrote a Scheme
#      interpreter like this in about 1982 for the T project (@l(#Rees and Adams
#      1982)). Marc @l(#Feeley (1986)) (see also @l(#Feeley and Lapalme 1987))
#      independently invented this technique in his master's thesis.
  :: @N(232) :: Esta técnica es una parte integral del proceso de compilación,
     que discutiremos en el @l(#Capitulo 5). Jonathan Rees escribió
     un intérprete Scheme como este en alrededor de 1982 para el proyecto T (
     @l(#Rees-and-Adams-1982<>Rees y Adams 1982) ). Marc
     @l(#Feeley-(1986<>Feeley (1986) ) (véase también
     @l(#Feeley-and-Lapalme-1987<>Feeley y Lapalme 1987) ) independientemente
     inventó esta técnica en su tesis de maestría.

#   :: @N(233) :: There is, however, an important part of the variable search that
#      @e(can) be done as part of the syntactic analysis. As we will show in
#      @l(#5.5.6), one can determine the position in the environment structure
#      where the value of the variable will be found, thus obviating the need to
#      scan the environment for the entry that matches the variable.
  :: @N(233) :: Sin embargo, hay una parte importante de la búsqueda de
     variables que @e(se) puede hacer como parte del análisis sintáctico. Como
     se muestra en la seccion @l(#5.5.6), se puede determinar la posición en la
     estructura del entorno donde se encontrará el valor de la variable,
     obviando así la necesidad de escanear el entorno para la entrada que
     coincida con la variable.

#   :: @N(234) :: See @l(#Exercise 4.23) for some insight into the processing of
#      sequences.
  :: @N(234) :: Consulte el @l(#Ejercicio 4.23) para obtener
     información sobre el procesamiento de secuencias.

#   :: @N(235) :: Snarf: @"(To grab, especially a large document or file for the
#      purpose of using it either with or without the owner's permission.)  Snarf
#      down: @"(To snarf, sometimes with the connotation of absorbing, processing,
#      or understanding.)  (These definitions were snarfed from @l(#Steele et
#      al. 1983). See also @l(#Raymond 1993).)
  :: @N(235) :: Snarf: @"(Para agarrar, especialmente un gran documento o
     archivo con el fin de usarlo con o sin el permiso del propietario. )  Snarf
     abajo: @"(Para snarf, a veces con la connotación de absorción,
     procesamiento o comprensión. )  (Estas definiciones fueron tomadas de
     @l(#Steele-et-al.-1983<>Steele et al., 1983.) Véase también
     @l(#Raymond-1993<>Raymond 1993) ).

#   :: @N(236) :: The difference between the @"(lazy) terminology and the
#      @"(normal-order) terminology is somewhat fuzzy. Generally, @"(lazy) refers
#      to the mechanisms of particular evaluators, while @"(normal-order) refers
#      to the semantics of languages, independent of any particular evaluation
#      strategy. But this is not a hard-and-fast distinction, and the two
#      terminologies are often used interchangeably.
  :: @N(236) :: La diferencia entre la terminología @"(perezosa) y la
     terminología de @"(orden normal) es algo difusa. Generalmente, la @"(pereza
     se) refiere a los mecanismos de los evaluadores particulares, mientras que
     @"(el orden normal se) refiere a la semántica de los lenguajes,
     independientemente de cualquier estrategia de evaluación particular. Pero
     esto no es una distinción difícil y rápida, y las dos terminologías se
     utilizan a menudo indistintamente.

#   :: @N(237) :: The @"(strict) versus @"(non-strict) terminology means
#      essentially the same thing as @"(applicative-order) versus
#      @"(normal-order,) except that it refers to individual procedures and
#      arguments rather than to the language as a whole. At a conference on
#      programming languages you might hear someone say, @"(The normal-order
#      language Hassle has certain strict primitives. Other procedures take their
#      arguments by lazy evaluation.)
  :: @N(237) :: La terminología @"(estricta) versus @"(no estricta) significa
     esencialmente lo mismo que el @"(orden aplicacional) versus el @"(orden
     )@"(normal,) excepto que se refiere a procedimientos y argumentos
     individuales en lugar de al lenguaje como un todo. En una conferencia sobre
     lenguajes de programación, puede que alguien diga: @"(El lenguaje de orden
     normal El fastidio tiene ciertas primitivas estrictas. Otros procedimientos
     toman sus argumentos mediante una evaluación perezosa.)

#   :: @N(238) :: The word @e(thunk) was invented by an informal working group
#      that was discussing the implementation of call-by-name in Algol 60. They
#      observed that most of the analysis of (@"(thinking about)) the expression
#      could be done at compile time; thus, at run time, the expression would
#      already have been @"(thunk) about (@l(#Ingerman et al. 1960)).
  :: @N(238) :: La palabra @e(thunk) fue inventada por un grupo de trabajo
     informal que estaba discutiendo la implementación de call-by-name en
     Algol 60. Observaron que la mayor parte del análisis de (la @"(reflexión
     sobre) ) la expresión podría hacerse en tiempo de compilación; Por lo
     tanto, en el momento de la ejecución, la expresión ya se habría
     @"(debatido) (@l(#Ingerman-et-al.-1960<>Ingerman et al., 1960) ).

#   :: @N(239) :: This is analogous to the use of @c(force) on the delayed objects
#      that were introduced in @l(#Chapter 3) to represent streams.  The critical
#      difference between what we are doing here and what we did in @l(#Chapter 3)
#      is that we are building delaying and forcing into the evaluator, and thus
#      making this uniform and automatic throughout the language.
  :: @N(239) :: Esto es análogo al uso de @c(force) los objetos retardados que
     fueron introducidos en el @l(#Capitulo 3) para representar los
     flujos. La diferencia crítica entre lo que estamos haciendo aquí y lo que
     hicimos en el @l(#Capitulo 3) es que estamos construyendo
     retrasar y forzar al evaluador, y por lo tanto hacerlo uniforme y
     automático en todo el lenguaje.

#   :: @N(240) :: Lazy evaluation combined with memoization is sometimes referred
#      to as @e(call-by-need) argument passing, in contrast to @e(call-by-name)
#      argument passing.  (Call-by-name, introduced in Algol 60, is similar to
#      non-memoized lazy evaluation.)  As language designers, we can build our
#      evaluator to memoize, not to memoize, or leave this an option for
#      programmers (@l(#Exercise 4.31)). As you might expect from @l(#Chapter 3),
#      these choices raise issues that become both subtle and confusing in the
#      presence of assignments. (See @l(#Exercise 4.27) and @l(#Exercise 4.29).)
#      An excellent article by @l[#Clinger (1982)] attempts to clarify the
#      multiple dimensions of confusion that arise here.
  :: @N(240) :: La evaluación perezosa combinada con la memoización se denomina
     a veces pasar de argumento de @e(llamada por necesidad), en contraste con
     el paso de argumento de @e(llamada por nombre). (Call-by-name, introducido
     en Algol 60, es similar a la evaluación no-memoized perezoso.) Como
     diseñadores de lenguaje, podemos construir nuestro evaluador para
     memorizar, no para memorizar, o dejar esta opción para los programadores (
     @l(#Ejercicio 4.31) ). Como es de esperar del
     @l(#Capitulo 3), estas decisiones plantean problemas que se
     vuelven sutiles y confusos en presencia de asignaciones. (Véase el
     @l(#Ejercicio 4.27) y el @l(#Ejercicio 4.29)
     .) Un excelente artículo de @l(#Clinger-(1982)<>Clinger (1982)) trata de
     aclarar las múltiples dimensiones de la confusión que surgen aquí.

#   :: @N(241) :: Notice that we also erase the @c(env) from the thunk once the
#      expression's value has been computed. This makes no difference in the
#      values returned by the interpreter. It does help save space, however,
#      because removing the reference from the thunk to the @c(env) once it is no
#      longer needed allows this structure to be @e(garbage-collected) and its
#      space recycled, as we will discuss in section @l(#5.3).
  :: @N(241) :: Tenga en cuenta que también borrar el @c(env) de la conversación
     una vez que el valor de la expresión se ha calculado. Esto no hace ninguna
     diferencia en los valores devueltos por el intérprete. Sin embargo, ayuda a
     ahorrar espacio, ya que la eliminación de la referencia del thunk a la
     @c(env) vez que ya no se necesita permite que esta estructura se @e(recoja
     de basura) y se recicle su espacio, como veremos en la seccion @l(#5.3).

#      Similarly, we could have allowed unneeded environments in the memoized
#      delayed objects of section @l(#3.5.1) to be garbage-collected, by having
#      @c(memo-proc) do something like @c[(set! proc '())] to discard the
#      procedure @c(proc) (which includes the environment in which the @c(delay)
#      was evaluated) after storing its value.
     De manera similar, podríamos haber permitido que los entornos innecesarios
     de los objetos retrasados memorizados de la seccion @l(#3.5.1) fueran
     recolectados de basura, al haber @c(memo-proc) hecho algo como @c[(set!
     proc '())] descartar el procedimiento @c(proc)(que incluye el entorno en el
     que @c(delay) se evaluó) después de almacenar su valor.

#   :: @N(242) :: This exercise demonstrates that the interaction between lazy
#      evaluation and side effects can be very confusing. This is just what you
#      might expect from the discussion in @l(#Chapter 3).
  :: @N(242) :: Este ejercicio demuestra que la interacción entre la evaluación
     perezosa y los efectos secundarios puede ser muy confuso. Esto es justo lo
     que usted podría esperar de la discusión en el @l(#Capitulo 3).

#   :: @N(243) :: This is precisely the issue with the @c(unless) procedure, as in
#      @l(#Exercise 4.26).
  :: @N(243) :: Éste es precisamente el problema con el procedimiento @c(unless), como en el @l(#Ejercicio 4.26).

#   :: @N(244) :: This is the procedural representation described in @l(#Exercise
#      2.4). Essentially any procedural representation (e.g., a message-passing
#      implementation) would do as well. Notice that we can install these
#      definitions in the lazy evaluator simply by typing them at the driver
#      loop. If we had originally included @c(cons), @c(car), and @c(cdr) as
#      primitives in the global environment, they will be redefined. (Also see
#      @l(#Exercise 4.33) and @l(#Exercise 4.34).)
  :: @N(244) :: Esta es la representación procesal descrita en el
     @l(#Ejercicio 2.4). Esencialmente, cualquier representación
     de procedimiento (por ejemplo, una implementación de paso de mensaje)
     también lo haría. Observe que podemos instalar estas definiciones en el
     evaluador perezoso simplemente escribiéndolas en el bucle del
     controlador. Si hubiéramos incluido originalmente @c(cons), @c(car) y
     @c(cdr) como primitivas en el medio ambiente mundial, van a ser
     redefinidos. (Véase también el @l(#Ejercicio 4.33) y el
     @l(#Ejercicio 4.34) .)

#   :: @N(245) :: This permits us to create delayed versions of more general kinds
#      of list structures, not just sequences. @l(#Hughes 1990) discusses some
#      applications of @"(lazy trees.)
  :: @N(245) :: Esto nos permite crear versiones retardadas de tipos más
     generales de estructuras de lista, no sólo
     secuencias. @l(#Hughes-1990<>Hughes 1990) discute algunas aplicaciones de
     los @"(árboles perezosos.)

#   :: @N(246) :: We assume that we have previously defined a procedure @c(prime?)
#      that tests whether numbers are prime. Even with @c(prime?) defined, the
#      @c(prime-sum-pair) procedure may look suspiciously like the unhelpful
#      @"(pseudo-Lisp) attempt to define the square-root function, which we
#      described at the beginning of section @l(#1.1.7). In fact, a square-root procedure
#      along those lines can actually be formulated as a nondeterministic
#      program. By incorporating a search mechanism into the evaluator, we are
#      eroding the distinction between purely declarative descriptions and
#      imperative specifications of how to compute answers. We'll go even farther
#      in this direction in section @l(#4.4).
  :: @N(246) :: Suponemos que previamente hemos definido un procedimiento
     @c(prime?) que prueba si los números son primos. Incluso con @c(prime?)
     definido, el procedimiento @c(prime-sum-pair) puede parecer sospechosamente
     como el inútil intento de @"(pseudo-Lisp) para definir la función de raíz
     cuadrada, que describimos al principio de la seccion @l(#1.1.7). De hecho, un
     procedimiento de raíz cuadrada a lo largo de esas líneas puede en realidad
     ser formulado como un programa no determinista. Al incorporar un mecanismo
     de búsqueda en el evaluador, estamos erosionando la distinción entre las
     descripciones puramente declarativas y las especificaciones imperativas de
     cómo calcular las respuestas. Vamos a ir aún más lejos en esta dirección en
     @l(#4.4).

#   :: @N(247) :: The idea of @c(amb) for nondeterministic programming was first
#      described in 1961 by John McCarthy (see @l(#McCarthy 1963)).
  :: @N(247) :: La idea de @c(amb) programación no determinista fue descrita por
     primera vez en 1961 por John McCarthy (véase
     @l(#McCarthy-1963<>McCarthy, 1963) ).

#   :: @N(248) :: In actuality, the distinction between nondeterministically
#      returning a single choice and returning all choices depends somewhat on our
#      point of view. From the perspective of the code that uses the value, the
#      nondeterministic choice returns a single value. From the perspective of the
#      programmer designing the code, the nondeterministic choice potentially
#      returns all possible values, and the computation branches so that each
#      value is investigated separately.
  :: @N(248) :: En realidad, la distinción entre el no determinismo de devolver
     una sola opción y devolver todas las opciones depende en cierta medida de
     nuestro punto de vista. Desde la perspectiva del código que utiliza el
     valor, la elección no determinista devuelve un único valor. Desde la
     perspectiva del programador que diseña el código, la elección no
     determinista devuelve potencialmente todos los valores posibles, y las
     ramas de cálculo para que cada valor sea investigado por separado.

#   :: @N(249) :: One might object that this is a hopelessly inefficient
#      mechanism. It might require millions of processors to solve some easily
#      stated problem this way, and most of the time most of those processors
#      would be idle. This objection should be taken in the context of
#      history. Memory used to be considered just such an expensive commodity. In
#      1964 a megabyte of @A(RAM) cost about $400,000. Now every personal computer
#      has many megabytes of @A(RAM), and most of the time most of that @A(RAM) is
#      unused. It is hard to underestimate the cost of mass-produced electronics.
  :: @N(249) :: Uno podría objetar que este es un mecanismo desesperadamente
     ineficiente. Puede requerir que millones de procesadores resuelvan algún
     problema fácilmente identificable de esta manera, y la mayoría de las veces
     la mayoría de esos procesadores estarían inactivos. Esta objeción debe
     tomarse en el contexto de la historia. La memoria solía ser considerada
     como una mercancía tan cara. En 1964 un megabyte de @A(RAM) costó alrededor
     de $ 400,000. Ahora cada computadora personal tiene muchos megabytes de
     @A(RAM), y la mayoría de las veces la mayor parte de esa @A(memoria RAM) no
     se utiliza. Es difícil subestimar el costo de la electrónica producida en
     masa.

#   :: @N(250) :: @t(Footnote 250)Automagically: @"(Automatically, but in a way
#      which, for some reason (typically because it is too complicated, or too
#      ugly, or perhaps even too trivial), the speaker doesn't feel like
#      explaining.)  (@l(#Steele et al. 1983), @l(#Raymond 1993))
  :: @N(250) :: <span id="Footnote-250">Nota de pie de página
     </span>@"(Automáticamente) : @"(pero de una manera que, por alguna razón
     (por ejemplo, porque es demasiado complicada, o demasiado fea, o quizás
     demasiado trivial), el orador no tiene ganas de explicarlo) (
     @l(#Steele-et-al.-1983<>Steele et al.), @l(#Steele-et-al.-1983<>1983),
     @l(#Raymond-1993<>Raymond 1993) )

#   :: @N(251) :: The integration of automatic search strategies into programming
#      languages has had a long and checkered history. The first suggestions that
#      nondeterministic algorithms might be elegantly encoded in a programming
#      language with search and automatic backtracking came from Robert @l(#Floyd
#      (1967)). Carl @l[#Hewitt (1969)] invented a programming language called
#      Planner that explicitly supported automatic chronological backtracking,
#      providing for a built-in depth-first search strategy. @l(#Sussman et
#      al. (1971)) implemented a subset of this language, called MicroPlanner,
#      which was used to support work in problem solving and robot
#      planning. Similar ideas, arising from logic and theorem proving, led to the
#      genesis in Edinburgh and Marseille of the elegant language Prolog (which we
#      will discuss in section @l(#4.4)). After sufficient frustration with automatic
#      search, @l(#McDermott and Sussman (1972)) developed a language called
#      Conniver, which included mechanisms for placing the search strategy under
#      programmer control. This proved unwieldy, however, and @l(#Sussman and
#      Stallman 1975) found a more tractable approach while investigating methods
#      of symbolic analysis for electrical circuits. They developed a
#      non-chronological backtracking scheme that was based on tracing out the
#      logical dependencies connecting facts, a technique that has come to be
#      known as @e(dependency-directed backtracking). Although their method was
#      complex, it produced reasonably efficient programs because it did little
#      redundant search. @l[#Doyle (1979)] and @l[#McAllester (1978; 1980)]
#      generalized and clarified the methods of Stallman and Sussman, developing a
#      new paradigm for formulating search that is now called @e(truth
#      maintenance). Modern problem-solving systems all use some form of
#      truth-maintenance system as a substrate. See @l(#Forbus and deKleer 1993)
#      for a discussion of elegant ways to build truth-maintenance systems and
#      applications using truth maintenance.  @l(#Zabih et al. 1987) describes a
#      nondeterministic extension to Scheme that is based on @c(amb); it is
#      similar to the interpreter described in this section, but more
#      sophisticated, because it uses dependency-directed backtracking rather than
#      chronological backtracking. @l(#Winston 1992) gives an introduction to both
#      kinds of backtracking.
  :: @N(251) :: La integración de las estrategias de búsqueda automática en los
     lenguajes de programación ha tenido una larga historia. Las primeras
     sugerencias de que los algoritmos no determinísticos pueden codificarse
     elegantemente en un lenguaje de programación con búsqueda y retroceso
     automático provienen de Robert @l(#Floyd-(1967<>Floyd (1967) ). Carl
     @l(#Hewitt-(1969)<>Hewitt (1969)) inventó un lenguaje de programación
     llamado Planner que apoyaba explícitamente el retroceso automático
     cronológico, proporcionando una estrategia integrada de búsqueda en
     profundidad. @l(#Sussman-et-al.-(1971<>Sussman et al. (1971) ) implementó
     un subconjunto de este lenguaje, llamado MicroPlanner, que se utilizó para
     apoyar el trabajo en la resolución de problemas y la planificación de
     robots. Ideas similares, surgidas de la lógica y del teorema probando,
     @l(#4.4<>Llevó a la génesis en Edimburgo y Marsella del lenguaje elegante
     Prolog (que discutiremos en 4.4) ). Después de suficiente frustración con
     la búsqueda automática, @l(#McDermott-and-Sussman-(1972<>McDermott y
     Sussman (1972) ) desarrollaron un lenguaje llamado Conniver, que incluía
     mecanismos para colocar la estrategia de búsqueda bajo control del
     programador. Sin embargo, esto resultó difícil de manejar, y
     @l(#Sussman-and-Stallman-1975<>Sussman y Stallman 1975) encontraron un
     enfoque más manejable al investigar métodos de análisis simbólico para
     circuitos eléctricos. Desarrollaron un esquema de backtracking no
     cronológico que se basó en el rastreo de las dependencias lógicas que
     conectan hechos, una técnica que ha llegado a ser conocida como
     @e(backtracking dirigido a la dependencia). Aunque su método era complejo,
     Produjo programas razonablemente eficientes porque realizó poca búsqueda
     redundante. @l(#Doyle-(1979)<>Doyle (1979)) y
     @l(#McAllester-(1978;-1980)<>McAllester (1978, 1980)) generalizaron y
     aclararon los métodos de Stallman y Sussman, desarrollando un nuevo
     paradigma para formular la búsqueda que ahora se llama @e(mantenimiento de
     la verdad). Los sistemas modernos de resolución de problemas usan algún
     tipo de sistema de mantenimiento de la verdad como sustrato. Véase
     @l(#Forbus-and-deKleer-1993<>Forbus y deKleer 1993) para una discusión de
     formas elegantes de construir sistemas y aplicaciones de mantenimiento de
     la verdad usando el mantenimiento de la verdad.
     @l(#Zabih-et-al.-1987<>Zabih et al. 1987) describe una extensión no
     determinista de Scheme que se basa en @c(amb); Es similar al intérprete
     descrito en esta sección, pero más sofisticado, Porque utiliza un retroceso
     en función de la dependencia en lugar de un retroceso
     cronológico. @l(#Winston-1992<>Winston 1992) da una introducción a ambos
     tipos de backtracking.

#   :: @N(252) :: Our program uses the following procedure to determine if the
#      elements of a list are distinct:
  :: @N(252) :: Nuestro programa utiliza el siguiente procedimiento para
     determinar si los elementos de una lista son distintos:

#      ..src > scheme
#        (define (distinct? items)
#          (cond ((null? items) true)
#                ((null? (cdr items)) true)
#                ((member (car items) (cdr items)) false)
#                (else (distinct? (cdr items)))))
#      < src..
     ..src > scheme
       (define (distinct? items)
         (cond ((null? items) true)
               ((null? (cdr items)) true)
               ((member (car items) (cdr items)) false)
               (else (distinct? (cdr items)))))
     < src..

#      @c(Member) is like @c(memq) except that it uses @c(equal?) instead of
#      @c(eq?) to test for equality.
     @c(Member) Es como @c(memq) excepto que utiliza en @c(equal?) lugar de
     @c(eq?) probar la igualdad.

#   :: @N(253) :: This is taken from a booklet called @"(Problematical
#      Recreations,) published in the 1960s by Litton Industries, where it is
#      attributed to the @q(Kansas State Engineer).
  :: @N(253) :: Esto se toma de un folleto llamado @"(Problematical
     Recreations,) publicado en los años 60 por las industrias de Litton, donde
     se atribuye al @"(ingeniero del estado de Kansas).

#   :: @N(254) :: Here we use the convention that the first element of each list
#      designates the part of speech for the rest of the words in the list.
  :: @N(254) :: Aquí usamos la convención de que el primer elemento de cada
     lista designa la parte de la palabra para el resto de las palabras de la
     lista.

#   :: @N(255) :: Notice that @c(parse-word) uses @c(set!) to modify the unparsed
#      input list. For this to work, our @c(amb) evaluator must undo the effects
#      of @c(set!) operations when it backtracks.
  :: @N(255) :: Tenga en cuenta que se @c(parse-word) utiliza @c(set!) para
     modificar la lista de entrada sin analizar. Para que esto funcione, nuestro
     @c(amb) evaluador debe deshacer los efectos de las @c(set!) operaciones
     cuando retrocede.

#   :: @N(256) :: Observe that this definition is recursive––a verb may be
#      followed by any number of prepositional phrases.
  :: @N(256) :: Observe que esta definición es recursiva - un verbo puede ser
     seguido por cualquier número de frases preposicionales.

#   :: @N(257) :: This kind of grammar can become arbitrarily complex, but it is
#      only a toy as far as real language understanding is concerned. Real
#      natural-language understanding by computer requires an elaborate mixture of
#      syntactic analysis and interpretation of meaning. On the other hand, even
#      toy parsers can be useful in supporting flexible command languages for
#      programs such as information-retrieval systems. @l(#Winston 1992) discusses
#      computational approaches to real language understanding and also the
#      applications of simple grammars to command languages.
  :: @N(257) :: Este tipo de gramática puede llegar a ser arbitrariamente
     complejo, pero es sólo un juguete en lo que respecta a la comprensión del
     lenguaje real. La comprensión real del lenguaje natural por ordenador
     requiere una elaborada mezcla de análisis sintáctico e interpretación del
     significado. Por otro lado, incluso los analizadores de juguete pueden ser
     útiles para soportar lenguajes de comandos flexibles para programas tales
     como sistemas de recuperación de
     información. @l(#Winston-1992<>Winston 1992) discute los acercamientos
     computacionales a la comprensión real del lenguaje y también las
     aplicaciones de gramáticas simples a los lenguajes del comando.

#   :: @N(258) :: Although Alyssa's idea works just fine (and is surprisingly
#      simple), the sentences that it generates are a bit boring––they don't
#      sample the possible sentences of this language in a very interesting way.
#      In fact, the grammar is highly recursive in many places, and Alyssa's
#      technique @"(falls into) one of these recursions and gets stuck. See
#      @l(#Exercise 4.50) for a way to deal with this.
  :: @N(258) :: Aunque la idea de Alyssa funciona muy bien (y es
     sorprendentemente simple), las frases que genera son un poco aburridas - no
     muestrean las frases posibles de este lenguaje de una manera muy
     interesante. De hecho, la gramática es altamente recursiva en muchos
     lugares, y la técnica de Alyssa @"(cae en) una de estas recursiones y se
     queda atascada. Vea el @l(#Ejercicio 4.50) para una manera
     de lidiar con esto.

#   :: @N(259) :: We chose to implement the lazy evaluator in section @l(#4.2) as a
#      modification of the ordinary metacircular evaluator of section @l(#4.1.1). In
#      contrast, we will base the @c(amb) evaluator on the analyzing evaluator of
#      @l(#4.1.7), because the execution procedures in that evaluator provide a
#      convenient framework for implementing backtracking.
  :: @N(259) :: Elegimos implementar el evaluador perezoso en la seccion @l(#4.2) como
     una modificación del evaluador metacircular ordinario de
     @l(#4.1.1). En contraste, @c(amb) basaremos al evaluador en el
     evaluador de análisis de la seccion @l(#4.1.7), porque los procedimientos de
     ejecución en ese evaluador proporcionan un marco conveniente para
     implementar la retrotracción.

#   :: @N(260) :: We assume that the evaluator supports @c(let) (see @l(#Exercise
#      4.22)), which we have used in our nondeterministic programs.
  :: @N(260) :: Suponemos que el evaluador apoya @c(let)(véase el
     @l(#Ejercicio 4.22) ), que hemos utilizado en nuestros
     programas no deterministas.

#   :: @N(261) :: We didn't worry about undoing definitions, since we can assume
#      that internal definitions are scanned out (section @l(#4.1.6)).
  :: @N(261) :: No nos preocupamos por deshacer las definiciones, ya que podemos
     suponer que las definiciones internas son escaneadas (seccion @l(#4.1.6)).

#   :: @N(262) :: Logic programming has grown out of a long history of research in
#      automatic theorem proving. Early theorem-proving programs could accomplish
#      very little, because they exhaustively searched the space of possible
#      proofs. The major breakthrough that made such a search plausible was the
#      discovery in the early 1960s of the @e(unification algorithm) and the
#      @e(resolution principle) (@l(#Robinson 1965)). Resolution was used, for
#      example, by @l[#Green and Raphael (1968)] (see also @l(#Green 1969)) as the
#      basis for a deductive question-answering system. During most of this
#      period, researchers concentrated on algorithms that are guaranteed to find
#      a proof if one exists. Such algorithms were difficult to control and to
#      direct toward a proof. @l[#Hewitt (1969)] recognized the possibility of
#      merging the control structure of a programming language with the operations
#      of a logic-manipulation system, leading to the work in automatic search
#      mentioned in section @l(#4.3.1) (@n(250<>Footnote 250)). At the same time that this
#      was being done, Colmerauer, in Marseille, was developing rule-based systems
#      for manipulating natural language (see @l(#Colmerauer et al. 1973)). He
#      invented a programming language called Prolog for representing those
#      rules. @l[#Kowalski (1973; 1979)], in Edinburgh, recognized that execution
#      of a Prolog program could be interpreted as proving theorems (using a proof
#      technique called linear Horn-clause resolution). The merging of the last
#      two strands led to the logic-programming movement. Thus, in assigning
#      credit for the development of logic programming, the French can point to
#      Prolog's genesis at the University of Marseille, while the British can
#      highlight the work at the University of Edinburgh. According to people at
#      @A(MIT), logic programming was developed by these groups in an attempt to
#      figure out what Hewitt was talking about in his brilliant but impenetrable
#      Ph.D. thesis. For a history of logic programming, see @l(#Robinson 1983).
  :: @N(262) :: La programación lógica ha surgido de una larga historia de
     investigación en la demostración automática de teoremas. Los primeros
     programas de demostración de teoremas podrían lograr muy poco, porque
     exhaustivamente buscaron el espacio de posibles pruebas. El descubrimiento
     principal que hizo tal búsqueda plausible era el descubrimiento en los años
     60 del @e(algoritmo) de la @e(unificación) y del @e(principio de) la
     @e(resolución) (@l(#Robinson-1965<>Robinson 1965) ). La resolución fue
     utilizada, por ejemplo, por @l(#Green-and-Raphael-(1968)<>Green y Raphael
     (1968)) (véase también @l(#Green-1969<>Green 1969) ) como base para un
     sistema deductivo de preguntas y respuestas. Durante la mayor parte de este
     período, los investigadores se concentraron en algoritmos que están
     garantizados para encontrar una prueba si existe. Tales algoritmos eran
     difíciles de controlar y dirigir hacia una
     prueba. @l(#Hewitt-(1969)<>Hewitt (1969)) reconoció la posibilidad de
     fusionar la estructura de control de un lenguaje de programación con las
     operaciones de un sistema de manipulación lógica, que conduce al trabajo en
     búsqueda automática mencionado en la seccion @l(#4.3.1) (@n(250<>Nota 250) ). Al mismo tiempo que esto se hacía, Colmerauer, en
     Marsella, estaba desarrollando sistemas basados en reglas para manipular el
     lenguaje natural (véase @l(#Colmerauer-et-al.-1973<>Colmerauer et
     al., 1973) ). Él inventó un lenguaje de programación llamado Prolog para
     representar esas reglas. @l(#Kowalski-(1973;-1979)<>Kowalski (1973, 1979)),
     en Edimburgo, reconoció que la ejecución de un programa de Prolog podría
     ser interpretada como teorías de prueba (usando una técnica de prueba
     llamada resolución de cláusula de Clase lineal). La fusión de las dos
     últimas hebras condujo al movimiento de la lógica-programación. Así, al
     asignar crédito para el desarrollo de la programación lógica, los franceses
     pueden apuntar a la génesis de Prolog en la Universidad de Marsella,
     mientras que los británicos pueden destacar el trabajo en la Universidad de
     Edimburgo. @A(Según la gente del MIT), la programación lógica fue
     desarrollada por estos grupos en un intento de averiguar lo que Hewitt
     estaba hablando en su brillante pero impenetrable Ph.D. tesis. Para una
     historia de programación lógica, véase @l(#Robinson-1983<>Robinson
     1983). La lógica de la programación fue desarrollado por estos grupos en un
     intento de averiguar lo que Hewitt estaba hablando en su brillante pero
     impenetrable Ph.D. tesis. @l(#Robinson-1983<>Para una historia de
     programación lógica, véase Robinson 1983). La lógica de la programación fue
     desarrollado por estos grupos en un intento de averiguar lo que Hewitt
     estaba hablando en su brillante pero impenetrable
     Ph.D. tesis. @l(#Robinson-1983<>Para una historia de programación lógica,
     véase Robinson 1983).

#   :: @N(263) :: To see the correspondence between the rules and the procedure,
#      let @c(x) in the procedure (where @c(x) is nonempty) correspond to @c[(cons
#      u v)] in the rule. Then @c(z) in the rule corresponds to the @c(append) of
#      @c[(cdr x)] and @c(y).
  :: @N(263) :: Para ver la correspondencia entre las reglas y el procedimiento,
     deje @c(x) en el procedimiento (donde @c(x) es no vacío) corresponden a
     @c[(cons u v)] en la regla. Entonces @c(z) en la regla corresponde al
     @c(append) de @c[(cdr x)] y @c(y).

#   :: @N(264) :: This certainly does not relieve the user of the entire problem
#      of how to compute the answer. There are many different mathematically
#      equivalent sets of rules for formulating the @c(append) relation, only some
#      of which can be turned into effective devices for computing in any
#      direction.  In addition, sometimes @"(what is) information gives no clue
#      @"(how to) compute an answer. For example, consider the problem of
#      computing the @m(y) such that @m(y² = x).
  :: @N(264) :: Esto ciertamente no alivia al usuario de todo el problema de
     cómo calcular la respuesta. Hay muchos diferentes conjuntos de reglas
     matemáticamente equivalentes para formular la @c(append) relación, sólo
     algunos de los cuales pueden convertirse en dispositivos eficaces para
     calcular en cualquier dirección. Además, a veces @"(lo que es) información
     no da idea de @"(cómo) calcular una respuesta. Por ejemplo, considere el
     problema de calcular el @m(y) tal que @m(y2 = x).

#   :: @N(265) :: Interest in logic programming peaked during the early 80s when
#      the Japanese government began an ambitious project aimed at building
#      superfast computers optimized to run logic programming languages. The speed
#      of such computers was to be measured in LIPS (Logical Inferences Per
#      Second) rather than the usual FLOPS (FLoating-point Operations Per
#      Second). Although the project succeeded in developing hardware and software
#      as originally planned, the international computer industry moved in a
#      different direction.  See @l(#Feigenbaum and Shrobe 1993) for an overview
#      evaluation of the Japanese project. The logic programming community has
#      also moved on to consider relational programming based on techniques other
#      than simple pattern matching, such as the ability to deal with numerical
#      constraints such as the ones illustrated in the constraint-propagation
#      system of section @l(#3.3.5).
  :: @N(265) :: El interés en la programación lógica alcanzó su punto máximo a
     principios de los años 80 cuando el gobierno japonés comenzó un ambicioso
     proyecto dirigido a construir computadoras súper optimizadas para ejecutar
     lenguajes de programación lógica. La velocidad de estos ordenadores se
     mediría en LIPS (Logical Inferences Per Second) en lugar de los FLOPS
     habituales (FLoating-point Operations Per Second). Aunque el proyecto logró
     desarrollar hardware y software como se había planeado originalmente, la
     industria informática internacional se movió en una dirección
     diferente. Vea @l(#Feigenbaum-and-Shrobe-1993<>Feigenbaum y Shrobe 1993)
     para una evaluación general del proyecto japonés. La comunidad de
     programación lógica también ha pasado a considerar la programación
     relacional basada en técnicas distintas de la simple correspondencia de
     patrones,@l(#3.3.5)

#   :: @N(266) :: This uses the dotted-tail notation introduced in @l(#Exercise
#      2.20).
  :: @N(266) :: Esto utiliza la notación de cola punteada introducida en el
     @l(#Ejercicio 2.20).

#   :: @N(267) :: Actually, this description of @c(not) is valid only for simple
#      cases. The real behavior of @c(not) is more complex. We will examine
#      @c(not)'s peculiarities in section @l(#4.4.2) and @l(#4.4.3).
  :: @N(267) :: En realidad, esta descripción de @c(not) es válida sólo para
     casos simples. El comportamiento real de @c(not) es más
     complejo. Examinaremos @c(not) las peculiaridades de la seccion @l(#4.4.2) y
     @l(#4.4.3).

#   :: @N(268) :: @c(Lisp-value) should be used only to perform an operation not
#      provided in the query language. In particular, it should not be used to
#      test equality (since that is what the matching in the query language is
#      designed to do) or inequality (since that can be done with the @c(same)
#      rule shown below).
  :: @N(268) :: @c(Lisp-value) Debe utilizarse únicamente para realizar una
     operación que no se proporciona en el lenguaje de consulta. En particular,
     no debe usarse para probar la igualdad (ya que eso es lo que la
     correspondencia en el lenguaje de consulta está diseñado para hacer) o la
     desigualdad (ya que se puede hacer con la @c(same) regla que se muestra a
     continuación).

#   :: @N(269) :: Notice that we do not need @c(same) in order to make two things
#      be the same: We just use the same pattern variable for each––in effect, we
#      have one thing instead of two things in the first place. For example, see
#      @c(?town) in the @c(lives-near) rule and @c(?middle-manager) in the
#      @c(wheel) rule below. @c(Same) is useful when we want to force two things
#      to be different, such as @c(?person-1) and @c(?person-2) in the
#      @c(lives-near) rule. Although using the same pattern variable in two parts
#      of a query forces the same value to appear in both places, using different
#      pattern variables does not force different values to appear. (The values
#      assigned to different pattern variables may be the same or different.)
  :: @N(269) :: Observe que no necesitamos @c(same) para hacer que dos cosas
     sean las mismas: Simplemente usamos la misma variable de patrón para cada
     uno - en efecto, tenemos una cosa en lugar de dos cosas en primer
     lugar. Por ejemplo, vea @c(?town) en la @c(lives-near) regla y
     @c(?middle-manager) en la @c(wheel) regla de abajo. @c(Same) Es útil cuando
     queremos obligar a dos cosas a ser diferentes, como @c(?person-1) y
     @c(?person-2) en la @c(lives-near) regla. Aunque el uso de la misma
     variable de patrón en dos partes de una consulta obliga a que aparezca el
     mismo valor en ambos lugares, el uso de diferentes variables de patrón no
     obliga a que aparezcan valores diferentes. (Los valores asignados a
     diferentes variables de patrón pueden ser iguales o diferentes.)

#   :: @N(270) :: We will also allow rules without bodies, as in @c(same), and we
#      will interpret such a rule to mean that the rule conclusion is satisfied by
#      any values of the variables.
  :: @N(270) :: También permitiremos reglas sin cuerpos, como en @c(same), y
     interpretaremos tal regla para significar que la conclusión de la regla es
     satisfecha por cualquier valor de las variables.

#   :: @N(271) :: Because matching is generally very expensive, we would like to
#      avoid applying the full matcher to every element of the data base. This is
#      usually arranged by breaking up the process into a fast, coarse match and
#      the final match. The coarse match filters the data base to produce a small
#      set of candidates for the final match. With care, we can arrange our data
#      base so that some of the work of coarse matching can be done when the data
#      base is constructed rather then when we want to select the candidates. This
#      is called @e(indexing) the data base. There is a vast technology built
#      around data-base-indexing schemes. Our implementation, described in
#      @l(#4.4.4), contains a simple-minded form of such an optimization.
  :: @N(271) :: Debido a que la coincidencia es generalmente muy costosa, nos
     gustaría evitar aplicar el combinador completo a cada elemento de la base
     de datos. Esto se arregla generalmente dividiendo el proceso en un fósforo
     rápido, grueso y el fósforo final. La coincidencia aproximada filtra la
     base de datos para producir un pequeño conjunto de candidatos para el
     partido final. Con cuidado, podemos organizar nuestra base de datos para
     que parte del trabajo de coincidencia gruesa se pueda hacer cuando se
     construye la base de datos en lugar de cuando queremos seleccionar a los
     candidatos. Esto se llama @e(indexar) la base de datos. Existe una vasta
     tecnología basada en esquemas de indexación de bases de datos. Nuestra
     implementación, descrita en la seccion @l(#4.4.4), contiene una forma simplista
     de tal optimización.

#   :: @N(272) :: But this kind of exponential explosion is not common in @c(and)
#      queries because the added conditions tend to reduce rather than expand the
#      number of frames produced.
  :: @N(272) :: Pero este tipo de explosión exponencial no es común en las
     @c(and) consultas porque las condiciones añadidas tienden a reducir en
     lugar de expandir el número de fotogramas producidos.

#   :: @N(273) :: There is a large literature on data-base-management systems that
#      is concerned with how to handle complex queries efficiently.
  :: @N(273) :: Hay una gran literatura sobre sistemas de gestión de bases de
     datos que se ocupa de cómo manejar consultas complejas de manera eficiente.

#   :: @N(274) :: There is a subtle difference between this filter implementation
#      of @c(not) and the usual meaning of @c(not) in mathematical logic. See
#      @l(#4.4.3).
  :: @N(274) :: Hay una sutil diferencia entre esta aplicación de filtro @c(not)
     y el significado usual @c(not) en la lógica matemática. Véase
     @l(#4.4.3).

#   :: @N(275) :: In one-sided pattern matching, all the equations that contain
#      pattern variables are explicit and already solved for the unknown (the
#      pattern variable).
  :: @N(275) :: En una coincidencia de patrones unilateral, todas las ecuaciones
     que contienen variables de patrón son explícitas y ya resueltas para lo
     desconocido (la variable de patrón).

#   :: @N(276) :: Another way to think of unification is that it generates the
#      most general pattern that is a specialization of the two input
#      patterns. That is, the unification of @c[(?x a)] and @c[((b ?y) ?z)] is
#      @c[((b ?y) a)], and the unification of @c[(?x a ?y)] and @c[(?y ?z a)],
#      discussed above, is @c[(a a a)]. For our implementation, it is more
#      convenient to think of the result of unification as a frame rather than a
#      pattern.
  :: @N(276) :: Otra forma de pensar en la unificación es que genera el patrón
     más general que es una especialización de los dos patrones de entrada. Es
     decir, la unificación de @c[(?x a)] y @c[((b ?y) ?z)] es @c[((b ?y) a)], y
     la unificación de @c[(?x a ?y)] y @c[(?y ?z a)], discutido arriba, es @c[(a
     a a)]. Para nuestra implementación, es más conveniente pensar en el
     resultado de la unificación como un marco que como un patrón.

#   :: @N(277) :: Since unification is a generalization of matching, we could
#      simplify the system by using the unifier to produce both streams. Treating
#      the easy case with the simple matcher, however, illustrates how matching
#      (as opposed to full-blown unification) can be useful in its own right.
  :: @N(277) :: Dado que la unificación es una generalización de coincidencia,
     podríamos simplificar el sistema utilizando el unificador para producir
     ambos flujos. Sin embargo, tratar el caso fácil con el simple encuadernador
     ilustra cómo la coincidencia (en oposición a la unificación completa) puede
     ser útil por derecho propio.

#   :: @N(278) :: The reason we use streams (rather than lists) of frames is that
#      the recursive application of rules can generate infinite numbers of values
#      that satisfy a query. The delayed evaluation embodied in streams is crucial
#      here: The system will print responses one by one as they are generated,
#      regardless of whether there are a finite or infinite number of responses.
  :: @N(278) :: La razón por la que utilizamos flujos (en lugar de listas) de
     tramas es que la aplicación recursiva de reglas puede generar infinitos
     números de valores que satisfacen una consulta. La evaluación retardada
     incorporada en corrientes es crucial aquí: El sistema imprimirá respuestas
     una por una a medida que se generan, independientemente de si hay un número
     finito o infinito de respuestas.

#   :: @N(279) :: That a particular method of inference is legitimate is not a
#      trivial assertion. One must prove that if one starts with true premises,
#      only true conclusions can be derived. The method of inference represented
#      by rule applications is @e(modus ponens), the familiar method of inference
#      that says that if @m(a) is true and @e(A implies B) is true, then we may
#      conclude that @m(B) is true.
  :: @N(279) :: Que un método particular de inferencia es legítimo no es una
     afirmación trivial. Uno debe probar que si uno empieza con premisas
     verdaderas, sólo se pueden derivar conclusiones verdaderas. El método de
     inferencia representado por las aplicaciones de reglas es @e(modus ponens),
     el método familiar de inferencia que dice que si @m(a) es verdadero y @e(A
     implica B) es verdadero, entonces podemos concluir que @m(B) es verdadero.

#   :: @N(280) :: We must qualify this statement by agreeing that, in speaking of
#      the @"(inference) accomplished by a logic program, we assume that the
#      computation terminates.  Unfortunately, even this qualified statement is
#      false for our implementation of the query language (and also false for
#      programs in Prolog and most other current logic programming languages)
#      because of our use of @c(not) and @c(lisp-value). As we will describe
#      below, the @c(not) implemented in the query language is not always
#      consistent with the @c(not) of mathematical logic, and @c(lisp-value)
#      introduces additional complications. We could implement a language
#      consistent with mathematical logic by simply removing @c(not) and
#      @c(lisp-value) from the language and agreeing to write programs using only
#      simple queries, @c(and), and @c(or). However, this would greatly restrict
#      the expressive power of the language. One of the major concerns of research
#      in logic programming is to find ways to achieve more consistency with
#      mathematical logic without unduly sacrificing expressive power.
  :: @N(280) :: Debemos calificar esta afirmación aceptando que, al hablar de la
     @"(inferencia) lograda por un programa lógico, asumimos que el cálculo
     termina. Desafortunadamente, incluso esta declaración calificada es falsa
     para nuestra implementación del lenguaje de consulta (y también falsa para
     programas en Prolog y la mayoría de los otros lenguajes de programación
     lógicos actuales) debido a nuestro uso de @c(not) y @c(lisp-value). Como
     describiremos a continuación, el @c(not) implementado en el lenguaje de
     consulta no siempre es consistente con el @c(not) de la lógica matemática,
     e @c(lisp-value) introduce complicaciones adicionales. Podríamos
     implementar un lenguaje consistente con la lógica matemática simplemente
     eliminando @c(not) y @c(lisp-value) del lenguaje y acordando escribir
     programas usando solo consultas simples @c(and), y @c(or). Sin embargo,
     Esto restringiría en gran medida el poder expresivo del lenguaje. Una de
     las principales preocupaciones de la investigación en la programación
     lógica es encontrar maneras de lograr más consistencia con la lógica
     matemática sin sacrificar excesivamente el poder expresivo.

#   :: @N(281) :: This is not a problem of the logic but one of the procedural
#      interpretation of the logic provided by our interpreter. We could write an
#      interpreter that would not fall into a loop here. For example, we could
#      enumerate all the proofs derivable from our assertions and our rules in a
#      breadth-first rather than a depth-first order. However, such a system makes
#      it more difficult to take advantage of the order of deductions in our
#      programs.  One attempt to build sophisticated control into such a program
#      is described in @l(#deKleer et al. 1977). Another technique, which does not
#      lead to such serious control problems, is to put in special knowledge, such
#      as detectors for particular kinds of loops (@l(#Exercise 4.67)). However,
#      there can be no general scheme for reliably preventing a system from going
#      down infinite paths in performing deductions. Imagine a diabolical rule of
#      the form @"(To show @m[P(x)] is true, show that @m[P(ƒ(x))] is true,) for
#      some suitably chosen function @m(ƒ).
  :: @N(281) :: Esto no es un problema de la lógica, sino uno de la
     interpretación procedimental de la lógica proporcionada por nuestro
     intérprete. Podríamos escribir un intérprete que no caería en un bucle
     aquí. Por ejemplo, podríamos enumerar todas las pruebas derivables de
     nuestras aserciones y nuestras reglas en un orden de ancho en lugar de un
     primer orden de profundidad. Sin embargo, este sistema hace más difícil
     aprovechar el orden de las deducciones en nuestros programas. Un intento de
     construir un control sofisticado en tal programa se describe en
     @l(#deKleer-et-al.-1977<>deKleer et al. 1977). Otra técnica, que no conduce
     a problemas de control tan graves, consiste en poner en conocimiento
     especial, como los detectores para tipos particulares de bucles (
     @l(#Ejercicio 4.67) ). Sin embargo, No puede haber un
     esquema general para evitar de manera fiable que un sistema pase por sendas
     infinitas al realizar deducciones. @"(Imaginemos una regla diabólica de la
     forma Para demostrar que @m(P (x)) es verdadera, demostrar que @m(P (ƒ
     (x))) es verdadera,) para alguna función @m(ƒ) apropiadamente escogida.

#   :: @N(282) :: Consider the query @c[(not (baseball-fan (Bitdiddle Ben)))]. The
#      system finds that @c[(baseball-fan (Bitdiddle Ben))] is not in the data
#      base, so the empty frame does not satisfy the pattern and is not filtered
#      out of the initial stream of frames. The result of the query is thus the
#      empty frame, which is used to instantiate the input query to produce
#      @c[(not (baseball-fan (Bitdiddle Ben)))].
  :: @N(282) :: Considere la consulta @c[(not (baseball-fan (Bitdiddle
     Ben)))]. El sistema encuentra que @c[(baseball-fan (Bitdiddle Ben))] no
     está en la base de datos, por lo que el marco vacío no satisface el patrón
     y no se filtra fuera del flujo inicial de marcos. El resultado de la
     consulta es, por tanto, el cuadro vacío, que se utiliza para instanciar la
     consulta de entrada para producir @c[(not (baseball-fan (Bitdiddle Ben)))].

#   :: @N(283) :: A discussion and justification of this treatment of @c(not) can
#      be found in the article by @l[#Clark (1978)].
  :: @N(283) :: Una discusión y justificación de este tratamiento @c(not) se
     puede encontrar en el artículo de @l(#Clark-(1978)<>Clark (1978)).

#   :: @N(284) :: In general, unifying @c(?y) with an expression involving @c(?y)
#      would require our being able to find a fixed point of the equation @c[?y] =
#      @c[(expression involving ?y)]. It is sometimes possible to syntactically
#      form an expression that appears to be the solution. For example, @c(?y) =
#      @c[(f ?y)] seems to have the fixed point @c[(f (f (f …  )))], which we can
#      produce by beginning with the expression @c[(f ?y)] and repeatedly
#      substituting @c[(f ?y)] for @c(?y). Unfortunately, not every such equation
#      has a meaningful fixed point. The issues that arise here are similar to the
#      issues of manipulating infinite series in mathematics. For example, we know
#      that 2 is the solution to the equation @m(y = 1 + y / 2). Beginning with
#      the expression @m(1 + y / 2) and repeatedly substituting @m(1 + y / 2) for
#      @m(y) gives
  :: @N(284) :: En general, la unificación @c(?y) con una expresión implica
     @c(?y) requerir que podamos encontrar un punto fijo de la ecuación @c(?y)=
     @c[(expression involving ?y)]. A veces es posible formar sintácticamente
     una expresión que parece ser la solución. Por ejemplo, @c(?y)= @c[(f ?y)]
     parece tener el punto fijo @c[(f (f (f …  )))], que podemos producir
     empezando por la expresión @c[(f ?y)] y sustituyendo repetidamente @c[(f
     ?y)] por @c(?y). Desafortunadamente, no todas estas ecuaciones tienen un
     punto fijo significativo. Los problemas que surgen aquí son similares a los
     problemas de manipulación de series infinitas en matemáticas. Por ejemplo,
     sabemos que 2 es la solución a la ecuación @m(y = 1 + y / 2) .@m()@m()@m()

#      ..example >
#        2 = y = 1 + y/2 = 1 + (1 + y/2)/2 = 1 + 1/2 + y/4 = ⋯
#      < example..
     ..example >
       2 = y = 1 + y/2 = 1 + (1 + y/2)/2 = 1 + 1/2 + y/4 = ⋯
     < example..

#      which leads to
     lo que lleva a

#      ..example >
#        2 = 1 + 1/2 + 1/4 + 1/8 + ⋯
#      < example..
     ..example >
       2 = 1 + 1/2 + 1/4 + 1/8 + ⋯
     < example..

#      However, if we try the same manipulation beginning with the observation
#      that @m(−1) is the solution to the equation @m(y = 1 + 2y), we obtain
     Sin embargo, si intentamos la misma manipulación empezando con la
     observación de que @m(-1) es la solución a la ecuación @m(y = 1 + 2y),
     obtenemos

#     ..example >
#       -1 = y = 1 + 2y = 1 + 2(1 + 2y) = 1 + 2 + 4y = ⋯
#     < example..
    ..example >
      -1 = y = 1 + 2y = 1 + 2(1 + 2y) = 1 + 2 + 4y = ⋯
    < example..

#      which leads to
     lo que lleva a

#      ..example >
#        -1 = 1 + 2 + 4 + 8 + ⋯
#      < example..
     ..example >
       -1 = 1 + 2 + 4 + 8 + ⋯
     < example..

#      Although the formal manipulations used in deriving these two equations are
#      identical, the first result is a valid assertion about infinite series but
#      the second is not. Similarly, for our unification results, reasoning with
#      an arbitrary syntactically constructed expression may lead to errors.
     Aunque las manipulaciones formales utilizadas para derivar estas dos
     ecuaciones son idénticas, el primer resultado es una afirmación válida
     sobre series infinitas, pero la segunda no. De manera similar, para
     nuestros resultados de unificación, el razonamiento con una expresión
     arbitraria sintácticamente construida puede conducir a errores.

#   :: @N(285) :: Most Lisp systems give the user the ability to modify the
#      ordinary @c(read) procedure to perform such transformations by defining
#      @e(reader macro characters). Quoted expressions are already handled in this
#      way: The reader automatically translates @c('expression) into @c[(quote
#      expression)] before the evaluator sees it. We could arrange for
#      @c(?expression) to be transformed into @c[(? expression)] in the same way;
#      however, for the sake of clarity we have included the transformation
#      procedure here explicitly.
  :: @N(285) :: La mayoría de los sistemas Lisp le dan al usuario la capacidad
     de modificar el procedimiento @c(read) ordinario para realizar tales
     transformaciones definiendo @e(los caracteres macro del
     lector). Expresiones citadas ya se manejan de esta manera: El lector se
     traduce automáticamente @c('expression) en @c[(quote expression)] antes de
     que el evaluador lo ve. Podríamos arreglar para @c(?expression) ser
     transformados @c[(? expression)] de la misma manera; Sin embargo, en aras
     de la claridad hemos incluido el procedimiento de transformación aquí
     explícitamente.

#      @c(Expand-question-mark) and @c(contract-question-mark) use several
#      procedures with @c(string) in their names. These are Scheme primitives.
     @c(Expand-question-mark) Y @c(contract-question-mark) utilizar varios
     procedimientos con @c(string) sus nombres. Estas son primitivas del
     Scheme.

#   :: @N(286) :: This assumption glosses over a great deal of complexity. Usually
#      a large portion of the implementation of a Lisp system is dedicated to
#      making reading and printing work.
  :: @N(286) :: Este supuesto supera una gran complejidad. Por lo general, una
     gran parte de la implementación de un sistema Lisp se dedica a hacer que la
     lectura y la impresión funcionen.

#   :: @N(287) :: One might argue that we don't need to save the old @c(n); after
#      we decrement it and solve the subproblem, we could simply increment it to
#      recover the old value. Although this strategy works for factorial, it
#      cannot work in general, since the old value of a register cannot always be
#      computed from the new one.
  :: @N(287) :: Uno podría argumentar que no necesitamos salvar lo viejo @c(n);
     Después de decrementarlo y resolver el subproblema, podríamos simplemente
     incrementarlo para recuperar el valor antiguo. Aunque esta estrategia
     funciona para factorial, no puede funcionar en general, ya que el valor
     antiguo de un registro no siempre se puede calcular a partir del nuevo.

#   :: @N(288) :: in section @l(#5.3) we will see how to implement a stack in terms of
#      more primitive operations.
  :: @N(288) :: en la seccion @l(#5.3) veremos cómo implementar una pila en términos
     de operaciones más primitivas.

#   :: @N(289) :: Using the @c(receive) procedure here is a way to get
#      @c(extract-labels) to effectively return two values––@c(labels) and
#      @c(insts)––without explicitly making a compound data structure to hold
#      them. An alternative implementation, which returns an explicit pair of
#      values, is
  :: @N(289) :: Usar el procedimiento @c(receive) aquí es una manera de llegar
     @c(extract-labels) a devolver efectivamente dos valores - @c(labels) y -
     @c(insts) sin hacer explícitamente una estructura de datos compuestos para
     contenerlos. Una implementación alternativa, que devuelve un par explícito
     de valores, es

#      ..src > scheme
#        (define (extract-labels text)
#          (if (null? text)
#              (cons '() '())
#              (let ((result
#                     (extract-labels (cdr text))))
#                (let ((insts (car result))
#                      (labels (cdr result)))
#                  (let ((next-inst (car text)))
#                    (if (symbol? next-inst)
#                        (cons
#                         insts
#                         (cons
#                          (make-label-entry
#                           next-inst insts)
#                          labels))
#                        (cons
#                         (cons
#                          (make-instruction next-inst)
#                          insts)
#                         labels)))))))
#      < src..
     ..src > scheme
       (define (extract-labels text)
         (if (null? text)
             (cons '() '())
             (let ((result
                    (extract-labels (cdr text))))
               (let ((insts (car result))
                     (labels (cdr result)))
                 (let ((next-inst (car text)))
                   (if (symbol? next-inst)
                       (cons
                        insts
                        (cons
                         (make-label-entry
                          next-inst insts)
                         labels))
                       (cons
                        (cons
                         (make-instruction next-inst)
                         insts)
                        labels)))))))
     < src..

#      which would be called by @c(assemble) as follows:
     Que se denominaría @c(assemble) como sigue:

#      ..src > scheme
#        (define (assemble controller-text machine)
#          (let ((result
#                 (extract-labels controller-text)))
#            (let ((insts (car result))
#                  (labels (cdr result)))
#              (update-insts! insts labels machine)
#              insts)))
#      < src..
     ..src > scheme
       (define (assemble controller-text machine)
         (let ((result
                (extract-labels controller-text)))
           (let ((insts (car result))
                 (labels (cdr result)))
             (update-insts! insts labels machine)
             insts)))
     < src..

#      You can consider our use of @c(receive) as demonstrating an elegant way to
#      return multiple values, or simply an excuse to show off a programming
#      trick.  An argument like @c(receive) that is the next procedure to be
#      invoked is called a @"(continuation.)  Recall that we also used
#      continuations to implement the backtracking control structure in the
#      @c(amb) evaluator in section @l(#4.3.3).
     Usted puede considerar nuestro uso de @c(receive) demostrar una forma
     elegante de devolver valores múltiples, o simplemente una excusa para
     mostrar un truco de programación. Un argumento como @c(receive) ese es el
     siguiente procedimiento a ser invocado se llama una @"(continuación. )
     Recordemos que también usamos las continuaciones para implementar la
     estructura de control de retroceso en el @c(amb) evaluador en
     @l(#4.3.3).

#   :: @N(290) :: We could represent memory as lists of items. However, the access
#      time would then not be independent of the index, since accessing the
#      @m(nᵗʰ) element of a list requires @m(n - 1) @c(cdr) operations.
  :: @N(290) :: Podríamos representar la memoria como listas de artículos. Sin
     embargo, el tiempo de acceso no sería independiente del índice, ya que
     acceder al elemento @m(nᵗʰ) de una lista requiere @m(n - 1) @c(cdr)
     operaciones.

#   :: @N(291) :: For completeness, we should specify a @c(make-vector) operation
#      that constructs vectors. However, in the present application we will use
#      vectors only to model fixed divisions of the computer memory.
  :: @N(291) :: Para completar, debemos especificar una @c(make-vector)
     operación que construye vectores. Sin embargo, en la presente solicitud
     utilizaremos vectores sólo para modelar divisiones fijas de la memoria del
     ordenador.

#   :: @N(292) :: This is precisely the same @"(tagged data) idea we introduced in
#      @l(#Chapter 2) for dealing with generic operations. Here, however, the data
#      types are included at the primitive machine level rather than constructed
#      through the use of lists.
  :: @N(292) :: Esta es precisamente la misma idea de @"(datos etiquetados) que
     introdujimos en el @l(#Capitulo 2) para tratar con operaciones
     genéricas. Aquí, sin embargo, los tipos de datos se incluyen a nivel de la
     máquina primitiva en lugar de construirse mediante el uso de listas.

#   :: @N(293) :: Type information may be encoded in a variety of ways, depending
#      on the details of the machine on which the Lisp system is to be
#      implemented. The execution efficiency of Lisp programs will be strongly
#      dependent on how cleverly this choice is made, but it is difficult to
#      formulate general design rules for good choices. The most straightforward
#      way to implement typed pointers is to allocate a fixed set of bits in each
#      pointer to be a @e(type field) that encodes the data type.  Important
#      questions to be addressed in designing such a representation include the
#      following: How many type bits are required?  How large must the vector
#      indices be?  How efficiently can the primitive machine instructions be used
#      to manipulate the type fields of pointers?  Machines that include special
#      hardware for the efficient handling of type fields are said to have
#      @e(tagged architectures).
  :: @N(293) :: La información de tipo puede codificarse de varias maneras,
     dependiendo de los detalles de la máquina en la que se va a implementar el
     sistema Lisp. La eficiencia de ejecución de los programas Lisp dependerá en
     gran medida de la habilidad con la que se haga esta elección, pero es
     difícil formular reglas generales de diseño para las buenas elecciones. La
     forma más sencilla de implementar punteros tipados es asignar un conjunto
     fijo de bits en cada puntero para que sea un @e(campo de tipo) que
     codifique el tipo de datos. Entre las cuestiones importantes que se deben
     abordar al diseñar dicha representación se incluyen las siguientes:
     ¿Cuántos bits de tipo son necesarios? ¿Cuán grande deben ser los índices
     vectoriales? ¿Qué tan eficientemente pueden usarse las instrucciones de la
     máquina primitiva para manipular los campos de tipos de punteros? @e(Se
     dice que las máquinas que incluyen hardware especial para el manejo
     eficiente de campos de tipo tienen arquitecturas etiquetadas).

#   :: @N(294) :: This decision on the representation of numbers determines
#      whether @c(eq?), which tests equality of pointers, can be used to test for
#      equality of numbers. If the pointer contains the number itself, then equal
#      numbers will have the same pointer. But if the pointer contains the index
#      of a location where the number is stored, equal numbers will be guaranteed
#      to have equal pointers only if we are careful never to store the same
#      number in more than one location.
  :: @N(294) :: Esta decisión sobre la representación de números determina si
     @c(eq?), que prueba la igualdad de punteros, se puede usar para probar la
     igualdad de números. Si el puntero contiene el número en sí, los números
     iguales tendrán el mismo puntero. Pero si el puntero contiene el índice de
     una ubicación donde se almacena el número, se garantizará que los números
     iguales tengan punteros iguales sólo si tenemos cuidado de no almacenar
     nunca el mismo número en más de una ubicación.

#   :: @N(295) :: This is just like writing a number as a sequence of digits,
#      except that each @"(digit) is a number between 0 and the largest number
#      that can be stored in a single pointer.
  :: @N(295) :: Esto es como escribir un número como una secuencia de dígitos,
     excepto que cada @"(dígito) es un número entre 0 y el número más grande que
     se puede almacenar en un solo puntero.

#   :: @N(296) :: There are other ways of finding free storage. For example, we
#      could link together all the unused pairs into a @e(free list). Our free
#      locations are consecutive (and hence can be accessed by incrementing a
#      pointer) because we are using a compacting garbage collector, as we will
#      see in section @l(#5.3.2).
  :: @N(296) :: Hay otras maneras de encontrar almacenamiento gratuito. Por
     ejemplo, podríamos enlazar todos los pares sin usar en una @e(lista
     libre). Nuestras ubicaciones libres son consecutivas (y por lo tanto se
     puede acceder al incrementar un puntero) porque estamos usando un
     recolector de recolección de compactación, como veremos en
     @l(#5.3.2).

#   :: @N(297) :: This is essentially the implementation of @c(cons) in terms of
#      @c(set-car!) and @c(set-cdr!), as described in section @l(#3.3.1). The operation
#      @c(get-new-pair) used in that implementation is realized here by the
#      @c(free) pointer.
  :: @N(297) :: Esto es esencialmente la implementación @c(cons) en términos de
     @c(set-car!) y @c(set-cdr!), como se describe en la seccion @l(#3.3.1). La
     operación @c(get-new-pair) utilizada en esa implementación se realiza aquí
     por el @c(free) puntero.

#   :: @N(298) :: This may not be true eventually, because memories may get large
#      enough so that it would be impossible to run out of free memory in the
#      lifetime of the computer. For example, there are about @m(3⋅10¹³)
#      microseconds in a year, so if we were to @c(cons) once per microsecond we
#      would need about @m(10¹⁵) cells of memory to build a machine that could
#      operate for 30 years without running out of memory. That much memory seems
#      absurdly large by today's standards, but it is not physically impossible.
#      On the other hand, processors are getting faster and a future computer may
#      have large numbers of processors operating in parallel on a single memory,
#      so it may be possible to use up memory much faster than we have postulated.
  :: @N(298) :: Esto puede no ser cierto con el tiempo, porque los recuerdos
     pueden ser lo suficientemente grandes para que sería imposible quedarse sin
     memoria libre en la vida de la computadora. Por ejemplo, hay
     aproximadamente @m(3⋅10¹³) microsegundos en un año, así que si fuéramos a
     @c(cons) una vez por cada microsegundo necesitaríamos alrededor de @m(10¹⁵)
     células de memoria para construir una máquina que podría funcionar durante
     30 años sin quedarse sin memoria. Esa cantidad de memoria parece
     absurdamente grande para los estándares actuales, pero no es físicamente
     imposible. Por otro lado, los procesadores se están volviendo más rápidos y
     un futuro ordenador puede tener un gran número de procesadores que
     funcionan en paralelo en una sola memoria, por lo que puede ser posible
     utilizar la memoria mucho más rápido de lo que hemos postulado.

#   :: @N(299) :: We assume here that the stack is represented as a list as
#      described in section @l(#5.3.1), so that items on the stack are accessible via the
#      pointer in the stack register.
  :: @N(299) :: Suponemos aquí que la pila se representa como una lista como se
     describe en la seccion @l(#5.3.1), de modo que los elementos de la pila son
     accesibles a través del puntero en el registro de la pila.

#   :: @N(300) :: This idea was invented and first implemented by Minsky, as part
#      of the implementation of Lisp for the PDP-1 at the @A(MIT) Research
#      Laboratory of Electronics. It was further developed by @l[#Fenichel and
#      Yochelson (1969)] for use in the Lisp implementation for the Multics
#      time-sharing system. Later, @l[#Baker (1978)] developed a @"(real-time)
#      version of the method, which does not require the computation to stop
#      during garbage collection. Baker's idea was extended by Hewitt, Lieberman,
#      and Moon (see @l(#Lieberman and Hewitt 1983)) to take advantage of the fact
#      that some structure is more volatile and other structure is more permanent.
  :: @N(300) :: Esta idea fue inventada e implementada por primera vez por
     Minsky, como parte de la implementación de Lisp para el PDP-1 en el @A(MIT)
     Research Laboratory of Electronics. Fue desarrollado por
     @l(#Fenichel-and-Yochelson-(1969)<>Fenichel y Yochelson (1969)) para su uso
     en la implementación de Lisp para el sistema de tiempo compartido
     Multics. Más tarde, @l(#Baker-(1978)<>Baker (1978)) desarrolló una versión
     en @"(tiempo real) del método, que no requiere el cálculo para detenerse
     durante la recolección de basura. La idea de Baker fue ampliada por Hewitt,
     Lieberman y Moon (ver @l(#Lieberman-and-Hewitt-1983<>Lieberman y
     Hewitt 1983) ) para aprovechar el hecho de que alguna estructura es más
     volátil y otra estructura es más permanente.

#      An alternative commonly used garbage-collection technique is the
#      @e(mark-sweep) method. This consists of tracing all the structure
#      accessible from the machine registers and marking each pair we reach. We
#      then scan all of memory, and any location that is unmarked is @"(swept up)
#      as garbage and made available for reuse. A full discussion of the
#      mark-sweep method can be found in @l(#Allen 1978).
  Una técnica de recolección de basura comúnmente usada es el método
  @e(mark-sweep). Consiste en rastrear toda la estructura accesible desde los
  registros de la máquina y marcar cada par que alcanzamos. A continuación,
  analizar toda la memoria, y cualquier ubicación que no está marcada es
  @"(barrido) como basura y se pone a disposición para su reutilización. Una
  discusión completa del método mark-sweep se puede encontrar en
  @l(#Allen-1978<>Allen 1978).

#      The Minsky-Fenichel-Yochelson algorithm is the dominant algorithm in use
#      for large-memory systems because it examines only the useful part of
#      memory. This is in contrast to mark-sweep, in which the sweep phase must
#      check all of memory. A second advantage of stop-and-copy is that it is a
#      @e(compacting) garbage collector. That is, at the end of the
#      garbage-collection phase the useful data will have been moved to
#      consecutive memory locations, with all garbage pairs compressed out. This
#      can be an extremely important performance consideration in machines with
#      virtual memory, in which accesses to widely separated memory addresses may
#      require extra paging operations.
     El algoritmo de Minsky-Fenichel-Yochelson es el algoritmo dominante en uso
     para sistemas de memoria grande porque examina solamente la parte útil de
     la memoria. Esto es en contraste con mark-sweep, en el que la fase de
     barrido debe comprobar toda la memoria. Una segunda ventaja de
     stop-and-copy es que es un recolector de basura de @e(compactación). Es
     decir, al final de la fase de recolección de basura, los datos útiles se
     habrán movido a posiciones de memoria consecutivas, con todos los pares de
     basura comprimidos. Esto puede ser una consideración de rendimiento
     extremadamente importante en máquinas con memoria virtual, en las que los
     accesos a direcciones de memoria ampliamente separadas pueden requerir
     operaciones de paginación adicionales.

#   :: @N(301) :: This list of registers does not include the registers used by
#      the storage-allocation system––@c(root), @c(the-cars), @c(the-cdrs), and
#      the other registers that will be introduced in this section.
  :: @N(301) :: Esta lista de registros no incluye los registros utilizados por
     el system-- de almacenamiento de la asignación @c(root), @c(the-cars),
     @c(the-cdrs), y los otros registros que serán introducidos en esta sección.

#   :: @N(302) :: The term @e(broken heart) was coined by David Cressey, who wrote
#      a garbage collector for MDL, a dialect of Lisp developed at @A(MIT) during
#      the early 1970s.
  :: @N(302) :: El término @e(corazón roto) fue acuñado por David Cressey, quien
     escribió un recolector de basura para MDL, un dialecto de Lisp desarrollado
     en el @A(MIT) durante la década de 1970.

#   :: @N(303) :: The garbage collector uses the low-level predicate
#      @c(pointer-to-pair?) instead of the list-structure @c(pair?)  operation
#      because in a real system there might be various things that are treated as
#      pairs for garbage-collection purposes. For example, in a Scheme system that
#      conforms to the @A(IEEE) standard a procedure object may be implemented as
#      a special kind of @"(pair) that doesn't satisfy the @c(pair?) predicate.
#      For simulation purposes, @c(pointer-to-pair?) can be implemented as
#      @c(pair?).
  :: @N(303) :: El recolector de basura usa el predicado de bajo nivel en
     @c(pointer-to-pair?) lugar de la @c(pair?)  operación de estructura de
     lista porque en un sistema real puede haber varias cosas que se tratan como
     pares para fines de recolección de basura. Por ejemplo, en un sistema
     Scheme que se ajusta a la norma @A(IEEE), un objeto de procedimiento puede
     implementarse como un tipo especial de @"(par) que no satisface el
     @c(pair?) predicado. Para fines de simulación, @c(pointer-to-pair?) se
     puede implementar como @c(pair?).

#   :: @N(304) :: See @l(#Batali et al. 1982) for more information on the chip and
#      the method by which it was designed.
  :: @N(304) :: Véase @l(#Batali-et-al.-1982<>Batali et al. 1982) para obtener
     más información sobre el chip y el método por el cual fue diseñado.

#   :: @N(305) :: In our controller, the dispatch is written as a sequence of
#      @c(test) and @c(branch) instructions. Alternatively, it could have been
#      written in a data-directed style (and in a real system it probably would
#      have been) to avoid the need to perform sequential tests and to facilitate
#      the definition of new expression types. A machine designed to run Lisp
#      would probably include a @c(dispatch-on-type) instruction that would
#      efficiently execute such data-directed dispatches.
  :: @N(305) :: En nuestro controlador, el despacho se escribe como una
     secuencia de @c(test) e @c(branch) instrucciones. Alternativamente, podría
     haber sido escrito en un estilo dirigido a datos (y en un sistema real
     probablemente habría sido) para evitar la necesidad de realizar pruebas
     secuenciales y facilitar la definición de nuevos tipos de expresión. Una
     máquina diseñada para ejecutar Lisp probablemente incluiría una
     @c(dispatch-on-type) instrucción que ejecutaría de manera eficiente tales
     envíos dirigidos a datos.

#   :: @N(306) :: This is an important but subtle point in translating algorithms
#      from a procedural language, such as Lisp, to a register-machine
#      language. As an alternative to saving only what is needed, we could save
#      all the registers (except @c(val)) before each recursive call. This is
#      called a @e(framed-stack) discipline.  This would work but might save more
#      registers than necessary; this could be an important consideration in a
#      system where stack operations are expensive.  Saving registers whose
#      contents will not be needed later may also hold onto useless data that
#      could otherwise be garbage-collected, freeing space to be reused.
  :: @N(306) :: Este es un punto importante pero sutil en la traducción de
     algoritmos de un lenguaje procedural, como Lisp, a un lenguaje de
     registro-máquina. Como alternativa a guardar sólo lo que se necesita,
     podríamos guardar todos los registros (excepto @c(val)) antes de cada
     llamada recursiva. Esto se llama una disciplina de @e(pila enmarcada). Esto
     funcionaría pero podría ahorrar más registros de lo necesario; Esto podría
     ser una consideración importante en un sistema donde las operaciones de la
     pila son costosas. Guardar registros cuyo contenido no será necesario más
     tarde también puede contener datos inútiles que de otro modo podrían ser
     recolectados de basura, liberando espacio para ser reutilizado.

#   :: @N(307) :: We add to the evaluator data-structure procedures in section @l(#4.1.3)
#      the following two procedures for manipulating argument lists:
  :: @N(307) :: Añadimos a los procedimientos de estructura de datos del
     evaluador en la seccion @l(#4.1.3) los dos procedimientos siguientes para
     manipular listas de argumentos:

#      ..src > scheme
#        (define (empty-arglist) '())
#        (define (adjoin-arg arg arglist)
#          (append arglist (list arg)))
#      < src..
     ..src > scheme
       (define (empty-arglist) '())
       (define (adjoin-arg arg arglist)
         (append arglist (list arg)))
     < src..

#      We also use an additional syntax procedure to test for the last operand in
#      a combination:
     También usamos un procedimiento de sintaxis adicional para probar el último
     operando en una combinación:

#      ..src > scheme
#        (define (last-operand? ops) (null? (cdr ops)))
#      < src..
     ..src > scheme
       (define (last-operand? ops) (null? (cdr ops)))
     < src..

#   :: @N(308) :: The optimization of treating the last operand specially is known
#      as @e(evlis tail recursion) (see @l(#Wand 1980)). We could be somewhat more
#      efficient in the argument evaluation loop if we made evaluation of the
#      first operand a special case too. This would permit us to postpone
#      initializing @c(argl) until after evaluating the first operand, so as to
#      avoid saving @c(argl) in this case. The compiler in section @l(#5.5) performs this
#      optimization. (Compare the @c(construct-arglist) procedure of section @l(#5.5.3).)
  :: @N(308) :: La optimización del tratamiento del último operando se conoce
     especialmente como @e(recursión de cola evlis) (véase
     @l(#Wand-1980<>Wand 1980) ). Podríamos ser algo más eficientes en el bucle
     de evaluación de argumentos si hacíamos que la evaluación del primer
     operando fuera también un caso especial. Esto nos permitiría posponer la
     inicialización @c(argl) hasta después de evaluar el primer operando, para
     evitar el ahorro @c(argl) en este caso. El compilador en la seccion @l(#5.5)
     realiza esta optimización. (Compare el procedimiento @c(construct-arglist)
     de la seccion @l(#5.5.3) .)

#   :: @N(309) :: The order of operand evaluation in the metacircular evaluator is
#      determined by the order of evaluation of the arguments to @c(cons) in the
#      procedure @c(list-of-values) of section @l(#4.1.1) (see @l(#Exercise 4.1)).
  :: @N(309) :: El orden de la evaluación del operando en el evaluador
     metacircular se determina por el orden de evaluación de los argumentos
     @c(cons) en el procedimiento @c(list-of-values) de la seccion @l(#4.1.1) (véase
     el @l(#Ejercicio 4.1) ).

#   :: @N(310) :: We saw in section @l(#5.1) how to implement such a process with a
#      register machine that had no stack; the state of the process was stored in
#      a fixed set of registers.
  :: @N(310) :: Vimos en la seccion @l(#5.1) cómo implementar tal proceso con una
     máquina de registro que no tenía pila; El estado del proceso se almacenó en
     un conjunto fijo de registros.

#   :: @N(311) :: This implementation of tail recursion in @c(ev-sequence) is one
#      variety of a well-known optimization technique used by many compilers. In
#      compiling a procedure that ends with a procedure call, one can replace the
#      call by a jump to the called procedure's entry point.  Building this
#      strategy into the interpreter, as we have done in this section, provides
#      the optimization uniformly throughout the language.
  :: @N(311) :: Esta implementación de la recursión de cola en @c(ev-sequence)
     es una variedad de una técnica de optimización bien conocida utilizada por
     muchos compiladores. Al compilar un procedimiento que termina con una
     llamada de procedimiento, se puede reemplazar la llamada por un salto al
     punto de entrada del procedimiento llamado. Construir esta estrategia en el
     intérprete, como hemos hecho en esta sección, proporciona la optimización
     de manera uniforme en todo el lenguaje.

#   :: @N(312) :: We can define @c(no-more-exps?) as follows:
  :: @N(312) :: Podemos definir @c(no-more-exps?) lo siguiente:

#      ..src > scheme
#        (define (no-more-exps? seq) (null? seq))
#      < src..
     ..src > scheme
       (define (no-more-exps? seq) (null? seq))
     < src..

#   :: @N(313) :: This isn't really cheating. In an actual implementation built
#      from scratch, we would use our explicit-control evaluator to interpret a
#      Scheme program that performs source-level transformations like @c(cond->if)
#      in a syntax phase that runs before execution.
  :: @N(313) :: Esto no es realmente hacer trampa. En una implementación real
     construida desde cero, usaríamos nuestro evaluador de control explícito
     para interpretar un programa Scheme que realiza transformaciones a nivel de
     origen como @c(cond->if) en una fase de sintaxis que se ejecuta antes de
     la ejecución.

#   :: @N(314) :: We assume here that @c(read) and the various printing operations
#      are available as primitive machine operations, which is useful for our
#      simulation, but completely unrealistic in practice. These are actually
#      extremely complex operations. In practice, they would be implemented using
#      low-level input-output operations such as transferring single characters to
#      and from a device.
  :: @N(314) :: Asumimos aquí que @c(read) y las diversas operaciones de
     impresión están disponibles como operaciones de máquina primitiva, que es
     útil para nuestra simulación, pero completamente irreal en la práctica. En
     realidad, son operaciones extremadamente complejas. En la práctica, se
     implementarían utilizando operaciones de entrada-salida de bajo nivel, como
     la transferencia de caracteres individuales hacia y desde un dispositivo.

#      To support the @c(get-global-environment) operation we define
     Para apoyar la @c(get-global-environment) operación definimos

#      ..src > scheme
#        (define the-global-environment
#          (setup-environment))
#
#        (define (get-global-environment)
#          the-global-environment)
#      < src..
     ..src > scheme
       (define the-global-environment
         (setup-environment))

       (define (get-global-environment)
         the-global-environment)
     < src..

#   :: @N(315) :: There are other errors that we would like the interpreter to
#      handle, but these are not so simple. See @l(#Exercise 5.30).
  :: @N(315) :: Hay otros errores que queremos que el intérprete maneje, pero
     estos no son tan simples. Véase el @l(#Ejercicio 5.30).

#   :: @N(316) :: We could perform the stack initialization only after errors, but
#      doing it in the driver loop will be convenient for monitoring the
#      evaluator's performance, as described below.
  :: @N(316) :: Podríamos realizar la inicialización de la pila sólo después de
     errores, pero hacerlo en el bucle del controlador será conveniente para
     supervisar el rendimiento del evaluador, como se describe a continuación.

#   :: @N(317) :: Regrettably, this is the normal state of affairs in conventional
#      compiler-based language systems such as C. In @A(UNIX)(tm) the system
#      @"(dumps core,) and in @A(DOS)/Windows(tm) it becomes catatonic. The
#      Macintosh(tm) displays a picture of an exploding bomb and offers you the
#      opportunity to reboot the computer––if you're lucky.
  :: @N(317) :: Lamentablemente, este es el estado normal de los sistemas
     convencionales de lenguaje basados en compilador como C. En @A(UNIX) (tm)
     el sistema @"(vuelca el núcleo,) y en @A(DOS) / Windows (tm) se convierte
     en catatónico. El Macintosh (tm) muestra una imagen de una explosión de la
     bomba y le ofrece la oportunidad de reiniciar el ordenador - si tienes
     suerte.

#   :: @N(318) :: This is a theoretical statement. We are not claiming that the
#      evaluator's data paths are a particularly convenient or efficient set of
#      data paths for a general-purpose computer. For example, they are not very
#      good for implementing high-performance floating-point calculations or
#      calculations that intensively manipulate bit vectors.
  :: @N(318) :: Esta es una declaración teórica. No estamos afirmando que las
     trayectorias de datos del evaluador sean un conjunto de rutas de datos
     particularmente conveniente o eficiente para una computadora de uso
     general. Por ejemplo, no son muy buenos para implementar cálculos de punto
     flotante de alto rendimiento o cálculos que manipulen intensamente vectores
     de bits.

#   :: @N(319) :: Actually, the machine that runs compiled code can be simpler
#      than the interpreter machine, because we won't use the @c(exp) and @c(unev)
#      registers. The interpreter used these to hold pieces of unevaluated
#      expressions. With the compiler, however, these expressions get built into
#      the compiled code that the register machine will run. For the same reason,
#      we don't need the machine operations that deal with expression syntax.  But
#      compiled code will use a few additional machine operations (to represent
#      compiled procedure objects) that didn't appear in the explicit-control
#      evaluator machine.
  :: @N(319) :: En realidad, la máquina que ejecuta código compilado puede ser
     más simple que la máquina de intérprete, porque no usaremos los registros
     @c(exp) y @c(unev). El intérprete los usó para contener fragmentos de
     expresiones no valoradas. Con el compilador, sin embargo, estas expresiones
     se incorporan en el código compilado que ejecutará la máquina de
     registro. Por la misma razón, no necesitamos las operaciones de la máquina
     que tratan con la sintaxis de la expresión. Pero el código compilado
     utilizará algunas operaciones adicionales de la máquina (para representar
     objetos de procedimiento compilados) que no aparecieron en la máquina de
     evaluación de control explícito.

#   :: @N(320) :: Notice, however, that our compiler is a Scheme program, and the
#      syntax procedures that it uses to manipulate expressions are the actual
#      Scheme procedures used with the metacircular evaluator. For the
#      explicit-control evaluator, in contrast, we assumed that equivalent syntax
#      operations were available as operations for the register machine. (Of
#      course, when we simulated the register machine in Scheme, we used the
#      actual Scheme procedures in our register machine simulation.)
  :: @N(320) :: Observe, sin embargo, que nuestro compilador es un programa
     Scheme y los procedimientos de sintaxis que utiliza para manipular
     expresiones son los procedimientos Scheme reales utilizados con el
     evaluador metacircular. Para el evaluador de control explícito, en
     contraste, se asumió que operaciones de sintaxis equivalentes estaban
     disponibles como operaciones para la máquina de registro. (Por supuesto,
     cuando simulamos la máquina de registro en Scheme, usamos los
     procedimientos Scheme reales en nuestra simulación de máquina de registro.)

#   :: @N(321) :: This procedure uses a feature of Lisp called @e(backquote) (or
#      @e(quasiquote)) that is handy for constructing lists. Preceding a list with
#      a backquote symbol is much like quoting it, except that anything in the
#      list that is flagged with a comma is evaluated.
  :: @N(321) :: Este procedimiento utiliza una característica de Lisp llamada
     @e(backquote) (o @e(quasiquote) ) que es útil para construir
     listas. Preceder una lista con un símbolo backquote es como citarlo,
     excepto que cualquier cosa en la lista que está marcado con una coma es
     evaluada.

#      For example, if the value of @c(linkage) is the symbol @c(branch25), then
#      the expression
     Por ejemplo, si el valor de @c(linkage) es el símbolo @c(branch25),
     entonces la expresión

#      ..src > scheme
#        `((goto (label ,linkage)))
#      < src..
     ..src > scheme
       `((goto (label ,linkage)))
     < src..

#      evaluates to the list
     Se evalúa a la lista

#      ..src > scheme
#        ((goto (label branch25)))
#      < src..
     ..src > scheme
       ((goto (label branch25)))
     < src..

#      Similarly, if the value of @c(x) is the list @c[(a b c)], then
     Del mismo modo, si el valor de @c(x) es la lista @c[(a b c)], entonces

#      ..src > scheme
#        `(1 2 ,(car x))
#      < src..
     ..src > scheme
       `(1 2 ,(car x))
     < src..

#      evaluates to the list
     Se evalúa a la lista

#      ..src > scheme
#        (1 2 a)
#      < src..
     ..src > scheme
       (1 2 a)
     < src..


#   :: @N(322) :: We can't just use the labels @c(true-branch), @c(false-branch),
#      and @c(after-if) as shown above, because there might be more than one
#      @c(if) in the program. The compiler uses the procedure @c(make-label) to
#      generate labels. @c(Make-label) takes a symbol as argument and returns a
#      new symbol that begins with the given symbol. For example, successive calls
#      to @c[(make-label 'a)] would return @c(a1), @c(a2), and so
#      on. @c(Make-label) can be implemented similarly to the generation of unique
#      variable names in the query language, as follows:
  :: @N(322) :: No podemos simplemente usar las etiquetas @c(true-branch),
     @c(false-branch) y @c(after-if) como se muestra arriba, porque puede haber
     más de una @c(if) en el programa. El compilador utiliza el procedimiento
     @c(make-label) para generar etiquetas. @c(Make-label) Toma un símbolo como
     argumento y devuelve un nuevo símbolo que comienza con el símbolo dado. Por
     ejemplo, las llamadas sucesivas a @c[(make-label 'a)] volverían @c(a1),
     @c(a2) y así sucesivamente. @c(Make-label) Se puede implementar de forma
     similar a la generación de nombres de variables únicos en el lenguaje de
     consulta, de la siguiente manera:

#      ..src > scheme
#        (define label-counter 0)
#
#        (define (new-label-number)
#          (set! label-counter (+ 1 label-counter))
#          label-counter)
#
#        (define (make-label name)
#          (string->symbol
#           (string-append
#            (symbol->string name)
#            (number->string (new-label-number)))))
#      < src..
     ..src > scheme
       (define label-counter 0)

       (define (new-label-number)
         (set! label-counter (+ 1 label-counter))
         label-counter)

       (define (make-label name)
         (string->symbol
          (string-append
           (symbol->string name)
           (number->string (new-label-number)))))
     < src..

#   :: @N(323) :: @t(Footnote 323) We need machine operations to implement a data
#      structure for representing compiled procedures, analogous to the structure
#      for compound procedures described in section @l(#4.1.3):
  :: @N(323) :: <span id="Footnote-323">Nota de pie de página 323</span>
     Necesitamos operaciones de máquina para implementar una estructura de datos
     para representar procedimientos compilados, análoga a la estructura para
     procedimientos compuestos descritos en la seccion @l(#4.1.3):

#      ..src > scheme
#        (define (make-compiled-procedure entry env)
#          (list 'compiled-procedure entry env))
#        (define (compiled-procedure? proc)
#          (tagged-list? proc 'compiled-procedure))
#        (define (compiled-procedure-entry c-proc)
#          (cadr c-proc))
#        (define (compiled-procedure-env c-proc)
#          (caddr c-proc))
#      < src..
     ..src > scheme
       (define (make-compiled-procedure entry env)
         (list 'compiled-procedure entry env))
       (define (compiled-procedure? proc)
         (tagged-list? proc 'compiled-procedure))
       (define (compiled-procedure-entry c-proc)
         (cadr c-proc))
       (define (compiled-procedure-env c-proc)
         (caddr c-proc))
     < src..

#   :: @N(324) :: Actually, we signal an error when the target is not @c(val) and
#      the linkage is @c(return), since the only place we request @c(return)
#      linkages is in compiling procedures, and our convention is that procedures
#      return their values in @c(val).
  :: @N(324) :: En realidad, señalamos un error cuando el objetivo no es @c(val)
     y el enlace es @c(return), ya que el único lugar que solicitamos @c(return)
     vínculos es en los procedimientos de compilación, y nuestra convención es
     que los procedimientos devuelven sus valores @c(val).

#   :: @N(325) :: Making a compiler generate tail-recursive code might seem like a
#      straightforward idea. But most compilers for common languages, including C
#      and Pascal, do not do this, and therefore these languages cannot represent
#      iterative processes in terms of procedure call alone. The difficulty with
#      tail recursion in these languages is that their implementations use the
#      stack to store procedure arguments and local variables as well as return
#      addresses. The Scheme implementations described in this book store
#      arguments and variables in memory to be garbage-collected. The reason for
#      using the stack for variables and arguments is that it avoids the need for
#      garbage collection in languages that would not otherwise require it, and is
#      generally believed to be more efficient. Sophisticated Lisp compilers can,
#      in fact, use the stack for arguments without destroying tail
#      recursion. (See @l(#Hanson 1990) for a description.)  There is also some
#      debate about whether stack allocation is actually more efficient than
#      garbage collection in the first place, but the details seem to hinge on
#      fine points of computer architecture. (See @l(#Appel 1987) and @l(#Miller
#      and Rozas 1994) for opposing views on this issue.)
  :: @N(325) :: Hacer que un compilador genere código recursivo de cola podría
     parecer una idea sencilla. Pero la mayoría de los compiladores para
     lenguajes comunes, incluyendo C y Pascal, no lo hacen, y por lo tanto estos
     lenguajes no pueden representar procesos iterativos en términos de llamada
     de procedimiento solo. La dificultad con la recursión de cola en estos
     lenguajes es que sus implementaciones utilizan la pila para almacenar
     argumentos de procedimiento y variables locales, así como direcciones de
     retorno. Las implementaciones de Scheme descritas en este libro almacenan
     los argumentos y las variables en la memoria para ser recolectados de
     basura. La razón para usar la pila para variables y argumentos es que evita
     la necesidad de recolección de basura en idiomas que de otra manera no lo
     requerirían, y generalmente se cree que es más eficiente. Los compiladores
     sofisticados de Lisp pueden, de hecho, Utilizar la pila para los argumentos
     sin destruir la recursión de la cola. También hay un cierto debate sobre si
     la asignación de la pila es realmente más eficiente que la recolección de
     basura en el primer lugar, pero los detalles parecen depender de los puntos
     finos de la arquitectura de la computadora (ver
     @l(#Hanson-1990<>Hanson 1990) para una descripción. (Ver
     @l(#Appel-1987<>Appel 1987) y @l(#Miller-and-Rozas-1994<>Miller y
     Rozas 1994) por opiniones opuestas sobre este tema.)

#   :: @N(326) :: The variable @c(all-regs) is bound to the list of names of all
#      the registers:
  :: @N(326) :: La variable @c(all-regs) está vinculada a la lista de nombres de
     todos los registros:

#      ..src > scheme
#        (define all-regs '(env proc val argl continue))
#      < src..
     ..src > scheme
       (define all-regs '(env proc val argl continue))
     < src..

#   :: @N(327) :: Note that @c(preserving) calls @c(append) with three
#      arguments. Though the definition of @c(append) shown in this book accepts
#      only two arguments, Scheme standardly provides an @c(append) procedure that
#      takes an arbitrary number of arguments.
  :: @N(327) :: Tenga en cuenta que las @c(preserving) llamadas @c(append) con
     tres argumentos. Aunque la definición de @c(append) este libro sólo acepta
     dos argumentos, Scheme proporciona de forma estándar un procedimiento @c(append) que toma un número arbitrario de argumentos.

#   :: @N(328) :: We have used the same symbol @c(+) here to denote both the
#      source-language procedure and the machine operation. In general there will
#      not be a one-to-one correspondence between primitives of the source
#      language and primitives of the machine.
  :: @N(328) :: Hemos utilizado el mismo símbolo @c(+) aquí para denotar tanto
     el procedimiento de lenguaje fuente como el funcionamiento de la
     máquina. En general no habrá una correspondencia uno a uno entre primitivas
     del lenguaje fuente y primitivas de la máquina.

#   :: @N(329) :: Making the primitives into reserved words is in general a bad
#      idea, since a user cannot then rebind these names to different procedures.
#      Moreover, if we add reserved words to a compiler that is in use, existing
#      programs that define procedures with these names will stop working. See
#      @l(#Exercise 5.44) for ideas on how to avoid this problem.
  :: @N(329) :: Hacer las primitivas en palabras reservadas es en general una
     mala idea, ya que un usuario no puede volver a vincular estos nombres a
     procedimientos diferentes. Además, si agregamos palabras reservadas a un
     compilador que está en uso, los programas existentes que definen
     procedimientos con estos nombres dejarán de funcionar. Consulte el
     @l(#Ejercicio 5.44) para obtener ideas sobre cómo evitar
     este problema.

#   :: @N(330) :: This is not true if we allow internal definitions, unless we
#      scan them out. See @l(#Exercise 5.43).
  :: @N(330) :: Esto no es cierto si permitimos definiciones internas, a menos
     que las escanemos. Véase el @l(#Ejercicio 5.43).

#   :: @N(331) :: This is the modification to variable lookup required if we
#      implement the scanning method to eliminate internal definitions
#      (@l(#Exercise 5.43)). We will need to eliminate these definitions in order
#      for lexical addressing to work.
  :: @N(331) :: Esta es la modificación de la búsqueda de variables necesaria si
     implementamos el método de escaneado para eliminar las definiciones
     internas (@l(#Ejercicio 5.43) ). Necesitaremos eliminar
     estas definiciones para que el direccionamiento léxico funcione.

#   :: @N(332) :: Lexical addresses cannot be used to access variables in the
#      global environment, because these names can be defined and redefined
#      interactively at any time. With internal definitions scanned out, as in
#      @l(#Exercise 5.43), the only definitions the compiler sees are those at top
#      level, which act on the global environment. Compilation of a definition
#      does not cause the defined name to be entered in the compile-time
#      environment.
  :: @N(332) :: Las direcciones léxicas no se pueden utilizar para acceder a
     variables en el entorno global, ya que estos nombres pueden definirse y
     redefinirse interactivamente en cualquier momento. Con las definiciones
     internas escaneadas, como en el @l(#Ejercicio 5.43), las
     únicas definiciones que ve el compilador son las de nivel superior, que
     actúan sobre el entorno global. La compilación de una definición no hace
     que se introduzca el nombre definido en el entorno de compilación.

#   :: @N(333) :: Of course, compiled procedures as well as interpreted procedures
#      are compound (nonprimitive). For compatibility with the terminology used in
#      the explicit-control evaluator, in this section we will use @"(compound) to
#      mean interpreted (as opposed to compiled).
  :: @N(333) :: Por supuesto, los procedimientos compilados así como los
     procedimientos interpretados son compuestos (no primitivos). Para la
     compatibilidad con la terminología utilizada en el evaluador de control
     explícito, en esta sección usaremos @"(compuesto) para significar
     interpretado (en contraposición a compilado).

#   :: @N(334) :: Now that the evaluator machine starts with a @c(branch), we must
#      always initialize the @c(flag) register before starting the evaluator
#      machine. To start the machine at its ordinary read-eval-print loop, we
#      could use
  :: @N(334) :: Ahora que la máquina evaluadora comienza con a @c(branch),
     siempre debemos inicializar el @c(flag) registro antes de iniciar la
     máquina evaluadora. Para iniciar la máquina en su bucle de
     lectura-eval-print normal, podríamos usar

#      ..src > scheme
#        (define (start-eceval)
#          (set! the-global-environment
#                (setup-environment))
#          (set-register-contents! eceval 'flag false)
#          (start eceval))
#      < src..
     ..src > scheme
       (define (start-eceval)
         (set! the-global-environment
               (setup-environment))
         (set-register-contents! eceval 'flag false)
         (start eceval))
     < src..

#   :: @N(335) :: Since a compiled procedure is an object that the system may try
#      to print, we also modify the system print operation @c(user-print) (from
#      @l(#4.1.4)) so that it will not attempt to print the components of a
#      compiled procedure:
  :: @N(335) :: Dado que un procedimiento compilado es un objeto que el sistema
     puede intentar imprimir, también modificamos la operación de impresión del
     sistema @c(user-print)(desde la seccion @l(#4.1.4)) para que no intente
     imprimir los componentes de un procedimiento compilado:

#      ..src > scheme
#        (define (user-print object)
#          (cond ((compound-procedure? object)
#                 (display
#                  (list 'compound-procedure
#                        (procedure-parameters object)
#                        (procedure-body object)
#                        '<procedure-env>)))
#                ((compiled-procedure? object)
#                 (display '<compiled-procedure>))
#                (else (display object))))
#      < src..
     ..src > scheme
       (define (user-print object)
         (cond ((compound-procedure? object)
                (display
                 (list 'compound-procedure
                       (procedure-parameters object)
                       (procedure-body object)
                       '<procedure-env>)))
               ((compiled-procedure? object)
                (display '<compiled-procedure>))
               (else (display object))))
     < src..


#   :: @N(336) :: We can do even better by extending the compiler to allow
#      compiled code to call interpreted procedures. See @l(#Exercise 5.47).
  :: @N(336) :: Podemos hacerlo aún mejor extendiendo el compilador para
     permitir que el código compilado llame a procedimientos
     interpretados. Véase el @l(#Ejercicio 5.47).

#   :: @N(337) :: Independent of the strategy of execution, we incur significant
#      overhead if we insist that errors encountered in execution of a user
#      program be detected and signaled, rather than being allowed to kill the
#      system or produce wrong answers. For example, an out-of-bounds array
#      reference can be detected by checking the validity of the reference before
#      performing it. The overhead of checking, however, can be many times the
#      cost of the array reference itself, and a programmer should weigh speed
#      against safety in determining whether such a check is desirable. A good
#      compiler should be able to produce code with such checks, should avoid
#      redundant checks, and should allow programmers to control the extent and
#      type of error checking in the compiled code.
  :: @N(337) :: Independientemente de la estrategia de ejecución, incurrimos en
     gastos indirectos significativos si insistimos en que los errores
     encontrados en la ejecución de un programa de usuario sean detectados y
     señalados, en lugar de que se les permita matar el sistema o producir
     respuestas incorrectas. Por ejemplo, una referencia de matriz fuera de
     límites puede detectarse comprobando la validez de la referencia antes de
     realizarla. La sobrecarga de la comprobación, sin embargo, puede ser muchas
     veces el coste de la referencia de la matriz en sí, y un programador debe
     pesar la velocidad contra la seguridad en la determinación de si tal cheque
     es deseable. Un buen compilador debe ser capaz de producir código con
     dichas comprobaciones, debe evitar verificaciones redundantes, y debe
     permitir a los programadores para controlar la extensión y el tipo de
     comprobación de errores en el código compilado.

#      Compilers for popular languages, such as C and C++, put hardly any
#      error-checking operations into running code, so as to make things run as
#      fast as possible. As a result, it falls to programmers to explicitly
#      provide error checking. Unfortunately, people often neglect to do this,
#      even in critical applications where speed is not a constraint. Their
#      programs lead fast and dangerous lives. For example, the notorious @"(Worm)
#      that paralyzed the Internet in 1988 exploited the @A(UNIX)ᵀᴹ operating
#      system's failure to check whether the input buffer has overflowed in the
#      finger daemon. (See @l(#Spafford 1989).)
     Los compiladores de lenguajes populares, como C y C ++, no ponen
     prácticamente ninguna operación de verificación de errores en el código en
     ejecución, para hacer que las cosas se ejecuten lo más rápido posible. Como
     resultado, corresponde a los programadores explícitamente proporcionar
     comprobación de errores. Desafortunadamente, las personas a menudo se
     olvidan de hacer esto, incluso en aplicaciones críticas donde la velocidad
     no es una limitación. Sus programas llevan vidas rápidas y peligrosas. Por
     ejemplo, el famoso @"(gusano) que paralizó Internet en 1988 explotó el
     fallo del sistema operativo @A(UNIX) ᵀᴹ para comprobar si el búfer de
     entrada se había desbordado en el daemon de dedo. (Véase
     @l(#Spafford-1989<>Spafford 1989) ).

#   :: @N(338) :: Of course, with either the interpretation or the compilation
#      strategy we must also implement for the new machine storage allocation,
#      input and output, and all the various operations that we took as
#      @"(primitive) in our discussion of the evaluator and compiler. One strategy
#      for minimizing work here is to write as many of these operations as
#      possible in Lisp and then compile them for the new machine. Ultimately,
#      everything reduces to a small kernel (such as garbage collection and the
#      mechanism for applying actual machine primitives) that is hand-coded for
#      the new machine.
  :: @N(338) :: Por supuesto, con la interpretación o la estrategia de
     compilación también debemos implementar para la nueva asignación de
     almacenamiento de la máquina, entrada y salida, y todas las diversas
     operaciones que tomamos como @"(primitivas) en nuestra discusión del
     evaluador y compilador. Una estrategia para minimizar el trabajo aquí es
     escribir tantas de estas operaciones como sea posible en Lisp y luego
     compilarlas para la nueva máquina. En última instancia, todo se reduce a un
     núcleo pequeño (como la recolección de basura y el mecanismo para aplicar
     primitivas reales de la máquina) que se codifica manualmente para la nueva
     máquina.

#   :: @N(339) :: This strategy leads to amusing tests of correctness of the
#      compiler, such as checking whether the compilation of a program on the new
#      machine, using the compiled compiler, is identical with the compilation of
#      the program on the original Lisp system. Tracking down the source of
#      differences is fun but often frustrating, because the results are extremely
#      sensitive to minuscule details.
  :: @N(339) :: Esta estrategia conduce a divertidas pruebas de corrección del
     compilador, como comprobar si la compilación de un programa en la nueva
     máquina, utilizando el compilador compilado, es idéntica a la compilación
     del programa en el sistema Lisp original. El seguimiento de la fuente de
     las diferencias es divertido, pero a menudo frustrante, porque los
     resultados son muy sensibles a los detalles minúsculos.!
