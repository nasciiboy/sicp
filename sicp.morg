..title    > Structure and Interpretation of Computer Programs
..subtitle > @e(Second Edition) Unofficial morg Format
..source   > 1996 Massachusetts Institute of Technology
..licence  > CC BY-SA 4.0
..author   > Harold Abelson and Gerald Jay Sussman with Julie Sussman
..style    > worg-data/worg.css
..options  > mathJax fancyCode toc

@ dircategory The Algorithmic Language Scheme
@ utfversion      2.andresraba6.6
@ utfversiondate  September 16, 2015
@ ↵

..pret >
  by Harold Abelson and Gerald Jay Sussman, with Julie Sussman
  foreword by Alan J. Perlis

This work is licensed under a Creative Commons Attribution-ShareAlike 4.0
International License (@l(http://creativecommons.org/licenses/by-sa/4.0/<>@A(CC
BY-SA 4.0))). Based on a work at @l(http://mitpress.mit.edu/sicp/<>mitpress.mit.edu).

..pret >
  The @A(MIT) Press
  Cambridge, Massachusetts
  London, England

..pret >
  McGraw-Hill Book Company
  New York, St. Louis, San Francisco,
  Montreal, Toronto

This book is one of a series of texts written by faculty of the Electrical
Engineering and Computer Science Department at the Massachusetts Institute of
Technology. It was edited and produced by The @A(MIT) Press under a joint
production-distribution arrangement with the McGraw-Hill Book Company.

* Unofficial @e(morg) Format

  This is the second edition @A(SICP) book, from Unofficial morg Format.

  This @l(https://github.com/nasciiboy/morg/<>morg) version is based on
  Unofficial Texinfo Format @l(http://sicpebook.wordpress.com) (July 07, 2017),
  based on @l(http://www.neilvandyke.org/sicp-texi/<>2.neilvandyke4).

  The freely-distributed official @A(HTML)-and-@A(GIF) format was first
  converted personally to Unofficial Texinfo Format (@A(UTF)) version 1 by Lytha
  Ayth during a long Emacs lovefest weekend in April, 2001.

  The Texinfo conversion has been a straight transliteration, to the extent
  possible. Like the @e(morg)-to-@A(HTML) conversion, this was not without some
  introduction of breakage. In the case of Unofficial morg Format, figures
  have suffered an amateurish resurrection of the lost art of @A(ASCII) (and
  Unicode). Also, it's quite possible that some errors of ambiguity were
  introduced during the conversion of some of the copious superscripts (@'(^))
  and subscripts (@'(_)).  Divining @e(which) has been left as an exercise to
  the reader.

  It is believed that the Unofficial Texinfo Format is in keeping with the
  spirit of the graciously freely-distributed @A(HTML) version. But you never
  know when someone's armada of lawyers might need something to do, and get
  their shorts all in a knot over some benign little thing, so think twice
  before you use your full name or distribute Info, @A(DVI), PostScript, or
  @A(PDF) formats that might embed your account or machine name. @i(Peath,
  Lytha Ayth)

* Dedication

  This book is dedicated, in respect and admiration, to the spirit that lives in
  the computer.

  ..quote >
    @"(I think that it's extraordinarily important that we in computer science
    keep fun in computing. When it started out, it was an awful lot of fun. Of
    course, the paying customers got shafted every now and then, and after a
    while we began to take their complaints seriously. We began to feel as if
    we really were responsible for the successful, error-free perfect use of
    these machines. I don't think we are. I think we're responsible for
    stretching them, setting them off in new directions, and keeping fun in the
    house. I hope the field of computer science never loses its sense of fun.
    Above all, I hope we don't become missionaries. Don't feel as if you're
    Bible salesmen. The world has too many of those already. What you know
    about computing other people will learn. Don't feel as if the key to
    successful computing is only in your hands. What's in your hands, I think
    and hope, is intelligence: the ability to see the machine as more than when
    you were first led up to it, that you can make it more.)

    --Alan J. Perlis (April 1, 1922−February 7, 1990)
  < quote..

* Foreword

  Educators, generals, dieticians, psychologists, and parents program. Armies,
  students, and some societies are programmed. An assault on large problems
  employs a succession of programs, most of which spring into existence en
  route. These programs are rife with issues that appear to be particular to
  the problem at hand. To appreciate programming as an intellectual activity in
  its own right you must turn to computer programming; you must read and write
  computer programs––many of them. It doesn't matter much what the programs
  are about or what applications they serve. What does matter is how well they
  perform and how smoothly they fit with other programs in the creation of still
  greater programs. The programmer must seek both perfection of part and
  adequacy of collection. In this book the use of @"(program) is focused on the
  creation, execution, and study of programs written in a dialect of Lisp for
  execution on a digital computer. Using Lisp we restrict or limit not what we
  may program, but only the notation for our program descriptions.

  Our traffic with the subject matter of this book involves us with three foci of
  phenomena: the human mind, collections of computer programs, and the computer.
  Every computer program is a model, hatched in the mind, of a real or mental
  process. These processes, arising from human experience and thought, are huge
  in number, intricate in detail, and at any time only partially understood.
  They are modeled to our permanent satisfaction rarely by our computer programs.
  Thus even though our programs are carefully handcrafted discrete collections of
  symbols, mosaics of interlocking functions, they continually evolve: we change
  them as our perception of the model deepens, enlarges, generalizes until the
  model ultimately attains a metastable place within still another model with
  which we struggle. The source of the exhilaration associated with computer
  programming is the continual unfolding within the mind and on the computer of
  mechanisms expressed as programs and the explosion of perception they generate.
  If art interprets our dreams, the computer executes them in the guise of
  programs!

  For all its power, the computer is a harsh taskmaster. Its programs must be
  correct, and what we wish to say must be said accurately in every detail. As
  in every other symbolic activity, we become convinced of program truth through
  argument. Lisp itself can be assigned a semantics (another model, by the way),
  and if a program's function can be specified, say, in the predicate calculus,
  the proof methods of logic can be used to make an acceptable correctness
  argument. Unfortunately, as programs get large and complicated, as they almost
  always do, the adequacy, consistency, and correctness of the specifications
  themselves become open to doubt, so that complete formal arguments of
  correctness seldom accompany large programs. Since large programs grow from
  small ones, it is crucial that we develop an arsenal of standard program
  structures of whose correctness we have become sure––we call them idioms––and
  learn to combine them into larger structures using organizational techniques of
  proven value. These techniques are treated at length in this book, and
  understanding them is essential to participation in the Promethean enterprise
  called programming. More than anything else, the uncovering and mastery of
  powerful organizational techniques accelerates our ability to create large,
  significant programs. Conversely, since writing large programs is very taxing,
  we are stimulated to invent new methods of reducing the mass of function and
  detail to be fitted into large programs.

  Unlike programs, computers must obey the laws of physics. If they wish to
  perform rapidly––a few nanoseconds per state change––they must transmit
  electrons only small distances (at most @m(1 ½) feet). The heat generated by
  the huge number of devices so concentrated in space has to be removed. An
  exquisite engineering art has been developed balancing between multiplicity of
  function and density of devices. In any event, hardware always operates at a
  level more primitive than that at which we care to program. The processes
  that transform our Lisp programs to @"(machine) programs are themselves
  abstract models which we program. Their study and creation give a great deal
  of insight into the organizational programs associated with programming
  arbitrary models. Of course the computer itself can be so modeled. Think of
  it: the behavior of the smallest physical switching element is modeled by
  quantum mechanics described by differential equations whose detailed behavior
  is captured by numerical approximations represented in computer programs
  executing on computers composed of …!

  It is not merely a matter of tactical convenience to separately identify the
  three foci. Even though, as they say, it's all in the head, this logical
  separation induces an acceleration of symbolic traffic between these foci
  whose richness, vitality, and potential is exceeded in human experience only
  by the evolution of life itself. At best, relationships between the foci are
  metastable. The computers are never large enough or fast enough. Each
  breakthrough in hardware technology leads to more massive programming
  enterprises, new organizational principles, and an enrichment of abstract
  models. Every reader should ask himself periodically @"(Toward what end,
  toward what end?)––but do not ask it too often lest you pass up the fun of
  programming for the constipation of bittersweet philosophy.

  Among the programs we write, some (but never enough) perform a precise
  mathematical function such as sorting or finding the maximum of a sequence of
  numbers, determining primality, or finding the square root. We call such
  programs algorithms, and a great deal is known of their optimal behavior,
  particularly with respect to the two important parameters of execution time
  and data storage requirements. A programmer should acquire good algorithms
  and idioms. Even though some programs resist precise specifications, it is
  the responsibility of the programmer to estimate, and always to attempt to
  improve, their performance.

  Lisp is a survivor, having been in use for about a quarter of a century.
  Among the active programming languages only Fortran has had a longer life.
  Both languages have supported the programming needs of important areas of
  application, Fortran for scientific and engineering computation and Lisp for
  artificial intelligence. These two areas continue to be important, and their
  programmers are so devoted to these two languages that Lisp and Fortran may
  well continue in active use for at least another quarter-century.

  Lisp changes. The Scheme dialect used in this text has evolved from the
  original Lisp and differs from the latter in several important ways, including
  static scoping for variable binding and permitting functions to yield
  functions as values. In its semantic structure Scheme is as closely akin to
  Algol 60 as to early Lisps. Algol 60, never to be an active language again,
  lives on in the genes of Scheme and Pascal. It would be difficult to find two
  languages that are the communicating coin of two more different cultures than
  those gathered around these two languages. Pascal is for building
  pyramids––imposing, breathtaking, static structures built by armies pushing
  heavy blocks into place. Lisp is for building organisms––imposing,
  breathtaking, dynamic structures built by squads fitting fluctuating myriads
  of simpler organisms into place. The organizing principles used are the same
  in both cases, except for one extraordinarily important difference: The
  discretionary exportable functionality entrusted to the individual Lisp
  programmer is more than an order of magnitude greater than that to be found
  within Pascal enterprises. Lisp programs inflate libraries with functions
  whose utility transcends the application that produced them. The list, Lisp's
  native data structure, is largely responsible for such growth of utility. The
  simple structure and natural applicability of lists are reflected in functions
  that are amazingly nonidiosyncratic. In Pascal the plethora of declarable
  data structures induces a specialization within functions that inhibits and
  penalizes casual cooperation. It is better to have 100 functions operate on
  one data structure than to have 10 functions operate on 10 data structures.
  As a result the pyramid must stand unchanged for a millennium; the organism
  must evolve or perish.

  To illustrate this difference, compare the treatment of material and exercises
  within this book with that in any first-course text using Pascal. Do not
  labor under the illusion that this is a text digestible at @A(MIT) only,
  peculiar to the breed found there. It is precisely what a serious book on
  programming Lisp must be, no matter who the student is or where it is used.

  Note that this is a text about programming, unlike most Lisp books, which are
  used as a preparation for work in artificial intelligence. After all, the
  critical programming concerns of software engineering and artificial
  intelligence tend to coalesce as the systems under investigation become
  larger. This explains why there is such growing interest in Lisp outside of
  artificial intelligence.

  As one would expect from its goals, artificial intelligence research generates
  many significant programming problems. In other programming cultures this
  spate of problems spawns new languages. Indeed, in any very large programming
  task a useful organizing principle is to control and isolate traffic within
  the task modules via the invention of language. These languages tend to
  become less primitive as one approaches the boundaries of the system where we
  humans interact most often. As a result, such systems contain complex
  language-processing functions replicated many times. Lisp has such a simple
  syntax and semantics that parsing can be treated as an elementary task. Thus
  parsing technology plays almost no role in Lisp programs, and the construction
  of language processors is rarely an impediment to the rate of growth and
  change of large Lisp systems. Finally, it is this very simplicity of syntax
  and semantics that is responsible for the burden and freedom borne by all Lisp
  programmers. No Lisp program of any size beyond a few lines can be written
  without being saturated with discretionary functions. Invent and fit; have
  fits and reinvent!  We toast the Lisp programmer who pens his thoughts within
  nests of parentheses.

  ..pret >
    Alan J. Perlis
    New Haven, Connecticut

* Preface to the Second Edition

  ..quote >
    Is it possible that software is not like anything else, that it is meant to
    be discarded: that the whole point is to always see it as a soap bubble?

    --Alan J. Perlis
  < quote..


  The material in this book has been the basis of @A(MIT)'s entry-level computer
  science subject since 1980. We had been teaching this material for four years
  when the first edition was published, and twelve more years have elapsed until
  the appearance of this second edition. We are pleased that our work has been
  widely adopted and incorporated into other texts. We have seen our students
  take the ideas and programs in this book and build them in as the core of new
  computer systems and languages. In literal realization of an ancient Talmudic
  pun, our students have become our builders. We are lucky to have such capable
  students and such accomplished builders.

  In preparing this edition, we have incorporated hundreds of clarifications
  suggested by our own teaching experience and the comments of colleagues at
  @A(MIT) and elsewhere. We have redesigned most of the major programming
  systems in the book, including the generic-arithmetic system, the
  interpreters, the register-machine simulator, and the compiler; and we have
  rewritten all the program examples to ensure that any Scheme implementation
  conforming to the @A(IEEE) Scheme standard (@l(#IEEE 1990)) will be able to
  run the code.

  This edition emphasizes several new themes. The most important of these is
  the central role played by different approaches to dealing with time in
  computational models: objects with state, concurrent programming, functional
  programming, lazy evaluation, and nondeterministic programming. We have
  included new sections on concurrency and nondeterminism, and we have tried to
  integrate this theme throughout the book.

  The first edition of the book closely followed the syllabus of our @A(MIT)
  one-semester subject. With all the new material in the second edition, it
  will not be possible to cover everything in a single semester, so the
  instructor will have to pick and choose. In our own teaching, we sometimes
  skip the section on logic programming (@l(#4.4)), we have students use the
  register-machine simulator but we do not cover its implementation (@l(#5.2)),
  and we give only a cursory overview of the compiler (@l(#5.5)). Even so, this
  is still an intense course. Some instructors may wish to cover only the first
  three or four chapters, leaving the other material for subsequent courses.

  The World-Wide-Web site @l(http://mitpress.mit.edu/sicp) provides support for
  users of this book. This includes programs from the book, sample programming
  assignments, supplementary materials, and downloadable implementations of the
  Scheme dialect of Lisp.

* Preface to the First Edition

  ..quote >
    A computer is like a violin. You can imagine a novice trying first a
    phonograph and then a violin. The latter, he says, sounds terrible. That
    is the argument we have heard from our humanists and most of our computer
    scientists. Computer programs are good, they say, for particular purposes,
    but they aren't flexible. Neither is a violin, or a typewriter, until you
    learn how to use it.

    --Marvin Minsky, @q(Why Programming Is a Good Medium for Expressing
      Poorly-Understood and Sloppily-Formulated Ideas)
  < quote..


  @"(The Structure and Interpretation of Computer Programs) is the entry-level
  subject in computer science at the Massachusetts Institute of Technology. It
  is required of all students at @A(MIT) who major in electrical engineering or
  in computer science, as one-fourth of the @"(common core curriculum,) which
  also includes two subjects on circuits and linear systems and a subject on the
  design of digital systems. We have been involved in the development of this
  subject since 1978, and we have taught this material in its present form since
  the fall of 1980 to between 600 and 700 students each year. Most of these
  students have had little or no prior formal training in computation, although
  many have played with computers a bit and a few have had extensive programming
  or hardware-design experience.

  Our design of this introductory computer-science subject reflects two major
  concerns. First, we want to establish the idea that a computer language is
  not just a way of getting a computer to perform operations but rather that it
  is a novel formal medium for expressing ideas about methodology. Thus,
  programs must be written for people to read, and only incidentally for
  machines to execute. Second, we believe that the essential material to be
  addressed by a subject at this level is not the syntax of particular
  programming-language constructs, nor clever algorithms for computing
  particular functions efficiently, nor even the mathematical analysis of
  algorithms and the foundations of computing, but rather the techniques used to
  control the intellectual complexity of large software systems.

  Our goal is that students who complete this subject should have a good feel
  for the elements of style and the aesthetics of programming. They should have
  command of the major techniques for controlling complexity in a large
  system. They should be capable of reading a 50-page-long program, if it is
  written in an exemplary style. They should know what not to read, and what
  they need not understand at any moment. They should feel secure about
  modifying a program, retaining the spirit and style of the original author.

  These skills are by no means unique to computer programming. The techniques we
  teach and draw upon are common to all of engineering design. We control
  complexity by building abstractions that hide details when appropriate. We
  control complexity by establishing conventional interfaces that enable us to
  construct systems by combining standard, well-understood pieces in a @"(mix
  and match) way. We control complexity by establishing new languages for
  describing a design, each of which emphasizes particular aspects of the design
  and deemphasizes others.

  Underlying our approach to this subject is our conviction that @"(computer
  science) is not a science and that its significance has little to do with
  computers. The computer revolution is a revolution in the way we think and in
  the way we express what we think. The essence of this change is the emergence
  of what might best be called @e(procedural epistemology)––the study of the
  structure of knowledge from an imperative point of view, as opposed to the
  more declarative point of view taken by classical mathematical subjects.
  Mathematics provides a framework for dealing precisely with notions of @"(what
  is.)  Computation provides a framework for dealing precisely with notions of
  @"(how to.)

  In teaching our material we use a dialect of the programming language Lisp. We
  never formally teach the language, because we don't have to. We just use it,
  and students pick it up in a few days. This is one great advantage of
  Lisp-like languages: They have very few ways of forming compound expressions,
  and almost no syntactic structure. All of the formal properties can be covered
  in an hour, like the rules of chess. After a short time we forget about
  syntactic details of the language (because there are none) and get on with the
  real issues––figuring out what we want to compute, how we will decompose
  problems into manageable parts, and how we will work on the parts. Another
  advantage of Lisp is that it supports (but does not enforce) more of the
  large-scale strategies for modular decomposition of programs than any other
  language we know. We can make procedural and data abstractions, we can use
  higher-order functions to capture common patterns of usage, we can model local
  state using assignment and data mutation, we can link parts of a program with
  streams and delayed evaluation, and we can easily implement embedded
  languages.  All of this is embedded in an interactive environment with
  excellent support for incremental program design, construction, testing, and
  debugging. We thank all the generations of Lisp wizards, starting with John
  McCarthy, who have fashioned a fine tool of unprecedented power and elegance.

  Scheme, the dialect of Lisp that we use, is an attempt to bring together the
  power and elegance of Lisp and Algol. From Lisp we take the metalinguistic
  power that derives from the simple syntax, the uniform representation of
  programs as data objects, and the garbage-collected heap-allocated data. From
  Algol we take lexical scoping and block structure, which are gifts from the
  pioneers of programming-language design who were on the Algol committee. We
  wish to cite John Reynolds and Peter Landin for their insights into the
  relationship of Church's λ-calculus to the structure of programming
  languages. We also recognize our debt to the mathematicians who scouted out
  this territory decades before computers appeared on the scene. These pioneers
  include Alonzo Church, Barkley Rosser, Stephen Kleene, and Haskell Curry.

* Acknowledgments

  We would like to thank the many people who have helped us develop this book
  and this curriculum.

  Our subject is a clear intellectual descendant of @"(6.231,) a wonderful
  subject on programming linguistics and the λ-calculus taught at @A(MIT) in the
  late 1960s by Jack Wozencraft and Arthur Evans, Jr.

  We owe a great debt to Robert Fano, who reorganized @A(MIT)'s introductory
  curriculum in electrical engineering and computer science to emphasize the
  principles of engineering design. He led us in starting out on this enterprise
  and wrote the first set of subject notes from which this book evolved.

  Much of the style and aesthetics of programming that we try to teach were
  developed in conjunction with Guy Lewis Steele Jr., who collaborated with
  Gerald Jay Sussman in the initial development of the Scheme language. In
  addition, David Turner, Peter Henderson, Dan Friedman, David Wise, and Will
  Clinger have taught us many of the techniques of the functional programming
  community that appear in this book.

  Joel Moses taught us about structuring large systems. His experience with the
  Macsyma system for symbolic computation provided the insight that one should
  avoid complexities of control and concentrate on organizing the data to
  reflect the real structure of the world being modeled.

  Marvin Minsky and Seymour Papert formed many of our attitudes about
  programming and its place in our intellectual lives. To them we owe the
  understanding that computation provides a means of expression for exploring
  ideas that would otherwise be too complex to deal with precisely. They
  emphasize that a student's ability to write and modify programs provides a
  powerful medium in which exploring becomes a natural activity.

  We also strongly agree with Alan Perlis that programming is lots of fun and we
  had better be careful to support the joy of programming. Part of this joy
  derives from observing great masters at work. We are fortunate to have been
  apprentice programmers at the feet of Bill Gosper and Richard Greenblatt.

  It is difficult to identify all the people who have contributed to the
  development of our curriculum. We thank all the lecturers, recitation
  instructors, and tutors who have worked with us over the past fifteen years
  and put in many extra hours on our subject, especially Bill Siebert, Albert
  Meyer, Joe Stoy, Randy Davis, Louis Braida, Eric Grimson, Rod Brooks, Lynn
  Stein, and Peter Szolovits. We would like to specially acknowledge the
  outstanding teaching contributions of Franklyn Turbak, now at Wellesley; his
  work in undergraduate instruction set a standard that we can all aspire to. We
  are grateful to Jerry Saltzer and Jim Miller for helping us grapple with the
  mysteries of concurrency, and to Peter Szolovits and David McAllester for
  their contributions to the exposition of nondeterministic evaluation in
  @l(#Chapter 4).

  Many people have put in significant effort presenting this material at other
  universities. Some of the people we have worked closely with are Jacob
  Katzenelson at the Technion, Hardy Mayer at the University of California at
  Irvine, Joe Stoy at Oxford, Elisha Sacks at Purdue, and Jan Komorowski at the
  Norwegian University of Science and Technology. We are exceptionally proud of
  our colleagues who have received major teaching awards for their adaptations
  of this subject at other universities, including Kenneth Yip at Yale, Brian
  Harvey at the University of California at Berkeley, and Dan Huttenlocher at
  Cornell.

  Al Moyé arranged for us to teach this material to engineers at
  Hewlett-Packard and for the production of videotapes of these lectures. We
  would like to thank the talented instructors––in particular Jim Miller, Bill
  Siebert, and Mike Eisenberg––who have designed continuing education courses
  incorporating these tapes and taught them at universities and industry all
  over the world.

  Many educators in other countries have put in significant work translating the
  first edition. Michel Briand, Pierre Chamard, and André Pic produced a
  French edition; Susanne Daniels-Herold produced a German edition; and Fumio
  Motoyoshi produced a Japanese edition. We do not know who produced the Chinese
  edition, but we consider it an honor to have been selected as the subject of
  an @"(unauthorized) translation.

  It is hard to enumerate all the people who have made technical contributions
  to the development of the Scheme systems we use for instructional purposes. In
  addition to Guy Steele, principal wizards have included Chris Hanson, Joe
  Bowbeer, Jim Miller, Guillermo Rozas, and Stephen Adams. Others who have put
  in significant time are Richard Stallman, Alan Bawden, Kent Pitman, Jon Taft,
  Neil Mayle, John Lamping, Gwyn Osnos, Tracy Larrabee, George Carrette, Soma
  Chaudhuri, Bill Chiarchiaro, Steven Kirsch, Leigh Klotz, Wayne Noss, Todd
  Cass, Patrick O'Donnell, Kevin Theobald, Daniel Weise, Kenneth Sinclair,
  Anthony Courtemanche, Henry M. Wu, Andrew Berlin, and Ruth Shyu.

  Beyond the @A(MIT) implementation, we would like to thank the many people who
  worked on the @A(IEEE) Scheme standard, including William Clinger and Jonathan
  Rees, who edited the R⁴RS, and Chris Haynes, David Bartley, Chris Hanson, and
  Jim Miller, who prepared the @A(IEEE) standard.

  Dan Friedman has been a long-time leader of the Scheme community. The
  community's broader work goes beyond issues of language design to encompass
  significant educational innovations, such as the high-school curriculum based
  on EdScheme by Schemer's Inc., and the wonderful books by Mike Eisenberg and
  by Brian Harvey and Matthew Wright.

  We appreciate the work of those who contributed to making this a real book,
  especially Terry Ehling, Larry Cohen, and Paul Bethge at the @A(MIT)
  Press. Ella Mazel found the wonderful cover image. For the second edition we
  are particularly grateful to Bernard and Ella Mazel for help with the book
  design, and to David Jones, @e(TeX) wizard extraordinaire. We also are
  indebted to those readers who made penetrating comments on the new draft:
  Jacob Katzenelson, Hardy Mayer, Jim Miller, and especially Brian Harvey, who
  did unto this book as Julie did unto his book @q{Simply Scheme}.

  Finally, we would like to acknowledge the support of the organizations that
  have encouraged this work over the years, including support from
  Hewlett-Packard, made possible by Ira Goldstein and Joel Birnbaum, and support
  from @A(DARPA), made possible by Bob Kahn.

* Chapter 1 <> Building Abstractions with Procedures

  ..quote >
    The acts of the mind, wherein it exerts its power over simple ideas, are
    chiefly these three: 1. Combining several simple ideas into one compound
    one, and thus all complex ideas are made. 2. The second is bringing two
    ideas, whether simple or complex, together, and setting them by one another
    so as to take a view of them at once, without uniting them into one, by
    which it gets all its ideas of relations. 3. The third is separating them
    from all other ideas that accompany them in their real existence: this is
    called abstraction, and thus all its general ideas are made.

    --John Locke, @q(An Essay Concerning Human Understanding) (1690)
  < quote..


  We are about to study the idea of a @e(computational process).  Computational
  processes are abstract beings that inhabit computers. As they evolve,
  processes manipulate other abstract things called @e(data). The evolution of a
  process is directed by a pattern of rules called a @e(program). People create
  programs to direct processes. In effect, we conjure the spirits of the
  computer with our spells.

  A computational process is indeed much like a sorcerer's idea of a spirit. It
  cannot be seen or touched. It is not composed of matter at all. However, it is
  very real. It can perform intellectual work. It can answer questions. It can
  affect the world by disbursing money at a bank or by controlling a robot arm
  in a factory. The programs we use to conjure processes are like a sorcerer's
  spells. They are carefully composed from symbolic expressions in arcane and
  esoteric @e(programming languages) that prescribe the tasks we want our
  processes to perform.

  A computational process, in a correctly working computer, executes programs
  precisely and accurately. Thus, like the sorcerer's apprentice, novice
  programmers must learn to understand and to anticipate the consequences of
  their conjuring. Even small errors (usually called @e(bugs) or @e(glitches))
  in programs can have complex and unanticipated consequences.

  Fortunately, learning to program is considerably less dangerous than learning
  sorcery, because the spirits we deal with are conveniently contained in a
  secure way. Real-world programming, however, requires care, expertise, and
  wisdom. A small bug in a computer-aided design program, for example, can lead
  to the catastrophic collapse of an airplane or a dam or the self-destruction
  of an industrial robot.

  Master software engineers have the ability to organize programs so that they
  can be reasonably sure that the resulting processes will perform the tasks
  intended. They can visualize the behavior of their systems in advance. They
  know how to structure programs so that unanticipated problems do not lead to
  catastrophic consequences, and when problems do arise, they can @e(debug)
  their programs. Well-designed computational systems, like well-designed
  automobiles or nuclear reactors, are designed in a modular manner, so that the
  parts can be constructed, replaced, and debugged separately.

** Programming in Lisp

   We need an appropriate language for describing processes, and we will use for
   this purpose the programming language Lisp. Just as our everyday thoughts are
   usually expressed in our natural language (such as English, French, or
   Japanese), and descriptions of quantitative phenomena are expressed with
   mathematical notations, our procedural thoughts will be expressed in Lisp.
   Lisp was invented in the late 1950s as a formalism for reasoning about the use
   of certain kinds of logical expressions, called @e(recursion equations), as a
   model for computation. The language was conceived by John McCarthy and is
   based on his paper @"(Recursive Functions of Symbolic Expressions and Their
   Computation by Machine) (@l(#McCarthy 1960)).

   Despite its inception as a mathematical formalism, Lisp is a practical
   programming language. A Lisp @e(interpreter) is a machine that carries out
   processes described in the Lisp language. The first Lisp interpreter was
   implemented by McCarthy with the help of colleagues and students in the
   Artificial Intelligence Group of the @A(MIT) Research Laboratory of
   Electronics and in the @A(MIT) Computation Center.@n(1) Lisp, whose name is an
   acronym for LISt Processing, was designed to provide symbol-manipulating
   capabilities for attacking programming problems such as the symbolic
   differentiation and integration of algebraic expressions. It included for this
   purpose new data objects known as atoms and lists, which most strikingly set
   it apart from all other languages of the period.

   Lisp was not the product of a concerted design effort. Instead, it evolved
   informally in an experimental manner in response to users' needs and to
   pragmatic implementation considerations. Lisp's informal evolution has
   continued through the years, and the community of Lisp users has traditionally
   resisted attempts to promulgate any @"(official) definition of the language.
   This evolution, together with the flexibility and elegance of the initial
   conception, has enabled Lisp, which is the second oldest language in
   widespread use today (only Fortran is older), to continually adapt to
   encompass the most modern ideas about program design. Thus, Lisp is by now a
   family of dialects, which, while sharing most of the original features, may
   differ from one another in significant ways. The dialect of Lisp used in this
   book is called Scheme.@n(2)

   Because of its experimental character and its emphasis on symbol manipulation,
   Lisp was at first very inefficient for numerical computations, at least in
   comparison with Fortran. Over the years, however, Lisp compilers have been
   developed that translate programs into machine code that can perform numerical
   computations reasonably efficiently. And for special applications, Lisp has
   been used with great effectiveness.@n(3) Although Lisp has not yet overcome
   its old reputation as hopelessly inefficient, Lisp is now used in many
   applications where efficiency is not the central concern. For example, Lisp
   has become a language of choice for operating-system shell languages and for
   extension languages for editors and computer-aided design systems.

   If Lisp is not a mainstream language, why are we using it as the framework for
   our discussion of programming?  Because the language possesses unique features
   that make it an excellent medium for studying important programming constructs
   and data structures and for relating them to the linguistic features that
   support them. The most significant of these features is the fact that Lisp
   descriptions of processes, called @e(procedures), can themselves be
   represented and manipulated as Lisp data. The importance of this is that there
   are powerful program-design techniques that rely on the ability to blur the
   traditional distinction between @"(passive) data and @"(active) processes. As
   we shall discover, Lisp's flexibility in handling procedures as data makes it
   one of the most convenient languages in existence for exploring these
   techniques. The ability to represent procedures as data also makes Lisp an
   excellent language for writing programs that must manipulate other programs as
   data, such as the interpreters and compilers that support computer languages.
   Above and beyond these considerations, programming in Lisp is great fun.

** 1.1 <> The Elements of Programming

   A powerful programming language is more than just a means for instructing a
   computer to perform tasks. The language also serves as a framework within
   which we organize our ideas about processes. Thus, when we describe a
   language, we should pay particular attention to the means that the language
   provides for combining simple ideas to form more complex ideas. Every powerful
   language has three mechanisms for accomplishing this:

   - @b{primitive expressions}, which represent the simplest entities the
     language is concerned with,

   - @b{means of combination}, by which compound elements are built from simpler
     ones, and

   - @b{means of abstraction}, by which compound elements can be named and
     manipulated as units.


   In programming, we deal with two kinds of elements: procedures and
   data. (Later we will discover that they are really not so distinct.)
   Informally, data is @"(stuff) that we want to manipulate, and procedures are
   descriptions of the rules for manipulating the data. Thus, any powerful
   programming language should be able to describe primitive data and primitive
   procedures and should have methods for combining and abstracting procedures
   and data.

   In this chapter we will deal only with simple numerical data so that we can
   focus on the rules for building procedures.@n(4) In later chapters we will see
   that these same rules allow us to build procedures to manipulate compound data
   as well.

*** 1.1.1 <> Expressions

    One easy way to get started at programming is to examine some typical
    interactions with an interpreter for the Scheme dialect of Lisp. Imagine that
    you are sitting at a computer terminal. You type an @e(expression), and the
    interpreter responds by displaying the result of its @e(evaluating) that
    expression.

    One kind of primitive expression you might type is a number. (More precisely,
    the expression that you type consists of the numerals that represent the
    number in base 10.)  If you present Lisp with a number

    ..src > scheme
      486
    < src..

    the interpreter will respond by printing@n(5)

    ..srci > scheme
      486
    < srci..

    Expressions representing numbers may be combined with an expression
    representing a primitive procedure (such as @c(+) or @c(*)) to form a compound
    expression that represents the application of the procedure to those
    numbers. For example:

    ..srci > scheme
      > (+ 137 349)
      486
      > (- 1000 334)
      666
      > (* 5 99)
      495
      > (/ 10 5)
      2
      > (+ 2.7 10)
      12.7
    < srci..

    Expressions such as these, formed by delimiting a list of expressions within
    parentheses in order to denote procedure application, are called
    @e(combinations). The leftmost element in the list is called the @e(operator),
    and the other elements are called @e(operands). The value of a combination is
    obtained by applying the procedure specified by the operator to the
    @e(arguments) that are the values of the operands.

    The convention of placing the operator to the left of the operands is known as
    @e(prefix notation), and it may be somewhat confusing at first because it
    departs significantly from the customary mathematical convention. Prefix
    notation has several advantages, however. One of them is that it can
    accommodate procedures that may take an arbitrary number of arguments, as in
    the following examples:

    ..srci > scheme
      > (+ 21 35 12 7)
      75
      > (* 25 4 12)
      1200
    < srci..

    No ambiguity can arise, because the operator is always the leftmost element
    and the entire combination is delimited by the parentheses.

    A second advantage of prefix notation is that it extends in a straightforward
    way to allow combinations to be @e(nested), that is, to have combinations
    whose elements are themselves combinations:

    ..srci > scheme
      > (+ (* 3 5) (- 10 6))
      19
    < srci..

    There is no limit (in principle) to the depth of such nesting and to the
    overall complexity of the expressions that the Lisp interpreter can evaluate.
    It is we humans who get confused by still relatively simple expressions such
    as

    ..src > scheme
      (+ (* 3 (+ (* 2 4) (+ 3 5))) (+ (- 10 7) 6))
    < src..

    which the interpreter would readily evaluate to be 57. We can help ourselves
    by writing such an expression in the form

    ..src > scheme
      (+ (* 3
            (+ (* 2 4)
               (+ 3 5)))
         (+ (- 10 7)
            6))
    < src..

    following a formatting convention known as @e(pretty-printing), in which each
    long combination is written so that the operands are aligned vertically.  The
    resulting indentations display clearly the structure of the expression.@n(6)

    Even with complex expressions, the interpreter always operates in the same
    basic cycle: It reads an expression from the terminal, evaluates the
    expression, and prints the result. This mode of operation is often expressed
    by saying that the interpreter runs in a @e(read-eval-print loop).  Observe in
    particular that it is not necessary to explicitly instruct the interpreter to
    print the value of the expression.@n(7)

*** 1.1.2 <> Naming and the Environment

    A critical aspect of a programming language is the means it provides for using
    names to refer to computational objects. We say that the name identifies a
    @e(variable) whose @e(value) is the object.

    In the Scheme dialect of Lisp, we name things with @c(define). Typing

    ..src > scheme
      (define size 2)
    < src..

    causes the interpreter to associate the value 2 with the name @c(size).@n(8)
    Once the name @c(size) has been associated with the number 2, we can refer to
    the value 2 by name:

    ..srci > scheme
      > size
      2
      > (* 5 size)
      10
    < srci..

    Here are further examples of the use of @c(define):

    ..srci > scheme
      > (define pi 3.14159)
      > (define radius 10)
      > (* pi (* radius radius))
      314.159
      > (define circumference (* 2 pi radius))
      > circumference
      62.8318
    < srci..

    @c(define) is our language's simplest means of abstraction, for it allows us
    to use simple names to refer to the results of compound operations, such as
    the @c(circumference) computed above. In general, computational objects may
    have very complex structures, and it would be extremely inconvenient to have
    to remember and repeat their details each time we want to use them. Indeed,
    complex programs are constructed by building, step by step, computational
    objects of increasing complexity. The interpreter makes this step-by-step
    program construction particularly convenient because name-object associations
    can be created incrementally in successive interactions. This feature
    encourages the incremental development and testing of programs and is largely
    responsible for the fact that a Lisp program usually consists of a large
    number of relatively simple procedures.

    It should be clear that the possibility of associating values with symbols and
    later retrieving them means that the interpreter must maintain some sort of
    memory that keeps track of the name-object pairs. This memory is called the
    @e(environment) (more precisely the @e(global environment), since we will see
    later that a computation may involve a number of different environments).@n(9)

*** 1.1.3 <> Evaluating Combinations

    One of our goals in this chapter is to isolate issues about thinking
    procedurally. As a case in point, let us consider that, in evaluating
    combinations, the interpreter is itself following a procedure.

    - To evaluate a combination, do the following:

      1. Evaluate the subexpressions of the combination.

      2. Apply the procedure that is the value of the leftmost subexpression (the
         operator) to the arguments that are the values of the other
         subexpressions (the operands).


    Even this simple rule illustrates some important points about processes in
    general. First, observe that the first step dictates that in order to
    accomplish the evaluation process for a combination we must first perform the
    evaluation process on each element of the combination. Thus, the evaluation
    rule is @e(recursive) in nature; that is, it includes, as one of its steps,
    the need to invoke the rule itself.@n(10)

    Notice how succinctly the idea of recursion can be used to express what, in
    the case of a deeply nested combination, would otherwise be viewed as a rather
    complicated process. For example, evaluating

    ..src > scheme
      (* (+ 2 (* 4 6)) (+ 3 5 7))
    < src..

    requires that the evaluation rule be applied to four different combinations.
    We can obtain a picture of this process by representing the combination in the
    form of a tree, as shown in @l(#Figure 1.1). Each combination is represented
    by a node with branches corresponding to the operator and the operands of the
    combination stemming from it. The terminal nodes (that is, nodes with no
    branches stemming from them) represent either operators or numbers. Viewing
    evaluation in terms of the tree, we can imagine that the values of the
    operands percolate upward, starting from the terminal nodes and then combining
    at higher and higher levels. In general, we shall see that recursion is a very
    powerful technique for dealing with hierarchical, treelike objects. In fact,
    the @"(percolate values upward) form of the evaluation rule is an example of a
    general kind of process known as @e(tree accumulation).

    ..figure > @t(Figure 1.1) Tree representation, showing the value of each
      subcombination.

      ..art >
           390
           /|\____________
          / |             \
         *  26            15
            /|\           /|\
           / | \         // \\
          +  2  24      / | | \
                /|\    +  3 5  7
               / | \
              *  4  6
      < art..

@   ..img > img/chap1/Fig1.1g.std.svg

    Next, observe that the repeated application of the first step brings us to the
    point where we need to evaluate, not combinations, but primitive expressions
    such as numerals, built-in operators, or other names. We take care of the
    primitive cases by stipulating that

    - the values of numerals are the numbers that they name,

    - the values of built-in operators are the machine instruction sequences that
      carry out the corresponding operations, and

    - the values of other names are the objects associated with those names in the
      environment.

    We may regard the second rule as a special case of the third one by
    stipulating that symbols such as @c(+) and @c(*) are also included in the
    global environment, and are associated with the sequences of machine
    instructions that are their @"(values.)  The key point to notice is the role
    of the environment in determining the meaning of the symbols in
    expressions. In an interactive language such as Lisp, it is meaningless to
    speak of the value of an expression such as @c[(+ x 1)] without specifying any
    information about the environment that would provide a meaning for the symbol
    @c(x) (or even for the symbol @c(+)). As we shall see in @l(#Chapter 3), the
    general notion of the environment as providing a context in which evaluation
    takes place will play an important role in our understanding of program
    execution.

    Notice that the evaluation rule given above does not handle definitions. For
    instance, evaluating @c[(define x 3)] does not apply @c(define) to two
    arguments, one of which is the value of the symbol @c(x) and the other of
    which is 3, since the purpose of the @c(define) is precisely to associate
    @c(x) with a value. (That is, @c[(define x 3)] is not a combination.)

    Such exceptions to the general evaluation rule are called @e(special forms).
    @c(define) is the only example of a special form that we have seen so far, but
    we will meet others shortly. Each special form has its own evaluation
    rule. The various kinds of expressions (each with its associated evaluation
    rule) constitute the syntax of the programming language. In comparison with
    most other programming languages, Lisp has a very simple syntax; that is, the
    evaluation rule for expressions can be described by a simple general rule
    together with specialized rules for a small number of special forms.@n(11)

*** 1.1.4 <> Compound Procedures

    We have identified in Lisp some of the elements that must appear in any
    powerful programming language:

    - Numbers and arithmetic operations are primitive data and procedures.

    - Nesting of combinations provides a means of combining operations.

    - Definitions that associate names with values provide a limited means of
      abstraction.

    Now we will learn about @e(procedure definitions), a much more powerful
    abstraction technique by which a compound operation can be given a name and
    then referred to as a unit.

    We begin by examining how to express the idea of @"(squaring.)  We might say,
    @"(To square something, multiply it by itself.)  This is expressed in our
    language as

    ..src > scheme
      (define (square x) (* x x))
    < src..

    We can understand this in the following way:

    ..example >
      (define (square x)    (*       x       x))
        |      |      |      |       |       |
       To square something, multiply it by itself.
    < example..

    We have here a @e(compound procedure), which has been given the name
    @c(square). The procedure represents the operation of multiplying something by
    itself. The thing to be multiplied is given a local name, @c(x), which plays
    the same role that a pronoun plays in natural language. Evaluating the
    definition creates this compound procedure and associates it with the name
    @c(square).@n(12)

    The general form of a procedure definition is

    ..src > scheme
      (define (⟨name⟩ ⟨formal parameters⟩) ⟨body⟩)
    < src..

    The @c[(name)] is a symbol to be associated with the procedure definition in
    the environment.@n(13) The @c[(formal parameters)] are the names used within
    the body of the procedure to refer to the corresponding arguments of the
    procedure. The @c[(body)] is an expression that will yield the value of the
    procedure application when the formal parameters are replaced by the actual
    arguments to which the procedure is applied.@n(14) The @c[(name)] and the
    @c[(formal parameters)] are grouped within parentheses, just as they would be
    in an actual call to the procedure being defined.

    Having defined @c(square), we can now use it:

    ..srci > scheme
      > (square 21)
      441
      > (square (+ 2 5))
      49
      > (square (square 3))
      81
    < srci..

    We can also use @c(square) as a building block in defining other procedures.
    For example, @m(x² + y²) can be expressed as

    ..src > scheme
      (+ (square x) (square y))
    < src..

    We can easily define a procedure @c(sum-of-squares) that, given any two
    numbers as arguments, produces the sum of their squares:

    ..srci > scheme
      > (define (sum-of-squares x y)
      ^   (+ (square x) (square y)))
      > (sum-of-squares 3 4)
      25
    < srci..

    Now we can use @c(sum-of-squares) as a building block in constructing further
    procedures:

    ..srci > scheme
      > (define (f a)
      ^   (sum-of-squares (+ a 1) (* a 2)))
      > (f 5)
      136
    < srci..

    Compound procedures are used in exactly the same way as primitive procedures.
    Indeed, one could not tell by looking at the definition of @c(sum-of-squares)
    given above whether @c(square) was built into the interpreter, like @c(+) and
    @c(*), or defined as a compound procedure.

*** 1.1.5 <> The Substitution Model for Procedure Application

    To evaluate a combination whose operator names a compound procedure, the
    interpreter follows much the same process as for combinations whose operators
    name primitive procedures, which we described in @l(#1.1.3). That is, the
    interpreter evaluates the elements of the combination and applies the
    procedure (which is the value of the operator of the combination) to the
    arguments (which are the values of the operands of the combination).

    We can assume that the mechanism for applying primitive procedures to
    arguments is built into the interpreter. For compound procedures, the
    application process is as follows:

    ..tab >
      To apply a compound procedure to arguments, evaluate the body of the
      procedure with each formal parameter replaced by the corresponding argument.
    < tab..

    To illustrate this process, let's evaluate the combination

    ..src > scheme
      (f 5)
    < src..

    where @c(f) is the procedure defined in @l(#1.1.4). We begin by retrieving the
    body of @c(f):

    ..src > scheme
      (sum-of-squares (+ a 1) (* a 2))
    < src..

    Then we replace the formal parameter @c(a) by the argument 5:

    ..src > scheme
      (sum-of-squares (+ 5 1) (* 5 2))
    < src..

    Thus the problem reduces to the evaluation of a combination with two operands
    and an operator @c(sum-of-squares). Evaluating this combination involves three
    subproblems. We must evaluate the operator to get the procedure to be applied,
    and we must evaluate the operands to get the arguments. Now @c[(+ 5 1)]
    produces 6 and @c[(* 5 2)] produces 10, so we must apply the
    @c(sum-of-squares) procedure to 6 and 10. These values are substituted for the
    formal parameters @c(x) and @c(y) in the body of @c(sum-of-squares), reducing
    the expression to

    ..src > scheme
      (+ (square 6) (square 10))
    < src..

    If we use the definition of @c(square), this reduces to

    ..src > scheme
      (+ (* 6 6) (* 10 10))
    < src..

    which reduces by multiplication to

    ..src > scheme
      (+ 36 100)
    < src..

    and finally to

    ..srci > scheme
      136
    < srci..

    The process we have just described is called the @e(substitution model) for
    procedure application. It can be taken as a model that determines the
    @"(meaning) of procedure application, insofar as the procedures in this
    chapter are concerned. However, there are two points that should be stressed:

    - The purpose of the substitution is to help us think about procedure
      application, not to provide a description of how the interpreter really
      works.  Typical interpreters do not evaluate procedure applications by
      manipulating the text of a procedure to substitute values for the formal
      parameters. In practice, the @"(substitution) is accomplished by using a
      local environment for the formal parameters. We will discuss this more fully
      in @l(#Chapter 3) and @l(#Chapter 4) when we examine the implementation of
      an interpreter in detail.

    - Over the course of this book, we will present a sequence of increasingly
      elaborate models of how interpreters work, culminating with a complete
      implementation of an interpreter and compiler in @l(#Chapter 5). The
      substitution model is only the first of these models––a way to get started
      thinking formally about the evaluation process. In general, when modeling
      phenomena in science and engineering, we begin with simplified, incomplete
      models. As we examine things in greater detail, these simple models become
      inadequate and must be replaced by more refined models. The substitution
      model is no exception. In particular, when we address in @l(#Chapter 3) the
      use of procedures with @"(mutable data,) we will see that the substitution
      model breaks down and must be replaced by a more complicated model of
      procedure application.@n(15)

**** Applicative order versus normal order

     According to the description of evaluation given in @l(#1.1.3), the
     interpreter first evaluates the operator and operands and then applies the
     resulting procedure to the resulting arguments. This is not the only way to
     perform evaluation. An alternative evaluation model would not evaluate the
     operands until their values were needed. Instead it would first substitute
     operand expressions for parameters until it obtained an expression involving
     only primitive operators, and would then perform the evaluation. If we used
     this method, the evaluation of @c[(f 5)] would proceed according to the
     sequence of expansions

     ..src > scheme
       (sum-of-squares (+ 5 1) (* 5 2))

       (+ (square (+ 5 1))
          (square (* 5 2)))

       (+ (* (+ 5 1) (+ 5 1))
          (* (* 5 2) (* 5 2)))
     < src..

     followed by the reductions

     ..srci > scheme
       > (+ (* 6 6)
       ^    (* 10 10))
       > (+ 36 100)
       136
     < srci..

     This gives the same answer as our previous evaluation model, but the process
     is different. In particular, the evaluations of @c[(+ 5 1)] and @c[(* 5 2)]
     are each performed twice here, corresponding to the reduction of the
     expression @c[(* x x)] with @c(x) replaced respectively by @c[(+ 5 1)] and
     @c[(* 5 2)].

     This alternative @"(fully expand and then reduce) evaluation method is known
     as @e(normal-order evaluation), in contrast to the @"(evaluate the arguments
     and then apply) method that the interpreter actually uses, which is called
     @e(applicative-order evaluation). It can be shown that, for procedure
     applications that can be modeled using substitution (including all the
     procedures in the first two chapters of this book) and that yield legitimate
     values, normal-order and applicative-order evaluation produce the same value.
     (See @l(#Exercise 1.5) for an instance of an @"(illegitimate) value where
     normal-order and applicative-order evaluation do not give the same result.)

     Lisp uses applicative-order evaluation, partly because of the additional
     efficiency obtained from avoiding multiple evaluations of expressions such as
     those illustrated with @c[(+ 5 1)] and @c[(* 5 2)] above and, more
     significantly, because normal-order evaluation becomes much more complicated
     to deal with when we leave the realm of procedures that can be modeled by
     substitution. On the other hand, normal-order evaluation can be an extremely
     valuable tool, and we will investigate some of its implications in @l(#Chapter
     3) and @l(#Chapter 4).@n(16)

*** 1.1.6 <> Conditional Expressions and Predicates

    The expressive power of the class of procedures that we can define at this
    point is very limited, because we have no way to make tests and to perform
    different operations depending on the result of a test. For instance, we
    cannot define a procedure that computes the absolute value of a number by
    testing whether the number is positive, negative, or zero and taking different
    actions in the different cases according to the rule

    ..example >
             ╭
             │   x  if x > 0
      │x│ = <    0  if x = 0
             │  −x  if x < 0
             ╰
    < example..

    This construct is called a @e(case analysis), and there is a special form in
    Lisp for notating such a case analysis. It is called @c(cond) (which stands
    for @"(conditional)), and it is used as follows:

    ..src > scheme
      (define (abs x)
        (cond ((> x 0) x)
              ((= x 0) 0)
              ((< x 0) (- x))))
    < src..

    The general form of a conditional expression is

    ..src > scheme
      (cond (⟨p₁⟩ ⟨e₁⟩)
            (⟨p₂⟩ ⟨e₂⟩)
            ;; …
            (⟨pₙ⟩ ⟨eₙ⟩))
    < src..

    consisting of the symbol @c(cond) followed by parenthesized pairs of
    expressions

    ..src > scheme
      (⟨p⟩ ⟨e⟩)
    < src..

    called @e(clauses). The first expression in each pair is a @e(predicate)––that
    is, an expression whose value is interpreted as either true or false.@n(17)
    Conditional expressions are evaluated as follows. The predicate @m[⟨p₁⟩] is
    evaluated first. If its value is false, then @m[⟨p₂⟩] is evaluated. If
    @m[⟨p₂⟩]'s value is also false, then @m[⟨p₃⟩] is evaluated. This process
    continues until a predicate is found whose value is true, in which case the
    interpreter returns the value of the corresponding @e(consequent expression)
    @m[⟨e⟩] of the clause as the value of the conditional expression.  If none of
    the @m[⟨p⟩]'s is found to be true, the value of the @c(cond) is undefined.

    The word @e(predicate) is used for procedures that return true or false, as
    well as for expressions that evaluate to true or false. The absolute-value
    procedure @c(abs) makes use of the primitive predicates @c(>), @c(<), and
    @c(=).@n(18) These take two numbers as arguments and test whether the first
    number is, respectively, greater than, less than, or equal to the second
    number, returning true or false accordingly.

    Another way to write the absolute-value procedure is

    ..src > scheme
      (define (abs x)
        (cond ((< x 0) (- x))
              (else x)))
    < src..

    which could be expressed in English as @"(If @m(x) is less than zero return
    @m(-x); otherwise return @m(x).)  @c(else) is a special symbol that can be
    used in place of the @m[⟨p⟩] in the final clause of a @c(cond). This causes
    the @c(cond) to return as its value the value of the corresponding @m[⟨e⟩]
    whenever all previous clauses have been bypassed. In fact, any expression that
    always evaluates to a true value could be used as the @m[⟨p⟩] here.

    Here is yet another way to write the absolute-value procedure:

    ..src > scheme
      (define (abs x)
        (if (< x 0)
            (- x)
            x))
    < src..

    This uses the special form @c(if), a restricted type of conditional that can
    be used when there are precisely two cases in the case analysis. The general
    form of an @c(if) expression is

    ..src > scheme
      (if ⟨predicate⟩ ⟨consequent⟩ ⟨alternative⟩)
    < src..

    To evaluate an @c(if) expression, the interpreter starts by evaluating the
    @c[(predicate)] part of the expression. If the @c[(predicate)] evaluates to a
    true value, the interpreter then evaluates the @c[(consequent)] and returns
    its value. Otherwise it evaluates the @c[(alternative)] and returns its
    value.@n(19)

    In addition to primitive predicates such as @c(<), @c(=), and @c(>), there are
    logical composition operations, which enable us to construct compound
    predicates. The three most frequently used are these:

    - @c[(and ⟨e₁⟩ … ⟨eₙ⟩)]

      The interpreter evaluates the expressions @c[(e)] one at a time, in
      left-to-right order. If any @c[(e)] evaluates to false, the value of the
      @c(and) expression is false, and the rest of the @c[(e)]'s are not
      evaluated. If all @c[(e)]'s evaluate to true values, the value of the
      @c(and) expression is the value of the last one.

    - @c[(or ⟨e₁⟩ … ⟨eₙ⟩)]

      The interpreter evaluates the expressions @c[(e)] one at a time, in
      left-to-right order. If any @c[(e)] evaluates to a true value, that value is
      returned as the value of the @c(or) expression, and the rest of the
      @c[(e)]'s are not evaluated. If all @c[(e)]'s evaluate to false, the value
      of the @c(or) expression is false.

    - @c[(not ⟨e⟩)]

      The value of a @c(not) expression is true when the expression @c[(e)]
      evaluates to false, and false otherwise.


    Notice that @c(and) and @c(or) are special forms, not procedures, because the
    subexpressions are not necessarily all evaluated. @c(Not) is an ordinary
    procedure.

    As an example of how these are used, the condition that a number @m(x) be in
    the range @m(5 < x < 10) may be expressed as

    ..src > scheme
      (and (> x 5) (< x 10))
    < src..

    As another example, we can define a predicate to test whether one number is
    greater than or equal to another as

    ..src > scheme
      (define (>= x y)
        (or (> x y) (= x y)))
    < src..

    or alternatively as

    ..src > scheme
      (define (>= x y)
        (not (< x y)))
    < src..

    :: @t(Exercise 1.1) :: Below is a sequence of expressions.  What is the result
       printed by the interpreter in response to each expression?  Assume that the
       sequence is to be evaluated in the order in which it is presented.

       ..src > scheme
         10
         (+ 5 3 4)
         (- 9 1)
         (/ 6 2)
         (+ (* 2 4) (- 4 6))
         (define a 3)
         (define b (+ a 1))
         (+ a b (* a b))
         (= a b)
         (if (and (> b a) (< b (* a b)))
             b
             a)
         (cond ((= a 4) 6)
               ((= b 4) (+ 6 7 a))
               (else 25))
         (+ 2 (if (> b a) b a))
         (* (cond ((> a b) a)
                  ((< a b) b)
                  (else -1))
            (+ a 1))
       < src..


    :: @t(Exercise 1.2) :: Translate the following expression into prefix form:

       ..example >
         5 + 4 + (2 − (3 − (6 + 4/5)))
         -----------------------------
                3(6 − 2)(2 − 7)
       < example..

    :: @t(Exercise 1.3) :: Define a procedure that takes three numbers as
       arguments and returns the sum of the squares of the two larger numbers.


    :: @t(Exercise 1.4) :: Observe that our model of evaluation allows for
       combinations whose operators are compound expressions. Use this observation
       to describe the behavior of the following procedure:

       ..src > scheme
         (define (a-plus-abs-b a b)
           ((if (> b 0) + -) a b))
       < src..

    :: @t(Exercise 1.5) :: Ben Bitdiddle has invented a test to determine whether
       the interpreter he is faced with is using applicative-order evaluation or
       normal-order evaluation. He defines the following two procedures:

       ..src > scheme
         (define (p) (p))

         (define (test x y)
           (if (= x 0)
               0
               y))
       < src..

       Then he evaluates the expression

       ..src > scheme
         (test 0 (p))
       < src..

       What behavior will Ben observe with an interpreter that uses
       applicative-order evaluation?  What behavior will he observe with an
       interpreter that uses normal-order evaluation?  Explain your
       answer. (Assume that the evaluation rule for the special form @c(if) is the
       same whether the interpreter is using normal or applicative order: The
       predicate expression is evaluated first, and the result determines whether
       to evaluate the consequent or the alternative expression.)

*** 1.1.7 <> Example: Square Roots by Newton's Method

    Procedures, as introduced above, are much like ordinary mathematical
    functions.  They specify a value that is determined by one or more
    parameters. But there is an important difference between mathematical
    functions and computer procedures. Procedures must be effective.

    As a case in point, consider the problem of computing square roots. We can
    define the square-root function as

    ..example >
      √x = the y such that y ≥ 0 and y² = x
    < example..

    This describes a perfectly legitimate mathematical function. We could use it
    to recognize whether one number is the square root of another, or to derive
    facts about square roots in general. On the other hand, the definition does
    not describe a procedure. Indeed, it tells us almost nothing about how to
    actually find the square root of a given number. It will not help matters to
    rephrase this definition in pseudo-Lisp:

    ..src > scheme
      (define (sqrt x)
        (the y (and (>= y 0)
                    (= (square y) x))))
    < src..

    This only begs the question.

    The contrast between function and procedure is a reflection of the general
    distinction between describing properties of things and describing how to do
    things, or, as it is sometimes referred to, the distinction between
    declarative knowledge and imperative knowledge. In mathematics we are usually
    concerned with declarative (what is) descriptions, whereas in computer science
    we are usually concerned with imperative (how to) descriptions.@n(20)

    How does one compute square roots?  The most common way is to use Newton's
    method of successive approximations, which says that whenever we have a guess
    @m(y) for the value of the square root of a number @m(x), we can perform a
    simple manipulation to get a better guess (one closer to the actual square
    root) by averaging @m(y) with @m(x / y).@n(21) For example, we can compute the
    square root of 2 as follows.  Suppose our initial guess is 1:

    ..example >
      Guess     Quotient      Average

      1         (2/1)  = 2    ((2 + 1)/2)  = 1.5

      1.5       (2/1.5)       ((1.3333 + 1.5)/2)
                  = 1.3333      = 1.4167

      1.4167    (2/1.4167)    ((1.4167 + 1.4118)/2)
                  = 1.4118      = 1.4142

      1.4142    ...           ...
    < example..

    Continuing this process, we obtain better and better approximations to the
    square root.

    Now let's formalize the process in terms of procedures. We start with a value
    for the radicand (the number whose square root we are trying to compute) and a
    value for the guess. If the guess is good enough for our purposes, we are
    done; if not, we must repeat the process with an improved guess. We write this
    basic strategy as a procedure:

    ..src > scheme
      (define (sqrt-iter guess x)
        (if (good-enough? guess x)
            guess
            (sqrt-iter (improve guess x) x)))
    < src..

    A guess is improved by averaging it with the quotient of the radicand and the
    old guess:

    ..src > scheme
      (define (improve guess x)
        (average guess (/ x guess)))
    < src..

    where

    ..src > scheme
      (define (average x y)
        (/ (+ x y) 2))
    < src..

    We also have to say what we mean by @"(good enough.)  The following will do
    for illustration, but it is not really a very good test. (See @l(#Exercise
    1.7).)  The idea is to improve the answer until it is close enough so that its
    square differs from the radicand by less than a predetermined tolerance (here
    0.001):@n(22)

    ..src > scheme
      (define (good-enough? guess x)
        (< (abs (- (square guess) x)) 0.001))
    < src..

    Finally, we need a way to get started. For instance, we can always guess that
    the square root of any number is 1:@n(23)

    ..src > scheme
      (define (sqrt x)
        (sqrt-iter 1.0 x))
    < src..

    If we type these definitions to the interpreter, we can use @c(sqrt) just as
    we can use any procedure:

    ..srci > scheme
      > (sqrt 9)
      3.00009155413138
      > (sqrt (+ 100 37))
      11.704699917758145
      > (sqrt (+ (sqrt 2) (sqrt 3)))
      1.7739279023207892
      > (square (sqrt 1000))
      1000.000369924366
    < srci..

    The @c(sqrt) program also illustrates that the simple procedural language we
    have introduced so far is sufficient for writing any purely numerical program
    that one could write in, say, C or Pascal. This might seem surprising, since
    we have not included in our language any iterative (looping) constructs that
    direct the computer to do something over and over again. @c(Sqrt-iter), on the
    other hand, demonstrates how iteration can be accomplished using no special
    construct other than the ordinary ability to call a procedure.@n(24)

    :: @t(Exercise 1.6) :: Alyssa P. Hacker doesn't see why @c(if) needs to be
       provided as a special form. @"(Why can't I just define it as an ordinary
       procedure in terms of @c(cond)?) she asks. Alyssa's friend Eva Lu Ator
       claims this can indeed be done, and she defines a new version of @c(if):

       ..src > scheme
         (define (new-if predicate
                         then-clause
                         else-clause)
           (cond (predicate then-clause)
                 (else else-clause)))
       < src..

       Eva demonstrates the program for Alyssa:

       ..srci > scheme
         > (new-if (= 2 3) 0 5)
         5
         > (new-if (= 1 1) 0 5)
         0
       < srci..

       Delighted, Alyssa uses @c(new-if) to rewrite the square-root program:

       ..src > scheme
         (define (sqrt-iter guess x)
           (new-if (good-enough? guess x)
                   guess
                   (sqrt-iter (improve guess x) x)))
       < src..

       What happens when Alyssa attempts to use this to compute square roots?
       Explain.

    :: @t(Exercise 1.7) :: The @c(good-enough?) test used in computing square
       roots will not be very effective for finding the square roots of very small
       numbers. Also, in real computers, arithmetic operations are almost always
       performed with limited precision. This makes our test inadequate for very
       large numbers. Explain these statements, with examples showing how the test
       fails for small and large numbers. An alternative strategy for implementing
       @c(good-enough?) is to watch how @c(guess) changes from one iteration to
       the next and to stop when the change is a very small fraction of the
       guess. Design a square-root procedure that uses this kind of end test. Does
       this work better for small and large numbers?

    :: @t(Exercise 1.8) :: Newton's method for cube roots is based on the fact
       that if @m(y) is an approximation to the cube root of @m(x), then a better
       approximation is given by the value

       ..example >
         x/y² + 2y
         ----------
             3
       < example..

       Use this formula to implement a cube-root procedure analogous to the
       square-root procedure. (In @l(#1.3.4) we will see how to implement Newton's
       method in general as an abstraction of these square-root and cube-root
       procedures.)

*** 1.1.8 <> Procedures as Black-Box Abstractions

    @c(Sqrt) is our first example of a process defined by a set of mutually
    defined procedures. Notice that the definition of @c(sqrt-iter) is
    @e(recursive); that is, the procedure is defined in terms of itself. The idea
    of being able to define a procedure in terms of itself may be disturbing; it
    may seem unclear how such a @"(circular) definition could make sense at all,
    much less specify a well-defined process to be carried out by a computer. This
    will be addressed more carefully in @l(#1.2). But first let's consider some
    other important points illustrated by the @c(sqrt) example.

    Observe that the problem of computing square roots breaks up naturally into a
    number of subproblems: how to tell whether a guess is good enough, how to
    improve a guess, and so on. Each of these tasks is accomplished by a separate
    procedure. The entire @c(sqrt) program can be viewed as a cluster of
    procedures (shown in @l(#Figure 1.2)) that mirrors the decomposition of the
    problem into subproblems.

    ..figure > @t(Figure 1.2) Procedural decomposition of the @c(sqrt) program.

      ..art >
                      sqrt
                       |
                   sqrt-iter
                   /       \
             good-enough   improve
             /         \         \
        square         abs       average
      < art..

@   ..img > img/chap1/Fig1.2.std.svg

    The importance of this decomposition strategy is not simply that one is
    dividing the program into parts. After all, we could take any large program
    and divide it into parts––the first ten lines, the next ten lines, the next
    ten lines, and so on. Rather, it is crucial that each procedure accomplishes
    an identifiable task that can be used as a module in defining other
    procedures.  For example, when we define the @c(good-enough?) procedure in
    terms of @c(square), we are able to regard the @c(square) procedure as a
    @"(black box.)  We are not at that moment concerned with @e(how) the procedure
    computes its result, only with the fact that it computes the square. The
    details of how the square is computed can be suppressed, to be considered at a
    later time. Indeed, as far as the @c(good-enough?) procedure is concerned,
    @c(square) is not quite a procedure but rather an abstraction of a procedure,
    a so-called @e(procedural abstraction). At this level of abstraction, any
    procedure that computes the square is equally good.

    Thus, considering only the values they return, the following two procedures
    for squaring a number should be indistinguishable. Each takes a numerical
    argument and produces the square of that number as the value.@n(25)

    ..src > scheme
      (define (square x) (* x x))

      (define (square x)
        (exp (double (log x))))

      (define (double x) (+ x x))
    < src..

    So a procedure definition should be able to suppress detail. The users of the
    procedure may not have written the procedure themselves, but may have obtained
    it from another programmer as a black box. A user should not need to know how
    the procedure is implemented in order to use it.

**** Local names

     One detail of a procedure's implementation that should not matter to the user
     of the procedure is the implementer's choice of names for the procedure's
     formal parameters. Thus, the following procedures should not be
     distinguishable:

     ..src > scheme
       (define (square x) (* x x))
       (define (square y) (* y y))
     < src..

     This principle––that the meaning of a procedure should be independent of the
     parameter names used by its author––seems on the surface to be self-evident,
     but its consequences are profound. The simplest consequence is that the
     parameter names of a procedure must be local to the body of the procedure. For
     example, we used @c(square) in the definition of @c(good-enough?) in our
     square-root procedure:

     ..src > scheme
       (define (good-enough? guess x)
         (< (abs (- (square guess) x)) 0.001))
     < src..

     The intention of the author of @c(good-enough?) is to determine if the square
     of the first argument is within a given tolerance of the second argument. We
     see that the author of @c(good-enough?) used the name @c(guess) to refer to
     the first argument and @c(x) to refer to the second argument. The argument of
     @c(square) is @c(guess). If the author of @c(square) used @c(x) (as above) to
     refer to that argument, we see that the @c(x) in @c(good-enough?) must be a
     different @c(x) than the one in @c(square). Running the procedure @c(square)
     must not affect the value of @c(x) that is used by @c(good-enough?), because
     that value of @c(x) may be needed by @c(good-enough?) after @c(square) is done
     computing.

     If the parameters were not local to the bodies of their respective procedures,
     then the parameter @c(x) in @c(square) could be confused with the parameter
     @c(x) in @c(good-enough?), and the behavior of @c(good-enough?) would depend
     upon which version of @c(square) we used.  Thus, @c(square) would not be the
     black box we desired.

     A formal parameter of a procedure has a very special role in the procedure
     definition, in that it doesn't matter what name the formal parameter has. Such
     a name is called a @e(bound variable), and we say that the procedure
     definition @e(binds) its formal parameters. The meaning of a procedure
     definition is unchanged if a bound variable is consistently renamed throughout
     the definition.@n(26) If a variable is not bound, we say that it is @e(free).
     The set of expressions for which a binding defines a name is called the
     @e(scope) of that name. In a procedure definition, the bound variables
     declared as the formal parameters of the procedure have the body of the
     procedure as their scope.

     In the definition of @c(good-enough?) above, @c(guess) and @c(x) are bound
     variables but @c(<), @c(-), @c(abs), and @c(square) are free.  The meaning of
     @c(good-enough?) should be independent of the names we choose for @c(guess)
     and @c(x) so long as they are distinct and different from @c(<), @c(-),
     @c(abs), and @c(square). (If we renamed @c(guess) to @c(abs) we would have
     introduced a bug by @e(capturing) the variable @c(abs). It would have changed
     from free to bound.)  The meaning of @c(good-enough?) is not independent of
     the names of its free variables, however. It surely depends upon the fact
     (external to this definition) that the symbol @c(abs) names a procedure for
     computing the absolute value of a number. @c(good-enough?) will compute a
     different function if we substitute @c(cos) for @c(abs) in its definition.

**** Internal definitions and block structure

     We have one kind of name isolation available to us so far: The formal
     parameters of a procedure are local to the body of the procedure. The
     square-root program illustrates another way in which we would like to control
     the use of names. The existing program consists of separate procedures:

     ..src > scheme
       (define (sqrt x)
         (sqrt-iter 1.0 x))

       (define (sqrt-iter guess x)
         (if (good-enough? guess x)
             guess
             (sqrt-iter (improve guess x) x)))

       (define (good-enough? guess x)
         (< (abs (- (square guess) x)) 0.001))

       (define (improve guess x)
         (average guess (/ x guess)))
     < src..

     The problem with this program is that the only procedure that is important to
     users of @c(sqrt) is @c(sqrt). The other procedures (@c(sqrt-iter),
     @c(good-enough?), and @c(improve)) only clutter up their minds. They may not
     define any other procedure called @c(good-enough?) as part of another program
     to work together with the square-root program, because @c(sqrt) needs it. The
     problem is especially severe in the construction of large systems by many
     separate programmers. For example, in the construction of a large library of
     numerical procedures, many numerical functions are computed as successive
     approximations and thus might have procedures named @c(good-enough?) and
     @c(improve) as auxiliary procedures. We would like to localize the
     subprocedures, hiding them inside @c(sqrt) so that @c(sqrt) could coexist with
     other successive approximations, each having its own private @c(good-enough?)
     procedure. To make this possible, we allow a procedure to have internal
     definitions that are local to that procedure. For example, in the square-root
     problem we can write

     ..src > scheme
       (define (sqrt x)
         (define (good-enough? guess x)
           (< (abs (- (square guess) x)) 0.001))
         (define (improve guess x)
           (average guess (/ x guess)))
         (define (sqrt-iter guess x)
           (if (good-enough? guess x)
               guess
               (sqrt-iter (improve guess x) x)))
         (sqrt-iter 1.0 x))
     < src..

     Such nesting of definitions, called @e(block structure), is basically the
     right solution to the simplest name-packaging problem. But there is a better
     idea lurking here. In addition to internalizing the definitions of the
     auxiliary procedures, we can simplify them. Since @c(x) is bound in the
     definition of @c(sqrt), the procedures @c(good-enough?), @c(improve), and
     @c(sqrt-iter), which are defined internally to @c(sqrt), are in the scope of
     @c(x). Thus, it is not necessary to pass @c(x) explicitly to each of these
     procedures. Instead, we allow @c(x) to be a free variable in the internal
     definitions, as shown below. Then @c(x) gets its value from the argument with
     which the enclosing procedure @c(sqrt) is called. This discipline is called
     @e(lexical scoping).@n(27)

     ..src > scheme
       (define (sqrt x)
         (define (good-enough? guess)
           (< (abs (- (square guess) x)) 0.001))
         (define (improve guess)
           (average guess (/ x guess)))
         (define (sqrt-iter guess)
           (if (good-enough? guess)
               guess
               (sqrt-iter (improve guess))))
         (sqrt-iter 1.0))
     < src..

     We will use block structure extensively to help us break up large programs
     into tractable pieces.@n(28) The idea of block structure originated with the
     programming language Algol 60. It appears in most advanced programming
     languages and is an important tool for helping to organize the construction of
     large programs.

** 1.2 <> Procedures and the Processes They Generate

   We have now considered the elements of programming: We have used primitive
   arithmetic operations, we have combined these operations, and we have
   abstracted these composite operations by defining them as compound procedures.
   But that is not enough to enable us to say that we know how to program. Our
   situation is analogous to that of someone who has learned the rules for how
   the pieces move in chess but knows nothing of typical openings, tactics, or
   strategy. Like the novice chess player, we don't yet know the common patterns
   of usage in the domain. We lack the knowledge of which moves are worth making
   (which procedures are worth defining). We lack the experience to predict the
   consequences of making a move (executing a procedure).

   The ability to visualize the consequences of the actions under consideration
   is crucial to becoming an expert programmer, just as it is in any synthetic,
   creative activity. In becoming an expert photographer, for example, one must
   learn how to look at a scene and know how dark each region will appear on a
   print for each possible choice of exposure and development conditions. Only
   then can one reason backward, planning framing, lighting, exposure, and
   development to obtain the desired effects. So it is with programming, where we
   are planning the course of action to be taken by a process and where we
   control the process by means of a program. To become experts, we must learn to
   visualize the processes generated by various types of procedures. Only after
   we have developed such a skill can we learn to reliably construct programs
   that exhibit the desired behavior.

   A procedure is a pattern for the @e(local evolution) of a computational
   process. It specifies how each stage of the process is built upon the previous
   stage. We would like to be able to make statements about the overall, or
   @e(global), behavior of a process whose local evolution has been specified by
   a procedure. This is very difficult to do in general, but we can at least try
   to describe some typical patterns of process evolution.

   In this section we will examine some common @"(shapes) for processes generated
   by simple procedures. We will also investigate the rates at which these
   processes consume the important computational resources of time and space. The
   procedures we will consider are very simple. Their role is like that played by
   test patterns in photography: as oversimplified prototypical patterns, rather
   than practical examples in their own right.

*** 1.2.1 <> Linear Recursion and Iteration

    We begin by considering the factorial function, defined by

    ..example >
      n! = n ⋅ (n − 1) ⋅ (n − 2) ⋯ 3 ⋅ 2 ⋅ 1
    < example..

    There are many ways to compute factorials. One way is to make use of the
    observation that @m(n!) is equal to @m(n) times @m[(n - 1)!] for any positive
    integer @m(n):

    ..example >
      n! = n ⋅ [(n − 1) ⋅ (n − 2) ⋯ 3 ⋅ 2 ⋅ 1] = n ⋅ (n − 1)!
    < example..

    Thus, we can compute @m(n!) by computing @m[(n - 1)!] and multiplying the
    result by @m[n]. If we add the stipulation that 1! is equal to 1, this
    observation translates directly into a procedure:

    ..src > scheme
      (define (factorial n)
        (if (= n 1)
            1
            (* n (factorial (- n 1)))))
    < src..

    We can use the substitution model of @l(#1.1.5) to watch this procedure in
    action computing 6!, as shown in @l(#Figure 1.3).

    ..figure > @t(Figure 1.3) A linear recursive process for computing 6!.

      ..art >
        (factorial 6)        ----------------
        (* 6 (factorial 5))                   \
        (* 6 (* 5 (factorial 4)))               \
        (* 6 (* 5 (* 4 (factorial 3))))           \
        (* 6 (* 5 (* 4 (* 3 (factorial 2)))))       \
        (* 6 (* 5 (* 4 (* 3 (* 2 (factorial 1))))))  |
        (* 6 (* 5 (* 4 (* 3 (* 2 1)))))             /
        (* 6 (* 5 (* 4 (* 3 2))))                 /
        (* 6 (* 5 (* 4 6)))                     /
        (* 6 (* 5 24))                        /
        (* 6 120)                           /
        720          <---------------------
      < art..

@   ..img > img/chap1/Fig1.3d.std.svg

    Now let's take a different perspective on computing factorials. We could
    describe a rule for computing @m[n!] by specifying that we first multiply 1 by
    2, then multiply the result by 3, then by 4, and so on until we reach @m[n].
    More formally, we maintain a running product, together with a counter that
    counts from 1 up to @m[n]. We can describe the computation by saying that the
    counter and the product simultaneously change from one step to the next
    according to the rule

    ..example >
      product ← counter * product
      counter ← counter + 1
    < example..

    and stipulating that @m[n!] is the value of the product when the counter
    exceeds @m[n].

    Once again, we can recast our description as a procedure for computing
    factorials:@n(29)

    ..src > scheme
      (define (factorial n)
        (fact-iter 1 1 n))

      (define (fact-iter product counter max-count)
        (if (> counter max-count)
            product
            (fact-iter (* counter product)
                       (+ counter 1)
                       max-count)))
    < src..

    As before, we can use the substitution model to visualize the process of
    computing 6!, as shown in @l(#Figure 1.4).

    ..figure > @t(Figure 1.4) A linear iterative process for computing 6!.

      ..art >
        (factorial 6)   ------.
        (fact-iter   1 1 6)   |
        (fact-iter   1 2 6)   |
        (fact-iter   2 3 6)   |
        (fact-iter   6 4 6)   |
        (fact-iter  24 5 6)   |
        (fact-iter 120 6 6)   |
        (fact-iter 720 7 6)  /
        720      <-----------
      < art..

@   ..img > img/chap1/Fig1.4d.std.svg

    Compare the two processes. From one point of view, they seem hardly different
    at all. Both compute the same mathematical function on the same domain, and
    each requires a number of steps proportional to @m(n) to compute @m(n!).
    Indeed, both processes even carry out the same sequence of multiplications,
    obtaining the same sequence of partial products. On the other hand, when we
    consider the @"(shapes) of the two processes, we find that they evolve quite
    differently.

    Consider the first process. The substitution model reveals a shape of
    expansion followed by contraction, indicated by the arrow in @l(#Figure 1.3).
    The expansion occurs as the process builds up a chain of @e(deferred
    operations) (in this case, a chain of multiplications). The contraction occurs
    as the operations are actually performed. This type of process, characterized
    by a chain of deferred operations, is called a @e(recursive process).
    Carrying out this process requires that the interpreter keep track of the
    operations to be performed later on. In the computation of @m[n!], the length
    of the chain of deferred multiplications, and hence the amount of information
    needed to keep track of it, grows linearly with @m[n] (is proportional to
    @m[n]), just like the number of steps. Such a process is called a @e(linear
    recursive process).

    By contrast, the second process does not grow and shrink. At each step, all we
    need to keep track of, for any @m[n], are the current values of the variables
    @c(product), @c(counter), and @c(max-count). We call this an @e(iterative
    process). In general, an iterative process is one whose state can be
    summarized by a fixed number of @e(state variables), together with a fixed
    rule that describes how the state variables should be updated as the process
    moves from state to state and an (optional) end test that specifies conditions
    under which the process should terminate. In computing @m[n!], the number of
    steps required grows linearly with @m[n]. Such a process is called a @e(linear
    iterative process).

    The contrast between the two processes can be seen in another way. In the
    iterative case, the program variables provide a complete description of the
    state of the process at any point. If we stopped the computation between
    steps, all we would need to do to resume the computation is to supply the
    interpreter with the values of the three program variables. Not so with the
    recursive process. In this case there is some additional @"(hidden)
    information, maintained by the interpreter and not contained in the program
    variables, which indicates @"(where the process is) in negotiating the chain
    of deferred operations. The longer the chain, the more information must be
    maintained.@n(30)

    In contrasting iteration and recursion, we must be careful not to confuse the
    notion of a recursive @e(process) with the notion of a recursive
    @e(procedure). When we describe a procedure as recursive, we are referring to
    the syntactic fact that the procedure definition refers (either directly or
    indirectly) to the procedure itself. But when we describe a process as
    following a pattern that is, say, linearly recursive, we are speaking about
    how the process evolves, not about the syntax of how a procedure is
    written. It may seem disturbing that we refer to a recursive procedure such as
    @c(fact-iter) as generating an iterative process. However, the process really
    is iterative: Its state is captured completely by its three state variables,
    and an interpreter need keep track of only three variables in order to execute
    the process.

    One reason that the distinction between process and procedure may be confusing
    is that most implementations of common languages (including Ada, Pascal, and
    C) are designed in such a way that the interpretation of any recursive
    procedure consumes an amount of memory that grows with the number of procedure
    calls, even when the process described is, in principle, iterative. As a
    consequence, these languages can describe iterative processes only by
    resorting to special-purpose @"(looping constructs) such as @c(do),
    @c(repeat), @c(until), @c(for), and @c(while). The implementation of Scheme we
    shall consider in @l(#Chapter 5) does not share this defect. It will execute
    an iterative process in constant space, even if the iterative process is
    described by a recursive procedure. An implementation with this property is
    called @e(tail-recursive). With a tail-recursive implementation, iteration can
    be expressed using the ordinary procedure call mechanism, so that special
    iteration constructs are useful only as syntactic sugar.@n(31)

    :: @t(Exercise 1.9) :: Each of the following two procedures defines a method
       for adding two positive integers in terms of the procedures @c(inc), which
       increments its argument by 1, and @c(dec), which decrements its argument
       by 1.

       ..src > scheme
         (define (+ a b)
           (if (= a 0)
               b
               (inc (+ (dec a) b))))

         (define (+ a b)
           (if (= a 0)
               b
               (+ (dec a) (inc b))))
       < src..

       Using the substitution model, illustrate the process generated by each
       procedure in evaluating @c[(+ 4 5)]. Are these processes iterative or
       recursive?


    :: @t(Exercise 1.10) :: The following procedure computes a mathematical
       function called Ackermann's function.

       ..src > scheme
         (define (A x y)
           (cond ((= y 0) 0)
                 ((= x 0) (* 2 y))
                 ((= y 1) 2)
                 (else (A (- x 1)
                          (A x (- y 1))))))
       < src..

       What are the values of the following expressions?

       ..src > scheme
         (A 1 10)
         (A 2 4)
         (A 3 3)
       < src..

       Consider the following procedures, where @c(A) is the procedure defined
       above:

       ..src > scheme
         (define (f n) (A 0 n))
         (define (g n) (A 1 n))
         (define (h n) (A 2 n))
         (define (k n) (* 5 n n))
       < src..

       Give concise mathematical definitions for the functions computed by the
       procedures @c(f), @c(g), and @c(h) for positive integer values of
       @m[n]. For example, @c[(k n)] computes @m[5n²].

*** 1.2.2 <> Tree Recursion

    Another common pattern of computation is called @e(tree recursion). As an
    example, consider computing the sequence of Fibonacci numbers, in which each
    number is the sum of the preceding two:

    ..center >
      0, 1, 1, 2, 3, 5, 8, 13, 21, ….

    In general, the Fibonacci numbers can be defined by the rule

    ..example >
                ╭
                │ 0                        if n = 0
      Fib(n) = <  1                        if n = 1
                │ Fib(n − 1) + Fib(n − 2)  otherwise
                ╰
    < example..

    We can immediately translate this definition into a recursive procedure for
    computing Fibonacci numbers:

    ..src > scheme
      (define (fib n)
        (cond ((= n 0) 0)
              ((= n 1) 1)
              (else (+ (fib (- n 1))
                       (fib (- n 2))))))
    < src..

    Consider the pattern of this computation. To compute @c[(fib 5)], we compute
    @c[(fib 4)] and @c[(fib 3)]. To compute @c[(fib 4)], we compute @c[(fib 3)]
    and @c[(fib 2)]. In general, the evolved process looks like a tree, as shown
    in @l(#Figure 1.5). Notice that the branches split into two at each level
    (except at the bottom); this reflects the fact that the @c(fib) procedure
    calls itself twice each time it is invoked.

    ..figure > @t(Figure 1.5) The tree-recursive process generated in computing @c[(fib 5)].

      ..art >

                           ..<............ fib5   <..........
                        ...     ___________/  \___________   .
                     ...       /       . .....            \    .
                   ..       fib4     .        . > . .     fib3  .
                 ..     ____/. \____  ..             .  __/  \__  .
               ..      /  . .  ..   \    .        ..   /  . .   \   .
             ..     fib3 .       .  fib2 .        . fib2 .   .  fib1 .
           ..      / . \  .     .   /  \  .      .  /  \ ...  .  |  .
         ..       / . . \   .  .   /  . \   .  .   / .  \   .  . 1 .
        .      fib2 . . fib1.  .fib1 .  fib0 . .fib1. . fib0 .  .  .
        .      /  \  . . |  .  . |  .  . |   . . |   . . |   .   .>
        V     /  . \   . 1  .  . 1  .  . 0  .  . 1  .  . 0  ..
        .  fib1 .. fib0..  .   .   .   .   .   .   .   ..  .
        .   |  .  . |  . .>     .>.     . .     .>.      .>
        .   1 .   . 0  .
         .   .     .  .
          .>.       ..
      < art..

@   ..img > img/chap1/Fig1.5d.std.svg

    This procedure is instructive as a prototypical tree recursion, but it is a
    terrible way to compute Fibonacci numbers because it does so much redundant
    computation. Notice in @l(#Figure 1.5) that the entire computation of
    @c[(fib 3)]––almost half the work––is duplicated. In fact, it is not hard
    to show that the number of times the procedure will compute @c[(fib 1)] or
    @c[(fib 0)] (the number of leaves in the above tree, in general) is
    precisely @m[Fib(n+1)]. To get an idea of how bad this is, one can
    show that the value of @m[Fib(n)] grows exponentially with @m[n]. More
    precisely (see @l(#Exercise 1.13)), @m[Fib(n)] is the closest integer
    to @m[φⁿ / √5], where

    ..example >
      φ = (1 + √5)/2 ≈ 1.6180
    < example..

    is the @e(golden ratio), which satisfies the equation

    ..example >
      φ² = φ + 1
    < example..

    Thus, the process uses a number of steps that grows exponentially with the
    input. On the other hand, the space required grows only linearly with the
    input, because we need keep track only of which nodes are above us in the tree
    at any point in the computation. In general, the number of steps required by a
    tree-recursive process will be proportional to the number of nodes in the
    tree, while the space required will be proportional to the maximum depth of
    the tree.

    We can also formulate an iterative process for computing the Fibonacci
    numbers.  The idea is to use a pair of integers @m[a] and @m[b], initialized
    to @m[Fib(1) = 1] and @m[Fib(0) = 0], and to repeatedly apply the simultaneous
    transformations

    ..example >
      a ← a + b
      b ← a
    < example..

    It is not hard to show that, after applying this transformation @m[n] times,
    @m[a] and @m[b] will be equal, respectively, to @m[Fib(n+1)] and
    @m[Fib(n)]. Thus, we can compute Fibonacci numbers iteratively using the
    procedure

    ..src > scheme
      (define (fib n)
        (fib-iter 1 0 n))

      (define (fib-iter a b count)
        (if (= count 0)
            b
            (fib-iter (+ a b) a (- count 1))))
    < src..

    This second method for computing @m[Fib(n)] is a linear iteration. The
    difference in number of steps required by the two methods––one linear in
    @m[n], one growing as fast as @m[Fib(n)] itself––is enormous, even for small
    inputs.

    One should not conclude from this that tree-recursive processes are useless.
    When we consider processes that operate on hierarchically structured data
    rather than numbers, we will find that tree recursion is a natural and
    powerful tool.@n(32) But even in numerical operations, tree-recursive
    processes can be useful in helping us to understand and design programs. For
    instance, although the first @c(fib) procedure is much less efficient than the
    second one, it is more straightforward, being little more than a translation
    into Lisp of the definition of the Fibonacci sequence. To formulate the
    iterative algorithm required noticing that the computation could be recast as
    an iteration with three state variables.

**** Example: Counting change

     It takes only a bit of cleverness to come up with the iterative Fibonacci
     algorithm. In contrast, consider the following problem: How many different
     ways can we make change of $1.00, given half-dollars, quarters, dimes,
     nickels, and pennies?  More generally, can we write a procedure to compute the
     number of ways to change any given amount of money?

     This problem has a simple solution as a recursive procedure. Suppose we think
     of the types of coins available as arranged in some order. Then the following
     relation holds:

     The number of ways to change amount @m[a] using @m[n] kinds of coins equals

     - the number of ways to change amount @m[a] using all but the first kind of
       coin, plus

     - the number of ways to change amount @m[a - d] using all @m[n] kinds of
       coins, where @m[d] is the denomination of the first kind of coin.

     To see why this is true, observe that the ways to make change can be divided
     into two groups: those that do not use any of the first kind of coin, and
     those that do. Therefore, the total number of ways to make change for some
     amount is equal to the number of ways to make change for the amount without
     using any of the first kind of coin, plus the number of ways to make change
     assuming that we do use the first kind of coin. But the latter number is equal
     to the number of ways to make change for the amount that remains after using a
     coin of the first kind.

     Thus, we can recursively reduce the problem of changing a given amount to the
     problem of changing smaller amounts using fewer kinds of coins. Consider this
     reduction rule carefully, and convince yourself that we can use it to describe
     an algorithm if we specify the following degenerate cases:@n(33)

     - If @m[a] is exactly 0, we should count that as 1 way to make change.

     - If @m[a] is less than 0, we should count that as 0 ways to make change.

     - If @m[n] is 0, we should count that as 0 ways to make change.


     We can easily translate this description into a recursive procedure:

     ..src > scheme
       (define (count-change amount)
         (cc amount 5))

       (define (cc amount kinds-of-coins)
         (cond ((= amount 0) 1)
               ((or (< amount 0)
                    (= kinds-of-coins 0))
                0)
               (else
                (+ (cc amount (- kinds-of-coins 1))
                   (cc (- amount (first-denomination
                                  kinds-of-coins))
                       kinds-of-coins)))))

       (define (first-denomination kinds-of-coins)
         (cond ((= kinds-of-coins 1) 1)
               ((= kinds-of-coins 2) 5)
               ((= kinds-of-coins 3) 10)
               ((= kinds-of-coins 4) 25)
               ((= kinds-of-coins 5) 50)))
     < src..

     (The @c(first-denomination) procedure takes as input the number of kinds of
     coins available and returns the denomination of the first kind. Here we are
     thinking of the coins as arranged in order from largest to smallest, but any
     order would do as well.)  We can now answer our original question about
     changing a dollar:

     ..srci > scheme
       > (count-change 100)
       292
     < srci..

     @c(Count-change) generates a tree-recursive process with redundancies similar
     to those in our first implementation of @c(fib). (It will take quite a while
     for that 292 to be computed.)  On the other hand, it is not obvious how to
     design a better algorithm for computing the result, and we leave this problem
     as a challenge. The observation that a tree-recursive process may be highly
     inefficient but often easy to specify and understand has led people to propose
     that one could get the best of both worlds by designing a @"(smart compiler)
     that could transform tree-recursive procedures into more efficient procedures
     that compute the same result.@n(34)

     :: @t(Exercise 1.11) :: A function @m[f] is defined by the rule that @m[f(n) =
        n] if @m[n < 3] and @m[f(n) = f(n-1) + 2f(n-2) + 3f(n-3)] if @m[n ≥
        3]. Write a procedure that computes @m[f] by means of a recursive
        process. Write a procedure that computes @m[f] by means of an iterative
        process.

     :: @t(Exercise 1.12) :: The following pattern of numbers is called @e(Pascal's
        triangle).

        ..example >
                   1
                 1   1
               1   2   1
             1   3   3   1
           1   4   6   4   1
                 . . .
        < example..

        The numbers at the edge of the triangle are all 1, and each number inside
        the triangle is the sum of the two numbers above it.@n(35) Write a
        procedure that computes elements of Pascal's triangle by means of a
        recursive process.

     :: @t(Exercise 1.13) :: Prove that @m[Fib(n)] is the closest integer to @m(φⁿ
        / √5), where @m[φ = (1 + √5) / 2]. Hint: Let @m[ψ = (1 - √5) / 2]. Use
        induction and the definition of the Fibonacci numbers (see @l(#1.2.2)) to
        prove that @m[Fib(n) = (φⁿ - ψⁿ) / √5].

*** 1.2.3 <> Orders of Growth

    The previous examples illustrate that processes can differ considerably in the
    rates at which they consume computational resources. One convenient way to
    describe this difference is to use the notion of @e(order of growth) to obtain
    a gross measure of the resources required by a process as the inputs become
    larger.

    Let @m[n] be a parameter that measures the size of the problem, and let
    @m[R(n)] be the amount of resources the process requires for a problem of size
    @m[n]. In our previous examples we took @m[n] to be the number for which a
    given function is to be computed, but there are other possibilities. For
    instance, if our goal is to compute an approximation to the square root of a
    number, we might take @m[n] to be the number of digits accuracy required. For
    matrix multiplication we might take @m[n] to be the number of rows in the
    matrices. In general there are a number of properties of the problem with
    respect to which it will be desirable to analyze a given process. Similarly,
    @m[R(n)] might measure the number of internal storage registers used, the
    number of elementary machine operations performed, and so on. In computers
    that do only a fixed number of operations at a time, the time required will be
    proportional to the number of elementary machine operations performed.

    We say that @m[R(n)] has order of growth @m[Θ(f(n))], written @m[R(n) =
    Θ(f(n))] (pronounced @"(theta of @m[f(n)]), if there are positive constants
    @m[k₁] and @m[k₂] independent of @m[n] such that @m[k₁ f(n) ≤ R(n) ≤ k₂ f(n)]
    for any sufficiently large value of @m[n]. (In other words, for large @m[n],
    the value @m[R(n)] is sandwiched between @m[k₁ f(n)] and @m[k₂ f(n)].)

    For instance, with the linear recursive process for computing factorial
    described in @l(#1.2.1) the number of steps grows proportionally to the input
    @m[n]. Thus, the steps required for this process grows as @m[Θ(n)]. We also
    saw that the space required grows as @m[Θ(n)]. For the iterative factorial,
    the number of steps is still @m[Θ(n)] but the space is @m[Θ(1)]––that is,
    constant.@n(36) The tree-recursive Fibonacci computation requires @m[Θ(φⁿ)]
    steps and space @m[Θ(n)], where @m(φ) is the golden ratio described in
    @l(#1.2.2).

    Orders of growth provide only a crude description of the behavior of a
    process.  For example, a process requiring @m[n²] steps and a process
    requiring @m[1000n²] steps and a process requiring @m[3n² + 10n + 17] steps
    all have @m[Θ(n²)] order of growth. On the other hand, order of growth
    provides a useful indication of how we may expect the behavior of the process
    to change as we change the size of the problem. For a @m[Θ(n)] (linear)
    process, doubling the size will roughly double the amount of resources
    used. For an exponential process, each increment in problem size will multiply
    the resource utilization by a constant factor. In the remainder of @l(#1.2) we
    will examine two algorithms whose order of growth is logarithmic, so that
    doubling the problem size increases the resource requirement by a constant
    amount.

    :: @t(Exercise 1.14) :: Draw the tree illustrating the process generated by
       the @c(count-change) procedure of @l(#1.2.2) in making change for 11
       cents. What are the orders of growth of the space and number of steps used
       by this process as the amount to be changed increases?

    :: @t(Exercise 1.15) :: The sine of an angle (specified in radians) can be
       computed by making use of the approximation @m(sin x ≈ x) if @m(x) is
       sufficiently small, and the trigonometric identity

       ..example >
                       x          x
         sin x = 3sin --- −4sin³ ---
                       3          3
       < example..

       to reduce the size of the argument of sin. (For purposes of this exercise
       an angle is considered @"(sufficiently small) if its magnitude is not
       greater than 0.1 radians.) These ideas are incorporated in the following
       procedures:

       ..src > scheme
         (define (cube x) (* x x x))
         (define (p x) (- (* 3 x) (* 4 (cube x))))
         (define (sine angle)
            (if (not (> (abs angle) 0.1))
                angle
                (p (sine (/ angle 3.0)))))
       < src..

       1. How many times is the procedure @c(p) applied when @c[(sine 12.15)] is
          evaluated?

       2. What is the order of growth in space and number of steps (as a function
          of @m(a)) used by the process generated by the @c(sine) procedure when
          @c[(sine a)] is evaluated?

*** 1.2.4 <> Exponentiation

    Consider the problem of computing the exponential of a given number. We would
    like a procedure that takes as arguments a base @m[b] and a positive integer
    exponent @m[n] and computes @m[bⁿ]. One way to do this is via the recursive
    definition

    ..example >
      bⁿ = b ⋅ bⁿ⁻¹
      b⁰ = 1
    < example..

    which translates readily into the procedure

    ..src > scheme
      (define (expt b n)
        (if (= n 0)
            1
            (* b (expt b (- n 1)))))
    < src..

    This is a linear recursive process, which requires @m[Θ(n)] steps and @m[Θ(n)]
    space. Just as with factorial, we can readily formulate an equivalent linear
    iteration:

    ..src > scheme
      (define (expt b n)
        (expt-iter b n 1))

      (define (expt-iter b counter product)
        (if (= counter 0)
            product
            (expt-iter b
                       (- counter 1)
                       (* b product))))
    < src..

    This version requires @m[Θ(n)] steps and @m[Θ(1)] space.

    We can compute exponentials in fewer steps by using successive squaring. For
    instance, rather than computing @m(b⁸) as

    ..example >
      b ⋅ (b ⋅ (b ⋅ (b ⋅ (b ⋅ (b ⋅ (b ⋅ b))))))
    < example..

    we can compute it using three multiplications:

    ..example >
      b² = b ⋅ b
      b⁴ = b² ⋅ b²
      b⁸ = b⁴ ⋅ b⁴
    < example..

    This method works fine for exponents that are powers of 2. We can also take
    advantage of successive squaring in computing exponentials in general if we
    use the rule

    ..example >
      bⁿ = (b^(n/2))²    if n is even
      bⁿ = b ⋅ bⁿ⁻¹      if n is odd
    < example..

    We can express this method as a procedure:

    ..src > scheme
      (define (fast-expt b n)
        (cond ((= n 0)
               1)
              ((even? n)
               (square (fast-expt b (/ n 2))))
              (else
               (* b (fast-expt b (- n 1))))))
    < src..

    where the predicate to test whether an integer is even is defined in terms of
    the primitive procedure @c(remainder) by

    ..src > scheme
      (define (even? n)
        (= (remainder n 2) 0))
    < src..

    The process evolved by @c(fast-expt) grows logarithmically with @m(n) in both
    space and number of steps. To see this, observe that computing @m(b²ⁿ) using
    @c(fast-expt) requires only one more multiplication than computing @m(bⁿ). The
    size of the exponent we can compute therefore doubles (approximately) with
    every new multiplication we are allowed. Thus, the number of multiplications
    required for an exponent of @m(n) grows about as fast as the logarithm of
    @m(n) to the base 2. The process has @m[Θ(log n)] growth.@n(37)

    The difference between @m[Θ(log n)] growth and @m[Θ(n)] growth becomes
    striking as @m(n) becomes large. For example, @c(fast-expt) for @m(n) = 1000
    requires only 14 multiplications.@n(38) It is also possible to use the idea of
    successive squaring to devise an iterative algorithm that computes
    exponentials with a logarithmic number of steps (see @l(#Exercise 1.16)),
    although, as is often the case with iterative algorithms, this is not written
    down so straightforwardly as the recursive algorithm.@n(39)

    :: @t(Exercise 1.16) :: Design a procedure that evolves an iterative
       exponentiation process that uses successive squaring and uses a logarithmic
       number of steps, as does @c(fast-expt). (Hint: Using the observation that
       @M[{(b^{n / 2})²} = {(b²)^{n / 2}}], keep, along with the exponent @m(n)
       and the base @m(b), an additional state variable @m(a), and define the
       state transformation in such a way that the product @m(abⁿ) is unchanged
       from state to state. At the beginning of the process @m(a) is taken to be
       1, and the answer is given by the value of @m(a) at the end of the
       process. In general, the technique of defining an @e(invariant quantity)
       that remains unchanged from state to state is a powerful way to think about
       the design of iterative algorithms.)

    :: @t(Exercise 1.17) :: The exponentiation algorithms in this section are
       based on performing exponentiation by means of repeated multiplication. In
       a similar way, one can perform integer multiplication by means of repeated
       addition. The following multiplication procedure (in which it is assumed
       that our language can only add, not multiply) is analogous to the @c(expt)
       procedure:

       ..src > scheme
         (define (* a b)
           (if (= b 0)
               0
               (+ a (* a (- b 1)))))
       < src..

       This algorithm takes a number of steps that is linear in @c(b). Now suppose
       we include, together with addition, operations @c(double), which doubles an
       integer, and @c(halve), which divides an (even) integer by 2. Using these,
       design a multiplication procedure analogous to @c(fast-expt) that uses a
       logarithmic number of steps.

    :: @t(Exercise 1.18) :: Using the results of @l(#Exercise 1.16) and
       @l(#Exercise 1.17), devise a procedure that generates an iterative process
       for multiplying two integers in terms of adding, doubling, and halving and
       uses a logarithmic number of steps.@n(40)

    :: @t(Exercise 1.19) :: There is a clever algorithm for computing the
       Fibonacci numbers in a logarithmic number of steps. Recall the
       transformation of the state variables @m(a) and @m(b) in the @c(fib-iter)
       process of @l(#1.2.2): @m(a ← a + b) and @m(b ← a).  Call this
       transformation @m(T), and observe that applying @m(T) over and over again
       @m(n) times, starting with 1 and 0, produces the pair @m[Fib(n+1)] and
       @m[Fib(n)]. In other words, the Fibonacci numbers are produced by applying
       @m(Tⁿ), the @m(nᵗʰ) power of the transformation @m(T), starting with the
       pair (1, 0). Now consider @m(T) to be the special case of @m(p=0) and
       @m(q=1) in a family of transformations @M(T_{pq}), where @M(T_{pq})
       transforms the pair @m[(a, b)] according to @m(a ← bq + aq + ap) and @m(b ←
       bp + aq).  Show that if we apply such a transformation @M[T_{pq}] twice,
       the effect is the same as using a single transformation @M[T_{p'q'}] of the
       same form, and compute @M[p'\!] and @M[q'\!] in terms of @m(p) and
       @m(q). This gives us an explicit way to square these transformations, and
       thus we can compute @m(Tⁿ) using successive squaring, as in the
       @c(fast-expt) procedure. Put this all together to complete the following
       procedure, which runs in a logarithmic number of steps:@n(41)

       ..src > scheme
         (define (fib n)
           (fib-iter 1 0 0 1 n))

         (define (fib-iter a b p q count)
           (cond ((= count 0)
                  b)
                 ((even? count)
                  (fib-iter a
                            b
                            ⟨??⟩  ;compute p'
                            ⟨??⟩  ;compute q'
                            (/ count 2)))
                 (else
                  (fib-iter (+ (* b q)
                               (* a q)
                               (* a p))
                            (+ (* b p)
                               (* a q))
                            p
                            q
                            (- count 1)))))
       < src..

*** 1.2.5 <> Greatest Common Divisors

    The greatest common divisor (@A(GCD)) of two integers @m(a) and @m(b) is
    defined to be the largest integer that divides both @m(a) and @m(b) with no
    remainder. For example, the @A(GCD) of 16 and 28 is 4. In @l(#Chapter 2), when
    we investigate how to implement rational-number arithmetic, we will need to be
    able to compute @A(GCD)s in order to reduce rational numbers to lowest
    terms. (To reduce a rational number to lowest terms, we must divide both the
    numerator and the denominator by their @A(GCD). For example, 16/28 reduces to
    4/7.)  One way to find the @A(GCD) of two integers is to factor them and
    search for common factors, but there is a famous algorithm that is much more
    efficient.

    The idea of the algorithm is based on the observation that, if @m(r) is the
    remainder when @m(a) is divided by @m(b), then the common divisors of @m(a)
    and @m(b) are precisely the same as the common divisors of @m(b) and
    @m(r). Thus, we can use the equation

    ..example >
      GCD(a,b) = GCD(b,r)
    < example..

    to successively reduce the problem of computing a @A(GCD) to the problem of
    computing the @A(GCD) of smaller and smaller pairs of integers. For example,

    ..example >
      GCD(206,40) = GCD(40,6)
                  = GCD(6,4)
                  = GCD(4,2)
                  = GCD(2,0) = 2
    < example..

    reduces @A(GCD)(206, 40) to @A(GCD)(2, 0), which is 2. It is possible to show
    that starting with any two positive integers and performing repeated
    reductions will always eventually produce a pair where the second number
    is 0. Then the @A(GCD) is the other number in the pair. This method for
    computing the @A(GCD) is known as @e(Euclid's Algorithm).@n(42)

    It is easy to express Euclid's Algorithm as a procedure:

    ..src > scheme
      (define (gcd a b)
        (if (= b 0)
            a
            (gcd b (remainder a b))))
    < src..

    This generates an iterative process, whose number of steps grows as the
    logarithm of the numbers involved.

    The fact that the number of steps required by Euclid's Algorithm has
    logarithmic growth bears an interesting relation to the Fibonacci numbers:

    - Lamé's Theorem :: If Euclid's Algorithm requires @m(k) steps to compute the
      @A(GCD) of some pair, then the smaller number in the pair must be greater
      than or equal to the @m(kᵗʰ) Fibonacci number.@n(43)

    We can use this theorem to get an order-of-growth estimate for Euclid's
    Algorithm. Let @m(n) be the smaller of the two inputs to the procedure. If
    the process takes @m(k) steps, then we must have @m[n ≥ Fib(k) ≈ φᵏ/√5].
    Therefore the number of steps @m(k) grows as the logarithm (to the base
    @m(φ) of @m(n). Hence, the order of growth is @m[Θ(log n)].

    :: @t(Exercise 1.20) :: The process that a procedure generates is of course
       dependent on the rules used by the interpreter. As an example, consider the
       iterative @c(gcd) procedure given above. Suppose we were to interpret this
       procedure using normal-order evaluation, as discussed in @l(#1.1.5). (The
       normal-order-evaluation rule for @c(if) is described in @l(#Exercise 1.5).)
       Using the substitution method (for normal order), illustrate the process
       generated in evaluating @c[(gcd 206 40)] and indicate the @c(remainder)
       operations that are actually performed. How many @c(remainder) operations
       are actually performed in the normal-order evaluation of @c[(gcd 206 40)]?
       In the applicative-order evaluation?

*** 1.2.6 <> Example: Testing for Primality

    This section describes two methods for checking the primality of an integer
    @m(n), one with order of growth @m[Θ(√n)], and a @"(probabilistic) algorithm
    with order of growth @m[Θ(log n)].  The exercises at the end of this section
    suggest programming projects based on these algorithms.

**** Searching for divisors

     Since ancient times, mathematicians have been fascinated by problems
     concerning prime numbers, and many people have worked on the problem of
     determining ways to test if numbers are prime. One way to test if a number is
     prime is to find the number's divisors. The following program finds the
     smallest integral divisor (greater than 1) of a given number @m(n). It does
     this in a straightforward way, by testing @m(n) for divisibility by successive
     integers starting with 2.

     ..src > scheme
       (define (smallest-divisor n)
         (find-divisor n 2))

       (define (find-divisor n test-divisor)
         (cond ((> (square test-divisor) n)
                n)
               ((divides? test-divisor n)
                test-divisor)
               (else (find-divisor
                      n
                      (+ test-divisor 1)))))

       (define (divides? a b)
         (= (remainder b a) 0))
     < src..

     We can test whether a number is prime as follows: @m(n) is prime if and only
     if @m(n) is its own smallest divisor.

     ..src > scheme
       (define (prime? n)
         (= n (smallest-divisor n)))
     < src..

     The end test for @c(find-divisor) is based on the fact that if @m(n) is not
     prime it must have a divisor less than or equal to @m(√n).@n(44) This means
     that the algorithm need only test divisors between 1 and @m(√n). Consequently,
     the number of steps required to identify @m(n) as prime will have order of
     growth @m(Θ(√n)).

**** The Fermat test

     The @m[Θ(log n)] primality test is based on a result from number theory known
     as Fermat's Little Theorem.@n(45)

     - Fermat's Little Theorem :: If @m(n) is a prime number and @m(a) is any
       positive integer less than @m(n), then @m(a) raised to the @m(nᵗʰ) power is
       congruent to @m(a) modulo @m(n).

     (Two numbers are said to be @e(congruent modulo) @m(n) if they both have the
     same remainder when divided by @m(n). The remainder of a number @m(a) when
     divided by @m(n) is also referred to as the @e(remainder of) @m(a) @e(modulo)
     @m(n), or simply as @m(a) @e(modulo) @m(n).)

     If @m(n) is not prime, then, in general, most of the numbers @m(a < n) will
     not satisfy the above relation. This leads to the following algorithm for
     testing primality: Given a number @m(n), pick a random number @m(a < n) and
     compute the remainder of @m(aⁿ) modulo @m(n). If the result is not equal to
     @m(a), then @m(n) is certainly not prime. If it is @m(a), then chances are
     good that @m(n) is prime. Now pick another random number @m(a) and test it
     with the same method. If it also satisfies the equation, then we can be even
     more confident that @m(n) is prime. By trying more and more values of @m(a),
     we can increase our confidence in the result. This algorithm is known as the
     Fermat test.

     To implement the Fermat test, we need a procedure that computes the
     exponential of a number modulo another number:

     ..src > scheme
       (define (expmod base exp m)
         (cond ((= exp 0) 1)
               ((even? exp)
                (remainder
                 (square (expmod base (/ exp 2) m))
                 m))
               (else
                (remainder
                 (* base (expmod base (- exp 1) m))
                 m))))
     < src..

     This is very similar to the @c(fast-expt) procedure of @l(#1.2.4).  It uses
     successive squaring, so that the number of steps grows logarithmically with
     the exponent.@n(46)

     The Fermat test is performed by choosing at random a number @m(a) between 1
     and @m(n-1) inclusive and checking whether the remainder modulo @m(n) of the
     @m(nᵗʰ) power of @m(a) is equal to @m(a). The random number @m(a) is chosen
     using the procedure @c(random), which we assume is included as a primitive in
     Scheme. @c(Random) returns a nonnegative integer less than its integer
     input. Hence, to obtain a random number between 1 and @m(n-1), we call
     @c(random) with an input of @m(n-1) and add 1 to the result:

     ..src > scheme
       (define (fermat-test n)
         (define (try-it a)
           (= (expmod a n n) a))
         (try-it (+ 1 (random (- n 1)))))
     < src..

     The following procedure runs the test a given number of times, as specified by
     a parameter. Its value is true if the test succeeds every time, and false
     otherwise.

     ..src > scheme
       (define (fast-prime? n times)
         (cond ((= times 0) true)
               ((fermat-test n)
                (fast-prime? n (- times 1)))
               (else false)))
     < src..

**** Probabilistic methods

     The Fermat test differs in character from most familiar algorithms, in which
     one computes an answer that is guaranteed to be correct. Here, the answer
     obtained is only probably correct. More precisely, if @m(n) ever fails the
     Fermat test, we can be certain that @m(n) is not prime. But the fact that
     @m(n) passes the test, while an extremely strong indication, is still not a
     guarantee that @m(n) is prime. What we would like to say is that for any
     number @m(n), if we perform the test enough times and find that @m(n) always
     passes the test, then the probability of error in our primality test can be
     made as small as we like.

     Unfortunately, this assertion is not quite correct. There do exist numbers
     that fool the Fermat test: numbers @m(n) that are not prime and yet have the
     property that @m(aⁿ) is congruent to @m(a) modulo @m(n) for all integers @m(a
     < n). Such numbers are extremely rare, so the Fermat test is quite reliable in
     practice.@n(47)

     There are variations of the Fermat test that cannot be fooled. In these tests,
     as with the Fermat method, one tests the primality of an integer @m(n) by
     choosing a random integer @m(a < n) and checking some condition that depends
     upon @m(n) and @m(a). (See @l(#Exercise 1.28) for an example of such a test.)
     On the other hand, in contrast to the Fermat test, one can prove that, for any
     @m(n), the condition does not hold for most of the integers @m(a < n) unless
     @m(n) is prime. Thus, if @m(n) passes the test for some random choice of
     @m(a), the chances are better than even that @m(n) is prime. If @m(n) passes
     the test for two random choices of @m(a), the chances are better than 3 out of
     4 that @m(n) is prime. By running the test with more and more randomly chosen
     values of @m(a) we can make the probability of error as small as we like.

     The existence of tests for which one can prove that the chance of error
     becomes arbitrarily small has sparked interest in algorithms of this type,
     which have come to be known as @e(probabilistic algorithms). There is a great
     deal of research activity in this area, and probabilistic algorithms have been
     fruitfully applied to many fields.@n(48)

     :: @t(Exercise 1.21) :: Use the @c(smallest-divisor) procedure to find the
        smallest divisor of each of the following numbers: 199, 1999, 19999.

     :: @t(Exercise 1.22) :: Most Lisp implementations include a primitive called
        @c(runtime) that returns an integer that specifies the amount of time the
        system has been running (measured, for example, in microseconds). The
        following @c(timed-prime-test) procedure, when called with an integer
        @m(n), prints @m(n) and checks to see if @m(n) is prime. If @m(n) is prime,
        the procedure prints three asterisks followed by the amount of time used in
        performing the test.

        ..src > scheme
          (define (timed-prime-test n)
            (newline)
            (display n)
            (start-prime-test n (runtime)))

          (define (start-prime-test n start-time)
            (if (prime? n)
                (report-prime (- (runtime)
                                 start-time))))

          (define (report-prime elapsed-time)
            (display " *** ")
            (display elapsed-time))
        < src..

        Using this procedure, write a procedure @c(search-for-primes) that checks
        the primality of consecutive odd integers in a specified range. Use your
        procedure to find the three smallest primes larger than 1000; larger than
        10,000; larger than 100,000; larger than 1,000,000. Note the time needed to
        test each prime. Since the testing algorithm has order of growth of
        @m[Θ(√n)], you should expect that testing for primes around 10,000 should
        take about @m(√10) times as long as testing for primes around 1000. Do your
        timing data bear this out?  How well do the data for 100,000 and 1,000,000
        support the @m[Θ(√n)] prediction?  Is your result compatible with the
        notion that programs on your machine run in time proportional to the number
        of steps required for the computation?

     :: @t(Exercise 1.23) :: The @c(smallest-divisor) procedure shown at the start
        of this section does lots of needless testing: After it checks to see if
        the number is divisible by 2 there is no point in checking to see if it is
        divisible by any larger even numbers. This suggests that the values used
        for @c(test-divisor) should not be 2, 3, 4, 5, 6, …, but rather 2, 3, 5, 7,
        9, …. To implement this change, define a procedure @c(next) that returns 3
        if its input is equal to 2 and otherwise returns its input plus 2. Modify
        the @c(smallest-divisor) procedure to use @c[(next test-divisor)] instead
        of @c[(+ test-divisor 1)]. With @c(timed-prime-test) incorporating this
        modified version of @c(smallest-divisor), run the test for each of the 12
        primes found in @l(#Exercise 1.22). Since this modification halves the
        number of test steps, you should expect it to run about twice as fast. Is
        this expectation confirmed?  If not, what is the observed ratio of the
        speeds of the two algorithms, and how do you explain the fact that it is
        different from 2?

     :: @t(Exercise 1.24) :: Modify the @c(timed-prime-test) procedure of
        @l(#Exercise 1.22) to use @c(fast-prime?) (the Fermat method), and test
        each of the 12 primes you found in that exercise. Since the Fermat test has
        @m[Θ(log n)] growth, how would you expect the time to test primes near
        1,000,000 to compare with the time needed to test primes near 1000?  Do
        your data bear this out?  Can you explain any discrepancy you find?

     :: @t(Exercise 1.25) :: Alyssa P. Hacker complains that we went to a lot of
        extra work in writing @c(expmod). After all, she says, since we already
        know how to compute exponentials, we could have simply written

        ..src > scheme
          (define (expmod base exp m)
            (remainder (fast-expt base exp) m))
        < src..

        Is she correct?  Would this procedure serve as well for our fast prime
        tester? Explain.

     :: @t(Exercise 1.26) :: Louis Reasoner is having great difficulty doing
        @l(#Exercise 1.24). His @c(fast-prime?) test seems to run more slowly than
        his @c(prime?) test. Louis calls his friend Eva Lu Ator over to help. When
        they examine Louis's code, they find that he has rewritten the @c(expmod)
        procedure to use an explicit multiplication, rather than calling
        @c(square):

        ..src > scheme
          (define (expmod base exp m)
            (cond ((= exp 0) 1)
                  ((even? exp)
                   (remainder
                    (* (expmod base (/ exp 2) m)
                       (expmod base (/ exp 2) m))
                    m))
                  (else
                   (remainder
                    (* base
                       (expmod base (- exp 1) m))
                    m))))
        < src..

        @"(I don't see what difference that could make,) says Louis. @"(I do.)
        says Eva. @"{By writing the procedure like that, you have transformed the
        @m[Θ(log n)] process into a @m[Θ(n)] process.}  Explain.

     :: @t(Exercise 1.27) :: Demonstrate that the Carmichael numbers listed in
        @n(47<>Footnote 47) really do fool the Fermat test. That is, write a
        procedure that takes an integer @m(n) and tests whether @m(aⁿ) is congruent
        to @m(a) modulo @m(n) for every @m(a < n), and try your procedure on the
        given Carmichael numbers.

     :: @t(Exercise 1.28) :: One variant of the Fermat test that cannot be fooled
        is called the @e(Miller-Rabin test) (@l(#Miller 1976); @l(#Rabin
        1980)). This starts from an alternate form of Fermat's Little Theorem,
        which states that if @m(n) is a prime number and @m(a) is any positive
        integer less than @m(n), then @m(a) raised to the @m[(n-1)]-st power is
        congruent to 1 modulo @m(n). To test the primality of a number @m(n) by the
        Miller-Rabin test, we pick a random number @m(a < n) and raise @m(a) to the
        @m[(n-1)]-st power modulo @m(n) using the @c(expmod) procedure. However,
        whenever we perform the squaring step in @c(expmod), we check to see if we
        have discovered a @"(nontrivial square root of 1 modulo @m(n),) that is, a
        number not equal to 1 or @m(n-1) whose square is equal to 1 modulo
        @m(n). It is possible to prove that if such a nontrivial square root of 1
        exists, then @m(n) is not prime. It is also possible to prove that if @m(n)
        is an odd number that is not prime, then, for at least half the numbers
        @m(a < n), computing @m(aⁿ⁻¹) in this way will reveal a nontrivial square
        root of 1 modulo @m(n). (This is why the Miller-Rabin test cannot be
        fooled.)  Modify the @c(expmod) procedure to signal if it discovers a
        nontrivial square root of 1, and use this to implement the Miller-Rabin
        test with a procedure analogous to @c(fermat-test). Check your procedure by
        testing various known primes and non-primes. Hint: One convenient way to
        make @c(expmod) signal is to have it return 0.

** 1.3 <> Formulating Abstractions with Higher-Order Procedures

   We have seen that procedures are, in effect, abstractions that describe
   compound operations on numbers independent of the particular numbers. For
   example, when we

   ..src > scheme
     (define (cube x) (* x x x))
   < src..

   we are not talking about the cube of a particular number, but rather about a
   method for obtaining the cube of any number. Of course we could get along
   without ever defining this procedure, by always writing expressions such as

   ..src > scheme
     (* 3 3 3)
     (* x x x)
     (* y y y)
   < src..

   and never mentioning @c(cube) explicitly. This would place us at a serious
   disadvantage, forcing us to work always at the level of the particular
   operations that happen to be primitives in the language (multiplication, in
   this case) rather than in terms of higher-level operations. Our programs would
   be able to compute cubes, but our language would lack the ability to express
   the concept of cubing. One of the things we should demand from a powerful
   programming language is the ability to build abstractions by assigning names
   to common patterns and then to work in terms of the abstractions directly.
   Procedures provide this ability. This is why all but the most primitive
   programming languages include mechanisms for defining procedures.

   Yet even in numerical processing we will be severely limited in our ability to
   create abstractions if we are restricted to procedures whose parameters must
   be numbers. Often the same programming pattern will be used with a number of
   different procedures. To express such patterns as concepts, we will need to
   construct procedures that can accept procedures as arguments or return
   procedures as values. Procedures that manipulate procedures are called
   @e(higher-order procedures). This section shows how higher-order procedures
   can serve as powerful abstraction mechanisms, vastly increasing the expressive
   power of our language.

*** 1.3.1 <> Procedures as Arguments

    Consider the following three procedures. The first computes the sum of the
    integers from @c(a) through @c(b):

    ..src > scheme
      (define (sum-integers a b)
        (if (> a b)
            0
            (+ a (sum-integers (+ a 1) b))))
    < src..

    The second computes the sum of the cubes of the integers in the given range:

    ..src > scheme
      (define (sum-cubes a b)
        (if (> a b)
            0
            (+ (cube a)
               (sum-cubes (+ a 1) b))))
    < src..

    The third computes the sum of a sequence of terms in the series

    ..example >
        1       1       1
      ----- + ----- + ------ + ...
      1 ⋅ 3   5 ⋅ 7   9 ⋅ 11
    < example..

    which converges to @m[π / 8] (very slowly):@n(49)

    ..src > scheme
      (define (pi-sum a b)
        (if (> a b)
            0
            (+ (/ 1.0 (* a (+ a 2)))
               (pi-sum (+ a 4) b))))
    < src..

    These three procedures clearly share a common underlying pattern. They are for
    the most part identical, differing only in the name of the procedure, the
    function of @c(a) used to compute the term to be added, and the function
    that provides the next value of @c(a). We could generate each of the
    procedures by filling in slots in the same template:

    ..src > scheme
      (define (⟨name⟩ a b)
        (if (> a b)
            0
            (+ (⟨term⟩ a)
               (⟨name⟩ (⟨next⟩ a) b))))
    < src..

    The presence of such a common pattern is strong evidence that there is a
    useful abstraction waiting to be brought to the surface. Indeed,
    mathematicians long ago identified the abstraction of @e(summation of a
    series) and invented @"(sigma notation,) for example

    ..example >
       b
       ∑ f(n) = f(a) + ⋯ + f(b)
      n=a
    < example..

    to express this concept. The power of sigma notation is that it allows
    mathematicians to deal with the concept of summation itself rather than only
    with particular sums––for example, to formulate general results about sums
    that are independent of the particular series being summed.

    Similarly, as program designers, we would like our language to be powerful
    enough so that we can write a procedure that expresses the concept of
    summation itself rather than only procedures that compute particular sums. We
    can do so readily in our procedural language by taking the common template
    shown above and transforming the @"(slots) into formal parameters:

    ..src > scheme
      (define (sum term a next b)
        (if (> a b)
            0
            (+ (term a)
               (sum term (next a) next b))))
    < src..

    Notice that @c(sum) takes as its arguments the lower and upper bounds @c(a)
    and @c(b) together with the procedures @c(term) and @c(next).  We can use
    @c(sum) just as we would any procedure. For example, we can use it (along with
    a procedure @c(inc) that increments its argument by 1) to define
    @c(sum-cubes):

    ..src > scheme
      (define (inc n) (+ n 1))

      (define (sum-cubes a b)
        (sum cube a inc b))
    < src..

    Using this, we can compute the sum of the cubes of the integers from 1 to 10:

    ..srci > scheme
      > (sum-cubes 1 10)
      3025
    < srci..

    With the aid of an identity procedure to compute the term, we can define
    @c(sum-integers) in terms of @c(sum):

    ..src > scheme
      (define (identity x) x)

      (define (sum-integers a b)
        (sum identity a inc b))
    < src..

    Then we can add up the integers from 1 to 10:

    ..srci > scheme
      > (sum-integers 1 10)
      55
    < srci..

    We can also define @c(pi-sum) in the same way:@n(50)

    ..src > scheme
      (define (pi-sum a b)
        (define (pi-term x)
          (/ 1.0 (* x (+ x 2))))
        (define (pi-next x)
          (+ x 4))
        (sum pi-term a pi-next b))
    < src..

    Using these procedures, we can compute an approximation to @m(π):

    ..srci > scheme
      > (* 8 (pi-sum 1 1000))
      3.139592655589783
    < srci..

    Once we have @c(sum), we can use it as a building block in formulating further
    concepts. For instance, the definite integral of a function @m(f) between the
    limits @m(a) and @m(b) can be approximated numerically using the formula

    ..example >
             ┌                                                          ┐
      ╭ᵇ     │  ╭     dx ╮    ╭          dx ╮    ╭           dx ╮       │
      │  f = │ f│ a + -- │ + f│ a + dx + -- │ + f│ a + 2dx + -- │ + ... │ dx
      ╯ᵃ     │  ╰     2  ╯    ╰          2  ╯    ╰           2  ╯       │
             └                                                          ┘
    < example..

    for small values of @m(dx). We can express this directly as a procedure:

    ..srci > scheme
      > (define (integral f a b dx)
      ^   (define (add-dx x) (+ x dx))
      ^   (* (sum f (+ a (/ dx 2.0)) add-dx b)
      ^      dx))
      > (integral cube 0 1 0.01)
      .24998750000000042
      > (integral cube 0 1 0.001)
      .249999875000001
    < srci..

    (The exact value of the integral of @c(cube) between 0 and 1 is 1/4.)

    :: @t(Exercise 1.29) :: Simpson's Rule is a more accurate method of numerical
       integration than the method illustrated above. Using Simpson's Rule, the
       integral of a function @m(f) between @m(a) and @m(b) is approximated as

       ..example >
         h
         - (y₀ + 4y₁ + 2y₂ + 4y₃ + 2y₄ + ... + 2y₍ₙ₋₂₎ + 4y₍ₙ₋₁₎ + yₙ)
         3
       < example..

       where @m[h = (b - a)/n], for some even integer @m(n), and @m[yₙ = f(a +
       kh)]. (Increasing @m(n) increases the accuracy of the approximation.)
       Define a procedure that takes as arguments @m(f), @m(a), @m(b), and @m(n)
       and returns the value of the integral, computed using Simpson's Rule. Use
       your procedure to integrate @c(cube) between 0 and 1 (with @m(n = 100) and
       @m(n = 1000), and compare the results to those of the @c(integral)
       procedure shown above.

    :: @t(Exercise 1.30) :: The @c(sum) procedure above generates a linear
       recursion. The procedure can be rewritten so that the sum is performed
       iteratively. Show how to do this by filling in the missing expressions in
       the following definition:

       ..src > scheme
         (define (sum term a next b)
           (define (iter a result)
             (if ⟨??⟩
                 ⟨??⟩
                 (iter ⟨??⟩ ⟨??⟩)))
           (iter ⟨??⟩ ⟨??⟩))
       < src..

    :: @t(Exercise 1.31) ::

       - The @c(sum) procedure is only the simplest of a vast number of similar
         abstractions that can be captured as higher-order procedures.@n(51) Write
         an analogous procedure called @c(product) that returns the product of the
         values of a function at points over a given range. Show how to define
         @c(factorial) in terms of @c(product). Also use @c(product) to compute
         approximations to @m(π) using the formula@n(52)

         ..example >
           π   2 ⋅ 4 ⋅ 4 ⋅ 6 ⋅ 6 ⋅ 8 ⋅ ⋯
           - = -------------------------
           4   3 ⋅ 3 ⋅ 5 ⋅ 5 ⋅ 7 ⋅ 7 ⋅ ⋯
         < example..

       - If your @c(product) procedure generates a recursive process, write one
         that generates an iterative process. If it generates an iterative
         process, write one that generates a recursive process.

    :: @t(Exercise 1.32) ::

       - Show that @c(sum) and @c(product) (@l(#Exercise 1.31)) are both special
         cases of a still more general notion called @c(accumulate) that combines
         a collection of terms, using some general accumulation function:

         ..src > scheme
           (accumulate
            combiner null-value term a next b)
         < src..

         @c(Accumulate) takes as arguments the same term and range specifications
         as @c(sum) and @c(product), together with a @c(combiner) procedure (of
         two arguments) that specifies how the current term is to be combined with
         the accumulation of the preceding terms and a @c(null-value) that
         specifies what base value to use when the terms run out. Write
         @c(accumulate) and show how @c(sum) and @c(product) can both be defined
         as simple calls to @c(accumulate).

       - If your @c(accumulate) procedure generates a recursive process, write one
         that generates an iterative process. If it generates an iterative
         process, write one that generates a recursive process.

    :: @t(Exercise 1.33) :: You can obtain an even more general version of
       @c(accumulate) (@l(#Exercise 1.32)) by introducing the notion of a
       @e(filter) on the terms to be combined. That is, combine only those terms
       derived from values in the range that satisfy a specified condition. The
       resulting @c(filtered-accumulate) abstraction takes the same arguments as
       accumulate, together with an additional predicate of one argument that
       specifies the filter. Write @c(filtered-accumulate) as a procedure.  Show
       how to express the following using @c(filtered-accumulate):

       - the sum of the squares of the prime numbers in the interval @m(a) to
         @m(b) (assuming that you have a @c(prime?) predicate already written)

       - the product of all the positive integers less than @m(n) that are
         relatively prime to @m(n) (i.e., all positive integers @m(i < n) such
         that @m[GCD(i, n) = 1].

*** 1.3.2 <> Constructing Procedures Using @c(Lambda)

    In using @c(sum) as in @l(#1.3.1), it seems terribly awkward to have to define
    trivial procedures such as @c(pi-term) and @c(pi-next) just so we can use them
    as arguments to our higher-order procedure. Rather than define @c(pi-next) and
    @c(pi-term), it would be more convenient to have a way to directly specify
    @"(the procedure that returns its input incremented by 4) and @"(the procedure
    that returns the reciprocal of its input times its input plus 2.)  We can do
    this by introducing the special form @c(lambda), which creates
    procedures. Using @c(lambda) we can describe what we want as

    ..src > scheme
      (lambda (x) (+ x 4))
    < src..

    and

    ..src > scheme
      (lambda (x) (/ 1.0 (* x (+ x 2))))
    < src..

    Then our @c(pi-sum) procedure can be expressed without defining any auxiliary
    procedures as

    ..src > scheme
      (define (pi-sum a b)
        (sum (lambda (x) (/ 1.0 (* x (+ x 2))))
             a
             (lambda (x) (+ x 4))
             b))
    < src..

    Again using @c(lambda), we can write the @c(integral) procedure without having
    to define the auxiliary procedure @c(add-dx):

    ..src > scheme
      (define (integral f a b dx)
        (* (sum f (+ a (/ dx 2.0))
                  (lambda (x) (+ x dx))
                  b)
           dx))
    < src..

    In general, @c(lambda) is used to create procedures in the same way as
    @c(define), except that no name is specified for the procedure:

    ..src > scheme
      (lambda (⟨formal-parameters⟩) ⟨body⟩)
    < src..

    The resulting procedure is just as much a procedure as one that is created
    using @c(define). The only difference is that it has not been associated with
    any name in the environment. In fact,

    ..src > scheme
      (define (plus4 x) (+ x 4))
    < src..

    is equivalent to

    ..src > scheme
      (define plus4 (lambda (x) (+ x 4)))
    < src..

    We can read a @c(lambda) expression as follows:

    ..example >
      (lambda                     (x)     (+   x     4))
          |                        |       |   |     |
      the procedure of an argument x that adds x and 4
    < example..

    Like any expression that has a procedure as its value, a @c(lambda) expression
    can be used as the operator in a combination such as

    ..srci > scheme
      > ((lambda (x y z) (+ x y (square z))) 1 2 3)
      12
    < srci..

    or, more generally, in any context where we would normally use a procedure
    name.@n(53)

**** Using @c(let) to create local variables

     Another use of @c(lambda) is in creating local variables. We often need
     local variables in our procedures other than those that have been bound as
     formal parameters. For example, suppose we wish to compute the function

     ..example >
       f(x,y) = x(1 + xy)² + y(1 − y) + (1 + xy)(1 − y)
     < example..

     which we could also express as

     ..example >
            a = 1 + xy
            b = 1 − y
       f(x,y) = xa² + yb + ab
     < example..

     In writing a procedure to compute @m(f), we would like to include as local
     variables not only @m(x) and @m(y) but also the names of intermediate
     quantities like @m(a) and @m(b). One way to accomplish this is to use an
     auxiliary procedure to bind the local variables:

     ..src > scheme
       (define (f x y)
         (define (f-helper a b)
           (+ (* x (square a))
              (* y b)
              (* a b)))
         (f-helper (+ 1 (* x y))
                   (- 1 y)))
     < src..

     Of course, we could use a @c(lambda) expression to specify an anonymous
     procedure for binding our local variables. The body of @c(f) then becomes a
     single call to that procedure:

     ..src > scheme
       (define (f x y)
         ((lambda (a b)
            (+ (* x (square a))
               (* y b)
               (* a b)))
          (+ 1 (* x y))
          (- 1 y)))
     < src..

     This construct is so useful that there is a special form called @c(let) to
     make its use more convenient. Using @c(let), the @c(f) procedure could be
     written as

     ..src > scheme
       (define (f x y)
         (let ((a (+ 1 (* x y)))
               (b (- 1 y)))
           (+ (* x (square a))
              (* y b)
              (* a b))))
     < src..

     The general form of a @c(let) expression is

     ..src > scheme
       (let ((⟨var₁⟩ ⟨exp₁⟩)
             (⟨var₂⟩ ⟨exp₂⟩)
             …
             (⟨varₙ⟩ ⟨expₙ⟩))
         ⟨body⟩)
     < src..

     which can be thought of as saying

     ..example >
       let ⟨var₁⟩ have the value ⟨exp₁⟩ and
           ⟨var₂⟩ have the value ⟨exp₂⟩ and
           …
           ⟨varₙ⟩ have the value ⟨expₙ⟩
         in ⟨body⟩
     < example..

     The first part of the @c(let) expression is a list of name-expression pairs.
     When the @c(let) is evaluated, each name is associated with the value of the
     corresponding expression. The body of the @c(let) is evaluated with these
     names bound as local variables. The way this happens is that the @c(let)
     expression is interpreted as an alternate syntax for

     ..src > scheme
       ((lambda (⟨var₁⟩ … ⟨varₙ⟩)
          ⟨body⟩)
        ⟨exp₁⟩
        …
        ⟨expₙ⟩)
     < src..

     No new mechanism is required in the interpreter in order to provide local
     variables. A @c(let) expression is simply syntactic sugar for the underlying
     @c(lambda) application.

     We can see from this equivalence that the scope of a variable specified by a
     @c(let) expression is the body of the @c(let). This implies that:

     - @c(Let) allows one to bind variables as locally as possible to where they
       are to be used. For example, if the value of @c(x) is 5, the value of the
       expression

       ..src > scheme
         (+ (let ((x 3))
              (+ x (* x 10)))
            x)
       < src..

       is 38. Here, the @c(x) in the body of the @c(let) is 3, so the value of the
       @c(let) expression is 33. On the other hand, the @c(x) that is the second
       argument to the outermost @c(+) is still 5.

     - The variables' values are computed outside the @c(let). This matters when
       the expressions that provide the values for the local variables depend upon
       variables having the same names as the local variables themselves. For
       example, if the value of @c(x) is 2, the expression

       ..src > scheme
         (let ((x 3)
               (y (+ x 2)))
           (* x y))
       < src..

       will have the value 12 because, inside the body of the @c(let), @c(x) will
       be 3 and @c(y) will be 4 (which is the outer @c(x) plus 2).


     Sometimes we can use internal definitions to get the same effect as with
     @c(let). For example, we could have defined the procedure @c(f) above as

     ..src > scheme
       (define (f x y)
         (define a
           (+ 1 (* x y)))
         (define b (- 1 y))
         (+ (* x (square a))
            (* y b)
            (* a b)))
     < src..

     We prefer, however, to use @c(let) in situations like this and to use internal
     @c(define) only for internal procedures.@n(54)

     :: @t(Exercise 1.34) :: Suppose we define the procedure

        ..src > scheme
          (define (f g) (g 2))
        < src..

        Then we have

        ..srci > scheme
          > (f square)
          4
          > (f (lambda (z) (* z (+ z 1))))
          6
        < srci..

        What happens if we (perversely) ask the interpreter to evaluate the
        combination @c[(f f)]?  Explain.

*** 1.3.3 <> Procedures as General Methods

    We introduced compound procedures in @l(#1.1.4) as a mechanism for abstracting
    patterns of numerical operations so as to make them independent of the
    particular numbers involved. With higher-order procedures, such as the
    @c(integral) procedure of @l(#1.3.1), we began to see a more powerful kind of
    abstraction: procedures used to express general methods of computation,
    independent of the particular functions involved. In this section we discuss
    two more elaborate examples––general methods for finding zeros and fixed
    points of functions––and show how these methods can be expressed directly as
    procedures.

**** Finding roots of equations by the half-interval method

     The @e(half-interval method) is a simple but powerful technique for finding
     roots of an equation @m[f(x) = 0], where @m(f) is a continuous function. The
     idea is that, if we are given points @m(a) and @m(b) such that @m[f(a) < 0 <
     f(b)], then @m(f) must have at least one zero between @m(a) and @m(b). To
     locate a zero, let @m(x) be the average of @m(a) and @m(b), and compute
     @m[f(x)]. If @m[f(x) > 0], then @m(f) must have a zero between @m(a) and
     @m(x). If @m[f(x) < 0], then @m(f) must have a zero between @m(x) and
     @m(b). Continuing in this way, we can identify smaller and smaller intervals
     on which @m(f) must have a zero. When we reach a point where the interval is
     small enough, the process stops. Since the interval of uncertainty is reduced
     by half at each step of the process, the number of steps required grows as
     @m[Θ(log(L / T))], where @m(L) is the length of the original interval and
     @m(T) is the error tolerance (that is, the size of the interval we will
     consider @"(small enough)]. Here is a procedure that implements this strategy:

     ..src > scheme
       (define (search f neg-point pos-point)
         (let ((midpoint
                (average neg-point pos-point)))
           (if (close-enough? neg-point pos-point)
               midpoint
               (let ((test-value (f midpoint)))
                 (cond
                  ((positive? test-value)
                   (search f neg-point midpoint))
                  ((negative? test-value)
                   (search f midpoint pos-point))
                  (else midpoint))))))
     < src..

     We assume that we are initially given the function @m(f) together with points
     at which its values are negative and positive. We first compute the midpoint
     of the two given points. Next we check to see if the given interval is small
     enough, and if so we simply return the midpoint as our answer. Otherwise, we
     compute as a test value the value of @m(f) at the midpoint. If the test value
     is positive, then we continue the process with a new interval running from the
     original negative point to the midpoint. If the test value is negative, we
     continue with the interval from the midpoint to the positive point. Finally,
     there is the possibility that the test value is 0, in which case the midpoint
     is itself the root we are searching for.

     To test whether the endpoints are @"(close enough) we can use a procedure
     similar to the one used in @l(#1.1.7) for computing square roots:@n(55)

     ..src > scheme
       (define (close-enough? x y)
         (< (abs (- x y)) 0.001))
     < src..

     @c(Search) is awkward to use directly, because we can accidentally give it
     points at which @m(f)'s values do not have the required sign, in which case we
     get a wrong answer. Instead we will use @c(search) via the following
     procedure, which checks to see which of the endpoints has a negative function
     value and which has a positive value, and calls the @c(search) procedure
     accordingly. If the function has the same sign on the two given points, the
     half-interval method cannot be used, in which case the procedure signals an
     error.@n(56)

     ..src > scheme
       (define (half-interval-method f a b)
         (let ((a-value (f a))
               (b-value (f b)))
           (cond ((and (negative? a-value)
                       (positive? b-value))
                  (search f a b))
                 ((and (negative? b-value)
                       (positive? a-value))
                  (search f b a))
                 (else
                  (error "Values are not of
                          opposite sign" a b)))))
     < src..

     The following example uses the half-interval method to approximate @m(π) as
     the root between 2 and 4 of @m(sin x = 0):

     ..srci > scheme
       (half-interval-method sin 2.0 4.0)
       3.14111328125
     < srci..

     Here is another example, using the half-interval method to search for a root
     of the equation @m(x³ - 2x - 3 = 0) between 1 and 2:

     ..srci > scheme
       > (half-interval-method
       ^  (lambda (x) (- (* x x x) (* 2 x) 3))
       ^  1.0
       ^  2.0)
       1.89306640625
     < srci..

**** Finding fixed points of functions

     A number @m(x) is called a @e(fixed point) of a function @m(f) if @m(x)
     satisfies the equation @m[f(x) = x]. For some functions @m(f) we can locate a
     fixed point by beginning with an initial guess and applying @m(f) repeatedly,

     ..example >
       f(x), f(f(x)), f(f(f(x))), ...
     < example..

     until the value does not change very much. Using this idea, we can devise a
     procedure @c(fixed-point) that takes as inputs a function and an initial guess
     and produces an approximation to a fixed point of the function. We apply the
     function repeatedly until we find two successive values whose difference is
     less than some prescribed tolerance:

     ..src > scheme
       (define tolerance 0.00001)

       (define (fixed-point f first-guess)
         (define (close-enough? v1 v2)
           (< (abs (- v1 v2))
              tolerance))
         (define (try guess)
           (let ((next (f guess)))
             (if (close-enough? guess next)
                 next
                 (try next))))
         (try first-guess))
     < src..

     For example, we can use this method to approximate the fixed point of the
     cosine function, starting with 1 as an initial approximation:@n(57)

     ..srci > scheme
       > (fixed-point cos 1.0)
       .7390822985224023
     < srci..

     Similarly, we can find a solution to the equation @m(y = sin y + cos y):

     ..srci > scheme
       > (fixed-point (lambda (y) (+ (sin y) (cos y)))
       ^              1.0)
       1.2587315962971173
     < srci..

     The fixed-point process is reminiscent of the process we used for finding
     square roots in @l(#1.1.7). Both are based on the idea of repeatedly improving
     a guess until the result satisfies some criterion. In fact, we can readily
     formulate the square-root computation as a fixed-point search.  Computing the
     square root of some number @m(x) requires finding a @m(y) such that @m(y² =
     x). Putting this equation into the equivalent form @m(y = x / y), we recognize
     that we are looking for a fixed point of the function@n(58) @m(y ↦ x / y), and
     we can therefore try to compute square roots as

     ..src > scheme
       (define (sqrt x)
         (fixed-point (lambda (y) (/ x y))
                      1.0))
     < src..

     Unfortunately, this fixed-point search does not converge. Consider an initial
     guess @m(y₁). The next guess is @m(y₂ = x / y₁) and the next guess is @m[y₃ =
     x / y₂ = x / (x / y₁) = y₁]. This results in an infinite loop in which the two
     guesses @m(y₁) and @m(y₂) repeat over and over, oscillating about the answer.

     One way to control such oscillations is to prevent the guesses from changing
     so much. Since the answer is always between our guess @m(y) and @m(x / y), we
     can make a new guess that is not as far from @m(y) as @m(x / y) by averaging
     @m(y) with @m(x / y), so that the next guess after @m(y) is @m[½(y + x / y)]
     instead of @m(x / y). The process of making such a sequence of guesses is
     simply the process of looking for a fixed point of @m(y ↦ ½(y + x / y)):

     ..src > scheme
       (define (sqrt x)
         (fixed-point
          (lambda (y) (average y (/ x y)))
          1.0))
     < src..

     (Note that @m[y = ½(y + x / y)] is a simple transformation of the equation
     @m(y = x / y); to derive it, add @m(y) to both sides of the equation and
     divide by 2.)

     With this modification, the square-root procedure works. In fact, if we
     unravel the definitions, we can see that the sequence of approximations to the
     square root generated here is precisely the same as the one generated by our
     original square-root procedure of @l(#1.1.7). This approach of averaging
     successive approximations to a solution, a technique that we call @e(average
     damping), often aids the convergence of fixed-point searches.

     :: @t(Exercise 1.35) :: Show that the golden ratio @m(φ) (@l(#1.2.2)) is a
        fixed point of the transformation @m(x ↦ 1 + 1 / x), and use this fact to
        compute @m(φ) by means of the @c(fixed-point) procedure.

     :: @t(Exercise 1.36) :: Modify @c(fixed-point) so that it prints the sequence
        of approximations it generates, using the @c(newline) and @c(display)
        primitives shown in @l(#Exercise 1.22). Then find a solution to @m(xˣ
        = 1000) by finding a fixed point of @m[x ↦ log(1000) / log(x)]. (Use
        Scheme's primitive @c(log) procedure, which computes natural logarithms.)
        Compare the number of steps this takes with and without average
        damping. (Note that you cannot start @c(fixed-point) with a guess of 1, as
        this would cause division by @m[log(1) = 0].)

     :: @t(Exercise 1.37) ::

        1. An infinite @e(continued fraction) is an expression of the form

           ..example >
                        N₁
             f = ---------------------
                            N₂
                 D₁  + ---------------
                                N₃
                       D₂ + ---------
                            D₃ + ...
           < example..

           As an example, one can show that the infinite continued fraction
           expansion with the @m(Nᵢ) and the @m(Dᵢ) all equal to 1 produces @m(1 /
           φ), where @m(φ) is the golden ratio (described in @l(#1.2.2)). One way
           to approximate an infinite continued fraction is to truncate the
           expansion after a given number of terms. Such a truncation––a so-called
           @e(@i{k}-term finite continued fraction)––has the form

           ..example >
                    N₁
             -----------------
                       N₂
             D₁ + ------------
                           Nₙ
                   ⋱  + -----
                           Dₙ
           < example..

           Suppose that @c(n) and @c(d) are procedures of one argument (the term
           index @m(i) that return the @m(Nᵢ) and @m(Dᵢ) of the terms of the
           continued fraction. Define a procedure @c(cont-frac) such that
           evaluating @c[(cont-frac n d k)] computes the value of the @m(k)-term
           finite continued fraction. Check your procedure by approximating @m(1 /
           φ) using

           ..src > scheme
             (cont-frac (lambda (i) 1.0)
             (lambda (i) 1.0)
             k)
           < src..

           for successive values of @c(k). How large must you make @c(k) in order
           to get an approximation that is accurate to 4 decimal places?

        2. If your @c(cont-frac) procedure generates a recursive process, write one
           that generates an iterative process. If it generates an iterative
           process, write one that generates a recursive process.


     :: @t(Exercise 1.38) :: In 1737, the Swiss mathematician Leonhard Euler
        published a memoir @q(De Fractionibus Continuis), which included a
        continued fraction expansion for @m(e - 2), where @m(e) is the base of the
        natural logarithms. In this fraction, the @m(Nᵢ) are all 1, and the @m(Dᵢ)
        are successively 1, 2, 1, 1, 4, 1, 1, 6, 1, 1, 8, ….  Write a program that
        uses your @c(cont-frac) procedure from @l(#Exercise 1.37) to approximate
        @m(e), based on Euler's expansion.

     :: @t(Exercise 1.39) :: A continued fraction representation of the tangent
        function was published in 1770 by the German mathematician J.H. Lambert:

        ..example >
                        x
          tan x = ---------------
                          x²
                  1 − -----------
                            x²
                      3 − -------
                          5 − ...
        < example..

        where @m(x) is in radians. Define a procedure @c[(tan-cf x k)] that
        computes an approximation to the tangent function based on Lambert's
        formula.  @c(k) specifies the number of terms to compute, as in
        @l(#Exercise 1.37).

*** 1.3.4 <> Procedures as Returned Values

    The above examples demonstrate how the ability to pass procedures as arguments
    significantly enhances the expressive power of our programming language. We
    can achieve even more expressive power by creating procedures whose returned
    values are themselves procedures.

    We can illustrate this idea by looking again at the fixed-point example
    described at the end of @l(#1.3.3). We formulated a new version of the
    square-root procedure as a fixed-point search, starting with the observation
    that @m(√x) is a fixed-point of the function @m(y ↦ x / y). Then we used
    average damping to make the approximations converge.  Average damping is a
    useful general technique in itself. Namely, given a function @m(f), we
    consider the function whose value at @m(x) is equal to the average of @m(x)
    and @m[f(x)].

    We can express the idea of average damping by means of the following
    procedure:

    ..src > scheme
      (define (average-damp f)
        (lambda (x)
          (average x (f x))))
    < src..

    @c(Average-damp) is a procedure that takes as its argument a procedure
    @c(f) and returns as its value a procedure (produced by the @c(lambda))
    that, when applied to a number @c(x), produces the average of @c(x) and
    @c[(f x)]. For example, applying @c(average-damp) to the @c(square)
    procedure produces a procedure whose value at some number @m(x) is the average
    of @m(x) and @m(x²). Applying this resulting procedure to 10 returns the
    average of 10 and 100, or 55:@n(59)

    ..srci > scheme
      > ((average-damp square) 10)
      55
    < srci..

    Using @c(average-damp), we can reformulate the square-root procedure as
    follows:

    ..src > scheme
      (define (sqrt x)
        (fixed-point
         (average-damp
          (lambda (y) (/ x y)))
         1.0))
    < src..

    Notice how this formulation makes explicit the three ideas in the method:
    fixed-point search, average damping, and the function @m(y ↦ x / y).  It is
    instructive to compare this formulation of the square-root method with the
    original version given in @l(#1.1.7). Bear in mind that these procedures
    express the same process, and notice how much clearer the idea becomes when we
    express the process in terms of these abstractions. In general, there are many
    ways to formulate a process as a procedure.  Experienced programmers know how
    to choose procedural formulations that are particularly perspicuous, and where
    useful elements of the process are exposed as separate entities that can be
    reused in other applications. As a simple example of reuse, notice that the
    cube root of @m(x) is a fixed point of the function @m(y ↦ x / y²), so we can
    immediately generalize our square-root procedure to one that extracts cube
    roots:@n(60)

    ..src > scheme
      (define (cube-root x)
        (fixed-point
         (average-damp
          (lambda (y)
            (/ x (square y))))
         1.0))
    < src..

**** Newton's method

     When we first introduced the square-root procedure, in @l(#1.1.7), we
     mentioned that this was a special case of @e(Newton's method).  If @m[x ↦
     g(x)] is a differentiable function, then a solution of the equation @m[g(x) =
     0] is a fixed point of the function @m[x ↦ f(x)] where

     ..example >
                  g(x)
       f(x) = x − -----
                  Dg(x)
     < example..

     and @m[Dg(x)] is the derivative of @m(g) evaluated at @m(x). Newton's method
     is the use of the fixed-point method we saw above to approximate a solution of
     the equation by finding a fixed point of the function @m(f).@n(61)

     For many functions @m(g) and for sufficiently good initial guesses for @m(x),
     Newton's method converges very rapidly to a solution of @m[g(x) = 0].@n(62)

     In order to implement Newton's method as a procedure, we must first express
     the idea of derivative. Note that @"(derivative,) like average damping, is
     something that transforms a function into another function. For instance, the
     derivative of the function @m(x ↦ x³) is the function @m(x ↦ 3x²).  In
     general, if @m(g) is a function and @m(dx) is a small number, then the
     derivative @m(Dg) of @m(g) is the function whose value at any number @m(x) is
     given (in the limit of small @m(dx) by

     ..example >
               g(x + dx) − g(x)
       Dg(x) = ----------------
                      dx
     < example..

     Thus, we can express the idea of derivative (taking @m(dx) to be, say,
     0.00001) as the procedure

     ..src > scheme
       (define (deriv g)
         (lambda (x)
           (/ (- (g (+ x dx)) (g x))
              dx)))
     < src..

     along with the definition

     ..src > scheme
       (define dx 0.00001)
     < src..

     Like @c(average-damp), @c(deriv) is a procedure that takes a procedure as
     argument and returns a procedure as value. For example, to approximate the
     derivative of @m(x ↦ x³) at 5 (whose exact value is 75) we can evaluate

     ..srci > scheme
       > (define (cube x) (* x x x))
       > ((deriv cube) 5)
       75.00014999664018
     < srci..

     With the aid of @c(deriv), we can express Newton's method as a fixed-point
     process:

     ..src > scheme
       (define (newton-transform g)
         (lambda (x)
           (- x (/ (g x)
                   ((deriv g) x)))))

       (define (newtons-method g guess)
         (fixed-point (newton-transform g)
                      guess))
     < src..

     The @c(newton-transform) procedure expresses the formula at the beginning of
     this section, and @c(newtons-method) is readily defined in terms of this.  It
     takes as arguments a procedure that computes the function for which we want to
     find a zero, together with an initial guess. For instance, to find the square
     root of @m(x), we can use Newton's method to find a zero of the function @m(y
     ↦ y² - x) starting with an initial guess of 1.@n(63)

     This provides yet another form of the square-root procedure:

     ..src > scheme
       (define (sqrt x)
         (newtons-method
          (lambda (y)
            (- (square y) x))
          1.0))
     < src..

**** Abstractions and first-class procedures

     We've seen two ways to express the square-root computation as an instance of a
     more general method, once as a fixed-point search and once using Newton's
     method. Since Newton's method was itself expressed as a fixed-point process,
     we actually saw two ways to compute square roots as fixed points. Each method
     begins with a function and finds a fixed point of some transformation of the
     function. We can express this general idea itself as a procedure:

     ..src > scheme
       (define (fixed-point-of-transform
                g transform guess)
         (fixed-point (transform g) guess))
     < src..

     This very general procedure takes as its arguments a procedure @c(g) that
     computes some function, a procedure that transforms @c(g), and an initial
     guess. The returned result is a fixed point of the transformed function.

     Using this abstraction, we can recast the first square-root computation from
     this section (where we look for a fixed point of the average-damped version of
     @m(y ↦ x / y)) as an instance of this general method:

     ..src > scheme
       (define (sqrt x)
         (fixed-point-of-transform
          (lambda (y) (/ x y))
          average-damp
          1.0))
     < src..

     Similarly, we can express the second square-root computation from this section
     (an instance of Newton's method that finds a fixed point of the Newton
     transform of @m(y ↦ y² - x)) as

     ..src > scheme
       (define (sqrt x)
         (fixed-point-of-transform
          (lambda (y) (- (square y) x))
          newton-transform
          1.0))
     < src..

     We began section @l(#1.3) with the observation that compound procedures are a
     crucial abstraction mechanism, because they permit us to express general
     methods of computing as explicit elements in our programming language. Now
     we've seen how higher-order procedures permit us to manipulate these general
     methods to create further abstractions.

     As programmers, we should be alert to opportunities to identify the underlying
     abstractions in our programs and to build upon them and generalize them to
     create more powerful abstractions. This is not to say that one should always
     write programs in the most abstract way possible; expert programmers know how
     to choose the level of abstraction appropriate to their task. But it is
     important to be able to think in terms of these abstractions, so that we can
     be ready to apply them in new contexts. The significance of higher-order
     procedures is that they enable us to represent these abstractions explicitly
     as elements in our programming language, so that they can be handled just like
     other computational elements.

     In general, programming languages impose restrictions on the ways in which
     computational elements can be manipulated. Elements with the fewest
     restrictions are said to have @e(first-class) status. Some of the @"(rights
     and privileges) of first-class elements are:@n(64)

     - They may be named by variables.
     - They may be passed as arguments to procedures.
     - They may be returned as the results of procedures.
     - They may be included in data structures.@n(65)

     Lisp, unlike other common programming languages, awards procedures full
     first-class status. This poses challenges for efficient implementation, but
     the resulting gain in expressive power is enormous.@n(66)

     :: @t(Exercise 1.40) :: Define a procedure @c(cubic) that can be used together
        with the @c(newtons-method) procedure in expressions of the form

        ..src > scheme
          (newtons-method (cubic a b c) 1)
        < src..

        to approximate zeros of the cubic @m(x³ + ax² + bx + c).

     :: @t(Exercise 1.41) :: Define a procedure @c(double) that takes a procedure
        of one argument as argument and returns a procedure that applies the
        original procedure twice. For example, if @c(inc) is a procedure that adds
        1 to its argument, then @c[(double inc)] should be a procedure that
        adds 2. What value is returned by

        ..src > scheme
          (((double (double double)) inc) 5)
        < src..

     :: @t(Exercise 1.42) :: Let @m(f) and @m(g) be two one-argument functions. The
        @e(composition) @m(f) after @m(g) is defined to be the function @m[x ↦
        f(g(x))]. Define a procedure @c(compose) that implements composition. For
        example, if @c(inc) is a procedure that adds 1 to its argument,

        ..srci > scheme
          > ((compose square inc) 6)
          49
        < srci..

     :: @t(Exercise 1.43) :: If @m(f) is a numerical function and @m(n) is a
        positive integer, then we can form the @m(nᵗʰ) repeated application of
        @m(f), which is defined to be the function whose value at @m(x) is @m[f(f(…
        (f(x))… ))]. For example, if @m(f) is the function @m(x ↦ x + 1), then the
        @m(nᵗʰ) repeated application of @m(f) is the function @m(x ↦ x + n). If
        @m(f) is the operation of squaring a number, then the @m(nᵗʰ) repeated
        application of @m(f) is the function that raises its argument to the
        @m(2ⁿ-th) power. Write a procedure that takes as inputs a procedure that
        computes @m(f) and a positive integer @m(n) and returns the procedure that
        computes the @m(nᵗʰ) repeated application of @m(f). Your procedure should
        be able to be used as follows:

        ..srci > scheme
          > ((repeated square 2) 5)
          625
        < srci..

        Hint: You may find it convenient to use @c(compose) from @l(#Exercise
        1.42).

     :: @t(Exercise 1.44) :: The idea of @e(smoothing) a function is an important
        concept in signal processing. If @m(f) is a function and @m(dx) is some
        small number, then the smoothed version of @m(f) is the function whose
        value at a point @m(x) is the average of @m[f(x - dx)], @m[f(x)], and
        @m[f(x + dx)]. Write a procedure @c(smooth) that takes as input a procedure
        that computes @m(f) and returns a procedure that computes the smoothed
        @m(f). It is sometimes valuable to repeatedly smooth a function (that is,
        smooth the smoothed function, and so on) to obtain the @e(@i{n}-fold
        smoothed function). Show how to generate the @i{n}-fold smoothed function
        of any given function using @c(smooth) and @c(repeated) from @l(#Exercise
        1.43).

     :: @t(Exercise 1.45) :: We saw in @l(#1.3.3) that attempting to compute square
        roots by naively finding a fixed point of @m(y ↦ x / y) does not converge,
        and that this can be fixed by average damping. The same method works for
        finding cube roots as fixed points of the average-damped @m(y ↦ x /
        y²). Unfortunately, the process does not work for fourth roots––a single
        average damp is not enough to make a fixed-point search for @m(y ↦ x / y³)
        converge. On the other hand, if we average damp twice (i.e., use the
        average damp of the average damp of @m(y ↦ x / y³) the fixed-point search
        does converge. Do some experiments to determine how many average damps are
        required to compute @m(nᵗʰ) roots as a fixed-point search based upon
        repeated average damping of @m(y ↦ x / yⁿ⁻¹).  Use this to implement a
        simple procedure for computing @m(nᵗʰ) roots using @c(fixed-point),
        @c(average-damp), and the @c(repeated) procedure of @l(#Exercise
        1.43). Assume that any arithmetic operations you need are available as
        primitives.

     :: @t(Exercise 1.46) :: Several of the numerical methods
        described in this chapter are instances of an extremely general computational
        strategy known as @e(iterative improvement). Iterative improvement says
        that, to compute something, we start with an initial guess for the answer, test
        if the guess is good enough, and otherwise improve the guess and continue the
        process using the improved guess as the new guess. Write a procedure
        @c(iterative-improve) that takes two procedures as arguments: a method for
        telling whether a guess is good enough and a method for improving a guess.
        @c(Iterative-improve) should return as its value a procedure that takes a
        guess as argument and keeps improving the guess until it is good enough.
        Rewrite the @c(sqrt) procedure of @l(#1.1.7) and the
        @c(fixed-point) procedure of @l(#1.3.3) in terms of
        @c(iterative-improve).

* Chapter 2 <> Building Abstractions with Data

  ..quote >
    We now come to the decisive step of mathematical abstraction: we forget
    about what the symbols stand for. … [The mathematician] need not be idle;
    there are many operations which he may carry out with these symbols, without
    ever having to look at the things they stand for.

    --Hermann Weyl, @q(The Mathematical Way of Thinking)
  < quote..

  We concentrated in @l(#Chapter 1) on computational processes and on the role
  of procedures in program design. We saw how to use primitive data (numbers)
  and primitive operations (arithmetic operations), how to combine procedures to
  form compound procedures through composition, conditionals, and the use of
  parameters, and how to abstract procedures by using @c(define). We saw that a
  procedure can be regarded as a pattern for the local evolution of a process,
  and we classified, reasoned about, and performed simple algorithmic analyses
  of some common patterns for processes as embodied in procedures. We also saw
  that higher-order procedures enhance the power of our language by enabling us
  to manipulate, and thereby to reason in terms of, general methods of
  computation.  This is much of the essence of programming.

  In this chapter we are going to look at more complex data. All the procedures
  in chapter 1 operate on simple numerical data, and simple data are not
  sufficient for many of the problems we wish to address using computation.
  Programs are typically designed to model complex phenomena, and more often
  than not one must construct computational objects that have several parts in
  order to model real-world phenomena that have several aspects. Thus, whereas
  our focus in chapter 1 was on building abstractions by combining procedures to
  form compound procedures, we turn in this chapter to another key aspect of any
  programming language: the means it provides for building abstractions by
  combining data objects to form @e(compound data).

  Why do we want compound data in a programming language?  For the same reasons
  that we want compound procedures: to elevate the conceptual level at which we
  can design our programs, to increase the modularity of our designs, and to
  enhance the expressive power of our language. Just as the ability to define
  procedures enables us to deal with processes at a higher conceptual level than
  that of the primitive operations of the language, the ability to construct
  compound data objects enables us to deal with data at a higher conceptual
  level than that of the primitive data objects of the language.

  Consider the task of designing a system to perform arithmetic with rational
  numbers. We could imagine an operation @c(add-rat) that takes two rational
  numbers and produces their sum. In terms of simple data, a rational number can
  be thought of as two integers: a numerator and a denominator. Thus, we could
  design a program in which each rational number would be represented by two
  integers (a numerator and a denominator) and where @c(add-rat) would be
  implemented by two procedures (one producing the numerator of the sum and one
  producing the denominator). But this would be awkward, because we would then
  need to explicitly keep track of which numerators corresponded to which
  denominators. In a system intended to perform many operations on many rational
  numbers, such bookkeeping details would clutter the programs substantially, to
  say nothing of what they would do to our minds. It would be much better if we
  could @"(glue together) a numerator and denominator to form a pair––a
  @e(compound data object)––that our programs could manipulate in a way that
  would be consistent with regarding a rational number as a single conceptual
  unit.

  The use of compound data also enables us to increase the modularity of our
  programs. If we can manipulate rational numbers directly as objects in their
  own right, then we can separate the part of our program that deals with
  rational numbers per se from the details of how rational numbers may be
  represented as pairs of integers. The general technique of isolating the parts
  of a program that deal with how data objects are represented from the parts of
  a program that deal with how data objects are used is a powerful design
  methodology called @e(data abstraction). We will see how data abstraction
  makes programs much easier to design, maintain, and modify.

  The use of compound data leads to a real increase in the expressive power of
  our programming language. Consider the idea of forming a @"(linear
  combination) @m(ax + by). We might like to write a procedure that would accept
  @m(a), @m(b), @m(x), and @m(y) as arguments and return the value of @m(ax +
  by). This presents no difficulty if the arguments are to be numbers, because
  we can readily define the procedure

  ..src > scheme
    (define (linear-combination a b x y)
      (+ (* a x) (* b y)))
  < src..

  But suppose we are not concerned only with numbers. Suppose we would like to
  express, in procedural terms, the idea that one can form linear combinations
  whenever addition and multiplication are defined––for rational numbers,
  complex numbers, polynomials, or whatever. We could express this as a
  procedure of the form

  ..src > scheme
    (define (linear-combination a b x y)
      (add (mul a x) (mul b y)))
  < src..

  where @c(add) and @c(mul) are not the primitive procedures @c(+) and @c(*) but
  rather more complex things that will perform the appropriate operations for
  whatever kinds of data we pass in as the arguments @c(a), @c(b), @c(x), and
  @c(y). The key point is that the only thing @c(linear-combination) should need
  to know about @c(a), @c(b), @c(x), and @c(y) is that the procedures @c(add)
  and @c(mul) will perform the appropriate manipulations. From the perspective
  of the procedure @c(linear-combination), it is irrelevant what @c(a), @c(b),
  @c(x), and @c(y) are and even more irrelevant how they might happen to be
  represented in terms of more primitive data. This same example shows why it is
  important that our programming language provide the ability to manipulate
  compound objects directly: Without this, there is no way for a procedure such
  as @c(linear-combination) to pass its arguments along to @c(add) and @c(mul)
  without having to know their detailed structure.@n(67)

  We begin this chapter by implementing the rational-number arithmetic system
  mentioned above. This will form the background for our discussion of compound
  data and data abstraction. As with compound procedures, the main issue to be
  addressed is that of abstraction as a technique for coping with complexity,
  and we will see how data abstraction enables us to erect suitable
  @e(abstraction barriers) between different parts of a program.

  We will see that the key to forming compound data is that a programming
  language should provide some kind of @"(glue) so that data objects can be
  combined to form more complex data objects. There are many possible kinds of
  glue. Indeed, we will discover how to form compound data using no special
  @"(data) operations at all, only procedures. This will further blur the
  distinction between @"(procedure) and @"(data,) which was already becoming
  tenuous toward the end of chapter 1. We will also explore some conventional
  techniques for representing sequences and trees. One key idea in dealing with
  compound data is the notion of @e(closure)––that the glue we use for combining
  data objects should allow us to combine not only primitive data objects, but
  compound data objects as well. Another key idea is that compound data objects
  can serve as @e(conventional interfaces) for combining program modules in
  mix-and-match ways. We illustrate some of these ideas by presenting a simple
  graphics language that exploits closure.

  We will then augment the representational power of our language by introducing
  @e(symbolic expressions)––data whose elementary parts can be arbitrary symbols
  rather than only numbers. We explore various alternatives for representing
  sets of objects. We will find that, just as a given numerical function can be
  computed by many different computational processes, there are many ways in
  which a given data structure can be represented in terms of simpler objects,
  and the choice of representation can have significant impact on the time and
  space requirements of processes that manipulate the data. We will investigate
  these ideas in the context of symbolic differentiation, the representation of
  sets, and the encoding of information.

  Next we will take up the problem of working with data that may be represented
  differently by different parts of a program. This leads to the need to
  implement @e(generic operations), which must handle many different types of
  data. Maintaining modularity in the presence of generic operations requires
  more powerful abstraction barriers than can be erected with simple data
  abstraction alone. In particular, we introduce @e(data-directed programming)
  as a technique that allows individual data representations to be designed in
  isolation and then combined @e(additively) (i.e., without modification). To
  illustrate the power of this approach to system design, we close the chapter
  by applying what we have learned to the implementation of a package for
  performing symbolic arithmetic on polynomials, in which the coefficients of
  the polynomials can be integers, rational numbers, complex numbers, and even
  other polynomials.

** 2.1 <> Introduction to Data Abstraction

   In @l(#1.1.8), we noted that a procedure used as an element in creating a more
   complex procedure could be regarded not only as a collection of particular
   operations but also as a procedural abstraction. That is, the details of how
   the procedure was implemented could be suppressed, and the particular
   procedure itself could be replaced by any other procedure with the same
   overall behavior. In other words, we could make an abstraction that would
   separate the way the procedure would be used from the details of how the
   procedure would be implemented in terms of more primitive procedures. The
   analogous notion for compound data is called @e(data abstraction). Data
   abstraction is a methodology that enables us to isolate how a compound data
   object is used from the details of how it is constructed from more primitive
   data objects.

   The basic idea of data abstraction is to structure the programs that are to
   use compound data objects so that they operate on @"(abstract data.) That is,
   our programs should use data in such a way as to make no assumptions about the
   data that are not strictly necessary for performing the task at hand. At the
   same time, a @"(concrete) data representation is defined independent of the
   programs that use the data. The interface between these two parts of our
   system will be a set of procedures, called @e(selectors) and @e(constructors),
   that implement the abstract data in terms of the concrete representation. To
   illustrate this technique, we will consider how to design a set of procedures
   for manipulating rational numbers.

*** 2.1.1 <> Example: Arithmetic Operations for Rational Numbers

    Suppose we want to do arithmetic with rational numbers. We want to be able to
    add, subtract, multiply, and divide them and to test whether two rational
    numbers are equal.

    Let us begin by assuming that we already have a way of constructing a rational
    number from a numerator and a denominator. We also assume that, given a
    rational number, we have a way of extracting (or selecting) its numerator and
    its denominator. Let us further assume that the constructor and selectors are
    available as procedures:

    - @c[(make-rat ⟨n⟩ ⟨d⟩)] returns the rational number whose numerator is the
      integer @c(⟨n⟩) and whose denominator is the integer @c(⟨d⟩).

    - @c[(numer ⟨x⟩)] returns the numerator of the rational number @c(⟨x⟩).

    - @c[(denom ⟨x⟩)] returns the denominator of the rational number @c(⟨x⟩).

    We are using here a powerful strategy of synthesis: @e(wishful thinking).  We
    haven't yet said how a rational number is represented, or how the procedures
    @c(numer), @c(denom), and @c(make-rat) should be implemented. Even so, if we
    did have these three procedures, we could then add, subtract, multiply,
    divide, and test equality by using the following relations:

    ..example >
      n₁   n₂   n₁ d₂ + n₂ d₁
      -- + -- = -------------
      d₁   d₂       d₁ d₂

      n₁   n₂   n₁ d₂ − n₂ d₁
      -- − -- = -------------
      d₁   d₂      d₁ d₂

      n₁   n₂   n₁ n₂
      -- ⋅ -- = -----
      d₁   d₂   d₁ d₂

      n₁ / d₁   n₁ d₂
      ------- = -----
      n₂ / d₂   d₁ n₂

      n₁   n₂
      -- = --  if and only if n₁ d₂ = n₂ d₁
      d₁   d₂
    < example..

    We can express these rules as procedures:

    ..src > scheme
      (define (add-rat x y)
        (make-rat (+ (* (numer x) (denom y))
                     (* (numer y) (denom x)))
                  (* (denom x) (denom y))))

      (define (sub-rat x y)
        (make-rat (- (* (numer x) (denom y))
                     (* (numer y) (denom x)))
                  (* (denom x) (denom y))))

      (define (mul-rat x y)
        (make-rat (* (numer x) (numer y))
                  (* (denom x) (denom y))))

      (define (div-rat x y)
        (make-rat (* (numer x) (denom y))
                  (* (denom x) (numer y))))

      (define (equal-rat? x y)
        (= (* (numer x) (denom y))
           (* (numer y) (denom x))))
    < src..

    Now we have the operations on rational numbers defined in terms of the
    selector and constructor procedures @c(numer), @c(denom), and @c(make-rat).
    But we haven't yet defined these. What we need is some way to glue together a
    numerator and a denominator to form a rational number.

**** Pairs

     To enable us to implement the concrete level of our data abstraction, our
     language provides a compound structure called a @e(pair), which can be
     constructed with the primitive procedure @c(cons). This procedure takes two
     arguments and returns a compound data object that contains the two arguments
     as parts. Given a pair, we can extract the parts using the primitive
     procedures @c(car) and @c(cdr).@n(68) Thus, we can use @c(cons), @c(car), and
     @c(cdr) as follows:

     ..srci > scheme
       > (define x (cons 1 2))
       > (car x)
       1
       > (cdr x)
       2
     < srci..

     Notice that a pair is a data object that can be given a name and manipulated,
     just like a primitive data object. Moreover, @c(cons) can be used to form
     pairs whose elements are pairs, and so on:

     ..srci > scheme
       > (define x (cons 1 2))
       > (define y (cons 3 4))
       > (define z (cons x y))
       > (car (car z))
       1
       > (car (cdr z))
       3
     < srci..

     In @l(#2.2) we will see how this ability to combine pairs means that pairs can
     be used as general-purpose building blocks to create all sorts of complex data
     structures. The single compound-data primitive @e(pair), implemented by the
     procedures @c(cons), @c(car), and @c(cdr), is the only glue we need. Data
     objects constructed from pairs are called @e(list-structured) data.

**** Representing rational numbers

     Pairs offer a natural way to complete the rational-number system. Simply
     represent a rational number as a pair of two integers: a numerator and a
     denominator. Then @c(make-rat), @c(numer), and @c(denom) are readily
     implemented as follows:@n(69)

     ..src > scheme
       (define (make-rat n d) (cons n d))
       (define (numer x) (car x))
       (define (denom x) (cdr x))
     < src..

     Also, in order to display the results of our computations, we can print
     rational numbers by printing the numerator, a slash, and the
     denominator:@n(70)

     ..src > scheme
       (define (print-rat x)
         (newline)
         (display (numer x))
         (display "/")
         (display (denom x)))
     < src..

     Now we can try our rational-number procedures:

     ..srci > scheme
       > (define one-half (make-rat 1 2))
       > (print-rat one-half)
       1/2
       > (define one-third (make-rat 1 3))
       > (print-rat
       ^  (add-rat one-half one-third))
       5/6
       > (print-rat
       ^  (mul-rat one-half one-third))
       1/6
       > (print-rat
       ^  (add-rat one-third one-third))
       6/9
     < srci..

     As the final example shows, our rational-number implementation does not reduce
     rational numbers to lowest terms. We can remedy this by changing
     @c(make-rat). If we have a @c(gcd) procedure like the one in @l(#1.2.5) that
     produces the greatest common divisor of two integers, we can use @c(gcd) to
     reduce the numerator and the denominator to lowest terms before constructing
     the pair:

     ..src > scheme
       (define (make-rat n d)
         (let ((g (gcd n d)))
           (cons (/ n g)
                 (/ d g))))
     < src..

     Now we have

     ..srci > scheme
       > (print-rat
       ^  (add-rat one-third one-third))
       2/3
     < srci..

     as desired. This modification was accomplished by changing the constructor
     @c(make-rat) without changing any of the procedures (such as @c(add-rat) and
     @c(mul-rat)) that implement the actual operations.

     :: @t(Exercise 2.1) :: Define a better version of @c(make-rat) that handles
        both positive and negative arguments.  @c(Make-rat) should normalize the
        sign so that if the rational number is positive, both the numerator and
        denominator are positive, and if the rational number is negative, only the
        numerator is negative.

*** 2.1.2 <> Abstraction Barriers

    Before continuing with more examples of compound data and data abstraction,
    let us consider some of the issues raised by the rational-number example. We
    defined the rational-number operations in terms of a constructor @c(make-rat)
    and selectors @c(numer) and @c(denom). In general, the underlying idea of data
    abstraction is to identify for each type of data object a basic set of
    operations in terms of which all manipulations of data objects of that type
    will be expressed, and then to use only those operations in manipulating the
    data.

    We can envision the structure of the rational-number system as shown in
    @l(#Figure 2.1). The horizontal lines represent @e(abstraction barriers) that
    isolate different @"(levels) of the system. At each level, the barrier
    separates the programs (above) that use the data abstraction from the programs
    (below) that implement the data abstraction. Programs that use rational
    numbers manipulate them solely in terms of the procedures supplied @"(for
    public use) by the rational-number package: @c(add-rat), @c(sub-rat),
    @c(mul-rat), @c(div-rat), and @c(equal-rat?). These, in turn, are implemented
    solely in terms of the constructor and selectors @c(make-rat), @c(numer), and
    @c(denom), which themselves are implemented in terms of pairs. The details of
    how pairs are implemented are irrelevant to the rest of the rational-number
    package so long as pairs can be manipulated by the use of @c(cons), @c(car),
    and @c(cdr). In effect, procedures at each level are the interfaces that
    define the abstraction barriers and connect the different levels.

    ..figure > @t(Figure 2.1) Data-abstraction barriers in the rational-number package.

      ..art >
                ╭────────────────────────────────────╮
        ────────┤ Programs that use rational numbers ├────────
                ╰────────────────────────────────────╯
                  Rational numbers in problem domain
                    ╭───────────────────────────╮
        ────────────┤   add-rat  sub-rat  ...   ├─────────────
                    ╰───────────────────────────╯
           Rational numbers as numerators and denominators
                      ╭────────────────────────╮
        ──────────────┤ make-rat  numer  denom ├──────────────
                      ╰────────────────────────╯
                      Rational numbers as pairs
                          ╭────────────────╮
        ──────────────────┤ cons  car  cdr ├──────────────────
                          ╰────────────────╯
                    However pairs are implemented
      < art..

@   ..img > img/chap2/Fig2.1d.std.svg

    This simple idea has many advantages. One advantage is that it makes programs
    much easier to maintain and to modify. Any complex data structure can be
    represented in a variety of ways with the primitive data structures provided
    by a programming language. Of course, the choice of representation influences
    the programs that operate on it; thus, if the representation were to be
    changed at some later time, all such programs might have to be modified
    accordingly. This task could be time-consuming and expensive in the case of
    large programs unless the dependence on the representation were to be confined
    by design to a very few program modules.

    For example, an alternate way to address the problem of reducing rational
    numbers to lowest terms is to perform the reduction whenever we access the
    parts of a rational number, rather than when we construct it. This leads to
    different constructor and selector procedures:

    ..src > scheme
      (define (make-rat n d)
        (cons n d))

      (define (numer x)
        (let ((g (gcd (car x) (cdr x))))
          (/ (car x) g)))

      (define (denom x)
        (let ((g (gcd (car x) (cdr x))))
          (/ (cdr x) g)))
    < src..

    The difference between this implementation and the previous one lies in when
    we compute the @c(gcd). If in our typical use of rational numbers we access
    the numerators and denominators of the same rational numbers many times, it
    would be preferable to compute the @c(gcd) when the rational numbers are
    constructed. If not, we may be better off waiting until access time to compute
    the @c(gcd). In any case, when we change from one representation to the other,
    the procedures @c(add-rat), @c(sub-rat), and so on do not have to be modified
    at all.

    Constraining the dependence on the representation to a few interface
    procedures helps us design programs as well as modify them, because it allows
    us to maintain the flexibility to consider alternate implementations. To
    continue with our simple example, suppose we are designing a rational-number
    package and we can't decide initially whether to perform the @c(gcd) at
    construction time or at selection time. The data-abstraction methodology gives
    us a way to defer that decision without losing the ability to make progress on
    the rest of the system.

    :: @t(Exercise 2.2) :: Consider the problem of representing line segments in a
       plane. Each segment is represented as a pair of points: a starting point
       and an ending point. Define a constructor @c(make-segment) and selectors
       @c(start-segment) and @c(end-segment) that define the representation of
       segments in terms of points. Furthermore, a point can be represented as a
       pair of numbers: the @m(x) coordinate and the @m(y)
       coordinate. Accordingly, specify a constructor @c(make-point) and selectors
       @c(x-point) and @c(y-point) that define this representation.  Finally,
       using your selectors and constructors, define a procedure
       @c(midpoint-segment) that takes a line segment as argument and returns its
       midpoint (the point whose coordinates are the average of the coordinates of
       the endpoints). To try your procedures, you'll need a way to print points:

       ..src > scheme
         (define (print-point p)
           (newline)
           (display "(")
           (display (x-point p))
           (display ",")
           (display (y-point p))
           (display ")"))
       < src..

    :: @t(Exercise 2.3) :: Implement a representation for rectangles in a
       plane. (Hint: You may want to make use of @l(#Exercise 2.2).)  In terms of
       your constructors and selectors, create procedures that compute the
       perimeter and the area of a given rectangle. Now implement a different
       representation for rectangles. Can you design your system with suitable
       abstraction barriers, so that the same perimeter and area procedures will
       work using either representation?

*** 2.1.3 <> What Is Meant by Data?

    We began the rational-number implementation in @l(#2.1.1) by implementing the
    rational-number operations @c(add-rat), @c(sub-rat), and so on in terms of
    three unspecified procedures: @c(make-rat), @c(numer), and @c(denom). At that
    point, we could think of the operations as being defined in terms of data
    objects––numerators, denominators, and rational numbers––whose behavior was
    specified by the latter three procedures.

    But exactly what is meant by @e(data)?  It is not enough to say @"(whatever is
    implemented by the given selectors and constructors.)  Clearly, not every
    arbitrary set of three procedures can serve as an appropriate basis for the
    rational-number implementation. We need to guarantee that, if we construct a
    rational number @c(x) from a pair of integers @c(n) and @c(d), then extracting
    the @c(numer) and the @c(denom) of @c(x) and dividing them should yield the
    same result as dividing @c(n) by @c(d).  In other words, @c(make-rat),
    @c(numer), and @c(denom) must satisfy the condition that, for any integer
    @c(n) and any non-zero integer @c(d), if @c(x) is @c[(make-rat n d)], then

    ..example >
      (numer x)    n
      --------- = ---
      (denom x)    d
    < example..

    In fact, this is the only condition @c(make-rat), @c(numer), and @c(denom)
    must fulfill in order to form a suitable basis for a rational-number
    representation. In general, we can think of data as defined by some collection
    of selectors and constructors, together with specified conditions that these
    procedures must fulfill in order to be a valid representation.@n(71)

    This point of view can serve to define not only @"(high-level) data objects,
    such as rational numbers, but lower-level objects as well. Consider the notion
    of a pair, which we used in order to define our rational numbers. We never
    actually said what a pair was, only that the language supplied procedures
    @c(cons), @c(car), and @c(cdr) for operating on pairs. But the only thing we
    need to know about these three operations is that if we glue two objects
    together using @c(cons) we can retrieve the objects using @c(car) and
    @c(cdr). That is, the operations satisfy the condition that, for any objects
    @c(x) and @c(y), if @c(z) is @c[(cons x y)] then @c[(car z)] is @c(x) and
    @c[(cdr z)] is @c(y). Indeed, we mentioned that these three procedures are
    included as primitives in our language. However, any triple of procedures that
    satisfies the above condition can be used as the basis for implementing
    pairs. This point is illustrated strikingly by the fact that we could
    implement @c(cons), @c(car), and @c(cdr) without using any data structures at
    all but only using procedures. Here are the definitions:

    ..src > scheme
      (define (cons x y)
        (define (dispatch m)
          (cond ((= m 0) x)
                ((= m 1) y)
                (else
                 (error "Argument not 0 or 1:
                         CONS" m))))
        dispatch)

      (define (car z) (z 0))
      (define (cdr z) (z 1))
    < src..

    This use of procedures corresponds to nothing like our intuitive notion of
    what data should be. Nevertheless, all we need to do to show that this is a
    valid way to represent pairs is to verify that these procedures satisfy the
    condition given above.

    The subtle point to notice is that the value returned by @c[(cons x y)] is a
    procedure––namely the internally defined procedure @c(dispatch), which takes
    one argument and returns either @c(x) or @c(y) depending on whether the
    argument is 0 or 1. Correspondingly, @c[(car z)] is defined to apply @c(z)
    to 0. Hence, if @c(z) is the procedure formed by @c[(cons x y)], then @c(z)
    applied to 0 will yield @c(x). Thus, we have shown that @c[(car (cons x y))]
    yields @c(x), as desired. Similarly, @c[(cdr (cons x y))] applies the
    procedure returned by @c[(cons x y)] to 1, which returns @c(y). Therefore,
    this procedural implementation of pairs is a valid implementation, and if we
    access pairs using only @c(cons), @c(car), and @c(cdr) we cannot distinguish
    this implementation from one that uses @"(real) data structures.

    The point of exhibiting the procedural representation of pairs is not that our
    language works this way (Scheme, and Lisp systems in general, implement pairs
    directly, for efficiency reasons) but that it could work this way. The
    procedural representation, although obscure, is a perfectly adequate way to
    represent pairs, since it fulfills the only conditions that pairs need to
    fulfill. This example also demonstrates that the ability to manipulate
    procedures as objects automatically provides the ability to represent compound
    data. This may seem a curiosity now, but procedural representations of data
    will play a central role in our programming repertoire. This style of
    programming is often called @e(message passing), and we will be using it as a
    basic tool in @l(#Chapter 3) when we address the issues of modeling and
    simulation.

    :: @t(Exercise 2.4) :: Here is an alternative procedural representation of
       pairs. For this representation, verify that @c[(car (cons x y))] yields
       @c(x) for any objects @c(x) and @c(y).

       ..src > scheme
         (define (cons x y)
           (lambda (m) (m x y)))

         (define (car z)
           (z (lambda (p q) p)))
       < src..

       What is the corresponding definition of @c(cdr)? (Hint: To verify that this
       works, make use of the substitution model of @l(#1.1.5).)

    :: @t(Exercise 2.5) :: Show that we can represent pairs of nonnegative
       integers using only numbers and arithmetic operations if we represent the
       pair @m(a) and @m(b) as the integer that is the product @m(2ᵃ 3ᵇ).  Give
       the corresponding definitions of the procedures @c(cons), @c(car), and
       @c(cdr).

    :: @t(Exercise 2.6) :: In case representing pairs as procedures wasn't
       mind-boggling enough, consider that, in a language that can manipulate
       procedures, we can get by without numbers (at least insofar as nonnegative
       integers are concerned) by implementing 0 and the operation of adding 1 as

       ..src > scheme
         (define zero (lambda (f) (lambda (x) x)))

         (define (add-1 n)
           (lambda (f) (lambda (x) (f ((n f) x)))))
       < src..

       This representation is known as @e(Church numerals), after its inventor,
       Alonzo Church, the logician who invented the λ-calculus.

       Define @c(one) and @c(two) directly (not in terms of @c(zero) and
       @c(add-1)). (Hint: Use substitution to evaluate @c[(add-1 zero)]). Give a
       direct definition of the addition procedure @c(+) (not in terms of repeated
       application of @c(add-1)).

*** 2.1.4 <> Extended Exercise: Interval Arithmetic

    Alyssa P. Hacker is designing a system to help people solve engineering
    problems. One feature she wants to provide in her system is the ability to
    manipulate inexact quantities (such as measured parameters of physical
    devices) with known precision, so that when computations are done with such
    approximate quantities the results will be numbers of known precision.

    Electrical engineers will be using Alyssa's system to compute electrical
    quantities. It is sometimes necessary for them to compute the value of a
    parallel equivalent resistance @m(Rₚ) of two resistors @m(R₁) and @m(R₂) using
    the formula

    ..example >
                1
      Rₚ = -----------
           1/R₁ + 1/R₂
    < example..

    Resistance values are usually known only up to some tolerance guaranteed by
    the manufacturer of the resistor. For example, if you buy a resistor labeled
    @"(6.8 ohms with 10% tolerance) you can only be sure that the resistor has a
    resistance between 6.8 − 0.68 = 6.12 and 6.8 + 0.68 = 7.48 ohms. Thus, if you
    have a 6.8-ohm 10% resistor in parallel with a 4.7-ohm 5% resistor, the
    resistance of the combination can range from about 2.58 ohms (if the two
    resistors are at the lower bounds) to about 2.97 ohms (if the two resistors
    are at the upper bounds).

    Alyssa's idea is to implement @"(interval arithmetic) as a set of arithmetic
    operations for combining @"(intervals) (objects that represent the range of
    possible values of an inexact quantity). The result of adding, subtracting,
    multiplying, or dividing two intervals is itself an interval, representing the
    range of the result.

    Alyssa postulates the existence of an abstract object called an @"(interval)
    that has two endpoints: a lower bound and an upper bound. She also presumes
    that, given the endpoints of an interval, she can construct the interval using
    the data constructor @c(make-interval). Alyssa first writes a procedure for
    adding two intervals. She reasons that the minimum value the sum could be is
    the sum of the two lower bounds and the maximum value it could be is the sum
    of the two upper bounds:

    ..src > scheme
      (define (add-interval x y)
        (make-interval (+ (lower-bound x)
                          (lower-bound y))
                       (+ (upper-bound x)
                          (upper-bound y))))
    < src..

    Alyssa also works out the product of two intervals by finding the minimum and
    the maximum of the products of the bounds and using them as the bounds of the
    resulting interval. (@c(Min) and @c(max) are primitives that find the minimum
    or maximum of any number of arguments.)

    ..src > scheme
      (define (mul-interval x y)
        (let ((p1 (* (lower-bound x)
                     (lower-bound y)))
              (p2 (* (lower-bound x)
                     (upper-bound y)))
              (p3 (* (upper-bound x)
                     (lower-bound y)))
              (p4 (* (upper-bound x)
                     (upper-bound y))))
          (make-interval (min p1 p2 p3 p4)
                         (max p1 p2 p3 p4))))
    < src..

    To divide two intervals, Alyssa multiplies the first by the reciprocal of the
    second. Note that the bounds of the reciprocal interval are the reciprocal of
    the upper bound and the reciprocal of the lower bound, in that order.

    ..src > scheme
      (define (div-interval x y)
        (mul-interval x
                      (make-interval
                       (/ 1.0 (upper-bound y))
                       (/ 1.0 (lower-bound y)))))
    < src..

    :: @t(Exercise 2.7) :: Alyssa's program is incomplete because she has not
       specified the implementation of the interval abstraction.  Here is a
       definition of the interval constructor:

       ..src > scheme
         (define (make-interval a b) (cons a b))
       < src..

       Define selectors @c(upper-bound) and @c(lower-bound) to complete the
       implementation.

    :: @t(Exercise 2.8) :: Using reasoning analogous to Alyssa's, describe how the
       difference of two intervals may be computed. Define a corresponding
       subtraction procedure, called @c(sub-interval).

    :: @t(Exercise 2.9) :: The @e(width) of an interval is half of the difference
       between its upper and lower bounds. The width is a measure of the
       uncertainty of the number specified by the interval. For some arithmetic
       operations the width of the result of combining two intervals is a function
       only of the widths of the argument intervals, whereas for others the width
       of the combination is not a function of the widths of the argument
       intervals. Show that the width of the sum (or difference) of two intervals
       is a function only of the widths of the intervals being added (or
       subtracted).  Give examples to show that this is not true for
       multiplication or division.

    :: @t(Exercise 2.10) :: Ben Bitdiddle, an expert systems programmer, looks
       over Alyssa's shoulder and comments that it is not clear what it means to
       divide by an interval that spans zero. Modify Alyssa's code to check for
       this condition and to signal an error if it occurs.

    :: @t(Exercise 2.11) :: In passing, Ben also cryptically comments: @"(By
       testing the signs of the endpoints of the intervals, it is possible to
       break @c(mul-interval) into nine cases, only one of which requires more
       than two multiplications.)  Rewrite this procedure using Ben's suggestion.

       After debugging her program, Alyssa shows it to a potential user, who
       complains that her program solves the wrong problem. He wants a program
       that can deal with numbers represented as a center value and an additive
       tolerance; for example, he wants to work with intervals such as 3.5 @m(±)
       0.15 rather than [3.35, 3.65]. Alyssa returns to her desk and fixes this
       problem by supplying an alternate constructor and alternate selectors:

       ..src > scheme
         (define (make-center-width c w)
           (make-interval (- c w) (+ c w)))

         (define (center i)
           (/ (+ (lower-bound i)
                 (upper-bound i))
              2))

         (define (width i)
           (/ (- (upper-bound i)
                 (lower-bound i))
              2))
       < src..

       Unfortunately, most of Alyssa's users are engineers. Real engineering
       situations usually involve measurements with only a small uncertainty,
       measured as the ratio of the width of the interval to the midpoint of the
       interval.  Engineers usually specify percentage tolerances on the
       parameters of devices, as in the resistor specifications given earlier.

    :: @t(Exercise 2.12) :: Define a constructor @c(make-center-percent) that
       takes a center and a percentage tolerance and produces the desired
       interval. You must also define a selector @c(percent) that produces the
       percentage tolerance for a given interval. The @c(center) selector is the
       same as the one shown above.

    :: @t(Exercise 2.13) :: Show that under the assumption of small percentage
       tolerances there is a simple formula for the approximate percentage
       tolerance of the product of two intervals in terms of the tolerances of the
       factors. You may simplify the problem by assuming that all numbers are
       positive.

       After considerable work, Alyssa P. Hacker delivers her finished system.
       Several years later, after she has forgotten all about it, she gets a
       frenzied call from an irate user, Lem E. Tweakit. It seems that Lem has
       noticed that the formula for parallel resistors can be written in two
       algebraically equivalent ways:

       ..example >
          R₁ R₂
         -------
         R₁ + R₂
       < example..

       and

       ..example >
              1
         -----------
         1/R₁ + 1/R₂
       < example..

       He has written the following two programs, each of which computes the
       parallel-resistors formula differently:

       ..src > scheme
         (define (par1 r1 r2)
           (div-interval
            (mul-interval r1 r2)
            (add-interval r1 r2)))

         (define (par2 r1 r2)
           (let ((one (make-interval 1 1)))
             (div-interval
              one
              (add-interval
               (div-interval one r1)
               (div-interval one r2)))))
       < src..

       Lem complains that Alyssa's program gives different answers for the two
       ways of computing. This is a serious complaint.

    :: @t(Exercise 2.14) :: Demonstrate that Lem is right.  Investigate the
       behavior of the system on a variety of arithmetic expressions. Make some
       intervals @m(a) and @m(B), and use them in computing the expressions @m(A /
       A) and @m(A / B). You will get the most insight by using intervals whose
       width is a small percentage of the center value. Examine the results of the
       computation in center-percent form (see @l(#Exercise 2.12)).

    :: @t(Exercise 2.15) :: Eva Lu Ator, another user, has also noticed the
       different intervals computed by different but algebraically equivalent
       expressions. She says that a formula to compute with intervals using
       Alyssa's system will produce tighter error bounds if it can be written in
       such a form that no variable that represents an uncertain number is
       repeated. Thus, she says, @c(par2) is a @"(better) program for parallel
       resistances than @c(par1). Is she right?  Why?

    :: @t(Exercise 2.16) :: Explain, in general, why equivalent algebraic
       expressions may lead to different answers. Can you devise an
       interval-arithmetic package that does not have this shortcoming, or is this
       task impossible?  (Warning: This problem is very difficult.)

** 2.2 <> Hierarchical Data and the Closure Property

   As we have seen, pairs provide a primitive @"(glue) that we can use to
   construct compound data objects. @l(#Figure 2.2) shows a standard way to
   visualize a pair––in this case, the pair formed by @c[(cons 1 2)]. In this
   representation, which is called @e(box-and-pointer notation), each object is
   shown as a @e(pointer) to a box. The box for a primitive object contains a
   representation of the object. For example, the box for a number contains a
   numeral. The box for a pair is actually a double box, the left part containing
   (a pointer to) the @c(car) of the pair and the right part containing the
   @c(cdr).

   ..figure > @t(Figure 2.2) Box-and-pointer representation of @c[(cons 1 2)].

     ..art >
            ╭───┬───╮     ╭───╮
       ────▶│ ◆ │ ◆ ┼────▶│ 2 │
            ╰─┼─┴───╯     ╰───╯
              │
              ▼
            ╭───╮
            │ 1 │
            ╰───╯
     < art..

@  ..img > img/chap2/Fig2.2e.std.svg

   We have already seen that @c(cons) can be used to combine not only numbers but
   pairs as well. (You made use of this fact, or should have, in doing
   @l(#Exercise 2.2) and @l(#Exercise 2.3).)  As a consequence, pairs provide a
   universal building block from which we can construct all sorts of data
   structures. @l(#Figure 2.3) shows two ways to use pairs to combine the numbers
   1, 2, 3, and 4.

   ..figure > @t(Figure 2.3) Two ways to combine 1, 2, 3, and 4 using pairs.

     ..art >
            ╭───┬───╮     ╭───┬───╮         ╭───┬───╮     ╭───╮
       ────▶│ ◆ │ ◆ ┼────▶│ ◆ │ ◆ │    ────▶│ ◆ │ ◆ ┼────▶│ 4 │
            ╰─┼─┴───╯     ╰─┼─┴─┼─╯         ╰─┼─┴───╯     ╰───╯
              │             │   │             │
              ▼             ▼   ▼             ▼
          ╭───┬───╮      ╭───╮ ╭───╮      ╭───┬───╮     ╭───┬───╮
          │ ◆ │ ◆ │      │ 3 │ │ 4 │      │ ◆ │ ◆ ┼────▶│ ◆ │ ◆ │
          ╰─┼─┴─┼─╯      ╰───╯ ╰───╯      ╰─┼─┴───╯     ╰─┼─┴─┼─╯
            │   │                           │             │   │
            ▼   ▼                           ▼             ▼   ▼
         ╭───╮ ╭───╮                      ╭───╮        ╭───╮ ╭───╮
         │ 1 │ │ 2 │                      │ 1 │        │ 2 │ │ 3 │
         ╰───╯ ╰───╯                      ╰───╯        ╰───╯ ╰───╯

         (cons (cons 1 2)                 (cons (cons 1
               (cons 3 4))                            (cons 2 3))
                                                4)
     < art..

@  ..img > img/chap2/Fig2.3e.std.svg

   The ability to create pairs whose elements are pairs is the essence of list
   structure's importance as a representational tool. We refer to this ability as
   the @e(closure property) of @c(cons). In general, an operation for combining
   data objects satisfies the closure property if the results of combining things
   with that operation can themselves be combined using the same operation.@n(72)
   Closure is the key to power in any means of combination because it permits us
   to create @e(hierarchical) structures––structures made up of parts, which
   themselves are made up of parts, and so on.

   From the outset of @l(#Chapter 1), we've made essential use of closure in
   dealing with procedures, because all but the very simplest programs rely on
   the fact that the elements of a combination can themselves be combinations. In
   this section, we take up the consequences of closure for compound data. We
   describe some conventional techniques for using pairs to represent sequences
   and trees, and we exhibit a graphics language that illustrates closure in a
   vivid way.@n(73)

*** 2.2.1 <> Representing Sequences

    One of the useful structures we can build with pairs is a @e(sequence)––an
    ordered collection of data objects. There are, of course, many ways to
    represent sequences in terms of pairs. One particularly straightforward
    representation is illustrated in @l(#Figure 2.4), where the sequence 1, 2, 3,
    4 is represented as a chain of pairs. The @c(car) of each pair is the
    corresponding item in the chain, and the @c(cdr) of the pair is the next pair
    in the chain. The @c(cdr) of the final pair signals the end of the sequence by
    pointing to a distinguished value that is not a pair, represented in
    box-and-pointer diagrams as a diagonal line and in programs as the value of
    the variable @c(nil). The entire sequence is constructed by nested @c(cons)
    operations:

    ..src > scheme
      (cons 1
            (cons 2
                  (cons 3
                        (cons 4 nil))))
    < src..

    ..figure > @t(Figure 2.4) The sequence 1, 2, 3, 4 represented as a chain of pairs.

      ..art >
             ╭───┬───╮     ╭───┬───╮     ╭───┬───╮     ╭───┬───╮
        ────▶│ ◆ │ ◆ ┼────▶│ ◆ │ ◆ ┼────▶│ ◆ │ ◆ ┼────▶│ ◆ │ ╱ │
             ╰─┼─┴───╯     ╰─┼─┴───╯     ╰─┼─┴───╯     ╰─┼─┴───╯
               │             │             │             │
               ▼             ▼             ▼             ▼
             ╭───╮         ╭───╮         ╭───╮         ╭───╮
             │ 1 │         │ 2 │         │ 3 │         │ 4 │
             ╰───╯         ╰───╯         ╰───╯         ╰───╯
      < art..

@   ..img > img/chap2/Fig2.4e.std.svg

    Such a sequence of pairs, formed by nested @c(cons)es, is called a @e(list),
    and Scheme provides a primitive called @c(list) to help in constructing
    lists.@n(74) The above sequence could be produced by @c[(list 1 2 3 4)].  In
    general,

    ..src > scheme
      (list ⟨a₁⟩ ⟨a₂⟩ … ⟨aₙ⟩)
    < src..

    is equivalent to

    ..src > scheme
      (cons ⟨a₁⟩
            (cons ⟨a₂⟩
                  (cons …
                       (cons ⟨aₙ⟩
                             nil)…)))
    < src..

    Lisp systems conventionally print lists by printing the sequence of elements,
    enclosed in parentheses. Thus, the data object in @l(#Figure 2.4) is printed
    as @c[(1 2 3 4)]:

    ..srci > scheme
      > (define one-through-four (list 1 2 3 4))
      one-through-four
      > (1 2 3 4)
    < srci..

    Be careful not to confuse the expression @c[(list 1 2 3 4)] with the list
    @c[(1 2 3 4)], which is the result obtained when the expression is
    evaluated. Attempting to evaluate the expression @c[(1 2 3 4)] will signal an
    error when the interpreter tries to apply the procedure @c(1) to arguments
    @c(2), @c(3), @c(4).

    We can think of @c(car) as selecting the first item in the list, and of
    @c(cdr) as selecting the sublist consisting of all but the first item.  Nested
    applications of @c(car) and @c(cdr) can be used to extract the second, third,
    and subsequent items in the list.@n(75) The constructor @c(cons) makes a list
    like the original one, but with an additional item at the beginning.

    ..srci > scheme
      > (car one-through-four)
      1
      > (cdr one-through-four)
      (2 3 4)
      > (car (cdr one-through-four))
      2
      > (cons 10 one-through-four)
      (10 1 2 3 4)
      > (cons 5 one-through-four)
      (5 1 2 3 4)
    < srci..

    The value of @c(nil), used to terminate the chain of pairs, can be thought of
    as a sequence of no elements, the @e(empty list). The word @e(nil) is a
    contraction of the Latin word @e(nihil), which means @"(nothing.)@n(76)

**** List operations

     The use of pairs to represent sequences of elements as lists is accompanied by
     conventional programming techniques for manipulating lists by successively
     @"(@c(cdr)ing down) the lists. For example, the procedure @c(list-ref) takes
     as arguments a list and a number @m(n) and returns the @m(nᵗʰ) item of the
     list. It is customary to number the elements of the list beginning with 0.
     The method for computing @c(list-ref) is the following:

     - For @m(n = 0), @c(list-ref) should return the @c(car) of the list.

     - Otherwise, @c(list-ref) should return the @m[(n - 1)]-st item of the @c(cdr)
       of the list.

     ..srci > scheme
       > (define (list-ref items n)
       ^   (if (= n 0)
       ^       (car items)
       ^       (list-ref (cdr items)
       ^                 (- n 1))))
       > (define squares
       ^   (list 1 4 9 16 25))
       > (list-ref squares 3)
       16
     < srci..

     Often we @c(cdr) down the whole list. To aid in this, Scheme includes a
     primitive predicate @c(null?), which tests whether its argument is the empty
     list. The procedure @c(length), which returns the number of items in a list,
     illustrates this typical pattern of use:

     ..srci > scheme
       > (define (length items)
       ^   (if (null? items)
       ^       0
       ^       (+ 1 (length (cdr items)))))
       > (define odds
       ^   (list 1 3 5 7))
       > (length odds)
       4
     < srci..

     The @c(length) procedure implements a simple recursive plan. The reduction
     step is:

     - The @c(length) of any list is 1 plus the @c(length) of the @c(cdr) of the
       list.

     This is applied successively until we reach the base case:

     - The @c(length) of the empty list is 0.

     We could also compute @c(length) in an iterative style:

     ..src > scheme
       (define (length items)
         (define (length-iter a count)
           (if (null? a)
               count
               (length-iter (cdr a)
                            (+ 1 count))))
         (length-iter items 0))
     < src..

     Another conventional programming technique is to @"(@c(cons) up) an answer
     list while @c(cdr)ing down a list, as in the procedure @c(append), which takes
     two lists as arguments and combines their elements to make a new list:

     ..srci > scheme
       > (append squares odds)
       (1 4 9 16 25 1 3 5 7)
       > (append odds squares)
       (1 3 5 7 1 4 9 16 25)
     < srci..

     @c(Append) is also implemented using a recursive plan. To @c(append) lists
     @c(list1) and @c(list2), do the following:

     - If @c(list1) is the empty list, then the result is just @c(list2).

     - Otherwise, @c(append) the @c(cdr) of @c(list1) and @c(list2), and @c(cons)
       the @c(car) of @c(list1) onto the result:


     ..src > scheme
       (define (append list1 list2)
         (if (null? list1)
             list2
             (cons (car list1)
                   (append (cdr list1)
                           list2))))
     < src..

     :: @t(Exercise 2.17) :: Define a procedure @c(last-pair) that returns the list
        that contains only the last element of a given (nonempty) list:

        ..srci > scheme
          > (last-pair (list 23 72 149 34))
          (34)
        < srci..

     :: @t(Exercise 2.18) :: Define a procedure @c(reverse) that takes a list as
        argument and returns a list of the same elements in reverse order:

        ..srci > scheme
          > (reverse (list 1 4 9 16 25))
          (25 16 9 4 1)
        < srci..

     :: @t(Exercise 2.19) :: Consider the change-counting program of @l(#1.2.2). It
        would be nice to be able to easily change the currency used by the program,
        so that we could compute the number of ways to change a British pound, for
        example. As the program is written, the knowledge of the currency is
        distributed partly into the procedure @c(first-denomination) and partly
        into the procedure @c(count-change) (which knows that there are five kinds
        of U.S. coins). It would be nicer to be able to supply a list of coins to
        be used for making change.

        We want to rewrite the procedure @c(cc) so that its second argument is a
        list of the values of the coins to use rather than an integer specifying
        which coins to use. We could then have lists that defined each kind of
        currency:

        ..src > scheme
          (define us-coins
            (list 50 25 10 5 1))

          (define uk-coins
            (list 100 50 20 10 5 2 1 0.5))
        < src..

        We could then call @c(cc) as follows:

        ..srci > scheme
          > (cc 100 us-coins)
          292
        < srci..

        To do this will require changing the program @c(cc) somewhat. It will still
        have the same form, but it will access its second argument differently, as
        follows:

        ..src > scheme
          (define (cc amount coin-values)
            (cond ((= amount 0)
                   1)
                  ((or (< amount 0)
                       (no-more? coin-values))
                   0)
                  (else
                   (+ (cc
                       amount
                       (except-first-denomination
                        coin-values))
                      (cc
                       (- amount
                          (first-denomination
                           coin-values))
                       coin-values)))))
        < src..

        Define the procedures @c(first-denomination), @c(except-first-denomination)
        and @c(no-more?) in terms of primitive operations on list structures. Does
        the order of the list @c(coin-values) affect the answer produced by @c(cc)?
        Why or why not?

     :: @t(Exercise 2.20) :: The procedures @c(+), @c(*), and @c(list) take
        arbitrary numbers of arguments. One way to define such procedures is to use
        @c(define) with @e(dotted-tail notation).  In a procedure definition, a
        parameter list that has a dot before the last parameter name indicates
        that, when the procedure is called, the initial parameters (if any) will
        have as values the initial arguments, as usual, but the final parameter's
        value will be a @e(list) of any remaining arguments. For instance, given
        the definition

        ..src > scheme
          (define (f x y . z) ⟨body⟩)
        < src..

        the procedure @c(f) can be called with two or more arguments. If we
        evaluate

        ..src > scheme
          (f 1 2 3 4 5 6)
        < src..

        then in the body of @c(f), @c(x) will be 1, @c(y) will be 2, and @c(z) will
        be the list @c[(3 4 5 6)]. Given the definition

        ..src > scheme
          (define (g . w) ⟨body⟩)
        < src..

        the procedure @c(g) can be called with zero or more arguments. If we
        evaluate

        ..src > scheme
          (g 1 2 3 4 5 6)
        < src..

        then in the body of @c(g), @c(w) will be the list @c[(1 2 3 4 5 6)].@n(77)

        Use this notation to write a procedure @c(same-parity) that takes one or
        more integers and returns a list of all the arguments that have the same
        even-odd parity as the first argument. For example,

        ..srci > scheme
          > (same-parity 1 2 3 4 5 6 7)
          (1 3 5 7)
          > (same-parity 2 3 4 5 6 7)
          (2 4 6)
        < srci..

**** Mapping over lists

     One extremely useful operation is to apply some transformation to each element
     in a list and generate the list of results. For instance, the following
     procedure scales each number in a list by a given factor:

     ..srci > scheme
       > (define (scale-list items factor)
       ^   (if (null? items)
       ^       nil
       ^       (cons (* (car items) factor)
       ^             (scale-list (cdr items)
       ^                         factor))))

       > (scale-list (list 1 2 3 4 5) 10)
       (10 20 30 40 50)}
     < srci..

     We can abstract this general idea and capture it as a common pattern expressed
     as a higher-order procedure, just as in @l(#1.3). The higher-order procedure
     here is called @c(map). @c(Map) takes as arguments a procedure of one argument
     and a list, and returns a list of the results produced by applying the
     procedure to each element in the list:@n(78)

     ..srci > scheme
       > (define (map proc items)
       ^   (if (null? items)
       ^       nil
       ^       (cons (proc (car items))
       ^             (map proc (cdr items)))))

       > (map abs (list -10 2.5 -11.6 17))
       (10 2.5 11.6 17)
       > (map (lambda (x) (* x x)) (list 1 2 3 4))
       (1 4 9 16)
     < srci..

     Now we can give a new definition of @c(scale-list) in terms of @c(map):

     ..src > scheme
       (define (scale-list items factor)
         (map (lambda (x) (* x factor))
              items))
     < src..

     @c(Map) is an important construct, not only because it captures a common
     pattern, but because it establishes a higher level of abstraction in dealing
     with lists. In the original definition of @c(scale-list), the recursive
     structure of the program draws attention to the element-by-element processing
     of the list. Defining @c(scale-list) in terms of @c(map) suppresses that level
     of detail and emphasizes that scaling transforms a list of elements to a list
     of results. The difference between the two definitions is not that the
     computer is performing a different process (it isn't) but that we think about
     the process differently. In effect, @c(map) helps establish an abstraction
     barrier that isolates the implementation of procedures that transform lists
     from the details of how the elements of the list are extracted and combined.
     Like the barriers shown in @l(#Figure 2.1), this abstraction gives us the
     flexibility to change the low-level details of how sequences are implemented,
     while preserving the conceptual framework of operations that transform
     sequences to sequences. Section @l(#2.2.3) expands on this use of sequences as
     a framework for organizing programs.

     :: @t(Exercise 2.21) :: The procedure @c(square-list) takes a list of numbers
        as argument and returns a list of the squares of those numbers.

        ..src > scheme
          (square-list (list 1 2 3 4))
          @i{(1 4 9 16)}
        < src..

        Here are two different definitions of @c(square-list). Complete both of
        them by filling in the missing expressions:

        ..src > scheme
          (define (square-list items)
            (if (null? items)
                nil
                (cons ⟨??⟩ ⟨??⟩)))

          (define (square-list items)
            (map ⟨??⟩ ⟨??⟩))
        < src..

     :: @t(Exercise 2.22) :: Louis Reasoner tries to rewrite the first
        @c(square-list) procedure of @l(#Exercise 2.21) so that it evolves an
        iterative process:

        ..src > scheme
          (define (square-list items)
            (define (iter things answer)
              (if (null? things)
                  answer
                  (iter (cdr things)
                        (cons (square (car things))
                              answer))))
            (iter items nil))
        < src..

        Unfortunately, defining @c(square-list) this way produces the answer list
        in the reverse order of the one desired. Why?

        Louis then tries to fix his bug by interchanging the arguments to @c(cons):

        ..src > scheme
          (define (square-list items)
            (define (iter things answer)
              (if (null? things)
                  answer
                  (iter (cdr things)
                        (cons answer
                              (square
                               (car things))))))
            (iter items nil))
        < src..

        This doesn't work either. Explain.

     :: @t(Exercise 2.23) :: The procedure @c(for-each) is similar to @c(map). It
        takes as arguments a procedure and a list of elements. However, rather than
        forming a list of the results, @c(for-each) just applies the procedure to
        each of the elements in turn, from left to right.  The values returned by
        applying the procedure to the elements are not used at all––@c(for-each) is
        used with procedures that perform an action, such as printing. For example,

        ..srci > scheme
          > (for-each
          ^  (lambda (x) (newline) (display x))
          ^  (list 57 321 88))
          57
          321
          88
        < srci..

        The value returned by the call to @c(for-each) (not illustrated above) can
        be something arbitrary, such as true. Give an implementation of
        @c(for-each).

*** 2.2.2 <> Hierarchical Structures

    The representation of sequences in terms of lists generalizes naturally to
    represent sequences whose elements may themselves be sequences. For example,
    we can regard the object @c[((1 2) 3 4)] constructed by

    ..src > scheme
      (cons (list 1 2) (list 3 4))
    < src..

    as a list of three items, the first of which is itself a list, @c[(1 2)].
    Indeed, this is suggested by the form in which the result is printed by the
    interpreter. @l(#Figure 2.5) shows the representation of this structure in
    terms of pairs.

    ..figure > @t(Figure 2.5) Structure formed by @c[(cons (list 1 2) (list 3 4))].

      ..art >
              ((1 2) 3 4)                   (3 4)
                   │                          │
                   ▼                          ▼
               ╭───┬───╮                  ╭───┬───╮     ╭───┬───╮
               │ ◆ │ ◆ ┼─────────────────▶│ ◆ │ ◆ ┼────▶│ ◆ │ ╱ │
               ╰─┼─┴───╯                  ╰─┼─┴───╯     ╰─┼─┴───╯
                 │                          │             │
                 ▼                          ▼             ▼
        (1 2)  ╭───┬───╮     ╭───┬───╮    ╭───╮         ╭───╮
        ──────▶│ ◆ │ ◆ ┼────▶│ ◆ │ ╱ │    │ 3 │         │ 4 │
               ╰─┼─┴───╯     ╰─┼─┴───╯    ╰───╯         ╰───╯
                 │             │
                 ▼             ▼
               ╭───╮         ╭───╮
               │ 1 │         │ 2 │
               ╰───╯         ╰───╯
      < art..

@   ..img > img/chap2/Fig2.5e.std.svg

    Another way to think of sequences whose elements are sequences is as
    @e(trees). The elements of the sequence are the branches of the tree, and
    elements that are themselves sequences are subtrees. @l(#Figure 2.6) shows the
    structure in @l(#Figure 2.5) viewed as a tree.

    ..figure > @t(Figure 2.6) The list structure in @l(#Figure 2.5) viewed as a tree.

      ..art >
           ((1 2) 3 4)
               /|\
              / | \
             /  |  \
            /   |   \
         (1 2)  3    4
          / \
         /   \
        1     2
      < art..

@   ..img > img/chap2/Fig2.6b.std.svg

    Recursion is a natural tool for dealing with tree structures, since we can
    often reduce operations on trees to operations on their branches, which reduce
    in turn to operations on the branches of the branches, and so on, until we
    reach the leaves of the tree. As an example, compare the @c(length) procedure
    of @l(#2.2.1) with the @c(count-leaves) procedure, which returns the total
    number of leaves of a tree:

    ..srci > scheme
      > (define x (cons (list 1 2) (list 3 4)))
      > (length x)
      3
      > (count-leaves x)
      4
      > (list x x)
      (((1 2) 3 4) ((1 2) 3 4))
      > (length (list x x))
      2
      > (count-leaves (list x x))
      8
    < srci..

    To implement @c(count-leaves), recall the recursive plan for computing
    @c(length):

    - @c(Length) of a list @c(x) is 1 plus @c(length) of the @c(cdr) of @c(x).

    - @c(Length) of the empty list is 0.


    @c(Count-leaves) is similar. The value for the empty list is the same:

    - @c(Count-leaves) of the empty list is 0.

    But in the reduction step, where we strip off the @c(car) of the list, we must
    take into account that the @c(car) may itself be a tree whose leaves we need
    to count. Thus, the appropriate reduction step is

    - @c(Count-leaves) of a tree @c(x) is @c(count-leaves) of the @c(car) of @c(x)
      plus @c(count-leaves) of the @c(cdr) of @c(x).

    Finally, by taking @c(car)s we reach actual leaves, so we need another base
    case:

    - @c(Count-leaves) of a leaf is 1.

    To aid in writing recursive procedures on trees, Scheme provides the primitive
    predicate @c(pair?), which tests whether its argument is a pair. Here is the
    complete procedure:@n(79)

    ..src > scheme
      (define (count-leaves x)
        (cond ((null? x) 0)
              ((not (pair? x)) 1)
              (else (+ (count-leaves (car x))
                       (count-leaves (cdr x))))))
    < src..

    :: @t(Exercise 2.24) :: Suppose we evaluate the expression @c[(list 1 (list 2
       (list 3 4)))]. Give the result printed by the interpreter, the
       corresponding box-and-pointer structure, and the interpretation of this as
       a tree (as in @l(#Figure 2.6)).

    :: @t(Exercise 2.25) :: Give combinations of @c(car)s and @c(cdr)s that will
       pick 7 from each of the following lists:

       ..src > scheme
         (1 3 (5 7) 9)
         ((7))
         (1 (2 (3 (4 (5 (6 7))))))
       < src..

    :: @t(Exercise 2.26) :: Suppose we define @c(x) and @c(y) to be two lists:

       ..src > scheme
         (define x (list 1 2 3))
         (define y (list 4 5 6))
       < src..

       What result is printed by the interpreter in response to evaluating each of
       the following expressions:

       ..src > scheme
         (append x y)
         (cons x y)
         (list x y)
       < src..

    :: @t(Exercise 2.27) :: Modify your @c(reverse) procedure of @l(#Exercise
       2.18) to produce a @c(deep-reverse) procedure that takes a list as argument
       and returns as its value the list with its elements reversed and with all
       sublists deep-reversed as well. For example,

       ..srci > scheme
         > (define x
         ^   (list (list 1 2) (list 3 4)))
         > x
         ((1 2) (3 4))
         > (reverse x)
         ((3 4) (1 2))
         > (deep-reverse x)
         ((4 3) (2 1))
       < srci..

    :: @t(Exercise 2.28) :: Write a procedure @c(fringe) that takes as argument a
       tree (represented as a list) and returns a list whose elements are all the
       leaves of the tree arranged in left-to-right order. For example,

       ..srci > scheme
         > (define x
         ^   (list (list 1 2) (list 3 4)))

         > (fringe x)
         (1 2 3 4)
         > (fringe (list x x))
         (1 2 3 4 1 2 3 4)
       < srci..

    :: @t(Exercise 2.29) :: A binary mobile consists of two branches, a left
       branch and a right branch. Each branch is a rod of a certain length, from
       which hangs either a weight or another binary mobile. We can represent a
       binary mobile using compound data by constructing it from two branches (for
       example, using @c(list)):

       ..src > scheme
         (define (make-mobile left right)
           (list left right))
       < src..

       A branch is constructed from a @c(length) (which must be a number) together
       with a @c(structure), which may be either a number (representing a simple
       weight) or another mobile:

       ..src > scheme
         (define (make-branch length structure)
           (list length structure))
       < src..

       1. Write the corresponding selectors @c(left-branch) and @c(right-branch),
          which return the branches of a mobile, and @c(branch-length) and
          @c(branch-structure), which return the components of a branch.

       2. Using your selectors, define a procedure @c(total-weight) that returns
          the total weight of a mobile.

       3. A mobile is said to be @e(balanced) if the torque applied by its
          top-left branch is equal to that applied by its top-right branch (that
          is, if the length of the left rod multiplied by the weight hanging from
          that rod is equal to the corresponding product for the right side) and
          if each of the submobiles hanging off its branches is balanced. Design a
          predicate that tests whether a binary mobile is balanced.

       4. Suppose we change the representation of mobiles so that the constructors
          are

          ..src > scheme
            (define (make-mobile left right)
              (cons left right))

            (define (make-branch length structure)
              (cons length structure))
          < src..

          How much do you need to change your programs to convert to the new
          representation?

**** Mapping over trees

     Just as @c(map) is a powerful abstraction for dealing with sequences, @c(map)
     together with recursion is a powerful abstraction for dealing with trees. For
     instance, the @c(scale-tree) procedure, analogous to @c(scale-list) of
     @l(#2.2.1), takes as arguments a numeric factor and a tree whose leaves are
     numbers. It returns a tree of the same shape, where each number is multiplied
     by the factor. The recursive plan for @c(scale-tree) is similar to the one for
     @c(count-leaves):

     ..srci > scheme
       > (define (scale-tree tree factor)
       ^   (cond ((null? tree) nil)
       ^         ((not (pair? tree))
       ^          (* tree factor))
       ^         (else
       ^          (cons (scale-tree (car tree)
       ^                            factor)
       ^                (scale-tree (cdr tree)
       ^                            factor)))))

       > (scale-tree (list 1
       ^                   (list 2 (list 3 4) 5)
       ^                   (list 6 7))
       ^             10)
       (10 (20 (30 40) 50) (60 70))
     < srci..

     Another way to implement @c(scale-tree) is to regard the tree as a sequence of
     sub-trees and use @c(map). We map over the sequence, scaling each sub-tree in
     turn, and return the list of results. In the base case, where the tree is a
     leaf, we simply multiply by the factor:

     ..src > scheme
       (define (scale-tree tree factor)
         (map (lambda (sub-tree)
                (if (pair? sub-tree)
                    (scale-tree sub-tree factor)
                    (* sub-tree factor)))
              tree))
     < src..

     Many tree operations can be implemented by similar combinations of sequence
     operations and recursion.

     :: @t(Exercise 2.30) :: Define a procedure @c(square-tree) analogous to the
        @c(square-list) procedure of @l(#Exercise 2.21). That is, @c(square-tree)
        should behave as follows:

        ..srci > scheme
          > (square-tree
          ^  (list 1
          ^        (list 2 (list 3 4) 5)
          ^        (list 6 7)))
          (1 (4 (9 16) 25) (36 49))
        < srci..

        Define @c(square-tree) both directly (i.e., without using any higher-order
        procedures) and also by using @c(map) and recursion.

     :: @t(Exercise 2.31) :: Abstract your answer to @l(#Exercise 2.30) to produce
        a procedure @c(tree-map) with the property that @c(square-tree) could be
        defined as

        ..src > scheme
          (define (square-tree tree)
            (tree-map square tree))
        < src..

     :: @t(Exercise 2.32) :: We can represent a set as a list of distinct elements,
        and we can represent the set of all subsets of the set as a list of
        lists. For example, if the set is @c[(1 2 3)], then the set of all subsets
        is @c[(() (3) (2) (2 3) (1) (1 3) (1 2) (1 2 3))]. Complete the following
        definition of a procedure that generates the set of subsets of a set and
        give a clear explanation of why it works:

        ..src > scheme
          (define (subsets s)
            (if (null? s)
                (list nil)
                (let ((rest (subsets (cdr s))))
                  (append rest (map ⟨??⟩ rest)))))
        < src..

*** 2.2.3 <> Sequences as Conventional Interfaces

    In working with compound data, we've stressed how data abstraction permits us
    to design programs without becoming enmeshed in the details of data
    representations, and how abstraction preserves for us the flexibility to
    experiment with alternative representations. In this section, we introduce
    another powerful design principle for working with data structures––the use of
    @e(conventional interfaces).

    In @l(#1.3) we saw how program abstractions, implemented as higher-order
    procedures, can capture common patterns in programs that deal with numerical
    data. Our ability to formulate analogous operations for working with compound
    data depends crucially on the style in which we manipulate our data
    structures. Consider, for example, the following procedure, analogous to the
    @c(count-leaves) procedure of @l(#2.2.2), which takes a tree as argument and
    computes the sum of the squares of the leaves that are odd:

    ..src > scheme
      (define (sum-odd-squares tree)
        (cond ((null? tree) 0)
              ((not (pair? tree))
               (if (odd? tree) (square tree) 0))
              (else (+ (sum-odd-squares
                        (car tree))
                       (sum-odd-squares
                        (cdr tree))))))
    < src..

    On the surface, this procedure is very different from the following one, which
    constructs a list of all the even Fibonacci numbers @m[Fib(k)], where @m(k) is
    less than or equal to a given integer @m(n):

    ..src > scheme
      (define (even-fibs n)
        (define (next k)
          (if (> k n)
              nil
              (let ((f (fib k)))
                (if (even? f)
                    (cons f (next (+ k 1)))
                    (next (+ k 1))))))
        (next 0))
    < src..

    Despite the fact that these two procedures are structurally very different, a
    more abstract description of the two computations reveals a great deal of
    similarity. The first program

    - enumerates the leaves of a tree;

    - filters them, selecting the odd ones;

    - squares each of the selected ones; and

    - accumulates the results using @c(+), starting with 0.

    The second program

    - enumerates the integers from 0 to @m(n);

    - computes the Fibonacci number for each integer;

    - filters them, selecting the even ones; and

    - accumulates the results using @c(cons), starting with the empty list.


    A signal-processing engineer would find it natural to conceptualize these
    processes in terms of signals flowing through a cascade of stages, each of
    which implements part of the program plan, as shown in @l(#Figure 2.7). In
    @c(sum-odd-squares), we begin with an @e(enumerator), which generates a
    @"(signal) consisting of the leaves of a given tree. This signal is passed
    through a @e(filter), which eliminates all but the odd elements. The resulting
    signal is in turn passed through a @e(map), which is a @"(transducer) that
    applies the @c(square) procedure to each element. The output of the map is
    then fed to an @e(accumulator), which combines the elements using @c(+),
    starting from an initial 0. The plan for @c(even-fibs) is analogous.

    ..figure > @t(Figure 2.7) The signal-flow plans for the procedures
      @c(sum-odd-squares) (top) and @c(even-fibs) (bottom) reveal the commonality
      between the two programs.

      ..art >
        ╭─────────────╮   ╭──────────╮   ╭─────────╮   ╭─────────────╮
        │ enumerate:  ├──▶│ filter:  ├──▶│ map:    ├──▶│ accumulate: │
        │ tree leaves │   │ odd?     │   │ square  │   │ +, 0        │
        ╰─────────────╯   ╰──────────╯   ╰─────────╯   ╰─────────────╯

        ╭─────────────╮   ╭──────────╮   ╭─────────╮   ╭─────────────╮
        │ enumerate:  ├──▶│ map:     ├──▶│ filter: ├──▶│ accumulate: │
        │ integers    │   │ fib      │   │ even?   │   │ cons, ()    │
        ╰─────────────╯   ╰──────────╯   ╰─────────╯   ╰─────────────╯
      < art..

@   ..img > img/chap2/Fig2.7e.std.svg

    Unfortunately, the two procedure definitions above fail to exhibit this
    signal-flow structure. For instance, if we examine the @c(sum-odd-squares)
    procedure, we find that the enumeration is implemented partly by the @c(null?)
    and @c(pair?) tests and partly by the tree-recursive structure of the
    procedure. Similarly, the accumulation is found partly in the tests and partly
    in the addition used in the recursion. In general, there are no distinct parts
    of either procedure that correspond to the elements in the signal-flow
    description. Our two procedures decompose the computations in a different way,
    spreading the enumeration over the program and mingling it with the map, the
    filter, and the accumulation. If we could organize our programs to make the
    signal-flow structure manifest in the procedures we write, this would increase
    the conceptual clarity of the resulting code.

**** Sequence Operations

     The key to organizing programs so as to more clearly reflect the signal-flow
     structure is to concentrate on the @"(signals) that flow from one stage in the
     process to the next. If we represent these signals as lists, then we can use
     list operations to implement the processing at each of the stages. For
     instance, we can implement the mapping stages of the signal-flow diagrams
     using the @c(map) procedure from @l(#2.2.1):

     ..srci > scheme
       > (map square (list 1 2 3 4 5))
       (1 4 9 16 25)
     < srci..

     Filtering a sequence to select only those elements that satisfy a given
     predicate is accomplished by

     ..src > scheme
       (define (filter predicate sequence)
         (cond ((null? sequence) nil)
               ((predicate (car sequence))
                (cons (car sequence)
                      (filter predicate
                              (cdr sequence))))
               (else  (filter predicate
                              (cdr sequence)))))
     < src..

     For example,

     ..srci > scheme
       > (filter odd? (list 1 2 3 4 5))
       (1 3 5)
     < srci..

     Accumulations can be implemented by

     ..srci > scheme
       > (define (accumulate op initial sequence)
       ^   (if (null? sequence)
       ^       initial
       ^       (op (car sequence)
       ^           (accumulate op
       ^                       initial
       ^                       (cdr sequence)))))

       > (accumulate + 0 (list 1 2 3 4 5))
       15
       > (accumulate * 1 (list 1 2 3 4 5))
       120
       > (accumulate cons nil (list 1 2 3 4 5))
       (1 2 3 4 5)
     < srci..

     All that remains to implement signal-flow diagrams is to enumerate the
     sequence of elements to be processed. For @c(even-fibs), we need to generate
     the sequence of integers in a given range, which we can do as follows:

     ..srci > scheme
       > (define (enumerate-interval low high)
       ^   (if (> low high)
       ^       nil
       ^       (cons low
       ^             (enumerate-interval
       ^              (+ low 1)
       ^              high))))
       > (enumerate-interval 2 7)
       (2 3 4 5 6 7)
     < srci..

     To enumerate the leaves of a tree, we can use@n(80)

     ..srci > scheme
       > (define (enumerate-tree tree)
       ^   (cond ((null? tree) nil)
       ^         ((not (pair? tree)) (list tree))
       ^         (else (append
       ^                (enumerate-tree (car tree))
       ^                (enumerate-tree (cdr tree))))))
       > (enumerate-tree (list 1 (list 2 (list 3 4)) 5))
       (1 2 3 4 5)
     < srci..

     Now we can reformulate @c(sum-odd-squares) and @c(even-fibs) as in the
     signal-flow diagrams. For @c(sum-odd-squares), we enumerate the sequence of
     leaves of the tree, filter this to keep only the odd numbers in the sequence,
     square each element, and sum the results:

     ..src > scheme
       (define (sum-odd-squares tree)
         (accumulate
          +
          0
          (map square
               (filter odd?
                       (enumerate-tree tree)))))
     < src..

     For @c(even-fibs), we enumerate the integers from 0 to @m(n), generate the
     Fibonacci number for each of these integers, filter the resulting sequence to
     keep only the even elements, and accumulate the results into a list:

     ..src > scheme
       (define (even-fibs n)
         (accumulate
          cons
          nil
          (filter even?
                  (map fib
                       (enumerate-interval 0 n)))))
     < src..

     The value of expressing programs as sequence operations is that this helps us
     make program designs that are modular, that is, designs that are constructed
     by combining relatively independent pieces. We can encourage modular design by
     providing a library of standard components together with a conventional
     interface for connecting the components in flexible ways.

     Modular construction is a powerful strategy for controlling complexity in
     engineering design. In real signal-processing applications, for example,
     designers regularly build systems by cascading elements selected from
     standardized families of filters and transducers. Similarly, sequence
     operations provide a library of standard program elements that we can mix and
     match. For instance, we can reuse pieces from the @c(sum-odd-squares) and
     @c(even-fibs) procedures in a program that constructs a list of the squares of
     the first @m(n + 1) Fibonacci numbers:

     ..srci > scheme
       > (define (list-fib-squares n)
       ^   (accumulate
       ^    cons
       ^    nil
       ^    (map square
       ^         (map fib
       ^              (enumerate-interval 0 n)))))

       > (list-fib-squares 10)
       (0 1 1 4 9 25 64 169 441 1156 3025)
     < srci..

     We can rearrange the pieces and use them in computing the product of the
     squares of the odd integers in a sequence:

     ..srci > scheme
       > (define
       ^   (product-of-squares-of-odd-elements
       ^    sequence)
       ^   (accumulate
       ^    *
       ^    1
       ^    (map square (filter odd? sequence))))

       > (product-of-squares-of-odd-elements
       ^  (list 1 2 3 4 5))
       225
     < srci..

     We can also formulate conventional data-processing applications in terms of
     sequence operations. Suppose we have a sequence of personnel records and we
     want to find the salary of the highest-paid programmer. Assume that we have a
     selector @c(salary) that returns the salary of a record, and a predicate
     @c(programmer?) that tests if a record is for a programmer. Then we can write

     ..src > scheme
       (define
         (salary-of-highest-paid-programmer
          records)
         (accumulate
          max
          0
          (map salary
               (filter programmer? records))))
     < src..

     These examples give just a hint of the vast range of operations that can be
     expressed as sequence operations.@n(81)

     Sequences, implemented here as lists, serve as a conventional interface that
     permits us to combine processing modules. Additionally, when we uniformly
     represent structures as sequences, we have localized the data-structure
     dependencies in our programs to a small number of sequence operations. By
     changing these, we can experiment with alternative representations of
     sequences, while leaving the overall design of our programs intact. We will
     exploit this capability in @l(#3.5), when we generalize the
     sequence-processing paradigm to admit infinite sequences.

     :: @t(Exercise 2.33) :: Fill in the missing expressions to complete the
        following definitions of some basic list-manipulation operations as
        accumulations:

        ..src > scheme
          (define (map p sequence)
            (accumulate (lambda (x y) ⟨??⟩)
                        nil sequence))

          (define (append seq1 seq2)
            (accumulate cons ⟨??⟩ ⟨??⟩))

          (define (length sequence)
            (accumulate ⟨??⟩ 0 sequence))
        < src..

     :: @t(Exercise 2.34) :: Evaluating a polynomial in @m(x) at a given value of
        @m(x) can be formulated as an accumulation. We evaluate the polynomial

        ..example >
          aₙxⁿ + a₍ₙ₋₁₎x⁽ⁿ⁻¹⁾ + ... + a₁x + a₀
        < example..

        using a well-known algorithm called @e(Horner's rule), which structures the
        computation as

        ..example >
          (... (aₙx + a₍ₙ₋₁₎)x + ... + a₁)x + a₀
        < example..

        In other words, we start with @m(aₙ), multiply by @m(x), add @m(aₙ₋₁),
        multiply by @m(x), and so on, until we reach @m(a₀).@n(82)

        Fill in the following template to produce a procedure that evaluates a
        polynomial using Horner's rule. Assume that the coefficients of the
        polynomial are arranged in a sequence, from @m(a₀) through @m(aₙ).

        ..src > scheme
          (define
            (horner-eval x coefficient-sequence)
            (accumulate
             (lambda (this-coeff higher-terms)
               ⟨??⟩)
             0
             coefficient-sequence))
        < src..

        For example, to compute @m(1 + 3x + 5x³ + x⁵) at @m(x = 2) you would
        evaluate

        ..src > scheme
          (horner-eval 2 (list 1 3 0 5 0 1))
        < src..

     :: @t(Exercise 2.35) :: Redefine @c(count-leaves) from @l(#2.2.2) as an
        accumulation:

        ..src > scheme
          (define (count-leaves t)
            (accumulate ⟨??⟩ ⟨??⟩ (map ⟨??⟩ ⟨??⟩)))
        < src..

     :: @t(Exercise 2.36) :: The procedure @c(accumulate-n) is similar to
        @c(accumulate) except that it takes as its third argument a sequence of
        sequences, which are all assumed to have the same number of elements. It
        applies the designated accumulation procedure to combine all the first
        elements of the sequences, all the second elements of the sequences, and so
        on, and returns a sequence of the results. For instance, if @c(s) is a
        sequence containing four sequences, @c[((1 2 3) (4 5 6) (7 8 9) (10 11
        12))], then the value of @c[(accumulate-n + 0 s)] should be the sequence
        @c[(22 26 30)]. Fill in the missing expressions in the following definition
        of @c(accumulate-n):

        ..src > scheme
          (define (accumulate-n op init seqs)
            (if (null? (car seqs))
                nil
                (cons (accumulate op init ⟨??⟩)
                      (accumulate-n op init ⟨??⟩))))
        < src..

     :: @t(Exercise 2.37) :: Suppose we represent vectors @b{v} = @m[(vᵢ)] as
        sequences of numbers, and matrices @b{m} = @m[(mᵢⱼ)] as sequences of
        vectors (the rows of the matrix). For example, the matrix

        ..example >
          ╭          ╮
          │  1 2 3 4 │
          │  4 5 6 6 │
          │  6 7 8 9 │
          ╰          ╯
        < example..

        is represented as the sequence @c[((1 2 3 4) (4 5 6 6) (6 7 8 9))]. With
        this representation, we can use sequence operations to concisely express
        the basic matrix and vector operations. These operations (which are
        described in any book on matrix algebra) are the following:

        ..example >
              (dot-product v w)  returns the sum ∑ᵢ vᵢ wᵢ

          (matrix-*-vector m v)  returns the vector t,

                                 where tᵢ = ∑ⱼmᵢⱼvⱼ

          (matrix-*-matrix m n)  returns the matrix p,

                                 where pᵢⱼ = ∑ₙmᵢₖnₖⱼ

                  (transpose m)  returns the matrix n,
                                 where nᵢⱼ = mⱼᵢ
        < example..

        We can define the dot product as@n(83)

        ..src > scheme
          (define (dot-product v w)
            (accumulate + 0 (map * v w)))
        < src..

        Fill in the missing expressions in the following procedures for computing
        the other matrix operations. (The procedure @c(accumulate-n) is defined in
        @l(#Exercise 2.36).)

        ..src > scheme
          (define (matrix-*-vector m v)
            (map ⟨??⟩ m))

          (define (transpose mat)
            (accumulate-n ⟨??⟩ ⟨??⟩ mat))

          (define (matrix-*-matrix m n)
            (let ((cols (transpose n)))
              (map ⟨??⟩ m)))
        < src..

     :: @t(Exercise 2.38) :: The @c(accumulate) procedure is also known as
        @c(fold-right), because it combines the first element of the sequence with
        the result of combining all the elements to the right. There is also a
        @c(fold-left), which is similar to @c(fold-right), except that it combines
        elements working in the opposite direction:

        ..src > scheme
          (define (fold-left op initial sequence)
            (define (iter result rest)
              (if (null? rest)
                  result
                  (iter (op result (car rest))
                        (cdr rest))))
            (iter initial sequence))
        < src..

        What are the values of

        ..src > scheme
          (fold-right / 1 (list 1 2 3))
          (fold-left  / 1 (list 1 2 3))
          (fold-right list nil (list 1 2 3))
          (fold-left  list nil (list 1 2 3))
        < src..

        Give a property that @c(op) should satisfy to guarantee that @c(fold-right)
        and @c(fold-left) will produce the same values for any sequence.

     :: @t(Exercise 2.39) :: Complete the following definitions of @c(reverse)
        (@l(#Exercise 2.18)) in terms of @c(fold-right) and @c(fold-left) from
        @l(#Exercise 2.38):

        ..src > scheme
          (define (reverse sequence)
            (fold-right
             (lambda (x y) ⟨??⟩) nil sequence))

          (define (reverse sequence)
            (fold-left
             (lambda (x y) ⟨??⟩) nil sequence))
        < src..

**** Nested Mappings

     We can extend the sequence paradigm to include many computations that are
     commonly expressed using nested loops.@n(84) Consider this problem: Given a
     positive integer @m(n), find all ordered pairs of distinct positive integers
     @m(i) and @m(j), where @m(1 ≤ j < i ≤ n), such that @m(i + j) is prime. For
     example, if @m(n) is 6, then the pairs are the following:

     ..example >
         i   | 2 3 4 4 5 6 6
         j   | 1 2 1 3 2 1 5
       ------+---------------
       i + j | 3 5 5 7 7 7 11
     < example..

     A natural way to organize this computation is to generate the sequence of all
     ordered pairs of positive integers less than or equal to @m(n), filter to
     select those pairs whose sum is prime, and then, for each pair @m[(i, j)] that
     passes through the filter, produce the triple @m[(i, j, i + j)].

     Here is a way to generate the sequence of pairs: For each integer @m(i ≤ n),
     enumerate the integers @m(j < i), and for each such @m(i) and @m(j) generate
     the pair @m[(i, j)]. In terms of sequence operations, we map along the
     sequence @c[(enumerate-interval 1 n)]. For each @m(i) in this sequence, we map
     along the sequence @c[(enumerate-interval 1 (- i 1))]. For each @m(j) in this
     latter sequence, we generate the pair @c[(list i j)]. This gives us a sequence
     of pairs for each @m(i). Combining all the sequences for all the @m(i) (by
     accumulating with @c(append)) produces the required sequence of pairs:@n(85)

     ..src > scheme
       (accumulate
        append
        nil
        (map (lambda (i)
               (map (lambda (j)
                      (list i j))
                    (enumerate-interval 1 (- i 1))))
             (enumerate-interval 1 n)))
     < src..

     The combination of mapping and accumulating with @c(append) is so common in
     this sort of program that we will isolate it as a separate procedure:

     ..src > scheme
       (define (flatmap proc seq)
         (accumulate append nil (map proc seq)))
     < src..

     Now filter this sequence of pairs to find those whose sum is prime. The filter
     predicate is called for each element of the sequence; its argument is a pair
     and it must extract the integers from the pair. Thus, the predicate to apply
     to each element in the sequence is

     ..src > scheme
       (define (prime-sum? pair)
         (prime? (+ (car pair) (cadr pair))))
     < src..

     Finally, generate the sequence of results by mapping over the filtered pairs
     using the following procedure, which constructs a triple consisting of the two
     elements of the pair along with their sum:

     ..src > scheme
       (define (make-pair-sum pair)
         (list (car pair)
               (cadr pair)
               (+ (car pair) (cadr pair))))
     < src..

     Combining all these steps yields the complete procedure:

     ..src > scheme
       (define (prime-sum-pairs n)
         (map make-pair-sum
              (filter
               prime-sum?
               (flatmap
                (lambda (i)
                  (map (lambda (j)
                         (list i j))
                       (enumerate-interval
                        1
                        (- i 1))))
                (enumerate-interval 1 n)))))
     < src..

     Nested mappings are also useful for sequences other than those that enumerate
     intervals. Suppose we wish to generate all the permutations of a set @m(S);
     that is, all the ways of ordering the items in the set. For instance, the
     permutations of @m({1, 2, 3}) are @m({1, 2, 3}), @m({1, 3, 2}), @m({2, 1, 3}),
     @m({2, 3, 1}), @m({3, 1, 2}), and @m({3, 2, 1}). Here is a plan for generating
     the permutations of @m(S): For each item @m(x) in @m(S), recursively generate
     the sequence of permutations of @m(S - x),@n(86) and adjoin @m(x) to the front
     of each one.  This yields, for each @m(x) in @m(S), the sequence of
     permutations of @m(S) that begin with @m(x). Combining these sequences for all
     @m(x) gives all the permutations of @m(S):@n(87)

     ..src > scheme
       (define (permutations s)
         (if (null? s)   ; empty set?
             (list nil)  ; sequence containing empty set
             (flatmap (lambda (x)
                        (map (lambda (p)
                               (cons x p))
                             (permutations
                              (remove x s))))
                      s)))
     < src..

     Notice how this strategy reduces the problem of generating permutations of
     @m(S) to the problem of generating the permutations of sets with fewer elements
     than @m(S). In the terminal case, we work our way down to the empty list,
     which represents a set of no elements. For this, we generate @c[(list
     nil)], which is a sequence with one item, namely the set with no elements. The
     @c(remove) procedure used in @c(permutations) returns all the items in a
     given sequence except for a given item. This can be expressed as a simple
     filter:

     ..src > scheme
       (define (remove item sequence)
         (filter (lambda (x) (not (= x item)))
                 sequence))
     < src..

     :: @t(Exercise 2.40) :: Define a procedure @c(unique-pairs) that, given an
        integer @m(n), generates the sequence of pairs @m[(i, j)] with @m(1 ≤ j < i
        ≤ n). Use @c(unique-pairs) to simplify the definition of
        @c(prime-sum-pairs) given above.

     :: @t(Exercise 2.41) :: Write a procedure to find all ordered triples of
        distinct positive integers @m(i), @m(j), and @m(k) less than or equal to a
        given integer @m(n) that sum to a given integer @m(s).

     :: @t(Exercise 2.42) :: The @"(eight-queens puzzle) asks how to place eight
        queens on a chessboard so that no queen is in check from any other (i.e.,
        no two queens are in the same row, column, or diagonal). One possible
        solution is shown in @l(#Figure 2.8). One way to solve the puzzle is to
        work across the board, placing a queen in each column. Once we have placed
        @m(k - 1) queens, we must place the @m(kᵗʰ) queen in a position where it
        does not check any of the queens already on the board. We can formulate
        this approach recursively: Assume that we have already generated the
        sequence of all possible ways to place @m(k - 1) queens in the first
        @m(k - 1) columns of the board. For each of these ways, generate an
        extended set of positions by placing a queen in each row of the @m(kᵗʰ)
        column. Now filter these, keeping only the positions for which the queen in
        the @m(kᵗʰ) column is safe with respect to the other queens. This produces
        the sequence of all ways to place @m(k) queens in the first @m(k)
        columns. By continuing this process, we will produce not only one solution,
        but all solutions to the puzzle.

        ..figure > @t(Figure 2.8) A solution to the eight-queens puzzle.

          ..img  > img/chap2/Fig2.8c.std.svg

        We implement this solution as a procedure @c(queens), which returns a
        sequence of all solutions to the problem of placing @m(n) queens on an @m(n
        × n) chessboard. @c(Queens) has an internal procedure @c(queen-cols) that
        returns the sequence of all ways to place queens in the first @m(k) columns
        of the board.

        ..src > scheme
          (define (queens board-size)
            (define (queen-cols k)
              (if (= k 0)
                  (list empty-board)
                  (filter
                   (lambda (positions)
                     (safe? k positions))
                   (flatmap
                    (lambda (rest-of-queens)
                      (map (lambda (new-row)
                             (adjoin-position
                              new-row
                              k
                              rest-of-queens))
                           (enumerate-interval
                            1
                            board-size)))
                    (queen-cols (- k 1))))))
            (queen-cols board-size))
        < src..

        In this procedure @c(rest-of-queens) is a way to place @m(k - 1) queens in
        the first @m(k - 1) columns, and @c(new-row) is a proposed row in which to
        place the queen for the @m(kᵗʰ) column. Complete the program by
        implementing the representation for sets of board positions, including the
        procedure @c(adjoin-position), which adjoins a new row-column position to a
        set of positions, and @c(empty-board), which represents an empty set of
        positions.  You must also write the procedure @c(safe?), which determines
        for a set of positions, whether the queen in the @m(kᵗʰ) column is safe
        with respect to the others. (Note that we need only check whether the new
        queen is safe––the other queens are already guaranteed safe with respect to
        each other.)

     :: @t(Exercise 2.43) :: Louis Reasoner is having a terrible time doing
        @l(#Exercise 2.42). His @c(queens) procedure seems to work, but it runs
        extremely slowly. (Louis never does manage to wait long enough for it to
        solve even the @m(6×6) case.)  When Louis asks Eva Lu Ator for help, she
        points out that he has interchanged the order of the nested mappings in the
        @c(flatmap), writing it as

        ..src > scheme
          (flatmap
           (lambda (new-row)
             (map (lambda (rest-of-queens)
                    (adjoin-position
                     new-row k rest-of-queens))
                  (queen-cols (- k 1))))
           (enumerate-interval 1 board-size))
        < src..

        Explain why this interchange makes the program run slowly. Estimate how
        long it will take Louis's program to solve the eight-queens puzzle,
        assuming that the program in @l(#Exercise 2.42) solves the puzzle in time
        @m(T).

*** 2.2.4 <> Example: A Picture Language

    This section presents a simple language for drawing pictures that illustrates
    the power of data abstraction and closure, and also exploits higher-order
    procedures in an essential way. The language is designed to make it easy to
    experiment with patterns such as the ones in @l(#Figure 2.9), which are
    composed of repeated elements that are shifted and scaled.@n(88) In this
    language, the data objects being combined are represented as procedures rather
    than as list structure. Just as @c(cons), which satisfies the closure
    property, allowed us to easily build arbitrarily complicated list structure,
    the operations in this language, which also satisfy the closure property,
    allow us to easily build arbitrarily complicated patterns.

    ..figure > @t(Figure 2.9) Designs generated with the picture language.

      ..img  > img/chap2/Fig2.9.std.svg

**** The picture language

     When we began our study of programming in @l(#1.1), we emphasized the
     importance of describing a language by focusing on the language's primitives,
     its means of combination, and its means of abstraction. We'll follow that
     framework here.

     Part of the elegance of this picture language is that there is only one kind
     of element, called a @e(painter). A painter draws an image that is shifted and
     scaled to fit within a designated parallelogram-shaped frame. For example,
     there's a primitive painter we'll call @c(wave) that makes a crude line
     drawing, as shown in @l(#Figure 2.10). The actual shape of the drawing depends
     on the frame––all four images in figure 2.10 are produced by the same @c(wave)
     painter, but with respect to four different frames. Painters can be more
     elaborate than this: The primitive painter called @c(rogers) paints a picture
     of @A(MIT)'s founder, William Barton Rogers, as shown in @l(#Figure
     2.11).@n(89) The four images in figure 2.11 are drawn with respect to the same
     four frames as the @c(wave) images in figure 2.10.

     ..figure > @t(Figure 2.10) Images produced by the @c(wave) painter, with
       respect to four different frames. The frames, shown with dotted lines, are
       not part of the images.

       ..img  > img/chap2/Fig2.10.std.svg

     ..figure > @t(Figure 2.11) Images of William Barton Rogers, founder and first
       president of @A(MIT), painted with respect to the same four frames as in
       @l(#Figure 2.10) (original image reprinted with the permission of the
       @A(MIT) Museum).

       ..img  > img/chap2/Fig2.11.std.svg


     To combine images, we use various operations that construct new painters from
     given painters. For example, the @c(beside) operation takes two painters and
     produces a new, compound painter that draws the first painter's image in the
     left half of the frame and the second painter's image in the right half of the
     frame. Similarly, @c(below) takes two painters and produces a compound painter
     that draws the first painter's image below the second painter's image.  Some
     operations transform a single painter to produce a new painter. For example,
     @c(flip-vert) takes a painter and produces a painter that draws its image
     upside-down, and @c(flip-horiz) produces a painter that draws the original
     painter's image left-to-right reversed.

     @l(#Figure 2.12) shows the drawing of a painter called @c(wave4) that is built
     up in two stages starting from @c(wave):

     ..src > scheme
       (define wave2 (beside wave (flip-vert wave)))
       (define wave4 (below wave2 wave2))
     < src..

     ..figure > @t(Figure 2.12) Creating a complex figure, starting from the
       @c(wave) painter of @l(#Figure 2.10).

       ..img  > img/chap2/Fig2.12.std.svg

       ..cols >
         ..src > scheme
           (define wave4
             (below wave2 wave2))
         < src..

         ::

         ..src > scheme
           (define wave4
             (below wave2 wave2))
         < src..


     In building up a complex image in this manner we are exploiting the fact that
     painters are closed under the language's means of combination. The @c(beside)
     or @c(below) of two painters is itself a painter; therefore, we can use it as
     an element in making more complex painters. As with building up list structure
     using @c(cons), the closure of our data under the means of combination is
     crucial to the ability to create complex structures while using only a few
     operations.

     Once we can combine painters, we would like to be able to abstract typical
     patterns of combining painters. We will implement the painter operations as
     Scheme procedures. This means that we don't need a special abstraction
     mechanism in the picture language: Since the means of combination are ordinary
     Scheme procedures, we automatically have the capability to do anything with
     painter operations that we can do with procedures. For example, we can
     abstract the pattern in @c(wave4) as

     ..src > scheme
       (define (flipped-pairs painter)
         (let ((painter2
                (beside painter
                        (flip-vert painter))))
           (below painter2 painter2)))
     < src..

     and define @c(wave4) as an instance of this pattern:

     ..src > scheme
       (define wave4 (flipped-pairs wave))
     < src..

     We can also define recursive operations. Here's one that makes painters split
     and branch towards the right as shown in @l(#Figure 2.13) and @l(#Figure
     2.14):

     ..src > scheme
       (define (right-split painter n)
         (if (= n 0)
             painter
             (let ((smaller (right-split painter
                                         (- n 1))))
               (beside painter
                       (below smaller smaller)))))
     < src..

     ..figure > @t(Figure 2.13) Recursive plans for @c(right-split) and @c(corner-split).

       ..art >
         ╭─────────────┬─────────────╮    ╭──────┬──────┬─────────────╮
         │             │             │    │ up-  │ up-  │             │
         │             │ right-split │    │ split│ split│ corner-split│
         │             │             │    │      │      │             │
         │             │     n-1     │    │  n-1 │  n-1 │     n-1     │
         │             │             │    │      │      │             │
         │  identity   ├─────────────┤    ├──────┴──────┼─────────────┤
         │             │             │    │             │ right-split │
         │             │ right-split │    │             │     n-1     │
         │             │             │    │  identity   ├─────────────┤
         │             │     n-1     │    │             │ right-split │
         │             │             │    │             │     n-1     │
         ╰─────────────┴─────────────╯    ╰─────────────┴─────────────╯

                right-split n                    corner-split n
       < art..

@    ..img > img/chap2/Fig2.13a.std.svg

     We can produce balanced patterns by branching upwards as well as towards the
     right (see @l(#Exercise 2.44), @l(#Figure 2.13) and @l(#Figure 2.14)):

     ..src > scheme
       (define (corner-split painter n)
         (if (= n 0)
             painter
             (let ((up (up-split painter (- n 1)))
                   (right (right-split painter
                                       (- n 1))))
               (let ((top-left (beside up up))
                     (bottom-right (below right
                                          right))
                     (corner (corner-split painter
                                           (- n 1))))
                 (beside (below painter top-left)
                         (below bottom-right
                                corner))))))
     < src..

     ..figure > @t(Figure 2.14) The recursive operations @c(right-split) and
       @c(corner-split) applied to the painters @c(wave) and @c(rogers).
       Combining four @c(corner-split) figures produces symmetric
       @c(square-limit) designs as shown in @l(#Figure 2.9).

       ..img  > img/chap2/Fig2.14b.std.svg


     By placing four copies of a @c(corner-split) appropriately, we obtain a
     pattern called @c(square-limit), whose application to @c(wave) and @c(rogers)
     is shown in @l(#Figure 2.9):

     ..src > scheme
       (define (square-limit painter n)
         (let ((quarter (corner-split painter n)))
           (let ((half (beside (flip-horiz quarter)
                               quarter)))
             (below (flip-vert half) half))))
     < src..

     :: @t(Exercise 2.44) :: Define the procedure @c(up-split) used by
        @c(corner-split). It is similar to @c(right-split), except that it switches
        the roles of @c(below) and @c(beside).

**** Higher-order operations

     In addition to abstracting patterns of combining painters, we can work at a
     higher level, abstracting patterns of combining painter operations. That is,
     we can view the painter operations as elements to manipulate and can write
     means of combination for these elements––procedures that take painter
     operations as arguments and create new painter operations.

     For example, @c(flipped-pairs) and @c(square-limit) each arrange four copies
     of a painter's image in a square pattern; they differ only in how they orient
     the copies. One way to abstract this pattern of painter combination is with
     the following procedure, which takes four one-argument painter operations and
     produces a painter operation that transforms a given painter with those four
     operations and arranges the results in a square. @c(Tl), @c(tr), @c(bl), and
     @c(br) are the transformations to apply to the top left copy, the top right
     copy, the bottom left copy, and the bottom right copy, respectively.

     ..src > scheme
       (define (square-of-four tl tr bl br)
         (lambda (painter)
           (let ((top (beside (tl painter)
                              (tr painter)))
                 (bottom (beside (bl painter)
                                 (br painter))))
             (below bottom top))))
     < src..

     Then @c(flipped-pairs) can be defined in terms of @c(square-of-four) as
     follows:@n(90)

     ..src > scheme
       (define (flipped-pairs painter)
         (let ((combine4
                (square-of-four identity
                                flip-vert
                                identity
                                flip-vert)))
           (combine4 painter)))
     < src..

     and @c(square-limit) can be expressed as@n(91)

     ..src > scheme
       (define (square-limit painter n)
         (let ((combine4
                (square-of-four flip-horiz
                                identity
                                rotate180
                                flip-vert)))
           (combine4 (corner-split painter n))))
     < src..

     :: @t(Exercise 2.45) :: @c(Right-split) and @c(up-split) can be expressed as
        instances of a general splitting operation.  Define a procedure @c(split)
        with the property that evaluating

        ..src > scheme
          (define right-split (split beside below))
          (define up-split (split below beside))
        < src..

        produces procedures @c(right-split) and @c(up-split) with the same
        behaviors as the ones already defined.

**** Frames

     Before we can show how to implement painters and their means of combination,
     we must first consider frames. A frame can be described by three vectors––an
     origin vector and two edge vectors. The origin vector specifies the offset of
     the frame's origin from some absolute origin in the plane, and the edge
     vectors specify the offsets of the frame's corners from its origin. If the
     edges are perpendicular, the frame will be rectangular. Otherwise the frame
     will be a more general parallelogram.

     @l(#Figure 2.15) shows a frame and its associated vectors.  In accordance with
     data abstraction, we need not be specific yet about how frames are
     represented, other than to say that there is a constructor @c(make-frame),
     which takes three vectors and produces a frame, and three corresponding
     selectors @c(origin-frame), @c(edge1-frame), and @c(edge2-frame) (see
     @l(#Exercise 2.47)).

     ..figure > @t(Figure 2.15) A frame is described by three vectors -- an origin
       and two edges.

       ..art >
                                  __
                              __--  \
                          __--       \
                      __--            \
                  __--                 \
                _-                      \
                ◤                   __-◥
         frame   \              __--
         edge2    \         __--    frame
         vector    \    __--        edge1
                    \_--            vector
                     - ◀╮
                        ╰───╮
                  frame     │
                  origin    ╰ (0, 0) point
                  vector      on display screen
       < art..

@      ..img > img/chap2/Fig2.15a.std.svg

     We will use coordinates in the unit square @m[(0 ≤ x, y ≤ 1)] to specify
     images. With each frame, we associate a @e(frame coordinate map), which will
     be used to shift and scale images to fit the frame. The map transforms the
     unit square into the frame by mapping the vector @m(v = (x, y)] to the vector
     sum

     ..example >
       Origin(Frame) + x ⋅ Edge₁(Frame) + y ⋅ Edge₂(Frame)
     < example..

     For example, (0, 0) is mapped to the origin of the frame, (1, 1) to the vertex
     diagonally opposite the origin, and (0.5, 0.5) to the center of the frame. We
     can create a frame's coordinate map with the following procedure:@n(92)

     ..src > scheme
       (define (frame-coord-map frame)
         (lambda (v)
           (add-vect
            (origin-frame frame)
            (add-vect
             (scale-vect (xcor-vect v)
                         (edge1-frame frame))
             (scale-vect (ycor-vect v)
                         (edge2-frame frame))))))
     < src..

     Observe that applying @c(frame-coord-map) to a frame returns a procedure that,
     given a vector, returns a vector. If the argument vector is in the unit
     square, the result vector will be in the frame. For example,

     ..src > scheme
       ((frame-coord-map a-frame) (make-vect 0 0))
     < src..

     returns the same vector as

     ..src > scheme
       (origin-frame a-frame)
     < src..

     :: @t(Exercise 2.46) :: A two-dimensional vector @m(v) running from the origin
        to a point can be represented as a pair consisting of an @m(x)-coordinate
        and a @m(y)-coordinate. Implement a data abstraction for vectors by giving
        a constructor @c(make-vect) and corresponding selectors @c(xcor-vect) and
        @c(ycor-vect). In terms of your selectors and constructor, implement
        procedures @c(add-vect), @c(sub-vect), and @c(scale-vect) that perform the
        operations vector addition, vector subtraction, and multiplying a vector by
        a scalar:

        ..example >
          (x₁, y₁) + (x₂, y₂) = (x₁ + x₂, y₁ + y₂)
          (x₁, y₁) − (x₂, y₂) = (x₁ − x₂, y₁ − y₂)
                   s ⋅ (x, y) = (sx, sy)
        < example..

     :: @t(Exercise 2.47) :: Here are two possible constructors for frames:

        ..src > scheme
          (define (make-frame origin edge1 edge2)
            (list origin edge1 edge2))

          (define (make-frame origin edge1 edge2)
            (cons origin (cons edge1 edge2)))
        < src..

        For each constructor supply the appropriate selectors to produce an
        implementation for frames.

**** Painters

     A painter is represented as a procedure that, given a frame as argument, draws
     a particular image shifted and scaled to fit the frame. That is to say, if
     @c(p) is a painter and @c(f) is a frame, then we produce @c(p)'s image in
     @c(f) by calling @c(p) with @c(f) as argument.

     The details of how primitive painters are implemented depend on the particular
     characteristics of the graphics system and the type of image to be drawn. For
     instance, suppose we have a procedure @c(draw-line) that draws a line on the
     screen between two specified points. Then we can create painters for line
     drawings, such as the @c(wave) painter in @l(#Figure 2.10), from lists of line
     segments as follows:@n(93)

     ..src > scheme
       (define (segments->painter segment-list)
         (lambda (frame)
           (for-each
            (lambda (segment)
              (draw-line
               ((frame-coord-map frame)
                (start-segment segment))
               ((frame-coord-map frame)
                (end-segment segment))))
            segment-list)))
     < src..

     The segments are given using coordinates with respect to the unit square. For
     each segment in the list, the painter transforms the segment endpoints with
     the frame coordinate map and draws a line between the transformed points.

     Representing painters as procedures erects a powerful abstraction barrier in
     the picture language. We can create and intermix all sorts of primitive
     painters, based on a variety of graphics capabilities. The details of their
     implementation do not matter. Any procedure can serve as a painter, provided
     that it takes a frame as argument and draws something scaled to fit the
     frame.@n(94)

     :: @t(Exercise 2.48) :: A directed line segment in the plane can be
        represented as a pair of vectors––the vector running from the origin to the
        start-point of the segment, and the vector running from the origin to the
        end-point of the segment. Use your vector representation from @l(#Exercise
        2.46) to define a representation for segments with a constructor
        @c(make-segment) and selectors @c(start-segment) and @c(end-segment).

     :: @t(Exercise 2.49) :: Use @c(segments->painter) to define the following
        primitive painters:

        1. The painter that draws the outline of the designated frame.

        2. The painter that draws an @"(X) by connecting opposite corners of the
           frame.

        3. The painter that draws a diamond shape by connecting the midpoints of
           the sides of the frame.

        4. The @c(wave) painter.

**** Transforming and combining painters

     An operation on painters (such as @c(flip-vert) or @c(beside)) works by
     creating a painter that invokes the original painters with respect to frames
     derived from the argument frame. Thus, for example, @c(flip-vert) doesn't have
     to know how a painter works in order to flip it––it just has to know how to
     turn a frame upside down: The flipped painter just uses the original painter,
     but in the inverted frame.

     Painter operations are based on the procedure @c(transform-painter), which
     takes as arguments a painter and information on how to transform a frame and
     produces a new painter. The transformed painter, when called on a frame,
     transforms the frame and calls the original painter on the transformed frame.
     The arguments to @c(transform-painter) are points (represented as vectors)
     that specify the corners of the new frame: When mapped into the frame, the
     first point specifies the new frame's origin and the other two specify the
     ends of its edge vectors. Thus, arguments within the unit square specify a
     frame contained within the original frame.

     ..src > scheme
       (define (transform-painter
                painter origin corner1 corner2)
         (lambda (frame)
           (let ((m (frame-coord-map frame)))
             (let ((new-origin (m origin)))
               (painter (make-frame new-origin
                         (sub-vect (m corner1)
                                   new-origin)
                         (sub-vect (m corner2)
                                   new-origin)))))))
     < src..

     Here's how to flip painter images vertically:

     ..src > scheme
       (define (flip-vert painter)
         (transform-painter
          painter
          (make-vect 0.0 1.0)   ; new origin
          (make-vect 1.0 1.0)   ; new end of edge1
          (make-vect 0.0 0.0))) ; new end of edge2
     < src..

     Using @c(transform-painter), we can easily define new transformations.  For
     example, we can define a painter that shrinks its image to the upper-right
     quarter of the frame it is given:

     ..src > scheme
       (define (shrink-to-upper-right painter)
         (transform-painter painter
                            (make-vect 0.5 0.5)
                            (make-vect 1.0 0.5)
                            (make-vect 0.5 1.0)))
     < src..

     Other transformations rotate images counterclockwise by 90 degrees@n(95)

     ..src > scheme
       (define (rotate90 painter)
         (transform-painter painter
                            (make-vect 1.0 0.0)
                            (make-vect 1.0 1.0)
                            (make-vect 0.0 0.0)))
     < src..

     or squash images towards the center of the frame:@n(96)

     ..src > scheme
       (define (squash-inwards painter)
         (transform-painter painter
                            (make-vect 0.0 0.0)
                            (make-vect 0.65 0.35)
                            (make-vect 0.35 0.65)))
     < src..

     Frame transformation is also the key to defining means of combining two or
     more painters. The @c(beside) procedure, for example, takes two painters,
     transforms them to paint in the left and right halves of an argument frame
     respectively, and produces a new, compound painter. When the compound painter
     is given a frame, it calls the first transformed painter to paint in the left
     half of the frame and calls the second transformed painter to paint in the
     right half of the frame:

     ..src > scheme
       (define (beside painter1 painter2)
         (let ((split-point (make-vect 0.5 0.0)))
           (let ((paint-left  (transform-painter
                               painter1
                               (make-vect 0.0 0.0)
                               split-point
                               (make-vect 0.0 1.0)))
                 (paint-right (transform-painter
                               painter2
                               split-point
                               (make-vect 1.0 0.0)
                               (make-vect 0.5 1.0))))
             (lambda (frame)
               (paint-left frame)
               (paint-right frame)))))
     < src..

     Observe how the painter data abstraction, and in particular the representation
     of painters as procedures, makes @c(beside) easy to implement. The @c(beside)
     procedure need not know anything about the details of the component painters
     other than that each painter will draw something in its designated frame.

     :: @t(Exercise 2.50) :: Define the transformation @c(flip-horiz), which flips
        painters horizontally, and transformations that rotate painters
        counterclockwise by 180 degrees and 270 degrees.

     :: @t(Exercise 2.51) :: Define the @c(below) operation for painters. @c(Below)
        takes two painters as arguments. The resulting painter, given a frame,
        draws with the first painter in the bottom of the frame and with the second
        painter in the top. Define @c(below) in two different ways––first by
        writing a procedure that is analogous to the @c(beside) procedure given
        above, and again in terms of @c(beside) and suitable rotation operations
        (from @l(#Exercise 2.50)).

**** Levels of language for robust design

     The picture language exercises some of the critical ideas we've introduced
     about abstraction with procedures and data. The fundamental data abstractions,
     painters, are implemented using procedural representations, which enables the
     language to handle different basic drawing capabilities in a uniform way. The
     means of combination satisfy the closure property, which permits us to easily
     build up complex designs. Finally, all the tools for abstracting procedures
     are available to us for abstracting means of combination for painters.

     We have also obtained a glimpse of another crucial idea about languages and
     program design. This is the approach of @e(stratified design), the notion that
     a complex system should be structured as a sequence of levels that are
     described using a sequence of languages. Each level is constructed by
     combining parts that are regarded as primitive at that level, and the parts
     constructed at each level are used as primitives at the next level. The
     language used at each level of a stratified design has primitives, means of
     combination, and means of abstraction appropriate to that level of detail.

     Stratified design pervades the engineering of complex systems. For example, in
     computer engineering, resistors and transistors are combined (and described
     using a language of analog circuits) to produce parts such as and-gates and
     or-gates, which form the primitives of a language for digital-circuit
     design.@n(97) These parts are combined to build processors, bus structures,
     and memory systems, which are in turn combined to form computers, using
     languages appropriate to computer architecture. Computers are combined to form
     distributed systems, using languages appropriate for describing network
     interconnections, and so on.

     As a tiny example of stratification, our picture language uses primitive
     elements (primitive painters) that are created using a language that specifies
     points and lines to provide the lists of line segments for
     @c(segments->painter), or the shading details for a painter like
     @c(rogers). The bulk of our description of the picture language focused on
     combining these primitives, using geometric combiners such as @c(beside) and
     @c(below). We also worked at a higher level, regarding @c(beside) and
     @c(below) as primitives to be manipulated in a language whose operations, such
     as @c(square-of-four), capture common patterns of combining geometric
     combiners.

     Stratified design helps make programs @e(robust), that is, it makes it likely
     that small changes in a specification will require correspondingly small
     changes in the program. For instance, suppose we wanted to change the image
     based on @c(wave) shown in @l(#Figure 2.9). We could work at the lowest level
     to change the detailed appearance of the @c(wave) element; we could work at
     the middle level to change the way @c(corner-split) replicates the @c(wave);
     we could work at the highest level to change how @c(square-limit) arranges the
     four copies of the corner. In general, each level of a stratified design
     provides a different vocabulary for expressing the characteristics of the
     system, and a different kind of ability to change it.

     :: @t(Exercise 2.52) :: Make changes to the square limit of @c(wave) shown in
        @l(#Figure 2.9) by working at each of the levels described above. In
        particular:

        1. Add some segments to the primitive @c(wave) painter of @l(#Exercise
           2.49) (to add a smile, for example).

        2. Change the pattern constructed by @c(corner-split) (for example, by
           using only one copy of the @c(up-split) and @c(right-split) images
           instead of two).

        3. Modify the version of @c(square-limit) that uses @c(square-of-four) so
           as to assemble the corners in a different pattern. (For example, you
           might make the big Mr. Rogers look outward from each corner of the
           square.)

** 2.3 <> Symbolic Data

   All the compound data objects we have used so far were constructed ultimately
   from numbers. In this section we extend the representational capability of our
   language by introducing the ability to work with arbitrary symbols as data.

*** 2.3.1 <> Quotation

    If we can form compound data using symbols, we can have lists such as

    ..src > scheme
      (a b c d)
      (23 45 17)
      ((Norah 12)
       (Molly 9)
       (Anna 7)
       (Lauren 6)
       (Charlotte 4))
    < src..

    Lists containing symbols can look just like the expressions of our language:

    ..src > scheme
      (* (+ 23 45) (+ x 9))
      (define (fact n)
        (if (= n 1)
            1
            (* n (fact (- n 1)))))
    < src..

    In order to manipulate symbols we need a new element in our language: the
    ability to @e(quote) a data object. Suppose we want to construct the list
    @c[(a b)]. We can't accomplish this with @c[(list a b)], because this
    expression constructs a list of the @e(values) of @c(a) and @c(b) rather than
    the symbols themselves. This issue is well known in the context of natural
    languages, where words and sentences may be regarded either as semantic
    entities or as character strings (syntactic entities). The common practice in
    natural languages is to use quotation marks to indicate that a word or a
    sentence is to be treated literally as a string of characters. For instance,
    the first letter of @"(John) is clearly @"(J.)  If we tell somebody @"(say
    your name aloud,) we expect to hear that person's name. However, if we tell
    somebody @"(say `your name' aloud,) we expect to hear the words @"(your name.)
    Note that we are forced to nest quotation marks to describe what somebody else
    might say.@n(98)

    We can follow this same practice to identify lists and symbols that are to be
    treated as data objects rather than as expressions to be evaluated. However,
    our format for quoting differs from that of natural languages in that we place
    a quotation mark (traditionally, the single quote symbol @c(')) only at the
    beginning of the object to be quoted. We can get away with this in Scheme
    syntax because we rely on blanks and parentheses to delimit objects. Thus, the
    meaning of the single quote character is to quote the next object.@n(99)

    Now we can distinguish between symbols and their values:

    ..srci > scheme
      > (define a 1)
      > (define b 2)
      > (list a b)
      (1 2)
      > (list 'a 'b)
      (a b)
      > (list 'a b)
      (a 2)
    < srci..

    Quotation also allows us to type in compound objects, using the conventional
    printed representation for lists:@n(100)

    ..srci > scheme
      > (car '(a b c))
      a
      > (cdr '(a b c))
      (b c)
    < srci..

    In keeping with this, we can obtain the empty list by evaluating @c['()], and
    thus dispense with the variable @c(nil).

    One additional primitive used in manipulating symbols is @c(eq?), which takes
    two symbols as arguments and tests whether they are the same.@n(101) Using
    @c(eq?), we can implement a useful procedure called @c(memq). This takes two
    arguments, a symbol and a list. If the symbol is not contained in the list
    (i.e., is not @c(eq?) to any item in the list), then @c(memq) returns
    false. Otherwise, it returns the sublist of the list beginning with the first
    occurrence of the symbol:

    ..src > scheme
      (define (memq item x)
        (cond ((null? x) false)
              ((eq? item (car x)) x)
              (else (memq item (cdr x)))))
    < src..

    For example, the value of

    ..src > scheme
      (memq 'apple '(pear banana prune))
    < src..

    is false, whereas the value of

    ..src > scheme
      (memq 'apple '(x (apple sauce) y apple pear))
    < src..

    is @c[(apple pear)].

    :: @t(Exercise 2.53) :: What would the interpreter print in response to
       evaluating each of the following expressions?

       ..src > scheme
         (list 'a 'b 'c)
         (list (list 'george))
         (cdr '((x1 x2) (y1 y2)))
         (cadr '((x1 x2) (y1 y2)))
         (pair? (car '(a short list)))
         (memq 'red '((red shoes) (blue socks)))
         (memq 'red '(red shoes blue socks))
       < src..

    :: @t(Exercise 2.54) :: Two lists are said to be @c(equal?) if they contain
       equal elements arranged in the same order. For example,

       ..src > scheme
         (equal? '(this is a list)
                 '(this is a list))
       < src..

       is true, but

       ..src > scheme
         (equal? '(this is a list)
                 '(this (is a) list))
       < src..

       is false. To be more precise, we can define @c(equal?)  recursively in
       terms of the basic @c(eq?) equality of symbols by saying that @c(a) and
       @c(b) are @c(equal?) if they are both symbols and the symbols are @c(eq?),
       or if they are both lists such that @c[(car a)] is @c(equal?)  to @c[(car
       b)] and @c[(cdr a)] is @c(equal?) to @c[(cdr b)]. Using this idea,
       implement @c(equal?) as a procedure.@n(102)

    :: @t(Exercise 2.55) :: Eva Lu Ator types to the interpreter the expression

       ..src > scheme
         (car ''abracadabra)
       < src..

       To her surprise, the interpreter prints back @c(quote). Explain.

*** 2.3.2 <> Example: Symbolic Differentiation

    As an illustration of symbol manipulation and a further illustration of data
    abstraction, consider the design of a procedure that performs symbolic
    differentiation of algebraic expressions. We would like the procedure to take
    as arguments an algebraic expression and a variable and to return the
    derivative of the expression with respect to the variable. For example, if the
    arguments to the procedure are @m(ax² + bx + c) and @m(x), the procedure
    should return @m(2ax + b). Symbolic differentiation is of special historical
    significance in Lisp. It was one of the motivating examples behind the
    development of a computer language for symbol manipulation.  Furthermore, it
    marked the beginning of the line of research that led to the development of
    powerful systems for symbolic mathematical work, which are currently being
    used by a growing number of applied mathematicians and physicists.

    In developing the symbolic-differentiation program, we will follow the same
    strategy of data abstraction that we followed in developing the
    rational-number system of @l(#2.1.1). That is, we will first define a
    differentiation algorithm that operates on abstract objects such as @"(sums,)
    @"(products,) and @"(variables) without worrying about how these are to be
    represented. Only afterward will we address the representation problem.

**** The differentiation program with abstract data

     In order to keep things simple, we will consider a very simple
     symbolic-differentiation program that handles expressions that are built up
     using only the operations of addition and multiplication with two arguments.
     Differentiation of any such expression can be carried out by applying the
     following reduction rules:

     ..example >
       dc
       -- = 0  for c a constant, or a variable different from x
       dx

             dx
             -- = 1
             dx

       d(u + v)   du   dv
       -------- = -- + --
          dx      dx   dx

          d(uv)    dv    du
          ----- = u-- + v--
           dx      dx    dx
     < example..

     Observe that the latter two rules are recursive in nature. That is, to obtain
     the derivative of a sum we first find the derivatives of the terms and add
     them. Each of the terms may in turn be an expression that needs to be
     decomposed. Decomposing into smaller and smaller pieces will eventually
     produce pieces that are either constants or variables, whose derivatives will
     be either 0 or 1.

     To embody these rules in a procedure we indulge in a little wishful thinking,
     as we did in designing the rational-number implementation. If we had a means
     for representing algebraic expressions, we should be able to tell whether an
     expression is a sum, a product, a constant, or a variable. We should be able
     to extract the parts of an expression. For a sum, for example we want to be
     able to extract the addend (first term) and the augend (second term). We
     should also be able to construct expressions from parts. Let us assume that we
     already have procedures to implement the following selectors, constructors,
     and predicates:

     | @c[(variable? e)]          | Is @c(e) a variable?                        |
     |----------------------------|---------------------------------------------|
     | @c[(same-variable? v1 v2)] | Are @c(v1) and @c(v2) the same variable?    |
     |----------------------------|---------------------------------------------|
     | @c[(sum? e)]               | Is @c(e) a sum?                             |
     |----------------------------|---------------------------------------------|
     | @c[(addend e)]             | Addend of the sum @c(e).                    |
     |----------------------------|---------------------------------------------|
     | @c[(augend e)]             | Augend of the sum @c(e).                    |
     |----------------------------|---------------------------------------------|
     | @c[(make-sum a1 a2)]       | Construct the sum of @c(a1) and @c(a2).     |
     |----------------------------|---------------------------------------------|
     | @c[(product? e)]           | Is @c(e) a product?                         |
     |----------------------------|---------------------------------------------|
     | @c[(multiplier e)]         | Multiplier of the product @c(e).            |
     |----------------------------|---------------------------------------------|
     | @c[(multiplicand e)]       | Multiplicand of the product @c(e).          |
     |----------------------------|---------------------------------------------|
     | @c[(make-product m1 m2)]   | Construct the product of @c(m1) and @c(m2). |


     Using these, and the primitive predicate @c(number?), which identifies
     numbers, we can express the differentiation rules as the following procedure:

     ..src > scheme
       (define (deriv exp var)
         (cond ((number? exp) 0)
               ((variable? exp)
                (if (same-variable? exp var) 1 0))
               ((sum? exp)
                (make-sum (deriv (addend exp) var)
                          (deriv (augend exp) var)))
               ((product? exp)
                (make-sum
                 (make-product
                  (multiplier exp)
                  (deriv (multiplicand exp) var))
                 (make-product
                  (deriv (multiplier exp) var)
                  (multiplicand exp))))
               (else (error "unknown expression
                             type: DERIV" exp))))
     < src..

     This @c(deriv) procedure incorporates the complete differentiation
     algorithm. Since it is expressed in terms of abstract data, it will work no
     matter how we choose to represent algebraic expressions, as long as we design
     a proper set of selectors and constructors. This is the issue we must address
     next.

**** Representing algebraic expressions

     We can imagine many ways to use list structure to represent algebraic
     expressions. For example, we could use lists of symbols that mirror the usual
     algebraic notation, representing @m(ax + b) as the list @c[(a * x + b)].
     However, one especially straightforward choice is to use the same
     parenthesized prefix notation that Lisp uses for combinations; that is, to
     represent @m(ax + b) as @c[(+ (* a x) b)]. Then our data representation for
     the differentiation problem is as follows:

     - The variables are symbols. They are identified by the primitive predicate
       @c(symbol?):

       ..src > scheme
         (define (variable? x) (symbol? x))
       < src..

     - Two variables are the same if the symbols representing them are @c(eq?):

       ..src > scheme
         (define (same-variable? v1 v2)
           (and (variable? v1)
                (variable? v2)
                (eq? v1 v2)))
       < src..

     - Sums and products are constructed as lists:

       ..src > scheme
         (define (make-sum a1 a2) (list '+ a1 a2))
         (define (make-product m1 m2) (list '* m1 m2))
       < src..

     - A sum is a list whose first element is the symbol @c(+):

       ..src > scheme
         (define (sum? x)
           (and (pair? x) (eq? (car x) '+)))
       < src..

     - The addend is the second item of the sum list:

       ..src > scheme
         (define (addend s) (cadr s))
       < src..

     - The augend is the third item of the sum list:

       ..src > scheme
         (define (augend s) (caddr s))
       < src..

     - A product is a list whose first element is the symbol @c(*):

       ..src > scheme
         (define (product? x)
           (and (pair? x) (eq? (car x) '*)))
       < src..

     - The multiplier is the second item of the product list:

       ..src > scheme
         (define (multiplier p) (cadr p))
       < src..

     - The multiplicand is the third item of the product list:

       ..src > scheme
         (define (multiplicand p) (caddr p))
       < src..


     Thus, we need only combine these with the algorithm as embodied by @c(deriv)
     in order to have a working symbolic-differentiation program. Let us look at
     some examples of its behavior:

     ..srci > scheme
       > (deriv '(+ x 3) 'x)
       (+ 1 0)
       > (deriv '(* x y) 'x)
       (+ (* x 0) (* 1 y))
       > (deriv '(* (* x y) (+ x 3)) 'x)
       (+ (* (* x y) (+ 1 0))
          (* (+ (* x 0) (* 1 y))
             (+  x 3)))
     < srci..

     The program produces answers that are correct; however, they are unsimplified.
     It is true that

     ..example >
       d(xy)
       ----- = x ⋅ 0 + 1 ⋅ y
        dx
     < example..

     but we would like the program to know that @m(x ⋅ 0 = 0), @m(1 ⋅ y = y), and
     @m(0 + y = y). The answer for the second example should have been simply
     @c(y). As the third example shows, this becomes a serious issue when the
     expressions are complex.

     Our difficulty is much like the one we encountered with the rational-number
     implementation: we haven't reduced answers to simplest form. To accomplish the
     rational-number reduction, we needed to change only the constructors and the
     selectors of the implementation. We can adopt a similar strategy here. We
     won't change @c(deriv) at all. Instead, we will change @c(make-sum) so that if
     both summands are numbers, @c(make-sum) will add them and return their
     sum. Also, if one of the summands is 0, then @c(make-sum) will return the
     other summand:

     ..src > scheme
       (define (make-sum a1 a2)
         (cond ((=number? a1 0) a2)
               ((=number? a2 0) a1)
               ((and (number? a1) (number? a2))
                (+ a1 a2))
               (else (list '+ a1 a2))))
     < src..

     This uses the procedure @c(=number?), which checks whether an expression is
     equal to a given number:

     ..src > scheme
       (define (=number? exp num)
         (and (number? exp) (= exp num)))
     < src..

     Similarly, we will change @c(make-product) to build in the rules that 0 times
     anything is 0 and 1 times anything is the thing itself:

     ..src > scheme
       (define (make-product m1 m2)
         (cond ((or (=number? m1 0)
                    (=number? m2 0))
                0)
               ((=number? m1 1) m2)
               ((=number? m2 1) m1)
               ((and (number? m1) (number? m2))
                (* m1 m2))
               (else (list '* m1 m2))))
     < src..

     Here is how this version works on our three examples:

     ..srci > scheme
       > (deriv '(+ x 3) 'x)
       1
       > (deriv '(* x y) 'x)
       y
       > (deriv '(* (* x y) (+ x 3)) 'x)
       (+ (* x y) (* y (+ x 3)))
     < srci..

     Although this is quite an improvement, the third example shows that there is
     still a long way to go before we get a program that puts expressions into a
     form that we might agree is @"(simplest.)  The problem of algebraic
     simplification is complex because, among other reasons, a form that may be
     simplest for one purpose may not be for another.

     :: @t(Exercise 2.56) :: Show how to extend the basic differentiator to handle
        more kinds of expressions. For instance, implement the differentiation rule

        ..example >
          d(uⁿ)           du
          ----- = nu⁽ⁿ⁻¹⁾ --
            dx            dx
        < example..

        by adding a new clause to the @c(deriv) program and defining appropriate
        procedures @c(exponentiation?), @c(base), @c(exponent), and
        @c(make-exponentiation). (You may use the symbol @c(**) to denote
        exponentiation.)  Build in the rules that anything raised to the power 0 is
        1 and anything raised to the power 1 is the thing itself.

     :: @t(Exercise 2.57) :: Extend the differentiation program to handle sums and
        products of arbitrary numbers of (two or more) terms. Then the last example
        above could be expressed as

        ..src > scheme
          (deriv '(* x y (+ x 3)) 'x)
        < src..

        Try to do this by changing only the representation for sums and products,
        without changing the @c(deriv) procedure at all. For example, the
        @c(addend) of a sum would be the first term, and the @c(augend) would be
        the sum of the rest of the terms.

     :: @t(Exercise 2.58) :: Suppose we want to modify the differentiation program
        so that it works with ordinary mathematical notation, in which @c(+) and
        @c(*) are infix rather than prefix operators. Since the differentiation
        program is defined in terms of abstract data, we can modify it to work with
        different representations of expressions solely by changing the predicates,
        selectors, and constructors that define the representation of the algebraic
        expressions on which the differentiator is to operate.

        - Show how to do this in order to differentiate algebraic expressions
          presented in infix form, such as @c[(x + (3 * (x + (y + 2))))]. To
          simplify the task, assume that @c(+) and @c(*) always take two arguments
          and that expressions are fully parenthesized.

        - The problem becomes substantially harder if we allow standard algebraic
          notation, such as @c[(x + 3 * (x + y + 2))], which drops unnecessary
          parentheses and assumes that multiplication is done before addition. Can
          you design appropriate predicates, selectors, and constructors for this
          notation such that our derivative program still works?

*** 2.3.3 <> Example: Representing Sets

    In the previous examples we built representations for two kinds of compound
    data objects: rational numbers and algebraic expressions. In one of these
    examples we had the choice of simplifying (reducing) the expressions at either
    construction time or selection time, but other than that the choice of a
    representation for these structures in terms of lists was
    straightforward. When we turn to the representation of sets, the choice of a
    representation is not so obvious. Indeed, there are a number of possible
    representations, and they differ significantly from one another in several
    ways.

    Informally, a set is simply a collection of distinct objects. To give a more
    precise definition we can employ the method of data abstraction. That is, we
    define @"(set) by specifying the operations that are to be used on sets. These
    are @c(union-set), @c(intersection-set), @c(element-of-set?), and
    @c(adjoin-set). @c(Element-of-set?) is a predicate that determines whether a
    given element is a member of a set. @c(Adjoin-set) takes an object and a set
    as arguments and returns a set that contains the elements of the original set
    and also the adjoined element. @c(Union-set) computes the union of two sets,
    which is the set containing each element that appears in either
    argument. @c(Intersection-set) computes the intersection of two sets, which is
    the set containing only elements that appear in both arguments.  From the
    viewpoint of data abstraction, we are free to design any representation that
    implements these operations in a way consistent with the interpretations given
    above.@n(103)

**** Sets as unordered lists

     One way to represent a set is as a list of its elements in which no element
     appears more than once. The empty set is represented by the empty list. In
     this representation, @c(element-of-set?) is similar to the procedure @c(memq)
     of @l(#2.3.1). It uses @c(equal?)  instead of @c(eq?) so that the set elements
     need not be symbols:

     ..src > scheme
       (define (element-of-set? x set)
         (cond ((null? set) false)
               ((equal? x (car set)) true)
               (else (element-of-set? x (cdr set)))))
     < src..

     Using this, we can write @c(adjoin-set). If the object to be adjoined is
     already in the set, we just return the set. Otherwise, we use @c(cons) to add
     the object to the list that represents the set:

     ..src > scheme
       (define (adjoin-set x set)
         (if (element-of-set? x set)
             set
             (cons x set)))
     < src..

     For @c(intersection-set) we can use a recursive strategy. If we know how to
     form the intersection of @c(set2) and the @c(cdr) of @c(set1), we only need to
     decide whether to include the @c(car) of @c(set1) in this. But this depends on
     whether @c[(car set1)] is also in @c(set2). Here is the resulting procedure:

     ..src > scheme
       (define (intersection-set set1 set2)
         (cond ((or (null? set1) (null? set2))
                '())
               ((element-of-set? (car set1) set2)
                (cons (car set1)
                      (intersection-set (cdr set1)
                                        set2)))
               (else (intersection-set (cdr set1)
                                       set2))))
     < src..

     In designing a representation, one of the issues we should be concerned with
     is efficiency. Consider the number of steps required by our set operations.
     Since they all use @c(element-of-set?), the speed of this operation has a
     major impact on the efficiency of the set implementation as a whole. Now, in
     order to check whether an object is a member of a set, @c(element-of-set?)
     may have to scan the entire set. (In the worst case, the object turns out not
     to be in the set.)  Hence, if the set has @m(n) elements, @c(element-of-set?)
     might take up to @m(n) steps. Thus, the number of steps required grows as
     @m[Θ(n)]. The number of steps required by @c(adjoin-set), which uses this
     operation, also grows as @m[Θ(n)].  For @c(intersection-set), which does an
     @c(element-of-set?) check for each element of @c(set1), the number of steps
     required grows as the product of the sizes of the sets involved, or @m[Θ(n²)]
     for two sets of size @m(n). The same will be true of @c(union-set).

     :: @t(Exercise 2.59) :: Implement the @c(union-set) operation for the
        unordered-list representation of sets.

     :: @t(Exercise 2.60) :: We specified that a set would be represented as a list
        with no duplicates. Now suppose we allow duplicates.  For instance, the set
        @m({1, 2, 3}) could be represented as the list @c[(2 3 2 1 3 2 2)]. Design
        procedures @c(element-of-set?), @c(adjoin-set), @c(union-set), and
        @c(intersection-set) that operate on this representation. How does the
        efficiency of each compare with the corresponding procedure for the
        non-duplicate representation?  Are there applications for which you would
        use this representation in preference to the non-duplicate one?

**** Sets as ordered lists

     One way to speed up our set operations is to change the representation so that
     the set elements are listed in increasing order. To do this, we need some way
     to compare two objects so that we can say which is bigger. For example, we
     could compare symbols lexicographically, or we could agree on some method for
     assigning a unique number to an object and then compare the elements by
     comparing the corresponding numbers. To keep our discussion simple, we will
     consider only the case where the set elements are numbers, so that we can
     compare elements using @c(>) and @c(<). We will represent a set of numbers by
     listing its elements in increasing order. Whereas our first representation
     above allowed us to represent the set @m({1, 3, 6, 10}) by listing the
     elements in any order, our new representation allows only the list @c[(1 3 6
     10)].

     One advantage of ordering shows up in @c(element-of-set?): In checking for the
     presence of an item, we no longer have to scan the entire set. If we reach a
     set element that is larger than the item we are looking for, then we know that
     the item is not in the set:

     ..src > scheme
       (define (element-of-set? x set)
         (cond ((null? set) false)
               ((= x (car set)) true)
               ((< x (car set)) false)
               (else (element-of-set? x (cdr set)))))
     < src..

     How many steps does this save?  In the worst case, the item we are looking for
     may be the largest one in the set, so the number of steps is the same as for
     the unordered representation. On the other hand, if we search for items of
     many different sizes we can expect that sometimes we will be able to stop
     searching at a point near the beginning of the list and that other times we
     will still need to examine most of the list. On the average we should expect
     to have to examine about half of the items in the set. Thus, the average
     number of steps required will be about @m(n / 2). This is still @m[Θ(n)]
     growth, but it does save us, on the average, a factor of 2 in number of steps
     over the previous implementation.

     We obtain a more impressive speedup with @c(intersection-set). In the
     unordered representation this operation required @m[Θ(n²)] steps, because we
     performed a complete scan of @c(set2) for each element of @c(set1). But with
     the ordered representation, we can use a more clever method. Begin by
     comparing the initial elements, @c(x1) and @c(x2), of the two sets. If @c(x1)
     equals @c(x2), then that gives an element of the intersection, and the rest of
     the intersection is the intersection of the @c(cdr)-s of the two
     sets. Suppose, however, that @c(x1) is less than @c(x2). Since @c(x2) is the
     smallest element in @c(set2), we can immediately conclude that @c(x1) cannot
     appear anywhere in @c(set2) and hence is not in the intersection. Hence, the
     intersection is equal to the intersection of @c(set2) with the @c(cdr) of
     @c(set1). Similarly, if @c(x2) is less than @c(x1), then the intersection is
     given by the intersection of @c(set1) with the @c(cdr) of @c(set2). Here is
     the procedure:

     ..src > scheme
       (define (intersection-set set1 set2)
         (if (or (null? set1) (null? set2))
             '()
             (let ((x1 (car set1)) (x2 (car set2)))
               (cond ((= x1 x2)
                      (cons x1 (intersection-set
                                (cdr set1)
                                (cdr set2))))
                     ((< x1 x2) (intersection-set
                                 (cdr set1)
                                 set2))
                     ((< x2 x1) (intersection-set
                                 set1
                                 (cdr set2)))))))
     < src..

     To estimate the number of steps required by this process, observe that at each
     step we reduce the intersection problem to computing intersections of smaller
     sets––removing the first element from @c(set1) or @c(set2) or both.  Thus, the
     number of steps required is at most the sum of the sizes of @c(set1) and
     @c(set2), rather than the product of the sizes as with the unordered
     representation. This is @m[Θ(n)] growth rather than @m[Θ(n²)]––a considerable
     speedup, even for sets of moderate size.

     :: @t(Exercise 2.61) :: Give an implementation of @c(adjoin-set) using the
        ordered representation. By analogy with @c(element-of-set?) show how to
        take advantage of the ordering to produce a procedure that requires on the
        average about half as many steps as with the unordered representation.

     :: @t(Exercise 2.62) :: Give a @m[Θ(n)] implementation of @c(union-set) for
        sets represented as ordered lists.

**** Sets as binary trees

     We can do better than the ordered-list representation by arranging the set
     elements in the form of a tree. Each node of the tree holds one element of the
     set, called the @"(entry) at that node, and a link to each of two other
     (possibly empty) nodes. The @"(left) link points to elements smaller than the
     one at the node, and the @"(right) link to elements greater than the one at
     the node. @l(#Figure 2.16) shows some trees that represent the set @m({1, 3,
     5, 7, 9, 11}). The same set may be represented by a tree in a number of
     different ways. The only thing we require for a valid representation is that
     all elements in the left subtree be smaller than the node entry and that all
     elements in the right subtree be larger.

     ..figure > @t(Figure 2.16) Various binary trees that represent the set
       @m({1, 3, 5, 7, 9, 11}).

       ..art >
            7          3             5
            /\         /\            /\
           3  9       1  7          3  9
          /\   \         /\        /   /\
         1  5  11       5  9      1   7  11
                            \
                            11
       < art..

@    ..img > img/chap2/Fig2.16c.std.svg

     The advantage of the tree representation is this: Suppose we want to check
     whether a number @m(x) is contained in a set. We begin by comparing @m(x) with
     the entry in the top node. If @m(x) is less than this, we know that we need
     only search the left subtree; if @m(x) is greater, we need only search the
     right subtree. Now, if the tree is @"(balanced,) each of these subtrees will
     be about half the size of the original. Thus, in one step we have reduced the
     problem of searching a tree of size @m(n) to searching a tree of size @m(n /
     2).  Since the size of the tree is halved at each step, we should expect that
     the number of steps needed to search a tree of size @m(n) grows as @m[Θ(log
     n)].@n(104) For large sets, this will be a significant speedup over the
     previous representations.

     We can represent trees by using lists. Each node will be a list of three
     items: the entry at the node, the left subtree, and the right subtree. A left
     or a right subtree of the empty list will indicate that there is no subtree
     connected there. We can describe this representation by the following
     procedures:@n(105)

     ..src > scheme
       (define (entry tree) (car tree))
       (define (left-branch tree) (cadr tree))
       (define (right-branch tree) (caddr tree))
       (define (make-tree entry left right)
         (list entry left right))
     < src..

     Now we can write the @c(element-of-set?) procedure using the strategy
     described above:

     ..src > scheme
       (define (element-of-set? x set)
         (cond ((null? set) false)
               ((= x (entry set)) true)
               ((< x (entry set))
                (element-of-set?
                 x
                 (left-branch set)))
               ((> x (entry set))
                (element-of-set?
                 x
                 (right-branch set)))))
     < src..

     Adjoining an item to a set is implemented similarly and also requires @m[Θ(log
     n)] steps. To adjoin an item @c(x), we compare @c(x) with the node entry to
     determine whether @c(x) should be added to the right or to the left branch,
     and having adjoined @c(x) to the appropriate branch we piece this newly
     constructed branch together with the original entry and the other branch. If
     @c(x) is equal to the entry, we just return the node. If we are asked to
     adjoin @c(x) to an empty tree, we generate a tree that has @c(x) as the entry
     and empty right and left branches. Here is the procedure:

     ..src > scheme
       (define (adjoin-set x set)
         (cond ((null? set) (make-tree x '() '()))
               ((= x (entry set)) set)
               ((< x (entry set))
                (make-tree
                 (entry set)
                 (adjoin-set x (left-branch set))
                 (right-branch set)))
               ((> x (entry set))
                (make-tree
                 (entry set)
                 (left-branch set)
                 (adjoin-set x (right-branch set))))))
     < src..

     The above claim that searching the tree can be performed in a logarithmic
     number of steps rests on the assumption that the tree is @"(balanced,) i.e.,
     that the left and the right subtree of every tree have approximately the same
     number of elements, so that each subtree contains about half the elements of
     its parent. But how can we be certain that the trees we construct will be
     balanced?  Even if we start with a balanced tree, adding elements with
     @c(adjoin-set) may produce an unbalanced result. Since the position of a newly
     adjoined element depends on how the element compares with the items already in
     the set, we can expect that if we add elements @"(randomly) the tree will tend
     to be balanced on the average. But this is not a guarantee. For example, if we
     start with an empty set and adjoin the numbers 1 through 7 in sequence we end
     up with the highly unbalanced tree shown in @l(#Figure 2.17).  In this tree
     all the left subtrees are empty, so it has no advantage over a simple ordered
     list. One way to solve this problem is to define an operation that transforms
     an arbitrary tree into a balanced tree with the same elements.  Then we can
     perform this transformation after every few @c(adjoin-set) operations to keep
     our set in balance. There are also other ways to solve this problem, most of
     which involve designing new data structures for which searching and insertion
     both can be done in @m[Θ(log n)] steps.@n(106)

     ..figure > @t(Figure 2.17) Unbalanced tree produced by adjoining 1 through 7
       in sequence.

       ..art >
         1
          \
           2
            \
             4
              \
               5
                \
                 6
                  \
                   7
       < art..

@    ..img > img/chap2/Fig2.17a.std.svg

     :: @t(Exercise 2.63) :: Each of the following two procedures converts a binary
        tree to a list.

        ..src > scheme
          (define (tree->list-1 tree)
            (if (null? tree)
                '()
                (append
                 (tree->list-1
                  (left-branch tree))
                 (cons (entry tree)
                       (tree->list-1
                        (right-branch tree))))))

          (define (tree->list-2 tree)
            (define (copy-to-list tree result-list)
              (if (null? tree)
                  result-list
                  (copy-to-list
                   (left-branch tree)
                   (cons (entry tree)
                         (copy-to-list
                          (right-branch tree)
                          result-list)))))
            (copy-to-list tree '()))
        < src..

        - Do the two procedures produce the same result for every tree?  If not,
          how do the results differ?  What lists do the two procedures produce for
          the trees in @l(#Figure 2.16)?

        - Do the two procedures have the same order of growth in the number of
          steps required to convert a balanced tree with @m(n) elements to a list?
          If not, which one grows more slowly?

     :: @t(Exercise 2.64) :: The following procedure @c(list->tree) converts an
        ordered list to a balanced binary tree. The helper procedure
        @c(partial-tree) takes as arguments an integer @m(n) and list of at least
        @m(n) elements and constructs a balanced tree containing the first @m(n)
        elements of the list. The result returned by @c(partial-tree) is a pair
        (formed with @c(cons)) whose @c(car) is the constructed tree and whose
        @c(cdr) is the list of elements not included in the tree.

        ..src > scheme
          (define (list->tree elements)
            (car (partial-tree
                  elements (length elements))))

          (define (partial-tree elts n)
            (if (= n 0)
                (cons '() elts)
                (let ((left-size
                       (quotient (- n 1) 2)))
                  (let ((left-result
                         (partial-tree
                          elts left-size)))
                    (let ((left-tree
                           (car left-result))
                          (non-left-elts
                           (cdr left-result))
                          (right-size
                           (- n (+ left-size 1))))
                      (let ((this-entry
                             (car non-left-elts))
                            (right-result
                             (partial-tree
                              (cdr non-left-elts)
                              right-size)))
                        (let ((right-tree
                               (car right-result))
                              (remaining-elts
                               (cdr right-result)))
                          (cons (make-tree this-entry
                                           left-tree
                                           right-tree)
                                remaining-elts))))))))
        < src..

        - Write a short paragraph explaining as clearly as you can how
          @c(partial-tree) works. Draw the tree produced by @c(list->tree) for the
          list @c[(1 3 5 7 9 11)].

        - What is the order of growth in the number of steps required by
          @c(list->tree) to convert a list of @m(n) elements?

     :: @t(Exercise 2.65) :: Use the results of @l(#Exercise 2.63)
        and @l(#Exercise 2.64) to give @m[Θ(n)] implementations of
        @c(union-set) and @c(intersection-set) for sets implemented as (balanced)
        binary trees.@n(107)

**** Sets and information retrieval

     We have examined options for using lists to represent sets and have seen how
     the choice of representation for a data object can have a large impact on the
     performance of the programs that use the data. Another reason for
     concentrating on sets is that the techniques discussed here appear again and
     again in applications involving information retrieval.

     Consider a data base containing a large number of individual records, such as
     the personnel files for a company or the transactions in an accounting system.
     A typical data-management system spends a large amount of time accessing or
     modifying the data in the records and therefore requires an efficient method
     for accessing records. This is done by identifying a part of each record to
     serve as an identifying @e(key). A key can be anything that uniquely
     identifies the record. For a personnel file, it might be an employee's ID
     number. For an accounting system, it might be a transaction number. Whatever
     the key is, when we define the record as a data structure we should include a
     @c(key) selector procedure that retrieves the key associated with a given
     record.

     Now we represent the data base as a set of records. To locate the record with
     a given key we use a procedure @c(lookup), which takes as arguments a key and
     a data base and which returns the record that has that key, or false if there
     is no such record. @c(Lookup) is implemented in almost the same way as
     @c(element-of-set?). For example, if the set of records is implemented as an
     unordered list, we could use

     ..src > scheme
       (define (lookup given-key set-of-records)
         (cond ((null? set-of-records) false)
               ((equal? given-key
                        (key (car set-of-records)))
                (car set-of-records))
               (else
                (lookup given-key
                        (cdr set-of-records)))))
     < src..

     Of course, there are better ways to represent large sets than as unordered
     lists. Information-retrieval systems in which records have to be @"(randomly
     accessed) are typically implemented by a tree-based method, such as the
     binary-tree representation discussed previously. In designing such a system
     the methodology of data abstraction can be a great help. The designer can
     create an initial implementation using a simple, straightforward
     representation such as unordered lists. This will be unsuitable for the
     eventual system, but it can be useful in providing a @"(quick and dirty) data
     base with which to test the rest of the system. Later on, the data
     representation can be modified to be more sophisticated. If the data base is
     accessed in terms of abstract selectors and constructors, this change in
     representation will not require any changes to the rest of the system.

     :: @t(Exercise 2.66) :: Implement the @c(lookup) procedure for the case where
        the set of records is structured as a binary tree, ordered by the numerical
        values of the keys.

*** 2.3.4 <> Example: Huffman Encoding Trees

    This section provides practice in the use of list structure and data
    abstraction to manipulate sets and trees. The application is to methods for
    representing data as sequences of ones and zeros (bits). For example, the
    ASCII standard code used to represent text in computers encodes each character
    as a sequence of seven bits. Using seven bits allows us to distinguish @m(2⁷),
    or 128, possible different characters. In general, if we want to distinguish
    @m(n) different symbols, we will need to use @m(log₂ₙ) bits per symbol. If all
    our messages are made up of the eight symbols A, B, C, D, E, F, G, and H, we
    can choose a code with three bits per character, for example

    ..example >
      A 000  C 010  E 100  G 110
      B 001  D 011  F 101  H 111
    < example..

    With this code, the message

    ..example >
      BACADAEAFABBAAAGAH
    < example..

    is encoded as the string of 54 bits

    ..example >
      001000010000011000100000101
      000001001000000000110000111
    < example..

    Codes such as ASCII and the A-through-H code above are known as
    @e(fixed-length) codes, because they represent each symbol in the message with
    the same number of bits. It is sometimes advantageous to use
    @e(variable-length) codes, in which different symbols may be represented by
    different numbers of bits. For example, Morse code does not use the same
    number of dots and dashes for each letter of the alphabet. In particular, E,
    the most frequent letter, is represented by a single dot. In general, if our
    messages are such that some symbols appear very frequently and some very
    rarely, we can encode data more efficiently (i.e., using fewer bits per
    message) if we assign shorter codes to the frequent symbols. Consider the
    following alternative code for the letters A through H:

    ..example >
      A 0    C 1010  E 1100  G 1110
      B 100  D 1011  F 1101  H 1111
    < example..

    With this code, the same message as above is encoded as the string

    ..example >
      100010100101101100011
      010100100000111001111
    < example..

    This string contains 42 bits, so it saves more than 20% in space in comparison
    with the fixed-length code shown above.

    One of the difficulties of using a variable-length code is knowing when you
    have reached the end of a symbol in reading a sequence of zeros and ones.
    Morse code solves this problem by using a special @e(separator code) (in this
    case, a pause) after the sequence of dots and dashes for each letter.  Another
    solution is to design the code in such a way that no complete code for any
    symbol is the beginning (or @e(prefix)) of the code for another symbol. Such a
    code is called a @e(prefix code). In the example above, A is encoded by 0 and
    B is encoded by 100, so no other symbol can have a code that begins with 0 or
    with 100.

    In general, we can attain significant savings if we use variable-length prefix
    codes that take advantage of the relative frequencies of the symbols in the
    messages to be encoded. One particular scheme for doing this is called the
    Huffman encoding method, after its discoverer, David Huffman. A Huffman code
    can be represented as a binary tree whose leaves are the symbols that are
    encoded. At each non-leaf node of the tree there is a set containing all the
    symbols in the leaves that lie below the node. In addition, each symbol at a
    leaf is assigned a weight (which is its relative frequency), and each non-leaf
    node contains a weight that is the sum of all the weights of the leaves lying
    below it. The weights are not used in the encoding or the decoding process.
    We will see below how they are used to help construct the tree.

    @l(#Figure 2.18) shows the Huffman tree for the A-through-H code given above.
    The weights at the leaves indicate that the tree was designed for messages in
    which A appears with relative frequency 8, B with relative frequency 3, and
    the other letters each with relative frequency 1.

    ..figure > @t(Figure 2.18) A Huffman encoding tree.

      ..art >
                   {A B C D E F G H} 17
                            *
                           / \
                          /   \
                        A 8    *  {B C D E F G H} 9
                    __________/ \_____________
                   /                          \
        {B C D} 5 *                            * {E F G H} 4
                 / \                       ___/ \___
                /   \                     /         \
              B 3    * {C D} 2   {E F} 2 *           * {G H} 2
                    / \                 / \         / \
                   /   \               /   \       /   \
                 C 1   D 1           E 1   F 1   G 1   H 1
      < art..

@   ..img > img/chap2/Fig2.18a.std.svg

    Given a Huffman tree, we can find the encoding of any symbol by starting at
    the root and moving down until we reach the leaf that holds the symbol. Each
    time we move down a left branch we add a 0 to the code, and each time we move
    down a right branch we add a 1. (We decide which branch to follow by testing
    to see which branch either is the leaf node for the symbol or contains the
    symbol in its set.)  For example, starting from the root of the tree in
    @l(#Figure 2.18), we arrive at the leaf for D by following a right branch,
    then a left branch, then a right branch, then a right branch; hence, the code
    for D is 1011.

    To decode a bit sequence using a Huffman tree, we begin at the root and use
    the successive zeros and ones of the bit sequence to determine whether to move
    down the left or the right branch. Each time we come to a leaf, we have
    generated a new symbol in the message, at which point we start over from the
    root of the tree to find the next symbol. For example, suppose we are given
    the tree above and the sequence 10001010. Starting at the root, we move down
    the right branch, (since the first bit of the string is 1), then down the left
    branch (since the second bit is 0), then down the left branch (since the third
    bit is also 0). This brings us to the leaf for B, so the first symbol of the
    decoded message is B. Now we start again at the root, and we make a left move
    because the next bit in the string is 0. This brings us to the leaf for
    A. Then we start again at the root with the rest of the string 1010, so we
    move right, left, right, left and reach C. Thus, the entire message is BAC.

**** Generating Huffman trees

     Given an @"(alphabet) of symbols and their relative frequencies, how do we
     construct the @"(best) code?  (In other words, which tree will encode messages
     with the fewest bits?)  Huffman gave an algorithm for doing this and showed
     that the resulting code is indeed the best variable-length code for messages
     where the relative frequency of the symbols matches the frequencies with which
     the code was constructed. We will not prove this optimality of Huffman codes
     here, but we will show how Huffman trees are constructed.@n(108)

     The algorithm for generating a Huffman tree is very simple. The idea is to
     arrange the tree so that the symbols with the lowest frequency appear farthest
     away from the root. Begin with the set of leaf nodes, containing symbols and
     their frequencies, as determined by the initial data from which the code is to
     be constructed. Now find two leaves with the lowest weights and merge them to
     produce a node that has these two nodes as its left and right branches. The
     weight of the new node is the sum of the two weights. Remove the two leaves
     from the original set and replace them by this new node. Now continue this
     process. At each step, merge two nodes with the smallest weights, removing
     them from the set and replacing them with a node that has these two as its
     left and right branches. The process stops when there is only one node left,
     which is the root of the entire tree. Here is how the Huffman tree of
     @l(#Figure 2.18) was generated:

     ..example >
       Initial {(A 8) (B 3) (C 1) (D 1)
       leaves   (E 1) (F 1) (G 1) (H 1)}

       Merge   {(A 8) (B 3) ({C D} 2)
                (E 1) (F 1) (G 1) (H 1)}

       Merge   {(A 8) (B 3) ({C D} 2)
                ({E F} 2) (G 1) (H 1)}

       Merge   {(A 8) (B 3) ({C D} 2)
                ({E F} 2) ({G H} 2)}

       Merge   {(A 8) (B 3) ({C D} 2)
                ({E F G H} 4)}

       Merge   {(A 8) ({B C D} 5)
                ({E F G H} 4)}

       Merge   {(A 8) ({B C D E F G H} 9)}

       Final   {({A B C D E F G H} 17)}
       merge
     < example..

     The algorithm does not always specify a unique tree, because there may not be
     unique smallest-weight nodes at each step. Also, the choice of the order in
     which the two nodes are merged (i.e., which will be the right branch and which
     will be the left branch) is arbitrary.

**** Representing Huffman trees

     In the exercises below we will work with a system that uses Huffman trees to
     encode and decode messages and generates Huffman trees according to the
     algorithm outlined above. We will begin by discussing how trees are
     represented.

     Leaves of the tree are represented by a list consisting of the symbol
     @c(leaf), the symbol at the leaf, and the weight:

     ..src > scheme
       (define (make-leaf symbol weight)
         (list 'leaf symbol weight))
       (define (leaf? object)
         (eq? (car object) 'leaf))
       (define (symbol-leaf x) (cadr x))
       (define (weight-leaf x) (caddr x))
     < src..

     A general tree will be a list of a left branch, a right branch, a set of
     symbols, and a weight. The set of symbols will be simply a list of the
     symbols, rather than some more sophisticated set representation. When we make
     a tree by merging two nodes, we obtain the weight of the tree as the sum of
     the weights of the nodes, and the set of symbols as the union of the sets of
     symbols for the nodes. Since our symbol sets are represented as lists, we can
     form the union by using the @c(append) procedure we defined in @l(#2.2.1):

     ..src > scheme
       (define (make-code-tree left right)
         (list left
               right
               (append (symbols left)
                       (symbols right))
               (+ (weight left) (weight right))))
     < src..

     If we make a tree in this way, we have the following selectors:

     ..src > scheme
       (define (left-branch tree) (car tree))
       (define (right-branch tree) (cadr tree))

       (define (symbols tree)
         (if (leaf? tree)
             (list (symbol-leaf tree))
             (caddr tree)))

       (define (weight tree)
         (if (leaf? tree)
             (weight-leaf tree)
             (cadddr tree)))
     < src..

     The procedures @c(symbols) and @c(weight) must do something slightly different
     depending on whether they are called with a leaf or a general tree.  These are
     simple examples of @e(generic procedures) (procedures that can handle more
     than one kind of data), which we will have much more to say about in @l(#2.4)
     and @l(#2.5).

**** The decoding procedure

     The following procedure implements the decoding algorithm. It takes as
     arguments a list of zeros and ones, together with a Huffman tree.

     ..src > scheme
       (define (decode bits tree)
         (define (decode-1 bits current-branch)
           (if (null? bits)
               '()
               (let ((next-branch
                      (choose-branch
                       (car bits)
                       current-branch)))
                 (if (leaf? next-branch)
                     (cons
                      (symbol-leaf next-branch)
                      (decode-1 (cdr bits) tree))
                     (decode-1 (cdr bits)
                               next-branch)))))
         (decode-1 bits tree))

       (define (choose-branch bit branch)
         (cond ((= bit 0) (left-branch branch))
               ((= bit 1) (right-branch branch))
               (else (error "bad bit:
                      CHOOSE-BRANCH" bit))))
     < src..

     The procedure @c(decode-1) takes two arguments: the list of remaining bits and
     the current position in the tree. It keeps moving @"(down) the tree, choosing
     a left or a right branch according to whether the next bit in the list is a
     zero or a one. (This is done with the procedure @c(choose-branch).)  When it
     reaches a leaf, it returns the symbol at that leaf as the next symbol in the
     message by @c(cons)ing it onto the result of decoding the rest of the message,
     starting at the root of the tree. Note the error check in the final clause of
     @c(choose-branch), which complains if the procedure finds something other than
     a zero or a one in the input data.

**** Sets of weighted elements

     In our representation of trees, each non-leaf node contains a set of symbols,
     which we have represented as a simple list. However, the tree-generating
     algorithm discussed above requires that we also work with sets of leaves and
     trees, successively merging the two smallest items. Since we will be required
     to repeatedly find the smallest item in a set, it is convenient to use an
     ordered representation for this kind of set.

     We will represent a set of leaves and trees as a list of elements, arranged in
     increasing order of weight. The following @c(adjoin-set) procedure for
     constructing sets is similar to the one described in @l(#Exercise 2.61);
     however, items are compared by their weights, and the element being added to
     the set is never already in it.

     ..src > scheme
       (define (adjoin-set x set)
         (cond ((null? set) (list x))
               ((< (weight x) (weight (car set)))
                (cons x set))
               (else
                (cons (car set)
                      (adjoin-set x (cdr set))))))
     < src..

     The following procedure takes a list of symbol-frequency pairs such as
     @c[((A 4) (B 2) (C 1) (D 1))] and constructs an initial ordered set of leaves,
     ready to be merged according to the Huffman algorithm:

     ..src > scheme
       (define (make-leaf-set pairs)
         (if (null? pairs)
             '()
             (let ((pair (car pairs)))
               (adjoin-set
                (make-leaf (car pair)    ; symbol
                           (cadr pair))  ; frequency
                (make-leaf-set (cdr pairs))))))
     < src..

     :: @t(Exercise 2.67) :: Define an encoding tree and a sample message:

        ..src > scheme
          (define sample-tree
            (make-code-tree
             (make-leaf 'A 4)
             (make-code-tree
              (make-leaf 'B 2)
              (make-code-tree
               (make-leaf 'D 1)
               (make-leaf 'C 1)))))

          (define sample-message
            '(0 1 1 0 0 1 0 1 0 1 1 1 0))
        < src..

        Use the @c(decode) procedure to decode the message, and give the result.

     :: @t(Exercise 2.68) :: The @c(encode) procedure takes as arguments a message
        and a tree and produces the list of bits that gives the encoded message.

        ..src > scheme
          (define (encode message tree)
            (if (null? message)
                '()
                (append
                 (encode-symbol (car message)
                                tree)
                 (encode (cdr message) tree))))
        < src..

        @c(Encode-symbol) is a procedure, which you must write, that returns the
        list of bits that encodes a given symbol according to a given tree. You
        should design @c(encode-symbol) so that it signals an error if the symbol
        is not in the tree at all. Test your procedure by encoding the result you
        obtained in @l(#Exercise 2.67) with the sample tree and seeing whether it
        is the same as the original sample message.

     :: @t(Exercise 2.69) :: The following procedure takes as its argument a list
        of symbol-frequency pairs (where no symbol appears in more than one pair)
        and generates a Huffman encoding tree according to the Huffman algorithm.

        ..src > scheme
          (define (generate-huffman-tree pairs)
            (successive-merge
             (make-leaf-set pairs)))
        < src..

        @c(Make-leaf-set) is the procedure given above that transforms the list of
        pairs into an ordered set of leaves. @c(Successive-merge) is the procedure
        you must write, using @c(make-code-tree) to successively merge the
        smallest-weight elements of the set until there is only one element left,
        which is the desired Huffman tree. (This procedure is slightly tricky, but
        not really complicated. If you find yourself designing a complex procedure,
        then you are almost certainly doing something wrong. You can take
        significant advantage of the fact that we are using an ordered set
        representation.)

     :: @t(Exercise 2.70) :: The following eight-symbol alphabet with associated
        relative frequencies was designed to efficiently encode the lyrics of 1950s
        rock songs. (Note that the @"(symbols) of an @"(alphabet) need not be
        individual letters.)

        ..example >

          A    2    NA  16
          BOOM 1    SHA  3
          GET  2    YIP  9
          JOB  2    WAH  1
        < example..

        Use @c(generate-huffman-tree) (@l(#Exercise 2.69)) to generate a
        corresponding Huffman tree, and use @c(encode) (@l(#Exercise 2.68)) to
        encode the following message:

        ..example >
          Get a job
          Sha na na na na na na na na

          Get a job
          Sha na na na na na na na na

          Wah yip yip yip yip
          yip yip yip yip yip
          Sha boom
        < example..

        How many bits are required for the encoding?  What is the smallest number
        of bits that would be needed to encode this song if we used a fixed-length
        code for the eight-symbol alphabet?

     :: @t(Exercise 2.71) :: Suppose we have a Huffman tree for an alphabet of
        @m(n) symbols, and that the relative frequencies of the symbols are @m(1,
        2, 4, …, 2ⁿ⁻¹). Sketch the tree for @m(n=5); for @m(n=10). In such a tree
        (for general @m(n)) how many bits are required to encode the most frequent
        symbol?  The least frequent symbol?

     :: @t(Exercise 2.72) :: Consider the encoding procedure that you designed in
        @l(#Exercise 2.68). What is the order of growth in the number of steps
        needed to encode a symbol?  Be sure to include the number of steps needed
        to search the symbol list at each node encountered. To answer this question
        in general is difficult. Consider the special case where the relative
        frequencies of the @m(n) symbols are as described in @l(#Exercise 2.71),
        and give the order of growth (as a function of @m(n)) of the number of
        steps needed to encode the most frequent and least frequent symbols in the
        alphabet.

** 2.4 <> Multiple Representations for Abstract Data

   We have introduced data abstraction, a methodology for structuring systems in
   such a way that much of a program can be specified independent of the choices
   involved in implementing the data objects that the program manipulates. For
   example, we saw in @l(#2.1.1) how to separate the task of designing a program
   that uses rational numbers from the task of implementing rational numbers in
   terms of the computer language's primitive mechanisms for constructing
   compound data. The key idea was to erect an abstraction barrier -- in this
   case, the selectors and constructors for rational numbers (@c(make-rat),
   @c(numer), @c(denom))––that isolates the way rational numbers are used from
   their underlying representation in terms of list structure. A similar
   abstraction barrier isolates the details of the procedures that perform
   rational arithmetic (@c(add-rat), @c(sub-rat), @c(mul-rat), and @c(div-rat))
   from the @"(higher-level) procedures that use rational numbers. The resulting
   program has the structure shown in @l(#Figure 2.1).

   These data-abstraction barriers are powerful tools for controlling complexity.
   By isolating the underlying representations of data objects, we can divide the
   task of designing a large program into smaller tasks that can be performed
   separately. But this kind of data abstraction is not yet powerful enough,
   because it may not always make sense to speak of @"(the underlying
   representation) for a data object.

   For one thing, there might be more than one useful representation for a data
   object, and we might like to design systems that can deal with multiple
   representations. To take a simple example, complex numbers may be represented
   in two almost equivalent ways: in rectangular form (real and imaginary parts)
   and in polar form (magnitude and angle). Sometimes rectangular form is more
   appropriate and sometimes polar form is more appropriate. Indeed, it is
   perfectly plausible to imagine a system in which complex numbers are
   represented in both ways, and in which the procedures for manipulating complex
   numbers work with either representation.

   More importantly, programming systems are often designed by many people
   working over extended periods of time, subject to requirements that change
   over time.  In such an environment, it is simply not possible for everyone to
   agree in advance on choices of data representation. So in addition to the
   data-abstraction barriers that isolate representation from use, we need
   abstraction barriers that isolate different design choices from each other and
   permit different choices to coexist in a single program. Furthermore, since
   large programs are often created by combining pre-existing modules that were
   designed in isolation, we need conventions that permit programmers to
   incorporate modules into larger systems @e(additively), that is, without
   having to redesign or reimplement these modules.

   In this section, we will learn how to cope with data that may be represented
   in different ways by different parts of a program. This requires constructing
   @e(generic procedures)––procedures that can operate on data that may be
   represented in more than one way. Our main technique for building generic
   procedures will be to work in terms of data objects that have @e(type tags),
   that is, data objects that include explicit information about how they are to
   be processed. We will also discuss @e(data-directed) programming, a powerful
   and convenient implementation strategy for additively assembling systems with
   generic operations.

   We begin with the simple complex-number example. We will see how type tags and
   data-directed style enable us to design separate rectangular and polar
   representations for complex numbers while maintaining the notion of an
   abstract @"(complex-number) data object. We will accomplish this by defining
   arithmetic procedures for complex numbers (@c(add-complex), @c(sub-complex),
   @c(mul-complex), and @c(div-complex)) in terms of generic selectors that
   access parts of a complex number independent of how the number is represented.
   The resulting complex-number system, as shown in @l(#Figure 2.19), contains
   two different kinds of abstraction barriers. The @"(horizontal) abstraction
   barriers play the same role as the ones in @l(#Figure 2.1). They isolate
   @"(higher-level) operations from @"(lower-level) representations. In addition,
   there is a @"(vertical) barrier that gives us the ability to separately design
   and install alternative representations.

   ..figure > @t(Figure 2.19) Data-abstraction barriers in the complex-number system.

     ..art >
                  Programs that use complex numbers
         ╭─────────────────────────────────────────────────╮
       ──┤ add-complex sub-complex mul-complex div-complex ├──
         ╰─────────────────────────────────────────────────╯
                     Complex arithmetic package
       ───────────────────────────┬───────────────────────────
                 Rectangular      │         Polar
               representation     │     representation
       ───────────────────────────┴───────────────────────────
           List structure and primitive machine arithmetic
     < art..

@  ..img > img/chap2/Fig2.19a.std.svg

   In @l(#2.5) we will show how to use type tags and data-directed style to
   develop a generic arithmetic package. This provides procedures (@c(add),
   @c(mul), and so on) that can be used to manipulate all sorts of @"(numbers)
   and can be easily extended when a new kind of number is needed. In @l(#2.5.3),
   we'll show how to use generic arithmetic in a system that performs symbolic
   algebra.

*** 2.4.1 <> Representations for Complex Numbers

    We will develop a system that performs arithmetic operations on complex
    numbers as a simple but unrealistic example of a program that uses generic
    operations.  We begin by discussing two plausible representations for complex
    numbers as ordered pairs: rectangular form (real part and imaginary part) and
    polar form (magnitude and angle).@n(109) Section @l(#2.4.2) will show how both
    representations can be made to coexist in a single system through the use of
    type tags and generic operations.

    Like rational numbers, complex numbers are naturally represented as ordered
    pairs. The set of complex numbers can be thought of as a two-dimensional space
    with two orthogonal axes, the @"(real) axis and the @"(imaginary) axis. (See
    @l(#Figure 2.20).)  From this point of view, the complex number @m(z = x + iy)
    (where @m(i² = −1)) can be thought of as the point in the plane whose real
    coordinate is @m(x) and whose imaginary coordinate is @m(y).  Addition of
    complex numbers reduces in this representation to addition of coordinates:

    ..example >
      Real-part(z₁ + z₂) = Real-part(z₁) + Real-part(z₂)

      Imaginary-part(z₁ + z₂) = Imaginary-part(z₁) + Imaginary-part(z₂)
    < example..

    ..figure > @t(Figure 2.20) Complex numbers as points in the plane.

      ..art >
         Imaginary
            ▲
            │
          y │.........................◆ z = x + iy = reⁱᴬ
            │                    __-- .
            │                __--     .
            │          r __--         .
            │        __--             .
            │    __-- \               .
            │__--    A |              .
        ────┼──────────┴───────────────────▶ Real
            │                         x
      < art..

@   ..img > img/chap2/Fig2.20.std.svg

    When multiplying complex numbers, it is more natural to think in terms of
    representing a complex number in polar form, as a magnitude and an angle
    (@m(r) and @m(a) in @l(#Figure 2.20)). The product of two complex numbers is
    the vector obtained by stretching one complex number by the length of the
    other and then rotating it through the angle of the other:

    ..example >
      Magnitude(z₁ ⋅ z₂) = Magnitude(z₁) ⋅ Magnitude(z₂)

          Angle(z₁ ⋅ z₂) = Angle(z₁) + Angle(z₂)
    < example..

    Thus, there are two different representations for complex numbers, which are
    appropriate for different operations. Yet, from the viewpoint of someone
    writing a program that uses complex numbers, the principle of data abstraction
    suggests that all the operations for manipulating complex numbers should be
    available regardless of which representation is used by the computer. For
    example, it is often useful to be able to find the magnitude of a complex
    number that is specified by rectangular coordinates. Similarly, it is often
    useful to be able to determine the real part of a complex number that is
    specified by polar coordinates.

    To design such a system, we can follow the same data-abstraction strategy we
    followed in designing the rational-number package in @l(#2.1.1).  Assume that
    the operations on complex numbers are implemented in terms of four selectors:
    @c(real-part), @c(imag-part), @c(magnitude), and @c(angle). Also assume that
    we have two procedures for constructing complex numbers:
    @c(make-from-real-imag) returns a complex number with specified real and
    imaginary parts, and @c(make-from-mag-ang) returns a complex number with
    specified magnitude and angle. These procedures have the property that, for
    any complex number @c(z), both

    ..src > scheme
      (make-from-real-imag (real-part z)
                           (imag-part z))
    < src..

    and

    ..src > scheme
      (make-from-mag-ang (magnitude z)
                         (angle z))
    < src..

    produce complex numbers that are equal to @c(z).

    Using these constructors and selectors, we can implement arithmetic on complex
    numbers using the @"(abstract data) specified by the constructors and
    selectors, just as we did for rational numbers in @l(#2.1.1). As shown in the
    formulas above, we can add and subtract complex numbers in terms of real and
    imaginary parts while multiplying and dividing complex numbers in terms of
    magnitudes and angles:

    ..src > scheme
      (define (add-complex z1 z2)
        (make-from-real-imag
         (+ (real-part z1) (real-part z2))
         (+ (imag-part z1) (imag-part z2))))

      (define (sub-complex z1 z2)
        (make-from-real-imag
         (- (real-part z1) (real-part z2))
         (- (imag-part z1) (imag-part z2))))

      (define (mul-complex z1 z2)
        (make-from-mag-ang
         (* (magnitude z1) (magnitude z2))
         (+ (angle z1) (angle z2))))

      (define (div-complex z1 z2)
        (make-from-mag-ang
         (/ (magnitude z1) (magnitude z2))
         (- (angle z1) (angle z2))))
    < src..

    To complete the complex-number package, we must choose a representation and we
    must implement the constructors and selectors in terms of primitive numbers
    and primitive list structure. There are two obvious ways to do this: We can
    represent a complex number in @"(rectangular form) as a pair (real part,
    imaginary part) or in @"(polar form) as a pair (magnitude, angle). Which shall
    we choose?

    In order to make the different choices concrete, imagine that there are two
    programmers, Ben Bitdiddle and Alyssa P. Hacker, who are independently
    designing representations for the complex-number system. Ben chooses to
    represent complex numbers in rectangular form. With this choice, selecting the
    real and imaginary parts of a complex number is straightforward, as is
    constructing a complex number with given real and imaginary parts. To find the
    magnitude and the angle, or to construct a complex number with a given
    magnitude and angle, he uses the trigonometric relations

    ..example >
                            ________
      x = r cos A     r = ./ x² + y²

      y = r sin A     A = arctan(y,x)
    < example..

    which relate the real and imaginary parts @m[(x, y)] to the magnitude and the
    angle @m[(r, A)].@n(110) Ben's representation is therefore given by the
    following selectors and constructors:

    ..src > scheme
      (define (real-part z) (car z))
      (define (imag-part z) (cdr z))

      (define (magnitude z)
        (sqrt (+ (square (real-part z))
                 (square (imag-part z)))))

      (define (angle z)
        (atan (imag-part z) (real-part z)))

      (define (make-from-real-imag x y)
        (cons x y))

      (define (make-from-mag-ang r a)
        (cons (* r (cos a)) (* r (sin a))))
    < src..

    Alyssa, in contrast, chooses to represent complex numbers in polar form. For
    her, selecting the magnitude and angle is straightforward, but she has to use
    the trigonometric relations to obtain the real and imaginary parts. Alyssa's
    representation is:

    ..src > scheme
      (define (real-part z)
        (* (magnitude z) (cos (angle z))))

      (define (imag-part z)
        (* (magnitude z) (sin (angle z))))

      (define (magnitude z) (car z))
      (define (angle z) (cdr z))

      (define (make-from-real-imag x y)
        (cons (sqrt (+ (square x) (square y)))
              (atan y x)))

      (define (make-from-mag-ang r a)
        (cons r a))
    < src..

    The discipline of data abstraction ensures that the same implementation of
    @c(add-complex), @c(sub-complex), @c(mul-complex), and @c(div-complex) will
    work with either Ben's representation or Alyssa's representation.

*** 2.4.2 <> Tagged data

    One way to view data abstraction is as an application of the @"(principle of
    least commitment.)  In implementing the complex-number system in @l(#2.4.1),
    we can use either Ben's rectangular representation or Alyssa's polar
    representation. The abstraction barrier formed by the selectors and
    constructors permits us to defer to the last possible moment the choice of a
    concrete representation for our data objects and thus retain maximum
    flexibility in our system design.

    The principle of least commitment can be carried to even further extremes. If
    we desire, we can maintain the ambiguity of representation even @e(after) we
    have designed the selectors and constructors, and elect to use both Ben's
    representation @e(and) Alyssa's representation. If both representations are
    included in a single system, however, we will need some way to distinguish
    data in polar form from data in rectangular form. Otherwise, if we were asked,
    for instance, to find the @c(magnitude) of the pair (3, 4), we wouldn't know
    whether to answer 5 (interpreting the number in rectangular form) or 3
    (interpreting the number in polar form). A straightforward way to accomplish
    this distinction is to include a @e(type tag)––the symbol @c(rectangular) or
    @c(polar)––as part of each complex number. Then when we need to manipulate a
    complex number we can use the tag to decide which selector to apply.

    In order to manipulate tagged data, we will assume that we have procedures
    @c(type-tag) and @c(contents) that extract from a data object the tag and the
    actual contents (the polar or rectangular coordinates, in the case of a
    complex number). We will also postulate a procedure @c(attach-tag) that takes
    a tag and contents and produces a tagged data object. A straightforward way to
    implement this is to use ordinary list structure:

    ..src > scheme
      (define (attach-tag type-tag contents)
        (cons type-tag contents))

      (define (type-tag datum)
        (if (pair? datum)
            (car datum)
            (error "Bad tagged datum:
                    TYPE-TAG" datum)))

      (define (contents datum)
        (if (pair? datum)
            (cdr datum)
            (error "Bad tagged datum:
                    CONTENTS" datum)))
    < src..

    Using these procedures, we can define predicates @c(rectangular?)  and
    @c(polar?), which recognize rectangular and polar numbers, respectively:

    ..src > scheme
      (define (rectangular? z)
        (eq? (type-tag z) 'rectangular))

      (define (polar? z)
        (eq? (type-tag z) 'polar))
    < src..

    With type tags, Ben and Alyssa can now modify their code so that their two
    different representations can coexist in the same system. Whenever Ben
    constructs a complex number, he tags it as rectangular. Whenever Alyssa
    constructs a complex number, she tags it as polar. In addition, Ben and Alyssa
    must make sure that the names of their procedures do not conflict. One way to
    do this is for Ben to append the suffix @c(rectangular) to the name of each of
    his representation procedures and for Alyssa to append @c(polar) to the names
    of hers. Here is Ben's revised rectangular representation from @l(#2.4.1):

    ..src > scheme
      (define (real-part-rectangular z) (car z))
      (define (imag-part-rectangular z) (cdr z))

      (define (magnitude-rectangular z)
        (sqrt (+ (square (real-part-rectangular z))
                 (square (imag-part-rectangular z)))))

      (define (angle-rectangular z)
        (atan (imag-part-rectangular z)
              (real-part-rectangular z)))

      (define (make-from-real-imag-rectangular x y)
        (attach-tag 'rectangular (cons x y)))

      (define (make-from-mag-ang-rectangular r a)
        (attach-tag
         'rectangular
         (cons (* r (cos a)) (* r (sin a)))))
    < src..

    and here is Alyssa's revised polar representation:

    ..src > scheme
      (define (real-part-polar z)
        (* (magnitude-polar z)
           (cos (angle-polar z))))

      (define (imag-part-polar z)
        (* (magnitude-polar z)
           (sin (angle-polar z))))

      (define (magnitude-polar z) (car z))
      (define (angle-polar z) (cdr z))

      (define (make-from-real-imag-polar x y)
        (attach-tag
         'polar
         (cons (sqrt (+ (square x) (square y)))
               (atan y x))))

      (define (make-from-mag-ang-polar r a)
        (attach-tag 'polar (cons r a)))
    < src..

    Each generic selector is implemented as a procedure that checks the tag of its
    argument and calls the appropriate procedure for handling data of that type.
    For example, to obtain the real part of a complex number, @c(real-part)
    examines the tag to determine whether to use Ben's @c(real-part-rectangular)
    or Alyssa's @c(real-part-polar). In either case, we use @c(contents) to
    extract the bare, untagged datum and send this to the rectangular or polar
    procedure as required:

    ..src > scheme
      (define (real-part z)
        (cond ((rectangular? z)
               (real-part-rectangular (contents z)))
              ((polar? z)
               (real-part-polar (contents z)))
              (else (error "Unknown type:
                     REAL-PART" z))))

      (define (imag-part z)
        (cond ((rectangular? z)
               (imag-part-rectangular (contents z)))
              ((polar? z)
               (imag-part-polar (contents z)))
              (else (error "Unknown type:
                     IMAG-PART" z))))

      (define (magnitude z)
        (cond ((rectangular? z)
               (magnitude-rectangular (contents z)))
              ((polar? z)
               (magnitude-polar (contents z)))
              (else (error "Unknown type:
                     MAGNITUDE" z))))

      (define (angle z)
        (cond ((rectangular? z)
               (angle-rectangular (contents z)))
              ((polar? z)
               (angle-polar (contents z)))
              (else (error "Unknown type:
                     ANGLE" z))))
    < src..

    To implement the complex-number arithmetic operations, we can use the same
    procedures @c(add-complex), @c(sub-complex), @c(mul-complex), and
    @c(div-complex) from @l(#2.4.1), because the selectors they call are generic,
    and so will work with either representation. For example, the procedure
    @c(add-complex) is still

    ..src > scheme
      (define (add-complex z1 z2)
        (make-from-real-imag
         (+ (real-part z1) (real-part z2))
         (+ (imag-part z1) (imag-part z2))))
    < src..

    Finally, we must choose whether to construct complex numbers using Ben's
    representation or Alyssa's representation. One reasonable choice is to
    construct rectangular numbers whenever we have real and imaginary parts and to
    construct polar numbers whenever we have magnitudes and angles:

    ..src > scheme
      (define (make-from-real-imag x y)
        (make-from-real-imag-rectangular x y))

      (define (make-from-mag-ang r a)
        (make-from-mag-ang-polar r a))
    < src..

    The resulting complex-number system has the structure shown in @l(#Figure
    2.21).  The system has been decomposed into three relatively independent
    parts: the complex-number-arithmetic operations, Alyssa's polar
    implementation, and Ben's rectangular implementation. The polar and
    rectangular implementations could have been written by Ben and Alyssa working
    separately, and both of these can be used as underlying representations by a
    third programmer implementing the complex-arithmetic procedures in terms of
    the abstract constructor/selector interface.

    ..figure > @t(Figure 2.21) Structure of the generic complex-arithmetic system.

      ..art >
             ╭─────────────────────────────────────────────────╮
        ─────┤ add-complex sub-complex mul-complex div-complex ├────
             ╰─────────────────────────────────────────────────╯
                        Complex arithmetic package
                         ╭───────────────────────╮
                         │ real-part   imag-part │
        ─────────────────┤                       ├──────────────────
                         │ magnitude   angle     │
                         ╰───────────┬───────────╯
                   Rectangular       │          Polar
                  representation     │     representation
        ─────────────────────────────┴──────────────────────────────
               List structure and primitive machine arithmetic
      < art..

@   ..img > img/chap2/Fig2.21a.std.svg

    Since each data object is tagged with its type, the selectors operate on the
    data in a generic manner. That is, each selector is defined to have a behavior
    that depends upon the particular type of data it is applied to. Notice the
    general mechanism for interfacing the separate representations: Within a given
    representation implementation (say, Alyssa's polar package) a complex number
    is an untyped pair (magnitude, angle). When a generic selector operates on a
    number of @c(polar) type, it strips off the tag and passes the contents on to
    Alyssa's code. Conversely, when Alyssa constructs a number for general use,
    she tags it with a type so that it can be appropriately recognized by the
    higher-level procedures. This discipline of stripping off and attaching tags
    as data objects are passed from level to level can be an important
    organizational strategy, as we shall see in @l(#2.5).

*** 2.4.3 <> Data-Directed Programming and Additivity

    The general strategy of checking the type of a datum and calling an
    appropriate procedure is called @e(dispatching on type). This is a powerful
    strategy for obtaining modularity in system design. On the other hand,
    implementing the dispatch as in @l(#2.4.2) has two significant weaknesses. One
    weakness is that the generic interface procedures (@c(real-part),
    @c(imag-part), @c(magnitude), and @c(angle)) must know about all the different
    representations. For instance, suppose we wanted to incorporate a new
    representation for complex numbers into our complex-number system. We would
    need to identify this new representation with a type, and then add a clause to
    each of the generic interface procedures to check for the new type and apply
    the appropriate selector for that representation.

    Another weakness of the technique is that even though the individual
    representations can be designed separately, we must guarantee that no two
    procedures in the entire system have the same name. This is why Ben and Alyssa
    had to change the names of their original procedures from @l(#2.4.1).

    The issue underlying both of these weaknesses is that the technique for
    implementing generic interfaces is not @e(additive). The person implementing
    the generic selector procedures must modify those procedures each time a new
    representation is installed, and the people interfacing the individual
    representations must modify their code to avoid name conflicts. In each of
    these cases, the changes that must be made to the code are straightforward,
    but they must be made nonetheless, and this is a source of inconvenience and
    error. This is not much of a problem for the complex-number system as it
    stands, but suppose there were not two but hundreds of different
    representations for complex numbers. And suppose that there were many generic
    selectors to be maintained in the abstract-data interface. Suppose, in fact,
    that no one programmer knew all the interface procedures or all the
    representations. The problem is real and must be addressed in such programs as
    large-scale data-base-management systems.

    What we need is a means for modularizing the system design even further. This
    is provided by the programming technique known as @e(data-directed
    programming).  To understand how data-directed programming works, begin with
    the observation that whenever we deal with a set of generic operations that
    are common to a set of different types we are, in effect, dealing with a
    two-dimensional table that contains the possible operations on one axis and
    the possible types on the other axis. The entries in the table are the
    procedures that implement each operation for each type of argument
    presented. In the complex-number system developed in the previous section, the
    correspondence between operation name, data type, and actual procedure was
    spread out among the various conditional clauses in the generic interface
    procedures. But the same information could have been organized in a table, as
    shown in @l(#Figure 2.22).

    ..figure > @t(Figure 2.22) Table of operations for the complex-number system.

      ..art >
                   |               Types
        Operations | Polar           | Rectangular
        ===========+=================+======================
        real-part  | real-part-polar | real-part-rectangular
        imag-part  | imag-part-polar | imag-part-rectangular
        magnitude  | magnitude-polar | magnitude-rectangular
        angle      | angle-polar     | angle-rectangular
      < art..

@   ..img > img/chap2/Fig2.22.std.svg

    Data-directed programming is the technique of designing programs to work with
    such a table directly. Previously, we implemented the mechanism that
    interfaces the complex-arithmetic code with the two representation packages as
    a set of procedures that each perform an explicit dispatch on type. Here we
    will implement the interface as a single procedure that looks up the
    combination of the operation name and argument type in the table to find the
    correct procedure to apply, and then applies it to the contents of the
    argument. If we do this, then to add a new representation package to the
    system we need not change any existing procedures; we need only add new
    entries to the table.

    To implement this plan, assume that we have two procedures, @c(put) and
    @c(get), for manipulating the operation-and-type table:

    - @c[(put ⟨op⟩ ⟨type⟩ ⟨item⟩)] installs the @c[(item)] in the table, indexed
      by the @c[(op)] and the @c[(type)].

    - @c[(get ⟨op⟩ ⟨type⟩)] looks up the @c[(op)], @c[(type)] entry in the table
      and returns the item found there.  If no item is found, @c(get) returns
      false.

    For now, we can assume that @c(put) and @c(get) are included in our
    language. In @l(#Chapter 3) (@l(#3.3.3)) we will see how to implement these
    and other operations for manipulating tables.

    Here is how data-directed programming can be used in the complex-number
    system.  Ben, who developed the rectangular representation, implements his
    code just as he did originally. He defines a collection of procedures, or a
    @e(package), and interfaces these to the rest of the system by adding entries
    to the table that tell the system how to operate on rectangular numbers. This
    is accomplished by calling the following procedure:

    ..src > scheme
      (define (install-rectangular-package)
        ;; internal procedures
        (define (real-part z) (car z))
        (define (imag-part z) (cdr z))
        (define (make-from-real-imag x y)
          (cons x y))
        (define (magnitude z)
          (sqrt (+ (square (real-part z))
                   (square (imag-part z)))))
        (define (angle z)
          (atan (imag-part z) (real-part z)))
        (define (make-from-mag-ang r a)
          (cons (* r (cos a)) (* r (sin a))))
        ;; interface to the rest of the system
        (define (tag x)
          (attach-tag 'rectangular x))
        (put 'real-part '(rectangular) real-part)
        (put 'imag-part '(rectangular) imag-part)
        (put 'magnitude '(rectangular) magnitude)
        (put 'angle '(rectangular) angle)
        (put 'make-from-real-imag 'rectangular
             (lambda (x y)
               (tag (make-from-real-imag x y))))
        (put 'make-from-mag-ang 'rectangular
             (lambda (r a)
               (tag (make-from-mag-ang r a))))
        'done)
    < src..

    Notice that the internal procedures here are the same procedures from
    @l(#2.4.1) that Ben wrote when he was working in isolation. No changes are
    necessary in order to interface them to the rest of the system. Moreover,
    since these procedure definitions are internal to the installation procedure,
    Ben needn't worry about name conflicts with other procedures outside the
    rectangular package. To interface these to the rest of the system, Ben
    installs his @c(real-part) procedure under the operation name @c(real-part)
    and the type @c[(rectangular)], and similarly for the other selectors.@n(111)
    The interface also defines the constructors to be used by the external
    system.@n(112) These are identical to Ben's internally defined constructors,
    except that they attach the tag.

    Alyssa's polar package is analogous:

    ..src > scheme
      (define (install-polar-package)
        ;; internal procedures
        (define (magnitude z) (car z))
        (define (angle z) (cdr z))
        (define (make-from-mag-ang r a) (cons r a))
        (define (real-part z)
          (* (magnitude z) (cos (angle z))))
        (define (imag-part z)
          (* (magnitude z) (sin (angle z))))
        (define (make-from-real-imag x y)
          (cons (sqrt (+ (square x) (square y)))
                (atan y x)))
        ;; interface to the rest of the system
        (define (tag x) (attach-tag 'polar x))
        (put 'real-part '(polar) real-part)
        (put 'imag-part '(polar) imag-part)
        (put 'magnitude '(polar) magnitude)
        (put 'angle '(polar) angle)
        (put 'make-from-real-imag 'polar
             (lambda (x y)
               (tag (make-from-real-imag x y))))
        (put 'make-from-mag-ang 'polar
             (lambda (r a)
               (tag (make-from-mag-ang r a))))
        'done)
    < src..

    Even though Ben and Alyssa both still use their original procedures defined
    with the same names as each other's (e.g., @c(real-part)), these definitions
    are now internal to different procedures (see @l(#1.1.8)), so there is no name
    conflict.

    The complex-arithmetic selectors access the table by means of a general
    @"(operation) procedure called @c(apply-generic), which applies a generic
    operation to some arguments. @c(Apply-generic) looks in the table under the
    name of the operation and the types of the arguments and applies the resulting
    procedure if one is present:@n(113)

    ..src > scheme
      (define (apply-generic op . args)
        (let ((type-tags (map type-tag args)))
          (let ((proc (get op type-tags)))
            (if proc
                (apply proc (map contents args))
                (error
                  "No method for these types:
                   APPLY-GENERIC"
                  (list op type-tags))))))
    < src..

    Using @c(apply-generic), we can define our generic selectors as follows:

    ..src > scheme
      (define (real-part z)
        (apply-generic 'real-part z))
      (define (imag-part z)
        (apply-generic 'imag-part z))
      (define (magnitude z)
        (apply-generic 'magnitude z))
      (define (angle z)
        (apply-generic 'angle z))
    < src..

    Observe that these do not change at all if a new representation is added to
    the system.

    We can also extract from the table the constructors to be used by the programs
    external to the packages in making complex numbers from real and imaginary
    parts and from magnitudes and angles. As in @l(#2.4.2), we construct
    rectangular numbers whenever we have real and imaginary parts, and polar
    numbers whenever we have magnitudes and angles:

    ..src > scheme
      (define (make-from-real-imag x y)
        ((get 'make-from-real-imag
              'rectangular)
         x y))

      (define (make-from-mag-ang r a)
        ((get 'make-from-mag-ang
              'polar)
         r a))
    < src..

    :: @t(Exercise 2.73) :: @l(#2.3.2) described a program that performs symbolic
       differentiation:

       ..src > scheme
         (define (deriv exp var)
           (cond ((number? exp) 0)
                 ((variable? exp)
                  (if (same-variable? exp var) 1 0))
                 ((sum? exp)
                  (make-sum (deriv (addend exp) var)
                            (deriv (augend exp) var)))
                 ((product? exp)
                  (make-sum
                    (make-product
                     (multiplier exp)
                     (deriv (multiplicand exp) var))
                    (make-product
                     (deriv (multiplier exp) var)
                     (multiplicand exp))))
                 ⟨more rules can be added here⟩
                 (else (error "unknown expression type:
                               DERIV" exp))))
       < src..

       We can regard this program as performing a dispatch on the type of the
       expression to be differentiated. In this situation the @"(type tag) of the
       datum is the algebraic operator symbol (such as @c(+)) and the operation
       being performed is @c(deriv). We can transform this program into
       data-directed style by rewriting the basic derivative procedure as

       ..src > scheme
         (define (deriv exp var)
            (cond ((number? exp) 0)
                  ((variable? exp)
                    (if (same-variable? exp var)
                        1
                        0))
                  (else ((get 'deriv (operator exp))
                         (operands exp)
                         var))))

         (define (operator exp) (car exp))
         (define (operands exp) (cdr exp))
       < src..

       1. Explain what was done above. Why can't we assimilate the predicates
          @c(number?) and @c(variable?) into the data-directed dispatch?

       2. Write the procedures for derivatives of sums and products, and the
          auxiliary code required to install them in the table used by the program
          above.

       3. Choose any additional differentiation rule that you like, such as the
          one for exponents (@l(#Exercise 2.56)), and install it in this
          data-directed system.

       4. In this simple algebraic manipulator the type of an expression is the
          algebraic operator that binds it together. Suppose, however, we indexed
          the procedures in the opposite way, so that the dispatch line in
          @c(deriv) looked like

          ..src > scheme
            ((get (operator exp) 'deriv)
             (operands exp) var)
          < src..

          What corresponding changes to the derivative system are required?

    :: @t(Exercise 2.74) :: Insatiable Enterprises, Inc., is a highly
       decentralized conglomerate company consisting of a large number of
       independent divisions located all over the world. The company's computer
       facilities have just been interconnected by means of a clever
       network-interfacing scheme that makes the entire network appear to any user
       to be a single computer. Insatiable's president, in her first attempt to
       exploit the ability of the network to extract administrative information
       from division files, is dismayed to discover that, although all the
       division files have been implemented as data structures in Scheme, the
       particular data structure used varies from division to division. A meeting
       of division managers is hastily called to search for a strategy to
       integrate the files that will satisfy headquarters' needs while preserving
       the existing autonomy of the divisions.

       Show how such a strategy can be implemented with data-directed
       programming. As an example, suppose that each division's personnel records
       consist of a single file, which contains a set of records keyed on
       employees' names. The structure of the set varies from division to
       division. Furthermore, each employee's record is itself a set (structured
       differently from division to division) that contains information keyed
       under identifiers such as @c(address) and @c(salary). In particular:

       1. Implement for headquarters a @c(get-record) procedure that retrieves a
          specified employee's record from a specified personnel file. The
          procedure should be applicable to any division's file. Explain how the
          individual divisions' files should be structured. In particular, what
          type information must be supplied?

       2. Implement for headquarters a @c(get-salary) procedure that returns the
          salary information from a given employee's record from any division's
          personnel file. How should the record be structured in order to make
          this operation work?

       3. Implement for headquarters a @c(find-employee-record) procedure. This
          should search all the divisions' files for the record of a given
          employee and return the record. Assume that this procedure takes as
          arguments an employee's name and a list of all the divisions' files.

       4. When Insatiable takes over a new company, what changes must be made in
          order to incorporate the new personnel information into the central
          system?

**** Message passing

     The key idea of data-directed programming is to handle generic operations in
     programs by dealing explicitly with operation-and-type tables, such as the
     table in @l(#Figure 2.22). The style of programming we used in @l(#2.4.2)
     organized the required dispatching on type by having each operation take care
     of its own dispatching. In effect, this decomposes the operation-and-type
     table into rows, with each generic operation procedure representing a row of
     the table.

     An alternative implementation strategy is to decompose the table into columns
     and, instead of using @"(intelligent operations) that dispatch on data types,
     to work with @"(intelligent data objects) that dispatch on operation names. We
     can do this by arranging things so that a data object, such as a rectangular
     number, is represented as a procedure that takes as input the required
     operation name and performs the operation indicated. In such a discipline,
     @c(make-from-real-imag) could be written as

     ..src > scheme
       (define (make-from-real-imag x y)
         (define (dispatch op)
           (cond ((eq? op 'real-part) x)
                 ((eq? op 'imag-part) y)
                 ((eq? op 'magnitude)
                  (sqrt (+ (square x) (square y))))
                 ((eq? op 'angle) (atan y x))
                 (else
                  (error "Unknown op:
                   MAKE-FROM-REAL-IMAG" op))))
         dispatch)
     < src..

     The corresponding @c(apply-generic) procedure, which applies a generic
     operation to an argument, now simply feeds the operation's name to the data
     object and lets the object do the work:@n(114)

     ..src > scheme
       (define (apply-generic op arg) (arg op))
     < src..

     Note that the value returned by @c(make-from-real-imag) is a procedure––the
     internal @c(dispatch) procedure. This is the procedure that is invoked when
     @c(apply-generic) requests an operation to be performed.

     This style of programming is called @e(message passing). The name comes from
     the image that a data object is an entity that receives the requested
     operation name as a @"(message.)  We have already seen an example of message
     passing in @l(#2.1.3), where we saw how @c(cons), @c(car), and @c(cdr) could
     be defined with no data objects but only procedures. Here we see that message
     passing is not a mathematical trick but a useful technique for organizing
     systems with generic operations. In the remainder of this chapter we will
     continue to use data-directed programming, rather than message passing, to
     discuss generic arithmetic operations. In @l(#Chapter 3) we will return to
     message passing, and we will see that it can be a powerful tool for
     structuring simulation programs.

     :: @t(Exercise 2.75) :: Implement the constructor @c(make-from-mag-ang) in
        message-passing style. This procedure should be analogous to the
        @c(make-from-real-imag) procedure given above.

     :: @t(Exercise 2.76) :: As a large system with generic operations evolves, new
        types of data objects or new operations may be needed.  For each of the
        three strategies––generic operations with explicit dispatch, data-directed
        style, and message-passing-style––describe the changes that must be made to
        a system in order to add new types or new operations. Which organization
        would be most appropriate for a system in which new types must often be
        added?  Which would be most appropriate for a system in which new
        operations must often be added?

** 2.5 <> Systems with Generic Operations

  In the previous section, we saw how to design systems in which data objects
  can be represented in more than one way. The key idea is to link the code that
  specifies the data operations to the several representations by means of
  generic interface procedures. Now we will see how to use this same idea not
  only to define operations that are generic over different representations but
  also to define operations that are generic over different kinds of arguments.
  We have already seen several different packages of arithmetic operations: the
  primitive arithmetic (@c(+), @c(-), @c(*), @c(/)) built into our language, the
  rational-number arithmetic (@c(add-rat), @c(sub-rat), @c(mul-rat),
  @c(div-rat)) of @l(#2.1.1), and the complex-number arithmetic that we
  implemented in @l(#2.4.3). We will now use data-directed techniques to
  construct a package of arithmetic operations that incorporates all the
  arithmetic packages we have already constructed.

  @l(#Figure 2.23) shows the structure of the system we shall build. Notice the
  abstraction barriers. From the perspective of someone using @"(numbers,) there
  is a single procedure @c(add) that operates on whatever numbers are
  supplied. @c(Add) is part of a generic interface that allows the separate
  ordinary-arithmetic, rational-arithmetic, and complex-arithmetic packages to
  be accessed uniformly by programs that use numbers. Any individual arithmetic
  package (such as the complex package) may itself be accessed through generic
  procedures (such as @c(add-complex)) that combine packages designed for
  different representations (such as rectangular and polar). Moreover, the
  structure of the system is additive, so that one can design the individual
  arithmetic packages separately and combine them to produce a generic
  arithmetic system.

  ..figure > @t(Figure 2.23) Generic arithmetic system.

    ..art >
                               Programs that use numbers
                                  ╭─────────────────╮
      ────────────────────────────┤ add sub mul div ├────────────────────
                                  ╰─────────────────╯
                               Generic arithmetic package
        ╭─────────────────╮   ╭─────────────────────────╮
        │ add-rat sub-rat │   │ add-complex sub-complex │   ╭─────────╮
      ──┤                 ├─┬─┤                         ├─┬─┤ + - * / ├──
        │ mul-rat div-rat │ │ │ mul-complex div-complex │ │ ╰─────────╯
        ╰─────────────────╯ │ ╰─────────────────────────╯ │
             Rational       │     Complex artithmetic     │   Ordinary
            arithmetic      ├──────────────┬──────────────┤  arithmetic
                            │ Rectangular  │     Polar    │
      ──────────────────────┴──────────────┴──────────────┴──────────────
                    List structure and primitive machine arithmetic
    < art..

@ ..img > img/chap2/Fig2.23b.std.svg

*** 2.5.1 <> Generic Arithmetic Operations

    The task of designing generic arithmetic operations is analogous to that of
    designing the generic complex-number operations. We would like, for instance,
    to have a generic addition procedure @c(add) that acts like ordinary primitive
    addition @c(+) on ordinary numbers, like @c(add-rat) on rational numbers, and
    like @c(add-complex) on complex numbers. We can implement @c(add), and the
    other generic arithmetic operations, by following the same strategy we used in
    @l(#2.4.3) to implement the generic selectors for complex numbers. We will
    attach a type tag to each kind of number and cause the generic procedure to
    dispatch to an appropriate package according to the data type of its
    arguments.

    The generic arithmetic procedures are defined as follows:

    ..src > scheme
      (define (add x y) (apply-generic 'add x y))
      (define (sub x y) (apply-generic 'sub x y))
      (define (mul x y) (apply-generic 'mul x y))
      (define (div x y) (apply-generic 'div x y))
    < src..

    We begin by installing a package for handling @e(ordinary) numbers, that is,
    the primitive numbers of our language. We will tag these with the symbol
    @c(scheme-number). The arithmetic operations in this package are the primitive
    arithmetic procedures (so there is no need to define extra procedures to
    handle the untagged numbers). Since these operations each take two arguments,
    they are installed in the table keyed by the list @c[(scheme-number
    scheme-number)]:

    ..src > scheme
      (define (install-scheme-number-package)
        (define (tag x)
          (attach-tag 'scheme-number x))
        (put 'add '(scheme-number scheme-number)
             (lambda (x y) (tag (+ x y))))
        (put 'sub '(scheme-number scheme-number)
             (lambda (x y) (tag (- x y))))
        (put 'mul '(scheme-number scheme-number)
             (lambda (x y) (tag (* x y))))
        (put 'div '(scheme-number scheme-number)
             (lambda (x y) (tag (/ x y))))
        (put 'make 'scheme-number
             (lambda (x) (tag x)))
        'done)
    < src..

    Users of the Scheme-number package will create (tagged) ordinary numbers by
    means of the procedure:

    ..src > scheme
      (define (make-scheme-number n)
        ((get 'make 'scheme-number) n))
    < src..

    Now that the framework of the generic arithmetic system is in place, we can
    readily include new kinds of numbers. Here is a package that performs rational
    arithmetic. Notice that, as a benefit of additivity, we can use without
    modification the rational-number code from @l(#2.1.1) as the internal
    procedures in the package:

    ..src > scheme
      (define (install-rational-package)
        ;; internal procedures
        (define (numer x) (car x))
        (define (denom x) (cdr x))
        (define (make-rat n d)
          (let ((g (gcd n d)))
            (cons (/ n g) (/ d g))))
        (define (add-rat x y)
          (make-rat (+ (* (numer x) (denom y))
                       (* (numer y) (denom x)))
                    (* (denom x) (denom y))))
        (define (sub-rat x y)
          (make-rat (- (* (numer x) (denom y))
                       (* (numer y) (denom x)))
                    (* (denom x) (denom y))))
        (define (mul-rat x y)
          (make-rat (* (numer x) (numer y))
                    (* (denom x) (denom y))))
        (define (div-rat x y)
          (make-rat (* (numer x) (denom y))
                    (* (denom x) (numer y))))
        ;; interface to rest of the system
        (define (tag x) (attach-tag 'rational x))
        (put 'add '(rational rational)
             (lambda (x y) (tag (add-rat x y))))
        (put 'sub '(rational rational)
             (lambda (x y) (tag (sub-rat x y))))
        (put 'mul '(rational rational)
             (lambda (x y) (tag (mul-rat x y))))
        (put 'div '(rational rational)
             (lambda (x y) (tag (div-rat x y))))
        (put 'make 'rational
             (lambda (n d) (tag (make-rat n d))))
        'done)

      (define (make-rational n d)
        ((get 'make 'rational) n d))
    < src..

    We can install a similar package to handle complex numbers, using the tag
    @c(complex). In creating the package, we extract from the table the operations
    @c(make-from-real-imag) and @c(make-from-mag-ang) that were defined by the
    rectangular and polar packages. Additivity permits us to use, as the internal
    operations, the same @c(add-complex), @c(sub-complex), @c(mul-complex), and
    @c(div-complex) procedures from @l(#2.4.1).

    ..src > scheme
      (define (install-complex-package)
        ;; imported procedures from rectangular
        ;; and polar packages
        (define (make-from-real-imag x y)
          ((get 'make-from-real-imag
                'rectangular)
           x y))
        (define (make-from-mag-ang r a)
          ((get 'make-from-mag-ang 'polar)
           r a))
        ;; internal procedures
        (define (add-complex z1 z2)
          (make-from-real-imag
           (+ (real-part z1) (real-part z2))
           (+ (imag-part z1) (imag-part z2))))
        (define (sub-complex z1 z2)
          (make-from-real-imag
           (- (real-part z1) (real-part z2))
           (- (imag-part z1) (imag-part z2))))
        (define (mul-complex z1 z2)
          (make-from-mag-ang
           (* (magnitude z1) (magnitude z2))
           (+ (angle z1) (angle z2))))
        (define (div-complex z1 z2)
          (make-from-mag-ang
           (/ (magnitude z1) (magnitude z2))
           (- (angle z1) (angle z2))))
        ;; interface to rest of the system
        (define (tag z) (attach-tag 'complex z))
        (put 'add '(complex complex)
             (lambda (z1 z2)
               (tag (add-complex z1 z2))))
        (put 'sub '(complex complex)
             (lambda (z1 z2)
               (tag (sub-complex z1 z2))))
        (put 'mul '(complex complex)
             (lambda (z1 z2)
               (tag (mul-complex z1 z2))))
        (put 'div '(complex complex)
             (lambda (z1 z2)
               (tag (div-complex z1 z2))))
        (put 'make-from-real-imag 'complex
             (lambda (x y)
               (tag (make-from-real-imag x y))))
        (put 'make-from-mag-ang 'complex
             (lambda (r a)
               (tag (make-from-mag-ang r a))))
        'done)
    < src..

    Programs outside the complex-number package can construct complex numbers
    either from real and imaginary parts or from magnitudes and angles. Notice how
    the underlying procedures, originally defined in the rectangular and polar
    packages, are exported to the complex package, and exported from there to the
    outside world.

    ..src > scheme
      (define (make-complex-from-real-imag x y)
        ((get 'make-from-real-imag 'complex) x y))
      (define (make-complex-from-mag-ang r a)
        ((get 'make-from-mag-ang 'complex) r a))
    < src..

    What we have here is a two-level tag system. A typical complex number, such as
    @m(3 + 4i) in rectangular form, would be represented as shown in @l(#Figure
    2.24).  The outer tag (@c(complex)) is used to direct the number to the
    complex package. Once within the complex package, the next tag
    (@c(rectangular)) is used to direct the number to the rectangular package.  In
    a large and complicated system there might be many levels, each interfaced
    with the next by means of generic operations. As a data object is passed
    @"(downward,) the outer tag that is used to direct it to the appropriate
    package is stripped off (by applying @c(contents)) and the next level of tag
    (if any) becomes visible to be used for further dispatching.

    ..figure > @t(Figure 2.24) Representation of @m(3 + 4i) in rectangular form.

      ..art >
             ╭───┬───╮     ╭───┬───╮     ╭───┬───╮
        ────▶│ ◆ │ ◆ ┼────▶│ ◆ │ ◆ ┼────▶│ ◆ │ ◆ │
             ╰─┼─┴───╯     ╰─┼─┴───╯     ╰─┼─┴─┼─╯
               │             │             │   │
               ▼             ▼             ▼   ▼
            ╭─────────╮ ╭─────────────╮ ╭───╮ ╭───╮
            │ complex │ │ rectangular │ │ 3 │ │ 4 │
            ╰─────────╯ ╰─────────────╯ ╰───╯ ╰───╯
      < art..

@     ..img > img/chap2/Fig2.24d.std.svg

    In the above packages, we used @c(add-rat), @c(add-complex), and the other
    arithmetic procedures exactly as originally written. Once these definitions
    are internal to different installation procedures, however, they no longer
    need names that are distinct from each other: we could simply name them
    @c(add), @c(sub), @c(mul), and @c(div) in both packages.

    :: @t(Exercise 2.77) :: Louis Reasoner tries to evaluate the expression
       @c[(magnitude z)] where @c(z) is the object shown in @l(#Figure 2.24). To
       his surprise, instead of the answer 5 he gets an error message from
       @c(apply-generic), saying there is no method for the operation
       @c(magnitude) on the types @c[(complex)]. He shows this interaction to
       Alyssa P. Hacker, who says @"(The problem is that the complex-number
       selectors were never defined for @c(complex) numbers, just for @c(polar)
       and @c(rectangular) numbers. All you have to do to make this work is add
       the following to the @c(complex) package:)

       ..src > scheme
         (put 'real-part '(complex) real-part)
         (put 'imag-part '(complex) imag-part)
         (put 'magnitude '(complex) magnitude)
         (put 'angle '(complex) angle)
       < src..

       Describe in detail why this works. As an example, trace through all the
       procedures called in evaluating the expression @c[(magnitude z)] where
       @c(z) is the object shown in @l(#Figure 2.24). In particular, how many
       times is @c(apply-generic) invoked?  What procedure is dispatched to in
       each case?

    :: @t(Exercise 2.78) :: The internal procedures in the @c(scheme-number)
       package are essentially nothing more than calls to the primitive procedures
       @c(+), @c(-), etc. It was not possible to use the primitives of the
       language directly because our type-tag system requires that each data
       object have a type attached to it. In fact, however, all Lisp
       implementations do have a type system, which they use internally. Primitive
       predicates such as @c(symbol?) and @c(number?)  determine whether data
       objects have particular types. Modify the definitions of @c(type-tag),
       @c(contents), and @c(attach-tag) from @l(#2.4.2) so that our generic system
       takes advantage of Scheme's internal type system. That is to say, the
       system should work as before except that ordinary numbers should be
       represented simply as Scheme numbers rather than as pairs whose @c(car) is
       the symbol @c(scheme-number).

    :: @t(Exercise 2.79) :: Define a generic equality predicate @c(equ?) that
       tests the equality of two numbers, and install it in the generic arithmetic
       package. This operation should work for ordinary numbers, rational numbers,
       and complex numbers.

    :: @t(Exercise 2.80) :: Define a generic predicate @c(=zero?) that tests if
       its argument is zero, and install it in the generic arithmetic
       package. This operation should work for ordinary numbers, rational numbers,
       and complex numbers.

*** 2.5.2 <> Combining Data of Different Types

    We have seen how to define a unified arithmetic system that encompasses
    ordinary numbers, complex numbers, rational numbers, and any other type of
    number we might decide to invent, but we have ignored an important issue. The
    operations we have defined so far treat the different data types as being
    completely independent. Thus, there are separate packages for adding, say, two
    ordinary numbers, or two complex numbers. What we have not yet considered is
    the fact that it is meaningful to define operations that cross the type
    boundaries, such as the addition of a complex number to an ordinary number. We
    have gone to great pains to introduce barriers between parts of our programs
    so that they can be developed and understood separately. We would like to
    introduce the cross-type operations in some carefully controlled way, so that
    we can support them without seriously violating our module boundaries.

    One way to handle cross-type operations is to design a different procedure for
    each possible combination of types for which the operation is valid. For
    example, we could extend the complex-number package so that it provides a
    procedure for adding complex numbers to ordinary numbers and installs this in
    the table using the tag @c[(complex scheme-number)]:@n(115)

    ..src > scheme
      (define (add-complex-to-schemenum z x)
        (make-from-real-imag (+ (real-part z) x)
                             (imag-part z)))

      (put 'add
           '(complex scheme-number)
           (lambda (z x)
             (tag (add-complex-to-schemenum z x))))
    < src..

    This technique works, but it is cumbersome. With such a system, the cost of
    introducing a new type is not just the construction of the package of
    procedures for that type but also the construction and installation of the
    procedures that implement the cross-type operations. This can easily be much
    more code than is needed to define the operations on the type itself. The
    method also undermines our ability to combine separate packages additively, or
    at least to limit the extent to which the implementors of the individual
    packages need to take account of other packages. For instance, in the example
    above, it seems reasonable that handling mixed operations on complex numbers
    and ordinary numbers should be the responsibility of the complex-number
    package. Combining rational numbers and complex numbers, however, might be
    done by the complex package, by the rational package, or by some third package
    that uses operations extracted from these two packages. Formulating coherent
    policies on the division of responsibility among packages can be an
    overwhelming task in designing systems with many packages and many cross-type
    operations.

**** Coercion

     In the general situation of completely unrelated operations acting on
     completely unrelated types, implementing explicit cross-type operations,
     cumbersome though it may be, is the best that one can hope for. Fortunately,
     we can usually do better by taking advantage of additional structure that may
     be latent in our type system. Often the different data types are not
     completely independent, and there may be ways by which objects of one type may
     be viewed as being of another type. This process is called @e(coercion).  For
     example, if we are asked to arithmetically combine an ordinary number with a
     complex number, we can view the ordinary number as a complex number whose
     imaginary part is zero. This transforms the problem to that of combining two
     complex numbers, which can be handled in the ordinary way by the
     complex-arithmetic package.

     In general, we can implement this idea by designing coercion procedures that
     transform an object of one type into an equivalent object of another type.
     Here is a typical coercion procedure, which transforms a given ordinary number
     to a complex number with that real part and zero imaginary part:

     ..src > scheme
       (define (scheme-number->complex n)
         (make-complex-from-real-imag
          (contents n) 0))
     < src..

     We install these coercion procedures in a special coercion table, indexed
     under the names of the two types:

     ..src > scheme
       (put-coercion 'scheme-number 'complex
                     scheme-number->complex)
     < src..

     (We assume that there are @c(put-coercion) and @c(get-coercion) procedures
     available for manipulating this table.)  Generally some of the slots in the
     table will be empty, because it is not generally possible to coerce an
     arbitrary data object of each type into all other types. For example, there is
     no way to coerce an arbitrary complex number to an ordinary number, so there
     will be no general @c(complex->scheme-number) procedure included in the table.

     Once the coercion table has been set up, we can handle coercion in a uniform
     manner by modifying the @c(apply-generic) procedure of @l(#2.4.3).  When asked
     to apply an operation, we first check whether the operation is defined for the
     arguments' types, just as before. If so, we dispatch to the procedure found in
     the operation-and-type table. Otherwise, we try coercion.  For simplicity, we
     consider only the case where there are two arguments.@n(116) We check the
     coercion table to see if objects of the first type can be coerced to the
     second type. If so, we coerce the first argument and try the operation
     again. If objects of the first type cannot in general be coerced to the second
     type, we try the coercion the other way around to see if there is a way to
     coerce the second argument to the type of the first argument. Finally, if
     there is no known way to coerce either type to the other type, we give
     up. Here is the procedure:

     ..src > scheme
       (define (apply-generic op . args)
         (let ((type-tags (map type-tag args)))
           (let ((proc (get op type-tags)))
             (if proc
                 (apply proc (map contents args))
                 (if (= (length args) 2)
                     (let ((type1 (car type-tags))
                           (type2 (cadr type-tags))
                           (a1 (car args))
                           (a2 (cadr args)))
                       (let ((t1->t2
                              (get-coercion type1
                                            type2))
                             (t2->t1
                              (get-coercion type2
                                            type1)))
                         (cond (t1->t2
                                (apply-generic
                                 op (t1->t2 a1) a2))
                               (t2->t1
                                (apply-generic
                                 op a1 (t2->t1 a2)))
                               (else
                                (error
                                 "No method for
                                  these types"
                                 (list
                                  op
                                  type-tags))))))
                     (error
                      "No method for these types"
                      (list op type-tags)))))))
     < src..

     This coercion scheme has many advantages over the method of defining explicit
     cross-type operations, as outlined above. Although we still need to write
     coercion procedures to relate the types (possibly @m(n²) procedures for a
     system with @m(n) types), we need to write only one procedure for each pair of
     types rather than a different procedure for each collection of types and each
     generic operation.@n(117) What we are counting on here is the fact that the
     appropriate transformation between types depends only on the types themselves,
     not on the operation to be applied.

     On the other hand, there may be applications for which our coercion scheme is
     not general enough. Even when neither of the objects to be combined can be
     converted to the type of the other it may still be possible to perform the
     operation by converting both objects to a third type. In order to deal with
     such complexity and still preserve modularity in our programs, it is usually
     necessary to build systems that take advantage of still further structure in
     the relations among types, as we discuss next.

**** Hierarchies of types

     The coercion scheme presented above relied on the existence of natural
     relations between pairs of types. Often there is more @"(global) structure in
     how the different types relate to each other. For instance, suppose we are
     building a generic arithmetic system to handle integers, rational numbers,
     real numbers, and complex numbers. In such a system, it is quite natural to
     regard an integer as a special kind of rational number, which is in turn a
     special kind of real number, which is in turn a special kind of complex
     number. What we actually have is a so-called @e(hierarchy of types), in which,
     for example, integers are a @e(subtype) of rational numbers (i.e., any
     operation that can be applied to a rational number can automatically be
     applied to an integer). Conversely, we say that rational numbers form a
     @e(supertype) of integers. The particular hierarchy we have here is of a very
     simple kind, in which each type has at most one supertype and at most one
     subtype. Such a structure, called a @e(tower), is illustrated in @l(#Figure
     2.25).

     ..figure > @t(Figure 2.25) A tower of types.

       ..art >
          complex
            ▲
            │
           real
            ▲
            │
         rational
            ▲
            │
         integer
       < art..

@    ..img > img/chap2/Fig2.25.std.svg

     If we have a tower structure, then we can greatly simplify the problem of
     adding a new type to the hierarchy, for we need only specify how the new type
     is embedded in the next supertype above it and how it is the supertype of the
     type below it. For example, if we want to add an integer to a complex number,
     we need not explicitly define a special coercion procedure
     @c(integer->complex). Instead, we define how an integer can be transformed
     into a rational number, how a rational number is transformed into a real
     number, and how a real number is transformed into a complex number. We then
     allow the system to transform the integer into a complex number through these
     steps and then add the two complex numbers.

     We can redesign our @c(apply-generic) procedure in the following way: For each
     type, we need to supply a @c(raise) procedure, which @"(raises) objects of
     that type one level in the tower. Then when the system is required to operate
     on objects of different types it can successively raise the lower types until
     all the objects are at the same level in the tower. (@l(#Exercise 2.83) and
     @l(#Exercise 2.84) concern the details of implementing such a strategy.)

     Another advantage of a tower is that we can easily implement the notion that
     every type @"(inherits) all operations defined on a supertype. For instance,
     if we do not supply a special procedure for finding the real part of an
     integer, we should nevertheless expect that @c(real-part) will be defined for
     integers by virtue of the fact that integers are a subtype of complex
     numbers. In a tower, we can arrange for this to happen in a uniform way by
     modifying @c(apply-generic). If the required operation is not directly defined
     for the type of the object given, we raise the object to its supertype and try
     again. We thus crawl up the tower, transforming our argument as we go, until
     we either find a level at which the desired operation can be performed or hit
     the top (in which case we give up).

     Yet another advantage of a tower over a more general hierarchy is that it
     gives us a simple way to @"(lower) a data object to the simplest
     representation. For example, if we add @m(2 + 3i) to @m(4 - 3i), it would be
     nice to obtain the answer as the integer 6 rather than as the complex number
     @m(6 + 0i).  @l(#Exercise 2.85) discusses a way to implement such a lowering
     operation.  (The trick is that we need a general way to distinguish those
     objects that can be lowered, such as @m(6 + 0i), from those that cannot, such
     as @m(6 + 2i).)

**** Inadequacies of hierarchies

     If the data types in our system can be naturally arranged in a tower, this
     greatly simplifies the problems of dealing with generic operations on
     different types, as we have seen. Unfortunately, this is usually not the case.
     @l(#Figure 2.26) illustrates a more complex arrangement of mixed types, this
     one showing relations among different types of geometric figures. We see that,
     in general, a type may have more than one subtype. Triangles and
     quadrilaterals, for instance, are both subtypes of polygons. In addition, a
     type may have more than one supertype. For example, an isosceles right
     triangle may be regarded either as an isosceles triangle or as a right
     triangle. This multiple-supertypes issue is particularly thorny, since it
     means that there is no unique way to @"(raise) a type in the hierarchy.
     Finding the @"(correct) supertype in which to apply an operation to an object
     may involve considerable searching through the entire type network on the part
     of a procedure such as @c(apply-generic). Since there generally are multiple
     subtypes for a type, there is a similar problem in coercing a value @"(down)
     the type hierarchy. Dealing with large numbers of interrelated types while
     still preserving modularity in the design of large systems is very difficult,
     and is an area of much current research.@n(118)

     ..figure > @t(Figure 2.26) Relations among types of geometric figures.

       ..art >
                              polygon
                             /       \
                            /         \
                     triangle         quadrilateral
                     /     \              /     \
                    /       \            /       \
              isosceles   right      trapezoid   kite
              triangle    triangle       |         |
               |     \      |            |         |
               |      \     |            |         |
         equilateral   isosceles   parallelogram   |
         triangle      right          |       \    |
                       triangle       |        \   |
                                   rectangle  rhombus
                                         \    /
                                          \  /
                                         square
       < art..

@    ..img > img/chap2/Fig2.26f.std.svg

     :: @t(Exercise 2.81) :: Louis Reasoner has noticed that @c(apply-generic) may
        try to coerce the arguments to each other's type even if they already have
        the same type. Therefore, he reasons, we need to put procedures in the
        coercion table to @e(coerce) arguments of each type to their own type. For
        example, in addition to the @c(scheme-number->complex) coercion shown
        above, he would do:

        ..src > scheme
          (define (scheme-number->scheme-number n) n)
          (define (complex->complex z) z)

          (put-coercion 'scheme-number 'scheme-number
                        scheme-number->scheme-number)

          (put-coercion 'complex 'complex
                        complex->complex)
        < src..

        1. With Louis's coercion procedures installed, what happens if
           @c(apply-generic) is called with two arguments of type @c(scheme-number)
           or two arguments of type @c(complex) for an operation that is not found
           in the table for those types?  For example, assume that we've defined a
           generic exponentiation operation:

           ..src > scheme
             (define (exp x y)
               (apply-generic 'exp x y))
           < src..

           and have put a procedure for exponentiation in the Scheme-number package
           but not in any other package:

           ..src > scheme
             ;; following added to Scheme-number package
             (put 'exp
                  '(scheme-number scheme-number)
                  (lambda (x y)
                    (tag (expt x y))))
                    ; using primitive @c(expt)
           < src..

           What happens if we call @c(exp) with two complex numbers as arguments?

        2. Is Louis correct that something had to be done about coercion with
           arguments of the same type, or does @c(apply-generic) work correctly as
           is?

        3. Modify @c(apply-generic) so that it doesn't try coercion if the two
           arguments have the same type.

     :: @t(Exercise 2.82) :: Show how to generalize @c(apply-generic) to handle
        coercion in the general case of multiple arguments. One strategy is to
        attempt to coerce all the arguments to the type of the first argument, then
        to the type of the second argument, and so on.  Give an example of a
        situation where this strategy (and likewise the two-argument version given
        above) is not sufficiently general. (Hint: Consider the case where there
        are some suitable mixed-type operations present in the table that will not
        be tried.)

     :: @t(Exercise 2.83) :: Suppose you are designing a generic arithmetic system
        for dealing with the tower of types shown in @l(#Figure 2.25): integer,
        rational, real, complex. For each type (except complex), design a procedure
        that raises objects of that type one level in the tower. Show how to
        install a generic @c(raise) operation that will work for each type (except
        complex).

     :: @t(Exercise 2.84) :: Using the @c(raise) operation of @l(#Exercise 2.83),
        modify the @c(apply-generic) procedure so that it coerces its arguments to
        have the same type by the method of successive raising, as discussed in
        this section. You will need to devise a way to test which of two types is
        higher in the tower. Do this in a manner that is @"(compatible) with the
        rest of the system and will not lead to problems in adding new levels to
        the tower.

     :: @t(Exercise 2.85) :: This section mentioned a method for @"(simplifying) a
        data object by lowering it in the tower of types as far as possible. Design
        a procedure @c(drop) that accomplishes this for the tower described in
        @l(#Exercise 2.83). The key is to decide, in some general way, whether an
        object can be lowered. For example, the complex number @m(1.5 + 0i) can be
        lowered as far as @c(real), the complex number @m(1 + 0i) can be lowered as
        far as @c(integer), and the complex number @m(2 + 3i) cannot be lowered at
        all. Here is a plan for determining whether an object can be lowered: Begin
        by defining a generic operation @c(project) that @"(pushes) an object down
        in the tower. For example, projecting a complex number would involve
        throwing away the imaginary part. Then a number can be dropped if, when we
        @c(project) it and @c(raise) the result back to the type we started with,
        we end up with something equal to what we started with. Show how to
        implement this idea in detail, by writing a @c(drop) procedure that drops
        an object as far as possible. You will need to design the various
        projection operations@n(119) and install @c(project) as a generic operation
        in the system. You will also need to make use of a generic equality
        predicate, such as described in @l(#Exercise 2.79). Finally, use @c(drop)
        to rewrite @c(apply-generic) from @l(#Exercise 2.84) so that it
        @"(simplifies) its answers.

     :: @t(Exercise 2.86) :: Suppose we want to handle complex numbers whose real
        parts, imaginary parts, magnitudes, and angles can be either ordinary
        numbers, rational numbers, or other numbers we might wish to add to the
        system. Describe and implement the changes to the system needed to
        accommodate this. You will have to define operations such as @c(sine) and
        @c(cosine) that are generic over ordinary numbers and rational numbers.

*** 2.5.3 <> Example: Symbolic Algebra

    The manipulation of symbolic algebraic expressions is a complex process that
    illustrates many of the hardest problems that occur in the design of
    large-scale systems. An algebraic expression, in general, can be viewed as a
    hierarchical structure, a tree of operators applied to operands. We can
    construct algebraic expressions by starting with a set of primitive objects,
    such as constants and variables, and combining these by means of algebraic
    operators, such as addition and multiplication. As in other languages, we form
    abstractions that enable us to refer to compound objects in simple terms.
    Typical abstractions in symbolic algebra are ideas such as linear combination,
    polynomial, rational function, or trigonometric function. We can regard these
    as compound @"(types,) which are often useful for directing the processing of
    expressions. For example, we could describe the expression

    ..example >
      x² sin (y² + 1) + x cos 2y + cos(y³ − 2y²)
    < example..

    as a polynomial in @m(x) with coefficients that are trigonometric functions of
    polynomials in @m(y) whose coefficients are integers.

    We will not attempt to develop a complete algebraic-manipulation system here.
    Such systems are exceedingly complex programs, embodying deep algebraic
    knowledge and elegant algorithms. What we will do is look at a simple but
    important part of algebraic manipulation: the arithmetic of polynomials. We
    will illustrate the kinds of decisions the designer of such a system faces,
    and how to apply the ideas of abstract data and generic operations to help
    organize this effort.

**** Arithmetic on polynomials

     Our first task in designing a system for performing arithmetic on polynomials
     is to decide just what a polynomial is. Polynomials are normally defined
     relative to certain variables (the @e(indeterminates) of the polynomial).  For
     simplicity, we will restrict ourselves to polynomials having just one
     indeterminate (@e(univariate polynomials)).@n(120) We will define a polynomial
     to be a sum of terms, each of which is either a coefficient, a power of the
     indeterminate, or a product of a coefficient and a power of the
     indeterminate. A coefficient is defined as an algebraic expression that is not
     dependent upon the indeterminate of the polynomial. For example,

     ..example >
       5x² + 3x + 7
     < example..

     is a simple polynomial in @m(x), and

     ..example >
       (y² + 1)x³ + (2y)x + 1
     < example..

     is a polynomial in @m(x) whose coefficients are polynomials in @m(y).

     Already we are skirting some thorny issues. Is the first of these polynomials
     the same as the polynomial @m(5y² + 3y + 7), or not?  A reasonable answer
     might be @"(yes, if we are considering a polynomial purely as a mathematical
     function, but no, if we are considering a polynomial to be a syntactic form.)
     The second polynomial is algebraically equivalent to a polynomial in @m(y)
     whose coefficients are polynomials in @m(x). Should our system recognize this,
     or not?  Furthermore, there are other ways to represent a polynomial––for
     example, as a product of factors, or (for a univariate polynomial) as the set
     of roots, or as a listing of the values of the polynomial at a specified set
     of points.@n(121) We can finesse these questions by deciding that in our
     algebraic-manipulation system a @"(polynomial) will be a particular syntactic
     form, not its underlying mathematical meaning.

     Now we must consider how to go about doing arithmetic on polynomials. In this
     simple system, we will consider only addition and multiplication. Moreover, we
     will insist that two polynomials to be combined must have the same
     indeterminate.

     We will approach the design of our system by following the familiar discipline
     of data abstraction. We will represent polynomials using a data structure
     called a @e(poly), which consists of a variable and a collection of terms. We
     assume that we have selectors @c(variable) and @c(term-list) that extract
     those parts from a poly and a constructor @c(make-poly) that assembles a poly
     from a given variable and a term list. A variable will be just a symbol, so we
     can use the @c(same-variable?)  procedure of @l(#2.3.2) to compare
     variables. The following procedures define addition and multiplication of
     polys:

     ..src > scheme
       (define (add-poly p1 p2)
         (if (same-variable? (variable p1)
                             (variable p2))
             (make-poly
              (variable p1)
              (add-terms (term-list p1)
                         (term-list p2)))
             (error "Polys not in same var:
                     ADD-POLY"
                    (list p1 p2))))

       (define (mul-poly p1 p2)
         (if (same-variable? (variable p1)
                             (variable p2))
             (make-poly
              (variable p1)
              (mul-terms (term-list p1)
                         (term-list p2)))
             (error "Polys not in same var:
                     MUL-POLY"
                    (list p1 p2))))
     < src..

     To incorporate polynomials into our generic arithmetic system, we need to
     supply them with type tags. We'll use the tag @c(polynomial), and install
     appropriate operations on tagged polynomials in the operation table. We'll
     embed all our code in an installation procedure for the polynomial package,
     similar to the ones in @l(#2.5.1):

     ..src > scheme
       (define (install-polynomial-package)
         ;; internal procedures
         ;; representation of poly
         (define (make-poly variable term-list)
           (cons variable term-list))
         (define (variable p) (car p))
         (define (term-list p) (cdr p))
         ⟨procedures same-variable?
          and variable? from section 2.3.2)

         ;; representation of terms and term lists
         ⟨procedures adjoin-term) … coeff
         from text below)⟩

         (define (add-poly p1 p2) …)
         ⟨procedures used by add-poly)
         (define (mul-poly p1 p2) …)
         ⟨procedures used by mul-poly)

         ;; interface to rest of the system
         (define (tag p) (attach-tag 'polynomial p))
         (put 'add '(polynomial polynomial)
              (lambda (p1 p2)
                (tag (add-poly p1 p2))))
         (put 'mul '(polynomial polynomial)
              (lambda (p1 p2)
                (tag (mul-poly p1 p2))))
         (put 'make 'polynomial
              (lambda (var terms)
                (tag (make-poly var terms))))
         'done)
     < src..

     Polynomial addition is performed termwise. Terms of the same order (i.e., with
     the same power of the indeterminate) must be combined. This is done by forming
     a new term of the same order whose coefficient is the sum of the coefficients
     of the addends. Terms in one addend for which there are no terms of the same
     order in the other addend are simply accumulated into the sum polynomial being
     constructed.

     In order to manipulate term lists, we will assume that we have a constructor
     @c(the-empty-termlist) that returns an empty term list and a constructor
     @c(adjoin-term) that adjoins a new term to a term list. We will also assume
     that we have a predicate @c(empty-termlist?) that tells if a given term list
     is empty, a selector @c(first-term) that extracts the highest-order term from
     a term list, and a selector @c(rest-terms) that returns all but the
     highest-order term. To manipulate terms, we will suppose that we have a
     constructor @c(make-term) that constructs a term with given order and
     coefficient, and selectors @c(order) and @c(coeff) that return, respectively,
     the order and the coefficient of the term. These operations allow us to
     consider both terms and term lists as data abstractions, whose concrete
     representations we can worry about separately.

     Here is the procedure that constructs the term list for the sum of two
     polynomials:@n(122)

     ..src > scheme
       (define (add-terms L1 L2)
         (cond ((empty-termlist? L1) L2)
               ((empty-termlist? L2) L1)
               (else
                (let ((t1 (first-term L1))
                      (t2 (first-term L2)))
                  (cond ((> (order t1) (order t2))
                         (adjoin-term
                          t1
                          (add-terms (rest-terms L1)
                                     L2)))
                        ((< (order t1) (order t2))
                         (adjoin-term
                          t2
                          (add-terms
                           L1
                           (rest-terms L2))))
                        (else
                         (adjoin-term
                          (make-term
                           (order t1)
                           (add (coeff t1)
                                (coeff t2)))
                          (add-terms
                           (rest-terms L1)
                           (rest-terms L2)))))))))
     < src..

     The most important point to note here is that we used the generic addition
     procedure @c(add) to add together the coefficients of the terms being
     combined. This has powerful consequences, as we will see below.

     In order to multiply two term lists, we multiply each term of the first list
     by all the terms of the other list, repeatedly using
     @c(mul-term-by-all-terms), which multiplies a given term by all terms in a
     given term list. The resulting term lists (one for each term of the first
     list) are accumulated into a sum.  Multiplying two terms forms a term whose
     order is the sum of the orders of the factors and whose coefficient is the
     product of the coefficients of the factors:

     ..src > scheme
       (define (mul-terms L1 L2)
         (if (empty-termlist? L1)
             (the-empty-termlist)
             (add-terms
              (mul-term-by-all-terms
               (first-term L1) L2)
              (mul-terms (rest-terms L1) L2))))

       (define (mul-term-by-all-terms t1 L)
         (if (empty-termlist? L)
             (the-empty-termlist)
             (let ((t2 (first-term L)))
               (adjoin-term
                (make-term
                 (+ (order t1) (order t2))
                 (mul (coeff t1) (coeff t2)))
                (mul-term-by-all-terms
                 t1
                 (rest-terms L))))))
     < src..

     This is really all there is to polynomial addition and multiplication. Notice
     that, since we operate on terms using the generic procedures @c(add) and
     @c(mul), our polynomial package is automatically able to handle any type of
     coefficient that is known about by the generic arithmetic package. If we
     include a coercion mechanism such as one of those discussed in @l(#2.5.2),
     then we also are automatically able to handle operations on polynomials of
     different coefficient types, such as

     ..example >
                               ┌      2              ┐
       [3x² + (2 + 3i)x + 7] ⋅ │x⁴ + ---x² + (5 + 3i)│
                               └      3              ┘
     < example..

     Because we installed the polynomial addition and multiplication procedures
     @c(add-poly) and @c(mul-poly) in the generic arithmetic system as the @c(add)
     and @c(mul) operations for type @c(polynomial), our system is also
     automatically able to handle polynomial operations such as

     ..example >
       [(y + 1)x² + (y² + 1)x + (y − 1)] ⋅ [(y − 2)x + (y³ + 7)]
     < example..

     The reason is that when the system tries to combine coefficients, it will
     dispatch through @c(add) and @c(mul). Since the coefficients are themselves
     polynomials (in @m(y)), these will be combined using @c(add-poly) and
     @c(mul-poly). The result is a kind of @"(data-directed recursion) in which,
     for example, a call to @c(mul-poly) will result in recursive calls to
     @c(mul-poly) in order to multiply the coefficients. If the coefficients of the
     coefficients were themselves polynomials (as might be used to represent
     polynomials in three variables), the data direction would ensure that the
     system would follow through another level of recursive calls, and so on
     through as many levels as the structure of the data dictates.@n(123)

**** Representing term lists

     Finally, we must confront the job of implementing a good representation for
     term lists. A term list is, in effect, a set of coefficients keyed by the
     order of the term. Hence, any of the methods for representing sets, as
     discussed in @l(#2.3.3), can be applied to this task. On the other hand, our
     procedures @c(add-terms) and @c(mul-terms) always access term lists
     sequentially from highest to lowest order. Thus, we will use some kind of
     ordered list representation.

     How should we structure the list that represents a term list?  One
     consideration is the @"(density) of the polynomials we intend to manipulate. A
     polynomial is said to be @e(dense) if it has nonzero coefficients in terms of
     most orders. If it has many zero terms it is said to be @e(sparse). For
     example,

     ..example >
       A: x⁵ + 2x⁴ + 3x² − 2x − 5
     < example..

     is a dense polynomial, whereas

     ..example >
       B: x¹⁰⁰ + 2x² + 1
     < example..

     is sparse.

     The term lists of dense polynomials are most efficiently represented as lists
     of the coefficients. For example, @m(a) above would be nicely represented as
     @c[(1 2 0 3 -2 -5)]. The order of a term in this representation is the length
     of the sublist beginning with that term's coefficient, decremented by
     1.@n(124) This would be a terrible representation for a sparse polynomial such
     as @m(B): There would be a giant list of zeros punctuated by a few lonely
     nonzero terms. A more reasonable representation of the term list of a sparse
     polynomial is as a list of the nonzero terms, where each term is a list
     containing the order of the term and the coefficient for that order. In such a
     scheme, polynomial @m(B) is efficiently represented as @c[((100 1) (2 2) (0
     1))]. As most polynomial manipulations are performed on sparse polynomials, we
     will use this method. We will assume that term lists are represented as lists
     of terms, arranged from highest-order to lowest-order term. Once we have made
     this decision, implementing the selectors and constructors for terms and term
     lists is straightforward:@n(125)

     ..src > scheme
       (define (adjoin-term term term-list)
         (if (=zero? (coeff term))
             term-list
             (cons term term-list)))
       (define (the-empty-termlist) '())
       (define (first-term term-list) (car term-list))
       (define (rest-terms term-list) (cdr term-list))
       (define (empty-termlist? term-list)
         (null? term-list))
       (define (make-term order coeff)
         (list order coeff))
       (define (order term) (car term))
       (define (coeff term) (cadr term))
     < src..

     where @c(=zero?) is as defined in @l(#Exercise 2.80). (See also @l(#Exercise
     2.87) below.)

     Users of the polynomial package will create (tagged) polynomials by means of
     the procedure:

     ..src > scheme
       (define (make-polynomial var terms)
         ((get 'make 'polynomial) var terms))
     < src..

     :: @t(Exercise 2.87) :: Install @c(=zero?) for polynomials in the generic
        arithmetic package. This will allow @c(adjoin-term) to work for polynomials
        with coefficients that are themselves polynomials.

     :: @t(Exercise 2.88) :: Extend the polynomial system to include subtraction of
        polynomials. (Hint: You may find it helpful to define a generic negation
        operation.)

     :: @t(Exercise 2.89) :: Define procedures that implement the term-list
        representation described above as appropriate for dense polynomials.

     :: @t(Exercise 2.90) :: Suppose we want to have a polynomial system that is
        efficient for both sparse and dense polynomials. One way to do this is to
        allow both kinds of term-list representations in our system. The situation
        is analogous to the complex-number example of @l(#2.4), where we allowed
        both rectangular and polar representations. To do this we must distinguish
        different types of term lists and make the operations on term lists
        generic. Redesign the polynomial system to implement this
        generalization. This is a major effort, not a local change.

     :: @t(Exercise 2.91) :: A univariate polynomial can be divided by another one
        to produce a polynomial quotient and a polynomial remainder. For example,

        ..example >
          x⁵ − 1
          ------ = x³ + x, remainder x − 1
          x² − 1
        < example..

        Division can be performed via long division. That is, divide the
        highest-order term of the dividend by the highest-order term of the
        divisor. The result is the first term of the quotient. Next, multiply the
        result by the divisor, subtract that from the dividend, and produce the
        rest of the answer by recursively dividing the difference by the
        divisor. Stop when the order of the divisor exceeds the order of the
        dividend and declare the dividend to be the remainder. Also, if the
        dividend ever becomes zero, return zero as both quotient and remainder.

        We can design a @c(div-poly) procedure on the model of @c(add-poly) and
        @c(mul-poly). The procedure checks to see if the two polys have the same
        variable. If so, @c(div-poly) strips off the variable and passes the
        problem to @c(div-terms), which performs the division operation on term
        lists. @c(Div-poly) finally reattaches the variable to the result supplied
        by @c(div-terms). It is convenient to design @c(div-terms) to compute both
        the quotient and the remainder of a division. @c(Div-terms) can take two
        term lists as arguments and return a list of the quotient term list and the
        remainder term list.

        Complete the following definition of @c(div-terms) by filling in the
        missing expressions. Use this to implement @c(div-poly), which takes two
        polys as arguments and returns a list of the quotient and remainder polys.

        ..src > scheme
          (define (div-terms L1 L2)
            (if (empty-termlist? L1)
                (list (the-empty-termlist)
                      (the-empty-termlist))
                (let ((t1 (first-term L1))
                      (t2 (first-term L2)))
                  (if (> (order t2) (order t1))
                      (list (the-empty-termlist) L1)
                      (let ((new-c (div (coeff t1)
                                        (coeff t2)))
                            (new-o (- (order t1)
                                      (order t2))))
                        (let ((rest-of-result
                               ⟨compute rest of result
                               recursively⟩ ))
                          ⟨form complete result⟩ ))))))
        < src..

**** Hierarchies of types in symbolic algebra

     Our polynomial system illustrates how objects of one type (polynomials) may in
     fact be complex objects that have objects of many different types as parts.
     This poses no real difficulty in defining generic operations. We need only
     install appropriate generic operations for performing the necessary
     manipulations of the parts of the compound types. In fact, we saw that
     polynomials form a kind of @"(recursive data abstraction,) in that parts of a
     polynomial may themselves be polynomials. Our generic operations and our
     data-directed programming style can handle this complication without much
     trouble.

     On the other hand, polynomial algebra is a system for which the data types
     cannot be naturally arranged in a tower. For instance, it is possible to have
     polynomials in @m(x) whose coefficients are polynomials in @m(y). It is also
     possible to have polynomials in @m(y) whose coefficients are polynomials in
     @m(x). Neither of these types is @"(above) the other in any natural way, yet
     it is often necessary to add together elements from each set. There are
     several ways to do this. One possibility is to convert one polynomial to the
     type of the other by expanding and rearranging terms so that both polynomials
     have the same principal variable. One can impose a towerlike structure on this
     by ordering the variables and thus always converting any polynomial to a
     @"(canonical form) with the highest-priority variable dominant and the
     lower-priority variables buried in the coefficients. This strategy works
     fairly well, except that the conversion may expand a polynomial unnecessarily,
     making it hard to read and perhaps less efficient to work with. The tower
     strategy is certainly not natural for this domain or for any domain where the
     user can invent new types dynamically using old types in various combining
     forms, such as trigonometric functions, power series, and integrals.

     It should not be surprising that controlling coercion is a serious problem in
     the design of large-scale algebraic-manipulation systems. Much of the
     complexity of such systems is concerned with relationships among diverse
     types.  Indeed, it is fair to say that we do not yet completely understand
     coercion.  In fact, we do not yet completely understand the concept of a data
     type.  Nevertheless, what we know provides us with powerful structuring and
     modularity principles to support the design of large systems.

     :: @t(Exercise 2.92) :: By imposing an ordering on variables, extend the
        polynomial package so that addition and multiplication of polynomials works
        for polynomials in different variables. (This is not easy!)

**** Extended exercise: Rational functions

     We can extend our generic arithmetic system to include @e(rational functions).
     These are @"(fractions) whose numerator and denominator are polynomials, such
     as

     ..example >
        x + 1
       -------
       x³ − 1
     < example..

     The system should be able to add, subtract, multiply, and divide rational
     functions, and to perform such computations as

     ..example >
        x + 1       x      x³ + 2x² + 3x + 1
       ------- + ------ = ------------------
       x³ − 1    x² − 1    x⁴ + x³ − x − 1
     < example..

     (Here the sum has been simplified by removing common factors. Ordinary
     @"(cross multiplication) would have produced a fourth-degree polynomial over a
     fifth-degree polynomial.)

     If we modify our rational-arithmetic package so that it uses generic
     operations, then it will do what we want, except for the problem of reducing
     fractions to lowest terms.

     :: @t(Exercise 2.93) :: Modify the rational-arithmetic package to use generic
        operations, but change @c(make-rat) so that it does not attempt to reduce
        fractions to lowest terms. Test your system by calling @c(make-rational) on
        two polynomials to produce a rational function:

        ..src > scheme
          (define p1 (make-polynomial 'x '((2 1) (0 1))))
          (define p2 (make-polynomial 'x '((3 1) (0 1))))
          (define rf (make-rational p2 p1))
        < src..

        Now add @c(rf) to itself, using @c(add). You will observe that this
        addition procedure does not reduce fractions to lowest terms.

     We can reduce polynomial fractions to lowest terms using the same idea we used
     with integers: modifying @c(make-rat) to divide both the numerator and the
     denominator by their greatest common divisor. The notion of @"(greatest common
     divisor) makes sense for polynomials. In fact, we can compute the @A(GCD) of
     two polynomials using essentially the same Euclid's Algorithm that works for
     integers.@n(126) The integer version is

     ..src > scheme
       (define (gcd a b)
         (if (= b 0)
             a
             (gcd b (remainder a b))))
     < src..

     Using this, we could make the obvious modification to define a @A(GCD)
     operation that works on term lists:

     ..src > scheme
       (define (gcd-terms a b)
         (if (empty-termlist? b)
             a
             (gcd-terms b (remainder-terms a b))))
     < src..

     where @c(remainder-terms) picks out the remainder component of the list
     returned by the term-list division operation @c(div-terms) that was
     implemented in @l(#Exercise 2.91).

     :: @t(Exercise 2.94) :: Using @c(div-terms), implement the procedure
        @c(remainder-terms) and use this to define @c(gcd-terms) as above. Now
        write a procedure @c(gcd-poly) that computes the polynomial @A(GCD) of two
        polys. (The procedure should signal an error if the two polys are not in
        the same variable.)  Install in the system a generic operation
        @c(greatest-common-divisor) that reduces to @c(gcd-poly) for polynomials
        and to ordinary @c(gcd) for ordinary numbers. As a test, try

        ..src > scheme
          (define p1
            (make-polynomial
             'x '((4 1) (3 -1) (2 -2) (1 2))))

          (define p2
            (make-polynomial
             'x '((3 1) (1 -1))))

          (greatest-common-divisor p1 p2)
        < src..

        and check your result by hand.

     :: @t(Exercise 2.95) :: Define @m(P₁), @m(P₂), and @m(P₃) to be the
        polynomials

        ..example >
          P₁: x² − 2x + 1

          P₂: 11x² + 7

          P₃: 13x + 5
        < example..

        Now define @m(Q₁) to be the product of @m(P₁) and @m(P₂), and @m(Q₂) to be
        the product of @m(P₁) and @m(P₃), and use @c(greatest-common-divisor)
        (@l(#Exercise 2.94)) to compute the @A(GCD) of @m(Q₁) and @m(Q₂).  Note
        that the answer is not the same as @m(P₁). This example introduces
        noninteger operations into the computation, causing difficulties with the
        @A(GCD) algorithm.@n(127) To understand what is happening, try tracing
        @c(gcd-terms) while computing the @A(GCD) or try performing the division by
        hand.

     We can solve the problem exhibited in @l(#Exercise 2.95) if we use the
     following modification of the @A(GCD) algorithm (which really works only in
     the case of polynomials with integer coefficients). Before performing any
     polynomial division in the @A(GCD) computation, we multiply the dividend by an
     integer constant factor, chosen to guarantee that no fractions will arise
     during the division process. Our answer will thus differ from the actual
     @A(GCD) by an integer constant factor, but this does not matter in the case of
     reducing rational functions to lowest terms; the @A(GCD) will be used to
     divide both the numerator and denominator, so the integer constant factor will
     cancel out.

     More precisely, if @m(P) and @m(Q) are polynomials, let @m(O₁) be the order of
     @m(P) (i.e., the order of the largest term of @m(P)) and let @m(O₂) be the
     order of @m(Q). Let @m(c) be the leading coefficient of @m(Q). Then it can be
     shown that, if we multiply @m(P) by the @e(integerizing factor) @M[c^{1 + O₁ -
     O₂}], the resulting polynomial can be divided by @m(Q) by using the
     @c(div-terms) algorithm without introducing any fractions. The operation of
     multiplying the dividend by this constant and then dividing is sometimes
     called the @e(pseudodivision) of @m(P) by @m(Q). The remainder of the division
     is called the @e(pseudoremainder).

     :: @t(Exercise 2.96) ::

        1. Implement the procedure @c(pseudoremainder-terms), which is just like
           @c(remainder-terms) except that it multiplies the dividend by the
           integerizing factor described above before calling @c(div-terms). Modify
           @c(gcd-terms) to use @c(pseudoremainder-terms), and verify that
           @c(greatest-common-divisor) now produces an answer with integer
           coefficients on the example in @l(#Exercise 2.95).

        2. The @A(GCD) now has integer coefficients, but they are larger than those
           of @m(P₁). Modify @c(gcd-terms) so that it removes common factors from
           the coefficients of the answer by dividing all the coefficients by their
           (integer) greatest common divisor.


     Thus, here is how to reduce a rational function to lowest terms:

     - Compute the @A(GCD) of the numerator and denominator, using the version of
       @c(gcd-terms) from @l(#Exercise 2.96).

     - When you obtain the @A(GCD), multiply both numerator and denominator by the
       same integerizing factor before dividing through by the @A(GCD), so that
       division by the @A(GCD) will not introduce any noninteger coefficients. As
       the factor you can use the leading coefficient of the @A(GCD) raised to the
       power @m(1 + O₁ - O₂), where @m(O₂) is the order of the @A(GCD) and @m(O₁)
       is the maximum of the orders of the numerator and denominator. This will
       ensure that dividing the numerator and denominator by the @A(GCD) will not
       introduce any fractions.

     - The result of this operation will be a numerator and denominator with
       integer coefficients. The coefficients will normally be very large because
       of all of the integerizing factors, so the last step is to remove the
       redundant factors by computing the (integer) greatest common divisor of all
       the coefficients of the numerator and the denominator and dividing through
       by this factor.

     :: @t(Exercise 2.97) ::

        1. Implement this algorithm as a procedure @c(reduce-terms) that takes two
           term lists @c(n) and @c(d) as arguments and returns a list @c(nn),
           @c(dd), which are @c(n) and @c(d) reduced to lowest terms via the
           algorithm given above. Also write a procedure @c(reduce-poly), analogous
           to @c(add-poly), that checks to see if the two polys have the same
           variable.  If so, @c(reduce-poly) strips off the variable and passes the
           problem to @c(reduce-terms), then reattaches the variable to the two
           term lists supplied by @c(reduce-terms).

        2. Define a procedure analogous to @c(reduce-terms) that does what the
           original @c(make-rat) did for integers:

           ..src > scheme
             (define (reduce-integers n d)
               (let ((g (gcd n d)))
                 (list (/ n g) (/ d g))))
           < src..

           and define @c(reduce) as a generic operation that calls
           @c(apply-generic) to dispatch to either @c(reduce-poly) (for
           @c(polynomial) arguments) or @c(reduce-integers) (for @c(scheme-number)
           arguments). You can now easily make the rational-arithmetic package
           reduce fractions to lowest terms by having @c(make-rat) call @c(reduce)
           before combining the given numerator and denominator to form a rational
           number. The system now handles rational expressions in either integers
           or polynomials. To test your program, try the example at the beginning
           of this extended exercise:

           ..src > scheme
             (define p1
               (make-polynomial 'x '((1 1) (0 1))))
             (define p2
               (make-polynomial 'x '((3 1) (0 -1))))
             (define p3
               (make-polynomial 'x '((1 1))))
             (define p4
               (make-polynomial 'x '((2 1) (0 -1))))
             (define rf1 (make-rational p1 p2))
             (define rf2 (make-rational p3 p4))
             (add rf1 rf2)
           < src..

           See if you get the correct answer, correctly reduced to lowest terms.


     The @A(GCD) computation is at the heart of any system that does operations on
     rational functions. The algorithm used above, although mathematically
     straightforward, is extremely slow. The slowness is due partly to the large
     number of division operations and partly to the enormous size of the
     intermediate coefficients generated by the pseudodivisions. One of the active
     areas in the development of algebraic-manipulation systems is the design of
     better algorithms for computing polynomial @A(GCD)s.@n(128)

* Chapter 3 <> Modularity, Objects, and State

  ..quote >
    Mεταβάλλον ὰναπαύεται
    (Even while it changes, it stands still.)

    --Heraclitus

    Plus ça change, plus c'est la même chose.

    --Alphonse Karr
  < quote..

  The preceding chapters introduced the basic elements from which programs are
  made. We saw how primitive procedures and primitive data are combined to
  construct compound entities, and we learned that abstraction is vital in
  helping us to cope with the complexity of large systems. But these tools are
  not sufficient for designing programs. Effective program synthesis also
  requires organizational principles that can guide us in formulating the
  overall design of a program. In particular, we need strategies to help us
  structure large systems so that they will be @e(modular), that is, so that
  they can be divided @"(naturally) into coherent parts that can be separately
  developed and maintained.

  One powerful design strategy, which is particularly appropriate to the
  construction of programs for modeling physical systems, is to base the
  structure of our programs on the structure of the system being modeled. For
  each object in the system, we construct a corresponding computational object.
  For each system action, we define a symbolic operation in our computational
  model. Our hope in using this strategy is that extending the model to
  accommodate new objects or new actions will require no strategic changes to
  the program, only the addition of the new symbolic analogs of those objects or
  actions. If we have been successful in our system organization, then to add a
  new feature or debug an old one we will have to work on only a localized part
  of the system.

  To a large extent, then, the way we organize a large program is dictated by
  our perception of the system to be modeled. In this chapter we will
  investigate two prominent organizational strategies arising from two rather
  different @"(world views) of the structure of systems. The first
  organizational strategy concentrates on @e(objects), viewing a large system as
  a collection of distinct objects whose behaviors may change over time. An
  alternative organizational strategy concentrates on the @e(streams) of
  information that flow in the system, much as an electrical engineer views a
  signal-processing system.

  Both the object-based approach and the stream-processing approach raise
  significant linguistic issues in programming. With objects, we must be
  concerned with how a computational object can change and yet maintain its
  identity. This will force us to abandon our old substitution model of
  computation (@l(#1.1.5)) in favor of a more mechanistic but less theoretically
  tractable @e(environment model) of computation. The difficulties of dealing
  with objects, change, and identity are a fundamental consequence of the need
  to grapple with time in our computational models.  These difficulties become
  even greater when we allow the possibility of concurrent execution of
  programs. The stream approach can be most fully exploited when we decouple
  simulated time in our model from the order of the events that take place in
  the computer during evaluation. We will accomplish this using a technique
  known as @e(delayed evaluation).

** 3.1 <> Assignment and Local State

   We ordinarily view the world as populated by independent objects, each of
   which has a state that changes over time. An object is said to @"(have state)
   if its behavior is influenced by its history. A bank account, for example, has
   state in that the answer to the question @"(Can I withdraw $100?)  depends
   upon the history of deposit and withdrawal transactions. We can characterize
   an object's state by one or more @e(state variables), which among them
   maintain enough information about history to determine the object's current
   behavior. In a simple banking system, we could characterize the state of an
   account by a current balance rather than by remembering the entire history of
   account transactions.

   In a system composed of many objects, the objects are rarely completely
   independent. Each may influence the states of others through interactions,
   which serve to couple the state variables of one object to those of other
   objects. Indeed, the view that a system is composed of separate objects is
   most useful when the state variables of the system can be grouped into closely
   coupled subsystems that are only loosely coupled to other subsystems.

   This view of a system can be a powerful framework for organizing computational
   models of the system. For such a model to be modular, it should be decomposed
   into computational objects that model the actual objects in the system. Each
   computational object must have its own @e(local state variables) describing
   the actual object's state. Since the states of objects in the system being
   modeled change over time, the state variables of the corresponding
   computational objects must also change. If we choose to model the flow of time
   in the system by the elapsed time in the computer, then we must have a way to
   construct computational objects whose behaviors change as our programs run. In
   particular, if we wish to model state variables by ordinary symbolic names in
   the programming language, then the language must provide an @e(assignment
   operator) to enable us to change the value associated with a name.

*** 3.1.1 <> Local State Variables

    To illustrate what we mean by having a computational object with time-varying
    state, let us model the situation of withdrawing money from a bank account. We
    will do this using a procedure @c(withdraw), which takes as argument an
    @c(amount) to be withdrawn. If there is enough money in the account to
    accommodate the withdrawal, then @c(withdraw) should return the balance
    remaining after the withdrawal. Otherwise, @c(withdraw) should return the
    message @e(Insufficient funds). For example, if we begin with $100 in the
    account, we should obtain the following sequence of responses using
    @c(withdraw):

    ..srci > scheme
      > (withdraw 25)
      75
      > (withdraw 25)
      50
      > (withdraw 60)
      "Insufficient funds"
      > (withdraw 15)
      35
    < srci..

    Observe that the expression @c[(withdraw 25)], evaluated twice, yields
    different values. This is a new kind of behavior for a procedure. Until now,
    all our procedures could be viewed as specifications for computing
    mathematical functions. A call to a procedure computed the value of the
    function applied to the given arguments, and two calls to the same procedure
    with the same arguments always produced the same result.@n(129)

    To implement @c(withdraw), we can use a variable @c(balance) to indicate the
    balance of money in the account and define @c(withdraw) as a procedure that
    accesses @c(balance). The @c(withdraw) procedure checks to see if @c(balance)
    is at least as large as the requested @c(amount). If so, @c(withdraw)
    decrements @c(balance) by @c(amount) and returns the new value of
    @c(balance). Otherwise, @c(withdraw) returns the @e(Insufficient funds)
    message. Here are the definitions of @c(balance) and @c(withdraw):

    ..src > scheme
      (define balance 100)

      (define (withdraw amount)
        (if (>= balance amount)
            (begin (set! balance (- balance amount))
                   balance)
            "Insufficient funds"))
    < src..

    Decrementing @c(balance) is accomplished by the expression

    ..src > scheme
      (set! balance (- balance amount))
    < src..

    This uses the @c(set!) special form, whose syntax is

    ..src > scheme
      (set! ⟨name⟩ ⟨new-value⟩)
    < src..

    Here @c[(name)] is a symbol and @c[(new-value)] is any expression.  @c(Set!)
    changes @c[(name)] so that its value is the result obtained by evaluating
    @c[(new-value)]. In the case at hand, we are changing @c(balance) so that its
    new value will be the result of subtracting @c(amount) from the previous value
    of @c(balance).@n(130)

    @c(Withdraw) also uses the @c(begin) special form to cause two expressions to
    be evaluated in the case where the @c(if) test is true: first decrementing
    @c(balance) and then returning the value of @c(balance). In general,
    evaluating the expression

    ..src > scheme
      (begin ⟨exp₁⟩ ⟨exp₂⟩ … ⟨expₖ⟩)
    < src..

    causes the expressions @m[⟨exp₁⟩] through @m[⟨expₙ⟩] to be evaluated in
    sequence and the value of the final expression @m[⟨expₙ⟩] to be returned as
    the value of the entire @c(begin) form.@n(131)

    Although @c(withdraw) works as desired, the variable @c(balance) presents a
    problem. As specified above, @c(balance) is a name defined in the global
    environment and is freely accessible to be examined or modified by any
    procedure. It would be much better if we could somehow make @c(balance)
    internal to @c(withdraw), so that @c(withdraw) would be the only procedure
    that could access @c(balance) directly and any other procedure could access
    @c(balance) only indirectly (through calls to @c(withdraw)).  This would more
    accurately model the notion that @c(balance) is a local state variable used by
    @c(withdraw) to keep track of the state of the account.

    We can make @c(balance) internal to @c(withdraw) by rewriting the definition
    as follows:

    ..src > scheme
      (define new-withdraw
        (let ((balance 100))
          (lambda (amount)
            (if (>= balance amount)
                (begin (set! balance
                             (- balance amount))
                       balance)
                "Insufficient funds"))))
    < src..

    What we have done here is use @c(let) to establish an environment with a local
    variable @c(balance), bound to the initial value 100. Within this local
    environment, we use @c(lambda) to create a procedure that takes @c(amount) as
    an argument and behaves like our previous @c(withdraw) procedure. This
    procedure––returned as the result of evaluating the @c(let) expression––is
    @c(new-withdraw), which behaves in precisely the same way as @c(withdraw) but
    whose variable @c(balance) is not accessible by any other procedure.@n(132)

    Combining @c(set!) with local variables is the general programming technique
    we will use for constructing computational objects with local state.
    Unfortunately, using this technique raises a serious problem: When we first
    introduced procedures, we also introduced the substitution model of evaluation
    (@l(#1.1.5)) to provide an interpretation of what procedure application
    means. We said that applying a procedure should be interpreted as evaluating
    the body of the procedure with the formal parameters replaced by their
    values. The trouble is that, as soon as we introduce assignment into our
    language, substitution is no longer an adequate model of procedure
    application.  (We will see why this is so in @l(#3.1.3).)  As a consequence,
    we technically have at this point no way to understand why the
    @c(new-withdraw) procedure behaves as claimed above. In order to really
    understand a procedure such as @c(new-withdraw), we will need to develop a new
    model of procedure application. In @l(#3.2) we will introduce such a model,
    together with an explanation of @c(set!) and local variables. First, however,
    we examine some variations on the theme established by @c(new-withdraw).

    The following procedure, @c(make-withdraw), creates @"(withdrawal processors.)
    The formal parameter @c(balance) in @c(make-withdraw) specifies the initial
    amount of money in the account.@n(133)

    ..src > scheme
      (define (make-withdraw balance)
        (lambda (amount)
          (if (>= balance amount)
              (begin (set! balance
                           (- balance amount))
                     balance)
              "Insufficient funds")))
    < src..

    @c(Make-withdraw) can be used as follows to create two objects @c(W1) and
    @c(W2):

    ..srci > scheme
      > (define W1 (make-withdraw 100))
      > (define W2 (make-withdraw 100))
      > (W1 50)
      50
      > (W2 70)
      30
      > (W2 40)
      "Insufficient funds"
      > (W1 40)
      10
    < srci..

    Observe that @c(W1) and @c(W2) are completely independent objects, each with
    its own local state variable @c(balance). Withdrawals from one do not affect
    the other.

    We can also create objects that handle deposits as well as withdrawals, and
    thus we can represent simple bank accounts. Here is a procedure that returns a
    @"(bank-account object) with a specified initial balance:

    ..src > scheme
      (define (make-account balance)
        (define (withdraw amount)
          (if (>= balance amount)
              (begin (set! balance
                           (- balance amount))
                     balance)
              "Insufficient funds"))
        (define (deposit amount)
          (set! balance (+ balance amount))
          balance)
        (define (dispatch m)
          (cond ((eq? m 'withdraw) withdraw)
                ((eq? m 'deposit) deposit)
                (else (error "Unknown request:
                       MAKE-ACCOUNT" m))))
        dispatch)
    < src..

    Each call to @c(make-account) sets up an environment with a local state
    variable @c(balance). Within this environment, @c(make-account) defines
    procedures @c(deposit) and @c(withdraw) that access @c(balance) and an
    additional procedure @c(dispatch) that takes a @"(message) as input and
    returns one of the two local procedures. The @c(dispatch) procedure itself is
    returned as the value that represents the bank-account object. This is
    precisely the @e(message-passing) style of programming that we saw in
    @l(#2.4.3), although here we are using it in conjunction with the ability to
    modify local variables.

    @c(Make-account) can be used as follows:

    ..srci > scheme
      > (define acc (make-account 100))
      > ((acc 'withdraw) 50)
      50
      > ((acc 'withdraw) 60)
      "Insufficient funds"
      > ((acc 'deposit) 40)
      90
      > ((acc 'withdraw) 60)
      30
    < srci..

    Each call to @c(acc) returns the locally defined @c(deposit) or @c(withdraw)
    procedure, which is then applied to the specified @c(amount). As was the case
    with @c(make-withdraw), another call to @c(make-account)

    ..src > scheme
      (define acc2 (make-account 100))
    < src..

    will produce a completely separate account object, which maintains its own
    local @c(balance).

    :: @t(Exercise 3.1) :: An @e(accumulator) is a procedure that is called
       repeatedly with a single numeric argument and accumulates its arguments
       into a sum. Each time it is called, it returns the currently accumulated
       sum. Write a procedure @c(make-accumulator) that generates accumulators,
       each maintaining an independent sum. The input to @c(make-accumulator)
       should specify the initial value of the sum; for example

       ..srci > scheme
         > (define A (make-accumulator 5))
         > (A 10)
         15
         > (A 10)
         25
       < srci..

    :: @t(Exercise 3.2) :: In software-testing applications, it is useful to be
       able to count the number of times a given procedure is called during the
       course of a computation. Write a procedure @c(make-monitored) that takes as
       input a procedure, @c(f), that itself takes one input. The result returned
       by @c(make-monitored) is a third procedure, say @c(mf), that keeps track of
       the number of times it has been called by maintaining an internal
       counter. If the input to @c(mf) is the special symbol @c(how-many-calls?),
       then @c(mf) returns the value of the counter. If the input is the special
       symbol @c(reset-count), then @c(mf) resets the counter to zero. For any
       other input, @c(mf) returns the result of calling @c(f) on that input and
       increments the counter. For instance, we could make a monitored version of
       the @c(sqrt) procedure:

       ..srci > scheme
         > (define s (make-monitored sqrt))
         > (s 100)
         10
         > (s 'how-many-calls?)
         1
       < srci..

    :: @t(Exercise 3.3) :: Modify the @c(make-account) procedure so that it
       creates password-protected accounts. That is, @c(make-account) should take
       a symbol as an additional argument, as in

       ..src > scheme
         (define acc
           (make-account 100 'secret-password))
       < src..

       The resulting account object should process a request only if it is
       accompanied by the password with which the account was created, and should
       otherwise return a complaint:

       ..srci > scheme
         > ((acc 'secret-password 'withdraw) 40)
         60
         > ((acc 'some-other-password 'deposit) 50)
         "Incorrect password"
       < srci..

    :: @t(Exercise 3.4) :: Modify the @c(make-account) procedure of @l(#Exercise
       3.3) by adding another local state variable so that, if an account is
       accessed more than seven consecutive times with an incorrect password, it
       invokes the procedure @c(call-the-cops).

*** 3.1.2 <> The Benefits of Introducing Assignment

    As we shall see, introducing assignment into our programming language leads us
    into a thicket of difficult conceptual issues. Nevertheless, viewing systems
    as collections of objects with local state is a powerful technique for
    maintaining a modular design. As a simple example, consider the design of a
    procedure @c(rand) that, whenever it is called, returns an integer chosen at
    random.

    It is not at all clear what is meant by @"(chosen at random.)  What we
    presumably want is for successive calls to @c(rand) to produce a sequence of
    numbers that has statistical properties of uniform distribution. We will not
    discuss methods for generating suitable sequences here. Rather, let us assume
    that we have a procedure @c(rand-update) that has the property that if we
    start with a given number @m(x₁) and form

    ..src > scheme
      x₂ = (rand-update x₁)
      x₃ = (rand-update x₂)
    < src..

    then the sequence of values @m(x₁), @m(x₂), @m(x₃), … will have the desired
    statistical properties.@n(134)

    We can implement @c(rand) as a procedure with a local state variable @c(x)
    that is initialized to some fixed value @c(random-init). Each call to @c(rand)
    computes @c(rand-update) of the current value of @c(x), returns this as the
    random number, and also stores this as the new value of @c(x).

    ..src > scheme
      (define rand
        (let ((x random-init))
          (lambda () (set! x (rand-update x)) x)))
    < src..

    Of course, we could generate the same sequence of random numbers without using
    assignment by simply calling @c(rand-update) directly. However, this would
    mean that any part of our program that used random numbers would have to
    explicitly remember the current value of @c(x) to be passed as an argument to
    @c(rand-update). To realize what an annoyance this would be, consider using
    random numbers to implement a technique called @e(Monte Carlo simulation).

    The Monte Carlo method consists of choosing sample experiments at random from
    a large set and then making deductions on the basis of the probabilities
    estimated from tabulating the results of those experiments. For example, we
    can approximate @m(π) using the fact that @m(6/π²) is the probability that two
    integers chosen at random will have no factors in common; that is, that their
    greatest common divisor will be 1.@n(135) To obtain the approximation to
    @m(π), we perform a large number of experiments.  In each experiment we choose
    two integers at random and perform a test to see if their @A(GCD) is 1. The
    fraction of times that the test is passed gives us our estimate of @m(6/π²),
    and from this we obtain our approximation to @m(π).

    The heart of our program is a procedure @c(monte-carlo), which takes as
    arguments the number of times to try an experiment, together with the
    experiment, represented as a no-argument procedure that will return either
    true or false each time it is run. @c(Monte-carlo) runs the experiment for the
    designated number of trials and returns a number telling the fraction of the
    trials in which the experiment was found to be true.

    ..src > scheme
      (define (estimate-pi trials)
        (sqrt (/ 6 (monte-carlo trials
                                cesaro-test))))
      (define (cesaro-test)
         (= (gcd (rand) (rand)) 1))

      (define (monte-carlo trials experiment)
        (define (iter trials-remaining trials-passed)
          (cond ((= trials-remaining 0)
                 (/ trials-passed trials))
                ((experiment)
                 (iter (- trials-remaining 1)
                       (+ trials-passed 1)))
                (else
                 (iter (- trials-remaining 1)
                       trials-passed))))
        (iter trials 0))
    < src..

    Now let us try the same computation using @c(rand-update) directly rather than
    @c(rand), the way we would be forced to proceed if we did not use assignment
    to model local state:

    ..src > scheme
      (define (estimate-pi trials)
        (sqrt (/ 6 (random-gcd-test trials
                                    random-init))))

      (define (random-gcd-test trials initial-x)
        (define (iter trials-remaining
                      trials-passed
                      x)
          (let ((x1 (rand-update x)))
            (let ((x2 (rand-update x1)))
              (cond ((= trials-remaining 0)
                     (/ trials-passed trials))
                    ((= (gcd x1 x2) 1)
                     (iter (- trials-remaining 1)
                           (+ trials-passed 1)
                           x2))
                    (else
                     (iter (- trials-remaining 1)
                           trials-passed
                           x2))))))
        (iter trials 0 initial-x))
    < src..

    While the program is still simple, it betrays some painful breaches of
    modularity. In our first version of the program, using @c(rand), we can
    express the Monte Carlo method directly as a general @c(monte-carlo) procedure
    that takes as an argument an arbitrary @c(experiment) procedure.  In our
    second version of the program, with no local state for the random-number
    generator, @c(random-gcd-test) must explicitly manipulate the random numbers
    @c(x1) and @c(x2) and recycle @c(x2) through the iterative loop as the new
    input to @c(rand-update). This explicit handling of the random numbers
    intertwines the structure of accumulating test results with the fact that our
    particular experiment uses two random numbers, whereas other Monte Carlo
    experiments might use one random number or three. Even the top-level procedure
    @c(estimate-pi) has to be concerned with supplying an initial random number.
    The fact that the random-number generator's insides are leaking out into other
    parts of the program makes it difficult for us to isolate the Monte Carlo idea
    so that it can be applied to other tasks. In the first version of the program,
    assignment encapsulates the state of the random-number generator within the
    @c(rand) procedure, so that the details of random-number generation remain
    independent of the rest of the program.

    The general phenomenon illustrated by the Monte Carlo example is this: From
    the point of view of one part of a complex process, the other parts appear to
    change with time. They have hidden time-varying local state. If we wish to
    write computer programs whose structure reflects this decomposition, we make
    computational objects (such as bank accounts and random-number generators)
    whose behavior changes with time. We model state with local state variables,
    and we model the changes of state with assignments to those variables.

    It is tempting to conclude this discussion by saying that, by introducing
    assignment and the technique of hiding state in local variables, we are able
    to structure systems in a more modular fashion than if all state had to be
    manipulated explicitly, by passing additional parameters. Unfortunately, as we
    shall see, the story is not so simple.

    :: @t(Exercise 3.5) :: @e(Monte Carlo integration) is a method of estimating
       definite integrals by means of Monte Carlo simulation. Consider computing
       the area of a region of space described by a predicate @m[P(x, y)] that is
       true for points @m[(x, y)] in the region and false for points not in the
       region. For example, the region contained within a circle of radius 3
       centered at (5, 7) is described by the predicate that tests whether @m[(x -
       5)² + (y - 7)² ≤ 3²]. To estimate the area of the region described by such
       a predicate, begin by choosing a rectangle that contains the region. For
       example, a rectangle with diagonally opposite corners at (2, 4) and (8, 10)
       contains the circle above. The desired integral is the area of that portion
       of the rectangle that lies in the region.  We can estimate the integral by
       picking, at random, points @m[(x, y)] that lie in the rectangle, and
       testing @m[P(x, y)] for each point to determine whether the point lies in
       the region. If we try this with many points, then the fraction of points
       that fall in the region should give an estimate of the proportion of the
       rectangle that lies in the region. Hence, multiplying this fraction by the
       area of the entire rectangle should produce an estimate of the integral.

       Implement Monte Carlo integration as a procedure @c(estimate-integral) that
       takes as arguments a predicate @c(P), upper and lower bounds @c(x1),
       @c(x2), @c(y1), and @c(y2) for the rectangle, and the number of trials to
       perform in order to produce the estimate. Your procedure should use the
       same @c(monte-carlo) procedure that was used above to estimate @m(π).  Use
       your @c(estimate-integral) to produce an estimate of @m(π) by measuring the
       area of a unit circle.

       You will find it useful to have a procedure that returns a number chosen at
       random from a given range. The following @c(random-in-range) procedure
       implements this in terms of the @c(random) procedure used in @l(#1.2.6),
       which returns a nonnegative number less than its input.@n(136)

       ..src > scheme
         (define (random-in-range low high)
           (let ((range (- high low)))
             (+ low (random range))))
       < src..

    :: @t(Exercise 3.6) :: It is useful to be able to reset a random-number
       generator to produce a sequence starting from a given value.  Design a new
       @c(rand) procedure that is called with an argument that is either the
       symbol @c(generate) or the symbol @c(reset) and behaves as follows:
       @c[(rand 'generate)] produces a new random number; @c[((rand 'reset)
       ⟨new-value⟩)] resets the internal state variable to the designated
       @c[(new-value)]. Thus, by resetting the state, one can generate repeatable
       sequences. These are very handy to have when testing and debugging programs
       that use random numbers.

*** 3.1.3 <> The Costs of Introducing Assignment

    As we have seen, the @c(set!) operation enables us to model objects that have
    local state. However, this advantage comes at a price. Our programming
    language can no longer be interpreted in terms of the substitution model of
    procedure application that we introduced in @l(#1.1.5). Moreover, no simple
    model with @"(nice) mathematical properties can be an adequate framework for
    dealing with objects and assignment in programming languages.

    So long as we do not use assignments, two evaluations of the same procedure
    with the same arguments will produce the same result, so that procedures can
    be viewed as computing mathematical functions. Programming without any use of
    assignments, as we did throughout the first two chapters of this book, is
    accordingly known as @e(functional programming).

    To understand how assignment complicates matters, consider a simplified
    version of the @c(make-withdraw) procedure of @l(#3.1.1) that does not bother
    to check for an insufficient amount:

    ..srci > scheme
      > (define (make-simplified-withdraw balance)
      ^   (lambda (amount)
      ^     (set! balance (- balance amount))
      ^     balance))
      > (define W (make-simplified-withdraw 25))
      > (W 20)
      5
      > (W 10)
      -5
    < srci..

    Compare this procedure with the following @c(make-decrementer) procedure,
    which does not use @c(set!):

    ..src > scheme
      (define (make-decrementer balance)
        (lambda (amount)
          (- balance amount)))
    < src..

    @c(Make-decrementer) returns a procedure that subtracts its input from a
    designated amount @c(balance), but there is no accumulated effect over
    successive calls, as with @c(make-simplified-withdraw):

    ..srci > scheme
      > (define D (make-decrementer 25))
      > (D 20)
      5
      > (D 10)
      15
    < srci..

    We can use the substitution model to explain how @c(make-decrementer) works.
    For instance, let us analyze the evaluation of the expression

    ..src > scheme
      ((make-decrementer 25) 20)
    < src..

    We first simplify the operator of the combination by substituting 25 for
    @c(balance) in the body of @c(make-decrementer). This reduces the expression
    to

    ..src > scheme
      ((lambda (amount) (- 25 amount)) 20)
    < src..

    Now we apply the operator by substituting 20 for @c(amount) in the body of the
    @c(lambda) expression:

    ..src > scheme
      (- 25 20)
    < src..

    The final answer is 5.

    Observe, however, what happens if we attempt a similar substitution analysis
    with @c(make-simplified-withdraw):

    ..src > scheme
      ((make-simplified-withdraw 25) 20)
    < src..

    We first simplify the operator by substituting 25 for @c(balance) in the body
    of @c(make-simplified-withdraw). This reduces the expression to@n(137)

    ..src > scheme
      ((lambda (amount)
         (set! balance (- 25 amount)) 25)
       20)
    < src..

    Now we apply the operator by substituting 20 for @c(amount) in the body of the
    @c(lambda) expression:

    ..src > scheme
      (set! balance (- 25 20)) 25
    < src..

    If we adhered to the substitution model, we would have to say that the meaning
    of the procedure application is to first set @c(balance) to 5 and then return
    25 as the value of the expression. This gets the wrong answer. In order to get
    the correct answer, we would have to somehow distinguish the first occurrence
    of @c(balance) (before the effect of the @c(set!))  from the second occurrence
    of @c(balance) (after the effect of the @c(set!)), and the substitution model
    cannot do this.

    The trouble here is that substitution is based ultimately on the notion that
    the symbols in our language are essentially names for values. But as soon as
    we introduce @c(set!) and the idea that the value of a variable can change, a
    variable can no longer be simply a name. Now a variable somehow refers to a
    place where a value can be stored, and the value stored at this place can
    change. In @l(#3.2) we will see how environments play this role of @"(place)
    in our computational model.

**** Sameness and change

     The issue surfacing here is more profound than the mere breakdown of a
     particular model of computation. As soon as we introduce change into our
     computational models, many notions that were previously straightforward become
     problematical. Consider the concept of two things being @"(the same.)

     Suppose we call @c(make-decrementer) twice with the same argument to create
     two procedures:

     ..src > scheme
       (define D1 (make-decrementer 25))
       (define D2 (make-decrementer 25))
     < src..

     Are @c(D1) and @c(D2) the same?  An acceptable answer is yes, because @c(D1)
     and @c(D2) have the same computational behavior––each is a procedure that
     subtracts its input from 25. In fact, @c(D1) could be substituted for @c(D2)
     in any computation without changing the result.

     Contrast this with making two calls to @c(make-simplified-withdraw):

     ..src > scheme
       (define W1 (make-simplified-withdraw 25))
       (define W2 (make-simplified-withdraw 25))
     < src..

     Are @c(W1) and @c(W2) the same?  Surely not, because calls to @c(W1) and
     @c(W2) have distinct effects, as shown by the following sequence of
     interactions:

     ..srci > scheme
       > (W1 20)
       5
       > (W1 20)
       -15
       > (W2 20)
       5
     < srci..

     Even though @c(W1) and @c(W2) are @"(equal) in the sense that they are both
     created by evaluating the same expression, @c[(make-simplified-withdraw 25)],
     it is not true that @c(W1) could be substituted for @c(W2) in any expression
     without changing the result of evaluating the expression.

     A language that supports the concept that @"(equals can be substituted for
     equals) in an expression without changing the value of the expression is said
     to be @e(referentially transparent). Referential transparency is violated when
     we include @c(set!) in our computer language. This makes it tricky to
     determine when we can simplify expressions by substituting equivalent
     expressions. Consequently, reasoning about programs that use assignment
     becomes drastically more difficult.

     Once we forgo referential transparency, the notion of what it means for
     computational objects to be @"(the same) becomes difficult to capture in a
     formal way. Indeed, the meaning of @"(same) in the real world that our
     programs model is hardly clear in itself. In general, we can determine that
     two apparently identical objects are indeed @"(the same one) only by modifying
     one object and then observing whether the other object has changed in the same
     way. But how can we tell if an object has @"(changed) other than by observing
     the @"(same) object twice and seeing whether some property of the object
     differs from one observation to the next?  Thus, we cannot determine
     @"(change) without some @e(a priori) notion of @"(sameness,) and we cannot
     determine sameness without observing the effects of change.

     As an example of how this issue arises in programming, consider the situation
     where Peter and Paul have a bank account with $100 in it. There is a
     substantial difference between modeling this as

     ..src > scheme
       (define peter-acc (make-account 100))
       (define paul-acc (make-account 100))
     < src..

     and modeling it as

     ..src > scheme
       (define peter-acc (make-account 100))
       (define paul-acc peter-acc)
     < src..

     In the first situation, the two bank accounts are distinct. Transactions made
     by Peter will not affect Paul's account, and vice versa. In the second
     situation, however, we have defined @c(paul-acc) to be @e(the same thing) as
     @c(peter-acc). In effect, Peter and Paul now have a joint bank account, and if
     Peter makes a withdrawal from @c(peter-acc) Paul will observe less money in
     @c(paul-acc). These two similar but distinct situations can cause confusion in
     building computational models. With the shared account, in particular, it can
     be especially confusing that there is one object (the bank account) that has
     two different names (@c(peter-acc) and @c(paul-acc)); if we are searching for
     all the places in our program where @c(paul-acc) can be changed, we must
     remember to look also at things that change @c(peter-acc).@n(138)

     With reference to the above remarks on @"(sameness) and @"(change,) observe
     that if Peter and Paul could only examine their bank balances, and could not
     perform operations that changed the balance, then the issue of whether the two
     accounts are distinct would be moot. In general, so long as we never modify
     data objects, we can regard a compound data object to be precisely the
     totality of its pieces. For example, a rational number is determined by giving
     its numerator and its denominator. But this view is no longer valid in the
     presence of change, where a compound data object has an @"(identity) that is
     something different from the pieces of which it is composed. A bank account is
     still @"(the same) bank account even if we change the balance by making a
     withdrawal; conversely, we could have two different bank accounts with the
     same state information. This complication is a consequence, not of our
     programming language, but of our perception of a bank account as an object. We
     do not, for example, ordinarily regard a rational number as a changeable
     object with identity, such that we could change the numerator and still have
     @"(the same) rational number.

**** Pitfalls of imperative programming

     In contrast to functional programming, programming that makes extensive use of
     assignment is known as @e(imperative programming). In addition to raising
     complications about computational models, programs written in imperative style
     are susceptible to bugs that cannot occur in functional programs. For example,
     recall the iterative factorial program from @l(#1.2.1):

     ..src > scheme
       (define (factorial n)
         (define (iter product counter)
           (if (> counter n)
               product
               (iter (* counter product)
                     (+ counter 1))))
         (iter 1 1))
     < src..

     Instead of passing arguments in the internal iterative loop, we could adopt a
     more imperative style by using explicit assignment to update the values of the
     variables @c(product) and @c(counter):

     ..src > scheme
       (define (factorial n)
         (let ((product 1)
               (counter 1))
           (define (iter)
             (if (> counter n)
                 product
                 (begin (set! product (* counter
                                         product))
                        (set! counter (+ counter 1))
                        (iter))))
           (iter)))
     < src..

     This does not change the results produced by the program, but it does
     introduce a subtle trap. How do we decide the order of the assignments?  As it
     happens, the program is correct as written. But writing the assignments in the
     opposite order

     ..src > scheme
       (set! counter (+ counter 1))
       (set! product (* counter product))
     < src..

     would have produced a different, incorrect result. In general, programming
     with assignment forces us to carefully consider the relative orders of the
     assignments to make sure that each statement is using the correct version of
     the variables that have been changed. This issue simply does not arise in
     functional programs.@n(139)

     The complexity of imperative programs becomes even worse if we consider
     applications in which several processes execute concurrently. We will return
     to this in @l(#3.4). First, however, we will address the issue of providing a
     computational model for expressions that involve assignment, and explore the
     uses of objects with local state in designing simulations.

     :: @t(Exercise 3.7) :: Consider the bank account objects created by
        @c(make-account), with the password modification described in @l(#Exercise
        3.3). Suppose that our banking system requires the ability to make joint
        accounts. Define a procedure @c(make-joint) that accomplishes
        this. @c(Make-joint) should take three arguments. The first is a
        password-protected account. The second argument must match the password
        with which the account was defined in order for the @c(make-joint)
        operation to proceed. The third argument is a new password. @c(Make-joint)
        is to create an additional access to the original account using the new
        password. For example, if @c(peter-acc) is a bank account with password
        @c(open-sesame), then

        ..src > scheme
          (define paul-acc
            (make-joint peter-acc
                        'open-sesame
                        'rosebud))
        < src..

        will allow one to make transactions on @c(peter-acc) using the name
        @c(paul-acc) and the password @c(rosebud). You may wish to modify your
        solution to @l(#Exercise 3.3) to accommodate this new feature.

     :: @t(Exercise 3.8) :: When we defined the evaluation model in @l(#1.1.3), we
        said that the first step in evaluating an expression is to evaluate its
        subexpressions. But we never specified the order in which the
        subexpressions should be evaluated (e.g., left to right or right to
        left). When we introduce assignment, the order in which the arguments to a
        procedure are evaluated can make a difference to the result. Define a
        simple procedure @c(f) such that evaluating

        ..src > scheme
          (+ (f 0) (f 1))
        < src..

        will return 0 if the arguments to @c(+) are evaluated from left to right
        but will return 1 if the arguments are evaluated from right to left.

** 3.2 <> The Environment Model of Evaluation

   When we introduced compound procedures in @l(#Chapter 1), we used the
   substitution model of evaluation (@l(#1.1.5)) to define what is meant by
   applying a procedure to arguments:

   - To apply a compound procedure to arguments, evaluate the body of the
     procedure with each formal parameter replaced by the corresponding argument.

   Once we admit assignment into our programming language, such a definition is
   no longer adequate. In particular, @l(#3.1.3) argued that, in the presence of
   assignment, a variable can no longer be considered to be merely a name for a
   value. Rather, a variable must somehow designate a @"(place) in which values
   can be stored. In our new model of evaluation, these places will be maintained
   in structures called @e(environments).

   An environment is a sequence of @e(frames). Each frame is a table (possibly
   empty) of @e(bindings), which associate variable names with their
   corresponding values. (A single frame may contain at most one binding for any
   variable.)  Each frame also has a pointer to its @e(enclosing environment),
   unless, for the purposes of discussion, the frame is considered to be
   @e(global). The @e(value of a variable) with respect to an environment is the
   value given by the binding of the variable in the first frame in the
   environment that contains a binding for that variable. If no frame in the
   sequence specifies a binding for the variable, then the variable is said to be
   @e(unbound) in the environment.

   @l(#Figure 3.1) shows a simple environment structure consisting of three
   frames, labeled I, II, and III. In the diagram, A, B, C, and D are pointers to
   environments. C and D point to the same environment. The variables @c(z) and
   @c(x) are bound in frame II, while @c(y) and @c(x) are bound in frame I. The
   value of @c(x) in environment D is 3. The value of @c(x) with respect to
   environment B is also 3. This is determined as follows: We examine the first
   frame in the sequence (frame III) and do not find a binding for @c(x), so we
   proceed to the enclosing environment D and find the binding in frame I. On the
   other hand, the value of @c(x) in environment A is 7, because the first frame
   in the sequence (frame II) contains a binding of @c(x) to 7. With respect to
   environment A, the binding of @c(x) to 7 in frame II is said to @e(shadow) the
   binding of @c(x) to 3 in frame I.

   ..figure > @t(Figure 3.1) A simple environment structure.

     ..art >
                  ╭────────╮
                  │      I │
                  │ x: 3   │
                  │ y: 5   │
                  ╰────────╯
                     ▲  ▲
                     │  │
                   C │  │ D
       ╭─────────╮   │  │   ╭─────────╮
       │      II │   │  │   │     III │
       │ z: 6    ├───╯  ╰───┤ m: 1    │
       │ x: 7    │          │ y: 2    │
       ╰─────────╯          ╰─────────╯
     < art..

@  ..img > img/chap3/Fig3.1b.std.svg

   The environment is crucial to the evaluation process, because it determines
   the context in which an expression should be evaluated. Indeed, one could say
   that expressions in a programming language do not, in themselves, have any
   meaning.  Rather, an expression acquires a meaning only with respect to some
   environment in which it is evaluated. Even the interpretation of an expression
   as straightforward as @c[(+ 1 1)] depends on an understanding that one is
   operating in a context in which @c(+) is the symbol for addition. Thus, in our
   model of evaluation we will always speak of evaluating an expression with
   respect to some environment. To describe interactions with the interpreter, we
   will suppose that there is a global environment, consisting of a single frame
   (with no enclosing environment) that includes values for the symbols
   associated with the primitive procedures. For example, the idea that @c(+) is
   the symbol for addition is captured by saying that the symbol @c(+) is bound
   in the global environment to the primitive addition procedure.

*** 3.2.1 <> The Rules for Evaluation

    The overall specification of how the interpreter evaluates a combination
    remains the same as when we first introduced it in @l(#1.1.3):

    - To evaluate a combination:

      1. Evaluate the subexpressions of the combination.@n(140)

      2. Apply the value of the operator subexpression to the values of the operand
         subexpressions.

    The environment model of evaluation replaces the substitution model in
    specifying what it means to apply a compound procedure to arguments.

    In the environment model of evaluation, a procedure is always a pair
    consisting of some code and a pointer to an environment. Procedures are
    created in one way only: by evaluating a λ-expression. This produces a
    procedure whose code is obtained from the text of the λ-expression and whose
    environment is the environment in which the λ-expression was evaluated to
    produce the procedure. For example, consider the procedure definition

    ..src > scheme
      (define (square x)
        (* x x))
    < src..

    evaluated in the global environment. The procedure definition syntax is just
    syntactic sugar for an underlying implicit λ-expression. It would have been
    equivalent to have used

    ..src > scheme
      (define square
        (lambda (x) (* x x)))
    < src..

    which evaluates @c[(lambda (x) (* x x))] and binds @c(square) to the resulting
    value, all in the global environment.

    @l(#Figure 3.2) shows the result of evaluating this @c(define) expression.
    The procedure object is a pair whose code specifies that the procedure has one
    formal parameter, namely @c(x), and a procedure body @c[(* x x)]. The
    environment part of the procedure is a pointer to the global environment,
    since that is the environment in which the λ-expression was evaluated to
    produce the procedure. A new binding, which associates the procedure object
    with the symbol @c(square), has been added to the global frame. In general,
    @c(define) creates definitions by adding bindings to frames.

    ..figure > @t(Figure 3.2) Environment structure produced by evaluating
      @c[(define (square x) (* x x))] in the global environment.

      ..art >
                   ╭──────────────────────╮
                   │ other variables      │
        global ───▶│                      │
        env        │ square: ──╮          │
                   ╰───────────┼──────────╯
                               │       ▲
        (define (square x)     │       │
          (* x x))             ▼       │
                           .───.───.   │
                           │ ◆ │ ◆ ┼───╯
                           `─┼─^───'
                             │
                             ▼
                           parameters: x
                           body: (* x x)
      < art..

@   ..img > img/chap3/Fig3.2b.std.svg

    Now that we have seen how procedures are created, we can describe how
    procedures are applied. The environment model specifies: To apply a procedure
    to arguments, create a new environment containing a frame that binds the
    parameters to the values of the arguments. The enclosing environment of this
    frame is the environment specified by the procedure. Now, within this new
    environment, evaluate the procedure body.

    To show how this rule is followed, @l(#Figure 3.3) illustrates the environment
    structure created by evaluating the expression @c[(square 5)] in the global
    environment, where @c(square) is the procedure generated in @l(#Figure 3.2).
    Applying the procedure results in the creation of a new environment, labeled
    E1 in the figure, that begins with a frame in which @c(x), the formal
    parameter for the procedure, is bound to the argument 5. The pointer leading
    upward from this frame shows that the frame's enclosing environment is the
    global environment. The global environment is chosen here, because this is the
    environment that is indicated as part of the @c(square) procedure
    object. Within E1, we evaluate the body of the procedure, @c[(* x x)].  Since
    the value of @c(x) in E1 is 5, the result is @c[(* 5 5)], or 25.

    ..figure > @t(Figure 3.3) Environment created by evaluating @c[(square 5)]
      in the global environment.

      ..art >
                   ╭─────────────────────────────────────────╮
                   │ other variables                         │
        global ───▶│                                         │
        env        │ square: ──╮                             │
                   ╰───────────┼─────────────────────────────╯
                               │       ▲              ▲
        (square 5)             │       │              │
                               ▼       │              │
                           .───.───.   │           ╭──┴────╮
                           │ ◆ │ ◆ ┼───╯   E1 ────▶│ x: 5  │
                           `─┼─^───'               ╰───────╯
                             │
                             ▼
                          parameters: x
                          body: (* x x)
      < art..

@   ..img > img/chap3/Fig3.3b.std.svg

    The environment model of procedure application can be summarized by two rules:

    - A procedure object is applied to a set of arguments by constructing a frame,
      binding the formal parameters of the procedure to the arguments of the call,
      and then evaluating the body of the procedure in the context of the new
      environment constructed. The new frame has as its enclosing environment the
      environment part of the procedure object being applied.

    - A procedure is created by evaluating a λ-expression relative to a given
      environment. The resulting procedure object is a pair consisting of the text
      of the λ-expression and a pointer to the environment in which the procedure
      was created.


    We also specify that defining a symbol using @c(define) creates a binding in
    the current environment frame and assigns to the symbol the indicated
    value.@n(141) Finally, we specify the behavior of @c(set!), the operation that
    forced us to introduce the environment model in the first place. Evaluating
    the expression @c[(set! ⟨variable⟩ ⟨value⟩)] in some environment locates the
    binding of the variable in the environment and changes that binding to
    indicate the new value. That is, one finds the first frame in the environment
    that contains a binding for the variable and modifies that frame. If the
    variable is unbound in the environment, then @c(set!) signals an error.

    These evaluation rules, though considerably more complex than the substitution
    model, are still reasonably straightforward. Moreover, the evaluation model,
    though abstract, provides a correct description of how the interpreter
    evaluates expressions. In @l(#Chapter 4) we shall see how this model can serve
    as a blueprint for implementing a working interpreter. The following sections
    elaborate the details of the model by analyzing some illustrative programs.

*** 3.2.2 <> Applying Simple Procedures

    When we introduced the substitution model in @l(#1.1.5) we showed how the
    combination @c[(f 5)] evaluates to 136, given the following procedure
    definitions:

    ..src > scheme
      (define (square x)
        (* x x))
      (define (sum-of-squares x y)
        (+ (square x) (square y)))
      (define (f a)
        (sum-of-squares (+ a 1) (* a 2)))
    < src..

    We can analyze the same example using the environment model. @l(#Figure 3.4)
    shows the three procedure objects created by evaluating the definitions of
    @c(f), @c(square), and @c(sum-of-squares) in the global environment.  Each
    procedure object consists of some code, together with a pointer to the global
    environment.

    ..figure > @t(Figure 3.4) Procedure objects in the global frame.

      ..art >
               ╭───────────────────────────────────────────────╮
        global │ sum-of-squares: ──────────────────────╮       │
        env    │ square: ───────────────╮              │       │
           ───▶│ f: ─────╮              │              │       │
               ╰─────────┼──────────────┼──────────────┼───────╯
                         │     ▲        │     ▲        │     ▲
                         │     │        │     │        │     │
                         ▼     │        ▼     │        ▼     │
                     .───.───. │    .───.───. │    .───.───. │
                     │ ◆ │ ◆ ┼─╯    │ ◆ │ ◆ ┼─╯    │ ◆ │ ◆ ┼─╯
                     `─┼─^───'      `─┼─^───'      `─┼─^───'
                       │              │              │
                       ▼              ▼              ▼
         parameters: a            parameters: x    parameters: x, y
         body: (sum-of-squares    body: (* x x)    body: (+ (square x)
                 (+ a 1)                                    (square y))
                 (* a 2))
      < art..

@     ..img > img/chap3/Fig3.4b.std.svg

    In @l(#Figure 3.5) we see the environment structure created by evaluating the
    expression @c[(f 5)]. The call to @c(f) creates a new environment E1 beginning
    with a frame in which @c(a), the formal parameter of @c(f), is bound to the
    argument 5. In E1, we evaluate the body of @c(f):

    ..src > scheme
      (sum-of-squares (+ a 1) (* a 2))
    < src..

    ..figure > @t(Figure 3.5) Environments created by evaluating @c[(f 5)] using
      the procedures in @l(#Figure 3.4).

      ..art >
                  ╭─────────────────────────────────────────────────────╮
        global ──▶│                                                     │
        env       ╰─────────────────────────────────────────────────────╯
                    ▲              ▲                ▲               ▲
        (f 5)       |              |                |               |
                ╭──────╮       ╭───────╮        ╭──────╮        ╭───────╮
          E1 ──▶│ a: 5 │  E2 ─▶│ x: 6  │  E3 ──▶│ x: 6 │  E4 ──▶│ x: 10 │
                │      │       │ y: 10 │        │      │        │       │
                ╰──────╯       ╰───────╯        ╰──────╯        ╰───────╯
           (sum-of-squares   (+ (square x)       (* x x)         (* x x)
             (+ a 1)            (square u))
             (+ a 2))
      < art..

@     ..img > img/chap3/Fig3.5b.std.svg

    To evaluate this combination, we first evaluate the subexpressions. The first
    subexpression, @c(sum-of-squares), has a value that is a procedure object.
    (Notice how this value is found: We first look in the first frame of E1, which
    contains no binding for @c(sum-of-squares). Then we proceed to the enclosing
    environment, i.e. the global environment, and find the binding shown in
    @l(#Figure 3.4).)  The other two subexpressions are evaluated by applying the
    primitive operations @c(+) and @c(*) to evaluate the two combinations @c[(+ a
    1)] and @c[(* a 2)] to obtain 6 and 10, respectively.

    Now we apply the procedure object @c(sum-of-squares) to the arguments 6 and
    10. This results in a new environment E2 in which the formal parameters
    @c(x) and @c(y) are bound to the arguments. Within E2 we evaluate the
    combination @c[(+ (square x) (square y))]. This leads us to evaluate
    @c[(square x)], where @c(square) is found in the global frame and @c(x)
    is 6. Once again, we set up a new environment, E3, in which @c(x) is bound to
    6, and within this we evaluate the body of @c(square), which is @c[(* x
    x)]. Also as part of applying @c(sum-of-squares), we must evaluate the
    subexpression @c[(square y)], where @c(y) is 10. This second call to
    @c(square) creates another environment, E4, in which @c(x), the formal
    parameter of @c(square), is bound to 10. And within E4 we must evaluate @c[(*
    x x)].

    The important point to observe is that each call to @c(square) creates a new
    environment containing a binding for @c(x). We can see here how the different
    frames serve to keep separate the different local variables all named
    @c(x). Notice that each frame created by @c(square) points to the global
    environment, since this is the environment indicated by the @c(square)
    procedure object.

    After the subexpressions are evaluated, the results are returned. The values
    generated by the two calls to @c(square) are added by @c(sum-of-squares), and
    this result is returned by @c(f). Since our focus here is on the environment
    structures, we will not dwell on how these returned values are passed from
    call to call; however, this is also an important aspect of the evaluation
    process, and we will return to it in detail in @l(#Chapter 5).

    :: @t(Exercise 3.9) :: In @l(#1.2.1) we used the substitution model to analyze
       two procedures for computing factorials, a recursive version

       ..src > scheme
         (define (factorial n)
           (if (= n 1)
               1
               (* n (factorial (- n 1)))))
       < src..

       and an iterative version

       ..src > scheme
         (define (factorial n)
           (fact-iter 1 1 n))

         (define (fact-iter product
                            counter
                            max-count)
           (if (> counter max-count)
               product
               (fact-iter (* counter product)
                          (+ counter 1)
                          max-count)))
       < src..

       Show the environment structures created by evaluating @c[(factorial 6)]
       using each version of the @c(factorial) procedure.@n(142)

*** 3.2.3 <> Frames as the Repository of Local State

    We can turn to the environment model to see how procedures and assignment can
    be used to represent objects with local state. As an example, consider the
    @"(withdrawal processor) from @l(#3.1.1) created by calling the procedure

    ..src > scheme
      (define (make-withdraw balance)
        (lambda (amount)
          (if (>= balance amount)
              (begin (set! balance
                           (- balance amount))
                     balance)
              "Insufficient funds")))
    < src..

    Let us describe the evaluation of

    ..src > scheme
      (define W1 (make-withdraw 100))
    < src..

    followed by

    ..srci > scheme
      > (W1 50)
      50
    < srci..

    @l(#Figure 3.6) shows the result of defining the @c(make-withdraw) procedure
    in the global environment. This produces a procedure object that contains a
    pointer to the global environment. So far, this is no different from the
    examples we have already seen, except that the body of the procedure is itself
    a λ-expression.

    ..figure > @t(Figure 3.6) Result of defining @c(make-withdraw) in the global
      environment.

      ..art >
                   ╭─────────────────────────────╮
        global ───▶│ make-withdraw:   ──╮        │
        env        ╰────────────────────┼────────╯
                                        │     ▲
                                        │     │
                                        ▼     │
                                    .───.───. │
                                    │ ◆ │ ◆ ┼─╯
                                    `─┼─^───'
                                      │
            parameters: balance       ▼
            body: (lambda (amount)
                    (if (>= balance amount)
                        (begin (set! balance
                                     (- balance amount))
                               balance)
                        "Insufficient funds"))
      < art..

@   ..img > img/chap3/Fig3.6c.std.svg

    The interesting part of the computation happens when we apply the procedure
    @c(make-withdraw) to an argument:

    ..src > scheme
      (define W1 (make-withdraw 100))
    < src..

    We begin, as usual, by setting up an environment E1 in which the formal
    parameter @c(balance) is bound to the argument 100. Within this environment,
    we evaluate the body of @c(make-withdraw), namely the λ-expression. This
    constructs a new procedure object, whose code is as specified by the
    @c(lambda) and whose environment is E1, the environment in which the
    @c(lambda) was evaluated to produce the procedure.  The resulting procedure
    object is the value returned by the call to @c(make-withdraw). This is bound
    to @c(W1) in the global environment, since the @c(define) itself is being
    evaluated in the global environment.  @l(#Figure 3.7) shows the resulting
    environment structure.

    ..figure > @t(Figure 3.7) Result of evaluating @c[(define W1 (make-withdraw 100))].

      ..art >
               ╭────────────────────────────────────────────────╮
        global │ make-withdraw: ─────────────────────────────╮  │
        env    │                                             │  │
           ───▶│ W1: ─╮                                      │  │
               ╰──────┼──────────────────────────────────────┼──╯
                      │                 ▲                    │
                      │                 |                    │
                      │          ╭──────────────╮  .───.───. │
                      │    E1 ──▶│ balance: 100 │  │ ◆ │ ◆ ┼─╯
                      │          ╰──────────────╯  `─┼─^───'
                      ▼                 │            │
                  .───.───.             │            ▼
                  │ ◆ │ ◆ ┼─────────────╯     parameters: balance
                  `─┼─^───'                   body: ...
                    │
                    ▼
            parameters: amount
            body: (if (>= balance amount)
                      (begin (set! balance (- balance amount))
                             balance)
                      "Insufficient funds")
      < art..

@     ..img > img/chap3/Fig3.7b.std.svg

    Now we can analyze what happens when @c(W1) is applied to an argument:

    ..srci > scheme
      > (W1 50)
      50
    < srci..

    We begin by constructing a frame in which @c(amount), the formal parameter of
    @c(W1), is bound to the argument 50. The crucial point to observe is that this
    frame has as its enclosing environment not the global environment, but rather
    the environment E1, because this is the environment that is specified by the
    @c(W1) procedure object. Within this new environment, we evaluate the body of
    the procedure:

    ..src > scheme
      (if (>= balance amount)
          (begin (set! balance (- balance amount))
                 balance)
          "Insufficient funds")
    < src..

    The resulting environment structure is shown in @l(#Figure 3.8). The
    expression being evaluated references both @c(amount) and @c(balance).
    @c(Amount) will be found in the first frame in the environment, while
    @c(balance) will be found by following the enclosing-environment pointer to
    E1.

    ..figure > @t(Figure 3.8) Environments created by applying the procedure object @c(W1).

      ..art >
               ╭──────────────────────────────────────╮
        global │ make-withdraw: ...                   │
        env    │                                      │
           ───▶│ W1: ─╮                               │
               ╰──────┼───────────────────────────────╯
                      │                 ▲
                      │                 |
                      │          ╭──────────────╮ Here is the balance
                      │    E1 ──▶│ balance: 100 │ that will be changed
                      │          ╰──────────────╯ by the set!.
                      ▼             │       ▲
                  .───.───.         │       |
                  │ ◆ │ ◆ ┼─────────╯    ╭────────────╮
                  `─┼─^───'              │ amount: 50 │
                    │                    ╰────────────╯
                    ▼
              parameters: amount   (if (>= balance amount)
              body: ...                (begin (set! balance
                                                    (- balance amount))
                                              balance)
                                       "Insufficient funds")
      < art..

@     ..img > img/chap3/Fig3.8c.std.svg

    When the @c(set!) is executed, the binding of @c(balance) in E1 is changed. At
    the completion of the call to @c(W1), @c(balance) is 50, and the frame that
    contains @c(balance) is still pointed to by the procedure object @c(W1). The
    frame that binds @c(amount) (in which we executed the code that changed
    @c(balance)) is no longer relevant, since the procedure call that constructed
    it has terminated, and there are no pointers to that frame from other parts of
    the environment. The next time @c(W1) is called, this will build a new frame
    that binds @c(amount) and whose enclosing environment is E1. We see that E1
    serves as the @"(place) that holds the local state variable for the procedure
    object @c(W1). @l(#Figure 3.9) shows the situation after the call to @c(W1).

    ..figure > @t(Figure 3.9) Environments after the call to @c(W1).

      ..art >
               ╭──────────────────────────────────────╮
        global │ make-withdraw: ...                   │
        env    │                                      │
           ───▶│ W1: ─────╮                           │
               ╰──────────┼───────────────────────────╯
                          │                 ▲
                          │                 |
                          │          ╭─────────────╮
                          │    E1 ──▶│ balance: 50 │
                          │          ╰─────────────╯
                          ▼                 │
                      .───.───.             │
                      │ ◆ │ ◆ ┼─────────────╯
                      `─┼─^───'
                        │
                        ▼
                  parameters: amount
                  body: ...
      < art..

@     ..img > img/chap3/Fig3.9b.std.svg

    Observe what happens when we create a second @"(withdraw) object by making
    another call to @c(make-withdraw):

    ..src > scheme
      (define W2 (make-withdraw 100))
    < src..

    This produces the environment structure of @l(#Figure 3.10), which shows that
    @c(W2) is a procedure object, that is, a pair with some code and an
    environment. The environment E2 for @c(W2) was created by the call to
    @c(make-withdraw). It contains a frame with its own local binding for
    @c(balance). On the other hand, @c(W1) and @c(W2) have the same code: the code
    specified by the λ-expression in the body of @c(make-withdraw).@n(143) We see
    here why @c(W1) and @c(W2) behave as independent objects. Calls to @c(W1)
    reference the state variable @c(balance) stored in E1, whereas calls to @c(W2)
    reference the @c(balance) stored in E2. Thus, changes to the local state of
    one object do not affect the other object.

    ..figure > @t(Figure 3.10) Using @c[(define W2 (make-withdraw 100))] to create
      a second object.

      ..art >
                 ╭─────────────────────────────────────────────────╮
                 │ make-withdraw: ...                              │
        global ─▶│ W2: ───────────────────────────╮                │
        env      │ W1:  ─╮                        │                │
                 ╰───────┼────────────────────────┼────────────────╯
                         │              ▲         │              ▲
                         │              |         │              |
                         │       ╭─────────────╮  │       ╭──────────────╮
                         │  E1 ─▶│ balance: 50 │  │  E2 ─▶│ balance: 100 │
                         │       ╰─────────────╯  │       ╰──────────────╯
                         ▼              ▲         ▼              ▲
                     .───.───.          │     .───.───.          │
                     │ ◆ │ ◆ ┼──────────╯     │ ◆ │ ◆ ┼──────────╯
                     `─┼─^───'                `─┼─^───'
                       │ ╭──────────────────────╯
                       ▼ ▼
                parameters: amount
                body: ...
      < art..

@     ..img > img/chap3/Fig3.10b.std.svg

    :: @t(Exercise 3.10) :: In the @c(make-withdraw) procedure, the local variable
       @c(balance) is created as a parameter of @c(make-withdraw). We could also
       create the local state variable explicitly, using @c(let), as follows:

       ..src > scheme
         (define (make-withdraw initial-amount)
           (let ((balance initial-amount))
             (lambda (amount)
               (if (>= balance amount)
                   (begin (set! balance
                                (- balance amount))
                          balance)
                   "Insufficient funds"))))
       < src..

       Recall from @l(#1.3.2) that @c(let) is simply syntactic sugar for a
       procedure call:

       ..src > scheme
         (let ((⟨var⟩ ⟨exp⟩)) ⟨body⟩)
       < src..

       is interpreted as an alternate syntax for

       ..src > scheme
         ((lambda (⟨var⟩) ⟨body⟩) ⟨exp⟩)
       < src..

       Use the environment model to analyze this alternate version of
       @c(make-withdraw), drawing figures like the ones above to illustrate the
       interactions

       ..src > scheme
         (define W1 (make-withdraw 100))
         (W1 50)
         (define W2 (make-withdraw 100))
       < src..

       Show that the two versions of @c(make-withdraw) create objects with the
       same behavior. How do the environment structures differ for the two
       versions?

*** 3.2.4 <> Internal Definitions

    Section @l(#1.1.8) introduced the idea that procedures can have internal
    definitions, thus leading to a block structure as in the following procedure
    to compute square roots:

    ..src > scheme
      (define (sqrt x)
        (define (good-enough? guess)
          (< (abs (- (square guess) x)) 0.001))
        (define (improve guess)
          (average guess (/ x guess)))
        (define (sqrt-iter guess)
          (if (good-enough? guess)
              guess
              (sqrt-iter (improve guess))))
        (sqrt-iter 1.0))
    < src..

    Now we can use the environment model to see why these internal definitions
    behave as desired. @l(#Figure 3.11) shows the point in the evaluation of the
    expression @c[(sqrt 2)] where the internal procedure @c(good-enough?) has been
    called for the first time with @c(guess) equal to 1.

    ..figure > @t(Figure 3.11) @c(Sqrt) procedure with internal definitions.

      ..art >
                  ╭──────────────────────────────────────────────────╮
        global ──▶│ sqrt: ──╮                                        │
        env       │         │                                        │
                  ╰─────────┼────────────────────────────────────────╯
                            ▼       ▲                   ▲
                        .───.───.   │                   │
             ╭──────────│ ◆ │ ◆ ┼───╯        ╭──────────┴────────────╮
             │          `───^───'            │ x: 2                  │
             ▼                         E1 ──▶│ good-enough?: ─╮      │
        parameters: x                        │ improve: ...   │      │
        body: (define good-enough? ...)      │ sqrt-iter: ... │      │
              (define improve ...)           ╰────────────────┼──────╯
              (define sqrt-iter ...)          ▲  ▲            │     ▲
              (sqrt-iter 1.0)                 │  │            ▼     │
                                    ╭─────────┴╮ │        .───.───. │
                              E2 ──▶│ guess: 1 │ │        │ ◆ │ ◆ ┼─╯
                                    ╰──────────╯ │        `─┼─^───'
                              call to sqrt─iter  │          │
                                                 │          ▼
                                       ╭─────────┴╮    parameters: guess
                                 E3 ──▶│ guess: 1 │    body: (< (abs ...)
                                       ╰──────────╯             ...)
                                 call to good-enough?
      < art..

@     ..img > img/chap3/Fig3.11b.std.svg

    Observe the structure of the environment. @c(Sqrt) is a symbol in the global
    environment that is bound to a procedure object whose associated environment
    is the global environment. When @c(sqrt) was called, a new environment E1 was
    formed, subordinate to the global environment, in which the parameter @c(x) is
    bound to 2. The body of @c(sqrt) was then evaluated in E1. Since the first
    expression in the body of @c(sqrt) is

    ..src > scheme
      (define (good-enough? guess)
        (< (abs (- (square guess) x)) 0.001))
    < src..

    evaluating this expression defined the procedure @c(good-enough?)  in the
    environment E1. To be more precise, the symbol @c(good-enough?) was added to
    the first frame of E1, bound to a procedure object whose associated
    environment is E1. Similarly, @c(improve) and @c(sqrt-iter) were defined as
    procedures in E1. For conciseness, @l(#Figure 3.11) shows only the procedure
    object for @c(good-enough?).

    After the local procedures were defined, the expression @c[(sqrt-iter 1.0)]
    was evaluated, still in environment E1. So the procedure object bound to
    @c(sqrt-iter) in E1 was called with 1 as an argument. This created an
    environment E2 in which @c(guess), the parameter of @c(sqrt-iter), is bound
    to 1. @c(Sqrt-iter) in turn called @c(good-enough?) with the value of
    @c(guess) (from E2) as the argument for @c(good-enough?). This set up another
    environment, E3, in which @c(guess) (the parameter of @c(good-enough?)) is
    bound to 1. Although @c(sqrt-iter) and @c(good-enough?) both have a parameter
    named @c(guess), these are two distinct local variables located in different
    frames. Also, E2 and E3 both have E1 as their enclosing environment, because
    the @c(sqrt-iter) and @c(good-enough?) procedures both have E1 as their
    environment part. One consequence of this is that the symbol @c(x) that
    appears in the body of @c(good-enough?) will reference the binding of @c(x)
    that appears in E1, namely the value of @c(x) with which the original @c(sqrt)
    procedure was called.

    The environment model thus explains the two key properties that make local
    procedure definitions a useful technique for modularizing programs:

    - The names of the local procedures do not interfere with names external to
      the enclosing procedure, because the local procedure names will be bound in
      the frame that the procedure creates when it is run, rather than being bound
      in the global environment.

    - The local procedures can access the arguments of the enclosing procedure,
      simply by using parameter names as free variables. This is because the body
      of the local procedure is evaluated in an environment that is subordinate to
      the evaluation environment for the enclosing procedure.


    :: @t(Exercise 3.11) :: In @l(#3.2.3) we saw how the environment model
       described the behavior of procedures with local state.  Now we have seen
       how internal definitions work. A typical message-passing procedure contains
       both of these aspects. Consider the bank account procedure of @l(#3.1.1):

       ..src > scheme
         (define (make-account balance)
           (define (withdraw amount)
             (if (>= balance amount)
                 (begin (set! balance
                              (- balance
                                 amount))
                        balance)
                 "Insufficient funds"))
           (define (deposit amount)
             (set! balance (+ balance amount))
             balance)
           (define (dispatch m)
             (cond ((eq? m 'withdraw) withdraw)
                   ((eq? m 'deposit) deposit)
                   (else (error "Unknown request:
                                 MAKE-ACCOUNT"
                                m))))
           dispatch)
       < src..

       Show the environment structure generated by the sequence of interactions

       ..srci > scheme
         > (define acc (make-account 50))
         > ((acc 'deposit) 40)
         90
         > ((acc 'withdraw) 60)
         30
       < srci..

       Where is the local state for @c(acc) kept?  Suppose we define another
       account

       ..src > scheme
         (define acc2 (make-account 100))
       < src..

       How are the local states for the two accounts kept distinct?  Which parts
       of the environment structure are shared between @c(acc) and @c(acc2)?

** 3.3 <> Modeling with Mutable Data

   @l(#Chapter 2) dealt with compound data as a means for constructing
   computational objects that have several parts, in order to model real-world
   objects that have several aspects. In that chapter we introduced the
   discipline of data abstraction, according to which data structures are
   specified in terms of constructors, which create data objects, and selectors,
   which access the parts of compound data objects. But we now know that there is
   another aspect of data that chapter 2 did not address. The desire to model
   systems composed of objects that have changing state leads us to the need to
   modify compound data objects, as well as to construct and select from them. In
   order to model compound objects with changing state, we will design data
   abstractions to include, in addition to selectors and constructors, operations
   called @e(mutators), which modify data objects. For instance, modeling a
   banking system requires us to change account balances. Thus, a data structure
   for representing bank accounts might admit an operation

   ..src > scheme
     (set-balance! ⟨account⟩ ⟨new-value⟩)
   < src..

   that changes the balance of the designated account to the designated new
   value.  Data objects for which mutators are defined are known as @e(mutable
   data objects).

   Chapter 2 introduced pairs as a general-purpose @"(glue) for synthesizing
   compound data. We begin this section by defining basic mutators for pairs, so
   that pairs can serve as building blocks for constructing mutable data objects.
   These mutators greatly enhance the representational power of pairs, enabling
   us to build data structures other than the sequences and trees that we worked
   with in @l(#2.2). We also present some examples of simulations in which
   complex systems are modeled as collections of objects with local state.

*** 3.3.1 <> Mutable List Structure

    The basic operations on pairs––@c(cons), @c(car), and @c(cdr)––can be used to
    construct list structure and to select parts from list structure, but they are
    incapable of modifying list structure. The same is true of the list operations
    we have used so far, such as @c(append) and @c(list), since these can be
    defined in terms of @c(cons), @c(car), and @c(cdr).  To modify list structures
    we need new operations.

    The primitive mutators for pairs are @c(set-car!) and
    @c(set-cdr!). @c(Set-car!) takes two arguments, the first of which must be a
    pair. It modifies this pair, replacing the @c(car) pointer by a pointer to the
    second argument of @c(set-car!).@n(144)

    As an example, suppose that @c(x) is bound to the list @c[((a b) c d)] and
    @c(y) to the list @c[(e f)] as illustrated in @l(#Figure 3.12).  Evaluating
    the expression @c[(set-car!  x y)] modifies the pair to which @c(x) is bound,
    replacing its @c(car) by the value of @c(y). The result of the operation is
    shown in @l(#Figure 3.13). The structure @c(x) has been modified and would now
    be printed as @c[((e f) c d)]. The pairs representing the list @c[(a b)],
    identified by the pointer that was replaced, are now detached from the
    original structure.@n(145)

    ..figure > @t(Figure 3.12) Lists @c(x): @c[((a b) c d)] and @c(y): @c[(e f)].

      ..art >
             ╭───┬───╮     ╭───┬───╮     ╭───┬───╮
        x ──▶│ ◆ │ ◆ ┼────▶│ ◆ │ ◆ ┼────▶│ ◆ │ ╱ │
             ╰─┼─┴───╯     ╰─┼─┴───╯     ╰─┼─┴───╯
               │             ▼             ▼
               │           ╭───╮         ╭───╮
               │           │ c │         │ d │
               │           ╰───╯         ╰───╯
               │           ╭───┬───╮     ╭───┬───╮
               ╰──────────▶│ ◆ │ ◆ ┼────▶│ ◆ │ ╱ │
                           ╰─┼─┴───╯     ╰─┼─┴───╯
                             ▼             ▼
                           ╭───╮         ╭───╮
                           │ a │         │ b │
                           ╰───╯         ╰───╯
                           ╭───┬───╮     ╭───┬───╮
                      y ──▶│ ◆ │ ◆ ┼────▶│ ◆ │ ╱ │
                           ╰─┼─┴───╯     ╰─┼─┴───╯
                             ▼             ▼
                           ╭───╮         ╭───╮
                           │ e │         │ f │
                           ╰───╯         ╰───╯
      < art..

@   ..img > img/chap3/Fig3.12b.std.svg

    ..figure > @t(Figure 3.13) Effect of @c[(set-car! x y)] on the lists in
      @l(#Figure 3.12).

      ..art >
             ╭───┬───╮     ╭───┬───╮     ╭───┬───╮
        x ──▶│ ◆ │ ◆ ┼────▶│ ◆ │ ◆ ┼────▶│ ◆ │ ╱ │
             ╰─┼─┴───╯     ╰─┼─┴───╯     ╰─┼─┴───╯
               │             ▼             ▼
               │           ╭───╮         ╭───╮
               │           │ c │         │ d │
               │           ╰───╯         ╰───╯
               │           ╭───┬───╮     ╭───┬───╮
               │           │ ◆ │ ◆ ┼────▶│ ◆ │ ╱ │
               │           ╰─┼─┴───╯     ╰─┼─┴───╯
               │             ▼             ▼
               │           ╭───╮         ╭───╮
               │           │ a │         │ b │
               │           ╰───╯         ╰───╯
               ╰──────────▶╭───┬───╮     ╭───┬───╮
                      y ──▶│ ◆ │ ◆ ┼────▶│ ◆ │ ╱ │
                           ╰─┼─┴───╯     ╰─┼─┴───╯
                             ▼             ▼
                           ╭───╮         ╭───╮
                           │ e │         │ f │
                           ╰───╯         ╰───╯
      < art..

@   ..img > img/chap3/Fig3.13b.std.svg

    Compare @l(#Figure 3.13) with @l(#Figure 3.14), which illustrates the result
    of executing @c[(define z (cons y (cdr x)))] with @c(x) and @c(y) bound to the
    original lists of @l(#Figure 3.12). The variable @c(z) is now bound to a new
    pair created by the @c(cons) operation; the list to which @c(x) is bound is
    unchanged.

    ..figure > @t(Figure 3.14) Effect of @c[(define z (cons y (cdr x)))] on the
      lists in @l(#Figure 3.12).

      ..art >
             ╭───┬───╮     ╭───┬───╮     ╭───┬───╮
        x ──▶│ ◆ │ ◆ ┼────▶│ ◆ │ ◆ ┼────▶│ ◆ │ ╱ │
             ╰─┼─┴───╯ ╭──▶╰─┼─┴───╯     ╰─┼─┴───╯
               │       │     ▼             ▼
               │       │   ╭───╮         ╭───╮
               │       │   │ c │         │ d │
               │       │   ╰───╯         ╰───╯
               │       │   ╭───┬───╮     ╭───┬───╮
               ╰───────┼──▶│ ◆ │ ◆ ┼────▶│ ◆ │ ╱ │
                       │   ╰─┼─┴───╯     ╰─┼─┴───╯
                       │     ▼             ▼
             ╭───┬───╮ │   ╭───╮         ╭───╮
        z ──▶│ ◆ │ ◆ ┼─╯   │ a │         │ b │
             ╰─┼─┴───╯     ╰───╯         ╰───╯
               ╰──────────▶╭───┬───╮     ╭───┬───╮
                      y ──▶│ ◆ │ ◆ ┼────▶│ ◆ │ ╱ │
                           ╰─┼─┴───╯     ╰─┼─┴───╯
                             ▼             ▼
                           ╭───╮         ╭───╮
                           │ e │         │ f │
                           ╰───╯         ╰───╯
      < art..

@   ..img > img/chap3/Fig3.14b.std.svg

    The @c(set-cdr!) operation is similar to @c(set-car!). The only difference is
    that the @c(cdr) pointer of the pair, rather than the @c(car) pointer, is
    replaced. The effect of executing @c[(set-cdr! x y)] on the lists of
    @l(#Figure 3.12) is shown in @l(#Figure 3.15). Here the @c(cdr) pointer of
    @c(x) has been replaced by the pointer to @c[(e f)]. Also, the list @c[(c d)],
    which used to be the @c(cdr) of @c(x), is now detached from the structure.

    ..figure > @t(Figure 3.15) Effect of @c[(set-cdr! x y)] on the lists in
      @l(#Figure 3.12).

      ..art >
             ╭───┬───╮     ╭───┬───╮     ╭───┬───╮
        x ──▶│ ◆ │ ◆ │     │ ◆ │ ◆ ┼────▶│ ◆ │ ╱ │
             ╰─┼─┴─┼─╯     ╰─┼─┴───╯     ╰─┼─┴───╯
               │   │         ▼             ▼
               │   │       ╭───╮         ╭───╮
               │   │       │ c │         │ d │
               │   │       ╰───╯         ╰───╯
               │   │       ╭───┬───╮     ╭───┬───╮
               ╰───┼──────▶│ ◆ │ ◆ ┼────▶│ ◆ │ ╱ │
                   │       ╰─┼─┴───╯     ╰─┼─┴───╯
                   │         ▼             ▼
                   │       ╭───╮         ╭───╮
                   │       │ a │         │ b │
                   │       ╰───╯         ╰───╯
                   ╰──────▶╭───┬───╮     ╭───┬───╮
                      y ──▶│ ◆ │ ◆ ┼────▶│ ◆ │ ╱ │
                           ╰─┼─┴───╯     ╰─┼─┴───╯
                             ▼             ▼
                           ╭───╮         ╭───╮
                           │ e │         │ f │
                           ╰───╯         ╰───╯
      < art..

@   ..img > img/chap3/Fig3.15b.std.svg

    @c(Cons) builds new list structure by creating new pairs, while @c(set-car!)
    and @c(set-cdr!) modify existing pairs. Indeed, we could implement @c(cons) in
    terms of the two mutators, together with a procedure @c(get-new-pair), which
    returns a new pair that is not part of any existing list structure. We obtain
    the new pair, set its @c(car) and @c(cdr) pointers to the designated objects,
    and return the new pair as the result of the @c(cons).@n(146)

    ..src > scheme
      (define (cons x y)
        (let ((new (get-new-pair)))
          (set-car! new x)
          (set-cdr! new y)
          new))
    < src..

    :: @t(Exercise 3.12) :: The following procedure for appending lists was
       introduced in @l(#2.2.1):

       ..src > scheme
         (define (append x y)
           (if (null? x)
               y
               (cons (car x) (append (cdr x) y))))
       < src..

       @c(Append) forms a new list by successively @c(cons)ing the elements of
       @c(x) onto @c(y). The procedure @c(append!) is similar to @c(append), but
       it is a mutator rather than a constructor. It appends the lists by splicing
       them together, modifying the final pair of @c(x) so that its @c(cdr) is now
       @c(y). (It is an error to call @c(append!) with an empty @c(x).)

       ..src > scheme
         (define (append! x y)
           (set-cdr! (last-pair x) y)
           x)
       < src..

       Here @c(last-pair) is a procedure that returns the last pair in its
       argument:

       ..src > scheme
         (define (last-pair x)
           (if (null? (cdr x))
               x
               (last-pair (cdr x))))
       < src..

       Consider the interaction

       ..srci > scheme
         > (define x (list 'a 'b))
         > (define y (list 'c 'd))
         > (define z (append x y))
         > z
         (a b c d)
         > (cdr x)
         > ⟨response⟩
         > (define w (append! x y))
         > w
         (a b c d)
         > (cdr x)
         > ⟨response⟩
       < srci..

       What are the missing @c[(response)]s?  Draw box-and-pointer diagrams to
       explain your answer.

    :: @t(Exercise 3.13) :: Consider the following @c(make-cycle) procedure, which
       uses the @c(last-pair) procedure defined in @l(#Exercise 3.12):

       ..src > scheme
         (define (make-cycle x)
           (set-cdr! (last-pair x) x)
           x)
       < src..

       Draw a box-and-pointer diagram that shows the structure @c(z) created by

       ..src > scheme
         (define z (make-cycle (list 'a 'b 'c)))
       < src..

       What happens if we try to compute @c[(last-pair z)]?

    :: @t(Exercise 3.14) :: The following procedure is quite useful, although
       obscure:

       ..src > scheme
         (define (mystery x)
           (define (loop x y)
             (if (null? x)
                 y
                 (let ((temp (cdr x)))
                   (set-cdr! x y)
                   (loop temp x))))
           (loop x '()))
       < src..

       @c(Loop) uses the @"(temporary) variable @c(temp) to hold the old value of
       the @c(cdr) of @c(x), since the @c(set-cdr!)  on the next line destroys the
       @c(cdr). Explain what @c(mystery) does in general. Suppose @c(v) is defined
       by @c[(define v (list 'a 'b 'c 'd))]. Draw the box-and-pointer diagram that
       represents the list to which @c(v) is bound.  Suppose that we now evaluate
       @c[(define w (mystery v))]. Draw box-and-pointer diagrams that show the
       structures @c(v) and @c(w) after evaluating this expression. What would be
       printed as the values of @c(v) and @c(w)?

**** Sharing and identity

     We mentioned in @l(#3.1.3) the theoretical issues of @"(sameness) and
     @"(change) raised by the introduction of assignment. These issues arise in
     practice when individual pairs are @e(shared) among different data
     objects. For example, consider the structure formed by

     ..src > scheme
       (define x (list 'a 'b))
       (define z1 (cons x x))
     < src..

     As shown in @l(#Figure 3.16), @c(z1) is a pair whose @c(car) and @c(cdr) both
     point to the same pair @c(x). This sharing of @c(x) by the @c(car) and @c(cdr)
     of @c(z1) is a consequence of the straightforward way in which @c(cons) is
     implemented. In general, using @c(cons) to construct lists will result in an
     interlinked structure of pairs in which many individual pairs are shared by
     many different structures.

     ..figure > @t(Figure 3.16) The list @c(z1) formed by @c[(cons x x)].

       ..art >
               ╭───┬───╮
         z1 ──▶│ ◆ │ ◆ │
               ╰─┼─┴─┼─╯
                 │   │
                 ▼   ▼
               ╭───┬───╮     ╭───┬───╮
          x ──▶│ ◆ │ ◆ ┼────▶│ ◆ │ ╱ │
               ╰─┼─┴───╯     ╰─┼─┴───╯
                 ▼             ▼
               ╭───╮         ╭───╮
               │ a │         │ b │
               ╰───╯         ╰───╯
       < art..

@    ..img > img/chap3/Fig3.16b.std.svg

     In contrast to @l(#Figure 3.16), @l(#Figure 3.17) shows the structure created
     by

     ..src > scheme
       (define z2
         (cons (list 'a 'b) (list 'a 'b)))
     < src..

     ..figure > @t(Figure 3.17) The list @c(z2) formed by
       @c[(cons (list 'a 'b) (list 'a 'b))].

       ..art >
               ╭───┬───╮     ╭───┬───╮     ╭───┬───╮
         z2 ──▶│ ◆ │ ◆ ┼────▶│ ◆ │ ◆ ┼────▶│ ◆ │ ╱ │
               ╰─┼─┴───╯     ╰─┼─┴───╯     ╰─┼─┴───╯
                 │             ▼             ▼
                 │           ╭───╮         ╭───╮
                 │           │ a │         │ b │
                 │           ╰───╯         ╰───╯
                 │             ▲             ▲
                 │           ╭─┼─┬───╮     ╭─┼─┬───╮
                 ╰──────────▶│ ◆ │ ◆ ┼────▶│ ◆ │ ╱ │
                             ╰───┴───╯     ╰───┴───╯
       < art..

@    ..img > img/chap3/Fig3.17b.std.svg

     In this structure, the pairs in the two @c[(a b)] lists are distinct, although
     the actual symbols are shared.@n(147)

     When thought of as a list, @c(z1) and @c(z2) both represent @"(the same) list,
     @c[((a b) a b)]. In general, sharing is completely undetectable if we operate
     on lists using only @c(cons), @c(car), and @c(cdr). However, if we allow
     mutators on list structure, sharing becomes significant. As an example of the
     difference that sharing can make, consider the following procedure, which
     modifies the @c(car) of the structure to which it is applied:

     ..src > scheme
       (define (set-to-wow! x)
         (set-car! (car x) 'wow)
         x)
     < src..

     Even though @c(z1) and @c(z2) are @"(the same) structure, applying
     @c(set-to-wow!) to them yields different results. With @c(z1), altering the
     @c(car) also changes the @c(cdr), because in @c(z1) the @c(car) and the
     @c(cdr) are the same pair. With @c(z2), the @c(car) and @c(cdr) are distinct,
     so @c(set-to-wow!) modifies only the @c(car):

     ..srci > scheme
       > z1
       ((a b) a b)
       > (set-to-wow! z1)
       ((wow b) wow b)
       > z2
       ((a b) a b)
       > (set-to-wow! z2)
       ((wow b) a b)
     < srci..

     One way to detect sharing in list structures is to use the predicate @c(eq?),
     which we introduced in @l(#2.3.1) as a way to test whether two symbols are
     equal. More generally, @c[(eq?  x y)] tests whether @c(x) and @c(y) are the
     same object (that is, whether @c(x) and @c(y) are equal as pointers). Thus,
     with @c(z1) and @c(z2) as defined in @l(#Figure 3.16) and @l(#Figure 3.17),
     @c[(eq?  (car z1) (cdr z1))] is true and @c[(eq? (car z2) (cdr z2))] is false.

     As will be seen in the following sections, we can exploit sharing to greatly
     extend the repertoire of data structures that can be represented by pairs. On
     the other hand, sharing can also be dangerous, since modifications made to
     structures will also affect other structures that happen to share the modified
     parts. The mutation operations @c(set-car!) and @c(set-cdr!) should be used
     with care; unless we have a good understanding of how our data objects are
     shared, mutation can have unanticipated results.@n(148)

     :: @t(Exercise 3.15) :: Draw box-and-pointer diagrams to explain the effect of
        @c(set-to-wow!) on the structures @c(z1) and @c(z2) above.

     :: @t(Exercise 3.16) :: Ben Bitdiddle decides to write a procedure to count
        the number of pairs in any list structure. @"(It's easy,) he
        reasons. @"(The number of pairs in any structure is the number in the
        @c(car) plus the number in the @c(cdr) plus one more to count the current
        pair.)  So Ben writes the following procedure:

        ..src > scheme
          (define (count-pairs x)
            (if (not (pair? x))
                0
                (+ (count-pairs (car x))
                   (count-pairs (cdr x))
                   1)))
        < src..

        Show that this procedure is not correct. In particular, draw
        box-and-pointer diagrams representing list structures made up of exactly
        three pairs for which Ben's procedure would return 3; return 4; return 7;
        never return at all.

     :: @t(Exercise 3.17) :: Devise a correct version of the @c(count-pairs)
        procedure of @l(#Exercise 3.16) that returns the number of distinct pairs
        in any structure. (Hint: Traverse the structure, maintaining an auxiliary
        data structure that is used to keep track of which pairs have already been
        counted.)

     :: @t(Exercise 3.18) :: Write a procedure that examines a list and determines
        whether it contains a cycle, that is, whether a program that tried to find
        the end of the list by taking successive @c(cdr)s would go into an infinite
        loop. @l(#Exercise 3.13) constructed such lists.

     :: @t(Exercise 3.19) :: Redo @l(#Exercise 3.18) using an algorithm that takes
        only a constant amount of space. (This requires a very clever idea.)

**** Mutation is just assignment

     When we introduced compound data, we observed in @l(#2.1.3) that pairs can be
     represented purely in terms of procedures:

     ..src > scheme
       (define (cons x y)
         (define (dispatch m)
           (cond ((eq? m 'car) x)
                 ((eq? m 'cdr) y)
                 (else (error "Undefined
                        operation: CONS" m))))
         dispatch)

       (define (car z) (z 'car))
       (define (cdr z) (z 'cdr))
     < src..

     The same observation is true for mutable data. We can implement mutable data
     objects as procedures using assignment and local state. For instance, we can
     extend the above pair implementation to handle @c(set-car!) and @c(set-cdr!)
     in a manner analogous to the way we implemented bank accounts using
     @c(make-account) in @l(#3.1.1):

     ..src > scheme
       (define (cons x y)
         (define (set-x! v) (set! x v))
         (define (set-y! v) (set! y v))
         (define (dispatch m)
           (cond ((eq? m 'car) x)
                 ((eq? m 'cdr) y)
                 ((eq? m 'set-car!) set-x!)
                 ((eq? m 'set-cdr!) set-y!)
                 (else (error "Undefined
                        operation: CONS" m))))
         dispatch)

       (define (car z) (z 'car))
       (define (cdr z) (z 'cdr))

       (define (set-car! z new-value)
         ((z 'set-car!) new-value)
         z)

       (define (set-cdr! z new-value)
         ((z 'set-cdr!) new-value)
         z)
     < src..

     Assignment is all that is needed, theoretically, to account for the behavior
     of mutable data. As soon as we admit @c(set!) to our language, we raise all
     the issues, not only of assignment, but of mutable data in general.@n(149)

     :: @t(Exercise 3.20) :: Draw environment diagrams to illustrate the evaluation
        of the sequence of expressions

        ..srci > scheme
          > (define x (cons 1 2))
          > (define z (cons x x))
          > (set-car! (cdr z) 17)
          > (car x)
          17
        < srci..

        using the procedural implementation of pairs given above. (Compare
        @l(#Exercise 3.11).)

*** 3.3.2 <> Representing Queues

    The mutators @c(set-car!) and @c(set-cdr!) enable us to use pairs to construct
    data structures that cannot be built with @c(cons), @c(car), and @c(cdr)
    alone. This section shows how to use pairs to represent a data structure
    called a queue. Section @l(#3.3.3) will show how to represent data structures
    called tables.

    A @e(queue) is a sequence in which items are inserted at one end (called the
    @e(rear) of the queue) and deleted from the other end (the
    @e(front)). @l(#Figure 3.18) shows an initially empty queue in which the items
    @c(a) and @c(b) are inserted. Then @c(a) is removed, @c(c) and @c(d) are
    inserted, and @c(b) is removed. Because items are always removed in the order
    in which they are inserted, a queue is sometimes called a @e(FIFO) (first in,
    first out) buffer.

    ..figure > @t(Figure 3.18) Queue operations.

      ..art >
        Operation                Resulting Queue
        (define q (make-queue))
        (insert-queue! q 'a)     a
        (insert-queue! q 'b)     a b
        (delete-queue! q)        b
        (insert-queue! q 'c)     b c
        (insert-queue! q 'd)     b c d
        (delete-queue! q)        c d
      < art..

@   ..img > img/chap3/Fig3.18.std.svg

    In terms of data abstraction, we can regard a queue as defined by the
    following set of operations:

    - a constructor: @c[(make-queue)] returns an empty queue (a queue containing
      no items).

    - two selectors:

      ..src > scheme
        (empty-queue? ⟨queue⟩)
      < src..

      tests if the queue is empty.

      ..src > scheme
        (front-queue ⟨queue⟩)
      < src..

      returns the object at the front of the queue, signaling an error if the
      queue is empty; it does not modify the queue.

    - two mutators:

      ..src > scheme
        (insert-queue! ⟨queue⟩ ⟨item⟩)
      < src..

      inserts the item at the rear of the queue and returns the modified queue as
      its value.

      ..src > scheme
        (delete-queue! ⟨queue⟩)
      < src..

      removes the item at the front of the queue and returns the modified queue as
      its value, signaling an error if the queue is empty before the deletion.


    Because a queue is a sequence of items, we could certainly represent it as an
    ordinary list; the front of the queue would be the @c(car) of the list,
    inserting an item in the queue would amount to appending a new element at the
    end of the list, and deleting an item from the queue would just be taking the
    @c(cdr) of the list. However, this representation is inefficient, because in
    order to insert an item we must scan the list until we reach the end. Since
    the only method we have for scanning a list is by successive @c(cdr)
    operations, this scanning requires @m[Θ(n)] steps for a list of @m(n) items. A
    simple modification to the list representation overcomes this disadvantage by
    allowing the queue operations to be implemented so that they require @m[Θ(1)]
    steps; that is, so that the number of steps needed is independent of the
    length of the queue.

    The difficulty with the list representation arises from the need to scan to
    find the end of the list. The reason we need to scan is that, although the
    standard way of representing a list as a chain of pairs readily provides us
    with a pointer to the beginning of the list, it gives us no easily accessible
    pointer to the end. The modification that avoids the drawback is to represent
    the queue as a list, together with an additional pointer that indicates the
    final pair in the list. That way, when we go to insert an item, we can consult
    the rear pointer and so avoid scanning the list.

    A queue is represented, then, as a pair of pointers, @c(front-ptr) and
    @c(rear-ptr), which indicate, respectively, the first and last pairs in an
    ordinary list. Since we would like the queue to be an identifiable object, we
    can use @c(cons) to combine the two pointers. Thus, the queue itself will be
    the @c(cons) of the two pointers. @l(#Figure 3.19) illustrates this
    representation.

    ..figure > @t(Figure 3.19) Implementation of a queue as a list with front and
      rear pointers.

      ..art >
             ╭───┬───╮
        q ──▶│ ◆ │ ◆ ┼─────────────────────╮
             ╰─┼─┴───╯                     │
               │                           │
               │ front-ptr                 │ rear-ptr
               │                           │
               ▼                           ▼
             ╭───┬───╮     ╭───┬───╮     ╭───┬───╮
             │ ◆ │ ◆ ┼────▶│ ◆ │ ◆ ┼────▶│ ◆ │ ╱ │
             ╰─┼─┴───╯     ╰─┼─┴───╯     ╰─┼─┴───╯
               │             │             │
               ▼             ▼             ▼
             ╭───╮         ╭───╮         ╭───╮
             │ a │         │ b │         │ c │
             ╰───╯         ╰───╯         ╰───╯
      < art..

@   ..img > img/chap3/Fig3.19b.std.svg

    To define the queue operations we use the following procedures, which enable
    us to select and to modify the front and rear pointers of a queue:

    ..src > scheme
      (define (front-ptr queue) (car queue))
      (define (rear-ptr queue) (cdr queue))
      (define (set-front-ptr! queue item)
        (set-car! queue item))
      (define (set-rear-ptr! queue item)
        (set-cdr! queue item))
    < src..

    Now we can implement the actual queue operations. We will consider a queue to
    be empty if its front pointer is the empty list:

    ..src > scheme
      (define (empty-queue? queue)
        (null? (front-ptr queue)))
    < src..

    The @c(make-queue) constructor returns, as an initially empty queue, a pair
    whose @c(car) and @c(cdr) are both the empty list:

    ..src > scheme
      (define (make-queue) (cons '() '()))
    < src..

    To select the item at the front of the queue, we return the @c(car) of the
    pair indicated by the front pointer:

    ..src > scheme
      (define (front-queue queue)
        (if (empty-queue? queue)
            (error "FRONT called with an
                    empty queue" queue)
            (car (front-ptr queue))))
    < src..

    To insert an item in a queue, we follow the method whose result is indicated
    in @l(#Figure 3.20). We first create a new pair whose @c(car) is the item to
    be inserted and whose @c(cdr) is the empty list. If the queue was initially
    empty, we set the front and rear pointers of the queue to this new pair.
    Otherwise, we modify the final pair in the queue to point to the new pair, and
    also set the rear pointer to the new pair.

    ..figure > @t(Figure 3.20) Result of using @c[(insert-queue! q 'd)] on the
      queue of @l(#Figure 3.19).

      ..art >
             ╭───┬───╮
        q ──▶│ ◆ │ ◆ ┼─────────────────────────────────╮
             ╰─┼─┴───╯                                 │
               │                                       │
               │ front-ptr                             │ rear-ptr
               │                                       │
               ▼                                       ▼
           ╭───┬───╮     ╭───┬───╮     ╭───┬───╮     ╭───┬───╮
           │ ◆ │ ◆ ┼────▶│ ◆ │ ◆ ┼────▶│ ◆ │ ◆ ┼────▶│ ◆ │ ╱ │
           ╰─┼─┴───╯     ╰─┼─┴───╯     ╰─┼─┴───╯     ╰─┼─┴───╯
             │             │             │             │
             ▼             ▼             ▼             ▼
           ╭───╮         ╭───╮         ╭───╮         ╭───╮
           │ a │         │ b │         │ c │         │ d │
           ╰───╯         ╰───╯         ╰───╯         ╰───╯
      < art..

@   ..img > img/chap3/Fig3.20c.std.svg

    ..src > scheme
      (define (insert-queue! queue item)
        (let ((new-pair (cons item '())))
          (cond ((empty-queue? queue)
                 (set-front-ptr! queue new-pair)
                 (set-rear-ptr! queue new-pair)
                 queue)
                (else (set-cdr! (rear-ptr queue)
                                new-pair)
                      (set-rear-ptr! queue new-pair)
                      queue))))
    < src..

    To delete the item at the front of the queue, we merely modify the front
    pointer so that it now points at the second item in the queue, which can be
    found by following the @c(cdr) pointer of the first item (see @l(#Figure
    3.21)):@n(150)

    ..src > scheme
      (define (delete-queue! queue)
        (cond ((empty-queue? queue)
               (error "DELETE! called with
                       an empty queue" queue))
              (else (set-front-ptr!
                     queue
                     (cdr (front-ptr queue)))
                    queue)))
    < src..

    ..figure > @t(Figure 3.21) Result of using @c[(delete-queue!  q)] on the queue
      of @l(#Figure 3.20).

      ..art >
             ╭───┬───╮
        q ──▶│ ◆ │ ◆ ┼───────────────────────────────────╮
             ╰─┼─┴───╯                                   │
               │                                         │
               │ front-ptr                               │ rear-ptr
               ╰─────────────╮                           │
                             ▼                           ▼
             ╭───┬───╮     ╭───┬───╮     ╭───┬───╮     ╭───┬───╮
             │ ◆ │ ◆ ┼────▶│ ◆ │ ◆ ┼────▶│ ◆ │ ◆ ┼────▶│ ◆ │ ╱ │
             ╰─┼─┴───╯     ╰─┼─┴───╯     ╰─┼─┴───╯     ╰─┼─┴───╯
               │             │             │             │
               ▼             ▼             ▼             ▼
             ╭───╮         ╭───╮         ╭───╮         ╭───╮
             │ a │         │ b │         │ c │         │ d │
             ╰───╯         ╰───╯         ╰───╯         ╰───╯
      < art..

@   ..img > img/chap3/Fig3.21c.std.svg

    :: @t(Exercise 3.21) :: Ben Bitdiddle decides to test the queue implementation
       described above. He types in the procedures to the Lisp interpreter and
       proceeds to try them out:

       ..srci > scheme
         > (define q1 (make-queue))
         > (insert-queue! q1 'a)
         ((a) a)
         > (insert-queue! q1 'b)
         ((a b) b)
         > (delete-queue! q1)
         ((b) b)
         > (delete-queue! q1)
         (() b)
       < srci..

       @"(It's all wrong!) he complains. @"(The interpreter's response shows that
       the last item is inserted into the queue twice. And when I delete both
       items, the second @c(b) is still there, so the queue isn't empty, even
       though it's supposed to be.)  Eva Lu Ator suggests that Ben has
       misunderstood what is happening. @"(It's not that the items are going into
       the queue twice,) she explains. @"(It's just that the standard Lisp printer
       doesn't know how to make sense of the queue representation. If you want to
       see the queue printed correctly, you'll have to define your own print
       procedure for queues.) Explain what Eva Lu is talking about. In particular,
       show why Ben's examples produce the printed results that they do. Define a
       procedure @c(print-queue) that takes a queue as input and prints the
       sequence of items in the queue.

    :: @t(Exercise 3.22) :: Instead of representing a queue as a pair of pointers,
       we can build a queue as a procedure with local state.  The local state will
       consist of pointers to the beginning and the end of an ordinary list. Thus,
       the @c(make-queue) procedure will have the form

       ..src > scheme
         (define (make-queue)
           (let ((front-ptr … )
                 (rear-ptr … ))
             ⟨definitions of internal procedures⟩
             (define (dispatch m) …)
             dispatch))
       < src..

       Complete the definition of @c(make-queue) and provide implementations of
       the queue operations using this representation.

    :: @t(Exercise 3.23) :: A @e(deque) (@"(double-ended queue)) is a sequence in
       which items can be inserted and deleted at either the front or the
       rear. Operations on deques are the constructor @c(make-deque), the
       predicate @c(empty-deque?), selectors @c(front-deque) and @c(rear-deque),
       and mutators @c(front-insert-deque!), @c(rear-insert-deque!),
       @c(front-delete-deque!), @c(rear-delete-deque!). Show how to represent
       deques using pairs, and give implementations of the operations.@n(151) All
       operations should be accomplished in @m[Θ(1)] steps.

*** 3.3.3 <> Representing Tables

    When we studied various ways of representing sets in @l(#Chapter 2), we
    mentioned in @l(#2.3.3) the task of maintaining a table of records indexed by
    identifying keys. In the implementation of data-directed programming in
    @l(#2.4.3), we made extensive use of two-dimensional tables, in which
    information is stored and retrieved using two keys. Here we see how to build
    tables as mutable list structures.

    We first consider a one-dimensional table, in which each value is stored under
    a single key. We implement the table as a list of records, each of which is
    implemented as a pair consisting of a key and the associated value. The
    records are glued together to form a list by pairs whose @c(car)s point to
    successive records. These gluing pairs are called the @e(backbone) of the
    table. In order to have a place that we can change when we add a new record to
    the table, we build the table as a @e(headed list). A headed list has a
    special backbone pair at the beginning, which holds a dummy @"(record)––in
    this case the arbitrarily chosen symbol @c(*table*).  @l(#Figure 3.22) shows
    the box-and-pointer diagram for the table

    ..src > scheme
      a:  1
      b:  2
      c:  3
    < src..

    ..figure > @t(Figure 3.22) A table represented as a headed list.

      ..art >
          table
            ╷
            │
            ▼
        ╭───┬───╮     ╭───┬───╮     ╭───┬───╮     ╭───┬───╮
        │ ◆ │ ◆ ┼────▶│ ◆ │ ◆ ┼────▶│ ◆ │ ◆ ┼────▶│ ◆ │ ╱ │
        ╰─┼─┴───╯     ╰─┼─┴───╯     ╰─┼─┴───╯     ╰─┼─┴───╯
          │             │             │             │
          ▼             ▼             ▼             ▼
        ┌─────────┐   ╭───┬───╮     ╭───┬───╮     ╭───┬───╮
        │ *table* │   │ ◆ │ ◆ ┼────▶│ ◆ │ ◆ ┼────▶│ ◆ │ ◆ │
        └─────────┘   ╰─┼─┴─┼─╯     ╰─┼─┴─┼─╯     ╰─┼─┴─┼─╯
                        │   │         │   │         │   │
                        ▼   ▼         ▼   ▼         ▼   ▼
                     ╭───╮ ╭───╮   ╭───╮ ╭───╮   ╭───╮ ╭───╮
                     │ a │ │ 1 │   │ b │ │ 2 │   │ c │ │ 3 │
                     ╰───╯ ╰───╯   ╰───╯ ╰───╯   ╰───╯ ╰───╯
      < art..

@   ..img > img/chap3/Fig3.22c.std.svg

    To extract information from a table we use the @c(lookup) procedure, which
    takes a key as argument and returns the associated value (or false if there is
    no value stored under that key). @c(Lookup) is defined in terms of the
    @c(assoc) operation, which expects a key and a list of records as arguments.
    Note that @c(assoc) never sees the dummy record. @c(Assoc) returns the record
    that has the given key as its @c(car).@n(152) @c(Lookup) then checks to see
    that the resulting record returned by @c(assoc) is not false, and returns the
    value (the @c(cdr)) of the record.

    ..src > scheme
      (define (lookup key table)
        (let ((record (assoc key (cdr table))))
          (if record
              (cdr record)
              false)))

      (define (assoc key records)
        (cond ((null? records) false)
              ((equal? key (caar records))
               (car records))
              (else (assoc key (cdr records)))))
    < src..

    To insert a value in a table under a specified key, we first use @c(assoc) to
    see if there is already a record in the table with this key. If not, we form a
    new record by @c(cons)ing the key with the value, and insert this at the head
    of the table's list of records, after the dummy record. If there already is a
    record with this key, we set the @c(cdr) of this record to the designated new
    value. The header of the table provides us with a fixed location to modify in
    order to insert the new record.@n(153)

    ..src > scheme
      (define (insert! key value table)
        (let ((record (assoc key (cdr table))))
          (if record
              (set-cdr! record value)
              (set-cdr! table
                        (cons (cons key value)
                              (cdr table)))))
        'ok)
    < src..

    To construct a new table, we simply create a list containing the symbol
    @c(*table*):

    ..src > scheme
      (define (make-table)
        (list '*table*))
    < src..

**** Two-dimensional tables

     In a two-dimensional table, each value is indexed by two keys. We can
     construct such a table as a one-dimensional table in which each key identifies
     a subtable. @l(#Figure 3.23) shows the box-and-pointer diagram for the table

     ..example >
       math:  +: 43    letters:  a: 97
              -: 45              b: 98
              *: 42
     < example..

     which has two subtables. (The subtables don't need a special header symbol,
     since the key that identifies the subtable serves this purpose.)

     ..figure > @t(Figure 3.23) A two-dimensional table.

       ..art >
         table
           ╷
           │
           ▼
         ╭───┬───╮     ╭───┬───╮     ╭───┬───╮
         │ ◆ │ ◆ ┼────▶│ ◆ │ ◆ ┼────▶│ ◆ │ ╱ │
         ╰─┼─┴───╯     ╰─┼─┴───╯     ╰─┼─┴───╯
           ▼             │             ▼
         ┌─────────┐     │           ╭───┬───╮     ╭───┬───╮     ╭───┬───╮
         │ *table* │     │           │ ◆ │ ◆ ┼────▶│ ◆ │ ◆ ┼────▶│ ◆ │ ╱ │
         └─────────┘     │           ╰─┼─┴───╯     ╰─┼─┴───╯     ╰─┼─┴───╯
                         │             ▼             ▼             ▼
                         │           ┌───────────┐ ╭───┬───╮     ╭───┬───╮
                         │           │ *letters* │ │ ◆ │ ◆ │     │ ◆ │ ◆ │
                         │           └───────────┘ ╰─┼─┴─┼─╯     ╰─┼─┴─┼─╯
                         │                           ▼   ▼         ▼   ▼
                         │                        ╭───╮╭────╮   ╭───╮╭────╮
                         │                        │ a ││ 97 │   │ b ││ 99 │
                         ▼                        ╰───╯╰────╯   ╰───╯╰────╯
                       ╭───┬───╮     ╭───┬───╮     ╭───┬───╮     ╭───┬───╮
                       │ ◆ │ ◆ ┼────▶│ ◆ │ ◆ ┼────▶│ ◆ │ ◆ ┼────▶│ ◆ │ ╱ │
                       ╰─┼─┴───╯     ╰─┼─┴───╯     ╰─┼─┴───╯     ╰─┼─┴───╯
                         ▼             ▼             ▼             ▼
                       ┌────────┐    ╭───┬───╮     ╭───┬───╮     ╭───┬───╮
                       │ *math* │    │ ◆ │ ◆ │     │ ◆ │ ◆ │     │ ◆ │ ◆ │
                       └────────┘    ╰─┼─┴─┼─╯     ╰─┼─┴─┼─╯     ╰─┼─┴─┼─╯
                                       ▼   ▼         ▼   ▼         ▼   ▼
                                    ╭───╮╭────╮   ╭───╮╭────╮   ╭───╮╭────╮
                                    │ + ││ 43 │   │ - ││ 45 │   │ * ││ 42 │
                                    ╰───╯╰────╯   ╰───╯╰────╯   ╰───╯╰────╯
       < art..

@    ..img > img/chap3/Fig3.23b.std.svg

     When we look up an item, we use the first key to identify the correct
     subtable.  Then we use the second key to identify the record within the
     subtable.

     ..src > scheme
       (define (lookup key-1 key-2 table)
         (let ((subtable (assoc key-1 (cdr table))))
           (if subtable
               (let ((record
                      (assoc key-2 (cdr subtable))))
                 (if record (cdr record) false))
               false)))
     < src..

     To insert a new item under a pair of keys, we use @c(assoc) to see if there is
     a subtable stored under the first key. If not, we build a new subtable
     containing the single record (@c(key-2), @c(value)) and insert it into the
     table under the first key. If a subtable already exists for the first key, we
     insert the new record into this subtable, using the insertion method for
     one-dimensional tables described above:

     ..src > scheme
       (define (insert! key-1 key-2 value table)
         (let ((subtable (assoc key-1 (cdr table))))
           (if subtable
               (let ((record
                      (assoc key-2 (cdr subtable))))
                 (if record
                     (set-cdr! record value)
                     (set-cdr!
                      subtable
                      (cons (cons key-2 value)
                            (cdr subtable)))))
               (set-cdr!
                table
                (cons (list key-1 (cons key-2 value))
                      (cdr table)))))
         'ok)
     < src..

**** Creating local tables

     The @c(lookup) and @c(insert!) operations defined above take the table as an
     argument. This enables us to use programs that access more than one table.
     Another way to deal with multiple tables is to have separate @c(lookup) and
     @c(insert!) procedures for each table. We can do this by representing a table
     procedurally, as an object that maintains an internal table as part of its
     local state. When sent an appropriate message, this @"(table object) supplies
     the procedure with which to operate on the internal table. Here is a generator
     for two-dimensional tables represented in this fashion:

     ..src > scheme
       (define (make-table)
         (let ((local-table (list '*table*)))
           (define (lookup key-1 key-2)
             (let ((subtable
                    (assoc key-1 (cdr local-table))))
               (if subtable
                   (let ((record
                          (assoc key-2
                                 (cdr subtable))))
                     (if record (cdr record) false))
                   false)))
           (define (insert! key-1 key-2 value)
             (let ((subtable
                    (assoc key-1 (cdr local-table))))
               (if subtable
                   (let ((record
                          (assoc key-2
                                 (cdr subtable))))
                     (if record
                         (set-cdr! record value)
                         (set-cdr!
                          subtable
                          (cons (cons key-2 value)
                                (cdr subtable)))))
                   (set-cdr!
                    local-table
                    (cons (list key-1
                                (cons key-2 value))
                          (cdr local-table)))))
             'ok)
           (define (dispatch m)
             (cond ((eq? m 'lookup-proc) lookup)
                   ((eq? m 'insert-proc!) insert!)
                   (else (error "Unknown operation:
                                 TABLE" m))))
           dispatch))
     < src..

     Using @c(make-table), we could implement the @c(get) and @c(put) operations
     used in @l(#2.4.3) for data-directed programming, as follows:

     ..src > scheme
       (define operation-table (make-table))
       (define get (operation-table 'lookup-proc))
       (define put (operation-table 'insert-proc!))
     < src..

     @c(Get) takes as arguments two keys, and @c(put) takes as arguments two keys
     and a value. Both operations access the same local table, which is
     encapsulated within the object created by the call to @c(make-table).

     :: @t(Exercise 3.24) :: In the table implementations above, the keys are
        tested for equality using @c(equal?) (called by @c(assoc)). This is not
        always the appropriate test. For instance, we might have a table with
        numeric keys in which we don't need an exact match to the number we're
        looking up, but only a number within some tolerance of it.  Design a table
        constructor @c(make-table) that takes as an argument a @c(same-key?)
        procedure that will be used to test @"(equality) of keys.  @c(Make-table)
        should return a @c(dispatch) procedure that can be used to access
        appropriate @c(lookup) and @c(insert!) procedures for a local table.

     :: @t(Exercise 3.25) :: Generalizing one- and two-dimensional tables, show how
        to implement a table in which values are stored under an arbitrary number
        of keys and different values may be stored under different numbers of
        keys. The @c(lookup) and @c(insert!)  procedures should take as input a
        list of keys used to access the table.

     :: @t(Exercise 3.26) :: To search a table as implemented above, one needs to
        scan through the list of records. This is basically the unordered list
        representation of @l(#2.3.3). For large tables, it may be more efficient to
        structure the table in a different manner. Describe a table implementation
        where the (key, value) records are organized using a binary tree, assuming
        that keys can be ordered in some way (e.g., numerically or
        alphabetically). (Compare @l(#Exercise 2.66) of @l(#Chapter 2).)

     :: @t(Exercise 3.27) :: @e(Memoization) (also called @e(tabulation)) is a
        technique that enables a procedure to record, in a local table, values that
        have previously been computed. This technique can make a vast difference in
        the performance of a program. A memoized procedure maintains a table in
        which values of previous calls are stored using as keys the arguments that
        produced the values. When the memoized procedure is asked to compute a
        value, it first checks the table to see if the value is already there and,
        if so, just returns that value. Otherwise, it computes the new value in the
        ordinary way and stores this in the table. As an example of memoization,
        recall from @l(#1.2.2) the exponential process for computing Fibonacci
        numbers:

        ..src > scheme
          (define (fib n)
            (cond ((= n 0) 0)
                  ((= n 1) 1)
                  (else (+ (fib (- n 1))
                           (fib (- n 2))))))
        < src..

        The memoized version of the same procedure is

        ..src > scheme
          (define memo-fib
            (memoize
             (lambda (n)
               (cond ((= n 0) 0)
                     ((= n 1) 1)
                     (else
                      (+ (memo-fib (- n 1))
                         (memo-fib (- n 2))))))))
        < src..

        where the memoizer is defined as

        ..src > scheme
          (define (memoize f)
            (let ((table (make-table)))
              (lambda (x)
                (let ((previously-computed-result
                       (lookup x table)))
                  (or previously-computed-result
                      (let ((result (f x)))
                        (insert! x result table)
                        result))))))
        < src..

        Draw an environment diagram to analyze the computation of @c[(memo-fib 3)].
        Explain why @c(memo-fib) computes the @m(nᵗʰ) Fibonacci number in a number
        of steps proportional to @m(n). Would the scheme still work if we had
        simply defined @c(memo-fib) to be @c[(memoize fib)]?

*** 3.3.4 <> A Simulator for Digital Circuits

    Designing complex digital systems, such as computers, is an important
    engineering activity. Digital systems are constructed by interconnecting
    simple elements. Although the behavior of these individual elements is simple,
    networks of them can have very complex behavior. Computer simulation of
    proposed circuit designs is an important tool used by digital systems
    engineers. In this section we design a system for performing digital logic
    simulations. This system typifies a kind of program called an @e(event-driven
    simulation), in which actions (@"(events)) trigger further events that happen
    at a later time, which in turn trigger more events, and so on.

    Our computational model of a circuit will be composed of objects that
    correspond to the elementary components from which the circuit is constructed.
    There are @e(wires), which carry @e(digital signals). A digital signal may at
    any moment have only one of two possible values, 0 and 1. There are also
    various types of digital @e(function boxes), which connect wires carrying
    input signals to other output wires. Such boxes produce output signals
    computed from their input signals. The output signal is delayed by a time that
    depends on the type of the function box. For example, an @e(inverter) is a
    primitive function box that inverts its input. If the input signal to an
    inverter changes to 0, then one inverter-delay later the inverter will change
    its output signal to 1. If the input signal to an inverter changes to 1, then
    one inverter-delay later the inverter will change its output signal to 0. We
    draw an inverter symbolically as in @l(#Figure 3.24).  An @e(and-gate), also
    shown in figure 3.24, is a primitive function box with two inputs and one
    output. It drives its output signal to a value that is the @e(logical and) of
    the inputs. That is, if both of its input signals become 1, then one
    and-gate-delay time later the and-gate will force its output signal to be 1;
    otherwise the output will be 0. An @e(or-gate) is a similar two-input
    primitive function box that drives its output signal to a value that is the
    @e(logical or) of the inputs. That is, the output will become 1 if at least
    one of the input signals is 1; otherwise the output will become 0.

    ..figure > @t(Figure 3.24) Primitive functions in the digital logic simulator.

      ..art >

          ╭-._           ╭───-.          ─────.
          │   `\       ──┤     \       ──\     \
        ──┤     >○──     │      )──       )     >--
          │ __./       ──┤     /       ──/     /
          ╰-'            ╰────`          ─────'

        Inverter       And-gate        Or-gate
      < art..

@   ..img > img/chap3/Fig3.24a.std.svg

    We can connect primitive functions together to construct more complex
    functions. To accomplish this we wire the outputs of some function boxes to
    the inputs of other function boxes. For example, the @e(half-adder) circuit
    shown in @l(#Figure 3.25) consists of an or-gate, two and-gates, and an
    inverter. It takes two input signals, A and B, and has two output signals, S
    and C. S will become 1 whenever precisely one of A and B is 1, and C will
    become 1 whenever A and B are both 1. We can see from the figure that, because
    of the delays involved, the outputs may be generated at different times. Many
    of the difficulties in the design of digital circuits arise from this fact.

    ..figure > @t(Figure 3.25) A half-adder circuit.

      ..art >
            ╭───────────────────────────────────────╮
            │         ____                          │
        A ──┼─────●───\   \ D                ___    │
            │     │    >   >────────────────│   \   │
            │  ╭──│───/___/                 │    )──┼── S
            │  │  │              │\.  E  ╭──│___/   │
            │  │  │           ╭──│  >○───╯          │
            │  │  │    ___    │  │/`                │
            │  │  ╰───│   \   │                     │
            │  │      │    )──●─────────────────────┼── C
        B ──┼──●──────│___/                         │
            │                                       │
            ╰───────────────────────────────────────╯
      < art..

@   ..img > img/chap3/Fig3.25c.std.svg

    We will now build a program for modeling the digital logic circuits we wish to
    study. The program will construct computational objects modeling the wires,
    which will @"(hold) the signals. Function boxes will be modeled by procedures
    that enforce the correct relationships among the signals.

    One basic element of our simulation will be a procedure @c(make-wire), which
    constructs wires. For example, we can construct six wires as follows:

    ..src > scheme
      (define a (make-wire))
      (define b (make-wire))
      (define c (make-wire))
      (define d (make-wire))
      (define e (make-wire))
      (define s (make-wire))
    < src..

    We attach a function box to a set of wires by calling a procedure that
    constructs that kind of box. The arguments to the constructor procedure are
    the wires to be attached to the box. For example, given that we can construct
    and-gates, or-gates, and inverters, we can wire together the half-adder shown
    in @l(#Figure 3.25):

    ..srci > scheme
      > (or-gate a b d)
      ok
      > (and-gate a b c)
      ok
      > (inverter c e)
      ok
      > (and-gate d e s)
      ok
    < srci..

    Better yet, we can explicitly name this operation by defining a procedure
    @c(half-adder) that constructs this circuit, given the four external wires to
    be attached to the half-adder:

    ..src > scheme
      (define (half-adder a b s c)
        (let ((d (make-wire)) (e (make-wire)))
          (or-gate a b d)
          (and-gate a b c)
          (inverter c e)
          (and-gate d e s)
          'ok))
    < src..

    The advantage of making this definition is that we can use @c(half-adder)
    itself as a building block in creating more complex circuits. @l(#Figure
    3.26), for example, shows a @e(full-adder) composed of two half-adders and an
    or-gate.@n(154) We can construct a full-adder as follows:

    ..src > scheme
      (define (full-adder a b c-in sum c-out)
        (let ((c1 (make-wire))
              (c2 (make-wire))
              (s  (make-wire)))
          (half-adder b c-in s c1)
          (half-adder a s sum c2)
          (or-gate c1 c2 c-out)
          'ok))
    < src..

    ..figure > @t(Figure 3.26) A full-adder circuit.

      ..art >
              ╭──────────────────────────────────╮
              │              ╭───────╮           │
         A  ──┼──────────────┤ half- ├───────────┼── SUM
              │  ╭───────╮   │ adder │   ____    │
         B  ──┼──┤ half- ├───┤       ├───\   \   │
              │  │ adder │   ╰───────╯    >or >──┼── Cₒᵤₜ
        Cᵢₙ ──┼──┤       ├───────────────/___/   │
              │  ╰───────╯                       │
              ╰──────────────────────────────────╯
      < art..

@   ..img > img/chap3/Fig3.26.std.svg

    Having defined @c(full-adder) as a procedure, we can now use it as a building
    block for creating still more complex circuits. (For example, see @l(#Exercise
    3.30).)

    In essence, our simulator provides us with the tools to construct a language
    of circuits. If we adopt the general perspective on languages with which we
    approached the study of Lisp in @l(#1.1), we can say that the primitive
    function boxes form the primitive elements of the language, that wiring boxes
    together provides a means of combination, and that specifying wiring patterns
    as procedures serves as a means of abstraction.

**** Primitive function boxes

     The primitive function boxes implement the @"(forces) by which a change in the
     signal on one wire influences the signals on other wires. To build function
     boxes, we use the following operations on wires:

     - @c[(get-signal ⟨wire⟩)]

       returns the current value of the signal on the wire.

     - @c[(set-signal! ⟨wire⟩ ⟨new value⟩)]

       changes the value of the signal on the wire to the new value.

     - @c[(add-action! ⟨wire⟩ ⟨procedure of no arguments⟩)]

       asserts that the designated procedure should be run whenever the signal on the
       wire changes value. Such procedures are the vehicles by which changes in the
       signal value on the wire are communicated to other wires.


     In addition, we will make use of a procedure @c(after-delay) that takes a time
     delay and a procedure to be run and executes the given procedure after the
     given delay.

     Using these procedures, we can define the primitive digital logic functions.
     To connect an input to an output through an inverter, we use @c(add-action!)
     to associate with the input wire a procedure that will be run whenever the
     signal on the input wire changes value. The procedure computes the
     @c(logical-not) of the input signal, and then, after one @c(inverter-delay),
     sets the output signal to be this new value:

     ..src > scheme
       (define (inverter input output)
         (define (invert-input)
           (let ((new-value
                  (logical-not (get-signal input))))
             (after-delay
              inverter-delay
              (lambda ()
                (set-signal! output new-value)))))
         (add-action! input invert-input)
         'ok)

       (define (logical-not s)
         (cond ((= s 0) 1)
               ((= s 1) 0)
               (else (error "Invalid signal" s))))
     < src..

     An and-gate is a little more complex. The action procedure must be run if
     either of the inputs to the gate changes. It computes the @c(logical-and)
     (using a procedure analogous to @c(logical-not)) of the values of the signals
     on the input wires and sets up a change to the new value to occur on the
     output wire after one @c(and-gate-delay).

     ..src > scheme
       (define (and-gate a1 a2 output)
         (define (and-action-procedure)
           (let ((new-value
                  (logical-and (get-signal a1)
                               (get-signal a2))))
             (after-delay
              and-gate-delay
              (lambda ()
                (set-signal! output new-value)))))
         (add-action! a1 and-action-procedure)
         (add-action! a2 and-action-procedure)
         'ok)
     < src..

     :: @t(Exercise 3.28) :: Define an or-gate as a primitive function box. Your
        @c(or-gate) constructor should be similar to @c(and-gate).

     :: @t(Exercise 3.29) :: Another way to construct an or-gate is as a compound
        digital logic device, built from and-gates and inverters. Define a
        procedure @c(or-gate) that accomplishes this. What is the delay time of the
        or-gate in terms of @c(and-gate-delay) and @c(inverter-delay)?

     :: @t(Exercise 3.30) :: @l(#Figure 3.27) shows a @e(ripple-carry adder) formed
        by stringing together @m(n) full-adders.  This is the simplest form of
        parallel adder for adding two @m(n)-bit binary numbers. The inputs @m(A₁),
        @m(A₂), @m(A₃), …, @m(Aₙ) and @m(B₁), @m(B₂), @m(B₃), …, @m(Bₙ) are the two
        binary numbers to be added (each @m(Aₙ) and @m(Bₙ) is a 0 or a 1). The
        circuit generates @m(S₁), @m(S₂), @m(S₃), …, @m(Sₙ), the @m(n) bits of the
        sum, and @m(C), the carry from the addition. Write a procedure
        @c(ripple-carry-adder) that generates this circuit. The procedure should
        take as arguments three lists of @m(n) wires each––the @m(Aₙ), the @m(Bₙ),
        and the @m(Sₙ)––and also another wire @m(C). The major drawback of the
        ripple-carry adder is the need to wait for the carry signals to propagate.
        What is the delay needed to obtain the complete output from an @m(n)-bit
        ripple-carry adder, expressed in terms of the delays for and-gates,
        or-gates, and inverters?

     ..figure > @t(Figure 3.27) A ripple-carry adder for @m(n)-bit numbers.

       ..art >
            |                                              |   |
            |  A₁  B₁    C₁    A₂  B₂    C₂    A₃  B₃   C₃ |   |  Aₙ  Bₙ Cₙ=0
            |  │   │   ╭───╮   │   │   ╭───╮   │   │   ╭───|─  |  │   │   ╭─
            |  │   │   │   │   │   │   │   │   │   │   │   |   |  │   │   │
            | ╭┴───┴───┴╮  │  ╭┴───┴───┴╮  │  ╭┴───┴───┴╮  |   | ╭┴───┴───┴╮
            | │   FA    │  │  │   FA    │  │  │   FA    │  |   | │   FA    │
            | ╰──┬───┬──╯  │  ╰──┬───┬──╯  │  ╰──┬───┬──╯  |   | ╰──┬───┬──╯
            |    │   │     │     │   │     │     │   │     |   |    │   │
         C ─|────╯   │     ╰─────╯   │     ╰─────╯   │     |  ─|────╯   │
            |        │        C₁     │        C₂     │     |   |C₍ₙ₋₁₎  │
            |        │               │               │     |   |        │
                     S₁              S₂              S₃                 Sₙ
       < art..

@    ..img > img/chap3/Fig3.27b.std.svg

**** Representing wires

     A wire in our simulation will be a computational object with two local state
     variables: a @c(signal-value) (initially taken to be 0) and a collection of
     @c(action-procedures) to be run when the signal changes value. We implement
     the wire, using message-passing style, as a collection of local procedures
     together with a @c(dispatch) procedure that selects the appropriate local
     operation, just as we did with the simple bank-account object in @l(#3.1.1):

     ..src > scheme
       (define (make-wire)
         (let ((signal-value 0)
               (action-procedures '()))
           (define (set-my-signal! new-value)
             (if (not (= signal-value new-value))
                 (begin (set! signal-value new-value)
                        (call-each
                         action-procedures))
                 'done))
           (define (accept-action-procedure! proc)
             (set! action-procedures
                   (cons proc action-procedures))
             (proc))
           (define (dispatch m)
             (cond ((eq? m 'get-signal)
                    signal-value)
                   ((eq? m 'set-signal!)
                    set-my-signal!)
                   ((eq? m 'add-action!)
                    accept-action-procedure!)
                   (else (error "Unknown operation:
                                 WIRE" m))))
           dispatch))
     < src..

     The local procedure @c(set-my-signal!) tests whether the new signal value
     changes the signal on the wire. If so, it runs each of the action procedures,
     using the following procedure @c(call-each), which calls each of the items in
     a list of no-argument procedures:

     ..src > scheme
       (define (call-each procedures)
         (if (null? procedures)
             'done
             (begin ((car procedures))
                    (call-each (cdr procedures)))))
     < src..

     The local procedure @c(accept-action-procedure!) adds the given procedure to
     the list of procedures to be run, and then runs the new procedure once. (See
     @l(#Exercise 3.31).)

     With the local @c(dispatch) procedure set up as specified, we can provide the
     following procedures to access the local operations on wires:@n(155)

     ..src > scheme
       (define (get-signal wire)
         (wire 'get-signal))
       (define (set-signal! wire new-value)
         ((wire 'set-signal!) new-value))
       (define (add-action! wire action-procedure)
         ((wire 'add-action!) action-procedure))
     < src..

     Wires, which have time-varying signals and may be incrementally attached to
     devices, are typical of mutable objects. We have modeled them as procedures
     with local state variables that are modified by assignment. When a new wire is
     created, a new set of state variables is allocated (by the @c(let) expression
     in @c(make-wire)) and a new @c(dispatch) procedure is constructed and
     returned, capturing the environment with the new state variables.

     The wires are shared among the various devices that have been connected to
     them. Thus, a change made by an interaction with one device will affect all
     the other devices attached to the wire. The wire communicates the change to
     its neighbors by calling the action procedures provided to it when the
     connections were established.

**** The agenda

     The only thing needed to complete the simulator is @c(after-delay). The idea
     here is that we maintain a data structure, called an @e(agenda), that contains
     a schedule of things to do. The following operations are defined for agendas:

     - @c[(make-agenda)] returns a new empty agenda.

     - @c[(empty-agenda? ⟨agenda⟩)] is true if the specified agenda is empty.

     - @c[(first-agenda-item ⟨agenda⟩)] returns the first item on the agenda.

     - @c[(remove-first-agenda-item! ⟨agenda⟩)] modifies the agenda by removing the
       first item.

     - @c[(add-to-agenda! ⟨time⟩ ⟨action⟩ ⟨agenda⟩)] modifies the agenda by adding
       the given action procedure to be run at the specified time.

     - @c[(current-time ⟨agenda⟩)] returns the current simulation time.

     The particular agenda that we use is denoted by @c(the-agenda). The procedure
     @c(after-delay) adds new elements to @c(the-agenda):

     ..src > scheme
       (define (after-delay delay action)
         (add-to-agenda!
          (+ delay (current-time the-agenda))
          action
          the-agenda))
     < src..

     The simulation is driven by the procedure @c(propagate), which operates on
     @c(the-agenda), executing each procedure on the agenda in sequence. In
     general, as the simulation runs, new items will be added to the agenda, and
     @c(propagate) will continue the simulation as long as there are items on the
     agenda:

     ..src > scheme
       (define (propagate)
         (if (empty-agenda? the-agenda)
             'done
             (let ((first-item
                    (first-agenda-item the-agenda)))
               (first-item)
               (remove-first-agenda-item! the-agenda)
               (propagate))))
     < src..

**** A sample simulation

     The following procedure, which places a @"(probe) on a wire, shows the
     simulator in action. The probe tells the wire that, whenever its signal
     changes value, it should print the new signal value, together with the current
     time and a name that identifies the wire:

     ..src > scheme
       (define (probe name wire)
         (add-action!
          wire
          (lambda ()
            (newline)
            (display name)
            (display " ")
            (display (current-time the-agenda))
            (display "  New-value = ")
            (display (get-signal wire)))))
     < src..

     We begin by initializing the agenda and specifying delays for the primitive
     function boxes:

     ..src > scheme
       (define the-agenda (make-agenda))
       (define inverter-delay 2)
       (define and-gate-delay 3)
       (define or-gate-delay 5)
     < src..

     Now we define four wires, placing probes on two of them:

     ..srci > scheme
       > (define input-1 (make-wire))
       > (define input-2 (make-wire))
       > (define sum (make-wire))
       > (define carry (make-wire))
       > (probe 'sum sum)
       sum 0  New-value = 0
       > (probe 'carry carry)
       carry 0  New-value = 0
     < srci..

     Next we connect the wires in a half-adder circuit (as in @l(#Figure 3.25)),
     set the signal on @c(input-1) to 1, and run the simulation:

     ..srci > scheme
       > (half-adder input-1 input-2 sum carry)
       ok
       > (set-signal! input-1 1)
       done
       > (propagate)
       sum 8  New-value = 1
       done
     < srci..

     The @c(sum) signal changes to 1 at time 8. We are now eight time units from
     the beginning of the simulation. At this point, we can set the signal on
     @c(input-2) to 1 and allow the values to propagate:

     ..srci > scheme
       > (set-signal! input-2 1)
       done
       > (propagate)
       carry 11  New-value = 1
       sum 16  New-value = 0
       done
     < srci..

     The @c(carry) changes to 1 at time 11 and the @c(sum) changes to 0 at time 16.

     :: @t(Exercise 3.31) :: The internal procedure @c(accept-action-procedure!)
        defined in @c(make-wire) specifies that when a new action procedure is
        added to a wire, the procedure is immediately run.  Explain why this
        initialization is necessary. In particular, trace through the half-adder
        example in the paragraphs above and say how the system's response would
        differ if we had defined @c(accept-action-procedure!) as

        ..src > scheme
          (define (accept-action-procedure! proc)
            (set! action-procedures
                  (cons proc action-procedures)))
        < src..

**** Implementing the agenda

     Finally, we give details of the agenda data structure, which holds the
     procedures that are scheduled for future execution.

     The agenda is made up of @e(time segments). Each time segment is a pair
     consisting of a number (the time) and a queue (see @l(#Exercise 3.32)) that
     holds the procedures that are scheduled to be run during that time segment.

     ..src > scheme
       (define (make-time-segment time queue)
         (cons time queue))
       (define (segment-time s) (car s))
       (define (segment-queue s) (cdr s))
     < src..

     We will operate on the time-segment queues using the queue operations
     described in @l(#3.3.2).

     The agenda itself is a one-dimensional table of time segments. It differs from
     the tables described in @l(#3.3.3) in that the segments will be sorted in
     order of increasing time. In addition, we store the @e(current time) (i.e.,
     the time of the last action that was processed) at the head of the agenda. A
     newly constructed agenda has no time segments and has a current time of
     0:@n(156)

     ..src > scheme
       (define (make-agenda) (list 0))
       (define (current-time agenda) (car agenda))
       (define (set-current-time! agenda time)
         (set-car! agenda time))
       (define (segments agenda) (cdr agenda))
       (define (set-segments! agenda segments)
         (set-cdr! agenda segments))
       (define (first-segment agenda)
         (car (segments agenda)))
       (define (rest-segments agenda)
         (cdr (segments agenda)))
     < src..

     An agenda is empty if it has no time segments:

     ..src > scheme
       (define (empty-agenda? agenda)
         (null? (segments agenda)))
     < src..

     To add an action to an agenda, we first check if the agenda is empty. If so,
     we create a time segment for the action and install this in the agenda.
     Otherwise, we scan the agenda, examining the time of each segment. If we find
     a segment for our appointed time, we add the action to the associated queue.
     If we reach a time later than the one to which we are appointed, we insert a
     new time segment into the agenda just before it. If we reach the end of the
     agenda, we must create a new time segment at the end.

     ..src > scheme
       (define (add-to-agenda! time action agenda)
         (define (belongs-before? segments)
           (or (null? segments)
               (< time
                  (segment-time (car segments)))))
         (define (make-new-time-segment time action)
           (let ((q (make-queue)))
             (insert-queue! q action)
             (make-time-segment time q)))
         (define (add-to-segments! segments)
           (if (= (segment-time (car segments)) time)
               (insert-queue!
                (segment-queue (car segments))
                action)
               (let ((rest (cdr segments)))
                 (if (belongs-before? rest)
                     (set-cdr!
                      segments
                      (cons (make-new-time-segment
                             time
                             action)
                            (cdr segments)))
                     (add-to-segments! rest)))))
         (let ((segments (segments agenda)))
           (if (belongs-before? segments)
               (set-segments!
                agenda
                (cons (make-new-time-segment
                       time
                       action)
                      segments))
               (add-to-segments! segments))))
     < src..

     The procedure that removes the first item from the agenda deletes the item at
     the front of the queue in the first time segment. If this deletion makes the
     time segment empty, we remove it from the list of segments:@n(157)

     ..src > scheme
       (define (remove-first-agenda-item! agenda)
         (let ((q (segment-queue
                   (first-segment agenda))))
           (delete-queue! q)
           (if (empty-queue? q)
               (set-segments!
                agenda
                (rest-segments agenda)))))
     < src..

     The first agenda item is found at the head of the queue in the first time
     segment. Whenever we extract an item, we also update the current time:@n(158)

     ..src > scheme
       (define (first-agenda-item agenda)
         (if (empty-agenda? agenda)
             (error "Agenda is empty:
                     FIRST-AGENDA-ITEM")
             (let ((first-seg
                    (first-segment agenda)))
               (set-current-time!
                agenda
                (segment-time first-seg))
               (front-queue
                (segment-queue first-seg)))))
     < src..

     :: @t(Exercise 3.32) :: The procedures to be run during each time segment of
        the agenda are kept in a queue. Thus, the procedures for each segment are
        called in the order in which they were added to the agenda (first in, first
        out). Explain why this order must be used. In particular, trace the
        behavior of an and-gate whose inputs change from 0, 1 to 1, 0 in the same
        segment and say how the behavior would differ if we stored a segment's
        procedures in an ordinary list, adding and removing procedures only at the
        front (last in, first out).

*** 3.3.5 <> Propagation of Constraints

    Computer programs are traditionally organized as one-directional computations,
    which perform operations on prespecified arguments to produce desired outputs.
    On the other hand, we often model systems in terms of relations among
    quantities. For example, a mathematical model of a mechanical structure might
    include the information that the deflection @m(d) of a metal rod is related to
    the force @m(F) on the rod, the length @m(L) of the rod, the cross-sectional
    area @m(a), and the elastic modulus @m(E) via the equation

    ..example >
      dAE = FL
    < example..

    Such an equation is not one-directional. Given any four of the quantities, we
    can use it to compute the fifth. Yet translating the equation into a
    traditional computer language would force us to choose one of the quantities
    to be computed in terms of the other four. Thus, a procedure for computing the
    area @m(a) could not be used to compute the deflection @m(d), even though the
    computations of @m(a) and @m(d) arise from the same equation.@n(159)

    In this section, we sketch the design of a language that enables us to work in
    terms of relations themselves. The primitive elements of the language are
    @e(primitive constraints), which state that certain relations hold between
    quantities. For example, @c[(adder a b c)] specifies that the quantities
    @m(a), @m(b), and @m(c) must be related by the equation @m(a + b = c),
    @c[(multiplier x y z)] expresses the constraint @m(xy = z), and @c[(constant
    3.14 x)] says that the value of @m(x) must be 3.14.

    Our language provides a means of combining primitive constraints in order to
    express more complex relations. We combine constraints by constructing
    @e(constraint networks), in which constraints are joined by @e(connectors). A
    connector is an object that @"(holds) a value that may participate in one or
    more constraints. For example, we know that the relationship between
    Fahrenheit and Celsius temperatures is

    ..example >
      9C = 5(F − 32)
    < example..

    Such a constraint can be thought of as a network consisting of primitive
    adder, multiplier, and constant constraints (@l(#Figure 3.28)). In the figure,
    we see on the left a multiplier box with three terminals, labeled @m(m1),
    @m(m2), and @m(p). These connect the multiplier to the rest of the network as
    follows: The @m(m1) terminal is linked to a connector @m(C), which will hold
    the Celsius temperature. The @m(m2) terminal is linked to a connector @m(w),
    which is also linked to a constant box that holds 9. The @m(p) terminal, which
    the multiplier box constrains to be the product of @m(m1) and @m(m2), is
    linked to the @m(p) terminal of another multiplier box, whose @m(m2) is
    connected to a constant 5 and whose @m(m1) is connected to one of the terms in
    a sum.

    ..figure > @t(Figure 3.28) The relation @m[9C = 5(F - 32)] expressed as a
      constraint network.

      ..art >
               ╭─────────╮     ╭─────────╮   v   ╭─────────╮
        C ─────┤ m1      │  u  │      m1 ├───────┤ a1      │
               │    *  p ├─────┤ p  *    │       │    *  s ├──── F
            ╭──┤ m2      │     │      m2 ├──╮ ╭──┤ a2      │
            │  ╰─────────╯     ╰─────────╯  │ │  ╰─────────╯
          w │                              x│ │y
            │    ╭─────╮        ╭─────╮     │ │     ╭─────╮
            ╰────┤  9  │        │  5  ├─────╯ ╰─────┤  32 │
                 ╰─────╯        ╰─────╯             ╰─────╯
      < art..

@   ..img > img/chap3/Fig3.28.std.svg

    Computation by such a network proceeds as follows: When a connector is given a
    value (by the user or by a constraint box to which it is linked), it awakens
    all of its associated constraints (except for the constraint that just
    awakened it) to inform them that it has a value. Each awakened constraint box
    then polls its connectors to see if there is enough information to determine a
    value for a connector. If so, the box sets that connector, which then awakens
    all of its associated constraints, and so on. For instance, in conversion
    between Celsius and Fahrenheit, @m(w), @m(x), and @m(y) are immediately set by
    the constant boxes to 9, 5, and 32, respectively. The connectors awaken the
    multipliers and the adder, which determine that there is not enough
    information to proceed. If the user (or some other part of the network) sets
    @m(C) to a value (say 25), the leftmost multiplier will be awakened, and it
    will set @m(u) to @m(25 ⋅ 9 = 225). Then @m(u) awakens the second multiplier,
    which sets @m(v) to 45, and @m(v) awakens the adder, which sets @m(f) to 77.

**** Using the constraint system

     To use the constraint system to carry out the temperature computation outlined
     above, we first create two connectors, @c(C) and @c(F), by calling the
     constructor @c(make-connector), and link @c(C) and @c(F) in an appropriate
     network:

     ..srci > scheme
       > (define C (make-connector))
       > (define F (make-connector))
       > (celsius-fahrenheit-converter C F)
       ok
     < srci..

     The procedure that creates the network is defined as follows:

     ..src > scheme
       (define (celsius-fahrenheit-converter c f)
         (let ((u (make-connector))
               (v (make-connector))
               (w (make-connector))
               (x (make-connector))
               (y (make-connector)))
           (multiplier c w u)
           (multiplier v x u)
           (adder v y f)
           (constant 9 w)
           (constant 5 x)
           (constant 32 y)
           'ok))
     < src..

     This procedure creates the internal connectors @c(u), @c(v), @c(w), @c(x), and
     @c(y), and links them as shown in @l(#Figure 3.28) using the primitive
     constraint constructors @c(adder), @c(multiplier), and @c(constant). Just as
     with the digital-circuit simulator of @l(#3.3.4), expressing these
     combinations of primitive elements in terms of procedures automatically
     provides our language with a means of abstraction for compound objects.

     To watch the network in action, we can place probes on the connectors @c(C)
     and @c(F), using a @c(probe) procedure similar to the one we used to monitor
     wires in @l(#3.3.4). Placing a probe on a connector will cause a message to be
     printed whenever the connector is given a value:

     ..src > scheme
       (probe "Celsius temp" C)
       (probe "Fahrenheit temp" F)
     < src..

     Next we set the value of @c(C) to 25. (The third argument to @c(set-value!)
     tells @c(C) that this directive comes from the @c(user).)

     ..srci > scheme
       > (set-value! C 25 'user)
       Probe: Celsius temp = 25
       Probe: Fahrenheit temp = 77
       done
     < srci..

     The probe on @c(C) awakens and reports the value. @c(C) also propagates its
     value through the network as described above. This sets @c(F) to 77, which is
     reported by the probe on @c(F).

     Now we can try to set @c(F) to a new value, say 212:

     ..srci > scheme
       > (set-value! F 212 'user)
       Error! Contradiction (77 212)
     < srci..

     The connector complains that it has sensed a contradiction: Its value is 77,
     and someone is trying to set it to 212. If we really want to reuse the network
     with new values, we can tell @c(C) to forget its old value:

     ..srci > scheme
       > (forget-value! C 'user)
       Probe: Celsius temp = ?
       Probe: Fahrenheit temp = ?
       done
     < srci..

     @c(C) finds that the @c(user), who set its value originally, is now retracting
     that value, so @c(C) agrees to lose its value, as shown by the probe, and
     informs the rest of the network of this fact. This information eventually
     propagates to @c(F), which now finds that it has no reason for continuing to
     believe that its own value is 77. Thus, @c(F) also gives up its value, as
     shown by the probe.

     Now that @c(F) has no value, we are free to set it to 212:

     ..srci > scheme
       > (set-value! F 212 'user)
       Probe: Fahrenheit temp = 212
       Probe: Celsius temp = 100
       done
     < srci..

     This new value, when propagated through the network, forces @c(C) to have a
     value of 100, and this is registered by the probe on @c(C). Notice that the
     very same network is being used to compute @c(C) given @c(F) and to compute
     @c(F) given @c(C). This nondirectionality of computation is the distinguishing
     feature of constraint-based systems.

**** Implementing the constraint system

     The constraint system is implemented via procedural objects with local state,
     in a manner very similar to the digital-circuit simulator of
     @l(#3.3.4). Although the primitive objects of the constraint system are
     somewhat more complex, the overall system is simpler, since there is no
     concern about agendas and logic delays.

     The basic operations on connectors are the following:

     - @c[(has-value? ⟨connector⟩)] tells whether the connector has a value.

     - @c[(get-value ⟨connector⟩)] returns the connector's current value.

     - @c[(set-value! ⟨connector⟩ ⟨new-value⟩ ⟨informant⟩)] indicates that the
       informant is requesting the connector to set its value to the new value.

     - @c[(forget-value! ⟨connector⟩ ⟨retractor⟩)] tells the connector that the
       retractor is requesting it to forget its value.

     - @c[(connect ⟨connector⟩ ⟨new-constraint⟩)] tells the connector to
       participate in the new constraint.


     The connectors communicate with the constraints by means of the procedures
     @c(inform-about-value), which tells the given constraint that the connector
     has a value, and @c(inform-about-no-value), which tells the constraint that
     the connector has lost its value.

     @c(Adder) constructs an adder constraint among summand connectors @c(a1) and
     @c(a2) and a @c(sum) connector. An adder is implemented as a procedure with
     local state (the procedure @c(me) below):

     ..src > scheme
       (define (adder a1 a2 sum)
         (define (process-new-value)
           (cond ((and (has-value? a1)
                       (has-value? a2))
                  (set-value! sum
                              (+ (get-value a1)
                                 (get-value a2))
                              me))
                 ((and (has-value? a1)
                       (has-value? sum))
                  (set-value! a2
                              (- (get-value sum)
                                 (get-value a1))
                              me))
                 ((and (has-value? a2)
                       (has-value? sum))
                  (set-value! a1
                              (- (get-value sum)
                                 (get-value a2))
                              me))))
         (define (process-forget-value)
           (forget-value! sum me)
           (forget-value! a1 me)
           (forget-value! a2 me)
           (process-new-value))
         (define (me request)
           (cond ((eq? request 'I-have-a-value)
                  (process-new-value))
                 ((eq? request 'I-lost-my-value)
                  (process-forget-value))
                 (else (error "Unknown request:
                               ADDER" request))))
         (connect a1 me)
         (connect a2 me)
         (connect sum me)
         me)
     < src..

     @c(Adder) connects the new adder to the designated connectors and returns it
     as its value. The procedure @c(me), which represents the adder, acts as a
     dispatch to the local procedures. The following @"(syntax interfaces) (see
     @n(155<>Footnote 155) in @l(#3.3.4)) are used in conjunction with the
     dispatch:

     ..src > scheme
       (define (inform-about-value constraint)
         (constraint 'I-have-a-value))
       (define (inform-about-no-value constraint)
         (constraint 'I-lost-my-value))
     < src..

     The adder's local procedure @c(process-new-value) is called when the adder is
     informed that one of its connectors has a value. The adder first checks to see
     if both @c(a1) and @c(a2) have values. If so, it tells @c(sum) to set its
     value to the sum of the two addends. The @c(informant) argument to
     @c(set-value!) is @c(me), which is the adder object itself. If @c(a1) and
     @c(a2) do not both have values, then the adder checks to see if perhaps @c(a1)
     and @c(sum) have values. If so, it sets @c(a2) to the difference of these
     two. Finally, if @c(a2) and @c(sum) have values, this gives the adder enough
     information to set @c(a1). If the adder is told that one of its connectors has
     lost a value, it requests that all of its connectors now lose their
     values. (Only those values that were set by this adder are actually lost.)
     Then it runs @c(process-new-value). The reason for this last step is that one
     or more connectors may still have a value (that is, a connector may have had a
     value that was not originally set by the adder), and these values may need to
     be propagated back through the adder.

     A multiplier is very similar to an adder. It will set its @c(product) to 0 if
     either of the factors is 0, even if the other factor is not known.

     ..src > scheme
       (define (multiplier m1 m2 product)
         (define (process-new-value)
           (cond ((or (and (has-value? m1)
                           (= (get-value m1) 0))
                      (and (has-value? m2)
                           (= (get-value m2) 0)))
                  (set-value! product 0 me))
                 ((and (has-value? m1)
                       (has-value? m2))
                  (set-value! product
                              (* (get-value m1)
                                 (get-value m2))
                              me))
                 ((and (has-value? product)
                       (has-value? m1))
                  (set-value! m2
                              (/ (get-value product)
                                 (get-value m1))
                              me))
                 ((and (has-value? product)
                       (has-value? m2))
                  (set-value! m1
                              (/ (get-value product)
                                 (get-value m2))
                              me))))
         (define (process-forget-value)
           (forget-value! product me)
           (forget-value! m1 me)
           (forget-value! m2 me)
           (process-new-value))
         (define (me request)
           (cond ((eq? request 'I-have-a-value)
                  (process-new-value))
                 ((eq? request 'I-lost-my-value)
                  (process-forget-value))
                 (else
                  (error "Unknown request:
                          MULTIPLIER"
                         request))))
         (connect m1 me)
         (connect m2 me)
         (connect product me)
         me)
     < src..

     A @c(constant) constructor simply sets the value of the designated
     connector. Any @c(I-have-a-value) or @c(I-lost-my-value) message sent to the
     constant box will produce an error.

     ..src > scheme
       (define (constant value connector)
         (define (me request)
           (error "Unknown request: CONSTANT"
                  request))
         (connect connector me)
         (set-value! connector value me)
         me)
     < src..

     Finally, a probe prints a message about the setting or unsetting of the
     designated connector:

     ..src > scheme
       (define (probe name connector)
         (define (print-probe value)
           (newline) (display "Probe: ")
           (display name) (display " = ")
           (display value))
         (define (process-new-value)
           (print-probe (get-value connector)))
         (define (process-forget-value)
           (print-probe "?"))
         (define (me request)
           (cond ((eq? request 'I-have-a-value)
                  (process-new-value))
                 ((eq? request 'I-lost-my-value)
                  (process-forget-value))
                 (else (error "Unknown request:
                               PROBE" request))))
         (connect connector me)
         me)
     < src..

**** Representing connectors

     A connector is represented as a procedural object with local state variables
     @c(value), the current value of the connector; @c(informant), the object that
     set the connector's value; and @c(constraints), a list of the constraints in
     which the connector participates.

     ..src > scheme
       (define (make-connector)
         (let ((value false)
               (informant false)
               (constraints '()))
           (define (set-my-value newval setter)
             (cond ((not (has-value? me))
                    (set! value newval)
                    (set! informant setter)
                    (for-each-except
                     setter
                     inform-about-value
                     constraints))
                   ((not (= value newval))
                    (error "Contradiction"
                           (list value newval)))
                   (else 'ignored)))
           (define (forget-my-value retractor)
             (if (eq? retractor informant)
                 (begin (set! informant false)
                        (for-each-except
                         retractor
                         inform-about-no-value
                         constraints))
                 'ignored))
           (define (connect new-constraint)
             (if (not (memq new-constraint
                            constraints))
                 (set! constraints
                       (cons new-constraint
                             constraints)))
             (if (has-value? me)
                 (inform-about-value new-constraint))
             'done)
           (define (me request)
             (cond ((eq? request 'has-value?)
                    (if informant true false))
                   ((eq? request 'value) value)
                   ((eq? request 'set-value!)
                    set-my-value)
                   ((eq? request 'forget)
                    forget-my-value)
                   ((eq? request 'connect) connect)
                   (else (error "Unknown operation:
                                 CONNECTOR"
                                request))))
           me))
     < src..

     The connector's local procedure @c(set-my-value) is called when there is a
     request to set the connector's value. If the connector does not currently have
     a value, it will set its value and remember as @c(informant) the constraint
     that requested the value to be set.@n(160) Then the connector will notify all
     of its participating constraints except the constraint that requested the
     value to be set. This is accomplished using the following iterator, which
     applies a designated procedure to all items in a list except a given one:

     ..src > scheme
       (define (for-each-except exception
                                procedure
                                list)
         (define (loop items)
           (cond ((null? items) 'done)
                 ((eq? (car items) exception)
                  (loop (cdr items)))
                 (else (procedure (car items))
                       (loop (cdr items)))))
         (loop list))
     < src..

     If a connector is asked to forget its value, it runs the local procedure
     @c(forget-my-value), which first checks to make sure that the request is
     coming from the same object that set the value originally. If so, the
     connector informs its associated constraints about the loss of the value.

     The local procedure @c(connect) adds the designated new constraint to the list
     of constraints if it is not already in that list. Then, if the connector has a
     value, it informs the new constraint of this fact.

     The connector's procedure @c(me) serves as a dispatch to the other internal
     procedures and also represents the connector as an object. The following
     procedures provide a syntax interface for the dispatch:

     ..src > scheme
       (define (has-value? connector)
         (connector 'has-value?))
       (define (get-value connector)
         (connector 'value))
       (define (set-value! connector
                           new-value
                           informant)
         ((connector 'set-value!)
          new-value
          informant))
       (define (forget-value! connector retractor)
         ((connector 'forget) retractor))
       (define (connect connector new-constraint)
         ((connector 'connect) new-constraint))
     < src..

     :: @t(Exercise 3.33) :: Using primitive multiplier, adder, and constant
        constraints, define a procedure @c(averager) that takes three connectors
        @c(a), @c(b), and @c(c) as inputs and establishes the constraint that the
        value of @c(c) is the average of the values of @c(a) and @c(b).

     :: @t(Exercise 3.34) :: Louis Reasoner wants to build a squarer, a constraint
        device with two terminals such that the value of connector @c(b) on the
        second terminal will always be the square of the value @c(a) on the first
        terminal. He proposes the following simple device made from a multiplier:

        ..src > scheme
          (define (squarer a b) (multiplier a a b))
        < src..

        There is a serious flaw in this idea. Explain.

     :: @t(Exercise 3.35) :: Ben Bitdiddle tells Louis that one way to avoid the
        trouble in @l(#Exercise 3.34) is to define a squarer as a new primitive
        constraint. Fill in the missing portions in Ben's outline for a procedure
        to implement such a constraint:

        ..src > scheme
          (define (squarer a b)
            (define (process-new-value)
              (if (has-value? b)
                  (if (< (get-value b) 0)
                      (error "square less than 0:
                              SQUARER"
                             (get-value b))
                      ⟨alternative1⟩)
                  ⟨alternative2⟩))
            (define (process-forget-value) ⟨body1⟩)
            (define (me request) ⟨body2⟩)
            ⟨rest of definition⟩
            me)
        < src..

     :: @t(Exercise 3.36) :: Suppose we evaluate the following sequence of
        expressions in the global environment:

        ..src > scheme
          (define a (make-connector))
          (define b (make-connector))
          (set-value! a 10 'user)
        < src..

        At some time during evaluation of the @c(set-value!), the following
        expression from the connector's local procedure is evaluated:

        ..src > scheme
          (for-each-except
            setter inform-about-value constraints)
        < src..

        Draw an environment diagram showing the environment in which the above
        expression is evaluated.

     :: @t(Exercise 3.37) :: The @c(celsius-fahrenheit-converter) procedure is
        cumbersome when compared with a more expression-oriented style of
        definition, such as

        ..src > scheme
          (define (celsius-fahrenheit-converter x)
            (c+ (c* (c/ (cv 9) (cv 5))
                    x)
                (cv 32)))

          (define C (make-connector))
          (define F (celsius-fahrenheit-converter C))
        < src..

        Here @c(c+), @c(c*), etc. are the @"(constraint) versions of the arithmetic
        operations. For example, @c(c+) takes two connectors as arguments and
        returns a connector that is related to these by an adder constraint:

        ..src > scheme
          (define (c+ x y)
            (let ((z (make-connector)))
              (adder x y z)
              z))
        < src..

        Define analogous procedures @c(c-), @c(c*), @c(c/), and @c(cv) (constant
        value) that enable us to define compound constraints as in the converter
        example above.@n(161)

** 3.4 <> Concurrency: Time Is of the Essence

   We've seen the power of computational objects with local state as tools for
   modeling. Yet, as @l(#3.1.3) warned, this power extracts a price: the loss of
   referential transparency, giving rise to a thicket of questions about sameness
   and change, and the need to abandon the substitution model of evaluation in
   favor of the more intricate environment model.

   The central issue lurking beneath the complexity of state, sameness, and
   change is that by introducing assignment we are forced to admit @e(time) into
   our computational models. Before we introduced assignment, all our programs
   were timeless, in the sense that any expression that has a value always has
   the same value. In contrast, recall the example of modeling withdrawals from a
   bank account and returning the resulting balance, introduced at the beginning
   of @l(#3.1.1):

   ..srci > scheme
     > (withdraw 25)
     75
     > (withdraw 25)
     50
   < srci..

   Here successive evaluations of the same expression yield different values.
   This behavior arises from the fact that the execution of assignment statements
   (in this case, assignments to the variable @c(balance)) delineates @e(moments
   in time) when values change. The result of evaluating an expression depends
   not only on the expression itself, but also on whether the evaluation occurs
   before or after these moments. Building models in terms of computational
   objects with local state forces us to confront time as an essential concept in
   programming.

   We can go further in structuring computational models to match our perception
   of the physical world. Objects in the world do not change one at a time in
   sequence. Rather we perceive them as acting @e(concurrently)––all at once. So
   it is often natural to model systems as collections of computational processes
   that execute concurrently. Just as we can make our programs modular by
   organizing models in terms of objects with separate local state, it is often
   appropriate to divide computational models into parts that evolve separately
   and concurrently. Even if the programs are to be executed on a sequential
   computer, the practice of writing programs as if they were to be executed
   concurrently forces the programmer to avoid inessential timing constraints and
   thus makes programs more modular.

   In addition to making programs more modular, concurrent computation can
   provide a speed advantage over sequential computation. Sequential computers
   execute only one operation at a time, so the amount of time it takes to
   perform a task is proportional to the total number of operations
   performed.@n(162) However, if it is possible to decompose a problem into
   pieces that are relatively independent and need to communicate only rarely, it
   may be possible to allocate pieces to separate computing processors, producing
   a speed advantage proportional to the number of processors available.

   Unfortunately, the complexities introduced by assignment become even more
   problematic in the presence of concurrency. The fact of concurrent execution,
   either because the world operates in parallel or because our computers do,
   entails additional complexity in our understanding of time.

*** 3.4.1 <> The Nature of Time in Concurrent Systems

    On the surface, time seems straightforward. It is an ordering imposed on
    events.@n(163) For any events @m(a) and @m(B), either @m(a) occurs before
    @m(B), @m(a) and @m(B) are simultaneous, or @m(a) occurs after @m(B). For
    instance, returning to the bank account example, suppose that Peter withdraws
    $10 and Paul withdraws $25 from a joint account that initially contains $100,
    leaving $65 in the account. Depending on the order of the two withdrawals, the
    sequence of balances in the account is either $100 → $90 → $65 or $100 → $75 →
    $65. In a computer implementation of the banking system, this changing
    sequence of balances could be modeled by successive assignments to a variable
    @c(balance).

    In complex situations, however, such a view can be problematic. Suppose that
    Peter and Paul, and other people besides, are accessing the same bank account
    through a network of banking machines distributed all over the world. The
    actual sequence of balances in the account will depend critically on the
    detailed timing of the accesses and the details of the communication among the
    machines.

    This indeterminacy in the order of events can pose serious problems in the
    design of concurrent systems. For instance, suppose that the withdrawals made
    by Peter and Paul are implemented as two separate processes sharing a common
    variable @c(balance), each process specified by the procedure given in
    @l(#3.1.1):

    ..src > scheme
      (define (withdraw amount)
        (if (>= balance amount)
            (begin
              (set! balance
                    (- balance amount))
              balance)
            "Insufficient funds"))
    < src..

    If the two processes operate independently, then Peter might test the balance
    and attempt to withdraw a legitimate amount. However, Paul might withdraw some
    funds in between the time that Peter checks the balance and the time Peter
    completes the withdrawal, thus invalidating Peter's test.

    Things can be worse still. Consider the expression

    ..src > scheme
      (set! balance (- balance amount))
    < src..

    executed as part of each withdrawal process. This consists of three steps: (1)
    accessing the value of the @c(balance) variable; (2) computing the new
    balance; (3) setting @c(balance) to this new value. If Peter and Paul's
    withdrawals execute this statement concurrently, then the two withdrawals
    might interleave the order in which they access @c(balance) and set it to the
    new value.

    The timing diagram in @l(#Figure 3.29) depicts an order of events where
    @c(balance) starts at 100, Peter withdraws 10, Paul withdraws 25, and yet the
    final value of @c(balance) is 75. As shown in the diagram, the reason for this
    anomaly is that Paul's assignment of 75 to @c(balance) is made under the
    assumption that the value of @c(balance) to be decremented is 100.  That
    assumption, however, became invalid when Peter changed @c(balance) to 90.
    This is a catastrophic failure for the banking system, because the total
    amount of money in the system is not conserved. Before the transactions, the
    total amount of money was $100. Afterwards, Peter has $10, Paul has $25, and
    the bank has $75.@n(164)

    ..figure > @t(Figure 3.29) Timing diagram showing how interleaving the order
      of events in two banking withdrawals can lead to an incorrect final balance.

      ..art >
         │           Peter              Bank              Paul
         │                              ____
         │                             ╱    ╲
         │             ╭──────────────( $100 )─────────────╮
         │             │               ╲____╱              │
         │             ▼                                   ▼
         │  ╭──────────────────────╮            ╭──────────────────────╮
         │  │ Access balance: $100 │            │ Access balance: $100 │
         │  ╰──────────┬───────────╯            ╰──────────┬───────────╯
         │             ▼                                   ▼
         │  ╭──────────────────────╮            ╭──────────────────────╮
         │  │ new value: 100─10=90 │            │ new value: 100─25=75 │
         │  ╰──────────┬───────────╯            ╰──────────┬───────────╯
         │             ▼                                   │
         │  ╭──────────────────────╮                       │
         │  │ set! balance to $90  │                       │
         │  ╰──────────┬───────────╯    ____               │
         │             │               ╱    ╲              │
         │             ╰─────────────>( $ 90 )             ▼
         │                             ╲____╱   ╭──────────────────────╮
         │                                      │ new value: 100─25=75 │
         │                              ____    ╰──────────┬───────────╯
         │                             ╱    ╲              │
         │                            ( $ 90 )<────────────╯
         ▼                             ╲____╱
        time
      < art..

@   ..img > img/chap3/Fig3.29b.std.svg

    The general phenomenon illustrated here is that several processes may share a
    common state variable. What makes this complicated is that more than one
    process may be trying to manipulate the shared state at the same time. For the
    bank account example, during each transaction, each customer should be able to
    act as if the other customers did not exist. When a customer changes the
    balance in a way that depends on the balance, he must be able to assume that,
    just before the moment of change, the balance is still what he thought it was.

**** Correct behavior of concurrent programs

     The above example typifies the subtle bugs that can creep into concurrent
     programs. The root of this complexity lies in the assignments to variables
     that are shared among the different processes. We already know that we must be
     careful in writing programs that use @c(set!), because the results of a
     computation depend on the order in which the assignments occur.@n(165) With
     concurrent processes we must be especially careful about assignments, because
     we may not be able to control the order of the assignments made by the
     different processes. If several such changes might be made concurrently (as
     with two depositors accessing a joint account) we need some way to ensure that
     our system behaves correctly. For example, in the case of withdrawals from a
     joint bank account, we must ensure that money is conserved. To make concurrent
     programs behave correctly, we may have to place some restrictions on
     concurrent execution.

     One possible restriction on concurrency would stipulate that no two operations
     that change any shared state variables can occur at the same time. This is an
     extremely stringent requirement. For distributed banking, it would require the
     system designer to ensure that only one transaction could proceed at a time.
     This would be both inefficient and overly conservative. @l(#Figure 3.30) shows
     Peter and Paul sharing a bank account, where Paul has a private account as
     well. The diagram illustrates two withdrawals from the shared account (one by
     Peter and one by Paul) and a deposit to Paul's private account.@n(166) The two
     withdrawals from the shared account must not be concurrent (since both access
     and update the same account), and Paul's deposit and withdrawal must not be
     concurrent (since both access and update the amount in Paul's wallet). But
     there should be no problem permitting Paul's deposit to his private account to
     proceed concurrently with Peter's withdrawal from the shared account.

     ..figure > @t(Figure 3.30) Concurrent deposits and withdrawals from a joint
       account in Bank1 and a private account in Bank2.

       ..art >
          │    Peter          Bank1          Paul           Bank2
          │    ____           ____           ____           ____
          │   ╱    ╲         ╱    ╲         ╱    ╲         ╱    ╲
          │  (  $7  )──╮ ╭──( $100 )       (  $5  )──╮ ╭──( $300 )
          │   ╲____╱   ▼ ▼   ╲____╱         ╲____╱   ▼ ▼   ╲____╱
          │           ╭───╮                         ╭───╮
          │           │ W │                         │ D │
          │    ____   ╰┬─┬╯   ____           ____   ╰┬─┬╯   ____
          │   ╱    ╲   │ │   ╱    ╲         ╱    ╲   │ │   ╱    ╲
          │  ( $17  )◀─╯ ╰─▶( $90  )──╮ ╭──(  $0  )◀─╯ ╰─▶( $305 )
          │   ╲____╱         ╲____╱   ▼ ▼   ╲____╱         ╲____╱
          │                          ╭───╮
          │                          │ W │
          │    ____           ____   ╰┬─┬╯   ____           ____
          │   ╱    ╲         ╱    ╲   │ │   ╱    ╲         ╱    ╲
          │  ( $17  )       ( $65  )◀─╯ ╰─▶( $25  )       ( $305 )
          │   ╲____╱         ╲____╱         ╲____╱         ╲____╱
          ▼
         time
       < art..

@    ..img > img/chap3/Fig3.30c.std.svg

     A less stringent restriction on concurrency would ensure that a concurrent
     system produces the same result as if the processes had run sequentially in
     some order. There are two important aspects to this requirement. First, it
     does not require the processes to actually run sequentially, but only to
     produce results that are the same @e(as if) they had run sequentially. For the
     example in @l(#Figure 3.30), the designer of the bank account system can
     safely allow Paul's deposit and Peter's withdrawal to happen concurrently,
     because the net result will be the same as if the two operations had happened
     sequentially. Second, there may be more than one possible @"(correct) result
     produced by a concurrent program, because we require only that the result be
     the same as for @e(some) sequential order. For example, suppose that Peter and
     Paul's joint account starts out with $100, and Peter deposits $40 while Paul
     concurrently withdraws half the money in the account. Then sequential
     execution could result in the account balance being either $70 or $90 (see
     @l(#Exercise 3.38)).@n(167)

     There are still weaker requirements for correct execution of concurrent
     programs. A program for simulating diffusion (say, the flow of heat in an
     object) might consist of a large number of processes, each one representing a
     small volume of space, that update their values concurrently. Each process
     repeatedly changes its value to the average of its own value and its
     neighbors' values. This algorithm converges to the right answer independent of
     the order in which the operations are done; there is no need for any
     restrictions on concurrent use of the shared values.

     :: @t(Exercise 3.38) :: Suppose that Peter, Paul, and Mary share a joint bank
        account that initially contains $100. Concurrently, Peter deposits $10,
        Paul withdraws $20, and Mary withdraws half the money in the account, by
        executing the following commands:

        ..example >
          Peter: (set! balance (+ balance 10))
          Paul:  (set! balance (- balance 20))
          Mary:  (set! balance (- balance
                                  (/ balance 2)))
        < example..

        1. List all the different possible values for @c(balance) after these three
           transactions have been completed, assuming that the banking system
           forces the three processes to run sequentially in some order.

        2. What are some other values that could be produced if the system allows
           the processes to be interleaved?  Draw timing diagrams like the one in
           @l(#Figure 3.29) to explain how these values can occur.

*** 3.4.2 <> Mechanisms for Controlling Concurrency

    We've seen that the difficulty in dealing with concurrent processes is rooted
    in the need to consider the interleaving of the order of events in the
    different processes. For example, suppose we have two processes, one with
    three ordered events @m[(a, b, c)] and one with three ordered events @m[(x, y,
    z)]. If the two processes run concurrently, with no constraints on how their
    execution is interleaved, then there are 20 different possible orderings for
    the events that are consistent with the individual orderings for the two
    processes:

    ..example >
      (a,b,c,x,y,z)  (a,x,b,y,c,z)  (x,a,b,c,y,z)
      (x,a,y,z,b,c)  (a,b,x,c,y,z)  (a,x,b,y,z,c)
      (x,a,b,y,c,z)  (x,y,a,b,c,z)  (a,b,x,y,c,z)
      (a,x,y,b,c,z)  (x,a,b,y,z,c)  (x,y,a,b,z,c)
      (a,b,x,y,z,c)  (a,x,y,b,z,c)  (x,a,y,b,c,z)
      (x,y,a,z,b,c)  (a,x,b,c,y,z)  (a,x,y,z,b,c)
      (x,a,y,b,z,c)  (x,y,z,a,b,c)
    < example..

    As programmers designing this system, we would have to consider the effects of
    each of these 20 orderings and check that each behavior is acceptable. Such an
    approach rapidly becomes unwieldy as the numbers of processes and events
    increase.

    A more practical approach to the design of concurrent systems is to devise
    general mechanisms that allow us to constrain the interleaving of concurrent
    processes so that we can be sure that the program behavior is correct. Many
    mechanisms have been developed for this purpose. In this section, we describe
    one of them, the @e(serializer).

**** Serializing access to shared state

     Serialization implements the following idea: Processes will execute
     concurrently, but there will be certain collections of procedures that cannot
     be executed concurrently. More precisely, serialization creates distinguished
     sets of procedures such that only one execution of a procedure in each
     serialized set is permitted to happen at a time. If some procedure in the set
     is being executed, then a process that attempts to execute any procedure in
     the set will be forced to wait until the first execution has finished.

     We can use serialization to control access to shared variables. For example,
     if we want to update a shared variable based on the previous value of that
     variable, we put the access to the previous value of the variable and the
     assignment of the new value to the variable in the same procedure. We then
     ensure that no other procedure that assigns to the variable can run
     concurrently with this procedure by serializing all of these procedures with
     the same serializer. This guarantees that the value of the variable cannot be
     changed between an access and the corresponding assignment.

**** Serializers in Scheme

     To make the above mechanism more concrete, suppose that we have extended
     Scheme to include a procedure called @c(parallel-execute):

     ..src > scheme
       (parallel-execute ⟨p₁⟩
                         ⟨p₂⟩
                         …
                         ⟨pₖ⟩)
     < src..

     Each @c[(p)] must be a procedure of no arguments. @c(Parallel-execute) creates
     a separate process for each @c[(p)], which applies @c[(p)] (to no
     arguments). These processes all run concurrently.@n(168)

     As an example of how this is used, consider

     ..src > scheme
       (define x 10)
       (parallel-execute (lambda () (set! x (* x x)))
                         (lambda () (set! x (+ x 1))))
     < src..

     This creates two concurrent processes––@m(P₁), which sets @c(x) to @c(x) times
     @c(x), and @m(P₂), which increments @c(x). After execution is complete, @c(x)
     will be left with one of five possible values, depending on the interleaving
     of the events of @m(P₁) and @m(P₂):

     - 101: @m(P₁) sets @c(x) to 100 and then @m(P₂) increments
            @c(x) to 101.

     - 121: @m(P₂) increments @c(x) to 11 and then @m(P₁) sets
            @c(x) to @c(x) times @c(x).

     - 110: @m(P₂) changes @c(x) from 10 to 11 between the
            two times that @m(P₁) accesses the value of
            @c(x) during the evaluation of @c[(* x x)].

     - 11: @m(P₂) accesses @c(x), then @m(P₁) sets @c(x) to 100,
            then @m(P₂) sets @c(x).

     - 100: @m(P₁) accesses @c(x) (twice), then @m(P₂) sets
            @c(x) to 11, then @m(P₁) sets @c(x).

     We can constrain the concurrency by using serialized procedures, which are
     created by @e(serializers). Serializers are constructed by
     @c(make-serializer), whose implementation is given below. A serializer takes a
     procedure as argument and returns a serialized procedure that behaves like the
     original procedure. All calls to a given serializer return serialized
     procedures in the same set.

     Thus, in contrast to the example above, executing

     ..src > scheme
       (define x 10)
       (define s (make-serializer))
       (parallel-execute
        (s (lambda () (set! x (* x x))))
        (s (lambda () (set! x (+ x 1)))))
     < src..

     can produce only two possible values for @c(x), 101 or 121. The other
     possibilities are eliminated, because the execution of @m(P₁) and @m(P₂)
     cannot be interleaved.

     Here is a version of the @c(make-account) procedure from @l(#3.1.1), where the
     deposits and withdrawals have been serialized:

     ..src > scheme
       (define (make-account balance)
         (define (withdraw amount)
           (if (>= balance amount)
               (begin (set! balance
                            (- balance amount))
                      balance)
               "Insufficient funds"))
         (define (deposit amount)
           (set! balance (+ balance amount))
           balance)
         (let ((protected (make-serializer)))
           (define (dispatch m)
             (cond ((eq? m 'withdraw)
                    (protected withdraw))
                   ((eq? m 'deposit)
                    (protected deposit))
                   ((eq? m 'balance)
                    balance)
                   (else (error "Unknown request:
                                 MAKE-ACCOUNT"
                                m))))
           dispatch))
     < src..

     With this implementation, two processes cannot be withdrawing from or
     depositing into a single account concurrently. This eliminates the source of
     the error illustrated in @l(#Figure 3.29), where Peter changes the account
     balance between the times when Paul accesses the balance to compute the new
     value and when Paul actually performs the assignment. On the other hand, each
     account has its own serializer, so that deposits and withdrawals for different
     accounts can proceed concurrently.

     :: @t(Exercise 3.39) :: Which of the five possibilities in the parallel
        execution shown above remain if we instead serialize execution as follows:

        ..src > scheme
          (define x 10)
          (define s (make-serializer))
          (parallel-execute
            (lambda ()
              (set! x ((s (lambda () (* x x))))))
            (s (lambda () (set! x (+ x 1)))))
        < src..

     :: @t(Exercise 3.40) :: Give all possible values of @c(x) that can result from
        executing

        ..src > scheme
          (define x 10)
          (parallel-execute
           (lambda () (set! x (* x x)))
           (lambda () (set! x (* x x x))))
        < src..

        Which of these possibilities remain if we instead use serialized
        procedures:

        ..src > scheme
          (define x 10)
          (define s (make-serializer))
          (parallel-execute
           (s (lambda () (set! x (* x x))))
           (s (lambda () (set! x (* x x x)))))
        < src..

     :: @t(Exercise 3.41) :: Ben Bitdiddle worries that it would be better to
        implement the bank account as follows (where the commented line has been
        changed):

        ..src > scheme
          (define (make-account balance)
            (define (withdraw amount)
              (if (>= balance amount)
                  (begin
                    (set! balance
                          (- balance amount))
                    balance)
                  "Insufficient funds"))
            (define (deposit amount)
              (set! balance (+ balance amount))
              balance)
            (let ((protected (make-serializer)))
              (define (dispatch m)
                (cond ((eq? m 'withdraw)
                       (protected withdraw))
                      ((eq? m 'deposit)
                       (protected deposit))
                      ((eq? m 'balance)
                       ((protected
                          (lambda ()
                            balance)))) ; serialized
                      (else
                       (error
                        "Unknown request:
                         MAKE-ACCOUNT"
                        m))))
              dispatch))
        < src..

        because allowing unserialized access to the bank balance can result in
        anomalous behavior. Do you agree?  Is there any scenario that demonstrates
        Ben's concern?

     :: @t(Exercise 3.42) :: Ben Bitdiddle suggests that it's a waste of time to
        create a new serialized procedure in response to every @c(withdraw) and
        @c(deposit) message. He says that @c(make-account) could be changed so that
        the calls to @c(protected) are done outside the @c(dispatch)
        procedure. That is, an account would return the same serialized procedure
        (which was created at the same time as the account) each time it is asked
        for a withdrawal procedure.

        ..src > scheme
          (define (make-account balance)
            (define (withdraw amount)
              (if (>= balance amount)
                  (begin (set! balance
                               (- balance amount))
                         balance)
                  "Insufficient funds"))
            (define (deposit amount)
              (set! balance (+ balance amount))
              balance)
            (let ((protected (make-serializer)))
              (let ((protected-withdraw
                     (protected withdraw))
                    (protected-deposit
                     (protected deposit)))
                (define (dispatch m)
                  (cond ((eq? m 'withdraw)
                         protected-withdraw)
                        ((eq? m 'deposit)
                         protected-deposit)
                        ((eq? m 'balance)
                         balance)
                        (else
                         (error "Unknown request:
                                 MAKE-ACCOUNT"
                                m))))
                dispatch)))
        < src..

        Is this a safe change to make?  In particular, is there any difference in
        what concurrency is allowed by these two versions of @c(make-account)?

**** Complexity of using multiple shared resources

     Serializers provide a powerful abstraction that helps isolate the complexities
     of concurrent programs so that they can be dealt with carefully and
     (hopefully) correctly. However, while using serializers is relatively
     straightforward when there is only a single shared resource (such as a single
     bank account), concurrent programming can be treacherously difficult when
     there are multiple shared resources.

     To illustrate one of the difficulties that can arise, suppose we wish to swap
     the balances in two bank accounts. We access each account to find the balance,
     compute the difference between the balances, withdraw this difference from one
     account, and deposit it in the other account. We could implement this as
     follows:@n(169)

     ..src > scheme
       (define (exchange account1 account2)
         (let ((difference (- (account1 'balance)
                              (account2 'balance))))
           ((account1 'withdraw) difference)
           ((account2 'deposit) difference)))
     < src..

     This procedure works well when only a single process is trying to do the
     exchange. Suppose, however, that Peter and Paul both have access to accounts
     @m(a1), @m(a2), and @m(a3), and that Peter exchanges @m(a1) and @m(a2) while
     Paul concurrently exchanges @m(a1) and @m(a3). Even with account deposits and
     withdrawals serialized for individual accounts (as in the @c(make-account)
     procedure shown above in this section), @c(exchange) can still produce
     incorrect results. For example, Peter might compute the difference in the
     balances for @m(a1) and @m(a2), but then Paul might change the balance in
     @m(a1) before Peter is able to complete the exchange.@n(170) For correct
     behavior, we must arrange for the @c(exchange) procedure to lock out any other
     concurrent accesses to the accounts during the entire time of the exchange.

     One way we can accomplish this is by using both accounts' serializers to
     serialize the entire @c(exchange) procedure. To do this, we will arrange for
     access to an account's serializer. Note that we are deliberately breaking the
     modularity of the bank-account object by exposing the serializer. The
     following version of @c(make-account) is identical to the original version
     given in @l(#3.1.1), except that a serializer is provided to protect the
     balance variable, and the serializer is exported via message passing:

     ..src > scheme
       (define (make-account-and-serializer balance)
         (define (withdraw amount)
           (if (>= balance amount)
               (begin
                 (set! balance (- balance amount))
                 balance)
               "Insufficient funds"))
         (define (deposit amount)
           (set! balance (+ balance amount))
           balance)
         (let ((balance-serializer
                (make-serializer)))
           (define (dispatch m)
             (cond ((eq? m 'withdraw) withdraw)
                   ((eq? m 'deposit) deposit)
                   ((eq? m 'balance) balance)
                   ((eq? m 'serializer)
                    balance-serializer)
                   (else (error "Unknown request:
                                 MAKE-ACCOUNT"
                                m))))
           dispatch))
     < src..

     We can use this to do serialized deposits and withdrawals. However, unlike our
     earlier serialized account, it is now the responsibility of each user of
     bank-account objects to explicitly manage the serialization, for example as
     follows:@n(171)

     ..src > scheme
       (define (deposit account amount)
         (let ((s (account 'serializer))
               (d (account 'deposit)))
           ((s d) amount)))
     < src..

     Exporting the serializer in this way gives us enough flexibility to implement
     a serialized exchange program. We simply serialize the original @c(exchange)
     procedure with the serializers for both accounts:

     ..src > scheme
       (define (serialized-exchange account1 account2)
         (let ((serializer1 (account1 'serializer))
               (serializer2 (account2 'serializer)))
           ((serializer1 (serializer2 exchange))
            account1
            account2)))
     < src..

     :: @t(Exercise 3.43) :: Suppose that the balances in three accounts start out
        as $10, $20, and $30, and that multiple processes run, exchanging the
        balances in the accounts. Argue that if the processes are run sequentially,
        after any number of concurrent exchanges, the account balances should be
        $10, $20, and $30 in some order. Draw a timing diagram like the one in
        @l(#Figure 3.29) to show how this condition can be violated if the
        exchanges are implemented using the first version of the account-exchange
        program in this section. On the other hand, argue that even with this
        @c(exchange) program, the sum of the balances in the accounts will be
        preserved. Draw a timing diagram to show how even this condition would be
        violated if we did not serialize the transactions on individual accounts.

     :: @t(Exercise 3.44) :: Consider the problem of transferring an amount from
        one account to another. Ben Bitdiddle claims that this can be accomplished
        with the following procedure, even if there are multiple people
        concurrently transferring money among multiple accounts, using any account
        mechanism that serializes deposit and withdrawal transactions, for example,
        the version of @c(make-account) in the text above.

        ..src > scheme
          (define
            (transfer from-account to-account amount)
            ((from-account 'withdraw) amount)
            ((to-account 'deposit) amount))
        < src..

        Louis Reasoner claims that there is a problem here, and that we need to use
        a more sophisticated method, such as the one required for dealing with the
        exchange problem. Is Louis right?  If not, what is the essential difference
        between the transfer problem and the exchange problem?  (You should assume
        that the balance in @c(from-account) is at least @c(amount).)

     :: @t(Exercise 3.45) :: Louis Reasoner thinks our bank-account system is
        unnecessarily complex and error-prone now that deposits and withdrawals
        aren't automatically serialized. He suggests that
        @c(make-account-and-serializer) should have exported the serializer (for
        use by such procedures as @c(serialized-exchange)) in addition to (rather
        than instead of) using it to serialize accounts and deposits as
        @c(make-account) did. He proposes to redefine accounts as follows:

        ..src > scheme
          (define
            (make-account-and-serializer balance)
            (define (withdraw amount)
              (if (>= balance amount)
                  (begin (set! balance
                               (- balance amount))
                         balance)
                  "Insufficient funds"))
            (define (deposit amount)
              (set! balance (+ balance amount))
              balance)
            (let ((balance-serializer
                   (make-serializer)))
              (define (dispatch m)
                (cond ((eq? m 'withdraw)
                       (balance-serializer withdraw))
                      ((eq? m 'deposit)
                       (balance-serializer deposit))
                      ((eq? m 'balance)
                       balance)
                      ((eq? m 'serializer)
                       balance-serializer)
                      (else (error "Unknown request:
                                    MAKE-ACCOUNT"
                                   m))))
              dispatch))
        < src..

        Then deposits are handled as with the original @c(make-account):

        ..src > scheme
          (define (deposit account amount)
            ((account 'deposit) amount))
        < src..

        Explain what is wrong with Louis's reasoning. In particular, consider what
        happens when @c(serialized-exchange) is called.

**** Implementing serializers

     We implement serializers in terms of a more primitive synchronization
     mechanism called a @e(mutex). A mutex is an object that supports two
     operations––the mutex can be @e(acquired), and the mutex can be
     @e(released). Once a mutex has been acquired, no other acquire operations on
     that mutex may proceed until the mutex is released.@n(172) In our
     implementation, each serializer has an associated mutex. Given a procedure
     @c(p), the serializer returns a procedure that acquires the mutex, runs @c(p),
     and then releases the mutex. This ensures that only one of the procedures
     produced by the serializer can be running at once, which is precisely the
     serialization property that we need to guarantee.

     ..src > scheme
       (define (make-serializer)
         (let ((mutex (make-mutex)))
           (lambda (p)
             (define (serialized-p . args)
               (mutex 'acquire)
               (let ((val (apply p args)))
                 (mutex 'release)
                 val))
             serialized-p)))
     < src..

     The mutex is a mutable object (here we'll use a one-element list, which we'll
     refer to as a @e(cell)) that can hold the value true or false. When the value
     is false, the mutex is available to be acquired. When the value is true, the
     mutex is unavailable, and any process that attempts to acquire the mutex must
     wait.

     Our mutex constructor @c(make-mutex) begins by initializing the cell contents
     to false. To acquire the mutex, we test the cell. If the mutex is available,
     we set the cell contents to true and proceed. Otherwise, we wait in a loop,
     attempting to acquire over and over again, until we find that the mutex is
     available.@n(173) To release the mutex, we set the cell contents to false.

     ..src > scheme
       (define (make-mutex)
         (let ((cell (list false)))
           (define (the-mutex m)
             (cond ((eq? m 'acquire)
                    (if (test-and-set! cell)
                        (the-mutex 'acquire))) ; retry
                   ((eq? m 'release) (clear! cell))))
           the-mutex))
       (define (clear! cell) (set-car! cell false))
     < src..

     @c(Test-and-set!) tests the cell and returns the result of the test. In
     addition, if the test was false, @c(test-and-set!) sets the cell contents to
     true before returning false. We can express this behavior as the following
     procedure:

     ..src > scheme
       (define (test-and-set! cell)
         (if (car cell)
             true
             (begin (set-car! cell true)
                    false)))
     < src..

     However, this implementation of @c(test-and-set!) does not suffice as it
     stands. There is a crucial subtlety here, which is the essential place where
     concurrency control enters the system: The @c(test-and-set!) operation must be
     performed @e(atomically). That is, we must guarantee that, once a process has
     tested the cell and found it to be false, the cell contents will actually be
     set to true before any other process can test the cell. If we do not make this
     guarantee, then the mutex can fail in a way similar to the bank-account
     failure in @l(#Figure 3.29). (See @l(#Exercise 3.46).)

     The actual implementation of @c(test-and-set!) depends on the details of how
     our system runs concurrent processes. For example, we might be executing
     concurrent processes on a sequential processor using a time-slicing mechanism
     that cycles through the processes, permitting each process to run for a short
     time before interrupting it and moving on to the next process. In that case,
     @c(test-and-set!)  can work by disabling time slicing during the testing and
     setting.@n(174) Alternatively, multiprocessing computers provide instructions
     that support atomic operations directly in hardware.@n(175)

     :: @t(Exercise 3.46) :: Suppose that we implement @c(test-and-set!)  using an
        ordinary procedure as shown in the text, without attempting to make the
        operation atomic. Draw a timing diagram like the one in @l(#Figure 3.29) to
        demonstrate how the mutex implementation can fail by allowing two processes
        to acquire the mutex at the same time.

     :: @t(Exercise 3.47) :: A semaphore (of size @m(n)) is a generalization of a
        mutex. Like a mutex, a semaphore supports acquire and release operations,
        but it is more general in that up to @m(n) processes can acquire it
        concurrently. Additional processes that attempt to acquire the semaphore
        must wait for release operations. Give implementations of semaphores

        1. in terms of mutexes

        2. in terms of atomic @c(test-and-set!) operations.

**** Deadlock

     Now that we have seen how to implement serializers, we can see that account
     exchanging still has a problem, even with the @c(serialized-exchange)
     procedure above. Imagine that Peter attempts to exchange @m(a1) with @m(a2)
     while Paul concurrently attempts to exchange @m(a2) with @m(a1). Suppose that
     Peter's process reaches the point where it has entered a serialized procedure
     protecting @m(a1) and, just after that, Paul's process enters a serialized
     procedure protecting @m(a2). Now Peter cannot proceed (to enter a serialized
     procedure protecting @m(a2)) until Paul exits the serialized procedure
     protecting @m(a2). Similarly, Paul cannot proceed until Peter exits the
     serialized procedure protecting @m(a1). Each process is stalled forever,
     waiting for the other. This situation is called a @e(deadlock).  Deadlock is
     always a danger in systems that provide concurrent access to multiple shared
     resources.

     One way to avoid the deadlock in this situation is to give each account a
     unique identification number and rewrite @c(serialized-exchange) so that a
     process will always attempt to enter a procedure protecting the
     lowest-numbered account first. Although this method works well for the
     exchange problem, there are other situations that require more sophisticated
     deadlock-avoidance techniques, or where deadlock cannot be avoided at
     all. (See @l(#Exercise 3.48) and @l(#Exercise 3.49).)@n(176)

     :: @t(Exercise 3.48) :: Explain in detail why the deadlock-avoidance method
        described above, (i.e., the accounts are numbered, and each process
        attempts to acquire the smaller-numbered account first) avoids deadlock in
        the exchange problem. Rewrite @c(serialized-exchange) to incorporate this
        idea. (You will also need to modify @c(make-account) so that each account
        is created with a number, which can be accessed by sending an appropriate
        message.)

     :: @t(Exercise 3.49) :: Give a scenario where the deadlock-avoidance mechanism
        described above does not work. (Hint: In the exchange problem, each process
        knows in advance which accounts it will need to get access to. Consider a
        situation where a process must get access to some shared resources before
        it can know which additional shared resources it will require.)

**** Concurrency, time, and communication

     We've seen how programming concurrent systems requires controlling the
     ordering of events when different processes access shared state, and we've
     seen how to achieve this control through judicious use of serializers. But the
     problems of concurrency lie deeper than this, because, from a fundamental
     point of view, it's not always clear what is meant by @"(shared state.)

     Mechanisms such as @c(test-and-set!) require processes to examine a global
     shared flag at arbitrary times. This is problematic and inefficient to
     implement in modern high-speed processors, where due to optimization
     techniques such as pipelining and cached memory, the contents of memory may
     not be in a consistent state at every instant. In contemporary multiprocessing
     systems, therefore, the serializer paradigm is being supplanted by new
     approaches to concurrency control.@n(177)

     The problematic aspects of shared state also arise in large, distributed
     systems. For instance, imagine a distributed banking system where individual
     branch banks maintain local values for bank balances and periodically compare
     these with values maintained by other branches. In such a system the value of
     @"(the account balance) would be undetermined, except right after
     synchronization. If Peter deposits money in an account he holds jointly with
     Paul, when should we say that the account balance has changed––when the
     balance in the local branch changes, or not until after the synchronization?
     And if Paul accesses the account from a different branch, what are the
     reasonable constraints to place on the banking system such that the behavior
     is @"(correct)?  The only thing that might matter for correctness is the
     behavior observed by Peter and Paul individually and the @"(state) of the
     account immediately after synchronization. Questions about the @"(real)
     account balance or the order of events between synchronizations may be
     irrelevant or meaningless.@n(178)

     The basic phenomenon here is that synchronizing different processes,
     establishing shared state, or imposing an order on events requires
     communication among the processes. In essence, any notion of time in
     concurrency control must be intimately tied to communication.@n(179) It is
     intriguing that a similar connection between time and communication also
     arises in the Theory of Relativity, where the speed of light (the fastest
     signal that can be used to synchronize events) is a fundamental constant
     relating time and space. The complexities we encounter in dealing with time
     and state in our computational models may in fact mirror a fundamental
     complexity of the physical universe.

** 3.5 <> Streams

   We've gained a good understanding of assignment as a tool in modeling, as well
   as an appreciation of the complex problems that assignment raises. It is time
   to ask whether we could have gone about things in a different way, so as to
   avoid some of these problems. In this section, we explore an alternative
   approach to modeling state, based on data structures called @e(streams).  As
   we shall see, streams can mitigate some of the complexity of modeling state.

   Let's step back and review where this complexity comes from. In an attempt to
   model real-world phenomena, we made some apparently reasonable decisions: We
   modeled real-world objects with local state by computational objects with
   local variables. We identified time variation in the real world with time
   variation in the computer. We implemented the time variation of the states of
   the model objects in the computer with assignments to the local variables of
   the model objects.

   Is there another approach?  Can we avoid identifying time in the computer with
   time in the modeled world?  Must we make the model change with time in order
   to model phenomena in a changing world?  Think about the issue in terms of
   mathematical functions. We can describe the time-varying behavior of a
   quantity @m(x) as a function of time @m[x(t)]. If we concentrate on @m(x)
   instant by instant, we think of it as a changing quantity. Yet if we
   concentrate on the entire time history of values, we do not emphasize
   change––the function itself does not change.@n(180)

   If time is measured in discrete steps, then we can model a time function as a
   (possibly infinite) sequence. In this section, we will see how to model change
   in terms of sequences that represent the time histories of the systems being
   modeled. To accomplish this, we introduce new data structures called
   @e(streams). From an abstract point of view, a stream is simply a
   sequence. However, we will find that the straightforward implementation of
   streams as lists (as in @l(#2.2.1)) doesn't fully reveal the power of stream
   processing. As an alternative, we introduce the technique of @e(delayed
   evaluation), which enables us to represent very large (even infinite)
   sequences as streams.

   Stream processing lets us model systems that have state without ever using
   assignment or mutable data. This has important implications, both theoretical
   and practical, because we can build models that avoid the drawbacks inherent
   in introducing assignment. On the other hand, the stream framework raises
   difficulties of its own, and the question of which modeling technique leads to
   more modular and more easily maintained systems remains open.

*** 3.5.1 <> Streams Are Delayed Lists

    As we saw in @l(#2.2.3), sequences can serve as standard interfaces for
    combining program modules. We formulated powerful abstractions for
    manipulating sequences, such as @c(map), @c(filter), and @c(accumulate), that
    capture a wide variety of operations in a manner that is both succinct and
    elegant.

    Unfortunately, if we represent sequences as lists, this elegance is bought at
    the price of severe inefficiency with respect to both the time and space
    required by our computations. When we represent manipulations on sequences as
    transformations of lists, our programs must construct and copy data structures
    (which may be huge) at every step of a process.

    To see why this is true, let us compare two programs for computing the sum of
    all the prime numbers in an interval. The first program is written in standard
    iterative style:@n(181)

    ..src > scheme
      (define (sum-primes a b)
        (define (iter count accum)
          (cond ((> count b) accum)
                ((prime? count)
                 (iter (+ count 1)
                       (+ count accum)))
                (else (iter (+ count 1) accum))))
        (iter a 0))
    < src..

    The second program performs the same computation using the sequence operations
    of @l(#2.2.3):

    ..src > scheme
      (define (sum-primes a b)
        (accumulate
         +
         0
         (filter prime? (enumerate-interval a b))))
    < src..

    In carrying out the computation, the first program needs to store only the sum
    being accumulated. In contrast, the filter in the second program cannot do any
    testing until @c(enumerate-interval) has constructed a complete list of the
    numbers in the interval. The filter generates another list, which in turn is
    passed to @c(accumulate) before being collapsed to form a sum. Such large
    intermediate storage is not needed by the first program, which we can think of
    as enumerating the interval incrementally, adding each prime to the sum as it
    is generated.

    The inefficiency in using lists becomes painfully apparent if we use the
    sequence paradigm to compute the second prime in the interval from 10,000 to
    1,000,000 by evaluating the expression

    ..src > scheme
      (car (cdr
            (filter
             prime?
             (enumerate-interval 10000 1000000))))
    < src..

    This expression does find the second prime, but the computational overhead is
    outrageous. We construct a list of almost a million integers, filter this list
    by testing each element for primality, and then ignore almost all of the
    result. In a more traditional programming style, we would interleave the
    enumeration and the filtering, and stop when we reached the second prime.

    Streams are a clever idea that allows one to use sequence manipulations
    without incurring the costs of manipulating sequences as lists. With streams
    we can achieve the best of both worlds: We can formulate programs elegantly as
    sequence manipulations, while attaining the efficiency of incremental
    computation. The basic idea is to arrange to construct a stream only
    partially, and to pass the partial construction to the program that consumes
    the stream. If the consumer attempts to access a part of the stream that has
    not yet been constructed, the stream will automatically construct just enough
    more of itself to produce the required part, thus preserving the illusion that
    the entire stream exists. In other words, although we will write programs as
    if we were processing complete sequences, we design our stream implementation
    to automatically and transparently interleave the construction of the stream
    with its use.

    On the surface, streams are just lists with different names for the procedures
    that manipulate them. There is a constructor, @c(cons-stream), and two
    selectors, @c(stream-car) and @c(stream-cdr), which satisfy the constraints

    ..example >
      (stream-car (cons-stream x y)) = x
      (stream-cdr (cons-stream x y)) = y
    < example..

    There is a distinguishable object, @c(the-empty-stream), which cannot be the
    result of any @c(cons-stream) operation, and which can be identified with the
    predicate @c(stream-null?).@n(182) Thus we can make and use streams, in just
    the same way as we can make and use lists, to represent aggregate data
    arranged in a sequence. In particular, we can build stream analogs of the list
    operations from @l(#Chapter 2), such as @c(list-ref), @c(map), and
    @c(for-each):@n(183)

    ..src > scheme
      (define (stream-ref s n)
        (if (= n 0)
            (stream-car s)
            (stream-ref (stream-cdr s) (- n 1))))

      (define (stream-map proc s)
        (if (stream-null? s)
            the-empty-stream
            (cons-stream
             (proc (stream-car s))
             (stream-map proc (stream-cdr s)))))

      (define (stream-for-each proc s)
        (if (stream-null? s)
            'done
            (begin
              (proc (stream-car s))
              (stream-for-each proc
                               (stream-cdr s)))))
    < src..

    @c(Stream-for-each) is useful for viewing streams:

    ..src > scheme
      (define (display-stream s)
        (stream-for-each display-line s))

      (define (display-line x)
        (newline)
        (display x))
    < src..

    To make the stream implementation automatically and transparently interleave
    the construction of a stream with its use, we will arrange for the @c(cdr) of
    a stream to be evaluated when it is accessed by the @c(stream-cdr) procedure
    rather than when the stream is constructed by @c(cons-stream).  This
    implementation choice is reminiscent of our discussion of rational numbers in
    @l(#2.1.2), where we saw that we can choose to implement rational numbers so
    that the reduction of numerator and denominator to lowest terms is performed
    either at construction time or at selection time. The two rational-number
    implementations produce the same data abstraction, but the choice has an
    effect on efficiency. There is a similar relationship between streams and
    ordinary lists. As a data abstraction, streams are the same as lists. The
    difference is the time at which the elements are evaluated. With ordinary
    lists, both the @c(car) and the @c(cdr) are evaluated at construction
    time. With streams, the @c(cdr) is evaluated at selection time.

    Our implementation of streams will be based on a special form called
    @c(delay). Evaluating @c[(delay ⟨exp⟩)] does not evaluate the expression
    @c[(exp)], but rather returns a so-called @e(delayed object), which we can
    think of as a @"(promise) to evaluate @c[(exp)] at some future time. As a
    companion to @c(delay), there is a procedure called @c(force) that takes a
    delayed object as argument and performs the evaluation––in effect, forcing the
    @c(delay) to fulfill its promise. We will see below how @c(delay) and
    @c(force) can be implemented, but first let us use these to construct streams.

    @c(Cons-stream) is a special form defined so that

    ..src > scheme
      (cons-stream ⟨a⟩ ⟨b⟩)
    < src..

    is equivalent to

    ..src > scheme
      (cons ⟨a⟩ (delay ⟨b⟩))
    < src..

    What this means is that we will construct streams using pairs. However, rather
    than placing the value of the rest of the stream into the @c(cdr) of the pair
    we will put there a promise to compute the rest if it is ever requested.
    @c(Stream-car) and @c(stream-cdr) can now be defined as procedures:

    ..src > scheme
      (define (stream-car stream)
        (car stream))

      (define (stream-cdr stream)
        (force (cdr stream)))
    < src..

    @c(Stream-car) selects the @c(car) of the pair; @c(stream-cdr) selects the
    @c(cdr) of the pair and evaluates the delayed expression found there to obtain
    the rest of the stream.@n(184)

**** The stream implementation in action

     To see how this implementation behaves, let us analyze the @"(outrageous)
     prime computation we saw above, reformulated in terms of streams:

     ..src > scheme
       (stream-car
        (stream-cdr
         (stream-filter
          prime? (stream-enumerate-interval
                  10000 1000000))))
     < src..

     We will see that it does indeed work efficiently.

     We begin by calling @c(stream-enumerate-interval) with the arguments 10,000
     and 1,000,000. @c(Stream-enumerate-interval) is the stream analog of
     @c(enumerate-interval) (@l(#2.2.3)):

     ..src > scheme
       (define (stream-enumerate-interval low high)
         (if (> low high)
             the-empty-stream
             (cons-stream
              low
              (stream-enumerate-interval (+ low 1)
                                         high))))
     < src..

     and thus the result returned by @c(stream-enumerate-interval), formed by the
     @c(cons-stream), is@n(185)

     ..src > scheme
       (cons 10000
             (delay
               (stream-enumerate-interval
                10001
                1000000)))
     < src..

     That is, @c(stream-enumerate-interval) returns a stream represented as a pair
     whose @c(car) is 10,000 and whose @c(cdr) is a promise to enumerate more of
     the interval if so requested. This stream is now filtered for primes, using
     the stream analog of the @c(filter) procedure (@l(#2.2.3)):

     ..src > scheme
       (define (stream-filter pred stream)
         (cond ((stream-null? stream)
                the-empty-stream)
               ((pred (stream-car stream))
                (cons-stream
                 (stream-car stream)
                 (stream-filter
                  pred
                  (stream-cdr stream))))
               (else (stream-filter
                      pred
                      (stream-cdr stream)))))
     < src..

     @c(Stream-filter) tests the @c(stream-car) of the stream (the @c(car) of the
     pair, which is 10,000). Since this is not prime, @c(stream-filter) examines
     the @c(stream-cdr) of its input stream. The call to @c(stream-cdr) forces
     evaluation of the delayed @c(stream-enumerate-interval), which now returns

     ..src > scheme
       (cons 10001
             (delay
               (stream-enumerate-interval
                10002
                1000000)))
     < src..

     @c(Stream-filter) now looks at the @c(stream-car) of this stream, 10,001, sees
     that this is not prime either, forces another @c(stream-cdr), and so on, until
     @c(stream-enumerate-interval) yields the prime 10,007, whereupon
     @c(stream-filter), according to its definition, returns

     ..src > scheme
       (cons-stream
        (stream-car stream)
        (stream-filter pred (stream-cdr stream)))
     < src..

     which in this case is

     ..src > scheme
       (cons 10007
             (delay
               (stream-filter
                prime?
                (cons 10008
                      (delay
                        (stream-enumerate-interval
                         10009 1000000))))))
     < src..

     This result is now passed to @c(stream-cdr) in our original expression.  This
     forces the delayed @c(stream-filter), which in turn keeps forcing the delayed
     @c(stream-enumerate-interval) until it finds the next prime, which is
     10,009. Finally, the result passed to @c(stream-car) in our original
     expression is

     ..src > scheme
       (cons 10009
             (delay
               (stream-filter
                prime?
                (cons 10010
                      (delay
                        (stream-enumerate-interval
                         10011 1000000))))))
     < src..

     @c(Stream-car) returns 10,009, and the computation is complete. Only as many
     integers were tested for primality as were necessary to find the second prime,
     and the interval was enumerated only as far as was necessary to feed the prime
     filter.

     In general, we can think of delayed evaluation as @"(demand-driven)
     programming, whereby each stage in the stream process is activated only enough
     to satisfy the next stage. What we have done is to decouple the actual order
     of events in the computation from the apparent structure of our procedures. We
     write procedures as if the streams existed @"(all at once) when, in reality,
     the computation is performed incrementally, as in traditional programming
     styles.

**** Implementing @c(delay) and @c(force)

     Although @c(delay) and @c(force) may seem like mysterious operations, their
     implementation is really quite straightforward. @c(Delay) must package an
     expression so that it can be evaluated later on demand, and we can accomplish
     this simply by treating the expression as the body of a procedure.  @c(Delay)
     can be a special form such that

     ..src > scheme
       (delay ⟨exp⟩)
     < src..

     is syntactic sugar for

     ..src > scheme
       (lambda () ⟨exp⟩)
     < src..

     @c(Force) simply calls the procedure (of no arguments) produced by @c(delay),
     so we can implement @c(force) as a procedure:

     ..src > scheme
       (define (force delayed-object)
         (delayed-object))
     < src..

     This implementation suffices for @c(delay) and @c(force) to work as
     advertised, but there is an important optimization that we can include. In
     many applications, we end up forcing the same delayed object many times. This
     can lead to serious inefficiency in recursive programs involving streams. (See
     @l(#Exercise 3.57).)  The solution is to build delayed objects so that the
     first time they are forced, they store the value that is computed. Subsequent
     forcings will simply return the stored value without repeating the computation.
     In other words, we implement @c(delay) as a special-purpose memoized procedure
     similar to the one described in @l(#Exercise 3.27). One way to accomplish this
     is to use the following procedure, which takes as argument a procedure (of no
     arguments) and returns a memoized version of the procedure.  The first time
     the memoized procedure is run, it saves the computed result. On subsequent
     evaluations, it simply returns the result.

     ..src > scheme
       (define (memo-proc proc)
         (let ((already-run? false) (result false))
           (lambda ()
             (if (not already-run?)
                 (begin (set! result (proc))
                        (set! already-run? true)
                        result)
                 result))))
     < src..

     @c(Delay) is then defined so that @c[(delay ⟨exp⟩)] is equivalent to

     ..src > scheme
       (memo-proc (lambda () ⟨exp⟩))
     < src..

     and @c(force) is as defined previously.@n(186)

     :: @t(Exercise 3.50) :: Complete the following definition, which generalizes
        @c(stream-map) to allow procedures that take multiple arguments, analogous
        to @c(map) in @l(#2.2.1), @n(78<>Footnote 78).

        ..src > scheme
          (define (stream-map proc . argstreams)
            (if (⟨??⟩ (car argstreams))
                the-empty-stream
                (⟨??⟩
                 (apply proc (map ⟨??⟩ argstreams))
                 (apply stream-map
                        (cons proc
                              (map ⟨??⟩
                                   argstreams))))))
        < src..

     :: @t(Exercise 3.51) :: In order to take a closer look at delayed evaluation,
        we will use the following procedure, which simply returns its argument
        after printing it:

        ..src > scheme
          (define (show x)
            (display-line x)
            x)
        < src..

        What does the interpreter print in response to evaluating each expression
        in the following sequence?@n(187)

        ..src > scheme
          (define x
            (stream-map
             show
             (stream-enumerate-interval 0 10)))

          (stream-ref x 5)
          (stream-ref x 7)
        < src..

     :: @t(Exercise 3.52) :: Consider the sequence of expressions

        ..src > scheme
          (define sum 0)

          (define (accum x)
            (set! sum (+ x sum))
            sum)

          (define seq
            (stream-map
             accum
             (stream-enumerate-interval 1 20)))

          (define y (stream-filter even? seq))

          (define z
            (stream-filter
             (lambda (x)
               (= (remainder x 5) 0)) seq))

          (stream-ref y 7)
          (display-stream z)
        < src..

        What is the value of @c(sum) after each of the above expressions is
        evaluated?  What is the printed response to evaluating the @c(stream-ref)
        and @c(display-stream) expressions?  Would these responses differ if we had
        implemented @c[(delay ⟨exp⟩)] simply as @c[(lambda () ⟨exp⟩)] without using
        the optimization provided by @c(memo-proc)?  Explain.

*** 3.5.2 <> Infinite Streams

    We have seen how to support the illusion of manipulating streams as complete
    entities even though, in actuality, we compute only as much of the stream as
    we need to access. We can exploit this technique to represent sequences
    efficiently as streams, even if the sequences are very long. What is more
    striking, we can use streams to represent sequences that are infinitely long.
    For instance, consider the following definition of the stream of positive
    integers:

    ..src > scheme
      (define (integers-starting-from n)
        (cons-stream
         n (integers-starting-from (+ n 1))))
      (define integers (integers-starting-from 1))
    < src..

    This makes sense because @c(integers) will be a pair whose @c(car) is 1 and
    whose @c(cdr) is a promise to produce the integers beginning with 2.  This is
    an infinitely long stream, but in any given time we can examine only a finite
    portion of it. Thus, our programs will never know that the entire infinite
    stream is not there.

    Using @c(integers) we can define other infinite streams, such as the stream of
    integers that are not divisible by 7:

    ..src > scheme
      (define (divisible? x y) (= (remainder x y) 0))
      (define no-sevens
        (stream-filter (lambda (x)
                         (not (divisible? x 7)))
                       integers))
    < src..

    Then we can find integers not divisible by 7 simply by accessing elements of
    this stream:

    ..srci > scheme
      > (stream-ref no-sevens 100)
      117
    < srci..

    In analogy with @c(integers), we can define the infinite stream of Fibonacci
    numbers:

    ..src > scheme
      (define (fibgen a b)
        (cons-stream a (fibgen b (+ a b))))
      (define fibs (fibgen 0 1))
    < src..

    @c(Fibs) is a pair whose @c(car) is 0 and whose @c(cdr) is a promise to
    evaluate @c[(fibgen 1 1)]. When we evaluate this delayed @c[(fibgen 1 1)], it
    will produce a pair whose @c(car) is 1 and whose @c(cdr) is a promise to
    evaluate @c[(fibgen 1 2)], and so on.

    For a look at a more exciting infinite stream, we can generalize the
    @c(no-sevens) example to construct the infinite stream of prime numbers, using
    a method known as the @e(sieve of Eratosthenes).@n(188) We start with the
    integers beginning with 2, which is the first prime. To get the rest of the
    primes, we start by filtering the multiples of 2 from the rest of the
    integers. This leaves a stream beginning with 3, which is the next prime. Now
    we filter the multiples of 3 from the rest of this stream. This leaves a
    stream beginning with 5, which is the next prime, and so on. In other words,
    we construct the primes by a sieving process, described as follows: To sieve a
    stream @c(S), form a stream whose first element is the first element of @c(S)
    and the rest of which is obtained by filtering all multiples of the first
    element of @c(S) out of the rest of @c(S) and sieving the result. This process
    is readily described in terms of stream operations:

    ..src > scheme
      (define (sieve stream)
        (cons-stream
         (stream-car stream)
         (sieve (stream-filter
                 (lambda (x)
                   (not (divisible?
                         x (stream-car stream))))
                 (stream-cdr stream)))))

      (define primes
        (sieve (integers-starting-from 2)))
    < src..

    Now to find a particular prime we need only ask for it:

    ..srci > scheme
      > (stream-ref primes 50)
      233
    < srci..

    It is interesting to contemplate the signal-processing system set up by
    @c(sieve), shown in the @"(Henderson diagram) in @l(#Figure 3.31).@n(189) The
    input stream feeds into an @"(un@c(cons)er) that separates the first element
    of the stream from the rest of the stream. The first element is used to
    construct a divisibility filter, through which the rest is passed, and the
    output of the filter is fed to another sieve box. Then the original first
    element is @c(cons)ed onto the output of the internal sieve to form the output
    stream.  Thus, not only is the stream infinite, but the signal processor is
    also infinite, because the sieve contains a sieve within it.

    ..figure > @t(Figure 3.31) The prime sieve viewed as a signal-processing system.

      ..art >
          ╭───────────────────────────────────────────────────────────────╮
          │ sieve                                                         │
          │                                                               │
          │        __/│                                        │\__       │
          │     __/car│........................................│   \__    │
          │   _/      │           :                            │      \_  │
        ──┼─▶<_       │           ▼                            │  cons _>─┼──▶
          │    \__    │    ╭────────────╮    ╭────────────╮    │    __/   │
          │       \cdr│───▶│ filter:    │    │ sieve      │───▶│ __/      │
          │          \│    │            │───▶│            │    │/         │
          │                │ not        │    │            │               │
          │                │ divisible? │    │            │               │
          │                ╰────────────╯    ╰────────────╯               │
          ╰───────────────────────────────────────────────────────────────╯
      < art..

@   ..img > img/chap3/Fig3.31a.std.svg

**** Defining streams implicitly

     The @c(integers) and @c(fibs) streams above were defined by specifying
     @"(generating) procedures that explicitly compute the stream elements one by
     one. An alternative way to specify streams is to take advantage of delayed
     evaluation to define streams implicitly. For example, the following expression
     defines the stream @c(ones) to be an infinite stream of ones:

     ..src > scheme
       (define ones (cons-stream 1 ones))
     < src..

     This works much like the definition of a recursive procedure: @c(ones) is a
     pair whose @c(car) is 1 and whose @c(cdr) is a promise to evaluate
     @c(ones). Evaluating the @c(cdr) gives us again a 1 and a promise to evaluate
     @c(ones), and so on.

     We can do more interesting things by manipulating streams with operations such
     as @c(add-streams), which produces the elementwise sum of two given
     streams:@n(190)

     ..src > scheme
       (define (add-streams s1 s2)
         (stream-map + s1 s2))
     < src..

     Now we can define the integers as follows:

     ..src > scheme
       (define integers
         (cons-stream 1 (add-streams ones integers)))
     < src..

     This defines @c(integers) to be a stream whose first element is 1 and the rest
     of which is the sum of @c(ones) and @c(integers). Thus, the second element of
     @c(integers) is 1 plus the first element of @c(integers), or 2; the third
     element of @c(integers) is 1 plus the second element of @c(integers), or 3;
     and so on. This definition works because, at any point, enough of the
     @c(integers) stream has been generated so that we can feed it back into the
     definition to produce the next integer.

     We can define the Fibonacci numbers in the same style:

     ..src > scheme
       (define fibs
         (cons-stream
          0 (cons-stream
             1 (add-streams
                (stream-cdr fibs) fibs))))
     < src..

     This definition says that @c(fibs) is a stream beginning with 0 and 1, such
     that the rest of the stream can be generated by adding @c(fibs) to itself
     shifted by one place:

     ..example >
           1 1 2 3 5  8 13 21 … = @c[(stream-cdr fibs)]
           0 1 1 2 3  5  8 13 … = @c(fibs)
       0 1 1 2 3 5 8 13 21 34 … = @c(fibs)
     < example..

     @c(Scale-stream) is another useful procedure in formulating such stream
     definitions. This multiplies each item in a stream by a given constant:

     ..src > scheme
       (define (scale-stream stream factor)
         (stream-map
          (lambda (x) (* x factor))
          stream))
     < src..

     For example,

     ..src > scheme
       (define double
         (cons-stream 1 (scale-stream double 2)))
     < src..

     produces the stream of powers of 2: 1, 2, 4, 8, 16, 32, ….

     An alternate definition of the stream of primes can be given by starting with
     the integers and filtering them by testing for primality. We will need the
     first prime, 2, to get started:

     ..src > scheme
       (define primes
         (cons-stream
          2 (stream-filter
             prime? (integers-starting-from 3))))
     < src..

     This definition is not so straightforward as it appears, because we will test
     whether a number @m(n) is prime by checking whether @m(n) is divisible by a
     prime (not by just any integer) less than or equal to @m(√n):

     ..src > scheme
       (define (prime? n)
         (define (iter ps)
           (cond ((> (square (stream-car ps)) n) true)
                 ((divisible? n (stream-car ps)) false)
                 (else (iter (stream-cdr ps)))))
         (iter primes))
     < src..

     This is a recursive definition, since @c(primes) is defined in terms of the
     @c(prime?) predicate, which itself uses the @c(primes) stream. The reason this
     procedure works is that, at any point, enough of the @c(primes) stream has
     been generated to test the primality of the numbers we need to check
     next. That is, for every @m(n) we test for primality, either @m(n) is not
     prime (in which case there is a prime already generated that divides it) or
     @m(n) is prime (in which case there is a prime already generated––i.e., a
     prime less than @m(n)––that is greater than @m(√n)).@n(191)

     :: @t(Exercise 3.53) :: Without running the program, describe the elements of
        the stream defined by

        ..src > scheme
          (define s (cons-stream 1 (add-streams s s)))
        < src..

     :: @t(Exercise 3.54) :: Define a procedure @c(mul-streams), analogous to
        @c(add-streams), that produces the elementwise product of its two input
        streams. Use this together with the stream of @c(integers) to complete the
        following definition of the stream whose @m(nᵗʰ) element (counting from 0)
        is @m(n + 1) factorial:

        ..src > scheme
          (define factorials
            (cons-stream 1 (mul-streams ⟨??⟩ ⟨??⟩)))
        < src..

     :: @t(Exercise 3.55) :: Define a procedure @c(partial-sums) that takes as
        argument a stream @m(S) and returns the stream whose elements are @m(S₀),
        @m(S₀ + S₁), @m(S₀ + S₁ + S₂, …).  For example, @c[(partial-sums integers)]
        should be the stream 1, 3, 6, 10, 15, ….

     :: @t(Exercise 3.56) :: A famous problem, first raised by R. Hamming, is to
        enumerate, in ascending order with no repetitions, all positive integers
        with no prime factors other than 2, 3, or 5. One obvious way to do this is
        to simply test each integer in turn to see whether it has any factors other
        than 2, 3, and 5. But this is very inefficient, since, as the integers get
        larger, fewer and fewer of them fit the requirement. As an alternative, let
        us call the required stream of numbers @c(S) and notice the following facts
        about it.

        - @c(S) begins with 1.

        - The elements of @c[(scale-stream S 2)] are also elements of @c(S).

        - The same is true for @c[(scale-stream S 3)] and @c[(scale-stream S 5)].

        - These are all the elements of @c(S).

        Now all we have to do is combine elements from these sources. For this we
        define a procedure @c(merge) that combines two ordered streams into one
        ordered result stream, eliminating repetitions:

        ..src > scheme
          (define (merge s1 s2)
            (cond ((stream-null? s1) s2)
                  ((stream-null? s2) s1)
                  (else
                   (let ((s1car (stream-car s1))
                         (s2car (stream-car s2)))
                     (cond ((< s1car s2car)
                            (cons-stream
                             s1car
                             (merge (stream-cdr s1)
                                    s2)))
                           ((> s1car s2car)
                            (cons-stream
                             s2car
                             (merge s1
                                    (stream-cdr s2))))
                           (else
                            (cons-stream
                             s1car
                             (merge
                              (stream-cdr s1)
                              (stream-cdr s2)))))))))
        < src..

        Then the required stream may be constructed with @c(merge), as follows:

        ..src > scheme
          (define S (cons-stream 1 (merge ⟨??⟩ ⟨??⟩)))
        < src..

        Fill in the missing expressions in the places marked @c[⟨??⟩] above.

     :: @t(Exercise 3.57) :: How many additions are performed when we compute the
        @m(nᵗʰ) Fibonacci number using the definition of @c(fibs) based on the
        @c(add-streams) procedure?  Show that the number of additions would be
        exponentially greater if we had implemented @c[(delay ⟨exp⟩)] simply as
        @c[(lambda () ⟨exp⟩)], without using the optimization provided by the
        @c(memo-proc) procedure described in @l(#3.5.1).@n(192)

     :: @t(Exercise 3.58) :: Give an interpretation of the stream computed by the
        following procedure:

        ..src > scheme
          (define (expand num den radix)
            (cons-stream
             (quotient (* num radix) den)
             (expand (remainder (* num radix) den)
                     den
                     radix)))
        < src..

        (@c(Quotient) is a primitive that returns the integer quotient of two
        integers.)  What are the successive elements produced by @c[(expand 1 7
        10)]?  What is produced by @c[(expand 3 8 10)]?

     :: @t(Exercise 3.59) :: In @l(#2.5.3) we saw how to implement a polynomial
        arithmetic system representing polynomials as lists of terms. In a similar
        way, we can work with @e(power series), such as

        ..example >
                        x²      x³        x⁴
          eˣ = 1 + x + ---- + ----- + --------- + ...
                        2     3 ⋅ 2   4 ⋅ 3 ⋅ 2

                       x²        x⁴
          cos x = 1 − ---- + --------- − ...
                       2     4 ⋅ 3 ⋅ 2

                        x³          x⁵
          sin x = x − ----- + ------------- − ...
                      3 ⋅ 2   5 ⋅ 4 ⋅ 3 ⋅ 2
        < example..

        represented as infinite streams. We will represent the series @m(a₀ + a₁
        x + a₂ x² + a₃ x³ + …) as the stream whose elements are the coefficients
        @m(a₀), @m(a₁), @m(a₂), @m(a₃), ….

        1. The integral of the series @m(a₀ + a₁ x + a₂ x² + a₃ x³ + …) is the
           series

           ..example >
                        1          1          1
             c + a₀x + --- a₁x² + --- a₂x³ + --- a₃ x⁴ + ...
                        2          3          4
           < example..

           where @m(c) is any constant. Define a procedure @c(integrate-series)
           that takes as input a stream @m(a₀), @m(a₁), @m(a₂), … representing a
           power series and returns the stream @m(a₀), @m(½a₁), @m(⅓a₂), … of
           coefficients of the non-constant terms of the integral of the
           series. (Since the result has no constant term, it doesn't represent a
           power series; when we use @c(integrate-series), we will @c(cons) on the
           appropriate constant.)

        2. The function @m(x ↦ eˣ) is its own derivative. This implies that @m(eˣ)
           and the integral of @m(eˣ) are the same series, except for the constant
           term, which is @m(e⁰ = 1). Accordingly, we can generate the series for
           @m(eˣ) as

           ..src > scheme
             (define exp-series
               (cons-stream
                1 (integrate-series exp-series)))
           < src..

           Show how to generate the series for sine and cosine, starting from the
           facts that the derivative of sine is cosine and the derivative of cosine
           is the negative of sine:

           ..src > scheme
             (define cosine-series
               (cons-stream 1 ⟨??⟩))

             (define sine-series
               (cons-stream 0 ⟨??⟩))
           < src..

     :: @t(Exercise 3.60) :: With power series represented as streams of
        coefficients as in @l(#Exercise 3.59), adding series is implemented by
        @c(add-streams). Complete the definition of the following procedure for
        multiplying series:

        ..src > scheme
          (define (mul-series s1 s2)
            (cons-stream ⟨??⟩ (add-streams ⟨??⟩ ⟨??⟩)))
        < src..

        You can test your procedure by verifying that @m(sin²x + cos²x = 1), using
        the series from @l(#Exercise 3.59).

     :: @t(Exercise 3.61) :: Let @m(S) be a power series (@l(#Exercise 3.59)) whose
        constant term is 1. Suppose we want to find the power series @m(1 / S),
        that is, the series @m(X) such that @m(SX = 1).  Write @M(S = 1 + S_R)
        where @M[S_R] is the part of @m(S) after the constant term. Then we can
        solve for @m(X) as follows:

        ..example >
                  S ⋅ X = 1
          (1 + S_R) ⋅ X = 1
            X + S_R ⋅ X = 1
                      X = 1 − S_R ⋅ X
        < example..

        In other words, @m(X) is the power series whose constant term is 1 and
        whose higher-order terms are given by the negative of @M(S_R) times
        @m(X). Use this idea to write a procedure @c(invert-unit-series) that
        computes @m(1 / S) for a power series @m(S) with constant term 1. You will
        need to use @c(mul-series) from @l(#Exercise 3.60).

     :: @t(Exercise 3.62) :: Use the results of @l(#Exercise 3.60) and @l(#Exercise
        3.61) to define a procedure @c(div-series) that divides two power
        series. @c(Div-series) should work for any two series, provided that the
        denominator series begins with a nonzero constant term. (If the denominator
        has a zero constant term, then @c(div-series) should signal an error.)
        Show how to use @c(div-series) together with the result of @l(#Exercise
        3.59) to generate the power series for tangent.

*** 3.5.3 <> Exploiting the Stream Paradigm

    Streams with delayed evaluation can be a powerful modeling tool, providing
    many of the benefits of local state and assignment. Moreover, they avoid some
    of the theoretical tangles that accompany the introduction of assignment into
    a programming language.

    The stream approach can be illuminating because it allows us to build systems
    with different module boundaries than systems organized around assignment to
    state variables. For example, we can think of an entire time series (or
    signal) as a focus of interest, rather than the values of the state variables
    at individual moments. This makes it convenient to combine and compare
    components of state from different moments.

**** Formulating iterations as stream processes

     In section @l(#1.2.1), we introduced iterative processes, which proceed by
     updating state variables. We know now that we can represent state as a
     @"(timeless) stream of values rather than as a set of variables to be updated.
     Let's adopt this perspective in revisiting the square-root procedure from
     @l(#1.1.7). Recall that the idea is to generate a sequence of better and
     better guesses for the square root of @m(x) by applying over and over again
     the procedure that improves guesses:

     ..src > scheme
       (define (sqrt-improve guess x)
         (average guess (/ x guess)))
     < src..

     In our original @c(sqrt) procedure, we made these guesses be the successive
     values of a state variable. Instead we can generate the infinite stream of
     guesses, starting with an initial guess of 1:@n(193)

     ..srci > scheme
       > (define (sqrt-stream x)
       ^   (define guesses
       ^     (cons-stream
       ^      1.0 (stream-map
       ^           (lambda (guess)
       ^             (sqrt-improve guess x))
       ^           guesses)))
       ^   guesses)

       > (display-stream (sqrt-stream 2))
       1.
       1.5
       1.4166666666666665
       1.4142156862745097
       1.4142135623746899
       …
     < srci..

     We can generate more and more terms of the stream to get better and better
     guesses. If we like, we can write a procedure that keeps generating terms
     until the answer is good enough. (See @l(#Exercise 3.64).)

     Another iteration that we can treat in the same way is to generate an
     approximation to @m(π), based upon the alternating series that we saw in
     @l(#1.3.1):

     ..example >
        π         1     1     1
       --- = 1 − --- + --- − --- + ...
        4         3     5     7
     < example..

     We first generate the stream of summands of the series (the reciprocals of the
     odd integers, with alternating signs). Then we take the stream of sums of more
     and more terms (using the @c(partial-sums) procedure of @l(#Exercise 3.55))
     and scale the result by 4:

     ..srci > scheme
       > (define (pi-summands n)
       ^   (cons-stream
       ^    (/ 1.0 n)
       ^    (stream-map - (pi-summands (+ n 2)))))

       > (define pi-stream
       ^   (scale-stream
       ^    (partial-sums (pi-summands 1)) 4))

       > (display-stream pi-stream)
       4.
       2.666666666666667
       3.466666666666667
       2.8952380952380956
       3.3396825396825403
       2.9760461760461765
       3.2837384837384844
       3.017071817071818
       …
     < srci..

     This gives us a stream of better and better approximations to @m(π), although
     the approximations converge rather slowly. Eight terms of the sequence bound
     the value of @m(π) between 3.284 and 3.017.

     So far, our use of the stream of states approach is not much different from
     updating state variables. But streams give us an opportunity to do some
     interesting tricks. For example, we can transform a stream with a @e(sequence
     accelerator) that converts a sequence of approximations to a new sequence that
     converges to the same value as the original, only faster.

     One such accelerator, due to the eighteenth-century Swiss mathematician
     Leonhard Euler, works well with sequences that are partial sums of alternating
     series (series of terms with alternating signs). In Euler's technique, if
     @m(Sₙ) is the @m(nᵗʰ) term of the original sum sequence, then the accelerated
     sequence has terms

     ..example >
                    (S₍ₙ₊₁₎ − Sₙ)²
       S₍ₙ₊₁₎ − ---------------------
                S₍ₙ₋₁₎ − 2Sₙ + S₍ₙ₊₁₎
     < example..

     Thus, if the original sequence is represented as a stream of values, the
     transformed sequence is given by

     ..src > scheme
       (define (euler-transform s)
         (let ((s0 (stream-ref s 0))     ; Sₙ₋₁
               (s1 (stream-ref s 1))     ; Sₙ
               (s2 (stream-ref s 2)))    ; Sₙ₊₁
           (cons-stream
            (- s2 (/ (square (- s2 s1))
                     (+ s0 (* -2 s1) s2)))
            (euler-transform (stream-cdr s)))))
     < src..

     We can demonstrate Euler acceleration with our sequence of approximations to
     @m(π):

     ..srci > scheme
       > (display-stream
       ^  (euler-transform pi-stream))
       3.166666666666667
       3.1333333333333337
       3.1452380952380956
       3.13968253968254
       3.1427128427128435
       3.1408813408813416
       3.142071817071818
       3.1412548236077655
       …
     < srci..

     Even better, we can accelerate the accelerated sequence, and recursively
     accelerate that, and so on. Namely, we create a stream of streams (a structure
     we'll call a @e(tableau)) in which each stream is the transform of the
     preceding one:

     ..src > scheme
       (define (make-tableau transform s)
         (cons-stream
          s
          (make-tableau
           transform
           (transform s))))
     < src..

     The tableau has the form

     ..example >
       s₀₀   s₀₁   s₀₂   s₀₃   s₀₄   ...
             s₁₀   s₁₁   s₁₂   s₁₃   ...
                   s₂₀   s₂₁   s₂₂   ...
                                     ...
     < example..

     Finally, we form a sequence by taking the first term in each row of the
     tableau:

     ..src > scheme
       (define (accelerated-sequence transform s)
         (stream-map stream-car
                     (make-tableau transform s)))
     < src..

     We can demonstrate this kind of @"(super-acceleration) of the @m(π) sequence:

     ..srci > scheme
       > (display-stream
       ^  (accelerated-sequence euler-transform
       ^                        pi-stream))
       4.
       3.166666666666667
       3.142105263157895
       3.141599357319005
       3.1415927140337785
       3.1415926539752927
       3.1415926535911765
       3.141592653589778
       …
     < srci..

     The result is impressive. Taking eight terms of the sequence yields the
     correct value of @m(π) to 14 decimal places. If we had used only the original
     @m(π) sequence, we would need to compute on the order of @m(10¹³) terms (i.e.,
     expanding the series far enough so that the individual terms are less than
     @m(10⁻¹³)) to get that much accuracy!

     We could have implemented these acceleration techniques without using streams.
     But the stream formulation is particularly elegant and convenient because the
     entire sequence of states is available to us as a data structure that can be
     manipulated with a uniform set of operations.

     :: @t(Exercise 3.63) :: Louis Reasoner asks why the @c(sqrt-stream) procedure
        was not written in the following more straightforward way, without the
        local variable @c(guesses):

        ..src > scheme
          (define (sqrt-stream x)
            (cons-stream
             1.0
             (stream-map (lambda (guess)
                           (sqrt-improve guess x))
                         (sqrt-stream x))))
        < src..

        Alyssa P. Hacker replies that this version of the procedure is considerably
        less efficient because it performs redundant computation. Explain Alyssa's
        answer. Would the two versions still differ in efficiency if our
        implementation of @c(delay) used only @c[(lambda () ⟨exp⟩)] without using
        the optimization provided by @c(memo-proc) (@l(#3.5.1))?

     :: @t(Exercise 3.64) :: Write a procedure @c(stream-limit) that takes as
        arguments a stream and a number (the tolerance). It should examine the
        stream until it finds two successive elements that differ in absolute value
        by less than the tolerance, and return the second of the two
        elements. Using this, we could compute square roots up to a given tolerance
        by

        ..src > scheme
          (define (sqrt x tolerance)
            (stream-limit (sqrt-stream x) tolerance))
        < src..

     :: @t(Exercise 3.65) :: Use the series

        ..example >
                      1     1     1
          ln 2 = 1 − --- + --- − --- + ...
                      2     3     4
        < example..

        to compute three sequences of approximations to the natural logarithm of 2,
        in the same way we did above for @m(π). How rapidly do these sequences
        converge?

**** Infinite streams of pairs

     In @l(#2.2.3), we saw how the sequence paradigm handles traditional nested
     loops as processes defined on sequences of pairs. If we generalize this
     technique to infinite streams, then we can write programs that are not easily
     represented as loops, because the @"(looping) must range over an infinite set.

     For example, suppose we want to generalize the @c(prime-sum-pairs) procedure
     of @l(#2.2.3) to produce the stream of pairs of @e(all) integers @m[(i, j)]
     with @m(i ≤ j) such that @m(i + j) is prime. If @c(int-pairs) is the sequence
     of all pairs of integers @m[(i, j)] with @m(i ≤ j), then our required stream
     is simply@n(194)

     ..src > scheme
       (stream-filter
        (lambda (pair)
          (prime? (+ (car pair) (cadr pair))))
        int-pairs)
     < src..

     Our problem, then, is to produce the stream @c(int-pairs). More generally,
     suppose we have two streams @m[S = (Sᵢ)] and @m[T = (Tⱼ)], and imagine the
     infinite rectangular array

     ..example >
       (S₀, T₀)  (S₀, T₁)  (S₀, T₂)  ...
       (S₁, T₀)  (S₁, T₁)  (S₁, T₂)  ...
       (S₂, T₀)  (S₂, T₁)  (S₂, T₂)  ...
          ...
     < example..

     We wish to generate a stream that contains all the pairs in the array that lie
     on or above the diagonal, i.e., the pairs

     ..example >
       (S₀, T₀)  (S₀, T₁)  (S₀, T₂)  ...
                 (S₁, T₁)  (S₁, T₂)  ...
                           (S₂, T₂)  ...
                                     ...
     < example..

     (If we take both @m(S) and @m(T) to be the stream of integers, then this will
     be our desired stream @c(int-pairs).)

     Call the general stream of pairs @c[(pairs S T)], and consider it to be
     composed of three parts: the pair @m[(S₀, T₀)], the rest of the pairs in the
     first row, and the remaining pairs:@n(195)

     ..example >
       (S₀, T₀)   | (S₀, T₁)  (S₀, T₂)  ...
       -----------+-----------------------------
                  | (S₁, T₁)  (S₁, T₂)  ...
                  |           (S₂, T₂)  ...
                  |                     ...
     < example..

     Observe that the third piece in this decomposition (pairs that are not in the
     first row) is (recursively) the pairs formed from @c[(stream-cdr S)] and
     @c[(stream-cdr T)]. Also note that the second piece (the rest of the first
     row) is

     ..src > scheme
       (stream-map (lambda (x)
                     (list (stream-car s) x))
                   (stream-cdr t))
     < src..

     Thus we can form our stream of pairs as follows:

     ..src > scheme
       (define (pairs s t)
         (cons-stream
          (list (stream-car s) (stream-car t))
          (⟨combine-in-some-way⟩
           (stream-map (lambda (x)
                         (list (stream-car s) x))
                       (stream-cdr t))
           (pairs (stream-cdr s)
                  (stream-cdr t)))))
     < src..

     In order to complete the procedure, we must choose some way to combine the two
     inner streams. One idea is to use the stream analog of the @c(append)
     procedure from @l(#2.2.1):

     ..src > scheme
       (define (stream-append s1 s2)
         (if (stream-null? s1)
             s2
             (cons-stream
              (stream-car s1)
              (stream-append (stream-cdr s1) s2))))
     < src..

     This is unsuitable for infinite streams, however, because it takes all the
     elements from the first stream before incorporating the second stream. In
     particular, if we try to generate all pairs of positive integers using

     ..src > scheme
       (pairs integers integers)
     < src..

     our stream of results will first try to run through all pairs with the first
     integer equal to 1, and hence will never produce pairs with any other value of
     the first integer.

     To handle infinite streams, we need to devise an order of combination that
     ensures that every element will eventually be reached if we let our program
     run long enough. An elegant way to accomplish this is with the following
     @c(interleave) procedure:@n(196)

     ..src > scheme
       (define (interleave s1 s2)
         (if (stream-null? s1)
             s2
             (cons-stream
              (stream-car s1)
              (interleave s2 (stream-cdr s1)))))
     < src..

     Since @c(interleave) takes elements alternately from the two streams, every
     element of the second stream will eventually find its way into the interleaved
     stream, even if the first stream is infinite.

     We can thus generate the required stream of pairs as

     ..src > scheme
       (define (pairs s t)
         (cons-stream
          (list (stream-car s) (stream-car t))
          (interleave
           (stream-map (lambda (x)
                         (list (stream-car s) x))
                       (stream-cdr t))
           (pairs (stream-cdr s) (stream-cdr t)))))
     < src..

     :: @t(Exercise 3.66) :: Examine the stream @c[(pairs integers integers)]. Can
        you make any general comments about the order in which the pairs are placed
        into the stream? For example, approximately how many pairs precede the pair
        (1, 100)?  the pair (99, 100)? the pair (100, 100)? (If you can make
        precise mathematical statements here, all the better. But feel free to give
        more qualitative answers if you find yourself getting bogged down.)

     :: @t(Exercise 3.67) :: Modify the @c(pairs) procedure so that @c[(pairs
        integers integers)] will produce the stream of @e(all) pairs of integers
        @m[(i, j)] (without the condition @m(i ≤ j)). Hint: You will need to mix in
        an additional stream.

     :: @t(Exercise 3.68) :: Louis Reasoner thinks that building a stream of pairs
        from three parts is unnecessarily complicated.  Instead of separating the
        pair @m[(S₀, T₀)] from the rest of the pairs in the first row, he proposes
        to work with the whole first row, as follows:

        ..src > scheme
          (define (pairs s t)
            (interleave
             (stream-map
              (lambda (x)
                (list (stream-car s) x))
              t)
             (pairs (stream-cdr s)
                    (stream-cdr t))))
        < src..

        Does this work?  Consider what happens if we evaluate @c[(pairs integers
        integers)] using Louis's definition of @c(pairs).

     :: @t(Exercise 3.69) :: Write a procedure @c(triples) that takes three
        infinite streams, @m(S), @m(T), and @m(U), and produces the stream of
        triples @m[(Sᵢ, Tⱼ, Uₙ)] such that @m(i ≤ j ≤ k).  Use @c(triples) to
        generate the stream of all Pythagorean triples of positive integers, i.e.,
        the triples @m[(i, j, k)] such that @m(i ≤ j) and @m(i² + j² = k²).

     :: @t(Exercise 3.70) :: It would be nice to be able to generate streams in
        which the pairs appear in some useful order, rather than in the order that
        results from an @e(ad hoc) interleaving process. We can use a technique
        similar to the @c(merge) procedure of @l(#Exercise 3.56), if we define a
        way to say that one pair of integers is @"(less than) another. One way to
        do this is to define a @"(weighting function) @m[W(i, j)] and stipulate
        that @m[(i₁, j₁)] is less than @m[(i₂, j₂)] if @m[W(i₁, j₁) < W(i₂,
        j₂)]. Write a procedure @c(merge-weighted) that is like @c(merge), except
        that @c(merge-weighted) takes an additional argument @c(weight), which is a
        procedure that computes the weight of a pair, and is used to determine the
        order in which elements should appear in the resulting merged
        stream.@n(197) Using this, generalize @c(pairs) to a procedure
        @c(weighted-pairs) that takes two streams, together with a procedure that
        computes a weighting function, and generates the stream of pairs, ordered
        according to weight. Use your procedure to generate

        1. the stream of all pairs of positive integers @m[(i, j)] with @m(i ≤ j)
           ordered according to the sum @m(i + j),

        2. the stream of all pairs of positive integers @m[(i, j)] with @m(i ≤ j),
           where neither @m(i) nor @m(j) is divisible by 2, 3, or 5, and the pairs
           are ordered according to the sum @m(2i + 3j + 5ij).

     :: @t(Exercise 3.71) :: Numbers that can be expressed as the sum of two cubes
        in more than one way are sometimes called @e(Ramanujan numbers), in honor
        of the mathematician Srinivasa Ramanujan.@n(198) Ordered streams of pairs
        provide an elegant solution to the problem of computing these numbers. To
        find a number that can be written as the sum of two cubes in two different
        ways, we need only generate the stream of pairs of integers @m[(i, j)]
        weighted according to the sum @m(i³ + j³) (see @l(#Exercise 3.70)), then
        search the stream for two consecutive pairs with the same weight. Write a
        procedure to generate the Ramanujan numbers. The first such number is
        1,729. What are the next five?

     :: @t(Exercise 3.72) :: In a similar way to @l(#Exercise 3.71) generate a
        stream of all numbers that can be written as the sum of two squares in
        three different ways (showing how they can be so written).

**** Streams as signals

     We began our discussion of streams by describing them as computational analogs
     of the @"(signals) in signal-processing systems. In fact, we can use streams
     to model signal-processing systems in a very direct way, representing the
     values of a signal at successive time intervals as consecutive elements of a
     stream. For instance, we can implement an @e(integrator) or @e(summer) that,
     for an input stream @m[x = (xᵢ)], an initial value @m(C), and a small
     increment @m(dt), accumulates the sum

     ..example >
                i
       Sᵢ = C + ∑ xⱼdt
               j=1
     < example..

     and returns the stream of values @m[S = (Sᵢ)]. The following @c(integral)
     procedure is reminiscent of the @"(implicit style) definition of the stream of
     integers (@l(#3.5.2)):

     ..src > scheme
       (define (integral integrand initial-value dt)
         (define int
           (cons-stream
            initial-value
            (add-streams (scale-stream integrand dt)
                         int)))
         int)
     < src..

     @l(#Figure 3.32) is a picture of a signal-processing system that corresponds
     to the @c(integral) procedure. The input stream is scaled by @m(dt) and passed
     through an adder, whose output is passed back through the same adder.  The
     self-reference in the definition of @c(int) is reflected in the figure by the
     feedback loop that connects the output of the adder to one of the inputs.

     ..figure > @t(Figure 3.32) The @c(integral) procedure viewed as a
       signal-processing system.

       ..art >
                                      initial-value
                                           │
                ╭───────────╮              │   │\__
         input  │           │      │\__    ╰──▶│   \_  integral
         ──────▶│ scale: dt ├─────▶│   \_      │cons_>──●───────▶
                │           │      │ add_>────▶│ __/    │
                ╰───────────╯  ╭──▶│ __/       │/       │
                               │   │/                   │
                               │                        │
                               ╰────────────────────────╯
       < art..

@    ..img > img/chap3/Fig3.32a.std.svg

     :: @t(Exercise 3.73) :: We can model electrical circuits using streams to
        represent the values of currents or voltages at a sequence of times. For
        instance, suppose we have an @e(RC circuit) consisting of a resistor of
        resistance @m(R) and a capacitor of capacitance @m(C) in series.  The
        voltage response @m(v) of the circuit to an injected current @m(i) is
        determined by the formula in @l(#Figure 3.33), whose structure is shown by
        the accompanying signal-flow diagram.

        ..figure > @t(Figure 3.33) An RC circuit and the associated signal-flow diagram.

          ..art >
                  +        v        -

                ──▶────'\/\/\,─────┤ ├────                  ╭t
                  i                           v = v₀ + (1/C)│ i dt +  R i
                          R         C                       ╯0

                    ╭────────────╮
                    │            │
                ╭──▶│ scale:  R  ├───────────────────────╮
                │   │            │                       │   |\_
                │   ╰────────────╯                       ╰──▶|  \_
                │                                            |    \  v
                │   ╭────────────╮        ╭──────────╮       | add >───▶
              i │   │            │        │          │       |   _/
            ────●──▶│ scale: i/C ├───────▶│ integral ├──────▶| _/
                    │            │        │          │       |/
                    ╰────────────╯        ╰──────────╯
                                               ▲
                                               │
                                               v₀
          < art..

@     ..img > img/chap3/Fig3.33a.std.svg

        Write a procedure @c(RC) that models this circuit. @c(RC) should take as
        inputs the values of @m(R), @m(C), and @m(dt) and should return a procedure
        that takes as inputs a stream representing the current @m(i) and an initial
        value for the capacitor voltage @m(v₀) and produces as output the stream of
        voltages @m(v). For example, you should be able to use @c(RC) to model an
        RC circuit with @m(R) = 5 ohms, @m(C) = 1 farad, and a 0.5-second time step
        by evaluating @c[(define RC1 (RC 5 1 0.5))]. This defines @c(RC1) as a
        procedure that takes a stream representing the time sequence of currents
        and an initial capacitor voltage and produces the output stream of
        voltages.

     :: @t(Exercise 3.74) :: Alyssa P. Hacker is designing a system to process
        signals coming from physical sensors. One important feature she wishes to
        produce is a signal that describes the @e(zero crossings) of the input
        signal. That is, the resulting signal should be @m(+1) whenever the input
        signal changes from negative to positive, @m(-1) whenever the input signal
        changes from positive to negative, and @m(0) otherwise. (Assume that the
        sign of a @m(0) input is positive.)  For example, a typical input signal
        with its associated zero-crossing signal would be

        ..src > scheme
          … 1 2 1.5 1 0.5 -0.1 -2 -3 -2 -0.5 0.2 3 4 …
          … 0 0  0  0  0   -1   0  0  0   0   1  0 0 …
        < src..

        In Alyssa's system, the signal from the sensor is represented as a stream
        @c(sense-data) and the stream @c(zero-crossings) is the corresponding
        stream of zero crossings. Alyssa first writes a procedure
        @c(sign-change-detector) that takes two values as arguments and compares
        the signs of the values to produce an appropriate @m(0), @m(1), or
        @m(-1). She then constructs her zero-crossing stream as follows:

        ..src > scheme
          (define (make-zero-crossings
                   input-stream last-value)
            (cons-stream
             (sign-change-detector
              (stream-car input-stream)
              last-value)
             (make-zero-crossings
              (stream-cdr input-stream)
              (stream-car input-stream))))

          (define zero-crossings
            (make-zero-crossings sense-data 0))
        < src..

        Alyssa's boss, Eva Lu Ator, walks by and suggests that this program is
        approximately equivalent to the following one, which uses the generalized
        version of @c(stream-map) from @l(#Exercise 3.50):

        ..src > scheme
          (define zero-crossings
            (stream-map sign-change-detector
                        sense-data
                        ⟨expression⟩))
        < src..

        Complete the program by supplying the indicated @c[(expression)].

     :: @t(Exercise 3.75) :: Unfortunately, Alyssa's zero-crossing detector in
        @l(#Exercise 3.74) proves to be insufficient, because the noisy signal from
        the sensor leads to spurious zero crossings. Lem E. Tweakit, a hardware
        specialist, suggests that Alyssa smooth the signal to filter out the noise
        before extracting the zero crossings. Alyssa takes his advice and decides
        to extract the zero crossings from the signal constructed by averaging each
        value of the sense data with the previous value. She explains the problem
        to her assistant, Louis Reasoner, who attempts to implement the idea,
        altering Alyssa's program as follows:

        ..src > scheme
          (define (make-zero-crossings
                   input-stream last-value)
            (let ((avpt
                   (/ (+ (stream-car input-stream)
                         last-value)
                      2)))
              (cons-stream
               (sign-change-detector avpt last-value)
               (make-zero-crossings
                (stream-cdr input-stream) avpt))))
        < src..

        This does not correctly implement Alyssa's plan. Find the bug that Louis
        has installed and fix it without changing the structure of the
        program. (Hint: You will need to increase the number of arguments to
        @c(make-zero-crossings).)

     :: @t(Exercise 3.76) :: Eva Lu Ator has a criticism of Louis's approach in
        @l(#Exercise 3.75). The program he wrote is not modular, because it
        intermixes the operation of smoothing with the zero-crossing
        extraction. For example, the extractor should not have to be changed if
        Alyssa finds a better way to condition her input signal. Help Louis by
        writing a procedure @c(smooth) that takes a stream as input and produces a
        stream in which each element is the average of two successive input stream
        elements.  Then use @c(smooth) as a component to implement the
        zero-crossing detector in a more modular style.

*** 3.5.4 <> Streams and Delayed Evaluation

    The @c(integral) procedure at the end of the preceding section shows how we
    can use streams to model signal-processing systems that contain feedback
    loops.  The feedback loop for the adder shown in @l(#Figure 3.32) is modeled
    by the fact that @c(integral)'s internal stream @c(int) is defined in terms of
    itself:

    ..src > scheme
      (define int
        (cons-stream
         initial-value
         (add-streams
          (scale-stream integrand dt) int)))
    < src..

    The interpreter's ability to deal with such an implicit definition depends on
    the @c(delay) that is incorporated into @c(cons-stream). Without this
    @c(delay), the interpreter could not construct @c(int) before evaluating both
    arguments to @c(cons-stream), which would require that @c(int) already be
    defined. In general, @c(delay) is crucial for using streams to model
    signal-processing systems that contain loops. Without @c(delay), our models
    would have to be formulated so that the inputs to any signal-processing
    component would be fully evaluated before the output could be produced. This
    would outlaw loops.

    Unfortunately, stream models of systems with loops may require uses of
    @c(delay) beyond the @"(hidden) @c(delay) supplied by @c(cons-stream).  For
    instance, @l(#Figure 3.34) shows a signal-processing system for solving the
    differential equation @m[dy / dt = f(y)] where @m(f) is a given function. The
    figure shows a mapping component, which applies @m(f) to its input signal,
    linked in a feedback loop to an integrator in a manner very similar to that of
    the analog computer circuits that are actually used to solve such equations.

    ..figure > @t(Figure 3.34) An @"(analog computer circuit) that solves the
      equation @m[dy / dt = f(y)].

      ..art >
                                    y₀
                                     │
                                     ▼
            ╭──────────╮  dy   ╭──────────╮     y
        ╭──▶│  map: f  ├──────▶│ integral ├──●─────▶
        │   ╰──────────╯       ╰──────────╯  │
        │                                    │
        ╰────────────────────────────────────╯
      < art..

@   ..img > img/chap3/Fig3.34.std.svg

    Assuming we are given an initial value @m(y₀) for @m(y), we could try to model
    this system using the procedure

    ..src > scheme
      (define (solve f y0 dt)
        (define y (integral dy y0 dt))
        (define dy (stream-map f y))
        y)
    < src..

    This procedure does not work, because in the first line of @c(solve) the call
    to @c(integral) requires that the input @c(dy) be defined, which does not
    happen until the second line of @c(solve).

    On the other hand, the intent of our definition does make sense, because we
    can, in principle, begin to generate the @c(y) stream without knowing
    @c(dy). Indeed, @c(integral) and many other stream operations have properties
    similar to those of @c(cons-stream), in that we can generate part of the
    answer given only partial information about the arguments. For @c(integral),
    the first element of the output stream is the specified
    @c(initial-value). Thus, we can generate the first element of the output
    stream without evaluating the integrand @c(dy). Once we know the first element
    of @c(y), the @c(stream-map) in the second line of @c(solve) can begin working
    to generate the first element of @c(dy), which will produce the next element
    of @c(y), and so on.

    To take advantage of this idea, we will redefine @c(integral) to expect the
    integrand stream to be a @e(delayed argument). @c(Integral) will @c(force) the
    integrand to be evaluated only when it is required to generate more than the
    first element of the output stream:

    ..src > scheme
      (define (integral
               delayed-integrand initial-value dt)
        (define int
          (cons-stream
           initial-value
           (let ((integrand
                  (force delayed-integrand)))
             (add-streams
              (scale-stream integrand dt)
              int))))
        int)
    < src..

    Now we can implement our @c(solve) procedure by delaying the evaluation of
    @c(dy) in the definition of @c(y):@n(199)

    ..src > scheme
      (define (solve f y0 dt)
        (define y (integral (delay dy) y0 dt))
        (define dy (stream-map f y))
        y)
    < src..

    In general, every caller of @c(integral) must now @c(delay) the integrand
    argument. We can demonstrate that the @c(solve) procedure works by
    approximating @m(e ≈ 2.718) by computing the value at @m(y = 1) of the
    solution to the differential equation @m(dy / dt = y) with initial condition
    @m[y(0) = 1]:

    ..srci > scheme
      > (stream-ref
      ^  (solve (lambda (y) y) 1 0.001) 1000)
      2.716924
    < srci..

    :: @t(Exercise 3.77) :: The @c(integral) procedure used above was analogous to
       the @"(implicit) definition of the infinite stream of integers in
       @l(#3.5.2). Alternatively, we can give a definition of @c(integral) that is
       more like @c(integers-starting-from) (also in @l(#3.5.2)):

       ..src > scheme
         (define (integral
                  integrand initial-value dt)
           (cons-stream
            initial-value
            (if (stream-null? integrand)
                the-empty-stream
                (integral
                 (stream-cdr integrand)
                 (+ (* dt (stream-car integrand))
                    initial-value)
                 dt))))
       < src..

       When used in systems with loops, this procedure has the same problem as
       does our original version of @c(integral). Modify the procedure so that it
       expects the @c(integrand) as a delayed argument and hence can be used in
       the @c(solve) procedure shown above.

    :: @t(Exercise 3.78) :: Consider the problem of designing a signal-processing
       system to study the homogeneous second-order linear differential equation

       ..example >
         d²y     dy
         --- − a---- −  by  =  0
         dt²     dt
       < example..

       The output stream, modeling @m(y), is generated by a network that contains
       a loop. This is because the value of @m(d² y / dt²) depends upon the values
       of @m(y) and @m(dy / dt) and both of these are determined by integrating
       @m(d² y / dt²). The diagram we would like to encode is shown in @l(#Figure
       3.35). Write a procedure @c(solve-2nd) that takes as arguments the
       constants @m(a), @m(b), and @m(dt) and the initial values @m(y₀) and
       @m(dy₀) for @m(y) and @m(dy / dt) and generates the stream of successive
       values of @m(y).

    ..figure > @t(Figure 3.35) Signal-flow diagram for the solution to a
      second-order linear differential equation.

      ..art >
                       dy₀                   y₀
                        │                    │
                        ▼                    ▼
           ddy     ╭──────────╮    dy   ╭──────────╮    y
        ╭─────────▶│ integral ├─────●──▶│ integral ├──●───▶
        │          ╰──────────╯     │   ╰──────────╯  │
        │                           │                 │
        │            ╭──────────╮   │                 │
        │     __/│◀──┤ scale: a │◀──╯                 │
        │   _/   │   ╰──────────╯                     │
        ╰──<_add │                                    │
             \__ │   ╭──────────╮                     │
                \│◀──┤ scale: b │◀────────────────────+
                     ╰──────────╯
      < art..

@   ..img > img/chap3/Fig3.35b.std.svg

    :: @t(Exercise 3.79) :: Generalize the @c(solve-2nd) procedure of @l(#Exercise
       3.78) so that it can be used to solve general second-order differential
       equations @m[d²y / dt² = f(dy / dt, y)].

    ..figure > @t(Figure 3.36) A series RLC circuit.

      ..art >
                     +  v_R  ─
                i_R
             ╭───▶────'\/\/\,────────╮
             │                       │  i_L
         +   │           R           ▼
             ▼                       │
             │  i_C                  │_   +
        v_C  ┴                        _)
             ┬  C                     _)  v_L
             │                        _)
         −   │                       │    −
             ╰───────────────────────╯
      < art..

@   ..img > img/chap3/Fig3.36.std.svg

    :: @t(Exercise 3.80) :: A @e(series RLC circuit) consists of a resistor, a
       capacitor, and an inductor connected in series, as shown in @l(#Figure
       3.36). If @m(R), @m(L), and @m(C) are the resistance, inductance, and
       capacitance, then the relations between voltage @m[(v)] and current @m[(i)]
       for the three components are described by the equations

       ..example >
         v_R = i_R R

                  d i_L
         v_L = L -------
                   d t

                  d v_C
         i_C = C -------
                   d t
       < example..

       and the circuit connections dictate the relations

       ..example >
         i_R = i_L = −i_C

         v_C = v_L + v_R
       < example..

       Combining these equations shows that the state of the circuit (summarized
       by @M[v_C], the voltage across the capacitor, and @M[i_L], the current in
       the inductor) is described by the pair of differential equations

       ..example >
         d v_C        i_L
         -----  =  −  ---
          d t          C

         d i_L      1           R
         -----  =  --- v_C  −  --- i_L
          d t       L           L
       < example..

       The signal-flow diagram representing this system of differential equations
       is shown in @l(#Figure 3.37).

    ..figure > @t(Figure 3.37) A signal-flow diagram for the solution to a series
      RLC circuit.

      ..art >
                         ╭─────────────╮
        ╭────────────────┤  scale: l/L │◀──╮
        │                ╰─────────────╯   │
        │                                  │
        │                ╭─────────────╮   │  v_C
        │       dv_C ╭──▶│   integral  ├───●──────▶
        │            │   ╰─────────────╯
        │            │        ▲
        │            │        ╰── v_(C_0)
        │            │
        │            │   ╭─────────────╮
        │            ╰───┤ scale: −l/C │◀──╮
        │                ╰─────────────╯   │
        │  │\__                            │
        ╰─▶│   \_  di_L  ╭─────────────╮   │  i_L
           │ add_>──────▶│   integral  ├───●──────▶
        ╭─▶│ __/         ╰─────────────╯   │
        │  │/                 ▲            │
        │                     ╰── i_(L_0)  │
        │                                  │
        │                ╭─────────────╮   │
        ╰────────────────┤ scale: −R/L │◀──╯
                         ╰─────────────╯
      < art..

@   ..img > img/chap3/Fig3.37.std.svg

    ..tab >
      Write a procedure @c(RLC) that takes as arguments the parameters @m(R),
      @m(L), and @m(C) of the circuit and the time increment @m(dt). In a manner
      similar to that of the @c(RC) procedure of @l(#Exercise 3.73), @c(RLC)
      should produce a procedure that takes the initial values of the state
      variables, @M[v_{C_0}] and @M[i_{L_0}], and produces a pair (using @c(cons))
      of the streams of states @M[v_C] and @M[i_L]. Using @c(RLC), generate the
      pair of streams that models the behavior of a series RLC circuit with @m(R)
      = 1 ohm, @m(C) = 0.2 farad, @m(L) = 1 henry, @m(dt) = 0.1 second, and
      initial values @M[i_{L_0}] = 0 amps and @M[v_{C_0}] = 10 volts.

**** Normal-order evaluation

     The examples in this section illustrate how the explicit use of @c(delay) and
     @c(force) provides great programming flexibility, but the same examples also
     show how this can make our programs more complex. Our new @c(integral)
     procedure, for instance, gives us the power to model systems with loops, but
     we must now remember that @c(integral) should be called with a delayed
     integrand, and every procedure that uses @c(integral) must be aware of this.
     In effect, we have created two classes of procedures: ordinary procedures and
     procedures that take delayed arguments. In general, creating separate classes
     of procedures forces us to create separate classes of higher-order procedures
     as well.@n(200)

     One way to avoid the need for two different classes of procedures is to make
     all procedures take delayed arguments. We could adopt a model of evaluation in
     which all arguments to procedures are automatically delayed and arguments are
     forced only when they are actually needed (for example, when they are required
     by a primitive operation). This would transform our language to use
     normal-order evaluation, which we first described when we introduced the
     substitution model for evaluation in @l(#1.1.5). Converting to normal-order
     evaluation provides a uniform and elegant way to simplify the use of delayed
     evaluation, and this would be a natural strategy to adopt if we were concerned
     only with stream processing. In @l(#4.2), after we have studied the evaluator,
     we will see how to transform our language in just this way. Unfortunately,
     including delays in procedure calls wreaks havoc with our ability to design
     programs that depend on the order of events, such as programs that use
     assignment, mutate data, or perform input or output. Even the single @c(delay)
     in @c(cons-stream) can cause great confusion, as illustrated by @l(#Exercise
     3.51) and @l(#Exercise 3.52). As far as anyone knows, mutability and delayed
     evaluation do not mix well in programming languages, and devising ways to deal
     with both of these at once is an active area of research.

*** 3.5.5 <> Modularity of Functional Programs and Modularity of Objects

    As we saw in @l(#3.1.2), one of the major benefits of introducing assignment
    is that we can increase the modularity of our systems by encapsulating, or
    @"(hiding,) parts of the state of a large system within local
    variables. Stream models can provide an equivalent modularity without the use
    of assignment. As an illustration, we can reimplement the Monte Carlo
    estimation of @m(π), which we examined in @l(#3.1.2), from a stream-processing
    point of view.

    The key modularity issue was that we wished to hide the internal state of a
    random-number generator from programs that used random numbers. We began with
    a procedure @c(rand-update), whose successive values furnished our supply of
    random numbers, and used this to produce a random-number generator:

    ..src > scheme
      (define rand
        (let ((x random-init))
          (lambda ()
            (set! x (rand-update x))
            x)))
    < src..

    In the stream formulation there is no random-number generator @e(per se), just
    a stream of random numbers produced by successive calls to @c(rand-update):

    ..src > scheme
      (define random-numbers
        (cons-stream random-init
                     (stream-map rand-update
                                 random-numbers)))
    < src..

    We use this to construct the stream of outcomes of the Cesàro experiment
    performed on consecutive pairs in the @c(random-numbers) stream:

    ..src > scheme
      (define cesaro-stream
        (map-successive-pairs
         (lambda (r1 r2) (= (gcd r1 r2) 1))
         random-numbers))

      (define (map-successive-pairs f s)
        (cons-stream
         (f (stream-car s)
            (stream-car (stream-cdr s)))
         (map-successive-pairs
          f (stream-cdr (stream-cdr s)))))
    < src..

    The @c(cesaro-stream) is now fed to a @c(monte-carlo) procedure, which
    produces a stream of estimates of probabilities. The results are then
    converted into a stream of estimates of @m(π). This version of the program
    doesn't need a parameter telling how many trials to perform. Better estimates
    of @m(π) (from performing more experiments) are obtained by looking farther
    into the @c(pi) stream:

    ..src > scheme
      (define (monte-carlo experiment-stream
                           passed
                           failed)
        (define (next passed failed)
          (cons-stream
           (/ passed (+ passed failed))
           (monte-carlo
            (stream-cdr experiment-stream)
            passed
            failed)))
        (if (stream-car experiment-stream)
            (next (+ passed 1) failed)
            (next passed (+ failed 1))))

      (define pi
        (stream-map
         (lambda (p) (sqrt (/ 6 p)))
         (monte-carlo cesaro-stream 0 0)))
    < src..

    There is considerable modularity in this approach, because we still can
    formulate a general @c(monte-carlo) procedure that can deal with arbitrary
    experiments. Yet there is no assignment or local state.

    :: @t(Exercise 3.81) :: @l(#Exercise 3.6) discussed generalizing the
       random-number generator to allow one to reset the random-number sequence so
       as to produce repeatable sequences of @"(random) numbers. Produce a stream
       formulation of this same generator that operates on an input stream of
       requests to @c(generate) a new random number or to @c(reset) the sequence
       to a specified value and that produces the desired stream of random
       numbers. Don't use assignment in your solution.

    :: @t(Exercise 3.82) :: Redo @l(#Exercise 3.5) on Monte Carlo integration in
       terms of streams. The stream version of @c(estimate-integral) will not have
       an argument telling how many trials to perform. Instead, it will produce a
       stream of estimates based on successively more trials.

**** A functional-programming view of time

     Let us now return to the issues of objects and state that were raised at the
     beginning of this chapter and examine them in a new light. We introduced
     assignment and mutable objects to provide a mechanism for modular construction
     of programs that model systems with state. We constructed computational
     objects with local state variables and used assignment to modify these
     variables. We modeled the temporal behavior of the objects in the world by the
     temporal behavior of the corresponding computational objects.

     Now we have seen that streams provide an alternative way to model objects with
     local state. We can model a changing quantity, such as the local state of some
     object, using a stream that represents the time history of successive states.
     In essence, we represent time explicitly, using streams, so that we decouple
     time in our simulated world from the sequence of events that take place during
     evaluation. Indeed, because of the presence of @c(delay) there may be little
     relation between simulated time in the model and the order of events during
     the evaluation.

     In order to contrast these two approaches to modeling, let us reconsider the
     implementation of a @"(withdrawal processor) that monitors the balance in a
     bank account. In @l(#3.1.3) we implemented a simplified version of such a
     processor:

     ..src > scheme
       (define (make-simplified-withdraw balance)
         (lambda (amount)
           (set! balance (- balance amount))
           balance))
     < src..

     Calls to @c(make-simplified-withdraw) produce computational objects, each with
     a local state variable @c(balance) that is decremented by successive calls to
     the object. The object takes an @c(amount) as an argument and returns the new
     balance. We can imagine the user of a bank account typing a sequence of inputs
     to such an object and observing the sequence of returned values shown on a
     display screen.

     Alternatively, we can model a withdrawal processor as a procedure that takes
     as input a balance and a stream of amounts to withdraw and produces the stream
     of successive balances in the account:

     ..src > scheme
       (define (stream-withdraw balance amount-stream)
         (cons-stream
          balance
          (stream-withdraw
           (- balance (stream-car amount-stream))
           (stream-cdr amount-stream))))
     < src..

     @c(Stream-withdraw) implements a well-defined mathematical function whose
     output is fully determined by its input. Suppose, however, that the input
     @c(amount-stream) is the stream of successive values typed by the user and
     that the resulting stream of balances is displayed. Then, from the perspective
     of the user who is typing values and watching results, the stream process has
     the same behavior as the object created by @c(make-simplified-withdraw).
     However, with the stream version, there is no assignment, no local state
     variable, and consequently none of the theoretical difficulties that we
     encountered in @l(#3.1.3). Yet the system has state!

     This is really remarkable. Even though @c(stream-withdraw) implements a
     well-defined mathematical function whose behavior does not change, the user's
     perception here is one of interacting with a system that has a changing state.
     One way to resolve this paradox is to realize that it is the user's temporal
     existence that imposes state on the system. If the user could step back from
     the interaction and think in terms of streams of balances rather than
     individual transactions, the system would appear stateless.@n(201)

     From the point of view of one part of a complex process, the other parts
     appear to change with time. They have hidden time-varying local state. If we
     wish to write programs that model this kind of natural decomposition in our
     world (as we see it from our viewpoint as a part of that world) with
     structures in our computer, we make computational objects that are not
     functional––they must change with time. We model state with local state
     variables, and we model the changes of state with assignments to those
     variables. By doing this we make the time of execution of a computation model
     time in the world that we are part of, and thus we get @"(objects) in our
     computer.

     Modeling with objects is powerful and intuitive, largely because this matches
     the perception of interacting with a world of which we are part. However, as
     we've seen repeatedly throughout this chapter, these models raise thorny
     problems of constraining the order of events and of synchronizing multiple
     processes. The possibility of avoiding these problems has stimulated the
     development of @e(functional programming languages), which do not include any
     provision for assignment or mutable data. In such a language, all procedures
     implement well-defined mathematical functions of their arguments, whose
     behavior does not change. The functional approach is extremely attractive for
     dealing with concurrent systems.@n(202)

     On the other hand, if we look closely, we can see time-related problems
     creeping into functional models as well. One particularly troublesome area
     arises when we wish to design interactive systems, especially ones that model
     interactions between independent entities. For instance, consider once more
     the implementation of a banking system that permits joint bank accounts. In a
     conventional system using assignment and objects, we would model the fact that
     Peter and Paul share an account by having both Peter and Paul send their
     transaction requests to the same bank-account object, as we saw in
     @l(#3.1.3). From the stream point of view, where there are no @"(objects)
     @e(per se), we have already indicated that a bank account can be modeled as a
     process that operates on a stream of transaction requests to produce a stream
     of responses. Accordingly, we could model the fact that Peter and Paul have a
     joint bank account by merging Peter's stream of transaction requests with
     Paul's stream of requests and feeding the result to the bank-account stream
     process, as shown in @l(#Figure 3.38).

     ..figure > @t(Figure 3.38) A joint bank account, modeled by merging two
       streams of transaction requests.

       ..art >
         Peter's requests   ╭─────────╮     ╭─────────╮
         ──────────────────▶│         │     │         │
         Paul's requests    │  merge  ├────▶│ bank    ├────▶
         ──────────────────▶│         │     │ account │
                            ╰─────────╯     ╰─────────╯
       < art..

@    ..img > img/chap3/Fig3.38a.std.svg

     The trouble with this formulation is in the notion of @e(merge). It will not
     do to merge the two streams by simply taking alternately one request from
     Peter and one request from Paul. Suppose Paul accesses the account only very
     rarely. We could hardly force Peter to wait for Paul to access the account
     before he could issue a second transaction. However such a merge is
     implemented, it must interleave the two transaction streams in some way that
     is constrained by @"(real time) as perceived by Peter and Paul, in the sense
     that, if Peter and Paul meet, they can agree that certain transactions were
     processed before the meeting, and other transactions were processed after the
     meeting.@n(203) This is precisely the same constraint that we had to deal with
     in @l(#3.4.1), where we found the need to introduce explicit synchronization
     to ensure a @"(correct) order of events in concurrent processing of objects
     with state. Thus, in an attempt to support the functional style, the need to
     merge inputs from different agents reintroduces the same problems that the
     functional style was meant to eliminate.

     We began this chapter with the goal of building computational models whose
     structure matches our perception of the real world we are trying to model. We
     can model the world as a collection of separate, time-bound, interacting
     objects with state, or we can model the world as a single, timeless, stateless
     unity. Each view has powerful advantages, but neither view alone is completely
     satisfactory. A grand unification has yet to emerge.@n(204)

* Chapter 4 <> Metalinguistic Abstraction

  ..quote >
    … It's in words that the magic is––Abracadabra, Open Sesame, and the
    rest––but the magic words in one story aren't magical in the next. The real
    magic is to understand which words work, and when, and for what; the trick
    is to learn the trick.

    … And those words are made from the letters of our alphabet: a couple-dozen
    squiggles we can draw with the pen. This is the key!  And the treasure, too,
    if we can only get our hands on it!  It's as if––as if the key to the
    treasure @e(is) the treasure!

    --John Barth, @q(Chimera)
  < quote..

  In our study of program design, we have seen that expert programmers control
  the complexity of their designs with the same general techniques used by
  designers of all complex systems. They combine primitive elements to form
  compound objects, they abstract compound objects to form higher-level building
  blocks, and they preserve modularity by adopting appropriate large-scale views
  of system structure. In illustrating these techniques, we have used Lisp as a
  language for describing processes and for constructing computational data
  objects and processes to model complex phenomena in the real world. However,
  as we confront increasingly complex problems, we will find that Lisp, or
  indeed any fixed programming language, is not sufficient for our needs. We
  must constantly turn to new languages in order to express our ideas more
  effectively. Establishing new languages is a powerful strategy for controlling
  complexity in engineering design; we can often enhance our ability to deal
  with a complex problem by adopting a new language that enables us to describe
  (and hence to think about) the problem in a different way, using primitives,
  means of combination, and means of abstraction that are particularly well
  suited to the problem at hand.@n(205)

  Programming is endowed with a multitude of languages. There are physical
  languages, such as the machine languages for particular computers. These
  languages are concerned with the representation of data and control in terms
  of individual bits of storage and primitive machine instructions. The
  machine-language programmer is concerned with using the given hardware to
  erect systems and utilities for the efficient implementation of
  resource-limited computations. High-level languages, erected on a
  machine-language substrate, hide concerns about the representation of data as
  collections of bits and the representation of programs as sequences of
  primitive instructions. These languages have means of combination and
  abstraction, such as procedure definition, that are appropriate to the
  larger-scale organization of systems.

  @e(Metalinguistic abstraction)––establishing new languages––plays an important
  role in all branches of engineering design. It is particularly important to
  computer programming, because in programming not only can we formulate new
  languages but we can also implement these languages by constructing
  evaluators. An @e(evaluator) (or @e(interpreter)) for a programming language
  is a procedure that, when applied to an expression of the language, performs
  the actions required to evaluate that expression.

  It is no exaggeration to regard this as the most fundamental idea in
  programming:

  ..quote >
    The evaluator, which determines the meaning of expressions in a programming
    language, is just another program.
  < quote..

  To appreciate this point is to change our images of ourselves as programmers.
  We come to see ourselves as designers of languages, rather than only users of
  languages designed by others.

  In fact, we can regard almost any program as the evaluator for some language.
  For instance, the polynomial manipulation system of @l(#2.5.3) embodies the
  rules of polynomial arithmetic and implements them in terms of operations on
  list-structured data. If we augment this system with procedures to read and
  print polynomial expressions, we have the core of a special-purpose language
  for dealing with problems in symbolic mathematics. The digital-logic simulator
  of @l(#3.3.4) and the constraint propagator of @l(#3.3.5) are legitimate
  languages in their own right, each with its own primitives, means of
  combination, and means of abstraction. Seen from this perspective, the
  technology for coping with large-scale computer systems merges with the
  technology for building new computer languages, and computer science itself
  becomes no more (and no less) than the discipline of constructing appropriate
  descriptive languages.

  We now embark on a tour of the technology by which languages are established
  in terms of other languages. In this chapter we shall use Lisp as a base,
  implementing evaluators as Lisp procedures. Lisp is particularly well suited
  to this task, because of its ability to represent and manipulate symbolic
  expressions. We will take the first step in understanding how languages are
  implemented by building an evaluator for Lisp itself. The language implemented
  by our evaluator will be a subset of the Scheme dialect of Lisp that we use in
  this book. Although the evaluator described in this chapter is written for a
  particular dialect of Lisp, it contains the essential structure of an
  evaluator for any expression-oriented language designed for writing programs
  for a sequential machine. (In fact, most language processors contain, deep
  within them, a little @"(Lisp) evaluator.)  The evaluator has been simplified
  for the purposes of illustration and discussion, and some features have been
  left out that would be important to include in a production-quality Lisp
  system.  Nevertheless, this simple evaluator is adequate to execute most of
  the programs in this book.@n(206)

  An important advantage of making the evaluator accessible as a Lisp program is
  that we can implement alternative evaluation rules by describing these as
  modifications to the evaluator program. One place where we can use this power
  to good effect is to gain extra control over the ways in which computational
  models embody the notion of time, which was so central to the discussion in
  @l(#Chapter 3). There, we mitigated some of the complexities of state and
  assignment by using streams to decouple the representation of time in the
  world from time in the computer. Our stream programs, however, were sometimes
  cumbersome, because they were constrained by the applicative-order evaluation
  of Scheme. In @l(#4.2), we'll change the underlying language to provide for a
  more elegant approach, by modifying the evaluator to provide for
  @e(normal-order evaluation).

  Section @l(#4.3) implements a more ambitious linguistic change, whereby
  expressions have many values, rather than just a single value. In this
  language of @e(nondeterministic computing), it is natural to express processes
  that generate all possible values for expressions and then search for those
  values that satisfy certain constraints. In terms of models of computation and
  time, this is like having time branch into a set of @"(possible futures) and
  then searching for appropriate time lines. With our nondeterministic
  evaluator, keeping track of multiple values and performing searches are
  handled automatically by the underlying mechanism of the language.

  In @l(#4.4) we implement a @e(logic-programming) language in which knowledge
  is expressed in terms of relations, rather than in terms of computations with
  inputs and outputs. Even though this makes the language drastically different
  from Lisp, or indeed from any conventional language, we will see that the
  logic-programming evaluator shares the essential structure of the Lisp
  evaluator.

** 4.1 <> The Metacircular Evaluator

   Our evaluator for Lisp will be implemented as a Lisp program. It may seem
   circular to think about evaluating Lisp programs using an evaluator that is
   itself implemented in Lisp. However, evaluation is a process, so it is
   appropriate to describe the evaluation process using Lisp, which, after all,
   is our tool for describing processes.@n(207) An evaluator that is written in
   the same language that it evaluates is said to be @e(metacircular).

   The metacircular evaluator is essentially a Scheme formulation of the
   environment model of evaluation described in @l(#3.2). Recall that the model
   has two basic parts:

   1. To evaluate a combination (a compound expression other than a special
      form), evaluate the subexpressions and then apply the value of the operator
      subexpression to the values of the operand subexpressions.

   2. To apply a compound procedure to a set of arguments, evaluate the body of
      the procedure in a new environment. To construct this environment, extend
      the environment part of the procedure object by a frame in which the formal
      parameters of the procedure are bound to the arguments to which the
      procedure is applied.


   These two rules describe the essence of the evaluation process, a basic cycle
   in which expressions to be evaluated in environments are reduced to procedures
   to be applied to arguments, which in turn are reduced to new expressions to be
   evaluated in new environments, and so on, until we get down to symbols, whose
   values are looked up in the environment, and to primitive procedures, which
   are applied directly (see @l(#Figure 4.1)).@n(208) This evaluation cycle will
   be embodied by the interplay between the two critical procedures in the
   evaluator, @c(eval) and @c(apply), which are described in @l(#4.1.1) (see
   @l(#Figure 4.1)).

   ..figure > @t(Figure 4.1) The @c(eval)-@c(apply) cycle exposes the essence of
     a computer language.

     ..art >
                                  .,ad88888888baa,
                         _    ,d8P"""        ""9888ba.      _
                        /  .a8"          ,ad88888888888a   |\
                      /   aP'          ,88888888888888888a   \
                     /  ,8"           ,88888888888888888888,  \
                    |  ,8'            (888888888888888888888, |
                   /  ,8'             `8888888888888888888888  \
                   |  8)               `888888888888888888888, |
       Procedure,  |  8                  "88888 Apply 8888888) | Expression
       Arguments   |  8     Eval          `888888888888888888) | Environment
                   |  8)                    "8888888888888888  |
                   \  (b                     "88888888888888'  /
                    | `8,                     8888888888888)  |
                    \  "8a                   ,888888888888)  /
                     \   V8,                 d88888888888"  /
                     _\| `8b,             ,d8888888888P' _/
                            `V8a,       ,ad8888888888P'
                               ""88888888888888888P"
                                    """"""""""""

                                      [graphic by Normand Veillux, modified]
     < art..

@  ..img > img/chap4/Fig4.1a.std.svg

   The implementation of the evaluator will depend upon procedures that define
   the @e(syntax) of the expressions to be evaluated. We will use data
   abstraction to make the evaluator independent of the representation of the
   language. For example, rather than committing to a choice that an assignment
   is to be represented by a list beginning with the symbol @c(set!) we use an
   abstract predicate @c(assignment?) to test for an assignment, and we use
   abstract selectors @c(assignment-variable) and @c(assignment-value) to access
   the parts of an assignment. Implementation of expressions will be described in
   detail in @l(#4.1.2). There are also operations, described in @l(#4.1.3), that
   specify the representation of procedures and environments. For example,
   @c(make-procedure) constructs compound procedures, @c(lookup-variable-value)
   accesses the values of variables, and @c(apply-primitive-procedure) applies a
   primitive procedure to a given list of arguments.

*** 4.1.1 <> The Core of the Evaluator

    The evaluation process can be described as the interplay between two
    procedures: @c(eval) and @c(apply).

**** Eval

     @c(Eval) takes as arguments an expression and an environment. It classifies
     the expression and directs its evaluation. @c(Eval) is structured as a case
     analysis of the syntactic type of the expression to be evaluated. In order to
     keep the procedure general, we express the determination of the type of an
     expression abstractly, making no commitment to any particular representation
     for the various types of expressions. Each type of expression has a predicate
     that tests for it and an abstract means for selecting its parts. This
     @e(abstract syntax) makes it easy to see how we can change the syntax of the
     language by using the same evaluator, but with a different collection of
     syntax procedures.

     :: Primitive expressions ::

        - For self-evaluating expressions, such as numbers, @c(eval) returns the
          expression itself.

        - @c(Eval) must look up variables in the environment to find their values.

     :: Special forms ::

        - For quoted expressions, @c(eval) returns the expression that was quoted.

        - An assignment to (or a definition of) a variable must recursively call
          @c(eval) to compute the new value to be associated with the variable. The
          environment must be modified to change (or create) the binding of the
          variable.

        - An @c(if) expression requires special processing of its parts, so as to
          evaluate the consequent if the predicate is true, and otherwise to
          evaluate the alternative.

        - A @c(lambda) expression must be transformed into an applicable procedure
          by packaging together the parameters and body specified by the @c(lambda)
          expression with the environment of the evaluation.

        - A @c(begin) expression requires evaluating its sequence of expressions in
          the order in which they appear.

        - A case analysis (@c(cond)) is transformed into a nest of @c(if)
          expressions and then evaluated.

     :: Combinations ::

        - For a procedure application, @c(eval) must recursively evaluate the
          operator part and the operands of the combination. The resulting procedure
          and arguments are passed to @c(apply), which handles the actual procedure
          application.


     Here is the definition of @c(eval):

     ..src > scheme
       (define (eval exp env)
         (cond ((self-evaluating? exp)
                exp)
               ((variable? exp)
                (lookup-variable-value exp env))
               ((quoted? exp)
                (text-of-quotation exp))
               ((assignment? exp)
                (eval-assignment exp env))
               ((definition? exp)
                (eval-definition exp env))
               ((if? exp)
                (eval-if exp env))
               ((lambda? exp)
                (make-procedure
                 (lambda-parameters exp)
                 (lambda-body exp)
                 env))
               ((begin? exp)
                (eval-sequence
                 (begin-actions exp)
                 env))
               ((cond? exp)
                (eval (cond->if exp) env))
               ((application? exp)
                (apply (eval (operator exp) env)
                       (list-of-values
                        (operands exp)
                        env)))
               (else
                (error "Unknown expression
                        type: EVAL" exp))))
     < src..

     For clarity, @c(eval) has been implemented as a case analysis using
     @c(cond). The disadvantage of this is that our procedure handles only a few
     distinguishable types of expressions, and no new ones can be defined without
     editing the definition of @c(eval). In most Lisp implementations, dispatching
     on the type of an expression is done in a data-directed style.  This allows a
     user to add new types of expressions that @c(eval) can distinguish, without
     modifying the definition of @c(eval) itself. (See @l(#Exercise 4.3).)

**** Apply

     @c(Apply) takes two arguments, a procedure and a list of arguments to which
     the procedure should be applied. @c(Apply) classifies procedures into two
     kinds: It calls @c(apply-primitive-procedure) to apply primitives; it applies
     compound procedures by sequentially evaluating the expressions that make up
     the body of the procedure. The environment for the evaluation of the body of a
     compound procedure is constructed by extending the base environment carried by
     the procedure to include a frame that binds the parameters of the procedure to
     the arguments to which the procedure is to be applied. Here is the definition
     of @c(apply):

     ..src > scheme
       (define (apply procedure arguments)
         (cond ((primitive-procedure? procedure)
                (apply-primitive-procedure
                 procedure
                 arguments))
               ((compound-procedure? procedure)
                (eval-sequence
                  (procedure-body procedure)
                  (extend-environment
                    (procedure-parameters
                     procedure)
                    arguments
                    (procedure-environment
                     procedure))))
               (else
                (error "Unknown procedure
                        type: APPLY"
                       procedure))))
     < src..

**** Procedure arguments

     When @c(eval) processes a procedure application, it uses @c(list-of-values) to
     produce the list of arguments to which the procedure is to be
     applied. @c(List-of-values) takes as an argument the operands of the
     combination. It evaluates each operand and returns a list of the corresponding
     values:@n(209)

     ..src > scheme
       (define (list-of-values exps env)
         (if (no-operands? exps)
             '()
             (cons (eval (first-operand exps) env)
                   (list-of-values
                    (rest-operands exps)
                    env))))
     < src..

**** Conditionals

     @c(Eval-if) evaluates the predicate part of an @c(if) expression in the given
     environment. If the result is true, @c(eval-if) evaluates the consequent,
     otherwise it evaluates the alternative:

     ..src > scheme
       (define (eval-if exp env)
         (if (true? (eval (if-predicate exp) env))
             (eval (if-consequent exp) env)
             (eval (if-alternative exp) env)))
     < src..

     The use of @c(true?) in @c(eval-if) highlights the issue of the connection
     between an implemented language and an implementation language. The
     @c(if-predicate) is evaluated in the language being implemented and thus
     yields a value in that language. The interpreter predicate @c(true?)
     translates that value into a value that can be tested by the @c(if) in the
     implementation language: The metacircular representation of truth might not be
     the same as that of the underlying Scheme.@n(210)

**** Sequences

     @c(Eval-sequence) is used by @c(apply) to evaluate the sequence of expressions
     in a procedure body and by @c(eval) to evaluate the sequence of expressions in
     a @c(begin) expression. It takes as arguments a sequence of expressions and an
     environment, and evaluates the expressions in the order in which they
     occur. The value returned is the value of the final expression.

     ..src > scheme
       (define (eval-sequence exps env)
         (cond ((last-exp? exps)
                (eval (first-exp exps) env))
               (else
                (eval (first-exp exps) env)
                (eval-sequence (rest-exps exps)
                               env))))
     < src..

**** Assignments and definitions

     The following procedure handles assignments to variables. It calls @c(eval) to
     find the value to be assigned and transmits the variable and the resulting
     value to @c(set-variable-value!) to be installed in the designated
     environment.

     ..src > scheme
       (define (eval-assignment exp env)
         (set-variable-value!
          (assignment-variable exp)
          (eval (assignment-value exp) env)
          env)
         'ok)
     < src..

     Definitions of variables are handled in a similar manner.@n(211)

     ..src > scheme
       (define (eval-definition exp env)
         (define-variable!
           (definition-variable exp)
           (eval (definition-value exp) env)
           env)
         'ok)
     < src..

     We have chosen here to return the symbol @c(ok) as the value of an assignment
     or a definition.@n(212)

     :: @t(Exercise 4.1) :: Notice that we cannot tell whether the metacircular
        evaluator evaluates operands from left to right or from right to left. Its
        evaluation order is inherited from the underlying Lisp: If the arguments to
        @c(cons) in @c(list-of-values) are evaluated from left to right, then
        @c(list-of-values) will evaluate operands from left to right; and if the
        arguments to @c(cons) are evaluated from right to left, then
        @c(list-of-values) will evaluate operands from right to left.

        Write a version of @c(list-of-values) that evaluates operands from left to
        right regardless of the order of evaluation in the underlying Lisp. Also
        write a version of @c(list-of-values) that evaluates operands from right to
        left.

*** 4.1.2 <> Representing Expressions

    The evaluator is reminiscent of the symbolic differentiation program discussed
    in @l(#2.3.2). Both programs operate on symbolic expressions. In both
    programs, the result of operating on a compound expression is determined by
    operating recursively on the pieces of the expression and combining the
    results in a way that depends on the type of the expression. In both programs
    we used data abstraction to decouple the general rules of operation from the
    details of how expressions are represented. In the differentiation program
    this meant that the same differentiation procedure could deal with algebraic
    expressions in prefix form, in infix form, or in some other form. For the
    evaluator, this means that the syntax of the language being evaluated is
    determined solely by the procedures that classify and extract pieces of
    expressions.

    Here is the specification of the syntax of our language:

    - The only self-evaluating items are numbers and strings:

      ..src > scheme
        (define (self-evaluating? exp)
          (cond ((number? exp) true)
                ((string? exp) true)
                (else false)))
      < src..

    - Variables are represented by symbols:

      ..src > scheme
        (define (variable? exp) (symbol? exp))
      < src..

    - Quotations have the form @c[(quote ⟨text-of-quotation⟩)]:@n(213)

      ..src > scheme
        (define (quoted? exp)
          (tagged-list? exp 'quote))

        (define (text-of-quotation exp)
          (cadr exp))
      < src..

      @c(Quoted?) is defined in terms of the procedure @c(tagged-list?), which
      identifies lists beginning with a designated symbol:

      ..src > scheme
        (define (tagged-list? exp tag)
          (if (pair? exp)
              (eq? (car exp) tag)
              false))
      < src..

    - Assignments have the form @c[(set! ⟨var⟩ ⟨value⟩)]:

      ..src > scheme
        (define (assignment? exp)
          (tagged-list? exp 'set!))

        (define (assignment-variable exp)
          (cadr exp))

        (define (assignment-value exp) (caddr exp))
      < src..

    - Definitions have the form

      ..src > scheme
        (define ⟨var⟩ ⟨value⟩)
      < src..

      or the form

      ..src > scheme
        (define (⟨var⟩ ⟨param₁⟩ … ⟨paramₙ⟩)
          ⟨body⟩)
      < src..

      The latter form (standard procedure definition) is syntactic sugar for

      ..src > scheme
        (define ⟨var⟩
          (lambda (⟨param₁⟩ … ⟨paramₙ⟩)
            ⟨body⟩))
      < src..

      The corresponding syntax procedures are the following:

      ..src > scheme
        (define (definition? exp)
          (tagged-list? exp 'define))

        (define (definition-variable exp)
          (if (symbol? (cadr exp))
              (cadr exp)
              (caadr exp)))

        (define (definition-value exp)
          (if (symbol? (cadr exp))
              (caddr exp)
              (make-lambda
               (cdadr exp)   ; formal parameters
               (cddr exp)))) ; body
      < src..

    - @c(Lambda) expressions are lists that begin with the symbol @c(lambda):

      ..src > scheme
        (define (lambda? exp)
          (tagged-list? exp 'lambda))
        (define (lambda-parameters exp) (cadr exp))
        (define (lambda-body exp) (cddr exp))
      < src..

      We also provide a constructor for @c(lambda) expressions, which is used by
      @c(definition-value), above:

      ..src > scheme
        (define (make-lambda parameters body)
          (cons 'lambda (cons parameters body)))
      < src..

    - Conditionals begin with @c(if) and have a predicate, a consequent, and an
      (optional) alternative. If the expression has no alternative part, we
      provide @c(false) as the alternative.@n(214)

      ..src > scheme
        (define (if? exp) (tagged-list? exp 'if))
        (define (if-predicate exp) (cadr exp))
        (define (if-consequent exp) (caddr exp))
        (define (if-alternative exp)
          (if (not (null? (cdddr exp)))
              (cadddr exp)
              'false))
      < src..

      We also provide a constructor for @c(if) expressions, to be used by
      @c(cond->if) to transform @c(cond) expressions into @c(if) expressions:

      ..src > scheme
        (define (make-if predicate
                         consequent
                         alternative)
          (list 'if
                predicate
                consequent
                alternative))
      < src..

    - @c(Begin) packages a sequence of expressions into a single expression. We
      include syntax operations on @c(begin) expressions to extract the actual
      sequence from the @c(begin) expression, as well as selectors that return the
      first expression and the rest of the expressions in the sequence.@n(215)

      ..src > scheme
        (define (begin? exp)
          (tagged-list? exp 'begin))
        (define (begin-actions exp) (cdr exp))
        (define (last-exp? seq) (null? (cdr seq)))
        (define (first-exp seq) (car seq))
        (define (rest-exps seq) (cdr seq))
      < src..

      We also include a constructor @c(sequence->exp) (for use by @c(cond->if))
      that transforms a sequence into a single expression, using @c(begin) if
      necessary:

      ..src > scheme
        (define (sequence->exp seq)
          (cond ((null? seq) seq)
                ((last-exp? seq) (first-exp seq))
                (else (make-begin seq))))

        (define (make-begin seq) (cons 'begin seq))
      < src..

    - A procedure application is any compound expression that is not one of the
      above expression types. The @c(car) of the expression is the operator, and
      the @c(cdr) is the list of operands:

      ..src > scheme
        (define (application? exp) (pair? exp))
        (define (operator exp) (car exp))
        (define (operands exp) (cdr exp))
        (define (no-operands? ops) (null? ops))
        (define (first-operand ops) (car ops))
        (define (rest-operands ops) (cdr ops))
      < src..

**** Derived expressions

     Some special forms in our language can be defined in terms of expressions
     involving other special forms, rather than being implemented directly. One
     example is @c(cond), which can be implemented as a nest of @c(if)
     expressions. For example, we can reduce the problem of evaluating the
     expression

     ..src > scheme
       (cond ((> x 0) x)
             ((= x 0) (display 'zero) 0)
             (else (- x)))
     < src..

     to the problem of evaluating the following expression involving @c(if) and
     @c(begin) expressions:

     ..src > scheme
       (if (> x 0)
           x
           (if (= x 0)
               (begin (display 'zero) 0)
               (- x)))
     < src..

     Implementing the evaluation of @c(cond) in this way simplifies the evaluator
     because it reduces the number of special forms for which the evaluation
     process must be explicitly specified.

     We include syntax procedures that extract the parts of a @c(cond) expression,
     and a procedure @c(cond->if) that transforms @c(cond) expressions into @c(if)
     expressions. A case analysis begins with @c(cond) and has a list of
     predicate-action clauses. A clause is an @c(else) clause if its predicate is
     the symbol @c(else).@n(216)

     ..src > scheme
       (define (cond? exp)
         (tagged-list? exp 'cond))
       (define (cond-clauses exp) (cdr exp))
       (define (cond-else-clause? clause)
         (eq? (cond-predicate clause) 'else))
       (define (cond-predicate clause)
         (car clause))
       (define (cond-actions clause)
         (cdr clause))
       (define (cond->if exp)
         (expand-clauses (cond-clauses exp)))
       (define (expand-clauses clauses)
         (if (null? clauses)
             'false     ; no @c(else) clause
             (let ((first (car clauses))
                   (rest (cdr clauses)))
               (if (cond-else-clause? first)
                   (if (null? rest)
                       (sequence->exp
                        (cond-actions first))
                       (error "ELSE clause isn't
                               last: COND->IF"
                              clauses))
                   (make-if (cond-predicate first)
                            (sequence->exp
                             (cond-actions first))
                            (expand-clauses
                             rest))))))
     < src..

     Expressions (such as @c(cond)) that we choose to implement as syntactic
     transformations are called @e(derived expressions). @c(Let) expressions are
     also derived expressions (see @l(#Exercise 4.6)).@n(217)

     :: @t(Exercise 4.2) :: Louis Reasoner plans to reorder the @c(cond) clauses in
        @c(eval) so that the clause for procedure applications appears before the
        clause for assignments. He argues that this will make the interpreter more
        efficient: Since programs usually contain more applications than
        assignments, definitions, and so on, his modified @c(eval) will usually
        check fewer clauses than the original @c(eval) before identifying the type
        of an expression.

        1. What is wrong with Louis's plan?  (Hint: What will Louis's evaluator do
           with the expression @c[(define x 3)]?)

        2. Louis is upset that his plan didn't work. He is willing to go to any
           lengths to make his evaluator recognize procedure applications before it
           checks for most other kinds of expressions. Help him by changing the
           syntax of the evaluated language so that procedure applications start
           with @c(call). For example, instead of @c[(factorial 3)] we will now
           have to write @c[(call factorial 3)] and instead of @c[(+ 1 2)] we will
           have to write @c[(call + 1 2)].

     :: @t(Exercise 4.3) :: Rewrite @c(eval) so that the dispatch is done in
        data-directed style. Compare this with the data-directed differentiation
        procedure of @l(#Exercise 2.73). (You may use the @c(car) of a compound
        expression as the type of the expression, as is appropriate for the syntax
        implemented in this section.)

     :: @t(Exercise 4.4) :: Recall the definitions of the special forms @c(and) and
        @c(or) from @l(#Chapter 1):

        - @c(and): The expressions are evaluated from left to right. If any
          expression evaluates to false, false is returned; any remaining
          expressions are not evaluated. If all the expressions evaluate to true
          values, the value of the last expression is returned. If there are no
          expressions then true is returned.

        - @c(or): The expressions are evaluated from left to right. If any
          expression evaluates to a true value, that value is returned; any
          remaining expressions are not evaluated. If all expressions evaluate to
          false, or if there are no expressions, then false is returned.


        Install @c(and) and @c(or) as new special forms for the evaluator by
        defining appropriate syntax procedures and evaluation procedures
        @c(eval-and) and @c(eval-or). Alternatively, show how to implement @c(and)
        and @c(or) as derived expressions.

     :: @t(Exercise 4.5) :: Scheme allows an additional syntax for @c(cond)
        clauses, @c[(⟨test⟩ => ⟨recipient⟩)]. If @c[(test)] evaluates to a true
        value, then @c[(recipient)] is evaluated.  Its value must be a procedure of
        one argument; this procedure is then invoked on the value of the
        @c[(test)], and the result is returned as the value of the @c(cond)
        expression. For example

        ..src > scheme
          (cond ((assoc 'b '((a 1) (b 2))) => cadr)
                (else false))
        < src..

        returns 2. Modify the handling of @c(cond) so that it supports this
        extended syntax.

     :: @t(Exercise 4.6) :: @c(Let) expressions are derived expressions, because

        ..src > scheme
          (let ((⟨var₁⟩ ⟨exp₁⟩) … (⟨varₙ⟩ ⟨expₙ⟩))
            ⟨body⟩)
        < src..

        is equivalent to

        ..src > scheme
          ((lambda (⟨var₁⟩ … ⟨varₙ⟩)
             ⟨body⟩)
           ⟨exp₁⟩
           …
           ⟨expₙ⟩)
        < src..

        Implement a syntactic transformation @c(let->combination) that reduces
        evaluating @c(let) expressions to evaluating combinations of the type shown
        above, and add the appropriate clause to @c(eval) to handle @c(let)
        expressions.

     :: @t(Exercise 4.7) :: @c(Let*) is similar to @c(let), except that the
        bindings of the @c(let*) variables are performed sequentially from left to
        right, and each binding is made in an environment in which all of the
        preceding bindings are visible. For example

        ..src > scheme
          (let* ((x 3)
                 (y (+ x 2))
                 (z (+ x y 5)))
            (* x z))
        < src..

        returns 39. Explain how a @c(let*) expression can be rewritten as a set of
        nested @c(let) expressions, and write a procedure @c(let*->nested-lets)
        that performs this transformation. If we have already implemented @c(let)
        (@l(#Exercise 4.6)) and we want to extend the evaluator to handle @c(let*),
        is it sufficient to add a clause to @c(eval) whose action is

        ..src > scheme
          (eval (let*->nested-lets exp) env)
        < src..

        or must we explicitly expand @c(let*) in terms of non-derived expressions?

     :: @t(Exercise 4.8) :: @"(Named @c(let)) is a variant of @c(let) that has the
        form

        ..src > scheme
          (let ⟨var⟩ ⟨bindings⟩ ⟨body⟩)
        < src..

        The @c[(bindings)] and @c[(body)] are just as in ordinary @c(let), except
        that @c[(var)] is bound within @c[(body)] to a procedure whose body is
        @c[(body)] and whose parameters are the variables in the @c[(bindings)].
        Thus, one can repeatedly execute the @c[(body)] by invoking the procedure
        named @c[(var)]. For example, the iterative Fibonacci procedure
        (@l(#1.2.2)) can be rewritten using named @c(let) as follows:

        ..src > scheme
          (define (fib n)
            (let fib-iter ((a 1) (b 0) (count n))
              (if (= count 0)
                  b
                  (fib-iter (+ a b)
                            a
                            (- count 1)))))
        < src..

        Modify @c(let->combination) of @l(#Exercise 4.6) to also support named
        @c(let).

     :: @t(Exercise 4.9) :: Many languages support a variety of iteration
        constructs, such as @c(do), @c(for), @c(while), and @c(until). In Scheme,
        iterative processes can be expressed in terms of ordinary procedure calls,
        so special iteration constructs provide no essential gain in computational
        power. On the other hand, such constructs are often convenient. Design some
        iteration constructs, give examples of their use, and show how to implement
        them as derived expressions.

     :: @t(Exercise 4.10) :: By using data abstraction, we were able to write an
        @c(eval) procedure that is independent of the particular syntax of the
        language to be evaluated. To illustrate this, design and implement a new
        syntax for Scheme by modifying the procedures in this section, without
        changing @c(eval) or @c(apply).

*** 4.1.3 <> Evaluator Data Structures

    In addition to defining the external syntax of expressions, the evaluator
    implementation must also define the data structures that the evaluator
    manipulates internally, as part of the execution of a program, such as the
    representation of procedures and environments and the representation of true
    and false.

**** Testing of predicates

     For conditionals, we accept anything to be true that is not the explicit
     @c(false) object.

     ..src > scheme
       (define (true? x)
         (not (eq? x false)))

       (define (false? x)
         (eq? x false))
     < src..

**** Representing procedures

     To handle primitives, we assume that we have available the following
     procedures:

     - @c[(apply-primitive-procedure ⟨proc⟩ ⟨args⟩)]

       applies the given primitive procedure to the argument values in the list
       @c[(args)] and returns the result of the application.

     - @c[(primitive-procedure? ⟨proc⟩)]

       tests whether @c[(proc)] is a primitive procedure.


     These mechanisms for handling primitives are further described in @l(#4.1.4).

     Compound procedures are constructed from parameters, procedure bodies, and
     environments using the constructor @c(make-procedure):

     ..src > scheme
       (define (make-procedure parameters body env)
         (list 'procedure parameters body env))
       (define (compound-procedure? p)
         (tagged-list? p 'procedure))
       (define (procedure-parameters p) (cadr p))
       (define (procedure-body p) (caddr p))
       (define (procedure-environment p) (cadddr p))
     < src..

**** Operations on Environments

     The evaluator needs operations for manipulating environments. As explained in
     @l(#3.2), an environment is a sequence of frames, where each frame is a table
     of bindings that associate variables with their corresponding values.  We use
     the following operations for manipulating environments:

     - @c[(lookup-variable-value ⟨var⟩ ⟨env⟩)]

       returns the value that is bound to the symbol @c[(var)] in the environment
       @c[(env)], or signals an error if the variable is unbound.

     - @c[(extend-environment ⟨variables⟩ ⟨values⟩ ⟨base-env⟩)]

       returns a new environment, consisting of a new frame in which the symbols in
       the list @c[(variables)] are bound to the corresponding elements in the list
       @c[(values)], where the enclosing environment is the environment
       @c[(base-env)].

     - @c[(define-variable! ⟨var⟩ ⟨value⟩ ⟨env⟩)]

       adds to the first frame in the environment @c[(env)] a new binding that
       associates the variable @c[(var)] with the value @c[(value)].

     - @c[(set-variable-value! ⟨var⟩ ⟨value⟩ ⟨env⟩)]

       changes the binding of the variable @c[(var)] in the environment @c[(env)]
       so that the variable is now bound to the value @c[(value)], or signals an
       error if the variable is unbound.


     To implement these operations we represent an environment as a list of frames.
     The enclosing environment of an environment is the @c(cdr) of the list. The
     empty environment is simply the empty list.

     ..src > scheme
       (define (enclosing-environment env) (cdr env))
       (define (first-frame env) (car env))
       (define the-empty-environment '())
     < src..

     Each frame of an environment is represented as a pair of lists: a list of the
     variables bound in that frame and a list of the associated values.@n(218)

     ..src > scheme
       (define (make-frame variables values)
         (cons variables values))
       (define (frame-variables frame) (car frame))
       (define (frame-values frame) (cdr frame))
       (define (add-binding-to-frame! var val frame)
         (set-car! frame (cons var (car frame)))
         (set-cdr! frame (cons val (cdr frame))))
     < src..

     To extend an environment by a new frame that associates variables with values,
     we make a frame consisting of the list of variables and the list of values,
     and we adjoin this to the environment. We signal an error if the number of
     variables does not match the number of values.

     ..src > scheme
       (define (extend-environment vars vals base-env)
         (if (= (length vars) (length vals))
             (cons (make-frame vars vals) base-env)
             (if (< (length vars) (length vals))
                 (error "Too many arguments supplied"
                        vars
                        vals)
                 (error "Too few arguments supplied"
                        vars
                        vals))))
     < src..

     To look up a variable in an environment, we scan the list of variables in the
     first frame. If we find the desired variable, we return the corresponding
     element in the list of values. If we do not find the variable in the current
     frame, we search the enclosing environment, and so on. If we reach the empty
     environment, we signal an @"(unbound variable) error.

     ..src > scheme
       (define (lookup-variable-value var env)
         (define (env-loop env)
           (define (scan vars vals)
             (cond ((null? vars)
                    (env-loop
                     (enclosing-environment env)))
                   ((eq? var (car vars))
                    (car vals))
                   (else (scan (cdr vars)
                               (cdr vals)))))
           (if (eq? env the-empty-environment)
               (error "Unbound variable" var)
               (let ((frame (first-frame env)))
                 (scan (frame-variables frame)
                       (frame-values frame)))))
         (env-loop env))
     < src..

     To set a variable to a new value in a specified environment, we scan for the
     variable, just as in @c(lookup-variable-value), and change the corresponding
     value when we find it.

     ..src > scheme
       (define (set-variable-value! var val env)
         (define (env-loop env)
           (define (scan vars vals)
             (cond ((null? vars)
                    (env-loop
                     (enclosing-environment env)))
                   ((eq? var (car vars))
                    (set-car! vals val))
                   (else (scan (cdr vars)
                               (cdr vals)))))
           (if (eq? env the-empty-environment)
               (error "Unbound variable: SET!" var)
               (let ((frame (first-frame env)))
                 (scan (frame-variables frame)
                       (frame-values frame)))))
         (env-loop env))
     < src..

     To define a variable, we search the first frame for a binding for the
     variable, and change the binding if it exists (just as in
     @c(set-variable-value!)).  If no such binding exists, we adjoin one to the
     first frame.

     ..src > scheme
       (define (define-variable! var val env)
         (let ((frame (first-frame env)))
           (define (scan vars vals)
             (cond ((null? vars)
                    (add-binding-to-frame!
                     var val frame))
                   ((eq? var (car vars))
                    (set-car! vals val))
                   (else (scan (cdr vars)
                               (cdr vals)))))
           (scan (frame-variables frame)
                 (frame-values frame))))
     < src..

     The method described here is only one of many plausible ways to represent
     environments. Since we used data abstraction to isolate the rest of the
     evaluator from the detailed choice of representation, we could change the
     environment representation if we wanted to. (See @l(#Exercise 4.11).)  In a
     production-quality Lisp system, the speed of the evaluator's environment
     operations––especially that of variable lookup––has a major impact on the
     performance of the system. The representation described here, although
     conceptually simple, is not efficient and would not ordinarily be used in a
     production system.@n(219)

     :: @t(Exercise 4.11) :: Instead of representing a frame as a pair of lists, we
        can represent a frame as a list of bindings, where each binding is a
        name-value pair. Rewrite the environment operations to use this alternative
        representation.

     :: @t(Exercise 4.12) :: The procedures @c(define-variable!),
        @c(set-variable-value!) and @c(lookup-variable-value) can be expressed in
        terms of more abstract procedures for traversing the environment
        structure. Define abstractions that capture the common patterns and
        redefine the three procedures in terms of these abstractions.

     :: @t(Exercise 4.13) :: Scheme allows us to create new bindings for variables
        by means of @c(define), but provides no way to get rid of
        bindings. Implement for the evaluator a special form @c(make-unbound!) that
        removes the binding of a given symbol from the environment in which the
        @c(make-unbound!) expression is evaluated. This problem is not completely
        specified. For example, should we remove only the binding in the first
        frame of the environment?  Complete the specification and justify any
        choices you make.

*** 4.1.4 <> Running the Evaluator as a Program

    Given the evaluator, we have in our hands a description (expressed in Lisp) of
    the process by which Lisp expressions are evaluated. One advantage of
    expressing the evaluator as a program is that we can run the program. This
    gives us, running within Lisp, a working model of how Lisp itself evaluates
    expressions. This can serve as a framework for experimenting with evaluation
    rules, as we shall do later in this chapter.

    Our evaluator program reduces expressions ultimately to the application of
    primitive procedures. Therefore, all that we need to run the evaluator is to
    create a mechanism that calls on the underlying Lisp system to model the
    application of primitive procedures.

    There must be a binding for each primitive procedure name, so that when
    @c(eval) evaluates the operator of an application of a primitive, it will find
    an object to pass to @c(apply). We thus set up a global environment that
    associates unique objects with the names of the primitive procedures that can
    appear in the expressions we will be evaluating. The global environment also
    includes bindings for the symbols @c(true) and @c(false), so that they can be
    used as variables in expressions to be evaluated.

    ..src > scheme
      (define (setup-environment)
        (let ((initial-env
               (extend-environment
                (primitive-procedure-names)
                (primitive-procedure-objects)
                the-empty-environment)))
          (define-variable! 'true true initial-env)
          (define-variable! 'false false initial-env)
          initial-env))

      (define the-global-environment
        (setup-environment))
    < src..

    It does not matter how we represent the primitive procedure objects, so long
    as @c(apply) can identify and apply them by using the procedures
    @c(primitive-procedure?) and @c(apply-primitive-procedure). We have chosen to
    represent a primitive procedure as a list beginning with the symbol
    @c(primitive) and containing a procedure in the underlying Lisp that
    implements that primitive.

    ..src > scheme
      (define (primitive-procedure? proc)
        (tagged-list? proc 'primitive))

      (define (primitive-implementation proc)
        (cadr proc))
    < src..

    @c(Setup-environment) will get the primitive names and implementation
    procedures from a list:@n(220)

    ..src > scheme
      (define primitive-procedures
        (list (list 'car car)
              (list 'cdr cdr)
              (list 'cons cons)
              (list 'null? null?)
              ⟨more primitives⟩ ))

      (define (primitive-procedure-names)
        (map car primitive-procedures))

      (define (primitive-procedure-objects)
        (map (lambda (proc)
               (list 'primitive (cadr proc)))
             primitive-procedures))
    < src..

    To apply a primitive procedure, we simply apply the implementation procedure
    to the arguments, using the underlying Lisp system:@n(221)

    ..src > scheme
      (define (apply-primitive-procedure proc args)
        (apply-in-underlying-scheme
         (primitive-implementation proc) args))
    < src..

    For convenience in running the metacircular evaluator, we provide a @e(driver
    loop) that models the read-eval-print loop of the underlying Lisp system. It
    prints a @e(prompt), reads an input expression, evaluates this expression in
    the global environment, and prints the result. We precede each printed result
    by an @e(output prompt) so as to distinguish the value of the expression from
    other output that may be printed.@n(222)

    ..src > scheme
      (define input-prompt  ";;; M-Eval input:")
      (define output-prompt ";;; M-Eval value:")

      (define (driver-loop)
        (prompt-for-input input-prompt)
        (let ((input (read)))
          (let ((output
                 (eval input
                       the-global-environment)))
            (announce-output output-prompt)
            (user-print output)))
        (driver-loop))

      (define (prompt-for-input string)
        (newline) (newline)
        (display string) (newline))

      (define (announce-output string)
        (newline) (display string) (newline))
    < src..

    We use a special printing procedure, @c(user-print), to avoid printing the
    environment part of a compound procedure, which may be a very long list (or
    may even contain cycles).

    ..src > scheme
      (define (user-print object)
        (if (compound-procedure? object)
            (display
             (list 'compound-procedure
                   (procedure-parameters object)
                   (procedure-body object)
                   '<procedure-env>))
            (display object)))
    < src..

    Now all we need to do to run the evaluator is to initialize the global
    environment and start the driver loop. Here is a sample interaction:

    ..srci > scheme
      > (define the-global-environment
      ^   (setup-environment))
      > (driver-loop)
      > ;;; M-Eval input:
      > (define (append x y)
      ^   (if (null? x)
      ^       y
      ^       (cons (car x) (append (cdr x) y))))
      ;;; M-Eval value:
      ok
      > ;;; M-Eval input:
      > (append '(a b c) '(d e f))
      ;;; M-Eval value:
      (a b c d e f)
    < srci..

    :: @t(Exercise 4.14) :: Eva Lu Ator and Louis Reasoner are each experimenting
       with the metacircular evaluator. Eva types in the definition of @c(map),
       and runs some test programs that use it. They work fine. Louis, in
       contrast, has installed the system version of @c(map) as a primitive for
       the metacircular evaluator. When he tries it, things go terribly
       wrong. Explain why Louis's @c(map) fails even though Eva's works.

*** 4.1.5 <> Data as Programs

    In thinking about a Lisp program that evaluates Lisp expressions, an analogy
    might be helpful. One operational view of the meaning of a program is that a
    program is a description of an abstract (perhaps infinitely large) machine.
    For example, consider the familiar program to compute factorials:

    ..src > scheme
      (define (factorial n)
        (if (= n 1)
            1
            (* (factorial (- n 1)) n)))
    < src..

    We may regard this program as the description of a machine containing parts
    that decrement, multiply, and test for equality, together with a two-position
    switch and another factorial machine. (The factorial machine is infinite
    because it contains another factorial machine within it.)  @l(#Figure 4.2) is
    a flow diagram for the factorial machine, showing how the parts are wired
    together.

    ..figure > @t(Figure 4.2) The factorial program, viewed as an abstract
      machine.

      ..art >
            ╭────────────────────────────────────╮
            │ factorial                    │1    │
            │               │1             V     │
            │               │           ╭─────╮  │
            │               ▼           │ •   │  │
            │            ╭─────╮        │     │  │
        6 ──┼─────●─────▶│  =  ├───────▶│  •  ├──┼──▶ 720
            │     │      ╰─────╯        │  ╱  │  │
            │     │                     │  •  │  │
            │     │                     ╰─────╯  │
            │     │                        ▲     │
            │     │                        │     │
            │     │                     ╭──┴──╮  │
            │     ●────────────────────▶│  *  │  │
            │     │                     ╰─────╯  │
            │     ▼                        ▲     │
            │  ╭─────╮     ╭───────────╮   │     │
            │  │  ─  ├────▶│ factorial ├───╯     │
            │  ╰─────╯     ╰───────────╯         │
            │     ▲                              │
            │     │1                             │
            ╰────────────────────────────────────╯
      < art..

@   ..img > img/chap4/Fig4.2a.std.svg

    In a similar way, we can regard the evaluator as a very special machine that
    takes as input a description of a machine. Given this input, the evaluator
    configures itself to emulate the machine described. For example, if we feed
    our evaluator the definition of @c(factorial), as shown in @l(#Figure 4.3),
    the evaluator will be able to compute factorials.

    ..figure > @t(Figure 4.3) The evaluator emulating a factorial machine.

      ..art >
                           ╭────────╮
                    6 ────▶│  eval  ├────▶ 720
                           ╰────────╯
                               ◥
                     . . .    /  . . .
               . . .       ../. .      .
             .                           ..
            .   (define (factorial n)      . . .
           .      (if (= n 1)                   . .
            .         1                            .
            .         (* (factorial (- n 1)) n)))   .
              . .                       . .        .
                  . . . .      . . . .     . . . .
                           . ..
      < art..

@   ..img > img/chap4/Fig4.3.std.svg

    From this perspective, our evaluator is seen to be a @e(universal machine).
    It mimics other machines when these are described as Lisp programs.@n(223)
    This is striking. Try to imagine an analogous evaluator for electrical
    circuits. This would be a circuit that takes as input a signal encoding the
    plans for some other circuit, such as a filter. Given this input, the circuit
    evaluator would then behave like a filter with the same description. Such a
    universal electrical circuit is almost unimaginably complex. It is remarkable
    that the program evaluator is a rather simple program.@n(224)

    Another striking aspect of the evaluator is that it acts as a bridge between
    the data objects that are manipulated by our programming language and the
    programming language itself. Imagine that the evaluator program (implemented
    in Lisp) is running, and that a user is typing expressions to the evaluator
    and observing the results. From the perspective of the user, an input
    expression such as @c[(* x x)] is an expression in the programming language,
    which the evaluator should execute. From the perspective of the evaluator,
    however, the expression is simply a list (in this case, a list of three
    symbols: @c(*), @c(x), and @c(x)) that is to be manipulated according to a
    well-defined set of rules.

    That the user's programs are the evaluator's data need not be a source of
    confusion. In fact, it is sometimes convenient to ignore this distinction, and
    to give the user the ability to explicitly evaluate a data object as a Lisp
    expression, by making @c(eval) available for use in programs. Many Lisp
    dialects provide a primitive @c(eval) procedure that takes as arguments an
    expression and an environment and evaluates the expression relative to the
    environment.@n(225) Thus,

    ..src > scheme
      (eval '(* 5 5) user-initial-environment)
    < src..

    and

    ..src > scheme
      (eval (cons '* (list 5 5))
            user-initial-environment)
    < src..

    will both return 25.@n(226)

    :: @t(Exercise 4.15) :: Given a one-argument procedure @c(p) and an object
       @c(a), @c(p) is said to @"(halt) on @c(a) if evaluating the expression
       @c[(p a)] returns a value (as opposed to terminating with an error message
       or running forever). Show that it is impossible to write a procedure
       @c(halts?) that correctly determines whether @c(p) halts on @c(a) for any
       procedure @c(p) and object @c(a). Use the following reasoning: If you had
       such a procedure @c(halts?), you could implement the following program:

       ..src > scheme
         (define (run-forever)
           (run-forever))

         (define (try p)
           (if (halts? p p)
               (run-forever)
               'halted))
       < src..

       Now consider evaluating the expression @c[(try try)] and show that any
       possible outcome (either halting or running forever) violates the intended
       behavior of @c(halts?).@n(227)

*** 4.1.6 <> Internal Definitions

    Our environment model of evaluation and our metacircular evaluator execute
    definitions in sequence, extending the environment frame one definition at a
    time. This is particularly convenient for interactive program development, in
    which the programmer needs to freely mix the application of procedures with
    the definition of new procedures. However, if we think carefully about the
    internal definitions used to implement block structure (introduced in
    @l(#1.1.8)), we will find that name-by-name extension of the environment may
    not be the best way to define local variables.

    Consider a procedure with internal definitions, such as

    ..src > scheme
      (define (f x)
        (define (even? n)
          (if (= n 0)
              true
              (odd? (- n 1))))
        (define (odd? n)
          (if (= n 0)
              false
              (even? (- n 1))))
        ⟨rest of body of @c(f)⟩)
    < src..

    Our intention here is that the name @c(odd?) in the body of the procedure
    @c(even?) should refer to the procedure @c(odd?) that is defined after
    @c(even?). The scope of the name @c(odd?) is the entire body of @c(f), not
    just the portion of the body of @c(f) starting at the point where the
    @c(define) for @c(odd?) occurs. Indeed, when we consider that @c(odd?) is
    itself defined in terms of @c(even?)––so that @c(even?)  and @c(odd?) are
    mutually recursive procedures––we see that the only satisfactory
    interpretation of the two @c(define)s is to regard them as if the names
    @c(even?) and @c(odd?) were being added to the environment
    simultaneously. More generally, in block structure, the scope of a local name
    is the entire procedure body in which the @c(define) is evaluated.

    As it happens, our interpreter will evaluate calls to @c(f) correctly, but for
    an @"(accidental) reason: Since the definitions of the internal procedures
    come first, no calls to these procedures will be evaluated until all of them
    have been defined. Hence, @c(odd?)  will have been defined by the time
    @c(even?) is executed. In fact, our sequential evaluation mechanism will give
    the same result as a mechanism that directly implements simultaneous
    definition for any procedure in which the internal definitions come first in a
    body and evaluation of the value expressions for the defined variables doesn't
    actually use any of the defined variables. (For an example of a procedure that
    doesn't obey these restrictions, so that sequential definition isn't
    equivalent to simultaneous definition, see @l(#Exercise 4.19).)@n(228)

    There is, however, a simple way to treat definitions so that internally
    defined names have truly simultaneous scope––just create all local variables
    that will be in the current environment before evaluating any of the value
    expressions.  One way to do this is by a syntax transformation on @c(lambda)
    expressions.  Before evaluating the body of a @c(lambda) expression, we
    @"(scan out) and eliminate all the internal definitions in the body. The
    internally defined variables will be created with a @c(let) and then set to
    their values by assignment. For example, the procedure

    ..src > scheme
      (lambda ⟨vars⟩
        (define u ⟨e1⟩)
        (define v ⟨e2⟩)
        ⟨e3⟩)
    < src..

    would be transformed into

    ..src > scheme
      (lambda ⟨vars⟩
        (let ((u '*unassigned*)
              (v '*unassigned*))
          (set! u ⟨e1⟩)
          (set! v ⟨e2⟩)
          ⟨e3⟩))
    < src..

    where @c(*unassigned*) is a special symbol that causes looking up a variable
    to signal an error if an attempt is made to use the value of the
    not-yet-assigned variable.

    An alternative strategy for scanning out internal definitions is shown in
    @l(#Exercise 4.18). Unlike the transformation shown above, this enforces the
    restriction that the defined variables' values can be evaluated without using
    any of the variables' values.@n(229)

    :: @t(Exercise 4.16) :: In this exercise we implement the method just
       described for interpreting internal definitions. We assume that the
       evaluator supports @c(let) (see @l(#Exercise 4.6)).

       1. Change @c(lookup-variable-value) (@l(#4.1.3)) to signal an error if the
          value it finds is the symbol @c(*unassigned*).

       2. Write a procedure @c(scan-out-defines) that takes a procedure body and
          returns an equivalent one that has no internal definitions, by making
          the transformation described above.

       3. Install @c(scan-out-defines) in the interpreter, either in
          @c(make-procedure) or in @c(procedure-body) (see @l(#4.1.3)).  Which
          place is better?  Why?

    :: @t(Exercise 4.17) :: Draw diagrams of the environment in effect when
       evaluating the expression @c[(e3)] in the procedure in the text, comparing
       how this will be structured when definitions are interpreted sequentially
       with how it will be structured if definitions are scanned out as
       described. Why is there an extra frame in the transformed program?  Explain
       why this difference in environment structure can never make a difference in
       the behavior of a correct program. Design a way to make the interpreter
       implement the @"(simultaneous) scope rule for internal definitions without
       constructing the extra frame.

    :: @t(Exercise 4.18) :: Consider an alternative strategy for scanning out
       definitions that translates the example in the text to

       ..src > scheme
         (lambda ⟨vars⟩
           (let ((u '*unassigned*)
                 (v '*unassigned*))
             (let ((a ⟨e1⟩)
                   (b ⟨e2⟩))
               (set! u a)
               (set! v b))
             ⟨e3⟩))
       < src..

       Here @c(a) and @c(b) are meant to represent new variable names, created by
       the interpreter, that do not appear in the user's program. Consider the
       @c(solve) procedure from @l(#3.5.4):

       ..src > scheme
         (define (solve f y0 dt)
           (define y (integral (delay dy) y0 dt))
           (define dy (stream-map f y))
           y)
       < src..

       Will this procedure work if internal definitions are scanned out as shown
       in this exercise?  What if they are scanned out as shown in the text?
       Explain.

    :: @t(Exercise 4.19) :: Ben Bitdiddle, Alyssa P. Hacker, and Eva Lu Ator are
       arguing about the desired result of evaluating the expression

       ..src > scheme
         (let ((a 1))
           (define (f x)
             (define b (+ a x))
             (define a 5)
             (+ a b))
           (f 10))
       < src..

       Ben asserts that the result should be obtained using the sequential rule
       for @c(define): @c(b) is defined to be 11, then @c(a) is defined to be 5,
       so the result is 16. Alyssa objects that mutual recursion requires the
       simultaneous scope rule for internal procedure definitions, and that it is
       unreasonable to treat procedure names differently from other names. Thus,
       she argues for the mechanism implemented in @l(#Exercise 4.16). This would
       lead to @c(a) being unassigned at the time that the value for @c(b) is to
       be computed. Hence, in Alyssa's view the procedure should produce an
       error. Eva has a third opinion. She says that if the definitions of @c(a)
       and @c(b) are truly meant to be simultaneous, then the value 5 for @c(a)
       should be used in evaluating @c(b). Hence, in Eva's view @c(a) should be 5,
       @c(b) should be 15, and the result should be 20. Which (if any) of these
       viewpoints do you support?  Can you devise a way to implement internal
       definitions so that they behave as Eva prefers?@n(230)

    :: @t(Exercise 4.20) :: Because internal definitions look sequential but are
       actually simultaneous, some people prefer to avoid them entirely, and use
       the special form @c(letrec) instead. @c(Letrec) looks like @c(let), so it
       is not surprising that the variables it binds are bound simultaneously and
       have the same scope as each other. The sample procedure @c(f) above can be
       written without internal definitions, but with exactly the same meaning, as

       ..src > scheme
         (define (f x)
           (letrec
               ((even?
                 (lambda (n)
                   (if (= n 0)
                       true
                       (odd? (- n 1)))))
                (odd?
                 (lambda (n)
                   (if (= n 0)
                       false
                       (even? (- n 1))))))
             ⟨rest of body of @c(f)⟩))
       < src..

       @c(Letrec) expressions, which have the form

       ..src > scheme
         (letrec ((⟨var₁⟩ ⟨exp₁⟩) … (⟨varₙ⟩ ⟨expₙ⟩))
           ⟨body⟩)
       < src..

       are a variation on @c(let) in which the expressions @m[⟨expₙ⟩] that provide
       the initial values for the variables @m[⟨varₙ⟩] are evaluated in an
       environment that includes all the @c(letrec) bindings. This permits
       recursion in the bindings, such as the mutual recursion of @c(even?) and
       @c(odd?) in the example above, or the evaluation of 10 factorial with

       ..src > scheme
         (letrec
             ((fact
               (lambda (n)
                 (if (= n 1)
                     1
                     (* n (fact (- n 1)))))))
           (fact 10))
       < src..

       1. Implement @c(letrec) as a derived expression, by transforming a
          @c(letrec) expression into a @c(let) expression as shown in the text
          above or in @l(#Exercise 4.18). That is, the @c(letrec) variables should
          be created with a @c(let) and then be assigned their values with
          @c(set!).

       2. Louis Reasoner is confused by all this fuss about internal
          definitions. The way he sees it, if you don't like to use @c(define)
          inside a procedure, you can just use @c(let). Illustrate what is loose
          about his reasoning by drawing an environment diagram that shows the
          environment in which the @c[(rest of body of @c(f))] is evaluated during
          evaluation of the expression @c[(f 5)], with @c(f) defined as in this
          exercise. Draw an environment diagram for the same evaluation, but with
          @c(let) in place of @c(letrec) in the definition of @c(f).

    :: @t(Exercise 4.21) :: Amazingly, Louis's intuition in @l(#Exercise 4.20) is
       correct. It is indeed possible to specify recursive procedures without
       using @c(letrec) (or even @c(define)), although the method for
       accomplishing this is much more subtle than Louis imagined. The following
       expression computes 10 factorial by applying a recursive factorial
       procedure:@n(231)

       ..src > scheme
         ((lambda (n)
            ((lambda (fact) (fact fact n))
             (lambda (ft k)
               (if (= k 1)
                   1
                   (* k (ft ft (- k 1)))))))
          10)
       < src..

       1. Check (by evaluating the expression) that this really does compute
          factorials.  Devise an analogous expression for computing Fibonacci
          numbers.

       2. Consider the following procedure, which includes mutually recursive
          internal definitions:

          ..src > scheme
            (define (f x)
              (define (even? n)
                (if (= n 0)
                    true
                    (odd? (- n 1))))
              (define (odd? n)
                (if (= n 0)
                    false
                    (even? (- n 1))))
              (even? x))
          < src..

          Fill in the missing expressions to complete an alternative definition of
          @c(f), which uses neither internal definitions nor @c(letrec):

          ..src > scheme
            (define (f x)
              ((lambda (even? odd?)
                 (even? even? odd? x))
               (lambda (ev? od? n)
                 (if (= n 0)
                     true
                     (od? ⟨??⟩ ⟨??⟩ ⟨??⟩)))
               (lambda (ev? od? n)
                 (if (= n 0)
                     false
                     (ev? ⟨??⟩ ⟨??⟩ ⟨??⟩)))))
          < src..

*** 4.1.7 <> Separating Syntactic Analysis from Execution

    The evaluator implemented above is simple, but it is very inefficient, because
    the syntactic analysis of expressions is interleaved with their execution.
    Thus if a program is executed many times, its syntax is analyzed many times.
    Consider, for example, evaluating @c[(factorial 4)] using the following
    definition of @c(factorial):

    ..src > scheme
      (define (factorial n)
        (if (= n 1)
            1
            (* (factorial (- n 1)) n)))
    < src..

    Each time @c(factorial) is called, the evaluator must determine that the body
    is an @c(if) expression and extract the predicate. Only then can it evaluate
    the predicate and dispatch on its value. Each time it evaluates the expression
    @c[(* (factorial (- n 1)) n)], or the subexpressions @c[(factorial (- n 1))]
    and @c[(- n 1)], the evaluator must perform the case analysis in @c(eval) to
    determine that the expression is an application, and must extract its operator
    and operands. This analysis is expensive. Performing it repeatedly is
    wasteful.

    We can transform the evaluator to be significantly more efficient by arranging
    things so that syntactic analysis is performed only once.@n(232) We split
    @c(eval), which takes an expression and an environment, into two parts. The
    procedure @c(analyze) takes only the expression. It performs the syntactic
    analysis and returns a new procedure, the @e(execution procedure), that
    encapsulates the work to be done in executing the analyzed expression. The
    execution procedure takes an environment as its argument and completes the
    evaluation. This saves work because @c(analyze) will be called only once on an
    expression, while the execution procedure may be called many times.

    With the separation into analysis and execution, @c(eval) now becomes

    ..src > scheme
      (define (eval exp env) ((analyze exp) env))
    < src..

    The result of calling @c(analyze) is the execution procedure to be applied to
    the environment. The @c(analyze) procedure is the same case analysis as
    performed by the original @c(eval) of @l(#4.1.1), except that the procedures
    to which we dispatch perform only analysis, not full evaluation:

    ..src > scheme
      (define (analyze exp)
        (cond ((self-evaluating? exp)
               (analyze-self-evaluating exp))
              ((quoted? exp)
               (analyze-quoted exp))
              ((variable? exp)
               (analyze-variable exp))
              ((assignment? exp)
               (analyze-assignment exp))
              ((definition? exp)
               (analyze-definition exp))
              ((if? exp)
               (analyze-if exp))
              ((lambda? exp)
               (analyze-lambda exp))
              ((begin? exp)
               (analyze-sequence
                (begin-actions exp)))
              ((cond? exp)
               (analyze (cond->if exp)))
              ((application? exp)
               (analyze-application exp))
              (else
               (error "Unknown expression
                       type: ANALYZE"
                      exp))))
    < src..

    Here is the simplest syntactic analysis procedure, which handles
    self-evaluating expressions. It returns an execution procedure that ignores
    its environment argument and just returns the expression:

    ..src > scheme
      (define (analyze-self-evaluating exp)
        (lambda (env) exp))
    < src..

    For a quoted expression, we can gain a little efficiency by extracting the
    text of the quotation only once, in the analysis phase, rather than in the
    execution phase.

    ..src > scheme
      (define (analyze-quoted exp)
        (let ((qval (text-of-quotation exp)))
          (lambda (env) qval)))
    < src..

    Looking up a variable value must still be done in the execution phase, since
    this depends upon knowing the environment.@n(233)

    ..src > scheme
      (define (analyze-variable exp)
        (lambda (env)
          (lookup-variable-value exp env)))
    < src..

    @c(Analyze-assignment) also must defer actually setting the variable until the
    execution, when the environment has been supplied. However, the fact that the
    @c(assignment-value) expression can be analyzed (recursively) during analysis
    is a major gain in efficiency, because the @c(assignment-value) expression
    will now be analyzed only once. The same holds true for definitions.

    ..src > scheme
      (define (analyze-assignment exp)
        (let ((var (assignment-variable exp))
              (vproc (analyze
                      (assignment-value exp))))
          (lambda (env)
            (set-variable-value!
             var (vproc env) env)
            'ok)))

      (define (analyze-definition exp)
        (let ((var (definition-variable exp))
              (vproc (analyze
                      (definition-value exp))))
          (lambda (env)
            (define-variable! var (vproc env) env)
            'ok)))
    < src..

    For @c(if) expressions, we extract and analyze the predicate, consequent, and
    alternative at analysis time.

    ..src > scheme
      (define (analyze-if exp)
        (let ((pproc (analyze (if-predicate exp)))
              (cproc (analyze (if-consequent exp)))
              (aproc (analyze (if-alternative exp))))
          (lambda (env)
            (if (true? (pproc env))
                (cproc env)
                (aproc env)))))
    < src..

    Analyzing a @c(lambda) expression also achieves a major gain in efficiency: We
    analyze the @c(lambda) body only once, even though procedures resulting from
    evaluation of the @c(lambda) may be applied many times.

    ..src > scheme
      (define (analyze-lambda exp)
        (let ((vars (lambda-parameters exp))
              (bproc (analyze-sequence
                      (lambda-body exp))))
          (lambda (env)
            (make-procedure vars bproc env))))
    < src..

    Analysis of a sequence of expressions (as in a @c(begin) or the body of a
    @c(lambda) expression) is more involved.@n(234) Each expression in the
    sequence is analyzed, yielding an execution procedure. These execution
    procedures are combined to produce an execution procedure that takes an
    environment as argument and sequentially calls each individual execution
    procedure with the environment as argument.

    ..src > scheme
      (define (analyze-sequence exps)
        (define (sequentially proc1 proc2)
          (lambda (env) (proc1 env) (proc2 env)))
        (define (loop first-proc rest-procs)
          (if (null? rest-procs)
              first-proc
              (loop (sequentially first-proc
                                  (car rest-procs))
                    (cdr rest-procs))))
        (let ((procs (map analyze exps)))
          (if (null? procs)
              (error "Empty sequence: ANALYZE"))
          (loop (car procs) (cdr procs))))
    < src..

    To analyze an application, we analyze the operator and operands and construct
    an execution procedure that calls the operator execution procedure (to obtain
    the actual procedure to be applied) and the operand execution procedures (to
    obtain the actual arguments). We then pass these to @c(execute-application),
    which is the analog of @c(apply) in @l(#4.1.1). @c(Execute-application)
    differs from @c(apply) in that the procedure body for a compound procedure has
    already been analyzed, so there is no need to do further analysis. Instead, we
    just call the execution procedure for the body on the extended environment.

    ..src > scheme
      (define (analyze-application exp)
        (let ((fproc (analyze (operator exp)))
              (aprocs (map analyze (operands exp))))
          (lambda (env)
            (execute-application
             (fproc env)
             (map (lambda (aproc) (aproc env))
                  aprocs)))))

      (define (execute-application proc args)
        (cond ((primitive-procedure? proc)
               (apply-primitive-procedure proc args))
              ((compound-procedure? proc)
               ((procedure-body proc)
                (extend-environment
                 (procedure-parameters proc)
                 args
                 (procedure-environment proc))))
              (else (error "Unknown procedure type:
                            EXECUTE-APPLICATION"
                           proc))))
    < src..

    Our new evaluator uses the same data structures, syntax procedures, and
    run-time support procedures as in @l(#4.1.2), @l(#4.1.3), and @l(#4.1.4).

    :: @t(Exercise 4.22) :: Extend the evaluator in this section to support the
       special form @c(let). (See @l(#Exercise 4.6).)

    :: @t(Exercise 4.23) :: Alyssa P. Hacker doesn't understand why
       @c(analyze-sequence) needs to be so complicated. All the other analysis
       procedures are straightforward transformations of the corresponding
       evaluation procedures (or @c(eval) clauses) in @l(#4.1.1). She expected
       @c(analyze-sequence) to look like this:

       ..src > scheme
         (define (analyze-sequence exps)
           (define (execute-sequence procs env)
             (cond ((null? (cdr procs))
                    ((car procs) env))
                   (else ((car procs) env)
                         (execute-sequence
                          (cdr procs) env))))
           (let ((procs (map analyze exps)))
             (if (null? procs)
                 (error "Empty sequence:
                         ANALYZE"))
             (lambda (env)
               (execute-sequence procs env))))
       < src..

       Eva Lu Ator explains to Alyssa that the version in the text does more of
       the work of evaluating a sequence at analysis time. Alyssa's
       sequence-execution procedure, rather than having the calls to the
       individual execution procedures built in, loops through the procedures in
       order to call them: In effect, although the individual expressions in the
       sequence have been analyzed, the sequence itself has not been.

       Compare the two versions of @c(analyze-sequence). For example, consider the
       common case (typical of procedure bodies) where the sequence has just one
       expression. What work will the execution procedure produced by Alyssa's
       program do?  What about the execution procedure produced by the program in
       the text above?  How do the two versions compare for a sequence with two
       expressions?

    :: @t(Exercise 4.24) :: Design and carry out some experiments to compare the
       speed of the original metacircular evaluator with the version in this
       section. Use your results to estimate the fraction of time that is spent in
       analysis versus execution for various procedures.

** 4.2 <> Variations on a Scheme –– Lazy Evaluation

   Now that we have an evaluator expressed as a Lisp program, we can experiment
   with alternative choices in language design simply by modifying the evaluator.
   Indeed, new languages are often invented by first writing an evaluator that
   embeds the new language within an existing high-level language. For example,
   if we wish to discuss some aspect of a proposed modification to Lisp with
   another member of the Lisp community, we can supply an evaluator that embodies
   the change. The recipient can then experiment with the new evaluator and send
   back comments as further modifications. Not only does the high-level
   implementation base make it easier to test and debug the evaluator; in
   addition, the embedding enables the designer to snarf@n(235) features from the
   underlying language, just as our embedded Lisp evaluator uses primitives and
   control structure from the underlying Lisp. Only later (if ever) need the
   designer go to the trouble of building a complete implementation in a
   low-level language or in hardware. In this section and the next we explore
   some variations on Scheme that provide significant additional expressive
   power.

*** 4.2.1 <> Normal Order and Applicative Order

    In @l(#1.1), where we began our discussion of models of evaluation, we noted
    that Scheme is an @e(applicative-order) language, namely, that all the
    arguments to Scheme procedures are evaluated when the procedure is applied.
    In contrast, @e(normal-order) languages delay evaluation of procedure
    arguments until the actual argument values are needed. Delaying evaluation of
    procedure arguments until the last possible moment (e.g., until they are
    required by a primitive operation) is called @e(lazy evaluation).@n(236)
    Consider the procedure

    ..src > scheme
      (define (try a b)
        (if (= a 0) 1 b))
    < src..

    Evaluating @c[(try 0 (/ 1 0))] generates an error in Scheme. With lazy
    evaluation, there would be no error. Evaluating the expression would return 1,
    because the argument @c[(/ 1 0)] would never be evaluated.

    An example that exploits lazy evaluation is the definition of a procedure
    @c(unless)

    ..src > scheme
      (define (unless condition
                      usual-value
                      exceptional-value)
        (if condition
            exceptional-value
            usual-value))
    < src..

    that can be used in expressions such as

    ..src > scheme
      (unless (= b 0)
              (/ a b)
              (begin
                (display "exception: returning 0")
                0))
    < src..

    This won't work in an applicative-order language because both the usual value
    and the exceptional value will be evaluated before @c(unless) is called
    (compare @l(#Exercise 1.6)). An advantage of lazy evaluation is that some
    procedures, such as @c(unless), can do useful computation even if evaluation
    of some of their arguments would produce errors or would not terminate.

    If the body of a procedure is entered before an argument has been evaluated we
    say that the procedure is @e(non-strict) in that argument. If the argument is
    evaluated before the body of the procedure is entered we say that the
    procedure is @e(strict) in that argument.@n(237) In a purely applicative-order
    language, all procedures are strict in each argument. In a purely normal-order
    language, all compound procedures are non-strict in each argument, and
    primitive procedures may be either strict or non-strict. There are also
    languages (see @l(#Exercise 4.31)) that give programmers detailed control over
    the strictness of the procedures they define.

    A striking example of a procedure that can usefully be made non-strict is
    @c(cons) (or, in general, almost any constructor for data structures). One can
    do useful computation, combining elements to form data structures and
    operating on the resulting data structures, even if the values of the elements
    are not known. It makes perfect sense, for instance, to compute the length of
    a list without knowing the values of the individual elements in the list. We
    will exploit this idea in @l(#4.2.3) to implement the streams of
    @l(#Chapter 3) as lists formed of non-strict @c(cons) pairs.

    :: @t(Exercise 4.25) :: Suppose that (in ordinary applicative-order Scheme) we
       define @c(unless) as shown above and then define @c(factorial) in terms of
       @c(unless) as

       ..src > scheme
         (define (factorial n)
           (unless (= n 1)
                   (* n (factorial (- n 1)))
                   1))
       < src..

       What happens if we attempt to evaluate @c[(factorial 5)]?  Will our
       definitions work in a normal-order language?

    :: @t(Exercise 4.26) :: Ben Bitdiddle and Alyssa P. Hacker disagree over the
       importance of lazy evaluation for implementing things such as
       @c(unless). Ben points out that it's possible to implement @c(unless) in
       applicative order as a special form. Alyssa counters that, if one did that,
       @c(unless) would be merely syntax, not a procedure that could be used in
       conjunction with higher-order procedures. Fill in the details on both sides
       of the argument. Show how to implement @c(unless) as a derived expression
       (like @c(cond) or @c(let)), and give an example of a situation where it
       might be useful to have @c(unless) available as a procedure, rather than as
       a special form.

*** 4.2.2 <> An Interpreter with Lazy Evaluation

    In this section we will implement a normal-order language that is the same as
    Scheme except that compound procedures are non-strict in each argument.
    Primitive procedures will still be strict. It is not difficult to modify the
    evaluator of @l(#4.1.1) so that the language it interprets behaves this
    way. Almost all the required changes center around procedure application.

    The basic idea is that, when applying a procedure, the interpreter must
    determine which arguments are to be evaluated and which are to be delayed. The
    delayed arguments are not evaluated; instead, they are transformed into
    objects called @e(thunks).@n(238) The thunk must contain the information
    required to produce the value of the argument when it is needed, as if it had
    been evaluated at the time of the application. Thus, the thunk must contain
    the argument expression and the environment in which the procedure application
    is being evaluated.

    The process of evaluating the expression in a thunk is called
    @e(forcing).@n(239) In general, a thunk will be forced only when its value is
    needed: when it is passed to a primitive procedure that will use the value of
    the thunk; when it is the value of a predicate of a conditional; and when it
    is the value of an operator that is about to be applied as a procedure. One
    design choice we have available is whether or not to @e(memoize) thunks, as we
    did with delayed objects in @l(#3.5.1). With memoization, the first time a
    thunk is forced, it stores the value that is computed. Subsequent forcings
    simply return the stored value without repeating the computation. We'll make
    our interpreter memoize, because this is more efficient for many applications.
    There are tricky considerations here, however.@n(240)

**** Modifying the evaluator

     The main difference between the lazy evaluator and the one in @l(#4.1) is in
     the handling of procedure applications in @c(eval) and @c(apply).

     The @c(application?) clause of @c(eval) becomes

     ..src > scheme
       ((application? exp)
        (apply (actual-value (operator exp) env)
               (operands exp)
               env))
     < src..

     This is almost the same as the @c(application?) clause of @c(eval) in
     @l(#4.1.1). For lazy evaluation, however, we call @c(apply) with the operand
     expressions, rather than the arguments produced by evaluating them.  Since we
     will need the environment to construct thunks if the arguments are to be
     delayed, we must pass this as well. We still evaluate the operator, because
     @c(apply) needs the actual procedure to be applied in order to dispatch on its
     type (primitive versus compound) and apply it.

     Whenever we need the actual value of an expression, we use

     ..src > scheme
       (define (actual-value exp env)
         (force-it (eval exp env)))
     < src..

     instead of just @c(eval), so that if the expression's value is a thunk, it
     will be forced.

     Our new version of @c(apply) is also almost the same as the version in
     @l(#4.1.1). The difference is that @c(eval) has passed in unevaluated operand
     expressions: For primitive procedures (which are strict), we evaluate all the
     arguments before applying the primitive; for compound procedures (which are
     non-strict) we delay all the arguments before applying the procedure.

     ..src > scheme
       (define (apply procedure arguments env)
         (cond ((primitive-procedure? procedure)
                (apply-primitive-procedure
                 procedure
                 (list-of-arg-values
                  arguments
                  env)))  ; changed
               ((compound-procedure? procedure)
                (eval-sequence
                 (procedure-body procedure)
                 (extend-environment
                  (procedure-parameters procedure)
                  (list-of-delayed-args
                   arguments
                   env)   ; changed
                  (procedure-environment procedure))))
               (else (error "Unknown procedure
                             type: APPLY"
                            procedure))))
     < src..

     The procedures that process the arguments are just like @c(list-of-values)
     from @l(#4.1.1), except that @c(list-of-delayed-args) delays the arguments
     instead of evaluating them, and @c(list-of-arg-values) uses @c(actual-value)
     instead of @c(eval):

     ..src > scheme
       (define (list-of-arg-values exps env)
         (if (no-operands? exps)
             '()
             (cons (actual-value
                    (first-operand exps)
                    env)
                   (list-of-arg-values
                    (rest-operands exps)
                    env))))

       (define (list-of-delayed-args exps env)
         (if (no-operands? exps)
             '()
             (cons (delay-it
                    (first-operand exps)
                    env)
                   (list-of-delayed-args
                    (rest-operands exps)
                    env))))
     < src..

     The other place we must change the evaluator is in the handling of @c(if),
     where we must use @c(actual-value) instead of @c(eval) to get the value of the
     predicate expression before testing whether it is true or false:

     ..src > scheme
       (define (eval-if exp env)
         (if (true? (actual-value (if-predicate exp)
                                  env))
             (eval (if-consequent exp) env)
             (eval (if-alternative exp) env)))
     < src..

     Finally, we must change the @c(driver-loop) procedure (@l(#4.1.4)) to use
     @c(actual-value) instead of @c(eval), so that if a delayed value is propagated
     back to the read-eval-print loop, it will be forced before being printed. We
     also change the prompts to indicate that this is the lazy evaluator:

     ..src > scheme
       (define input-prompt  ";;; L-Eval input:")
       (define output-prompt ";;; L-Eval value:")

       (define (driver-loop)
         (prompt-for-input input-prompt)
         (let ((input (read)))
           (let ((output (actual-value
                          input
                          the-global-environment)))
             (announce-output output-prompt)
             (user-print output)))
         (driver-loop))
     < src..

     With these changes made, we can start the evaluator and test it. The
     successful evaluation of the @c(try) expression discussed in @l(#4.2.1)
     indicates that the interpreter is performing lazy evaluation:

     ..srci > scheme
       > (define the-global-environment
       ^   (setup-environment))
       > (driver-loop)
       ;;; L-Eval input:
       > (define (try a b) (if (= a 0) 1 b))
       ;;; L-Eval value:
       ok
       ;;; L-Eval input:
       > (try 0 (/ 1 0))
       ;;; L-Eval value:
       1
     < srci..

**** Representing thunks

     Our evaluator must arrange to create thunks when procedures are applied to
     arguments and to force these thunks later. A thunk must package an expression
     together with the environment, so that the argument can be produced later. To
     force the thunk, we simply extract the expression and environment from the
     thunk and evaluate the expression in the environment. We use @c(actual-value)
     rather than @c(eval) so that in case the value of the expression is itself a
     thunk, we will force that, and so on, until we reach something that is not a
     thunk:

     ..src > scheme
       (define (force-it obj)
         (if (thunk? obj)
             (actual-value (thunk-exp obj)
                           (thunk-env obj))
             obj))
     < src..

     One easy way to package an expression with an environment is to make a list
     containing the expression and the environment. Thus, we create a thunk as
     follows:

     ..src > scheme
       (define (delay-it exp env)
         (list 'thunk exp env))
       (define (thunk? obj) (tagged-list? obj 'thunk))
       (define (thunk-exp thunk) (cadr thunk))
       (define (thunk-env thunk) (caddr thunk))
     < src..

     Actually, what we want for our interpreter is not quite this, but rather
     thunks that have been memoized. When a thunk is forced, we will turn it into
     an evaluated thunk by replacing the stored expression with its value and
     changing the @c(thunk) tag so that it can be recognized as already
     evaluated.@n(241)

     ..src > scheme
       (define (evaluated-thunk? obj)
         (tagged-list? obj 'evaluated-thunk))

       (define (thunk-value evaluated-thunk)
         (cadr evaluated-thunk))

       (define (force-it obj)
         (cond ((thunk? obj)
                (let ((result
                       (actual-value
                        (thunk-exp obj)
                        (thunk-env obj))))
                  (set-car! obj 'evaluated-thunk)
                  ;; replace @c(exp) with its value:
                  (set-car! (cdr obj) result)
                  ;; forget unneeded @c(env):
                  (set-cdr! (cdr obj) '())
                  result))
               ((evaluated-thunk? obj)
                (thunk-value obj))
               (else obj)))
     < src..

     Notice that the same @c(delay-it) procedure works both with and without
     memoization.

     :: @t(Exercise 4.27) :: Suppose we type in the following definitions to the
        lazy evaluator:

        ..src > scheme
          (define count 0)
          (define (id x) (set! count (+ count 1)) x)
        < src..

        Give the missing values in the following sequence of interactions, and
        explain your answers.@n(242)

        ..srci > scheme
          > (define w (id (id 10)))
          ;;; L-Eval input:
          > count
          ;;; L-Eval value:
          > ⟨response⟩
          ;;; L-Eval input:
          > w
          ;;; L-Eval value:
          > ⟨response⟩
          ;;; L-Eval input:
          > count
          ;;; L-Eval value:
          > ⟨response⟩
        < srci..

     :: @t(Exercise 4.28) :: @c(Eval) uses @c(actual-value) rather than @c(eval) to
        evaluate the operator before passing it to @c(apply), in order to force the
        value of the operator. Give an example that demonstrates the need for this
        forcing.

     :: @t(Exercise 4.29) :: Exhibit a program that you would expect to run much
        more slowly without memoization than with memoization.  Also, consider the
        following interaction, where the @c(id) procedure is defined as in
        @l(#Exercise 4.27) and @c(count) starts at 0:

        ..srci > scheme
          > (define (square x) (* x x))
          ;;; L-Eval input:
          > (square (id 10))
          ;;; L-Eval value:
          > ⟨response⟩
          ;;; L-Eval input:
          > count
          ;;; L-Eval value:
          > ⟨response⟩
        < srci..

        Give the responses both when the evaluator memoizes and when it does not.

     :: @t(Exercise 4.30) :: Cy D. Fect, a reformed C programmer, is worried that
        some side effects may never take place, because the lazy evaluator doesn't
        force the expressions in a sequence. Since the value of an expression in a
        sequence other than the last one is not used (the expression is there only
        for its effect, such as assigning to a variable or printing), there can be
        no subsequent use of this value (e.g., as an argument to a primitive
        procedure) that will cause it to be forced. Cy thus thinks that when
        evaluating sequences, we must force all expressions in the sequence except
        the final one. He proposes to modify @c(eval-sequence) from @l(#4.1.1) to
        use @c(actual-value) rather than @c(eval):

        ..src > scheme
          (define (eval-sequence exps env)
            (cond ((last-exp? exps)
                   (eval (first-exp exps) env))
                  (else
                   (actual-value (first-exp exps)
                                 env)
                   (eval-sequence (rest-exps exps)
                                  env))))
        < src..

        1. Ben Bitdiddle thinks Cy is wrong. He shows Cy the @c(for-each) procedure
           described in @l(#Exercise 2.23), which gives an important example of a
           sequence with side effects:

           ..src > scheme
             (define (for-each proc items)
               (if (null? items)
                   'done
                   (begin (proc (car items))
                          (for-each proc
                                    (cdr items)))))
           < src..

           He claims that the evaluator in the text (with the original
           @c(eval-sequence)) handles this correctly:

           ..srci > scheme
             ;;; L-Eval input:
             > (for-each
             ^  (lambda (x) (newline) (display x))
             ^  (list 57 321 88))
             57
             321
             88

             ;;; L-Eval value:
             > done
           < srci..

           Explain why Ben is right about the behavior of @c(for-each).

        2. Cy agrees that Ben is right about the @c(for-each) example, but says
           that that's not the kind of program he was thinking about when he
           proposed his change to @c(eval-sequence). He defines the following two
           procedures in the lazy evaluator:

           ..src > scheme
             (define (p1 x)
               (set! x (cons x '(2))) x)

             (define (p2 x)
               (define (p e) e x)
               (p (set! x (cons x '(2)))))
           < src..

           What are the values of @c[(p1 1)] and @c[(p2 1)] with the original
           @c(eval-sequence)?  What would the values be with Cy's proposed change
           to @c(eval-sequence)?

        3. Cy also points out that changing @c(eval-sequence) as he proposes does
           not affect the behavior of the example in part a. Explain why this is
           true.

        4. How do you think sequences ought to be treated in the lazy evaluator?
           Do you like Cy's approach, the approach in the text, or some other
           approach?

     :: @t(Exercise 4.31) :: The approach taken in this section is somewhat
        unpleasant, because it makes an incompatible change to Scheme. It might be
        nicer to implement lazy evaluation as an @e(upward-compatible extension),
        that is, so that ordinary Scheme programs will work as before. We can do
        this by extending the syntax of procedure declarations to let the user
        control whether or not arguments are to be delayed. While we're at it, we
        may as well also give the user the choice between delaying with and without
        memoization. For example, the definition

        ..src > scheme
          (define (f a (b lazy) c (d lazy-memo))
            …)
        < src..

        would define @c(f) to be a procedure of four arguments, where the first and
        third arguments are evaluated when the procedure is called, the second
        argument is delayed, and the fourth argument is both delayed and
        memoized. Thus, ordinary procedure definitions will produce the same
        behavior as ordinary Scheme, while adding the @c(lazy-memo) declaration to
        each parameter of every compound procedure will produce the behavior of the
        lazy evaluator defined in this section. Design and implement the changes
        required to produce such an extension to Scheme. You will have to implement
        new syntax procedures to handle the new syntax for @c(define). You must
        also arrange for @c(eval) or @c(apply) to determine when arguments are to
        be delayed, and to force or delay arguments accordingly, and you must
        arrange for forcing to memoize or not, as appropriate.

*** 4.2.3 <> Streams as Lazy Lists

    In @l(#3.5.1), we showed how to implement streams as delayed lists.  We
    introduced special forms @c(delay) and @c(cons-stream), which allowed us to
    construct a @"(promise) to compute the @c(cdr) of a stream, without actually
    fulfilling that promise until later. We could use this general technique of
    introducing special forms whenever we need more control over the evaluation
    process, but this is awkward. For one thing, a special form is not a
    first-class object like a procedure, so we cannot use it together with
    higher-order procedures.@n(243) Additionally, we were forced to create streams
    as a new kind of data object similar but not identical to lists, and this
    required us to reimplement many ordinary list operations (@c(map), @c(append),
    and so on) for use with streams.

    With lazy evaluation, streams and lists can be identical, so there is no need
    for special forms or for separate list and stream operations. All we need to
    do is to arrange matters so that @c(cons) is non-strict. One way to accomplish
    this is to extend the lazy evaluator to allow for non-strict primitives, and
    to implement @c(cons) as one of these. An easier way is to recall (@l(#2.1.3))
    that there is no fundamental need to implement @c(cons) as a primitive at
    all. Instead, we can represent pairs as procedures:@n(244)

    ..src > scheme
      (define (cons x y) (lambda (m) (m x y)))
      (define (car z) (z (lambda (p q) p)))
      (define (cdr z) (z (lambda (p q) q)))
    < src..

    In terms of these basic operations, the standard definitions of the list
    operations will work with infinite lists (streams) as well as finite ones, and
    the stream operations can be implemented as list operations. Here are some
    examples:

    ..srci > scheme
      > (define (list-ref items n)
      ^   (if (= n 0)
      ^       (car items)
      ^       (list-ref (cdr items) (- n 1))))
      > (define (map proc items)
      ^   (if (null? items)
      ^       '()
      ^       (cons (proc (car items))
      ^             (map proc (cdr items)))))
      > (define (scale-list items factor)
      ^   (map (lambda (x) (* x factor))
      ^        items))
      > (define (add-lists list1 list2)
      ^   (cond ((null? list1) list2)
      ^         ((null? list2) list1)
      ^         (else (cons (+ (car list1)
      ^                        (car list2))
      ^                     (add-lists
      ^                      (cdr list1)
      ^                      (cdr list2))))))
      > (define ones (cons 1 ones))
      > (define integers
      ^   (cons 1 (add-lists ones integers)))
      ;;; L-Eval input:
      >  (list-ref integers 17)
      ;;; L-Eval value:
      18
    < srci..

    Note that these lazy lists are even lazier than the streams of @l(#Chapter 3):
    The @c(car) of the list, as well as the @c(cdr), is delayed.@n(245) In fact,
    even accessing the @c(car) or @c(cdr) of a lazy pair need not force the value
    of a list element. The value will be forced only when it is really
    needed––e.g., for use as the argument of a primitive, or to be printed as an
    answer.

    Lazy pairs also help with the problem that arose with streams in @l(#3.5.4),
    where we found that formulating stream models of systems with loops may
    require us to sprinkle our programs with explicit @c(delay) operations, beyond
    the ones supplied by @c(cons-stream). With lazy evaluation, all arguments to
    procedures are delayed uniformly. For instance, we can implement procedures to
    integrate lists and solve differential equations as we originally intended in
    @l(#3.5.4):

    ..srci > scheme
      > (define (integral integrand initial-value dt)
      ^   (define int
      ^     (cons initial-value
      ^           (add-lists (scale-list integrand dt)
      ^                      int)))
      ^   int)
      > (define (solve f y0 dt)
      ^   (define y (integral dy y0 dt))
      ^   (define dy (map f y))
      ^   y)
      ;;; L-Eval input:
      > (list-ref (solve (lambda (x) x) 1 0.001) 1000)
      ;;; L-Eval value:
      2.716924
    < srci..

    :: @t(Exercise 4.32) :: Give some examples that illustrate the difference
       between the streams of @l(#Chapter 3) and the @"(lazier) lazy lists
       described in this section. How can you take advantage of this extra
       laziness?

    :: @t(Exercise 4.33) :: Ben Bitdiddle tests the lazy list implementation given
       above by evaluating the expression

       ..src > scheme
         (car '(a b c))
       < src..

       To his surprise, this produces an error. After some thought, he realizes
       that the @"(lists) obtained by reading in quoted expressions are different
       from the lists manipulated by the new definitions of @c(cons), @c(car), and
       @c(cdr). Modify the evaluator's treatment of quoted expressions so that
       quoted lists typed at the driver loop will produce true lazy lists.

    :: @t(Exercise 4.34) :: Modify the driver loop for the evaluator so that lazy
       pairs and lists will print in some reasonable way.  (What are you going to
       do about infinite lists?)  You may also need to modify the representation
       of lazy pairs so that the evaluator can identify them in order to print
       them.

** 4.3 <> Variations on a Scheme –– Nondeterministic Computing

   In this section, we extend the Scheme evaluator to support a programming
   paradigm called @e(nondeterministic computing) by building into the evaluator
   a facility to support automatic search. This is a much more profound change to
   the language than the introduction of lazy evaluation in @l(#4.2).

   Nondeterministic computing, like stream processing, is useful for @"(generate
   and test) applications. Consider the task of starting with two lists of
   positive integers and finding a pair of integers––one from the first list and
   one from the second list––whose sum is prime. We saw how to handle this with
   finite sequence operations in @l(#2.2.3) and with infinite streams in
   @l(#3.5.3). Our approach was to generate the sequence of all possible pairs
   and filter these to select the pairs whose sum is prime. Whether we actually
   generate the entire sequence of pairs first as in @l(#Chapter 2), or
   interleave the generating and filtering as in @l(#Chapter 3), is immaterial to
   the essential image of how the computation is organized.

   The nondeterministic approach evokes a different image. Imagine simply that we
   choose (in some way) a number from the first list and a number from the second
   list and require (using some mechanism) that their sum be prime. This is
   expressed by following procedure:

   ..src > scheme
     (define (prime-sum-pair list1 list2)
       (let ((a (an-element-of list1))
             (b (an-element-of list2)))
         (require (prime? (+ a b)))
         (list a b)))
   < src..

   It might seem as if this procedure merely restates the problem, rather than
   specifying a way to solve it. Nevertheless, this is a legitimate
   nondeterministic program.@n(246)

   The key idea here is that expressions in a nondeterministic language can have
   more than one possible value. For instance, @c(an-element-of) might return any
   element of the given list. Our nondeterministic program evaluator will work by
   automatically choosing a possible value and keeping track of the choice. If a
   subsequent requirement is not met, the evaluator will try a different choice,
   and it will keep trying new choices until the evaluation succeeds, or until we
   run out of choices. Just as the lazy evaluator freed the programmer from the
   details of how values are delayed and forced, the nondeterministic program
   evaluator will free the programmer from the details of how choices are made.

   It is instructive to contrast the different images of time evoked by
   nondeterministic evaluation and stream processing. Stream processing uses lazy
   evaluation to decouple the time when the stream of possible answers is
   assembled from the time when the actual stream elements are produced. The
   evaluator supports the illusion that all the possible answers are laid out
   before us in a timeless sequence. With nondeterministic evaluation, an
   expression represents the exploration of a set of possible worlds, each
   determined by a set of choices. Some of the possible worlds lead to dead ends,
   while others have useful values. The nondeterministic program evaluator
   supports the illusion that time branches, and that our programs have different
   possible execution histories. When we reach a dead end, we can revisit a
   previous choice point and proceed along a different branch.

   The nondeterministic program evaluator implemented below is called the @c(amb)
   evaluator because it is based on a new special form called @c(amb). We can
   type the above definition of @c(prime-sum-pair) at the @c(amb) evaluator
   driver loop (along with definitions of @c(prime?), @c(an-element-of), and
   @c(require)) and run the procedure as follows:

   ..srci > scheme
     ;;; Amb-Eval input:
     > (prime-sum-pair '(1 3 5 8) '(20 35 110))
     ;;; Starting a new problem
     ;;; Amb-Eval value:
     (3 20)
   < srci..

   The value returned was obtained after the evaluator repeatedly chose elements
   from each of the lists, until a successful choice was made.

   Section @l(#4.3.1) introduces @c(amb) and explains how it supports
   nondeterminism through the evaluator's automatic search mechanism.  @l(#4.3.2)
   presents examples of nondeterministic programs, and @l(#4.3.3) gives the
   details of how to implement the @c(amb) evaluator by modifying the ordinary
   Scheme evaluator.

*** 4.3.1 <> Amb and Search

    To extend Scheme to support nondeterminism, we introduce a new special form
    called @c(amb).@n(247) The expression

    ..src > scheme
      (amb ⟨e₁⟩ ⟨e₂⟩ … ⟨eₙ⟩)
    < src..

    returns the value of one of the @m(n) expressions @m[⟨eᵢ⟩] @"(ambiguously.)
    For example, the expression

    ..src > scheme
      (list (amb 1 2 3) (amb 'a 'b))
    < src..

    can have six possible values:

    ..example >
      (1 a) (1 b) (2 a) (2 b) (3 a) (3 b)
    < example..

    @c(Amb) with a single choice produces an ordinary (single) value.

    @c(Amb) with no choices––the expression @c[(amb)]––is an expression with no
    acceptable values. Operationally, we can think of @c[(amb)] as an expression
    that when evaluated causes the computation to @"(fail): The computation aborts
    and no value is produced. Using this idea, we can express the requirement that
    a particular predicate expression @c(p) must be true as follows:

    ..src > scheme
      (define (require p)
        (if (not p) (amb)))
    < src..

    With @c(amb) and @c(require), we can implement the @c(an-element-of) procedure
    used above:

    ..src > scheme
      (define (an-element-of items)
        (require (not (null? items)))
        (amb (car items)
             (an-element-of (cdr items))))
    < src..

    @c(An-element-of) fails if the list is empty. Otherwise it ambiguously returns
    either the first element of the list or an element chosen from the rest of the
    list.

    We can also express infinite ranges of choices. The following procedure
    potentially returns any integer greater than or equal to some given @m(n):

    ..src > scheme
      (define (an-integer-starting-from n)
        (amb n (an-integer-starting-from (+ n 1))))
    < src..

    This is like the stream procedure @c(integers-starting-from) described in
    @l(#3.5.2), but with an important difference: The stream procedure returns an
    object that represents the sequence of all integers beginning with @m(n),
    whereas the @c(amb) procedure returns a single integer.@n(248)

    Abstractly, we can imagine that evaluating an @c(amb) expression causes time
    to split into branches, where the computation continues on each branch with
    one of the possible values of the expression. We say that @c(amb) represents a
    @e(nondeterministic choice point). If we had a machine with a sufficient
    number of processors that could be dynamically allocated, we could implement
    the search in a straightforward way. Execution would proceed as in a
    sequential machine, until an @c(amb) expression is encountered. At this point,
    more processors would be allocated and initialized to continue all of the
    parallel executions implied by the choice. Each processor would proceed
    sequentially as if it were the only choice, until it either terminates by
    encountering a failure, or it further subdivides, or it finishes.@n(249)

    On the other hand, if we have a machine that can execute only one process (or
    a few concurrent processes), we must consider the alternatives
    sequentially. One could imagine modifying an evaluator to pick at random a
    branch to follow whenever it encounters a choice point. Random choice,
    however, can easily lead to failing values. We might try running the evaluator
    over and over, making random choices and hoping to find a non-failing value,
    but it is better to @e(systematically search) all possible execution
    paths. The @c(amb) evaluator that we will develop and work with in this
    section implements a systematic search as follows: When the evaluator
    encounters an application of @c(amb), it initially selects the first
    alternative. This selection may itself lead to a further choice. The evaluator
    will always initially choose the first alternative at each choice point. If a
    choice results in a failure, then the evaluator automagically@n(250)
    @e(backtracks) to the most recent choice point and tries the next
    alternative. If it runs out of alternatives at any choice point, the evaluator
    will back up to the previous choice point and resume from there. This process
    leads to a search strategy known as @e(depth-first search) or @e(chronological
    backtracking).@n(251)

**** Driver loop

     The driver loop for the @c(amb) evaluator has some unusual properties. It
     reads an expression and prints the value of the first non-failing execution,
     as in the @c(prime-sum-pair) example shown above. If we want to see the value
     of the next successful execution, we can ask the interpreter to backtrack and
     attempt to generate a second non-failing execution. This is signaled by typing
     the symbol @c(try-again). If any expression except @c(try-again) is given, the
     interpreter will start a new problem, discarding the unexplored alternatives
     in the previous problem. Here is a sample interaction:

     ..srci > scheme
       ;;; Amb-Eval input:
       > (prime-sum-pair '(1 3 5 8) '(20 35 110))
       ;;; Starting a new problem
       ;;; Amb-Eval value:
       (3 20)

       ;;; Amb-Eval input:
       > try-again

       ;;; Amb-Eval value:
       (3 110)

       ;;; Amb-Eval input:
       > try-again

       ;;; Amb-Eval value:
       (8 35)

       ;;; Amb-Eval input:
       > try-again

       ;;; There are no more values of
       (prime-sum-pair
         (quote (1 3 5 8))
         (quote (20 35 110)))

       ;;; Amb-Eval input:
       > (prime-sum-pair '(19 27 30) '(11 36 58))

       ;;; Starting a new problem
       ;;; Amb-Eval value:
       (30 11)
     < srci..

     :: @t(Exercise 4.35) :: Write a procedure @c(an-integer-between) that returns
        an integer between two given bounds.  This can be used to implement a
        procedure that finds Pythagorean triples, i.e., triples of integers @m[(i,
        j, k)] between the given bounds such that @m(i ≤ j) and @m(i² + j² = k²),
        as follows:

        ..src > scheme
          (define (a-pythagorean-triple-between low high)
            (let ((i (an-integer-between low high)))
              (let ((j (an-integer-between i high)))
                (let ((k (an-integer-between j high)))
                  (require (= (+ (* i i) (* j j))
                              (* k k)))
                  (list i j k)))))
        < src..

     :: @t(Exercise 4.36) :: @l(#Exercise 3.69) discussed how to generate the
        stream of @e(all) Pythagorean triples, with no upper bound on the size of
        the integers to be searched. Explain why simply replacing
        @c(an-integer-between) by @c(an-integer-starting-from) in the procedure in
        @l(#Exercise 4.35) is not an adequate way to generate arbitrary Pythagorean
        triples. Write a procedure that actually will accomplish this. (That is,
        write a procedure for which repeatedly typing @c(try-again) would in
        principle eventually generate all Pythagorean triples.)

     :: @t(Exercise 4.37) :: Ben Bitdiddle claims that the following method for
        generating Pythagorean triples is more efficient than the one in
        @l(#Exercise 4.35). Is he correct?  (Hint: Consider the number of
        possibilities that must be explored.)

        ..src > scheme
          (define (a-pythagorean-triple-between low high)
            (let ((i (an-integer-between low high))
                  (hsq (* high high)))
              (let ((j (an-integer-between i high)))
                (let ((ksq (+ (* i i) (* j j))))
                  (require (>= hsq ksq))
                  (let ((k (sqrt ksq)))
                    (require (integer? k))
                    (list i j k))))))
        < src..

*** 4.3.2 <> Examples of Nondeterministic Programs

    Section @l(#4.3.3) describes the implementation of the @c(amb) evaluator.
    First, however, we give some examples of how it can be used. The advantage of
    nondeterministic programming is that we can suppress the details of how search
    is carried out, thereby expressing our programs at a higher level of
    abstraction.

**** Logic Puzzles

     The following puzzle (taken from @l(#Dinesman 1968)) is typical of a large
     class of simple logic puzzles:

     ..tab >
       Baker, Cooper, Fletcher, Miller, and Smith live on different floors of an
       apartment house that contains only five floors. Baker does not live on the
       top floor. Cooper does not live on the bottom floor. Fletcher does not live
       on either the top or the bottom floor. Miller lives on a higher floor than
       does Cooper. Smith does not live on a floor adjacent to Fletcher's. Fletcher
       does not live on a floor adjacent to Cooper's. Where does everyone live?


     We can determine who lives on each floor in a straightforward way by
     enumerating all the possibilities and imposing the given restrictions:@n(252)

     ..src > scheme
       (define (multiple-dwelling)
         (let ((baker (amb 1 2 3 4 5))
               (cooper (amb 1 2 3 4 5))
               (fletcher (amb 1 2 3 4 5))
               (miller (amb 1 2 3 4 5))
               (smith (amb 1 2 3 4 5)))
           (require
            (distinct? (list baker cooper fletcher
                             miller smith)))
           (require (not (= baker 5)))
           (require (not (= cooper 1)))
           (require (not (= fletcher 5)))
           (require (not (= fletcher 1)))
           (require (> miller cooper))
           (require
            (not (= (abs (- smith fletcher)) 1)))
           (require
            (not (= (abs (- fletcher cooper)) 1)))
           (list (list 'baker baker)
                 (list 'cooper cooper)
                 (list 'fletcher fletcher)
                 (list 'miller miller)
                 (list 'smith smith))))
     < src..

     Evaluating the expression @c[(multiple-dwelling)] produces the result

     ..src > scheme
       ((baker 3) (cooper 2) (fletcher 4)
        (miller 5) (smith 1))
     < src..

     Although this simple procedure works, it is very slow. @l(#Exercise 4.39) and
     @l(#Exercise 4.40) discuss some possible improvements.

     :: @t(Exercise 4.38) :: Modify the multiple-dwelling procedure to omit the
        requirement that Smith and Fletcher do not live on adjacent floors. How
        many solutions are there to this modified puzzle?

     :: @t(Exercise 4.39) :: Does the order of the restrictions in the
        multiple-dwelling procedure affect the answer? Does it affect the time to
        find an answer?  If you think it matters, demonstrate a faster program
        obtained from the given one by reordering the restrictions. If you think it
        does not matter, argue your case.

     :: @t(Exercise 4.40) :: In the multiple dwelling problem, how many sets of
        assignments are there of people to floors, both before and after the
        requirement that floor assignments be distinct?  It is very inefficient to
        generate all possible assignments of people to floors and then leave it to
        backtracking to eliminate them. For example, most of the restrictions
        depend on only one or two of the person-floor variables, and can thus be
        imposed before floors have been selected for all the people. Write and
        demonstrate a much more efficient nondeterministic procedure that solves
        this problem based upon generating only those possibilities that are not
        already ruled out by previous restrictions. (Hint: This will require a nest
        of @c(let) expressions.)

     :: @t(Exercise 4.41) :: Write an ordinary Scheme program to solve the multiple
        dwelling puzzle.

     :: @t(Exercise 4.42) :: Solve the following @"(Liars) puzzle (from
        @l(#Phillips 1934)):

        Five schoolgirls sat for an examination. Their parents––so they
        thought––showed an undue degree of interest in the result. They therefore
        agreed that, in writing home about the examination, each girl should make
        one true statement and one untrue one. The following are the relevant
        passages from their letters:

        - Betty: @"(Kitty was second in the examination. I was only third.)

        - Ethel: @"(You'll be glad to hear that I was on top. Joan was second.)

        - Joan: @"(I was third, and poor old Ethel was bottom.)

        - Kitty: @"(I came out second. Mary was only fourth.)

        - Mary: @"(I was fourth. Top place was taken by Betty.)


        What in fact was the order in which the five girls were placed?

     :: @t(Exercise 4.43) :: Use the @c(amb) evaluator to solve the following
        puzzle:@n(253)

        ..tab >
          Mary Ann Moore's father has a yacht and so has each of his four friends:
          Colonel Downing, Mr. Hall, Sir Barnacle Hood, and Dr. Parker. Each of the
          five also has one daughter and each has named his yacht after a daughter
          of one of the others. Sir Barnacle's yacht is the Gabrielle, Mr. Moore
          owns the Lorna; Mr. Hall the Rosalind. The Melissa, owned by Colonel
          Downing, is named after Sir Barnacle's daughter. Gabrielle's father owns
          the yacht that is named after Dr. Parker's daughter. Who is Lorna's
          father?

        Try to write the program so that it runs efficiently (see @l(#Exercise
        4.40)). Also determine how many solutions there are if we are not told that
        Mary Ann's last name is Moore.

     :: @t(Exercise 4.44) :: @l(#Exercise 2.42) described the @"(eight-queens
        puzzle) of placing queens on a chessboard so that no two attack each
        other. Write a nondeterministic program to solve this puzzle.

**** Parsing natural language

     Programs designed to accept natural language as input usually start by
     attempting to @e(parse) the input, that is, to match the input against some
     grammatical structure. For example, we might try to recognize simple sentences
     consisting of an article followed by a noun followed by a verb, such as @"(The
     cat eats.)  To accomplish such an analysis, we must be able to identify the
     parts of speech of individual words. We could start with some lists that
     classify various words:@n(254)

     ..src > scheme
       (define nouns
         '(noun student professor cat class))

       (define verbs
         '(verb studies lectures eats sleeps))

       (define articles '(article the a))
     < src..

     We also need a @e(grammar), that is, a set of rules describing how grammatical
     elements are composed from simpler elements. A very simple grammar might
     stipulate that a sentence always consists of two pieces––a noun phrase
     followed by a verb––and that a noun phrase consists of an article followed by
     a noun. With this grammar, the sentence @"(The cat eats) is parsed as follows:

     ..src > scheme
       (sentence
        (noun-phrase (article the) (noun cat))
        (verb eats))
     < src..

     We can generate such a parse with a simple program that has separate
     procedures for each of the grammatical rules. To parse a sentence, we identify
     its two constituent pieces and return a list of these two elements, tagged
     with the symbol @c(sentence):

     ..src > scheme
       (define (parse-sentence)
         (list 'sentence
                (parse-noun-phrase)
                (parse-word verbs)))
     < src..

     A noun phrase, similarly, is parsed by finding an article followed by a noun:

     ..src > scheme
       (define (parse-noun-phrase)
         (list 'noun-phrase
               (parse-word articles)
               (parse-word nouns)))
     < src..

     At the lowest level, parsing boils down to repeatedly checking that the next
     unparsed word is a member of the list of words for the required part of
     speech.  To implement this, we maintain a global variable @c(*unparsed*),
     which is the input that has not yet been parsed. Each time we check a word, we
     require that @c(*unparsed*) must be non-empty and that it should begin with a
     word from the designated list. If so, we remove that word from @c(*unparsed*)
     and return the word together with its part of speech (which is found at the
     head of the list):@n(255)

     ..src > scheme
       (define (parse-word word-list)
         (require (not (null? *unparsed*)))
         (require (memq (car *unparsed*)
                        (cdr word-list)))
         (let ((found-word (car *unparsed*)))
           (set! *unparsed* (cdr *unparsed*))
           (list (car word-list) found-word)))
     < src..

     To start the parsing, all we need to do is set @c(*unparsed*) to be the entire
     input, try to parse a sentence, and check that nothing is left over:

     ..src > scheme
       (define *unparsed* '())
       (define (parse input)
         (set! *unparsed* input)
         (let ((sent (parse-sentence)))
           (require (null? *unparsed*))
           sent))
     < src..

     We can now try the parser and verify that it works for our simple test
     sentence:

     ..src > scheme
       ;;; Amb-Eval input:
       (parse '(the cat eats))

       ;;; Starting a new problem
       ;;; Amb-Eval value:
       (sentence
        (noun-phrase (article the) (noun cat))
        (verb eats))
     < src..

     The @c(amb) evaluator is useful here because it is convenient to express the
     parsing constraints with the aid of @c(require). Automatic search and
     backtracking really pay off, however, when we consider more complex grammars
     where there are choices for how the units can be decomposed.

     Let's add to our grammar a list of prepositions:

     ..src > scheme
       (define prepositions
         '(prep for to in by with))
     < src..

     and define a prepositional phrase (e.g., @"(for the cat)) to be a preposition
     followed by a noun phrase:

     ..src > scheme
       (define (parse-prepositional-phrase)
         (list 'prep-phrase
               (parse-word prepositions)
               (parse-noun-phrase)))
     < src..

     Now we can define a sentence to be a noun phrase followed by a verb phrase,
     where a verb phrase can be either a verb or a verb phrase extended by a
     prepositional phrase:@n(256)

     ..src > scheme
       (define (parse-sentence)
         (list 'sentence
                (parse-noun-phrase)
                (parse-verb-phrase)))

       (define (parse-verb-phrase)
         (define (maybe-extend verb-phrase)
           (amb
            verb-phrase
            (maybe-extend
             (list 'verb-phrase
                   verb-phrase
                   (parse-prepositional-phrase)))))
         (maybe-extend (parse-word verbs)))
     < src..

     While we're at it, we can also elaborate the definition of noun phrases to
     permit such things as @"(a cat in the class.)  What we used to call a noun
     phrase, we'll now call a simple noun phrase, and a noun phrase will now be
     either a simple noun phrase or a noun phrase extended by a prepositional
     phrase:

     ..src > scheme
       (define (parse-simple-noun-phrase)
         (list 'simple-noun-phrase
               (parse-word articles)
               (parse-word nouns)))

       (define (parse-noun-phrase)
         (define (maybe-extend noun-phrase)
           (amb
            noun-phrase
            (maybe-extend
             (list 'noun-phrase
                   noun-phrase
                   (parse-prepositional-phrase)))))
         (maybe-extend (parse-simple-noun-phrase)))
     < src..

     Our new grammar lets us parse more complex sentences. For example

     ..src > scheme
       (parse '(the student with the cat
                sleeps in the class))
     < src..

     produces

     ..src > scheme
       (sentence
        (noun-phrase
         (simple-noun-phrase (article the)
                             (noun student))
         (prep-phrase (prep with)
                      (simple-noun-phrase
                       (article the)
                       (noun cat))))
        (verb-phrase
         (verb sleeps)
         (prep-phrase (prep in)
                      (simple-noun-phrase
                       (article the)
                       (noun class)))))
     < src..

     Observe that a given input may have more than one legal parse. In the sentence
     @"(The professor lectures to the student with the cat,) it may be that the
     professor is lecturing with the cat, or that the student has the cat. Our
     nondeterministic program finds both possibilities:

     ..src > scheme
       (parse '(the professor lectures to
                the student with the cat))
     < src..

     produces

     ..src > scheme
       (sentence
        (simple-noun-phrase (article the)
                            (noun professor))
        (verb-phrase
         (verb-phrase
          (verb lectures)
          (prep-phrase (prep to)
                       (simple-noun-phrase
                        (article the)
                        (noun student))))
         (prep-phrase (prep with)
                      (simple-noun-phrase
                       (article the)
                       (noun cat)))))
     < src..

     Asking the evaluator to try again yields

     ..src > scheme
       (sentence
        (simple-noun-phrase (article the)
                            (noun professor))
        (verb-phrase (verb lectures)
                     (prep-phrase
                      (prep to)
                      (noun-phrase
                       (simple-noun-phrase
                        (article the)
                        (noun student))
                       (prep-phrase
                        (prep with)
                        (simple-noun-phrase
                         (article the)
                         (noun cat)))))))
     < src..

     :: @t(Exercise 4.45) :: With the grammar given above, the following sentence
        can be parsed in five different ways: @"(The professor lectures to the
        student in the class with the cat.)  Give the five parses and explain the
        differences in shades of meaning among them.

     :: @t(Exercise 4.46) :: The evaluators in @l(#4.1) and @l(#4.2) do not
        determine what order operands are evaluated in.  We will see that the
        @c(amb) evaluator evaluates them from left to right.  Explain why our
        parsing program wouldn't work if the operands were evaluated in some other
        order.

     :: @t(Exercise 4.47) :: Louis Reasoner suggests that, since a verb phrase is
        either a verb or a verb phrase followed by a prepositional phrase, it would
        be much more straightforward to define the procedure @c(parse-verb-phrase)
        as follows (and similarly for noun phrases):

        ..src > scheme
          (define (parse-verb-phrase)
            (amb (parse-word verbs)
                 (list
                  'verb-phrase
                  (parse-verb-phrase)
                  (parse-prepositional-phrase))))
        < src..

        Does this work?  Does the program's behavior change if we interchange the
        order of expressions in the @c(amb)?

     :: @t(Exercise 4.48) :: Extend the grammar given above to handle more complex
        sentences. For example, you could extend noun phrases and verb phrases to
        include adjectives and adverbs, or you could handle compound
        sentences.@n(257)

     :: @t(Exercise 4.49) :: Alyssa P. Hacker is more interested in generating
        interesting sentences than in parsing them. She reasons that by simply
        changing the procedure @c(parse-word) so that it ignores the @"(input
        sentence) and instead always succeeds and generates an appropriate word, we
        can use the programs we had built for parsing to do generation
        instead. Implement Alyssa's idea, and show the first half-dozen or so
        sentences generated.@n(258)

*** 4.3.3 <> Implementing the @c(Amb) Evaluator

    The evaluation of an ordinary Scheme expression may return a value, may never
    terminate, or may signal an error. In nondeterministic Scheme the evaluation
    of an expression may in addition result in the discovery of a dead end, in
    which case evaluation must backtrack to a previous choice point. The
    interpretation of nondeterministic Scheme is complicated by this extra case.

    We will construct the @c(amb) evaluator for nondeterministic Scheme by
    modifying the analyzing evaluator of @l(#4.1.7).@n(259) As in the analyzing
    evaluator, evaluation of an expression is accomplished by calling an execution
    procedure produced by analysis of that expression. The difference between the
    interpretation of ordinary Scheme and the interpretation of nondeterministic
    Scheme will be entirely in the execution procedures.

**** Execution procedures and continuations

     Recall that the execution procedures for the ordinary evaluator take one
     argument: the environment of execution. In contrast, the execution procedures
     in the @c(amb) evaluator take three arguments: the environment, and two
     procedures called @e(continuation procedures). The evaluation of an expression
     will finish by calling one of these two continuations: If the evaluation
     results in a value, the @e(success continuation) is called with that value; if
     the evaluation results in the discovery of a dead end, the @e(failure
     continuation) is called. Constructing and calling appropriate continuations is
     the mechanism by which the nondeterministic evaluator implements backtracking.

     It is the job of the success continuation to receive a value and proceed with
     the computation. Along with that value, the success continuation is passed
     another failure continuation, which is to be called subsequently if the use of
     that value leads to a dead end.

     It is the job of the failure continuation to try another branch of the
     nondeterministic process. The essence of the nondeterministic language is in
     the fact that expressions may represent choices among alternatives. The
     evaluation of such an expression must proceed with one of the indicated
     alternative choices, even though it is not known in advance which choices will
     lead to acceptable results. To deal with this, the evaluator picks one of the
     alternatives and passes this value to the success continuation. Together with
     this value, the evaluator constructs and passes along a failure continuation
     that can be called later to choose a different alternative.

     A failure is triggered during evaluation (that is, a failure continuation is
     called) when a user program explicitly rejects the current line of attack (for
     example, a call to @c(require) may result in execution of @c[(amb)], an
     expression that always fails––see @l(#4.3.1)). The failure continuation in
     hand at that point will cause the most recent choice point to choose another
     alternative. If there are no more alternatives to be considered at that choice
     point, a failure at an earlier choice point is triggered, and so on. Failure
     continuations are also invoked by the driver loop in response to a
     @c(try-again) request, to find another value of the expression.

     In addition, if a side-effect operation (such as assignment to a variable)
     occurs on a branch of the process resulting from a choice, it may be
     necessary, when the process finds a dead end, to undo the side effect before
     making a new choice. This is accomplished by having the side-effect operation
     produce a failure continuation that undoes the side effect and propagates the
     failure.

     In summary, failure continuations are constructed by

     - @c(amb) expressions––to provide a mechanism to make alternative choices if
       the current choice made by the @c(amb) expression leads to a dead end;

     - the top-level driver––to provide a mechanism to report failure when the
       choices are exhausted;

     - assignments––to intercept failures and undo assignments during backtracking.

     Failures are initiated only when a dead end is encountered. This occurs

     - if the user program executes @c[(amb)];

     - if the user types @c(try-again) at the top-level driver.

     Failure continuations are also called during processing of a failure:

     - When the failure continuation created by an assignment finishes undoing a
       side effect, it calls the failure continuation it intercepted, in order to
       propagate the failure back to the choice point that led to this assignment
       or to the top level.

     - When the failure continuation for an @c(amb) runs out of choices, it calls
       the failure continuation that was originally given to the @c(amb), in order
       to propagate the failure back to the previous choice point or to the top
       level.

**** Structure of the evaluator

     The syntax- and data-representation procedures for the @c(amb) evaluator, and
     also the basic @c(analyze) procedure, are identical to those in the evaluator
     of @l(#4.1.7), except for the fact that we need additional syntax procedures
     to recognize the @c(amb) special form:@n(260)

     ..src > scheme
       (define (amb? exp) (tagged-list? exp 'amb))
       (define (amb-choices exp) (cdr exp))
     < src..

     We must also add to the dispatch in @c(analyze) a clause that will recognize
     this special form and generate an appropriate execution procedure:

     ..src > scheme
       ((amb? exp) (analyze-amb exp))
     < src..

     The top-level procedure @c(ambeval) (similar to the version of @c(eval) given
     in @l(#4.1.7)) analyzes the given expression and applies the resulting
     execution procedure to the given environment, together with two given
     continuations:

     ..src > scheme
       (define (ambeval exp env succeed fail)
         ((analyze exp) env succeed fail))
     < src..

     A success continuation is a procedure of two arguments: the value just
     obtained and another failure continuation to be used if that value leads to a
     subsequent failure. A failure continuation is a procedure of no arguments. So
     the general form of an execution procedure is

     ..src > scheme
       (lambda (env succeed fail)
         ;; succeed is (lambda (value fail) …)
         ;; fail is (lambda () …)
         …)
     < src..

     For example, executing

     ..src > scheme
       (ambeval ⟨exp⟩
                the-global-environment
                (lambda (value fail) value)
                (lambda () 'failed))
     < src..

     will attempt to evaluate the given expression and will return either the
     expression's value (if the evaluation succeeds) or the symbol @c(failed) (if
     the evaluation fails). The call to @c(ambeval) in the driver loop shown below
     uses much more complicated continuation procedures, which continue the loop
     and support the @c(try-again) request.

     Most of the complexity of the @c(amb) evaluator results from the mechanics of
     passing the continuations around as the execution procedures call each
     other. In going through the following code, you should compare each of the
     execution procedures with the corresponding procedure for the ordinary
     evaluator given in @l(#4.1.7).

**** Simple expressions

     The execution procedures for the simplest kinds of expressions are essentially
     the same as those for the ordinary evaluator, except for the need to manage
     the continuations. The execution procedures simply succeed with the value of
     the expression, passing along the failure continuation that was passed to
     them.

     ..src > scheme
       (define (analyze-self-evaluating exp)
         (lambda (env succeed fail)
           (succeed exp fail)))

       (define (analyze-quoted exp)
         (let ((qval (text-of-quotation exp)))
           (lambda (env succeed fail)
             (succeed qval fail))))

       (define (analyze-variable exp)
         (lambda (env succeed fail)
           (succeed (lookup-variable-value exp env)
                    fail)))

       (define (analyze-lambda exp)
         (let ((vars (lambda-parameters exp))
               (bproc (analyze-sequence
                       (lambda-body exp))))
           (lambda (env succeed fail)
             (succeed (make-procedure vars bproc env)
                      fail))))
     < src..

     Notice that looking up a variable always @'(succeeds).  If
     @c(lookup-variable-value) fails to find the variable, it signals an error, as
     usual. Such a @"(failure) indicates a program bug––a reference to an unbound
     variable; it is not an indication that we should try another nondeterministic
     choice instead of the one that is currently being tried.

**** Conditionals and sequences

     Conditionals are also handled in a similar way as in the ordinary evaluator.
     The execution procedure generated by @c(analyze-if) invokes the predicate
     execution procedure @c(pproc) with a success continuation that checks whether
     the predicate value is true and goes on to execute either the consequent or
     the alternative. If the execution of @c(pproc) fails, the original failure
     continuation for the @c(if) expression is called.

     ..src > scheme
       (define (analyze-if exp)
         (let ((pproc (analyze (if-predicate exp)))
               (cproc (analyze (if-consequent exp)))
               (aproc (analyze (if-alternative exp))))
           (lambda (env succeed fail)
             (pproc env
                    ;; success continuation for evaluating
                    ;; the predicate to obtain pred-value
                    (lambda (pred-value fail2)
                      (if (true? pred-value)
                          (cproc env succeed fail2)
                          (aproc env succeed fail2)))
                    ;; failure continuation for
                    ;; evaluating the predicate
                    fail))))
     < src..

     Sequences are also handled in the same way as in the previous evaluator,
     except for the machinations in the subprocedure @c(sequentially) that are
     required for passing the continuations. Namely, to sequentially execute @c(a)
     and then @c(b), we call @c(a) with a success continuation that calls @c(b).

     ..src > scheme
       (define (analyze-sequence exps)
         (define (sequentially a b)
           (lambda (env succeed fail)
             (a env
                ;; success continuation for calling a
                (lambda (a-value fail2)
                  (b env succeed fail2))
                ;; failure continuation for calling a
                fail)))
         (define (loop first-proc rest-procs)
           (if (null? rest-procs)
               first-proc
               (loop (sequentially first-proc
                                   (car rest-procs))
                     (cdr rest-procs))))
         (let ((procs (map analyze exps)))
           (if (null? procs)
               (error "Empty sequence: ANALYZE"))
           (loop (car procs) (cdr procs))))
     < src..

**** Definitions and assignments

     Definitions are another case where we must go to some trouble to manage the
     continuations, because it is necessary to evaluate the definition-value
     expression before actually defining the new variable. To accomplish this, the
     definition-value execution procedure @c(vproc) is called with the environment,
     a success continuation, and the failure continuation. If the execution of
     @c(vproc) succeeds, obtaining a value @c(val) for the defined variable, the
     variable is defined and the success is propagated:

     ..src > scheme
       (define (analyze-definition exp)
         (let ((var (definition-variable exp))
               (vproc (analyze
                       (definition-value exp))))
           (lambda (env succeed fail)
             (vproc env
                    (lambda (val fail2)
                      (define-variable! var val env)
                      (succeed 'ok fail2))
                    fail))))
     < src..

     Assignments are more interesting. This is the first place where we really use
     the continuations, rather than just passing them around. The execution
     procedure for assignments starts out like the one for definitions. It first
     attempts to obtain the new value to be assigned to the variable. If this
     evaluation of @c(vproc) fails, the assignment fails.

     If @c(vproc) succeeds, however, and we go on to make the assignment, we must
     consider the possibility that this branch of the computation might later fail,
     which will require us to backtrack out of the assignment. Thus, we must
     arrange to undo the assignment as part of the backtracking process.@n(261)

     This is accomplished by giving @c(vproc) a success continuation (marked with
     the comment @"(*1*) below) that saves the old value of the variable before
     assigning the new value to the variable and proceeding from the assignment.
     The failure continuation that is passed along with the value of the assignment
     (marked with the comment @"(*2*) below) restores the old value of the variable
     before continuing the failure. That is, a successful assignment provides a
     failure continuation that will intercept a subsequent failure; whatever
     failure would otherwise have called @c(fail2) calls this procedure instead, to
     undo the assignment before actually calling @c(fail2).

     ..src > scheme
       (define (analyze-assignment exp)
         (let ((var (assignment-variable exp))
               (vproc (analyze
                       (assignment-value exp))))
           (lambda (env succeed fail)
             (vproc env
                    (lambda (val fail2)    ; *1*
                      (let ((old-value
                             (lookup-variable-value
                              var
                              env)))
                        (set-variable-value!
                         var
                         val
                         env)
                        (succeed
                         'ok
                         (lambda ()    ; *2*
                           (set-variable-value!
                            var
                            old-value
                            env)
                           (fail2)))))
                      fail))))
     < src..

**** Procedure applications

     The execution procedure for applications contains no new ideas except for the
     technical complexity of managing the continuations. This complexity arises in
     @c(analyze-application), due to the need to keep track of the success and
     failure continuations as we evaluate the operands. We use a procedure
     @c(get-args) to evaluate the list of operands, rather than a simple @c(map) as
     in the ordinary evaluator.

     ..src > scheme
       (define (analyze-application exp)
         (let ((fproc (analyze (operator exp)))
               (aprocs (map analyze (operands exp))))
           (lambda (env succeed fail)
             (fproc env
                    (lambda (proc fail2)
                      (get-args
                       aprocs
                       env
                       (lambda (args fail3)
                         (execute-application
                          proc args succeed fail3))
                       fail2))
                    fail))))
     < src..

     In @c(get-args), notice how @c(cdr)-ing down the list of @c(aproc) execution
     procedures and @c(cons)ing up the resulting list of @c(args) is accomplished
     by calling each @c(aproc) in the list with a success continuation that
     recursively calls @c(get-args). Each of these recursive calls to @c(get-args)
     has a success continuation whose value is the @c(cons) of the newly obtained
     argument onto the list of accumulated arguments:

     ..src > scheme
       (define (get-args aprocs env succeed fail)
         (if (null? aprocs)
             (succeed '() fail)
             ((car aprocs)
              env
              ;; success continuation for this @c(aproc)
              (lambda (arg fail2)
                (get-args
                 (cdr aprocs)
                 env
                 ;; success continuation for
                 ;; recursive call to @c(get-args)
                 (lambda (args fail3)
                   (succeed (cons arg args)
                            fail3))
                 fail2))
              fail)))
     < src..

     The actual procedure application, which is performed by
     @c(execute-application), is accomplished in the same way as for the ordinary
     evaluator, except for the need to manage the continuations.

     ..src > scheme
       (define (execute-application
                proc args succeed fail)
         (cond ((primitive-procedure? proc)
                (succeed
                 (apply-primitive-procedure
                  proc args)
                 fail))
               ((compound-procedure? proc)
                ((procedure-body proc)
                 (extend-environment
                  (procedure-parameters proc)
                  args
                  (procedure-environment proc))
                 succeed
                 fail))
               (else (error "Unknown procedure type:
                             EXECUTE-APPLICATION"
                            proc))))
     < src..

**** Evaluating @c(amb) expressions

     The @c(amb) special form is the key element in the nondeterministic
     language. Here we see the essence of the interpretation process and the reason
     for keeping track of the continuations. The execution procedure for @c(amb)
     defines a loop @c(try-next) that cycles through the execution procedures for
     all the possible values of the @c(amb) expression. Each execution procedure is
     called with a failure continuation that will try the next one. When there are
     no more alternatives to try, the entire @c(amb) expression fails.

     ..src > scheme
       (define (analyze-amb exp)
         (let ((cprocs
                (map analyze (amb-choices exp))))
           (lambda (env succeed fail)
             (define (try-next choices)
               (if (null? choices)
                   (fail)
                   ((car choices)
                    env
                    succeed
                    (lambda ()
                      (try-next (cdr choices))))))
             (try-next cprocs))))
     < src..

**** Driver loop

     The driver loop for the @c(amb) evaluator is complex, due to the mechanism
     that permits the user to try again in evaluating an expression. The driver
     uses a procedure called @c(internal-loop), which takes as argument a procedure
     @c(try-again). The intent is that calling @c(try-again) should go on to the
     next untried alternative in the nondeterministic evaluation.
     @c(Internal-loop) either calls @c(try-again) in response to the user typing
     @c(try-again) at the driver loop, or else starts a new evaluation by calling
     @c(ambeval).

     The failure continuation for this call to @c(ambeval) informs the user that
     there are no more values and re-invokes the driver loop.

     The success continuation for the call to @c(ambeval) is more subtle. We print
     the obtained value and then invoke the internal loop again with a
     @c(try-again) procedure that will be able to try the next alternative. This
     @c(next-alternative) procedure is the second argument that was passed to the
     success continuation. Ordinarily, we think of this second argument as a
     failure continuation to be used if the current evaluation branch later fails.
     In this case, however, we have completed a successful evaluation, so we can
     invoke the @"(failure) alternative branch in order to search for additional
     successful evaluations.

     ..src > scheme
       (define input-prompt  ";;; Amb-Eval input:")
       (define output-prompt ";;; Amb-Eval value:")

       (define (driver-loop)
         (define (internal-loop try-again)
           (prompt-for-input input-prompt)
           (let ((input (read)))
             (if (eq? input 'try-again)
                 (try-again)
                 (begin
                   (newline)
                   (display
                    ";;; Starting a new problem ")
                   (ambeval
                    input
                    the-global-environment
                    ;; @c(ambeval) success
                    (lambda (val next-alternative)
                      (announce-output
                       output-prompt)
                      (user-print val)
                      (internal-loop
                       next-alternative))
                    ;; @c(ambeval) failure
                    (lambda ()
                      (announce-output
                       ";;; There are no
                        more values of")
                      (user-print input)
                      (driver-loop)))))))
         (internal-loop
          (lambda ()
            (newline)
            (display
             ";;; There is no current problem")
            (driver-loop))))
     < src..

     The initial call to @c(internal-loop) uses a @c(try-again) procedure that
     complains that there is no current problem and restarts the driver loop. This
     is the behavior that will happen if the user types @c(try-again) when there is
     no evaluation in progress.

     :: @t(Exercise 4.50) :: Implement a new special form @c(ramb) that is like
        @c(amb) except that it searches alternatives in a random order, rather than
        from left to right. Show how this can help with Alyssa's problem in
        @l(#Exercise 4.49).

     :: @t(Exercise 4.51) :: Implement a new kind of assignment called
        @c(permanent-set!) that is not undone upon failure. For example, we can
        choose two distinct elements from a list and count the number of trials
        required to make a successful choice as follows:

        ..srci > scheme
          > (define count 0)
          > (let ((x (an-element-of '(a b c)))
          ^       (y (an-element-of '(a b c))))
          ^   (permanent-set! count (+ count 1))
          ^   (require (not (eq? x y)))
          ^   (list x y count))

          ;;; Starting a new problem
          ;;; Amb-Eval value:
          (a b 2)

          ;;; Amb-Eval input:
          > try-again

          ;;; Amb-Eval value:
          (a c 3)
        < srci..

        What values would have been displayed if we had used @c(set!) here rather
        than @c(permanent-set!)?

     :: @t(Exercise 4.52) :: Implement a new construct called @c(if-fail) that
        permits the user to catch the failure of an expression.  @c(If-fail) takes
        two expressions. It evaluates the first expression as usual and returns as
        usual if the evaluation succeeds. If the evaluation fails, however, the
        value of the second expression is returned, as in the following example:

        ..srci > scheme
          ;;; Amb-Eval input:
          > (if-fail
          ^  (let ((x (an-element-of '(1 3 5))))
          ^    (require (even? x))
          ^    x)
          ^  'all-odd)
          ;;; Starting a new problem
          ;;; Amb-Eval value:
          all-odd

          ;;; Amb-Eval input:
          > (if-fail
          ^  (let ((x (an-element-of '(1 3 5 8))))
          ^    (require (even? x))
          ^    x)
          ^  'all-odd)

          ;;; Starting a new problem
          ;;; Amb-Eval value:
          8
        < srci..

     :: @t(Exercise 4.53) :: With @c(permanent-set!) as described in @l(#Exercise
        4.51) and @c(if-fail) as in @l(#Exercise 4.52), what will be the result of
        evaluating

        ..src > scheme
          (let ((pairs '()))
            (if-fail
             (let ((p (prime-sum-pair
                       '(1 3 5 8)
                       '(20 35 110))))
               (permanent-set! pairs
                               (cons p pairs))
               (amb))
             pairs))
        < src..

     :: @t(Exercise 4.54) :: If we had not realized that @c(require) could be
        implemented as an ordinary procedure that uses @c(amb), to be defined by
        the user as part of a nondeterministic program, we would have had to
        implement it as a special form. This would require syntax procedures

        ..src > scheme
          (define (require? exp)
            (tagged-list? exp 'require))

          (define (require-predicate exp)
            (cadr exp))
        < src..

        and a new clause in the dispatch in @c(analyze)

        ..src > scheme
          ((require? exp) (analyze-require exp))
        < src..

        as well the procedure @c(analyze-require) that handles @c(require)
        expressions. Complete the following definition of @c(analyze-require).

        ..src > scheme
          (define (analyze-require exp)
            (let ((pproc (analyze
                          (require-predicate exp))))
              (lambda (env succeed fail)
                (pproc env
                       (lambda (pred-value fail2)
                         (if ⟨??⟩
                             ⟨??⟩
                             (succeed 'ok fail2)))
                       fail))))
        < src..

** 4.4 <> Logic Programming

   In @l(#Chapter 1) we stressed that computer science deals with imperative (how
   to) knowledge, whereas mathematics deals with declarative (what is) knowledge.
   Indeed, programming languages require that the programmer express knowledge in
   a form that indicates the step-by-step methods for solving particular
   problems.  On the other hand, high-level languages provide, as part of the
   language implementation, a substantial amount of methodological knowledge that
   frees the user from concern with numerous details of how a specified
   computation will progress.

   Most programming languages, including Lisp, are organized around computing the
   values of mathematical functions. Expression-oriented languages (such as Lisp,
   Fortran, and Algol) capitalize on the @"(pun) that an expression that
   describes the value of a function may also be interpreted as a means of
   computing that value. Because of this, most programming languages are strongly
   biased toward unidirectional computations (computations with well-defined
   inputs and outputs). There are, however, radically different programming
   languages that relax this bias. We saw one such example in @l(#3.3.5), where
   the objects of computation were arithmetic constraints. In a constraint system
   the direction and the order of computation are not so well specified; in
   carrying out a computation the system must therefore provide more detailed
   @"(how to) knowledge than would be the case with an ordinary arithmetic
   computation. This does not mean, however, that the user is released altogether
   from the responsibility of providing imperative knowledge. There are many
   constraint networks that implement the same set of constraints, and the user
   must choose from the set of mathematically equivalent networks a suitable
   network to specify a particular computation.

   The nondeterministic program evaluator of @l(#4.3) also moves away from the
   view that programming is about constructing algorithms for computing
   unidirectional functions. In a nondeterministic language, expressions can have
   more than one value, and, as a result, the computation is dealing with
   relations rather than with single-valued functions. Logic programming extends
   this idea by combining a relational vision of programming with a powerful kind
   of symbolic pattern matching called @e(unification).@n(262)

   This approach, when it works, can be a very powerful way to write programs.
   Part of the power comes from the fact that a single @"(what is) fact can be
   used to solve a number of different problems that would have different @"(how
   to) components. As an example, consider the @c(append) operation, which takes
   two lists as arguments and combines their elements to form a single list.  In
   a procedural language such as Lisp, we could define @c(append) in terms of the
   basic list constructor @c(cons), as we did in @l(#2.2.1):

   ..src > scheme
     (define (append x y)
       (if (null? x)
           y
           (cons (car x) (append (cdr x) y))))
   < src..

   This procedure can be regarded as a translation into Lisp of the following two
   rules, the first of which covers the case where the first list is empty and
   the second of which handles the case of a nonempty list, which is a @c(cons)
   of two parts:

   - For any list @c(y), the empty list and @c(y) @c(append) to form @c(y).

   - For any @c(u), @c(v), @c(y), and @c(z), @c[(cons u v)] and @c(y) @c(append)
     to form @c[(cons u z)] if @c(v) and @c(y) @c(append) to form @c(z).@n(263)


   Using the @c(append) procedure, we can answer questions such as

   ..tab >
     Find the @c(append) of @c[(a b)] and @c[(c d)].

   But the same two rules are also sufficient for answering the following sorts
   of questions, which the procedure can't answer:

   ..tab >
     Find a list @c(y) that @c(append)s with @c[(a b)] to produce @c[(a b c d)].

     Find all @c(x) and @c(y) that @c(append) to form @c[(a b c d)].
   < tab..

   In a logic programming language, the programmer writes an @c(append)
   @"(procedure) by stating the two rules about @c(append) given above. @"(How
   to) knowledge is provided automatically by the interpreter to allow this
   single pair of rules to be used to answer all three types of questions about
   @c(append).@n(264)

   Contemporary logic programming languages (including the one we implement here)
   have substantial deficiencies, in that their general @"(how to) methods can
   lead them into spurious infinite loops or other undesirable behavior. Logic
   programming is an active field of research in computer science.@n(265)

   Earlier in this chapter we explored the technology of implementing
   interpreters and described the elements that are essential to an interpreter
   for a Lisp-like language (indeed, to an interpreter for any conventional
   language). Now we will apply these ideas to discuss an interpreter for a logic
   programming language. We call this language the @e(query language), because it
   is very useful for retrieving information from data bases by formulating
   @e(queries), or questions, expressed in the language. Even though the query
   language is very different from Lisp, we will find it convenient to describe
   the language in terms of the same general framework we have been using all
   along: as a collection of primitive elements, together with means of
   combination that enable us to combine simple elements to create more complex
   elements and means of abstraction that enable us to regard complex elements as
   single conceptual units. An interpreter for a logic programming language is
   considerably more complex than an interpreter for a language like Lisp.
   Nevertheless, we will see that our query-language interpreter contains many of
   the same elements found in the interpreter of @l(#4.1). In particular, there
   will be an @"(eval) part that classifies expressions according to type and an
   @"(apply) part that implements the language's abstraction mechanism
   (procedures in the case of Lisp, and @e(rules) in the case of logic
   programming). Also, a central role is played in the implementation by a frame
   data structure, which determines the correspondence between symbols and their
   associated values. One additional interesting aspect of our query-language
   implementation is that we make substantial use of streams, which were
   introduced in @l(#Chapter 3).

*** 4.4.1 <> Deductive Information Retrieval

    Logic programming excels in providing interfaces to data bases for information
    retrieval. The query language we shall implement in this chapter is designed
    to be used in this way.

    In order to illustrate what the query system does, we will show how it can be
    used to manage the data base of personnel records for Microshaft, a thriving
    high-technology company in the Boston area. The language provides
    pattern-directed access to personnel information and can also take advantage
    of general rules in order to make logical deductions.

**** A sample data base

     The personnel data base for Microshaft contains @e(assertions) about company
     personnel. Here is the information about Ben Bitdiddle, the resident computer
     wizard:

     ..src > scheme
       (address (Bitdiddle Ben)
                (Slumerville (Ridge Road) 10))
       (job (Bitdiddle Ben) (computer wizard))
       (salary (Bitdiddle Ben) 60000)
     < src..

     Each assertion is a list (in this case a triple) whose elements can themselves
     be lists.

     As resident wizard, Ben is in charge of the company's computer division, and
     he supervises two programmers and one technician. Here is the information
     about them:

     ..src > scheme
       (address (Hacker Alyssa P)
                (Cambridge (Mass Ave) 78))
       (job (Hacker Alyssa P) (computer programmer))
       (salary (Hacker Alyssa P) 40000)
       (supervisor (Hacker Alyssa P) (Bitdiddle Ben))

       (address (Fect Cy D)
                (Cambridge (Ames Street) 3))
       (job (Fect Cy D) (computer programmer))
       (salary (Fect Cy D) 35000)
       (supervisor (Fect Cy D) (Bitdiddle Ben))

       (address (Tweakit Lem E)
                (Boston (Bay State Road) 22))
       (job (Tweakit Lem E) (computer technician))
       (salary (Tweakit Lem E) 25000)
       (supervisor (Tweakit Lem E) (Bitdiddle Ben))
     < src..

     There is also a programmer trainee, who is supervised by Alyssa:

     ..src > scheme
       (address (Reasoner Louis)
                (Slumerville (Pine Tree Road) 80))
       (job (Reasoner Louis)
            (computer programmer trainee))
       (salary (Reasoner Louis) 30000)
       (supervisor (Reasoner Louis)
                   (Hacker Alyssa P))
     < src..

     All of these people are in the computer division, as indicated by the word
     @c(computer) as the first item in their job descriptions.

     Ben is a high-level employee. His supervisor is the company's big wheel
     himself:

     ..src > scheme
       (supervisor (Bitdiddle Ben) (Warbucks Oliver))
       (address (Warbucks Oliver)
                (Swellesley (Top Heap Road)))
       (job (Warbucks Oliver)
            (administration big wheel))
       (salary (Warbucks Oliver) 150000)
     < src..

     Besides the computer division supervised by Ben, the company has an accounting
     division, consisting of a chief accountant and his assistant:

     ..src > scheme
       (address (Scrooge Eben)
                (Weston (Shady Lane) 10))
       (job (Scrooge Eben)
            (accounting chief accountant))
       (salary (Scrooge Eben) 75000)
       (supervisor (Scrooge Eben) (Warbucks Oliver))

       (address (Cratchet Robert)
                (Allston (N Harvard Street) 16))
       (job (Cratchet Robert) (accounting scrivener))
       (salary (Cratchet Robert) 18000)
       (supervisor (Cratchet Robert) (Scrooge Eben))
     < src..

     There is also a secretary for the big wheel:

     ..src > scheme
       (address (Aull DeWitt)
                (Slumerville (Onion Square) 5))
       (job (Aull DeWitt) (administration secretary))
       (salary (Aull DeWitt) 25000)
       (supervisor (Aull DeWitt) (Warbucks Oliver))
     < src..

     The data base also contains assertions about which kinds of jobs can be done
     by people holding other kinds of jobs. For instance, a computer wizard can do
     the jobs of both a computer programmer and a computer technician:

     ..src > scheme
       (can-do-job (computer wizard)
                   (computer programmer))

       (can-do-job (computer wizard)
                   (computer technician))
     < src..

     A computer programmer could fill in for a trainee:

     ..src > scheme
       (can-do-job (computer programmer)
                   (computer programmer trainee))
     < src..

     Also, as is well known,

     ..src > scheme
       (can-do-job (administration secretary)
                   (administration big wheel))
     < src..

**** Simple queries

     The query language allows users to retrieve information from the data base by
     posing queries in response to the system's prompt. For example, to find all
     computer programmers one can say

     ..srci > scheme
       ;;; Query input:
       > (job ?x (computer programmer))
     < srci..

     The system will respond with the following items:

     ..srci > scheme
       ;;; Query results:
       > (job (Hacker Alyssa P) (computer programmer))
       > (job (Fect Cy D) (computer programmer))
     < srci..

     The input query specifies that we are looking for entries in the data base
     that match a certain @e(pattern). In this example, the pattern specifies
     entries consisting of three items, of which the first is the literal symbol
     @c(job), the second can be anything, and the third is the literal list
     @c[(computer programmer)]. The @"(anything) that can be the second item in the
     matching list is specified by a @e(pattern variable), @c(?x). The general form
     of a pattern variable is a symbol, taken to be the name of the variable,
     preceded by a question mark. We will see below why it is useful to specify
     names for pattern variables rather than just putting @c(?) into patterns to
     represent @"(anything.)  The system responds to a simple query by showing all
     entries in the data base that match the specified pattern.

     A pattern can have more than one variable. For example, the query

     ..src > scheme
       (address ?x ?y)
     < src..

     will list all the employees' addresses.

     A pattern can have no variables, in which case the query simply determines
     whether that pattern is an entry in the data base. If so, there will be one
     match; if not, there will be no matches.

     The same pattern variable can appear more than once in a query, specifying
     that the same @"(anything) must appear in each position. This is why variables
     have names. For example,

     ..src > scheme
       (supervisor ?x ?x)
     < src..

     finds all people who supervise themselves (though there are no such assertions
     in our sample data base).

     The query

     ..src > scheme
       (job ?x (computer ?type))
     < src..

     matches all job entries whose third item is a two-element list whose first
     item is @c(computer):

     ..src > scheme
       (job (Bitdiddle Ben) (computer wizard))
       (job (Hacker Alyssa P) (computer programmer))
       (job (Fect Cy D) (computer programmer))
       (job (Tweakit Lem E) (computer technician))
     < src..

     This same pattern does @e(not) match

     ..src > scheme
       (job (Reasoner Louis)
            (computer programmer trainee))
     < src..

     because the third item in the entry is a list of three elements, and the
     pattern's third item specifies that there should be two elements. If we wanted
     to change the pattern so that the third item could be any list beginning with
     @c(computer), we could specify@n(266)

     ..src > scheme
       (job ?x (computer . ?type))
     < src..

     For example,

     ..src > scheme
       (computer . ?type)
     < src..

     matches the data

     ..src > scheme
       (computer programmer trainee)
     < src..

     with @c(?type) as the list @c[(programmer trainee)]. It also matches the data

     ..src > scheme
       (computer programmer)
     < src..

     with @c(?type) as the list @c[(programmer)], and matches the data

     ..src > scheme
       (computer)
     < src..

     with @c(?type) as the empty list @c[()].

     We can describe the query language's processing of simple queries as follows:

     - The system finds all assignments to variables in the query pattern that
       @e(satisfy) the pattern––that is, all sets of values for the variables such
       that if the pattern variables are @e(instantiated with) (replaced by) the
       values, the result is in the data base.

     - The system responds to the query by listing all instantiations of the query
       pattern with the variable assignments that satisfy it.


     Note that if the pattern has no variables, the query reduces to a
     determination of whether that pattern is in the data base. If so, the empty
     assignment, which assigns no values to variables, satisfies that pattern for
     that data base.

     :: @t(Exercise 4.55) :: Give simple queries that retrieve the following
        information from the data base:

        1. all people supervised by Ben Bitdiddle;

        2. the names and jobs of all people in the accounting division;

        3. the names and addresses of all people who live in Slumerville.

**** Compound queries

     Simple queries form the primitive operations of the query language. In order
     to form compound operations, the query language provides means of combination.
     One thing that makes the query language a logic programming language is that
     the means of combination mirror the means of combination used in forming
     logical expressions: @c(and), @c(or), and @c(not). (Here @c(and), @c(or), and
     @c(not) are not the Lisp primitives, but rather operations built into the
     query language.)

     We can use @c(and) as follows to find the addresses of all the computer
     programmers:

     ..src > scheme
       (and (job ?person (computer programmer))
            (address ?person ?where))
     < src..

     The resulting output is

     ..src > scheme
       (and (job (Hacker Alyssa P)
                 (computer programmer))
            (address (Hacker Alyssa P)
                     (Cambridge (Mass Ave) 78)))

       (and (job (Fect Cy D) (computer programmer))
            (address (Fect Cy D)
                     (Cambridge (Ames Street) 3)))
     < src..

     In general,

     ..src > scheme
       (and ⟨query₁⟩ ⟨query₂⟩ … ⟨queryₙ⟩)
     < src..

     is satisfied by all sets of values for the pattern variables that
     simultaneously satisfy @m[⟨query₁⟩] … @m[⟨queryₙ⟩].

     As for simple queries, the system processes a compound query by finding all
     assignments to the pattern variables that satisfy the query, then displaying
     instantiations of the query with those values.

     Another means of constructing compound queries is through @c(or). For example,

     ..src > scheme
       (or (supervisor ?x (Bitdiddle Ben))
           (supervisor ?x (Hacker Alyssa P)))
     < src..

     will find all employees supervised by Ben Bitdiddle or Alyssa P. Hacker:

     ..src > scheme
       (or (supervisor (Hacker Alyssa P)
                       (Bitdiddle Ben))
           (supervisor (Hacker Alyssa P)
                       (Hacker Alyssa P)))

       (or (supervisor (Fect Cy D)
                       (Bitdiddle Ben))
           (supervisor (Fect Cy D)
                       (Hacker Alyssa P)))

       (or (supervisor (Tweakit Lem E)
                       (Bitdiddle Ben))
           (supervisor (Tweakit Lem E)
                       (Hacker Alyssa P)))

       (or (supervisor (Reasoner Louis)
                       (Bitdiddle Ben))
           (supervisor (Reasoner Louis)
                       (Hacker Alyssa P)))
     < src..

     In general,

     ..src > scheme
       (or ⟨query₁⟩ ⟨query₂⟩ … ⟨queryₙ⟩)
     < src..

     is satisfied by all sets of values for the pattern variables that satisfy at
     least one of @m[⟨query₁⟩] … @m[⟨queryₙ⟩].

     Compound queries can also be formed with @c(not). For example,

     ..src > scheme
       (and (supervisor ?x (Bitdiddle Ben))
            (not (job ?x (computer programmer))))
     < src..

     finds all people supervised by Ben Bitdiddle who are not computer programmers.
     In general,

     ..src > scheme
       (not ⟨query₁⟩)
     < src..

     is satisfied by all assignments to the pattern variables that do not satisfy
     @m[⟨query₁⟩].@n(267)

     The final combining form is called @c(lisp-value). When @c(lisp-value) is the
     first element of a pattern, it specifies that the next element is a Lisp
     predicate to be applied to the rest of the (instantiated) elements as
     arguments. In general,

     ..src > scheme
       (lisp-value ⟨predicate⟩ ⟨arg₁⟩ … ⟨argₙ⟩)
     < src..

     will be satisfied by assignments to the pattern variables for which the
     @c[(predicate)] applied to the instantiated @m[⟨arg₁⟩] …  @m[⟨argₙ⟩] is
     true. For example, to find all people whose salary is greater than $30,000 we
     could write@n(268)

     ..src > scheme
       (and (salary ?person ?amount)
            (lisp-value > ?amount 30000))
     < src..

     :: @t(Exercise 4.56) :: Formulate compound queries that
        retrieve the following information:

        1. the names of all people who are supervised by Ben Bitdiddle, together
           with their addresses;

        2. all people whose salary is less than Ben Bitdiddle's, together with
           their salary and Ben Bitdiddle's salary;

        3. all people who are supervised by someone who is not in the computer
           division, together with the supervisor's name and job.

**** Rules

     In addition to primitive queries and compound queries, the query language
     provides means for abstracting queries. These are given by @e(rules).  The
     rule

     ..src > scheme
       (rule (lives-near ?person-1 ?person-2)
             (and (address ?person-1
                           (?town . ?rest-1))
                  (address ?person-2
                           (?town . ?rest-2))
                  (not (same ?person-1 ?person-2))))
     < src..

     specifies that two people live near each other if they live in the same town.
     The final @c(not) clause prevents the rule from saying that all people live
     near themselves. The @c(same) relation is defined by a very simple
     rule:@n(269)

     ..src > scheme
       (rule (same ?x ?x))
     < src..

     The following rule declares that a person is a @"(wheel) in an organization if
     he supervises someone who is in turn a supervisor:

     ..src > scheme
       (rule (wheel ?person)
             (and (supervisor ?middle-manager
                              ?person)
                  (supervisor ?x ?middle-manager)))
     < src..

     The general form of a rule is

     ..src > scheme
       (rule ⟨conclusion⟩ ⟨body⟩)
     < src..

     where @c[(conclusion)] is a pattern and @c[(body)] is any query.@n(270) We can
     think of a rule as representing a large (even infinite) set of assertions,
     namely all instantiations of the rule conclusion with variable assignments
     that satisfy the rule body. When we described simple queries (patterns), we
     said that an assignment to variables satisfies a pattern if the instantiated
     pattern is in the data base. But the pattern needn't be explicitly in the data
     base as an assertion. It can be an implicit assertion implied by a rule. For
     example, the query

     ..src > scheme
       (lives-near ?x (Bitdiddle Ben))
     < src..

     results in

     ..src > scheme
       (lives-near (Reasoner Louis) (Bitdiddle Ben))
       (lives-near (Aull DeWitt) (Bitdiddle Ben))
     < src..

     To find all computer programmers who live near Ben Bitdiddle, we can ask

     ..src > scheme
       (and (job ?x (computer programmer))
            (lives-near ?x (Bitdiddle Ben)))
     < src..

     As in the case of compound procedures, rules can be used as parts of other
     rules (as we saw with the @c(lives-near) rule above) or even be defined
     recursively. For instance, the rule

     ..src > scheme
       (rule (outranked-by ?staff-person ?boss)
             (or (supervisor ?staff-person ?boss)
                 (and (supervisor ?staff-person
                                  ?middle-manager)
                      (outranked-by ?middle-manager
                                    ?boss))))
     < src..

     says that a staff person is outranked by a boss in the organization if the
     boss is the person's supervisor or (recursively) if the person's supervisor is
     outranked by the boss.

     :: @t(Exercise 4.57) :: Define a rule that says that person 1 can replace
        person 2 if either person 1 does the same job as person 2 or someone who
        does person 1's job can also do person 2's job, and if person 1 and person
        2 are not the same person. Using your rule, give queries that find the
        following:

        1. all people who can replace Cy D. Fect;

        2. all people who can replace someone who is being paid more than they are,
           together with the two salaries.

     :: @t(Exercise 4.58) :: Define a rule that says that a person is a @"(big
        shot) in a division if the person works in the division but does not have a
        supervisor who works in the division.

     :: @t(Exercise 4.59) :: Ben Bitdiddle has missed one meeting too many. Fearing
        that his habit of forgetting meetings could cost him his job, Ben decides
        to do something about it. He adds all the weekly meetings of the firm to
        the Microshaft data base by asserting the following:

        ..src > scheme
          (meeting accounting (Monday 9am))
          (meeting administration (Monday 10am))
          (meeting computer (Wednesday 3pm))
          (meeting administration (Friday 1pm))
        < src..

        Each of the above assertions is for a meeting of an entire division. Ben
        also adds an entry for the company-wide meeting that spans all the
        divisions. All of the company's employees attend this meeting.

        ..src > scheme
          (meeting whole-company (Wednesday 4pm))
        < src..

        1. On Friday morning, Ben wants to query the data base for all the meetings
           that occur that day. What query should he use?

        2. Alyssa P. Hacker is unimpressed. She thinks it would be much more useful
           to be able to ask for her meetings by specifying her name. So she
           designs a rule that says that a person's meetings include all
           @c(whole-company) meetings plus all meetings of that person's
           division. Fill in the body of Alyssa's rule.

           ..src > scheme
             (rule (meeting-time ?person ?day-and-time)
                   ⟨rule-body⟩)
           < src..

        3. Alyssa arrives at work on Wednesday morning and wonders what meetings
           she has to attend that day. Having defined the above rule, what query
           should she make to find this out?

     :: @t(Exercise 4.60) :: By giving the query

        ..src > scheme
          (lives-near ?person (Hacker Alyssa P))
        < src..

        Alyssa P. Hacker is able to find people who live near her, with whom she
        can ride to work. On the other hand, when she tries to find all pairs of
        people who live near each other by querying

        ..src > scheme
          (lives-near ?person-1 ?person-2)
        < src..

        she notices that each pair of people who live near each other is listed
        twice; for example,

        ..src > scheme
          (lives-near (Hacker Alyssa P) (Fect Cy D))
          (lives-near (Fect Cy D) (Hacker Alyssa P))
        < src..

        Why does this happen?  Is there a way to find a list of people who live
        near each other, in which each pair appears only once?  Explain.

**** Logic as programs

     We can regard a rule as a kind of logical implication: @e(If) an assignment of
     values to pattern variables satisfies the body, @e(then) it satisfies the
     conclusion. Consequently, we can regard the query language as having the
     ability to perform @e(logical deductions) based upon the rules. As an example,
     consider the @c(append) operation described at the beginning of @l(#4.4). As
     we said, @c(append) can be characterized by the following two rules:

     - For any list @c(y), the empty list and @c(y) @c(append) to form @c(y).

     - For any @c(u), @c(v), @c(y), and @c(z), @c[(cons u v)] and @c(y) @c(append)
       to form @c[(cons u z)] if @c(v) and @c(y) @c(append) to form @c(z).

     To express this in our query language, we define two rules for a relation

     ..src > scheme
       (append-to-form x y z)
     < src..

     which we can interpret to mean @"(@c(x) and @c(y) @c(append) to form @c(z)):

     ..src > scheme
       (rule (append-to-form () ?y ?y))
       (rule (append-to-form (?u . ?v) ?y (?u . ?z))
             (append-to-form ?v ?y ?z))
     < src..

     The first rule has no body, which means that the conclusion holds for any
     value of @c(?y). Note how the second rule makes use of dotted-tail notation to
     name the @c(car) and @c(cdr) of a list.

     Given these two rules, we can formulate queries that compute the @c(append) of
     two lists:

     ..srci > scheme
       ;;; Query input:
       > (append-to-form (a b) (c d) ?z)

       ;;; Query results:
       > (append-to-form (a b) (c d) (a b c d))
     < srci..

     What is more striking, we can use the same rules to ask the question @"(Which
     list, when @c(append)ed to @c[(a b)], yields @c[(a b c d)]?)  This is done as
     follows:

     ..srci > scheme
       ;;; Query input:
       > (append-to-form (a b) ?y (a b c d))

       ;;; Query results:
       > (append-to-form (a b) (c d) (a b c d))
     < srci..

     We can also ask for all pairs of lists that @c(append) to form @c[(a b c d)]:

     ..srci > scheme
       ;;; Query input:
       > (append-to-form ?x ?y (a b c d))

       ;;; Query results:
       > (append-to-form () (a b c d) (a b c d))
       > (append-to-form (a) (b c d) (a b c d))
       > (append-to-form (a b) (c d) (a b c d))
       > (append-to-form (a b c) (d) (a b c d))
       > (append-to-form (a b c d) () (a b c d))
     < srci..

     The query system may seem to exhibit quite a bit of intelligence in using the
     rules to deduce the answers to the queries above. Actually, as we will see in
     the next section, the system is following a well-determined algorithm in
     unraveling the rules. Unfortunately, although the system works impressively in
     the @c(append) case, the general methods may break down in more complex cases,
     as we will see in @l(#4.4.3).

     :: @t(Exercise 4.61) :: The following rules implement a @c(next-to) relation
        that finds adjacent elements of a list:

        ..src > scheme
          (rule (?x next-to ?y in (?x ?y . ?u)))
          (rule (?x next-to ?y in (?v . ?z))
                (?x next-to ?y in ?z))
        < src..

        What will the response be to the following queries?

        ..src > scheme
          (?x next-to ?y in (1 (2 3) 4))
          (?x next-to 1 in (2 1 3 1))
        < src..

     :: @t(Exercise 4.62) :: Define rules to implement the @c(last-pair) operation
        of @l(#Exercise 2.17), which returns a list containing the last element of
        a nonempty list. Check your rules on queries such as @c[(last-pair (3)
        ?x)], @c[(last-pair (1 2 3) ?x)] and @c[(last-pair (2 ?x) (3))]. Do your
        rules work correctly on queries such as @c[(last-pair ?x (3))]?

     :: @t(Exercise 4.63) :: The following data base (see Genesis 4) traces the
        genealogy of the descendants of Ada back to Adam, by way of Cain:

        ..src > scheme
          (son Adam Cain) (son Cain Enoch)
          (son Enoch Irad) (son Irad Mehujael)
          (son Mehujael Methushael)
          (son Methushael Lamech)
          (wife Lamech Ada) (son Ada Jabal)
          (son Ada Jubal)
        < src..

        Formulate rules such as @"(If @m(S) is the son of @m(f), and @m(f) is the
        son of @m(G), then @m(S) is the grandson of @m(G)) and @"(If @m(W) is the
        wife of @m(M), and @m(S) is the son of @m(W), then @m(S) is the son of
        @m(M)) (which was supposedly more true in biblical times than today) that
        will enable the query system to find the grandson of Cain; the sons of
        Lamech; the grandsons of Methushael. (See @l(#Exercise 4.69) for some rules
        to deduce more complicated relationships.)

*** 4.4.2 <> How the Query System Works

    In section @l(#4.4.4) we will present an implementation of the query
    interpreter as a collection of procedures. In this section we give an overview
    that explains the general structure of the system independent of low-level
    implementation details. After describing the implementation of the
    interpreter, we will be in a position to understand some of its limitations
    and some of the subtle ways in which the query language's logical operations
    differ from the operations of mathematical logic.

    It should be apparent that the query evaluator must perform some kind of
    search in order to match queries against facts and rules in the data base. One
    way to do this would be to implement the query system as a nondeterministic
    program, using the @c(amb) evaluator of @l(#4.3) (see @l(#Exercise 4.78)).
    Another possibility is to manage the search with the aid of streams. Our
    implementation follows this second approach.

    The query system is organized around two central operations called @e(pattern
    matching) and @e(unification). We first describe pattern matching and explain
    how this operation, together with the organization of information in terms of
    streams of frames, enables us to implement both simple and compound
    queries. We next discuss unification, a generalization of pattern matching
    needed to implement rules. Finally, we show how the entire query interpreter
    fits together through a procedure that classifies expressions in a manner
    analogous to the way @c(eval) classifies expressions for the interpreter
    described in @l(#4.1).

**** Pattern matching

     A @e(pattern matcher) is a program that tests whether some datum fits a
     specified pattern. For example, the data list @c[((a b) c (a b))] matches the
     pattern @c[(?x c ?x)] with the pattern variable @c(?x) bound to @c[(a b)]. The
     same data list matches the pattern @c[(?x ?y ?z)] with @c(?x) and @c(?z) both
     bound to @c[(a b)] and @c(?y) bound to @c(c). It also matches the pattern
     @c[((?x ?y) c (?x ?y))] with @c(?x) bound to @c(a) and @c(?y) bound to
     @c(b). However, it does not match the pattern @c[(?x a ?y)], since that
     pattern specifies a list whose second element is the symbol @c(a).

     The pattern matcher used by the query system takes as inputs a pattern, a
     datum, and a @e(frame) that specifies bindings for various pattern
     variables. It checks whether the datum matches the pattern in a way that is
     consistent with the bindings already in the frame. If so, it returns the given
     frame augmented by any bindings that may have been determined by the match.
     Otherwise, it indicates that the match has failed.

     For example, using the pattern @c[(?x ?y ?x)] to match @c[(a b a)] given an
     empty frame will return a frame specifying that @c(?x) is bound to @c(a) and
     @c(?y) is bound to @c(b). Trying the match with the same pattern, the same
     datum, and a frame specifying that @c(?y) is bound to @c(a) will fail. Trying
     the match with the same pattern, the same datum, and a frame in which @c(?y)
     is bound to @c(b) and @c(?x) is unbound will return the given frame augmented
     by a binding of @c(?x) to @c(a).

     The pattern matcher is all the mechanism that is needed to process simple
     queries that don't involve rules. For instance, to process the query

     ..src > scheme
       (job ?x (computer programmer))
     < src..

     we scan through all assertions in the data base and select those that match
     the pattern with respect to an initially empty frame. For each match we find,
     we use the frame returned by the match to instantiate the pattern with a value
     for @c(?x).

**** Streams of frames

     The testing of patterns against frames is organized through the use of
     streams.  Given a single frame, the matching process runs through the
     data-base entries one by one. For each data-base entry, the matcher generates
     either a special symbol indicating that the match has failed or an extension
     to the frame. The results for all the data-base entries are collected into a
     stream, which is passed through a filter to weed out the failures. The result
     is a stream of all the frames that extend the given frame via a match to some
     assertion in the data base.@n(271)

     In our system, a query takes an input stream of frames and performs the above
     matching operation for every frame in the stream, as indicated in @l(#Figure
     4.4).  That is, for each frame in the input stream, the query generates a new
     stream consisting of all extensions to that frame by matches to assertions in
     the data base. All these streams are then combined to form one huge stream,
     which contains all possible extensions of every frame in the input stream.
     This stream is the output of the query.

     ..figure > @t(Figure 4.4) A query processes a stream of frames.

       ..art >
                                           output stream
           input stream   ╭─────────────╮  of frames,
           of frames      │    query    │  filtered and extended
         ────────────────▶│             ├─────────────────────────▶
                          │ (job ?x ?y) │
                          ╰─────────────╯
                                 ▲
                                 │
                        stream of assertions
                           from data base
       < art..

@    ..img > img/chap4/Fig4.4a.std.svg

     To answer a simple query, we use the query with an input stream consisting of
     a single empty frame. The resulting output stream contains all extensions to
     the empty frame (that is, all answers to our query). This stream of frames is
     then used to generate a stream of copies of the original query pattern with
     the variables instantiated by the values in each frame, and this is the stream
     that is finally printed.

**** Compound queries

     The real elegance of the stream-of-frames implementation is evident when we
     deal with compound queries. The processing of compound queries makes use of
     the ability of our matcher to demand that a match be consistent with a
     specified frame. For example, to handle the @c(and) of two queries, such as

     ..src > scheme
       (and (can-do-job
             ?x
             (computer programmer trainee))
            (job ?person ?x))
     < src..

     (informally, @"(Find all people who can do the job of a computer programmer
     trainee)), we first find all entries that match the pattern

     ..src > scheme
       (can-do-job ?x (computer programmer trainee))
     < src..

     This produces a stream of frames, each of which contains a binding for
     @c(?x). Then for each frame in the stream we find all entries that match

     ..src > scheme
       (job ?person ?x)
     < src..

     in a way that is consistent with the given binding for @c(?x). Each such match
     will produce a frame containing bindings for @c(?x) and @c(?person). The
     @c(and) of two queries can be viewed as a series combination of the two
     component queries, as shown in @l(#Figure 4.5). The frames that pass through
     the first query filter are filtered and further extended by the second query.

     ..figure > @t(Figure 4.5) The @c(and) combination of two queries is produced
       by operating on the stream of frames in series.

       ..art >
                         ╭──────────────────────╮
                         │       (and A B)      │
           input stream  │                      │  output stream
           of frames     │   ╭───╮       ╭───╮  │  of frames
         ────────────────┼──▶│ A ├──────▶│ B ├──┼─────────────────▶
                         │   ╰───╯       ╰───╯  │
                         │     ▲           ▲    │
                         │     │           │    │
                         │     ╰─────●─────╯    │
                         ╰───────────┼──────────╯
                                     │
                                 data base
       < art..

@    ..img > img/chap4/Fig4.5a.std.svg

     @l(#Figure 4.6) shows the analogous method for computing the @c(or) of two
     queries as a parallel combination of the two component queries. The input
     stream of frames is extended separately by each query. The two resulting
     streams are then merged to produce the final output stream.

     ..figure > @t(Figure 4.6) The @c(or) combination of two queries is produced by
       operating on the stream of frames in parallel and merging the results.

       ..art >
                    ╭───────────────────────────╮
                    │          (or A B)         │
                    │    ╭───╮                  │
         input      │ ╭─▶│ A │────────────╮     │  output
         stream of  │ │  ╰───╯            ▼     │  stream of
         frames     │ │    ▲          ╭───────╮ │  frames
         ───────────┼─●    │          │ merge ├─┼─────────────▶
                    │ │    │          ╰───────╯ │
                    │ │    │              ▲     │
                    │ │    │   ╭───╮      │     │
                    │ ╰────┼──▶│ B ├──────╯     │
                    │      │   ╰───╯            │
                    │      │     ▲              │
                    │      │     │              │
                    │      ╰──●──╯              │
                    ╰─────────┼─────────────────╯
                              │
                          data base
       < art..

@    ..img > img/chap4/Fig4.6a.std.svg

     Even from this high-level description, it is apparent that the processing of
     compound queries can be slow. For example, since a query may produce more than
     one output frame for each input frame, and each query in an @c(and) gets its
     input frames from the previous query, an @c(and) query could, in the worst
     case, have to perform a number of matches that is exponential in the number of
     queries (see @l(#Exercise 4.76)).@n(272) Though systems for handling only
     simple queries are quite practical, dealing with complex queries is extremely
     difficult.@n(273)

     From the stream-of-frames viewpoint, the @c(not) of some query acts as a
     filter that removes all frames for which the query can be satisfied. For
     instance, given the pattern

     ..src > scheme
       (not (job ?x (computer programmer)))
     < src..

     we attempt, for each frame in the input stream, to produce extension frames
     that satisfy @c[(job ?x (computer programmer))]. We remove from the input
     stream all frames for which such extensions exist. The result is a stream
     consisting of only those frames in which the binding for @c(?x) does not
     satisfy @c[(job ?x (computer programmer))]. For example, in processing the
     query

     ..src > scheme
       (and (supervisor ?x ?y)
            (not (job ?x (computer programmer))))
     < src..

     the first clause will generate frames with bindings for @c(?x) and @c(?y). The
     @c(not) clause will then filter these by removing all frames in which the
     binding for @c(?x) satisfies the restriction that @c(?x) is a computer
     programmer.@n(274)

     The @c(lisp-value) special form is implemented as a similar filter on frame
     streams. We use each frame in the stream to instantiate any variables in the
     pattern, then apply the Lisp predicate. We remove from the input stream all
     frames for which the predicate fails.

**** Unification

     In order to handle rules in the query language, we must be able to find the
     rules whose conclusions match a given query pattern. Rule conclusions are like
     assertions except that they can contain variables, so we will need a
     generalization of pattern matching––called @e(unification)––in which both the
     @"(pattern) and the @"(datum) may contain variables.

     A unifier takes two patterns, each containing constants and variables, and
     determines whether it is possible to assign values to the variables that will
     make the two patterns equal. If so, it returns a frame containing these
     bindings. For example, unifying @c[(?x a ?y)] and @c[(?y ?z a)] will specify a
     frame in which @c(?x), @c(?y), and @c(?z) must all be bound to @c(a). On the
     other hand, unifying @c[(?x ?y a)] and @c[(?x b ?y)] will fail, because there
     is no value for @c(?y) that can make the two patterns equal. (For the second
     elements of the patterns to be equal, @c(?y) would have to be @c(b); however,
     for the third elements to be equal, @c(?y) would have to be @c(a).)  The
     unifier used in the query system, like the pattern matcher, takes a frame as
     input and performs unifications that are consistent with this frame.

     The unification algorithm is the most technically difficult part of the query
     system. With complex patterns, performing unification may seem to require
     deduction. To unify @c[(?x ?x)] and @c[((a ?y c) (a b ?z))], for example, the
     algorithm must infer that @c(?x) should be @c[(a b c)], @c(?y) should be
     @c(b), and @c(?z) should be @c(c). We may think of this process as solving a
     set of equations among the pattern components. In general, these are
     simultaneous equations, which may require substantial manipulation to
     solve.@n(275) For example, unifying @c[(?x ?x)] and @c[((a ?y c) (a b ?z))]
     may be thought of as specifying the simultaneous equations

     ..src > scheme
       ?x = (a ?y c)
       ?x = (a b ?z)
     < src..

     These equations imply that

     ..src > scheme
       (a ?y c) = (a b ?z)
     < src..

     which in turn implies that

     ..src > scheme
       a = a, ?y = b, c = ?z,
     < src..

     and hence that

     ..src > scheme
       ?x = (a b c)
     < src..

     In a successful pattern match, all pattern variables become bound, and the
     values to which they are bound contain only constants. This is also true of
     all the examples of unification we have seen so far. In general, however, a
     successful unification may not completely determine the variable values; some
     variables may remain unbound and others may be bound to values that contain
     variables.

     Consider the unification of @c[(?x a)] and @c[((b ?y) ?z)]. We can deduce that
     @c(?x = (b ?y)) and @c(a = ?z), but we cannot further solve for @c(?x) or
     @c(?y). The unification doesn't fail, since it is certainly possible to make
     the two patterns equal by assigning values to @c(?x) and @c(?y). Since this
     match in no way restricts the values @c(?y) can take on, no binding for @c(?y)
     is put into the result frame.  The match does, however, restrict the value of
     @c(?x). Whatever value @c(?y) has, @c(?x) must be @c[(b ?y)]. A binding of
     @c(?x) to the pattern @c[(b ?y)] is thus put into the frame. If a value for
     @c(?y) is later determined and added to the frame (by a pattern match or
     unification that is required to be consistent with this frame), the previously
     bound @c(?x) will refer to this value.@n(276)

**** Applying rules

     Unification is the key to the component of the query system that makes
     inferences from rules. To see how this is accomplished, consider processing a
     query that involves applying a rule, such as

     ..src > scheme
       (lives-near ?x (Hacker Alyssa P))
     < src..

     To process this query, we first use the ordinary pattern-match procedure
     described above to see if there are any assertions in the data base that match
     this pattern. (There will not be any in this case, since our data base
     includes no direct assertions about who lives near whom.)  The next step is to
     attempt to unify the query pattern with the conclusion of each rule. We find
     that the pattern unifies with the conclusion of the rule

     ..src > scheme
       (rule (lives-near ?person-1 ?person-2)
             (and (address ?person-1
                           (?town . ?rest-1))
                  (address ?person-2
                           (?town . ?rest-2))
                  (not (same ?person-1 ?person-2))))
     < src..

     resulting in a frame specifying that @c(?person-2) is bound to @c[(Hacker
     Alyssa P)] and that @c(?x) should be bound to (have the same value as)
     @c(?person-1). Now, relative to this frame, we evaluate the compound query
     given by the body of the rule. Successful matches will extend this frame by
     providing a binding for @c(?person-1), and consequently a value for @c(?x),
     which we can use to instantiate the original query pattern.

     In general, the query evaluator uses the following method to apply a rule when
     trying to establish a query pattern in a frame that specifies bindings for
     some of the pattern variables:

     - Unify the query with the conclusion of the rule to form, if successful, an
       extension of the original frame.

     - Relative to the extended frame, evaluate the query formed by the body of the
       rule.


     Notice how similar this is to the method for applying a procedure in the
     @c(eval)/@c(apply) evaluator for Lisp:

     - Bind the procedure's parameters to its arguments to form a frame that
       extends the original procedure environment.

     - Relative to the extended environment, evaluate the expression formed by the
       body of the procedure.


     The similarity between the two evaluators should come as no surprise. Just as
     procedure definitions are the means of abstraction in Lisp, rule definitions
     are the means of abstraction in the query language. In each case, we unwind
     the abstraction by creating appropriate bindings and evaluating the rule or
     procedure body relative to these.

**** Simple queries

     We saw earlier in this section how to evaluate simple queries in the absence
     of rules. Now that we have seen how to apply rules, we can describe how to
     evaluate simple queries by using both rules and assertions.

     Given the query pattern and a stream of frames, we produce, for each frame in
     the input stream, two streams:

     - a stream of extended frames obtained by matching the pattern against all
       assertions in the data base (using the pattern matcher), and

     - a stream of extended frames obtained by applying all possible rules (using
       the unifier).@n(277)

     Appending these two streams produces a stream that consists of all the ways
     that the given pattern can be satisfied consistent with the original frame.
     These streams (one for each frame in the input stream) are now all combined to
     form one large stream, which therefore consists of all the ways that any of
     the frames in the original input stream can be extended to produce a match
     with the given pattern.

**** The query evaluator and the driver loop

     Despite the complexity of the underlying matching operations, the system is
     organized much like an evaluator for any language. The procedure that
     coordinates the matching operations is called @c(qeval), and it plays a role
     analogous to that of the @c(eval) procedure for Lisp. @c(Qeval) takes as
     inputs a query and a stream of frames. Its output is a stream of frames,
     corresponding to successful matches to the query pattern, that extend some
     frame in the input stream, as indicated in @l(#Figure 4.4). Like @c(eval),
     @c(qeval) classifies the different types of expressions (queries) and
     dispatches to an appropriate procedure for each. There is a procedure for each
     special form (@c(and), @c(or), @c(not), and @c(lisp-value)) and one for simple
     queries.

     The driver loop, which is analogous to the @c(driver-loop) procedure for the
     other evaluators in this chapter, reads queries from the terminal. For each
     query, it calls @c(qeval) with the query and a stream that consists of a
     single empty frame. This will produce the stream of all possible matches (all
     possible extensions to the empty frame). For each frame in the resulting
     stream, it instantiates the original query using the values of the variables
     found in the frame. This stream of instantiated queries is then
     printed.@n(278)

     The driver also checks for the special command @c(assert!), which signals that
     the input is not a query but rather an assertion or rule to be added to the
     data base. For instance,

     ..src > scheme
       (assert!
        (job (Bitdiddle Ben)
             (computer wizard)))

       (assert!
        (rule (wheel ?person)
              (and (supervisor
                    ?middle-manager ?person)
                   (supervisor
                    ?x ?middle-manager))))
     < src..

*** 4.4.3 <> Is Logic Programming Mathematical Logic?

    The means of combination used in the query language may at first seem
    identical to the operations @c(and), @c(or), and @c(not) of mathematical
    logic, and the application of query-language rules is in fact accomplished
    through a legitimate method of inference.@n(279) This identification of the
    query language with mathematical logic is not really valid, though, because
    the query language provides a @e(control structure) that interprets the
    logical statements procedurally. We can often take advantage of this control
    structure. For example, to find all of the supervisors of programmers we could
    formulate a query in either of two logically equivalent forms:

    ..src > scheme
      (and (job ?x (computer programmer))
           (supervisor ?x ?y))
    < src..

    or

    ..src > scheme
      (and (supervisor ?x ?y)
           (job ?x (computer programmer)))
    < src..

    If a company has many more supervisors than programmers (the usual case), it
    is better to use the first form rather than the second because the data base
    must be scanned for each intermediate result (frame) produced by the first
    clause of the @c(and).

    The aim of logic programming is to provide the programmer with techniques for
    decomposing a computational problem into two separate problems: @"(what) is to
    be computed, and @"(how) this should be computed. This is accomplished by
    selecting a subset of the statements of mathematical logic that is powerful
    enough to be able to describe anything one might want to compute, yet weak
    enough to have a controllable procedural interpretation. The intention here is
    that, on the one hand, a program specified in a logic programming language
    should be an effective program that can be carried out by a computer. Control
    (@"(how) to compute) is effected by using the order of evaluation of the
    language. We should be able to arrange the order of clauses and the order of
    subgoals within each clause so that the computation is done in an order deemed
    to be effective and efficient. At the same time, we should be able to view the
    result of the computation (@"(what) to compute) as a simple consequence of the
    laws of logic.

    Our query language can be regarded as just such a procedurally interpretable
    subset of mathematical logic. An assertion represents a simple fact (an atomic
    proposition). A rule represents the implication that the rule conclusion holds
    for those cases where the rule body holds. A rule has a natural procedural
    interpretation: To establish the conclusion of the rule, establish the body of
    the rule. Rules, therefore, specify computations. However, because rules can
    also be regarded as statements of mathematical logic, we can justify any
    @"(inference) accomplished by a logic program by asserting that the same
    result could be obtained by working entirely within mathematical logic.@n(280)

**** Infinite loops

     A consequence of the procedural interpretation of logic programs is that it is
     possible to construct hopelessly inefficient programs for solving certain
     problems. An extreme case of inefficiency occurs when the system falls into
     infinite loops in making deductions. As a simple example, suppose we are
     setting up a data base of famous marriages, including

     ..src > scheme
       (assert! (married Minnie Mickey))
     < src..

     If we now ask

     ..src > scheme
       (married Mickey ?who)
     < src..

     we will get no response, because the system doesn't know that if @m(a) is
     married to @m(B), then @m(B) is married to @m(a). So we assert the rule

     ..src > scheme
       (assert! (rule (married ?x ?y)
                      (married ?y ?x)))
     < src..

     and again query

     ..src > scheme
       (married Mickey ?who)
     < src..

     Unfortunately, this will drive the system into an infinite loop, as follows:

     - The system finds that the @c(married) rule is applicable; that is, the rule
       conclusion @c[(married ?x ?y)] successfully unifies with the query pattern
       @c[(married Mickey ?who)] to produce a frame in which @c(?x) is bound to
       @c(Mickey) and @c(?y) is bound to @c(?who). So the interpreter proceeds to
       evaluate the rule body @c[(married ?y ?x)] in this frame––in effect, to
       process the query @c[(married ?who Mickey)].

     - One answer appears directly as an assertion in the data base: @c[(married
       Minnie Mickey)].

     - The @c(married) rule is also applicable, so the interpreter again evaluates
       the rule body, which this time is equivalent to @c[(married Mickey ?who)].


     The system is now in an infinite loop. Indeed, whether the system will find
     the simple answer @c[(married Minnie Mickey)] before it goes into the loop
     depends on implementation details concerning the order in which the system
     checks the items in the data base. This is a very simple example of the kinds
     of loops that can occur. Collections of interrelated rules can lead to loops
     that are much harder to anticipate, and the appearance of a loop can depend on
     the order of clauses in an @c(and) (see @l(#Exercise 4.64)) or on low-level
     details concerning the order in which the system processes queries.@n(281)

**** Problems with @c(not)

     Another quirk in the query system concerns @c(not). Given the data base of
     @l(#4.4.1), consider the following two queries:

     ..src > scheme
       (and (supervisor ?x ?y)
            (not (job ?x (computer programmer))))

       (and (not (job ?x (computer programmer)))
            (supervisor ?x ?y))
     < src..

     These two queries do not produce the same result. The first query begins by
     finding all entries in the data base that match @c[(supervisor ?x ?y)], and
     then filters the resulting frames by removing the ones in which the value of
     @c(?x) satisfies @c[(job ?x (computer programmer))]. The second query begins
     by filtering the incoming frames to remove those that can satisfy @c[(job ?x
     (computer programmer))]. Since the only incoming frame is empty, it checks the
     data base to see if there are any patterns that satisfy @c[(job ?x (computer
     programmer))]. Since there generally are entries of this form, the @c(not)
     clause filters out the empty frame and returns an empty stream of
     frames. Consequently, the entire compound query returns an empty stream.

     The trouble is that our implementation of @c(not) really is meant to serve as
     a filter on values for the variables. If a @c(not) clause is processed with a
     frame in which some of the variables remain unbound (as does @c(?x) in the
     example above), the system will produce unexpected results. Similar problems
     occur with the use of @c(lisp-value)––the Lisp predicate can't work if some of
     its arguments are unbound. See @l(#Exercise 4.77).

     There is also a much more serious way in which the @c(not) of the query
     language differs from the @c(not) of mathematical logic. In logic, we
     interpret the statement @"(not @m(P)) to mean that @m(P) is not true. In the
     query system, however, @"(not @m(P)) means that @m(P) is not deducible from
     the knowledge in the data base. For example, given the personnel data base of
     @l(#4.4.1), the system would happily deduce all sorts of @c(not) statements,
     such as that Ben Bitdiddle is not a baseball fan, that it is not raining
     outside, and that 2 + 2 is not 4.@n(282) In other words, the @c(not) of logic
     programming languages reflects the so-called @e(closed world assumption) that
     all relevant information has been included in the data base.@n(283)

     :: @t(Exercise 4.64) :: Louis Reasoner mistakenly deletes the @c(outranked-by)
        rule (@l(#4.4.1)) from the data base. When he realizes this, he quickly
        reinstalls it. Unfortunately, he makes a slight change in the rule, and
        types it in as

        ..src > scheme
          (rule (outranked-by ?staff-person ?boss)
            (or (supervisor ?staff-person ?boss)
                (and (outranked-by ?middle-manager
                                   ?boss)
                     (supervisor ?staff-person
                                 ?middle-manager))))
        < src..

        Just after Louis types this information into the system, DeWitt Aull comes
        by to find out who outranks Ben Bitdiddle. He issues the query

        ..src > scheme
          (outranked-by (Bitdiddle Ben) ?who)
        < src..

        After answering, the system goes into an infinite loop. Explain why.

     :: @t(Exercise 4.65) :: Cy D. Fect, looking forward to the day when he will
        rise in the organization, gives a query to find all the wheels (using the
        @c(wheel) rule of @l(#4.4.1)):

        ..src > scheme
          (wheel ?who)
        < src..

        To his surprise, the system responds

        ..srci > scheme
          ;;; Query results:
          > (wheel (Warbucks Oliver))
          > (wheel (Bitdiddle Ben))
          > (wheel (Warbucks Oliver))
          > (wheel (Warbucks Oliver))
          > (wheel (Warbucks Oliver))
        < srci..

        Why is Oliver Warbucks listed four times?

     :: @t(Exercise 4.66) :: Ben has been generalizing the query system to provide
        statistics about the company. For example, to find the total salaries of
        all the computer programmers one will be able to say

        ..src > scheme
          (sum ?amount
               (and (job ?x (computer programmer))
                    (salary ?x ?amount)))
        < src..

        In general, Ben's new system allows expressions of the form

        ..src > scheme
          (accumulation-function ⟨variable⟩
                                 ⟨query pattern⟩)
        < src..

        where @c(accumulation-function) can be things like @c(sum), @c(average), or
        @c(maximum). Ben reasons that it should be a cinch to implement this. He
        will simply feed the query pattern to @c(qeval). This will produce a stream
        of frames. He will then pass this stream through a mapping function that
        extracts the value of the designated variable from each frame in the stream
        and feed the resulting stream of values to the accumulation function. Just
        as Ben completes the implementation and is about to try it out, Cy walks
        by, still puzzling over the @c(wheel) query result in @l(#Exercise
        4.65). When Cy shows Ben the system's response, Ben groans, @"(Oh, no, my
        simple accumulation scheme won't work!)

        What has Ben just realized?  Outline a method he can use to salvage the
        situation.

     :: @t(Exercise 4.67) :: Devise a way to install a loop detector in the query
        system so as to avoid the kinds of simple loops illustrated in the text and
        in @l(#Exercise 4.64). The general idea is that the system should maintain
        some sort of history of its current chain of deductions and should not
        begin processing a query that it is already working on. Describe what kind
        of information (patterns and frames) is included in this history, and how
        the check should be made. (After you study the details of the query-system
        implementation in @l(#4.4.4), you may want to modify the system to include
        your loop detector.)

     :: @t(Exercise 4.68) :: Define rules to implement the @c(reverse) operation of
        @l(#Exercise 2.18), which returns a list containing the same elements as a
        given list in reverse order. (Hint: Use @c(append-to-form).)  Can your
        rules answer both @c[(reverse (1 2 3) ?x)] and @c[(reverse ?x (1 2 3))]?

     :: @t(Exercise 4.69) :: Beginning with the data base and the rules you
        formulated in @l(#Exercise 4.63), devise a rule for adding @"(greats) to a
        grandson relationship. This should enable the system to deduce that Irad is
        the great-grandson of Adam, or that Jabal and Jubal are the
        great-great-great-great-great-grandsons of Adam. (Hint: Represent the fact
        about Irad, for example, as @c[((great grandson) Adam Irad)]. Write rules
        that determine if a list ends in the word @c(grandson). Use this to express
        a rule that allows one to derive the relationship @c[((great . ?rel) ?x
        ?y)], where @c(?rel) is a list ending in @c(grandson).)  Check your rules
        on queries such as @c[((great grandson) ?g ?ggs)] and @c[(?relationship
        Adam Irad)].

*** 4.4.4 <> Implementing the Query System

    Section @l(#4.4.2) described how the query system works. Now we fill in the
    details by presenting a complete implementation of the system.

**** 4.4.4.1 <> The Driver Loop and Instantiation

     The driver loop for the query system repeatedly reads input expressions. If
     the expression is a rule or assertion to be added to the data base, then the
     information is added. Otherwise the expression is assumed to be a query. The
     driver passes this query to the evaluator @c(qeval) together with an initial
     frame stream consisting of a single empty frame. The result of the evaluation
     is a stream of frames generated by satisfying the query with variable values
     found in the data base. These frames are used to form a new stream consisting
     of copies of the original query in which the variables are instantiated with
     values supplied by the stream of frames, and this final stream is printed at
     the terminal:

     ..src > scheme
       (define input-prompt  ";;; Query input:")
       (define output-prompt ";;; Query results:")

       (define (query-driver-loop)
         (prompt-for-input input-prompt)
         (let ((q (query-syntax-process (read))))
           (cond ((assertion-to-be-added? q)
                  (add-rule-or-assertion!
                   (add-assertion-body q))
                  (newline)
                  (display
                   "Assertion added to data base.")
                  (query-driver-loop))
                 (else
                  (newline)
                  (display output-prompt)
                  (display-stream
                   (stream-map
                    (lambda (frame)
                      (instantiate
                       q
                       frame
                       (lambda (v f)
                         (contract-question-mark v))))
                    (qeval q (singleton-stream '()))))
                  (query-driver-loop)))))
     < src..

     Here, as in the other evaluators in this chapter, we use an abstract syntax
     for the expressions of the query language. The implementation of the
     expression syntax, including the predicate @c(assertion-to-be-added?) and the
     selector @c(add-assertion-body), is given in @l(#4.4.4.7).
     @c(Add-rule-or-assertion!) is defined in @l(#4.4.4.5).

     Before doing any processing on an input expression, the driver loop transforms
     it syntactically into a form that makes the processing more efficient. This
     involves changing the representation of pattern variables. When the query is
     instantiated, any variables that remain unbound are transformed back to the
     input representation before being printed. These transformations are performed
     by the two procedures @c(query-syntax-process) and @c(contract-question-mark)
     (@l(#4.4.4.7)).

     To instantiate an expression, we copy it, replacing any variables in the
     expression by their values in a given frame. The values are themselves
     instantiated, since they could contain variables (for example, if @c(?x) in
     @c(exp) is bound to @c(?y) as the result of unification and @c(?y) is in turn
     bound to 5). The action to take if a variable cannot be instantiated is given
     by a procedural argument to @c(instantiate).

     ..src > scheme
       (define (instantiate
                exp frame unbound-var-handler)
         (define (copy exp)
           (cond ((var? exp)
                  (let ((binding
                         (binding-in-frame
                          exp frame)))
                    (if binding
                        (copy
                         (binding-value binding))
                        (unbound-var-handler
                         exp frame))))
                 ((pair? exp)
                  (cons (copy (car exp))
                        (copy (cdr exp))))
                 (else exp)))
         (copy exp))
     < src..

     The procedures that manipulate bindings are defined in @l(#4.4.4.8).

**** 4.4.4.2 <> The Evaluator

     The @c(qeval) procedure, called by the @c(query-driver-loop), is the basic
     evaluator of the query system. It takes as inputs a query and a stream of
     frames, and it returns a stream of extended frames. It identifies special
     forms by a data-directed dispatch using @c(get) and @c(put), just as we did in
     implementing generic operations in @l(#Chapter 2). Any query that is not
     identified as a special form is assumed to be a simple query, to be processed
     by @c(simple-query).

     ..src > scheme
       (define (qeval query frame-stream)
         (let ((qproc (get (type query) 'qeval)))
           (if qproc
               (qproc (contents query) frame-stream)
               (simple-query query frame-stream))))
     < src..

     @c(Type) and @c(contents), defined in @l(#4.4.4.7), implement the abstract
     syntax of the special forms.

***** Simple queries

      The @c(simple-query) procedure handles simple queries. It takes as arguments a
      simple query (a pattern) together with a stream of frames, and it returns the
      stream formed by extending each frame by all data-base matches of the query.

      ..src > scheme
        (define (simple-query query-pattern
                              frame-stream)
          (stream-flatmap
           (lambda (frame)
             (stream-append-delayed
              (find-assertions query-pattern frame)
              (delay
                (apply-rules query-pattern frame))))
           frame-stream))
      < src..

      For each frame in the input stream, we use @c(find-assertions) (@l(#4.4.4.3))
      to match the pattern against all assertions in the data base, producing a
      stream of extended frames, and we use @c(apply-rules) (@l(#4.4.4.4)) to apply
      all possible rules, producing another stream of extended frames. These two
      streams are combined (using @c(stream-append-delayed), @l(#4.4.4.6)) to make a
      stream of all the ways that the given pattern can be satisfied consistent with
      the original frame (see @l(#Exercise 4.71)). The streams for the individual
      input frames are combined using @c(stream-flatmap) (@l(#4.4.4.6)) to form one
      large stream of all the ways that any of the frames in the original input
      stream can be extended to produce a match with the given pattern.

***** Compound queries

      @c(And) queries are handled as illustrated in @l(#Figure 4.5) by the
      @c(conjoin) procedure. @c(Conjoin) takes as inputs the conjuncts and the frame
      stream and returns the stream of extended frames. First, @c(conjoin) processes
      the stream of frames to find the stream of all possible frame extensions that
      satisfy the first query in the conjunction. Then, using this as the new frame
      stream, it recursively applies @c(conjoin) to the rest of the queries.

      ..src > scheme
        (define (conjoin conjuncts frame-stream)
          (if (empty-conjunction? conjuncts)
              frame-stream
              (conjoin (rest-conjuncts conjuncts)
                       (qeval
                        (first-conjunct conjuncts)
                        frame-stream))))
      < src..

      The expression

      ..src > scheme
        (put 'and 'qeval conjoin)
      < src..

      sets up @c(qeval) to dispatch to @c(conjoin) when an @c(and) form is
      encountered.

      @c(Or) queries are handled similarly, as shown in @l(#Figure 4.6). The output
      streams for the various disjuncts of the @c(or) are computed separately and
      merged using the @c(interleave-delayed) procedure from @l(#4.4.4.6). (See
      @l(#Exercise 4.71) and @l(#Exercise 4.72).)

      ..src > scheme
        (define (disjoin disjuncts frame-stream)
          (if (empty-disjunction? disjuncts)
              the-empty-stream
              (interleave-delayed
               (qeval (first-disjunct disjuncts)
                      frame-stream)
               (delay (disjoin
                       (rest-disjuncts disjuncts)
                       frame-stream)))))
        (put 'or 'qeval disjoin)
      < src..

      The predicates and selectors for the syntax of conjuncts and disjuncts are
      given in @l(#4.4.4.7).

***** Filters

      @c(Not) is handled by the method outlined in @l(#4.4.2). We attempt to extend
      each frame in the input stream to satisfy the query being negated, and we
      include a given frame in the output stream only if it cannot be extended.

      ..src > scheme
        (define (negate operands frame-stream)
          (stream-flatmap
           (lambda (frame)
             (if (stream-null?
                  (qeval (negated-query operands)
                         (singleton-stream frame)))
                 (singleton-stream frame)
                 the-empty-stream))
           frame-stream))
        (put 'not 'qeval negate)
      < src..

      @c(Lisp-value) is a filter similar to @c(not). Each frame in the stream is
      used to instantiate the variables in the pattern, the indicated predicate is
      applied, and the frames for which the predicate returns false are filtered out
      of the input stream. An error results if there are unbound pattern variables.

      ..src > scheme
        (define (lisp-value call frame-stream)
          (stream-flatmap
           (lambda (frame)
             (if (execute
                  (instantiate
                   call
                   frame
                   (lambda (v f)
                     (error
                      "Unknown pat var: LISP-VALUE"
                      v))))
                 (singleton-stream frame)
                 the-empty-stream))
           frame-stream))
        (put 'lisp-value 'qeval lisp-value)
      < src..

      @c(Execute), which applies the predicate to the arguments, must @c(eval) the
      predicate expression to get the procedure to apply. However, it must not
      evaluate the arguments, since they are already the actual arguments, not
      expressions whose evaluation (in Lisp) will produce the arguments. Note that
      @c(execute) is implemented using @c(eval) and @c(apply) from the underlying
      Lisp system.

      ..src > scheme
        (define (execute exp)
          (apply (eval (predicate exp)
                       user-initial-environment)
                 (args exp)))
      < src..

      The @c(always-true) special form provides for a query that is always
      satisfied. It ignores its contents (normally empty) and simply passes through
      all the frames in the input stream. @c(Always-true) is used by the
      @c(rule-body) selector (@l(#4.4.4.7)) to provide bodies for rules that were
      defined without bodies (that is, rules whose conclusions are always
      satisfied).

      ..src > scheme
        (define (always-true ignore frame-stream)
          frame-stream)
        (put 'always-true 'qeval always-true)
      < src..

      The selectors that define the syntax of @c(not) and @c(lisp-value) are given
      in @l(#4.4.4.7).

**** 4.4.4.3 <> Finding Assertions by Pattern Matching

     @c(Find-assertions), called by @c(simple-query) (@l(#4.4.4.2)), takes as input
     a pattern and a frame. It returns a stream of frames, each extending the given
     one by a data-base match of the given pattern. It uses @c(fetch-assertions)
     (@l(#4.4.4.5)) to get a stream of all the assertions in the data base that
     should be checked for a match against the pattern and the frame. The reason
     for @c(fetch-assertions) here is that we can often apply simple tests that
     will eliminate many of the entries in the data base from the pool of
     candidates for a successful match. The system would still work if we
     eliminated @c(fetch-assertions) and simply checked a stream of all assertions
     in the data base, but the computation would be less efficient because we would
     need to make many more calls to the matcher.

     ..src > scheme
       (define (find-assertions pattern frame)
         (stream-flatmap
           (lambda (datum)
             (check-an-assertion datum pattern frame))
           (fetch-assertions pattern frame)))
     < src..

     @c(Check-an-assertion) takes as arguments a pattern, a data object
     (assertion), and a frame and returns either a one-element stream containing
     the extended frame or @c(the-empty-stream) if the match fails.

     ..src > scheme
       (define (check-an-assertion
                assertion query-pat query-frame)
         (let ((match-result
                (pattern-match
                 query-pat assertion query-frame)))
           (if (eq? match-result 'failed)
               the-empty-stream
               (singleton-stream match-result))))
     < src..

     The basic pattern matcher returns either the symbol @c(failed) or an extension
     of the given frame. The basic idea of the matcher is to check the pattern
     against the data, element by element, accumulating bindings for the pattern
     variables. If the pattern and the data object are the same, the match succeeds
     and we return the frame of bindings accumulated so far. Otherwise, if the
     pattern is a variable we extend the current frame by binding the variable to
     the data, so long as this is consistent with the bindings already in the
     frame. If the pattern and the data are both pairs, we (recursively) match the
     @c(car) of the pattern against the @c(car) of the data to produce a frame; in
     this frame we then match the @c(cdr) of the pattern against the @c(cdr) of the
     data. If none of these cases are applicable, the match fails and we return the
     symbol @c(failed).

     ..src > scheme
       (define (pattern-match pat dat frame)
         (cond ((eq? frame 'failed) 'failed)
               ((equal? pat dat) frame)
               ((var? pat)
                (extend-if-consistent
                 pat dat frame))
               ((and (pair? pat) (pair? dat))
                (pattern-match
                 (cdr pat)
                 (cdr dat)
                 (pattern-match
                  (car pat) (car dat) frame)))
               (else 'failed)))
     < src..

     Here is the procedure that extends a frame by adding a new binding, if this is
     consistent with the bindings already in the frame:

     ..src > scheme
       (define (extend-if-consistent var dat frame)
         (let ((binding (binding-in-frame var frame)))
           (if binding
               (pattern-match
                (binding-value binding) dat frame)
               (extend var dat frame))))
     < src..

     If there is no binding for the variable in the frame, we simply add the
     binding of the variable to the data. Otherwise we match, in the frame, the
     data against the value of the variable in the frame. If the stored value
     contains only constants, as it must if it was stored during pattern matching
     by @c(extend-if-consistent), then the match simply tests whether the stored
     and new values are the same. If so, it returns the unmodified frame; if not,
     it returns a failure indication. The stored value may, however, contain
     pattern variables if it was stored during unification (see @l(#4.4.4.4)). The
     recursive match of the stored pattern against the new data will add or check
     bindings for the variables in this pattern. For example, suppose we have a
     frame in which @c(?x) is bound to @c[(f ?y)] and @c(?y) is unbound, and we
     wish to augment this frame by a binding of @c(?x) to @c[(f b)].  We look up
     @c(?x) and find that it is bound to @c[(f ?y)]. This leads us to match @c[(f
     ?y)] against the proposed new value @c[(f b)] in the same frame. Eventually
     this match extends the frame by adding a binding of @c(?y) to @c(b). @c(?X)
     remains bound to @c[(f ?y)]. We never modify a stored binding and we never
     store more than one binding for a given variable.

     The procedures used by @c(extend-if-consistent) to manipulate bindings are
     defined in @l(#4.4.4.8).

***** Patterns with dotted tails

      If a pattern contains a dot followed by a pattern variable, the pattern
      variable matches the rest of the data list (rather than the next element of
      the data list), just as one would expect with the dotted-tail notation
      described in @l(#Exercise 2.20). Although the pattern matcher we have just
      implemented doesn't look for dots, it does behave as we want. This is because
      the Lisp @c(read) primitive, which is used by @c(query-driver-loop) to read
      the query and represent it as a list structure, treats dots in a special way.

      When @c(read) sees a dot, instead of making the next item be the next element
      of a list (the @c(car) of a @c(cons) whose @c(cdr) will be the rest of the
      list) it makes the next item be the @c(cdr) of the list structure. For
      example, the list structure produced by @c(read) for the pattern @c[(computer
      ?type)] could be constructed by evaluating the expression @c[(cons 'computer
      (cons '?type '()))], and that for @c[(computer . ?type)] could be constructed
      by evaluating the expression @c[(cons 'computer '?type)].

      Thus, as @c(pattern-match) recursively compares @c(car)s and @c(cdr)s of a
      data list and a pattern that had a dot, it eventually matches the variable
      after the dot (which is a @c(cdr) of the pattern) against a sublist of the
      data list, binding the variable to that list. For example, matching the
      pattern @c[(computer . ?type)] against @c[(computer programmer trainee)] will
      match @c(?type) against the list @c[(programmer trainee)].

**** 4.4.4.4 <> Rules and Unification

     @c(Apply-rules) is the rule analog of @c(find-assertions) (@l(#4.4.4.3)). It
     takes as input a pattern and a frame, and it forms a stream of extension
     frames by applying rules from the data base.  @c(Stream-flatmap) maps
     @c(apply-a-rule) down the stream of possibly applicable rules (selected by
     @c(fetch-rules), @l(#4.4.4.5)) and combines the resulting streams of frames.

     ..src > scheme
       (define (apply-rules pattern frame)
         (stream-flatmap
          (lambda (rule)
            (apply-a-rule rule pattern frame))
          (fetch-rules pattern frame)))
     < src..

     @c(Apply-a-rule) applies rules using the method outlined in @l(#4.4.2). It
     first augments its argument frame by unifying the rule conclusion with the
     pattern in the given frame. If this succeeds, it evaluates the rule body in
     this new frame.

     Before any of this happens, however, the program renames all the variables in
     the rule with unique new names. The reason for this is to prevent the
     variables for different rule applications from becoming confused with each
     other. For instance, if two rules both use a variable named @c(?x), then each
     one may add a binding for @c(?x) to the frame when it is applied.  These two
     @c(?x)'s have nothing to do with each other, and we should not be fooled into
     thinking that the two bindings must be consistent. Rather than rename
     variables, we could devise a more clever environment structure; however, the
     renaming approach we have chosen here is the most straightforward, even if not
     the most efficient. (See @l(#Exercise 4.79).)  Here is the @c(apply-a-rule)
     procedure:

     ..src > scheme
       (define (apply-a-rule rule
                             query-pattern
                             query-frame)
         (let ((clean-rule
                (rename-variables-in rule)))
           (let ((unify-result
                  (unify-match query-pattern
                               (conclusion clean-rule)
                               query-frame)))
             (if (eq? unify-result 'failed)
                 the-empty-stream
                 (qeval (rule-body clean-rule)
                        (singleton-stream
                         unify-result))))))
     < src..

     The selectors @c(rule-body) and @c(conclusion) that extract parts of a rule
     are defined in @l(#4.4.4.7).

     We generate unique variable names by associating a unique identifier (such as
     a number) with each rule application and combining this identifier with the
     original variable names. For example, if the rule-application identifier is 7,
     we might change each @c(?x) in the rule to @c(?x-7) and each @c(?y) in the
     rule to @c(?y-7). (@c(Make-new-variable) and @c(new-rule-application-id) are
     included with the syntax procedures in @l(#4.4.4.7).)

     ..src > scheme
       (define (rename-variables-in rule)
         (let ((rule-application-id
                (new-rule-application-id)))
           (define (tree-walk exp)
             (cond ((var? exp)
                    (make-new-variable
                     exp
                     rule-application-id))
                   ((pair? exp)
                    (cons (tree-walk (car exp))
                          (tree-walk (cdr exp))))
                   (else exp)))
           (tree-walk rule)))
     < src..

     The unification algorithm is implemented as a procedure that takes as inputs
     two patterns and a frame and returns either the extended frame or the symbol
     @c(failed). The unifier is like the pattern matcher except that it is
     symmetrical––variables are allowed on both sides of the match.
     @c(Unify-match) is basically the same as @c(pattern-match), except that there
     is extra code (marked @"(@c(***)) below) to handle the case where the object
     on the right side of the match is a variable.

     ..src > scheme
       (define (unify-match p1 p2 frame)
         (cond ((eq? frame 'failed) 'failed)
               ((equal? p1 p2) frame)
               ((var? p1)
                (extend-if-possible p1 p2 frame))
               ((var? p2)
                (extend-if-possible
                 p2
                 p1
                 frame))        ; ***
               ((and (pair? p1)
                     (pair? p2))
                (unify-match
                 (cdr p1)
                 (cdr p2)
                 (unify-match
                  (car p1)
                  (car p2)
                  frame)))
               (else 'failed)))
     < src..

     In unification, as in one-sided pattern matching, we want to accept a proposed
     extension of the frame only if it is consistent with existing bindings. The
     procedure @c(extend-if-possible) used in unification is the same as the
     @c(extend-if-consistent) used in pattern matching except for two special
     checks, marked @"(@c(***)) in the program below. In the first case, if the
     variable we are trying to match is not bound, but the value we are trying to
     match it with is itself a (different) variable, it is necessary to check to
     see if the value is bound, and if so, to match its value. If both parties to
     the match are unbound, we may bind either to the other.

     The second check deals with attempts to bind a variable to a pattern that
     includes that variable. Such a situation can occur whenever a variable is
     repeated in both patterns. Consider, for example, unifying the two patterns
     @c[(?x ?x)] and @c[(?y ⟨expression involving @c(?y)⟩)] in a frame where both
     @c(?x) and @c(?y) are unbound. First @c(?x) is matched against @c(?y), making
     a binding of @c(?x) to @c(?y). Next, the same @c(?x) is matched against the
     given expression involving @c(?y).  Since @c(?x) is already bound to @c(?y),
     this results in matching @c(?y) against the expression. If we think of the
     unifier as finding a set of values for the pattern variables that make the
     patterns the same, then these patterns imply instructions to find a @c(?y)
     such that @c(?y) is equal to the expression involving @c(?y). There is no
     general method for solving such equations, so we reject such bindings; these
     cases are recognized by the predicate @c(depends-on?).@n(284) On the other
     hand, we do not want to reject attempts to bind a variable to itself.  For
     example, consider unifying @c[(?x ?x)] and @c[(?y ?y)]. The second attempt to
     bind @c(?x) to @c(?y) matches @c(?y) (the stored value of @c(?x)) against
     @c(?y) (the new value of @c(?x)). This is taken care of by the @c(equal?)
     clause of @c(unify-match).

     ..src > scheme
       (define (extend-if-possible var val frame)
         (let ((binding (binding-in-frame var frame)))
           (cond (binding
                  (unify-match
                   (binding-value binding) val frame))
                 ((var? val)                   ; ***
                  (let ((binding
                         (binding-in-frame
                          val
                          frame)))
                    (if binding
                        (unify-match
                         var
                         (binding-value binding)
                         frame)
                        (extend var val frame))))
                 ((depends-on? val var frame)  ; ***
                  'failed)
                 (else (extend var val frame)))))
     < src..

     @c(Depends-on?) is a predicate that tests whether an expression proposed to be
     the value of a pattern variable depends on the variable. This must be done
     relative to the current frame because the expression may contain occurrences
     of a variable that already has a value that depends on our test variable. The
     structure of @c(depends-on?) is a simple recursive tree walk in which we
     substitute for the values of variables whenever necessary.

     ..src > scheme
       (define (depends-on? exp var frame)
         (define (tree-walk e)
           (cond ((var? e)
                  (if (equal? var e)
                      true
                      (let
                        ((b (binding-in-frame
                             e
                             frame)))
                         (if b
                             (tree-walk
                              (binding-value b))
                             false))))
                 ((pair? e)
                  (or (tree-walk (car e))
                      (tree-walk (cdr e))))
                 (else false)))
         (tree-walk exp))
     < src..

**** 4.4.4.5 <> Maintaining the Data Base

     One important problem in designing logic programming languages is that of
     arranging things so that as few irrelevant data-base entries as possible will
     be examined in checking a given pattern. In our system, in addition to storing
     all assertions in one big stream, we store all assertions whose @c(car)s are
     constant symbols in separate streams, in a table indexed by the symbol. To
     fetch an assertion that may match a pattern, we first check to see if the
     @c(car) of the pattern is a constant symbol. If so, we return (to be tested
     using the matcher) all the stored assertions that have the same @c(car). If
     the pattern's @c(car) is not a constant symbol, we return all the stored
     assertions. Cleverer methods could also take advantage of information in the
     frame, or try also to optimize the case where the @c(car) of the pattern is
     not a constant symbol. We avoid building our criteria for indexing (using the
     @c(car), handling only the case of constant symbols) into the program; instead
     we call on predicates and selectors that embody our criteria.

     ..src > scheme
       (define THE-ASSERTIONS the-empty-stream)

       (define (fetch-assertions pattern frame)
         (if (use-index? pattern)
             (get-indexed-assertions pattern)
             (get-all-assertions)))

       (define (get-all-assertions) THE-ASSERTIONS)

       (define (get-indexed-assertions pattern)
         (get-stream (index-key-of pattern)
                     'assertion-stream))
     < src..

     @c(Get-stream) looks up a stream in the table and returns an empty stream if
     nothing is stored there.

     ..src > scheme
       (define (get-stream key1 key2)
         (let ((s (get key1 key2)))
           (if s s the-empty-stream)))
     < src..

     Rules are stored similarly, using the @c(car) of the rule conclusion. Rule
     conclusions are arbitrary patterns, however, so they differ from assertions in
     that they can contain variables. A pattern whose @c(car) is a constant symbol
     can match rules whose conclusions start with a variable as well as rules whose
     conclusions have the same @c(car). Thus, when fetching rules that might match
     a pattern whose @c(car) is a constant symbol we fetch all rules whose
     conclusions start with a variable as well as those whose conclusions have the
     same @c(car) as the pattern. For this purpose we store all rules whose
     conclusions start with a variable in a separate stream in our table, indexed
     by the symbol @c(?).

     ..src > scheme
       (define THE-RULES the-empty-stream)

       (define (fetch-rules pattern frame)
         (if (use-index? pattern)
             (get-indexed-rules pattern)
             (get-all-rules)))

       (define (get-all-rules) THE-RULES)

       (define (get-indexed-rules pattern)
         (stream-append
          (get-stream (index-key-of pattern)
                      'rule-stream)
          (get-stream '? 'rule-stream)))
     < src..

     @c(Add-rule-or-assertion!) is used by @c(query-driver-loop) to add assertions
     and rules to the data base. Each item is stored in the index, if appropriate,
     and in a stream of all assertions or rules in the data base.

     ..src > scheme
       (define (add-rule-or-assertion! assertion)
         (if (rule? assertion)
             (add-rule! assertion)
             (add-assertion! assertion)))

       (define (add-assertion! assertion)
         (store-assertion-in-index assertion)
         (let ((old-assertions THE-ASSERTIONS))
           (set! THE-ASSERTIONS
                 (cons-stream assertion
                              old-assertions))
           'ok))

       (define (add-rule! rule)
         (store-rule-in-index rule)
         (let ((old-rules THE-RULES))
           (set! THE-RULES
                 (cons-stream rule old-rules))
           'ok))
     < src..

     To actually store an assertion or a rule, we check to see if it can be
     indexed.  If so, we store it in the appropriate stream.

     ..src > scheme
       (define (store-assertion-in-index assertion)
         (if (indexable? assertion)
             (let ((key (index-key-of assertion)))
               (let ((current-assertion-stream
                      (get-stream
                       key 'assertion-stream)))
                 (put key
                      'assertion-stream
                      (cons-stream
                       assertion
                       current-assertion-stream))))))

       (define (store-rule-in-index rule)
         (let ((pattern (conclusion rule)))
           (if (indexable? pattern)
               (let ((key (index-key-of pattern)))
                 (let ((current-rule-stream
                        (get-stream
                         key 'rule-stream)))
                   (put key
                        'rule-stream
                        (cons-stream
                         rule
                         current-rule-stream)))))))
     < src..

     The following procedures define how the data-base index is used. A pattern (an
     assertion or a rule conclusion) will be stored in the table if it starts with
     a variable or a constant symbol.

     ..src > scheme
       (define (indexable? pat)
         (or (constant-symbol? (car pat))
             (var? (car pat))))
     < src..

     The key under which a pattern is stored in the table is either @c(?) (if it
     starts with a variable) or the constant symbol with which it starts.

     ..src > scheme
       (define (index-key-of pat)
         (let ((key (car pat)))
           (if (var? key) '? key)))
     < src..

     The index will be used to retrieve items that might match a pattern if the
     pattern starts with a constant symbol.

     ..src > scheme
       (define (use-index? pat)
         (constant-symbol? (car pat)))
     < src..

     :: @t(Exercise 4.70) :: What is the purpose of the @c(let) bindings in the
        procedures @c(add-assertion!) and @c(add-rule!)?  What would be wrong with
        the following implementation of @c(add-assertion!)?  Hint: Recall the
        definition of the infinite stream of ones in @l(#3.5.2): @c[(define ones
        (cons-stream 1 ones))].

        ..src > scheme
          (define (add-assertion! assertion)
            (store-assertion-in-index assertion)
            (set! THE-ASSERTIONS
                  (cons-stream assertion
                               THE-ASSERTIONS))
            'ok)
        < src..

**** 4.4.4.6 <> Stream Operations

     The query system uses a few stream operations that were not presented in
     @l(#Chapter 3).

     @c(Stream-append-delayed) and @c(interleave-delayed) are just like
     @c(stream-append) and @c(interleave) (@l(#3.5.3)), except that they take a
     delayed argument (like the @c(integral) procedure in @l(#3.5.4)). This
     postpones looping in some cases (see @l(#Exercise 4.71)).

     ..src > scheme
       (define (stream-append-delayed s1 delayed-s2)
         (if (stream-null? s1)
             (force delayed-s2)
             (cons-stream
              (stream-car s1)
              (stream-append-delayed (stream-cdr s1)
                                     delayed-s2))))

       (define (interleave-delayed s1 delayed-s2)
         (if (stream-null? s1)
             (force delayed-s2)
             (cons-stream
              (stream-car s1)
              (interleave-delayed
               (force delayed-s2)
               (delay (stream-cdr s1))))))
     < src..

     @c(Stream-flatmap), which is used throughout the query evaluator to map a
     procedure over a stream of frames and combine the resulting streams of frames,
     is the stream analog of the @c(flatmap) procedure introduced for ordinary
     lists in @l(#2.2.3). Unlike ordinary @c(flatmap), however, we accumulate the
     streams with an interleaving process, rather than simply appending them (see
     @l(#Exercise 4.72) and @l(#Exercise 4.73)).

     ..src > scheme
       (define (stream-flatmap proc s)
         (flatten-stream (stream-map proc s)))

       (define (flatten-stream stream)
         (if (stream-null? stream)
             the-empty-stream
             (interleave-delayed
              (stream-car stream)
              (delay (flatten-stream
                      (stream-cdr stream))))))
     < src..

     The evaluator also uses the following simple procedure to generate a stream
     consisting of a single element:

     ..src > scheme
       (define (singleton-stream x)
         (cons-stream x the-empty-stream))
     < src..

**** 4.4.4.7 <> Query Syntax Procedures

     @c(Type) and @c(contents), used by @c(qeval) (@l(#4.4.4.2)), specify that a
     special form is identified by the symbol in its @c(car).  They are the same as
     the @c(type-tag) and @c(contents) procedures in @l(#2.4.2), except for the
     error message.

     ..src > scheme
       (define (type exp)
         (if (pair? exp)
             (car exp)
             (error "Unknown expression TYPE"
                    exp)))

       (define (contents exp)
         (if (pair? exp)
             (cdr exp)
             (error "Unknown expression CONTENTS"
                    exp)))
     < src..

     The following procedures, used by @c(query-driver-loop) (in @l(#4.4.4.1)),
     specify that rules and assertions are added to the data base by expressions of
     the form @c[(assert! ⟨rule-or-assertion⟩)]:

     ..src > scheme
       (define (assertion-to-be-added? exp)
         (eq? (type exp) 'assert!))

       (define (add-assertion-body exp)
         (car (contents exp)))
     < src..

     Here are the syntax definitions for the @c(and), @c(or), @c(not), and
     @c(lisp-value) special forms (@l(#4.4.4.2)):

     ..src > scheme
       (define (empty-conjunction? exps) (null? exps))
       (define (first-conjunct exps) (car exps))
       (define (rest-conjuncts exps) (cdr exps))
       (define (empty-disjunction? exps) (null? exps))
       (define (first-disjunct exps) (car exps))
       (define (rest-disjuncts exps) (cdr exps))
       (define (negated-query exps) (car exps))
       (define (predicate exps) (car exps))
       (define (args exps) (cdr exps))
     < src..

     The following three procedures define the syntax of rules:

     ..src > scheme
       (define (rule? statement)
         (tagged-list? statement 'rule))

       (define (conclusion rule) (cadr rule))

       (define (rule-body rule)
         (if (null? (cddr rule))
             '(always-true)
             (caddr rule)))
     < src..

     @c(Query-driver-loop) (@l(#4.4.4.1)) calls @c(query-syntax-process) to
     transform pattern variables in the expression, which have the form
     @c(?symbol), into the internal format @c[(? symbol)].  That is to say, a
     pattern such as @c[(job ?x ?y)] is actually represented internally by the
     system as @c[(job (? x) (? y))]. This increases the efficiency of query
     processing, since it means that the system can check to see if an expression
     is a pattern variable by checking whether the @c(car) of the expression is the
     symbol @c(?), rather than having to extract characters from the symbol. The
     syntax transformation is accomplished by the following procedure:@n(285)

     ..src > scheme
       (define (query-syntax-process exp)
         (map-over-symbols expand-question-mark exp))

       (define (map-over-symbols proc exp)
         (cond ((pair? exp)
                (cons (map-over-symbols
                       proc (car exp))
                      (map-over-symbols
                       proc (cdr exp))))
               ((symbol? exp) (proc exp))
               (else exp)))

       (define (expand-question-mark symbol)
         (let ((chars (symbol->string symbol)))
           (if (string=? (substring chars 0 1) "?")
               (list '? (string->symbol
                         (substring
                          chars
                          1
                          (string-length chars))))
               symbol)))
     < src..

     Once the variables are transformed in this way, the variables in a pattern are
     lists starting with @c(?), and the constant symbols (which need to be
     recognized for data-base indexing, @l(#4.4.4.5)) are just the symbols.

     ..src > scheme
       (define (var? exp) (tagged-list? exp '?))
       (define (constant-symbol? exp) (symbol? exp))
     < src..

     Unique variables are constructed during rule application (in @l(#4.4.4.4)) by
     means of the following procedures. The unique identifier for a rule
     application is a number, which is incremented each time a rule is applied.

     ..src > scheme
       (define rule-counter 0)

       (define (new-rule-application-id)
         (set! rule-counter (+ 1 rule-counter))
         rule-counter)

       (define (make-new-variable
                var rule-application-id)
         (cons '? (cons rule-application-id
                        (cdr var))))
     < src..

     When @c(query-driver-loop) instantiates the query to print the answer, it
     converts any unbound pattern variables back to the right form for printing,
     using

     ..src > scheme
       (define (contract-question-mark variable)
         (string->symbol
          (string-append "?"
            (if (number? (cadr variable))
                (string-append
                 (symbol->string (caddr variable))
                 "-"
                 (number->string (cadr variable)))
                (symbol->string (cadr variable))))))
     < src..

**** 4.4.4.8 <> Frames and Bindings

     Frames are represented as lists of bindings, which are variable-value pairs:

     ..src > scheme
       (define (make-binding variable value)
         (cons variable value))

       (define (binding-variable binding)
         (car binding))

       (define (binding-value binding)
         (cdr binding))

       (define (binding-in-frame variable frame)
         (assoc variable frame))

       (define (extend variable value frame)
         (cons (make-binding variable value) frame))
     < src..

     :: @t(Exercise 4.71) :: Louis Reasoner wonders why the @c(simple-query) and
        @c(disjoin) procedures (@l(#4.4.4.2)) are implemented using explicit
        @c(delay) operations, rather than being defined as follows:

        ..src > scheme
          (define (simple-query
                   query-pattern frame-stream)
            (stream-flatmap
             (lambda (frame)
               (stream-append
                (find-assertions query-pattern frame)
                (apply-rules query-pattern frame)))
             frame-stream))

          (define (disjoin disjuncts frame-stream)
            (if (empty-disjunction? disjuncts)
                the-empty-stream
                (interleave
                 (qeval (first-disjunct disjuncts)
                        frame-stream)
                 (disjoin (rest-disjuncts disjuncts)
                          frame-stream))))
        < src..

        Can you give examples of queries where these simpler definitions would lead
        to undesirable behavior?

     :: @t(Exercise 4.72) :: Why do @c(disjoin) and @c(stream-flatmap) interleave
        the streams rather than simply append them?  Give examples that illustrate
        why interleaving works better. (Hint: Why did we use @c(interleave) in
        @l(#3.5.3)?)

     :: @t(Exercise 4.73) :: Why does @c(flatten-stream) use @c(delay) explicitly?
        What would be wrong with defining it as follows:

        ..src > scheme
          (define (flatten-stream stream)
            (if (stream-null? stream)
                the-empty-stream
                (interleave (stream-car stream)
                            (flatten-stream
                             (stream-cdr stream)))))
        < src..

     :: @t(Exercise 4.74) :: Alyssa P. Hacker proposes to use a simpler version of
        @c(stream-flatmap) in @c(negate), @c(lisp-value), and
        @c(find-assertions). She observes that the procedure that is mapped over
        the frame stream in these cases always produces either the empty stream or
        a singleton stream, so no interleaving is needed when combining these
        streams.

        1. Fill in the missing expressions in Alyssa's program.

           ..src > scheme
             (define (simple-stream-flatmap proc s)
               (simple-flatten (stream-map proc s)))

             (define (simple-flatten stream)
               (stream-map ⟨??⟩
                           (stream-filter ⟨??⟩
                                          stream)))
           < src..

        2. Does the query system's behavior change if we change it in this way?

     :: @t(Exercise 4.75) :: Implement for the query language a new special form
        called @c(unique). @c(Unique) should succeed if there is precisely one item
        in the data base satisfying a specified query. For example,

        ..src > scheme
          (unique (job ?x (computer wizard)))
        < src..

        should print the one-item stream

        ..src > scheme
          (unique (job (Bitdiddle Ben)
                       (computer wizard)))
        < src..

        since Ben is the only computer wizard, and

        ..src > scheme
          (unique (job ?x (computer programmer)))
        < src..

        should print the empty stream, since there is more than one computer
        programmer. Moreover,

        ..src > scheme
          (and (job ?x ?j)
               (unique (job ?anyone ?j)))
        < src..

        should list all the jobs that are filled by only one person, and the people
        who fill them.

        There are two parts to implementing @c(unique). The first is to write a
        procedure that handles this special form, and the second is to make
        @c(qeval) dispatch to that procedure. The second part is trivial, since
        @c(qeval) does its dispatching in a data-directed way. If your procedure is
        called @c(uniquely-asserted), all you need to do is

        ..src > scheme
          (put 'unique 'qeval uniquely-asserted)
        < src..

        and @c(qeval) will dispatch to this procedure for every query whose
        @c(type) (@c(car)) is the symbol @c(unique).

        The real problem is to write the procedure @c(uniquely-asserted). This
        should take as input the @c(contents) (@c(cdr)) of the @c(unique) query,
        together with a stream of frames. For each frame in the stream, it should
        use @c(qeval) to find the stream of all extensions to the frame that
        satisfy the given query. Any stream that does not have exactly one item in
        it should be eliminated. The remaining streams should be passed back to be
        accumulated into one big stream that is the result of the @c(unique) query.
        This is similar to the implementation of the @c(not) special form.

        Test your implementation by forming a query that lists all people who
        supervise precisely one person.

     :: @t(Exercise 4.76) :: Our implementation of @c(and) as a series combination
        of queries (@l(#Figure 4.5)) is elegant, but it is inefficient because in
        processing the second query of the @c(and) we must scan the data base for
        each frame produced by the first query. If the data base has @m(n)
        elements, and a typical query produces a number of output frames
        proportional to @m(n) (say @m(n / k)), then scanning the data base for each
        frame produced by the first query will require @m(n² / k) calls to the
        pattern matcher. Another approach would be to process the two clauses of
        the @c(and) separately, then look for all pairs of output frames that are
        compatible. If each query produces @m(n / k) output frames, then this means
        that we must perform @m(n² / k²) compatibility checks––a factor of @m(k)
        fewer than the number of matches required in our current method.

        Devise an implementation of @c(and) that uses this strategy. You must
        implement a procedure that takes two frames as inputs, checks whether the
        bindings in the frames are compatible, and, if so, produces a frame that
        merges the two sets of bindings. This operation is similar to unification.

     :: @t(Exercise 4.77) :: In @l(#4.4.3) we saw that @c(not) and @c(lisp-value)
        can cause the query language to give @"(wrong) answers if these filtering
        operations are applied to frames in which variables are unbound. Devise a
        way to fix this shortcoming. One idea is to perform the filtering in a
        @"(delayed) manner by appending to the frame a @"(promise) to filter that
        is fulfilled only when enough variables have been bound to make the
        operation possible. We could wait to perform filtering until all other
        operations have been performed. However, for efficiency's sake, we would
        like to perform filtering as soon as possible so as to cut down on the
        number of intermediate frames generated.

     :: @t(Exercise 4.78) :: Redesign the query language as a nondeterministic
        program to be implemented using the evaluator of @l(#4.3), rather than as a
        stream process. In this approach, each query will produce a single answer
        (rather than the stream of all answers) and the user can type @c(try-again)
        to see more answers. You should find that much of the mechanism we built in
        this section is subsumed by nondeterministic search and backtracking. You
        will probably also find, however, that your new query language has subtle
        differences in behavior from the one implemented here. Can you find
        examples that illustrate this difference?

     :: @t(Exercise 4.79) :: When we implemented the Lisp evaluator in @l(#4.1), we
        saw how to use local environments to avoid name conflicts between the
        parameters of procedures. For example, in evaluating

        ..src > scheme
          (define (square x)
            (* x x))

          (define (sum-of-squares x y)
            (+ (square x) (square y)))

          (sum-of-squares 3 4)
        < src..

        there is no confusion between the @c(x) in @c(square) and the @c(x) in
        @c(sum-of-squares), because we evaluate the body of each procedure in an
        environment that is specially constructed to contain bindings for the local
        variables. In the query system, we used a different strategy to avoid name
        conflicts in applying rules. Each time we apply a rule we rename the
        variables with new names that are guaranteed to be unique. The analogous
        strategy for the Lisp evaluator would be to do away with local environments
        and simply rename the variables in the body of a procedure each time we
        apply the procedure.

        Implement for the query language a rule-application method that uses
        environments rather than renaming. See if you can build on your environment
        structure to create constructs in the query language for dealing with large
        systems, such as the rule analog of block-structured procedures. Can you
        relate any of this to the problem of making deductions in a context (e.g.,
        @"(If I supposed that @m(P) were true, then I would be able to deduce @m(a)
        and @m(B).)) as a method of problem solving?  (This problem is
        open-ended. A good answer is probably worth a Ph.D.)

* Chapter 5 <> Computing with Register Machines

  ..quote >
    My aim is to show that the heavenly machine is not a kind of divine, live
    being, but a kind of clockwork (and he who believes that a clock has soul
    attributes the maker's glory to the work), insofar as nearly all the
    manifold motions are caused by a most simple and material force, just as all
    motions of the clock are caused by a single weight.

    --Johannes Kepler (letter to Herwart von Hohenburg, 1605)
  < quote..


  We began this book by studying processes and by describing processes in terms
  of procedures written in Lisp. To explain the meanings of these procedures, we
  used a succession of models of evaluation: the substitution model of
  @l(#Chapter 1), the environment model of @l(#Chapter 3), and the metacircular
  evaluator of @l(#Chapter 4). Our examination of the metacircular evaluator, in
  particular, dispelled much of the mystery of how Lisp-like languages are
  interpreted. But even the metacircular evaluator leaves important questions
  unanswered, because it fails to elucidate the mechanisms of control in a Lisp
  system. For instance, the evaluator does not explain how the evaluation of a
  subexpression manages to return a value to the expression that uses this
  value, nor does the evaluator explain how some recursive procedures generate
  iterative processes (that is, are evaluated using constant space) whereas
  other recursive procedures generate recursive processes. These questions
  remain unanswered because the metacircular evaluator is itself a Lisp program
  and hence inherits the control structure of the underlying Lisp system. In
  order to provide a more complete description of the control structure of the
  Lisp evaluator, we must work at a more primitive level than Lisp itself.

  In this chapter we will describe processes in terms of the step-by-step
  operation of a traditional computer. Such a computer, or @e(register machine),
  sequentially executes @e(instructions) that manipulate the contents of a fixed
  set of storage elements called @e(registers). A typical register-machine
  instruction applies a primitive operation to the contents of some registers
  and assigns the result to another register. Our descriptions of processes
  executed by register machines will look very much like @"(machine-language)
  programs for traditional computers. However, instead of focusing on the
  machine language of any particular computer, we will examine several Lisp
  procedures and design a specific register machine to execute each
  procedure. Thus, we will approach our task from the perspective of a hardware
  architect rather than that of a machine-language computer programmer. In
  designing register machines, we will develop mechanisms for implementing
  important programming constructs such as recursion. We will also present a
  language for describing designs for register machines. In @l(#5.2) we will
  implement a Lisp program that uses these descriptions to simulate the machines
  we design.

  Most of the primitive operations of our register machines are very simple. For
  example, an operation might add the numbers fetched from two registers,
  producing a result to be stored into a third register. Such an operation can
  be performed by easily described hardware. In order to deal with list
  structure, however, we will also use the memory operations @c(car), @c(cdr),
  and @c(cons), which require an elaborate storage-allocation mechanism. In
  @l(#5.3) we study their implementation in terms of more elementary operations.

  In @l(#5.4), after we have accumulated experience formulating simple
  procedures as register machines, we will design a machine that carries out the
  algorithm described by the metacircular evaluator of @l(#4.1). This will fill
  in the gap in our understanding of how Scheme expressions are interpreted, by
  providing an explicit model for the mechanisms of control in the evaluator. In
  @l(#5.5) we will study a simple compiler that translates Scheme programs into
  sequences of instructions that can be executed directly with the registers and
  operations of the evaluator register machine.

** 5.1 <> Designing Register Machines

   To design a register machine, we must design its @e(data paths) (registers and
   operations) and the @e(controller) that sequences these operations. To
   illustrate the design of a simple register machine, let us examine Euclid's
   Algorithm, which is used to compute the greatest common divisor (@A(GCD)) of
   two integers. As we saw in @l(#1.2.5), Euclid's Algorithm can be carried out
   by an iterative process, as specified by the following procedure:

   ..src > scheme
     (define (gcd a b)
       (if (= b 0)
           a
           (gcd b (remainder a b))))
   < src..

   A machine to carry out this algorithm must keep track of two numbers, @m(a)
   and @m(b), so let us assume that these numbers are stored in two registers
   with those names. The basic operations required are testing whether the
   contents of register @c(b) is zero and computing the remainder of the contents
   of register @c(a) divided by the contents of register @c(b). The remainder
   operation is a complex process, but assume for the moment that we have a
   primitive device that computes remainders. On each cycle of the @A(GCD)
   algorithm, the contents of register @c(a) must be replaced by the contents of
   register @c(b), and the contents of @c(b) must be replaced by the remainder of
   the old contents of @c(a) divided by the old contents of @c(b). It would be
   convenient if these replacements could be done simultaneously, but in our
   model of register machines we will assume that only one register can be
   assigned a new value at each step. To accomplish the replacements, our machine
   will use a third @"(temporary) register, which we call @c(t). (First the
   remainder will be placed in @c(t), then the contents of @c(b) will be placed
   in @c(a), and finally the remainder stored in @c(t) will be placed in @c(b).)

   We can illustrate the registers and operations required for this machine by
   using the data-path diagram shown in @l(#Figure 5.1). In this diagram, the
   registers (@c(a), @c(b), and @c(t)) are represented by rectangles.  Each way
   to assign a value to a register is indicated by an arrow with an @c(X) behind
   the head, pointing from the source of data to the register. We can think of
   the @c(X) as a button that, when pushed, allows the value at the source to
   @"(flow) into the designated register. The label next to each button is the
   name we will use to refer to the button. The names are arbitrary, and can be
   chosen to have mnemonic value (for example, @c(a<-b) denotes pushing the
   button that assigns the contents of register @c(b) to register @c(a)). The
   source of data for a register can be another register (as in the @c(a<-b)
   assignment), an operation result (as in the @c(t<-r) assignment), or a
   constant (a built-in value that cannot be changed, represented in a data-path
   diagram by a triangle containing the constant).

   ..figure > @t(Figure 5.1) Data paths for a @A(GCD) machine.

     ..art >
                                     ___
       ╭─────╮          ╭─────╮     ╱   ╲
       │  a  │◀──(X)────│  b  ├───▶(  =  )
       ╰──┬──╯   a←b    ╰─┬───╯     ╲___╱
          │               │  ▲        ▲
          ╰──────╮   ╭────╯  │        │
                 ▼   ▼      (X) b←t   │
              .─────────.    │       ╱ ╲
               ╲  rem  ╱     │      ╱ O ╲
                ╲_____╱      │     '─────'
                   │         │
                  (X) t←r    │
                   │         │
                   ▼         │
                ╭─────╮      │
                │  t  +──────╯
                ╰─────╯
     < art..

@  ..img > img/chap5/Fig5.1a.std.svg

   An operation that computes a value from constants and the contents of
   registers is represented in a data-path diagram by a trapezoid containing a
   name for the operation. For example, the box marked @c(rem) in @l(#Figure 5.1)
   represents an operation that computes the remainder of the contents of the
   registers @c(a) and @c(b) to which it is attached. Arrows (without buttons)
   point from the input registers and constants to the box, and arrows connect
   the operation's output value to registers. A test is represented by a circle
   containing a name for the test. For example, our @A(GCD) machine has an
   operation that tests whether the contents of register @c(b) is zero.  A test
   also has arrows from its input registers and constants, but it has no output
   arrows; its value is used by the controller rather than by the data
   paths. Overall, the data-path diagram shows the registers and operations that
   are required for the machine and how they must be connected. If we view the
   arrows as wires and the @c(X) buttons as switches, the data-path diagram is
   very like the wiring diagram for a machine that could be constructed from
   electrical components.

   In order for the data paths to actually compute @A(GCD)s, the buttons must be
   pushed in the correct sequence. We will describe this sequence in terms of a
   controller diagram, as illustrated in @l(#Figure 5.2). The elements of the
   controller diagram indicate how the data-path components should be
   operated. The rectangular boxes in the controller diagram identify data-path
   buttons to be pushed, and the arrows describe the sequencing from one step to
   the next. The diamond in the diagram represents a decision. One of the two
   sequencing arrows will be followed, depending on the value of the data-path
   test identified in the diamond. We can interpret the controller in terms of a
   physical analogy: Think of the diagram as a maze in which a marble is
   rolling. When the marble rolls into a box, it pushes the data-path button that
   is named by the box. When the marble rolls into a decision node (such as the
   test for @c(b) = 0), it leaves the node on the path determined by the result
   of the indicated test. Taken together, the data paths and the controller
   completely describe a machine for computing @A(GCD)s. We start the controller
   (the rolling marble) at the place marked @c(start), after placing numbers in
   registers @c(a) and @c(b). When the controller reaches @c(done), we will find
   the value of the @A(GCD) in register @c(a).

   ..figure > @t(Figure 5.2) Controller for a @A(GCD) machine.

     ..art >
            start
              │
              ▼
             ╱ ╲  no   ╭─────╮
       ╭───▶( = )─────▶│ t←r │
       │     ╲ ╱       ╰──┬──╯
       │      │           │
       │      │ yes       ▼
       │      ▼        ╭─────╮
       │     done      │ a←b │
       │               ╰──┬──╯
       │                  │
       │                  ▼
       │               ╭─────╮
       ╰───────────────┤ b←t │
                       ╰─────╯
     < art..

@  ..img > img/chap5/Fig5.2.std.svg

   :: @t(Exercise 5.1) :: Design a register machine to compute factorials using
      the iterative algorithm specified by the following procedure. Draw
      data-path and controller diagrams for this machine.

      ..src > scheme
        (define (factorial n)
          (define (iter product counter)
            (if (> counter n)
                product
                (iter (* counter product)
                      (+ counter 1))))
          (iter 1 1))
      < src..

*** 5.1.1 <> A Language for Describing Register Machines

    Data-path and controller diagrams are adequate for representing simple
    machines such as @A(GCD), but they are unwieldy for describing large machines
    such as a Lisp interpreter. To make it possible to deal with complex machines,
    we will create a language that presents, in textual form, all the information
    given by the data-path and controller diagrams. We will start with a notation
    that directly mirrors the diagrams.

    We define the data paths of a machine by describing the registers and the
    operations. To describe a register, we give it a name and specify the buttons
    that control assignment to it. We give each of these buttons a name and
    specify the source of the data that enters the register under the button's
    control. (The source is a register, a constant, or an operation.)  To describe
    an operation, we give it a name and specify its inputs (registers or
    constants).

    We define the controller of a machine as a sequence of @e(instructions)
    together with @e(labels) that identify @e(entry points) in the sequence. An
    instruction is one of the following:

    - The name of a data-path button to push to assign a value to a
      register. (This corresponds to a box in the controller diagram.)

    - A @c(test) instruction, that performs a specified test.

    - A conditional branch (@c(branch) instruction) to a location indicated by a
      controller label, based on the result of the previous test. (The test and
      branch together correspond to a diamond in the controller diagram.)  If the
      test is false, the controller should continue with the next instruction in
      the sequence. Otherwise, the controller should continue with the instruction
      after the label.

    - An unconditional branch (@c(goto) instruction) naming a controller label at
      which to continue execution.


    The machine starts at the beginning of the controller instruction sequence and
    stops when execution reaches the end of the sequence. Except when a branch
    changes the flow of control, instructions are executed in the order in which
    they are listed.

    @l(#Figure 5.3) shows the @A(GCD) machine described in this way. This example
    only hints at the generality of these descriptions, since the @A(GCD) machine
    is a very simple case: Each register has only one button, and each button and
    test is used only once in the controller.

    ..figure > @t(Figure 5.3) A specification of the @A(GCD) machine.

      ..src > scheme
        (data-paths
         (registers
          ((name a)
           (buttons ((name a<-b)
                     (source (register b)))))
          ((name b)
           (buttons ((name b<-t)
                     (source (register t)))))
          ((name t)
           (buttons ((name t<-r)
                     (source (operation rem))))))
         (operations
          ((name rem)
           (inputs (register a) (register b)))
          ((name =)
           (inputs (register b) (constant 0)))))

        (controller
         test-b                ; label
           (test =)            ; test
           (branch
            (label gcd-done))  ; conditional branch
           (t<-r)              ; button push
           (a<-b)              ; button push
           (b<-t)              ; button push
           (goto
            (label test-b))    ; unconditional branch
         gcd-done)             ; label
      < src..


    Unfortunately, it is difficult to read such a description. In order to
    understand the controller instructions we must constantly refer back to the
    definitions of the button names and the operation names, and to understand
    what the buttons do we may have to refer to the definitions of the operation
    names.  We will thus transform our notation to combine the information from
    the data-path and controller descriptions so that we see it all together.

    To obtain this form of description, we will replace the arbitrary button and
    operation names by the definitions of their behavior. That is, instead of
    saying (in the controller) @"(Push button @c(t<-r)) and separately saying (in
    the data paths) @"(Button @c(t<-r) assigns the value of the @c(rem) operation
    to register @c(t)) and @"(The @c(rem) operation's inputs are the contents of
    registers @c(a) and @c(b),) we will say (in the controller) @"(Push the button
    that assigns to register @c(t) the value of the @c(rem) operation on the
    contents of registers @c(a) and @c(b).)  Similarly, instead of saying (in the
    controller) @"(Perform the @c(=) test) and separately saying (in the data
    paths) @"(The @c(=) test operates on the contents of register @c(b) and the
    constant 0,) we will say @"(Perform the @c(=) test on the contents of register
    @c(b) and the constant 0.)  We will omit the data-path description, leaving
    only the controller sequence.  Thus, the @A(GCD) machine is described as
    follows:

    ..src > scheme
      (controller
       test-b
         (test (op =) (reg b) (const 0))
         (branch (label gcd-done))
         (assign t (op rem) (reg a) (reg b))
         (assign a (reg b))
         (assign b (reg t))
         (goto (label test-b))
       gcd-done)
    < src..

    This form of description is easier to read than the kind illustrated in
    @l(#Figure 5.3), but it also has disadvantages:

    - It is more verbose for large machines, because complete descriptions of the
      data-path elements are repeated whenever the elements are mentioned in the
      controller instruction sequence. (This is not a problem in the @A(GCD)
      example, because each operation and button is used only once.)  Moreover,
      repeating the data-path descriptions obscures the actual data-path structure
      of the machine; it is not obvious for a large machine how many registers,
      operations, and buttons there are and how they are interconnected.

    - Because the controller instructions in a machine definition look like Lisp
      expressions, it is easy to forget that they are not arbitrary Lisp
      expressions.  They can notate only legal machine operations. For example,
      operations can operate directly only on constants and the contents of
      registers, not on the results of other operations.

    In spite of these disadvantages, we will use this register-machine language
    throughout this chapter, because we will be more concerned with understanding
    controllers than with understanding the elements and connections in data
    paths.  We should keep in mind, however, that data-path design is crucial in
    designing real machines.

    :: @t(Exercise 5.2) :: Use the register-machine language to describe the
       iterative factorial machine of @l(#Exercise 5.1).

**** Actions

     Let us modify the @A(GCD) machine so that we can type in the numbers whose
     @A(GCD) we want and get the answer printed at our terminal. We will not
     discuss how to make a machine that can read and print, but will assume (as we
     do when we use @c(read) and @c(display) in Scheme) that they are available as
     primitive operations.@n(286)

     @c(Read) is like the operations we have been using in that it produces a value
     that can be stored in a register. But @c(read) does not take inputs from any
     registers; its value depends on something that happens outside the parts of
     the machine we are designing. We will allow our machine's operations to have
     such behavior, and thus will draw and notate the use of @c(read) just as we do
     any other operation that computes a value.

     @c(Print), on the other hand, differs from the operations we have been using
     in a fundamental way: It does not produce an output value to be stored in a
     register. Though it has an effect, this effect is not on a part of the machine
     we are designing. We will refer to this kind of operation as an @e(action). We
     will represent an action in a data-path diagram just as we represent an
     operation that computes a value––as a trapezoid that contains the name of the
     action. Arrows point to the action box from any inputs (registers or
     constants). We also associate a button with the action. Pushing the button
     makes the action happen. To make a controller push an action button we use a
     new kind of instruction called @c(perform). Thus, the action of printing the
     contents of register @c(a) is represented in a controller sequence by the
     instruction

     ..src > scheme
       (perform (op print) (reg a))
     < src..

     @l(#Figure 5.4) shows the data paths and controller for the new @A(GCD)
     machine. Instead of having the machine stop after printing the answer, we have
     made it start over, so that it repeatedly reads a pair of numbers, computes
     their @A(GCD), and prints the result. This structure is like the driver loops
     we used in the interpreters of @l(#Chapter 4).

     ..figure > @t(Figure 5.4) A @A(GCD) machine that reads inputs and prints results.

       ..art >
                           .─────────.
                            ╲ read  ╱
                             ╲_____╱
                                │
                        ╭───────*──────╮
                        │              │
                  a←rd (X)            (X) b←rd
                        │              │
                        ▼              ▼           ___
                     ╭─────╮        ╭─────╮       ╱   ╲
                     │  a  │◀──(X)──┤  b  ├─────▶(  =  )
                     ╰─┬─┬─╯   a←b  ╰─┬───╯       ╲___╱
                       │ │            │  ▲          ▲
                    ╭──╯ ╰────╮    ╭──╯  │          │
                    │         │    │    (X) b←t    ╱ ╲
                    ▼         ▼    ▼     │        ╱ O ╲
               .─────────.  .─────────.  │       ╱_____╲
         ──(X)─▶╲ print ╱    ╲  rem  ╱   │
            P    ╲_____╱      ╲_____╱    │
                                 │       │
                                (X) t←r  │
                                 │       │
                                 ▼       │
                              ╭─────╮    │
                              │  t  ├────╯
                              ╰─────╯
       < art..

       ..src > scheme
          (controller
           gcd-loop
             (assign a (op read))
             (assign b (op read))
           test-b
             (test (op =) (reg b) (const 0))
             (branch (label gcd-done))
             (assign t (op rem) (reg a) (reg b))
             (assign a (reg b))
             (assign b (reg t))
             (goto (label test-b))
           gcd-done
             (perform (op print) (reg a))
             (goto (label gcd-loop)))
       < src..

*** 5.1.2 <> Abstraction in Machine Design

    We will often define a machine to include @"(primitive) operations that are
    actually very complex. For example, in @l(#5.4) and @l(#5.5) we will treat
    Scheme's environment manipulations as primitive. Such abstraction is valuable
    because it allows us to ignore the details of parts of a machine so that we
    can concentrate on other aspects of the design. The fact that we have swept a
    lot of complexity under the rug, however, does not mean that a machine design
    is unrealistic. We can always replace the complex @"(primitives) by simpler
    primitive operations.

    Consider the @A(GCD) machine. The machine has an instruction that computes the
    remainder of the contents of registers @c(a) and @c(b) and assigns the result
    to register @c(t). If we want to construct the @A(GCD) machine without using a
    primitive remainder operation, we must specify how to compute remainders in
    terms of simpler operations, such as subtraction. Indeed, we can write a
    Scheme procedure that finds remainders in this way:

    ..src > scheme
      (define (remainder n d)
        (if (< n d) n (remainder (- n d) d)))
    < src..

    We can thus replace the remainder operation in the @A(GCD) machine's data
    paths with a subtraction operation and a comparison test. @l(#Figure 5.5)
    shows the data paths and controller for the elaborated machine. The
    instruction

    ..src > scheme
      (assign t (op rem) (reg a) (reg b))
    < src..

    in the @A(GCD) controller definition is replaced by a sequence of instructions
    that contains a loop, as shown in @l(#Figure 5.6).

    ..figure > @t(Figure 5.5) Data paths and controller for the elaborated @A(GCD) machine.

      ..art >
                                            ___
        ╭─────╮         ╭─────╮            ╱   ╲
        │  a  │◀──(X)───┤  b  ├───────●──▶(  =  )
        ╰──┬──╯   a←b   ╰─┬───╯       │    ╲___╱
           │              │  ▲        │
          (X) t←a         │  │        │
           │              │ (X) b←t   │
           ▼              │  │       _▼_
        ╭─────╮           │  │      ╱   ╲
        │  t  ├───────●───┼──●─────(  <  )
        ╰─────╯       │   │         ╲___╱
           ▲          ▼   ▼
           │       .─────────.
          (X) t←d   ╲   −   ╱
           │         '──┬──'
           │            │
           ╰────────────╯


           start
             │
             ▼
            ╱ ╲ yes            ╭───────╮
        ╭─▶( = )────▶ done     │  t←d  │◀──╮
        │   ╲ ╱                ╰───┬───╯   │
        │    │ no                  │       │
        │    │                     ▼       │
        │    │   ╭───────╮        ╱ ╲ no   │
        │    ╰──▶│  t←a  ├──────▶( < )─────╯
        │        ╰───────╯        ╲ ╱
        │                          │ yes
        │      ╭───────────────────╯
        │      ▼
        │  ╭───────╮
        │  │  a←b  │
        │  ╰───┬───╯
        │      │
        │      ▼
        │  ╭───────╮
        ╰──┤  b←t  │
           ╰───────╯
      < art..

@   ..img > img/chap5/Fig5.5b.std.svg

    ..figure > @t(Figure 5.6) Controller instruction sequence for the @A(GCD)
      machine in @l(#Figure 5.5).

      ..src > scheme
        (controller
         test-b
           (test (op =) (reg b) (const 0))
           (branch (label gcd-done))
           (assign t (reg a))
         rem-loop
           (test (op <) (reg t) (reg b))
           (branch (label rem-done))
           (assign t (op -) (reg t) (reg b))
           (goto (label rem-loop))
         rem-done
           (assign a (reg b))
           (assign b (reg t))
           (goto (label test-b))
         gcd-done)
      < src..


    :: @t(Exercise 5.3) :: Design a machine to compute square roots using Newton's
       method, as described in @l(#Sec.1.1.7,,1.1.7):

       ..src > scheme
         (define (sqrt x)
           (define (good-enough? guess)
             (< (abs (- (square guess) x)) 0.001))
           (define (improve guess)
             (average guess (/ x guess)))
           (define (sqrt-iter guess)
             (if (good-enough? guess)
                 guess
                 (sqrt-iter (improve guess))))
           (sqrt-iter 1.0))
       < src..

      Begin by assuming that @c(good-enough?) and @c(improve) operations are
      available as primitives. Then show how to expand these in terms of
      arithmetic operations. Describe each version of the @c(sqrt) machine design
      by drawing a data-path diagram and writing a controller definition in the
      register-machine language.

*** 5.1.3 <> Subroutines

    When designing a machine to perform a computation, we would often prefer to
    arrange for components to be shared by different parts of the computation
    rather than duplicate the components. Consider a machine that includes two
    @A(GCD) computations––one that finds the @A(GCD) of the contents of registers
    @c(a) and @c(b) and one that finds the @A(GCD) of the contents of registers
    @c(c) and @c(d). We might start by assuming we have a primitive @c(gcd)
    operation, then expand the two instances of @c(gcd) in terms of more primitive
    operations. @l(#Figure 5.7) shows just the @A(GCD) portions of the resulting
    machine's data paths, without showing how they connect to the rest of the
    machine. The figure also shows the corresponding portions of the machine's
    controller sequence.

    ..figure > @t(Figure 5.7) Portions of the data paths and controller sequence
      for a machine with two @A(GCD) computations.

      ..cols >

        ..art >
                                       ___
          ╭─────╮        ╭─────╮      ╱   ╲
          │  a  │◀─(X)───┤  b  │────▶(  =  )
          ╰──┬──╯  a←b   ╰┬────╯      ╲___╱
             │            │   ▲         ▲
             ╰────╮   ╭───╯   │         │
                  ▼   ▼      (X) b←t    │
                .───────.     │        ╱ ╲
                 ╲ rem ╱      │       ╱ 0 ╲
                  ──┬──       │      '─────'
                    │         │
                   (X) t←r    │
                    │         │
                    V         │
                 ╭─────╮      │
                 │  t  ├──────╯
                 ╰─────╯
        < art..

        ::

        ..src > scheme
          gcd-1
           (test (op =) (reg b) (const 0))
           (branch (label after-gcd-1))
           (assign t (op rem) (reg a) (reg b))
           (assign a (reg b))
           (assign b (reg t))
           (goto (label gcd-1))
          after-gcd-1
        < src..

      ..cols >

        ..art >
                                       ___
          ╭─────╮        ╭─────╮      ╱   ╲
          │  c  │◀─(X)───┤  d  │────▶(  =  )
          ╰──┬──╯  c←d   ╰┬────╯      ╲___╱
             │            │   ▲         ▲
             ╰────╮   ╭───╯   │         │
                  ▼   ▼      (X) d←t    │
                .───────.     │        ╱ ╲
                 ╲ rem ╱      │       ╱ 0 ╲
                  ──┬──       │      '─────'
                    │         │
                   (X) s←r    │
                    │         │
                    V         │
                 ╭─────╮      │
                 │  s  ├──────╯
                 ╰─────╯
        < art..

        ::

        ..src > scheme
          gcd-2
           (test (op =) (reg d) (const 0))
           (branch (label after-gcd-2))
           (assign s (op rem) (reg c) (reg d))
           (assign c (reg d))
           (assign d (reg s))
           (goto (label gcd-2))
          after-gcd-2
        < src..

@   ..img > img/chap5/Fig5.7b.std.svg

    This machine has two remainder operation boxes and two boxes for testing
    equality. If the duplicated components are complicated, as is the remainder
    box, this will not be an economical way to build the machine. We can avoid
    duplicating the data-path components by using the same components for both
    @A(GCD) computations, provided that doing so will not affect the rest of the
    larger machine's computation. If the values in registers @c(a) and @c(b) are
    not needed by the time the controller gets to @c(gcd-2) (or if these values
    can be moved to other registers for safekeeping), we can change the machine so
    that it uses registers @c(a) and @c(b), rather than registers @c(c) and @c(d),
    in computing the second @A(GCD) as well as the first. If we do this, we obtain
    the controller sequence shown in @l(#Figure 5.8).

    ..figure > @t(Figure 5.8) Portions of the controller sequence for a machine
      that uses the same data-path components for two different @A(GCD)
      computations.

      ..src > scheme
        gcd-1
         (test (op =) (reg b) (const 0))
         (branch (label after-gcd-1))
         (assign t (op rem) (reg a) (reg b))
         (assign a (reg b))
         (assign b (reg t))
         (goto (label gcd-1))
        after-gcd-1
          …
        gcd-2
         (test (op =) (reg b) (const 0))
         (branch (label after-gcd-2))
         (assign t (op rem) (reg a) (reg b))
         (assign a (reg b))
         (assign b (reg t))
         (goto (label gcd-2))
        after-gcd-2
      < src..

    We have removed the duplicate data-path components (so that the data paths are
    again as in @l(#Figure 5.1)), but the controller now has two @A(GCD) sequences
    that differ only in their entry-point labels. It would be better to replace
    these two sequences by branches to a single sequence––a @c(gcd)
    @e(subroutine)––at the end of which we branch back to the correct place in the
    main instruction sequence. We can accomplish this as follows: Before branching
    to @c(gcd), we place a distinguishing value (such as 0 or 1) into a special
    register, @c(continue). At the end of the @c(gcd) subroutine we return either
    to @c(after-gcd-1) or to @c(after-gcd-2), depending on the value of the
    @c(continue) register. @l(#Figure 5.9) shows the relevant portion of the
    resulting controller sequence, which includes only a single copy of the
    @c(gcd) instructions.

    ..figure > @t(Figure 5.9) Using a @c(continue) register to avoid the duplicate
      controller sequence in @l(#Figure 5.8).

      ..src > scheme
        gcd
         (test (op =) (reg b) (const 0))
         (branch (label gcd-done))
         (assign t (op rem) (reg a) (reg b))
         (assign a (reg b))
         (assign b (reg t))
         (goto (label gcd))
        gcd-done
         (test (op =) (reg continue) (const 0))
         (branch (label after-gcd-1))
         (goto (label after-gcd-2))
          …
        ;; Before branching to gcd from
        ;; the first place where it is needed,
        ;; we place 0 in the continue register
         (assign continue (const 0))
         (goto (label gcd))
        after-gcd-1
          …
        ;; Before the second use of gcd,
        ;; we place 1 in the continue register
         (assign continue (const 1))
         (goto (label gcd))
        after-gcd-2
      < src..


    This is a reasonable approach for handling small problems, but it would be
    awkward if there were many instances of @A(GCD) computations in the controller
    sequence. To decide where to continue executing after the @c(gcd) subroutine,
    we would need tests in the data paths and branch instructions in the
    controller for all the places that use @c(gcd). A more powerful method for
    implementing subroutines is to have the @c(continue) register hold the label
    of the entry point in the controller sequence at which execution should
    continue when the subroutine is finished. Implementing this strategy requires
    a new kind of connection between the data paths and the controller of a
    register machine: There must be a way to assign to a register a label in the
    controller sequence in such a way that this value can be fetched from the
    register and used to continue execution at the designated entry point.

    To reflect this ability, we will extend the @c(assign) instruction of the
    register-machine language to allow a register to be assigned as value a label
    from the controller sequence (as a special kind of constant). We will also
    extend the @c(goto) instruction to allow execution to continue at the entry
    point described by the contents of a register rather than only at an entry
    point described by a constant label. Using these new constructs we can
    terminate the @c(gcd) subroutine with a branch to the location stored in the
    @c(continue) register. This leads to the controller sequence shown in
    @l(#Figure 5.10).

    ..figure > @t(Figure 5.10) Assigning labels to the @c(continue) register
      simplifies and generalizes the strategy shown in @l(#Figure 5.9).

      ..src > scheme
        gcd
         (test (op =) (reg b) (const 0))
         (branch (label gcd-done))
         (assign t (op rem) (reg a) (reg b))
         (assign a (reg b))
         (assign b (reg t))
         (goto (label gcd))
        gcd-done
         (goto (reg continue))
          …
        ;; Before calling gcd,
        ;; we assign to continue the label
        ;; to which gcd should return.
         (assign continue (label after-gcd-1))
         (goto (label gcd))
        after-gcd-1
          …
        ;; Here is the second call to gcd,
        ;; with a different continuation.
         (assign continue (label after-gcd-2))
         (goto (label gcd))
        after-gcd-2
      < src..

    A machine with more than one subroutine could use multiple continuation
    registers (e.g., @c(gcd-continue), @c(factorial-continue)) or we could have
    all subroutines share a single @c(continue) register. Sharing is more
    economical, but we must be careful if we have a subroutine (@c(sub1)) that
    calls another subroutine (@c(sub2)). Unless @c(sub1) saves the contents of
    @c(continue) in some other register before setting up @c(continue) for the
    call to @c(sub2), @c(sub1) will not know where to go when it is finished. The
    mechanism developed in the next section to handle recursion also provides a
    better solution to this problem of nested subroutine calls.

*** 5.1.4 <> Using a Stack to Implement Recursion

    With the ideas illustrated so far, we can implement any iterative process by
    specifying a register machine that has a register corresponding to each state
    variable of the process. The machine repeatedly executes a controller loop,
    changing the contents of the registers, until some termination condition is
    satisfied. At each point in the controller sequence, the state of the machine
    (representing the state of the iterative process) is completely determined by
    the contents of the registers (the values of the state variables).

    Implementing recursive processes, however, requires an additional mechanism.
    Consider the following recursive method for computing factorials, which we
    first examined in @l(#1.2.1):

    ..src > scheme
      (define (factorial n)
        (if (= n 1)
            1
            (* (factorial (- n 1)) n)))
    < src..

    As we see from the procedure, computing @m(n!) requires computing @m[(n - 1)!].
    Our @A(GCD) machine, modeled on the procedure

    ..src > scheme
      (define (gcd a b)
        (if (= b 0)
            a
            (gcd b (remainder a b))))
    < src..

    similarly had to compute another @A(GCD). But there is an important difference
    between the @c(gcd) procedure, which reduces the original computation to a new
    @A(GCD) computation, and @c(factorial), which requires computing another
    factorial as a subproblem. In @A(GCD), the answer to the new @A(GCD)
    computation is the answer to the original problem. To compute the next
    @A(GCD), we simply place the new arguments in the input registers of the
    @A(GCD) machine and reuse the machine's data paths by executing the same
    controller sequence. When the machine is finished solving the final @A(GCD)
    problem, it has completed the entire computation.

    In the case of factorial (or any recursive process) the answer to the new
    factorial subproblem is not the answer to the original problem. The value
    obtained for @m[(n - 1)!] must be multiplied by @m(n) to get the final answer.
    If we try to imitate the @A(GCD) design, and solve the factorial subproblem by
    decrementing the @c(n) register and rerunning the factorial machine, we will
    no longer have available the old value of @c(n) by which to multiply the
    result. We thus need a second factorial machine to work on the
    subproblem. This second factorial computation itself has a factorial
    subproblem, which requires a third factorial machine, and so on. Since each
    factorial machine contains another factorial machine within it, the total
    machine contains an infinite nest of similar machines and hence cannot be
    constructed from a fixed, finite number of parts.

    Nevertheless, we can implement the factorial process as a register machine if
    we can arrange to use the same components for each nested instance of the
    machine. Specifically, the machine that computes @m(n!)  should use the same
    components to work on the subproblem of computing @m[(n - 1)!], on the
    subproblem for @m[(n - 2)!], and so on. This is plausible because, although
    the factorial process dictates that an unbounded number of copies of the same
    machine are needed to perform a computation, only one of these copies needs to
    be active at any given time. When the machine encounters a recursive
    subproblem, it can suspend work on the main problem, reuse the same physical
    parts to work on the subproblem, then continue the suspended computation.

    In the subproblem, the contents of the registers will be different than they
    were in the main problem. (In this case the @c(n) register is decremented.)
    In order to be able to continue the suspended computation, the machine must
    save the contents of any registers that will be needed after the subproblem is
    solved so that these can be restored to continue the suspended computation. In
    the case of factorial, we will save the old value of @c(n), to be restored
    when we are finished computing the factorial of the decremented @c(n)
    register.@n(287)

    Since there is no @e(a priori) limit on the depth of nested recursive calls,
    we may need to save an arbitrary number of register values. These values must
    be restored in the reverse of the order in which they were saved, since in a
    nest of recursions the last subproblem to be entered is the first to be
    finished. This dictates the use of a @e(stack), or @"(last in, first out) data
    structure, to save register values. We can extend the register-machine
    language to include a stack by adding two kinds of instructions: Values are
    placed on the stack using a @c(save) instruction and restored from the stack
    using a @c(restore) instruction. After a sequence of values has been @c(save)d
    on the stack, a sequence of @c(restore)s will retrieve these values in reverse
    order.@n(288)

    With the aid of the stack, we can reuse a single copy of the factorial
    machine's data paths for each factorial subproblem. There is a similar design
    issue in reusing the controller sequence that operates the data paths. To
    reexecute the factorial computation, the controller cannot simply loop back to
    the beginning, as with an iterative process, because after solving the @m[(n -
    1)!] subproblem the machine must still multiply the result by @m(n). The
    controller must suspend its computation of @m(n!), solve the @m[(n - 1)!]
    subproblem, then continue its computation of @m(n!). This view of the
    factorial computation suggests the use of the subroutine mechanism described
    in @l(#5.1.3), which has the controller use a @c(continue) register to
    transfer to the part of the sequence that solves a subproblem and then
    continue where it left off on the main problem. We can thus make a factorial
    subroutine that returns to the entry point stored in the @c(continue)
    register. Around each subroutine call, we save and restore @c(continue) just
    as we do the @c(n) register, since each @"(level) of the factorial computation
    will use the same @c(continue) register. That is, the factorial subroutine
    must put a new value in @c(continue) when it calls itself for a subproblem,
    but it will need the old value in order to return to the place that called it
    to solve a subproblem.

    @l(#Figure 5.11) shows the data paths and controller for a machine that
    implements the recursive @c(factorial) procedure. The machine has a stack and
    three registers, called @c(n), @c(val), and @c(continue). To simplify the
    data-path diagram, we have not named the register-assignment buttons, only the
    stack-operation buttons (@c(sc) and @c(sn) to save registers, @c(rc) and
    @c(rn) to restore registers). To operate the machine, we put in register @c(n)
    the number whose factorial we wish to compute and start the machine. When the
    machine reaches @c(fact-done), the computation is finished and the answer will
    be found in the @c(val) register. In the controller sequence, @c(n) and
    @c(continue) are saved before each recursive call and restored upon return
    from the call. Returning from a call is accomplished by branching to the
    location stored in @c(continue). @c(Continue) is initialized when the machine
    starts so that the last return will go to @c(fact-done). The @c(val) register,
    which holds the result of the factorial computation, is not saved before the
    recursive call, because the old contents of @c(val) is not useful after the
    subroutine returns. Only the new value, which is the value produced by the
    subcomputation, is needed.

    ..figure > @t(Figure 5.11) A recursive factorial machine.

      ..art >
                                     ___
                                    ╱   ╲
            ╭──────────●───────────(  =  )
            │          │            ╲___╱
           (X)         │              ▲
            │          │              │
            ▼          │          ╭───┴───╮    sn   ╭───────╮
        ╭───────╮      │          │       ├───(X)──▶│       │
        │  val  │◀─(X)─│──────────┤   n   │         │ stack │
        ╰─────┬─╯      │          │       │◀──(X)───┤       │
          ▲   │        │          ╰───────╯   rn    ╰─┬─────╯
          │   │        │            │   ▲             │   ▲
         (X)  │        │            │   │             │   │
          │   │   ╭────┼────────────●  (X)            │  (X) sc
          │   │   │    │            │   │         rc (X)  │
          │   │   │    ●────────╮   │   │             │   │
          │   ▼   ▼    │        ▼   ▼   │             ▼   │
          │  ───────   │       ───────  │         ╭───────┴──╮
          │  ╲  *  ╱   │       ╲  ─  ╱  │         │ continue ├──▶ controller
          │   ──┬──    │        ──┬──   │         ╰──────────╯
          │     │      │          │     │           ▲       ▲
          ╰─────╯      │          ╰─────╯           │       │
                       │                           (X)     (X)
                       │                            │       │
                      ╱ ╲                   after- ╱ ╲     ╱ ╲  fact-
                     ╱ 1 ╲                  fact  ╱   ╲   ╱   ╲ done
                    ╱_____╲                      ╱_____╲ ╱_____╲
      < art..

      ..src > scheme
        (controller
           (assign continue (label fact-done))     ; set up final return address
         fact-loop
           (test (op =) (reg n) (const 1))
           (branch (label base-case))
           ;; Set up for the recursive call by saving n and continue.
           ;; Set up continue so that the computation will continue
           ;; at after-fact when the subroutine returns.
           (save continue)
           (save n)
           (assign n (op -) (reg n) (const 1))
           (assign continue (label after-fact))
           (goto (label fact-loop))
         after-fact
           (restore n)
           (restore continue)
           (assign val (op *) (reg n) (reg val))   ; val now contains n(n − 1)!
           (goto (reg continue))                   ; return to caller
         base-case
           (assign val (const 1))                  ; base case: 1! = 1
           (goto (reg continue))                   ; return to caller
         fact-done)
      < src..
    < figure..

@   ..img > img/chap5/Fig5.11b.std.svg

    Although in principle the factorial computation requires an infinite machine,
    the machine in @l(#Figure 5.11) is actually finite except for the stack, which
    is potentially unbounded. Any particular physical implementation of a stack,
    however, will be of finite size, and this will limit the depth of recursive
    calls that can be handled by the machine. This implementation of factorial
    illustrates the general strategy for realizing recursive algorithms as
    ordinary register machines augmented by stacks. When a recursive subproblem is
    encountered, we save on the stack the registers whose current values will be
    required after the subproblem is solved, solve the recursive subproblem, then
    restore the saved registers and continue execution on the main problem. The
    @c(continue) register must always be saved. Whether there are other registers
    that need to be saved depends on the particular machine, since not all
    recursive computations need the original values of registers that are modified
    during solution of the subproblem (see @l(#Exercise 5.4)).

**** A double recursion

     Let us examine a more complex recursive process, the tree-recursive
     computation of the Fibonacci numbers, which we introduced in @l(#1.2.2):

     ..src > scheme
       (define (fib n)
         (if (< n 2)
             n
             (+ (fib (- n 1)) (fib (- n 2)))))
     < src..

     Just as with factorial, we can implement the recursive Fibonacci computation
     as a register machine with registers @c(n), @c(val), and @c(continue).  The
     machine is more complex than the one for factorial, because there are two
     places in the controller sequence where we need to perform recursive
     calls––once to compute @m[Fib(n - 1)] and once to compute @m[Fib(n - 2)]. To
     set up for each of these calls, we save the registers whose values will be
     needed later, set the @c(n) register to the number whose Fib we need to
     compute recursively (@m(n - 1) or @m(n - 2)), and assign to @c(continue) the
     entry point in the main sequence to which to return (@c(afterfib-n-1) or
     @c(afterfib-n-2), respectively). We then go to @c(fib-loop). When we return
     from the recursive call, the answer is in @c(val). @l(#Figure 5.12) shows the
     controller sequence for this machine.

     ..figure > @t(Figure 5.12) Controller for a machine to compute Fibonacci
       numbers.

       ..src > scheme
         (controller
            (assign continue (label fib-done))
          fib-loop
            (test (op <) (reg n) (const 2))
            (branch (label immediate-answer))
            ;; set up to compute Fib(n − 1)
            (save continue)
            (assign continue (label afterfib-n-1))
            (save n)           ; save old value of n
            (assign n
                    (op -)
                    (reg n)
                    (const 1)) ; clobber n to n-1
            (goto
             (label fib-loop)) ; perform recursive call
          afterfib-n-1 ; upon return, val contains Fib(n − 1)
            (restore n)
            (restore continue)
            ;; set up to compute Fib(n − 2)
            (assign n (op -) (reg n) (const 2))
            (save continue)
            (assign continue (label afterfib-n-2))
            (save val)         ; save Fib(n − 1)
            (goto (label fib-loop))
          afterfib-n-2 ; upon return, val contains Fib(n − 2)
            (assign n
                    (reg val)) ; n now contains Fib(n − 2)
            (restore val)      ; val now contains Fib(n − 1)
            (restore continue)
            (assign val        ; Fib(n − 1) + Fib(n − 2)
                    (op +)
                    (reg val)
                    (reg n))
            (goto              ; return to caller,
             (reg continue))   ; answer is in val
          immediate-answer
            (assign val
                    (reg n))   ; base case: Fib(n) = n
            (goto (reg continue))
          fib-done)
       < src..

     :: @t(Exercise 5.4) :: Specify register machines that implement each of the
        following procedures. For each machine, write a controller instruction
        sequence and draw a diagram showing the data paths.

        1. Recursive exponentiation:

           ..src > scheme
             (define (expt b n)
               (if (= n 0)
                   1
                   (* b (expt b (- n 1)))))
           < src..

        2. Iterative exponentiation:

           ..src > scheme
             (define (expt b n)
               (define (expt-iter counter product)
                 (if (= counter 0)
                     product
                     (expt-iter (- counter 1)
                                (* b product))))
               (expt-iter n 1))
           < src..

     :: @t(Exercise 5.5) :: Hand-simulate the factorial and Fibonacci machines,
        using some nontrivial input (requiring execution of at least one recursive
        call). Show the contents of the stack at each significant point in the
        execution.

     :: @t(Exercise 5.6) :: Ben Bitdiddle observes that the Fibonacci machine's
        controller sequence has an extra @c(save) and an extra @c(restore), which
        can be removed to make a faster machine. Where are these instructions?

*** 5.1.5 <> Instruction Summary

    A controller instruction in our register-machine language has one of the
    following forms, where each @m[⟨inputᵢ⟩] is either @c[(reg ⟨register-name⟩)]
    or @c[(const ⟨constant-value⟩)].  These instructions were introduced in
    @l(#5.1.1):

    ..src > scheme
      (assign ⟨register-name⟩ (reg ⟨register-name⟩))
      (assign ⟨register-name⟩
              (const ⟨constant-value⟩))
      (assign ⟨register-name⟩
              (op ⟨operation-name⟩)
              ⟨input₁⟩ … ⟨inputₙ⟩)
      (perform (op ⟨operation-name⟩)
               ⟨input₁⟩
               …
               ⟨inputₙ⟩)
      (test (op ⟨operation-name⟩)
            ⟨input₁⟩
            …
            ⟨inputₙ⟩)
      (branch (label ⟨label-name⟩))
      (goto (label ⟨label-name⟩))
    < src..

    The use of registers to hold labels was introduced in @l(#5.1.3):

    ..src > scheme
      (assign ⟨register-name⟩ (label ⟨label-name⟩))
      (goto (reg ⟨register-name⟩))
    < src..

    Instructions to use the stack were introduced in @l(#5.1.4):

    ..src > scheme
      (save ⟨register-name⟩)
      (restore ⟨register-name⟩)
    < src..

    The only kind of @c[(constant-value)] we have seen so far is a number, but
    later we will use strings, symbols, and lists.  For example,

    - @c[(const "abc")] is the string @c("abc"),

    - @c[(const abc)] is the symbol @c(abc),

    - @c[(const (a b c))] is the list @c[(a b c)],

    - and @c[(const ())] is the empty list.

** 5.2 <> A Register-Machine Simulator

   In order to gain a good understanding of the design of register machines, we
   must test the machines we design to see if they perform as expected. One way
   to test a design is to hand-simulate the operation of the controller, as in
   @l(#Exercise 5.5). But this is extremely tedious for all but the simplest
   machines. In this section we construct a simulator for machines described in
   the register-machine language. The simulator is a Scheme program with four
   interface procedures. The first uses a description of a register machine to
   construct a model of the machine (a data structure whose parts correspond to
   the parts of the machine to be simulated), and the other three allow us to
   simulate the machine by manipulating the model:

   ..tab >
     ..src > scheme
       (make-machine ⟨register-names⟩
                     ⟨operations⟩
                     ⟨controller⟩)
     < src..

     constructs and returns a model of the machine with the given registers,
     operations, and controller.

     ..src > scheme
       (set-register-contents! ⟨machine-model⟩
                               ⟨register-name⟩
                               ⟨value⟩)
     < src..

     stores a value in a simulated register in the given machine.

     ..src > scheme
       (get-register-contents ⟨machine-model⟩
                              ⟨register-name⟩)
     < src..

     returns the contents of a simulated register in the given machine.

     ..src > scheme
       (start ⟨machine-model⟩)
     < src..

     simulates the execution of the given machine, starting from the beginning of
     the controller sequence and stopping when it reaches the end of the
     sequence.
   < tab..

   As an example of how these procedures are used, we can define @c(gcd-machine)
   to be a model of the @A(GCD) machine of @l(#5.1.1) as follows:

   ..src > scheme
     (define gcd-machine
       (make-machine
        '(a b t)
        (list (list 'rem remainder) (list '= =))
        '(test-b
            (test (op =) (reg b) (const 0))
            (branch (label gcd-done))
            (assign t (op rem) (reg a) (reg b))
            (assign a (reg b))
            (assign b (reg t))
            (goto (label test-b))
          gcd-done)))
   < src..

   The first argument to @c(make-machine) is a list of register names. The next
   argument is a table (a list of two-element lists) that pairs each operation
   name with a Scheme procedure that implements the operation (that is, produces
   the same output value given the same input values). The last argument
   specifies the controller as a list of labels and machine instructions, as in
   @l(#5.1).

   To compute @A(GCD)s with this machine, we set the input registers, start the
   machine, and examine the result when the simulation terminates:

   ..srci > scheme
     > (set-register-contents! gcd-machine 'a 206)
     done
     > (set-register-contents! gcd-machine 'b 40)
     done
     > (start gcd-machine)
     done
     > (get-register-contents gcd-machine 'a)
     2
   < srci..

   This computation will run much more slowly than a @c(gcd) procedure written in
   Scheme, because we will simulate low-level machine instructions, such as
   @c(assign), by much more complex operations.

   :: @t(Exercise 5.7) :: Use the simulator to test the machines you designed in
      @l(#Exercise 5.4).

*** 5.2.1 <> The Machine Model

    The machine model generated by @c(make-machine) is represented as a procedure
    with local state using the message-passing techniques developed in @l(#Chapter
    3). To build this model, @c(make-machine) begins by calling the procedure
    @c(make-new-machine) to construct the parts of the machine model that are
    common to all register machines. This basic machine model constructed by
    @c(make-new-machine) is essentially a container for some registers and a
    stack, together with an execution mechanism that processes the controller
    instructions one by one.

    @c(Make-machine) then extends this basic model (by sending it messages) to
    include the registers, operations, and controller of the particular machine
    being defined. First it allocates a register in the new machine for each of
    the supplied register names and installs the designated operations in the
    machine. Then it uses an @e(assembler) (described below in @l(#5.2.2)) to
    transform the controller list into instructions for the new machine and
    installs these as the machine's instruction sequence.  @c(Make-machine)
    returns as its value the modified machine model.

    ..src > scheme
      (define (make-machine register-names
                            ops
                            controller-text)
        (let ((machine (make-new-machine)))
          (for-each (lambda (register-name)
                      ((machine 'allocate-register)
                       register-name))
                    register-names)
          ((machine 'install-operations) ops)
          ((machine 'install-instruction-sequence)
           (assemble controller-text machine))
          machine))
    < src..

**** Registers

     We will represent a register as a procedure with local state, as in
     @l(#Chapter 3). The procedure @c(make-register) creates a register that holds
     a value that can be accessed or changed:

     ..src > scheme
       (define (make-register name)
         (let ((contents '*unassigned*))
           (define (dispatch message)
             (cond ((eq? message 'get) contents)
                   ((eq? message 'set)
                    (lambda (value)
                      (set! contents value)))
                   (else
                    (error "Unknown request:
                            REGISTER"
                           message))))
           dispatch))
     < src..

     The following procedures are used to access registers:

     ..src > scheme
       (define (get-contents register)
         (register 'get))

       (define (set-contents! register value)
         ((register 'set) value))
     < src..

**** The stack

     We can also represent a stack as a procedure with local state. The procedure
     @c(make-stack) creates a stack whose local state consists of a list of the
     items on the stack. A stack accepts requests to @c(push) an item onto the
     stack, to @c(pop) the top item off the stack and return it, and to
     @c(initialize) the stack to empty.

     ..src > scheme
       (define (make-stack)
         (let ((s '()))
           (define (push x)
             (set! s (cons x s)))
           (define (pop)
             (if (null? s)
                 (error "Empty stack: POP")
                 (let ((top (car s)))
                   (set! s (cdr s))
                   top)))
           (define (initialize)
             (set! s '())
             'done)
           (define (dispatch message)
             (cond ((eq? message 'push) push)
                   ((eq? message 'pop) (pop))
                   ((eq? message 'initialize)
                    (initialize))
                   (else
                    (error "Unknown request: STACK"
                           message))))
           dispatch))
     < src..

     The following procedures are used to access stacks:

     ..src > scheme
       (define (pop stack) (stack 'pop))
       (define (push stack value)
         ((stack 'push) value))
     < src..

**** The basic machine

     The @c(make-new-machine) procedure, shown in @l(#Figure 5.13), constructs
     an object whose local state consists of a stack, an initially empty
     instruction sequence, a list of operations that initially contains an
     operation to initialize the stack, and a @e(register table) that initially
     contains two registers, named @c(flag) and @c(pc) (for @"(program
     counter)). The internal procedure @c(allocate-register) adds new entries to
     the register table, and the internal procedure @c(lookup-register) looks up
     registers in the table.

     ..figure > @t(Figure 5.13) The @c(make-new-machine) procedure, which
       implements the basic machine model.

       ..src > scheme
         (define (make-new-machine)
           (let ((pc (make-register 'pc))
                 (flag (make-register 'flag))
                 (stack (make-stack))
                 (the-instruction-sequence '()))
             (let ((the-ops
                    (list
                     (list 'initialize-stack
                           (lambda ()
                             (stack 'initialize)))))
                   (register-table
                    (list (list 'pc pc)
                          (list 'flag flag))))
               (define (allocate-register name)
                 (if (assoc name register-table)
                     (error
                      "Multiply defined register: "
                      name)
                     (set! register-table
                           (cons
                            (list name
                                  (make-register name))
                            register-table)))
                 'register-allocated)
               (define (lookup-register name)
                 (let ((val
                        (assoc name register-table)))
                   (if val
                       (cadr val)
                       (error "Unknown register:"
                              name))))
               (define (execute)
                 (let ((insts (get-contents pc)))
                   (if (null? insts)
                       'done
                       (begin
                         ((instruction-execution-proc
                           (car insts)))
                         (execute)))))
               (define (dispatch message)
                 (cond ((eq? message 'start)
                        (set-contents!
                         pc
                         the-instruction-sequence)
                        (execute))
                       ((eq?
                         message
                         'install-instruction-sequence)
                        (lambda (seq)
                          (set!
                           the-instruction-sequence
                           seq)))
                       ((eq? message
                             'allocate-register)
                        allocate-register)
                       ((eq? message 'get-register)
                        lookup-register)
                       ((eq? message
                             'install-operations)
                        (lambda (ops)
                          (set! the-ops
                                (append the-ops ops))))
                       ((eq? message 'stack) stack)
                       ((eq? message 'operations)
                        the-ops)
                       (else (error "Unknown request:
                                     MACHINE"
                                    message))))
               dispatch)))
       < src..

     The @c(flag) register is used to control branching in the simulated machine.
     @c(Test) instructions set the contents of @c(flag) to the result of the test
     (true or false). @c(Branch) instructions decide whether or not to branch by
     examining the contents of @c(flag).

     The @c(pc) register determines the sequencing of instructions as the machine
     runs. This sequencing is implemented by the internal procedure @c(execute).
     In the simulation model, each machine instruction is a data structure that
     includes a procedure of no arguments, called the @e(instruction execution
     procedure), such that calling this procedure simulates executing the
     instruction. As the simulation runs, @c(pc) points to the place in the
     instruction sequence beginning with the next instruction to be executed.
     @c(Execute) gets that instruction, executes it by calling the instruction
     execution procedure, and repeats this cycle until there are no more
     instructions to execute (i.e., until @c(pc) points to the end of the
     instruction sequence).

     As part of its operation, each instruction execution procedure modifies @c(pc)
     to indicate the next instruction to be executed. @c(Branch) and @c(goto)
     instructions change @c(pc) to point to the new destination. All other
     instructions simply advance @c(pc), making it point to the next instruction in
     the sequence. Observe that each call to @c(execute) calls @c(execute) again,
     but this does not produce an infinite loop because running the instruction
     execution procedure changes the contents of @c(pc).

     @c(Make-new-machine) returns a @c(dispatch) procedure that implements
     message-passing access to the internal state. Notice that starting the machine
     is accomplished by setting @c(pc) to the beginning of the instruction sequence
     and calling @c(execute).

     For convenience, we provide an alternate procedural interface to a machine's
     @c(start) operation, as well as procedures to set and examine register
     contents, as specified at the beginning of @l(#5.2):

     ..src > scheme
       (define (start machine)
         (machine 'start))

       (define (get-register-contents
                machine register-name)
         (get-contents
          (get-register machine register-name)))

       (define (set-register-contents!
                machine register-name value)
         (set-contents!
          (get-register machine register-name)
          value)
         'done)
     < src..

     These procedures (and many procedures in @l(#5.2.2) and @l(#5.2.3)) use the
     following to look up the register with a given name in a given machine:

     ..src > scheme
       (define (get-register machine reg-name)
         ((machine 'get-register) reg-name))
     < src..

*** 5.2.2 <> The Assembler

    The assembler transforms the sequence of controller expressions for a machine
    into a corresponding list of machine instructions, each with its execution
    procedure. Overall, the assembler is much like the evaluators we studied in
    @l(#Chapter 4)––there is an input language (in this case, the register-machine
    language) and we must perform an appropriate action for each type of
    expression in the language.

    The technique of producing an execution procedure for each instruction is just
    what we used in @l(#4.1.7) to speed up the evaluator by separating analysis
    from runtime execution. As we saw in @l(#Chapter 4), much useful analysis of
    Scheme expressions could be performed without knowing the actual values of
    variables. Here, analogously, much useful analysis of register-machine-language
    expressions can be performed without knowing the actual contents of machine
    registers. For example, we can replace references to registers by pointers to
    the register objects, and we can replace references to labels by pointers to
    the place in the instruction sequence that the label designates.

    Before it can generate the instruction execution procedures, the assembler
    must know what all the labels refer to, so it begins by scanning the
    controller text to separate the labels from the instructions. As it scans the
    text, it constructs both a list of instructions and a table that associates
    each label with a pointer into that list. Then the assembler augments the
    instruction list by inserting the execution procedure for each instruction.

    The @c(assemble) procedure is the main entry to the assembler. It takes the
    controller text and the machine model as arguments and returns the instruction
    sequence to be stored in the model. @c(Assemble) calls @c(extract-labels) to
    build the initial instruction list and label table from the supplied
    controller text. The second argument to @c(extract-labels) is a procedure to
    be called to process these results: This procedure uses @c(update-insts!) to
    generate the instruction execution procedures and insert them into the
    instruction list, and returns the modified list.

    ..src > scheme
      (define (assemble controller-text machine)
        (extract-labels controller-text
          (lambda (insts labels)
            (update-insts! insts labels machine)
            insts)))
    < src..

    @c(Extract-labels) takes as arguments a list @c(text) (the sequence of
    controller instruction expressions) and a @c(receive) procedure.  @c(Receive)
    will be called with two values: (1) a list @c(insts) of instruction data
    structures, each containing an instruction from @c(text); and (2) a table
    called @c(labels), which associates each label from @c(text) with the position
    in the list @c(insts) that the label designates.

    ..src > scheme
      (define (extract-labels text receive)
        (if (null? text)
            (receive '() '())
            (extract-labels
             (cdr text)
             (lambda (insts labels)
               (let ((next-inst (car text)))
                 (if (symbol? next-inst)
                     (receive
                         insts
                         (cons
                          (make-label-entry
                           next-inst
                           insts)
                          labels))
                     (receive
                         (cons (make-instruction
                                next-inst)
                               insts)
                         labels)))))))
    < src..

    @c(Extract-labels) works by sequentially scanning the elements of the @c(text)
    and accumulating the @c(insts) and the @c(labels). If an element is a symbol
    (and thus a label) an appropriate entry is added to the @c(labels)
    table. Otherwise the element is accumulated onto the @c(insts) list.@n(289)

    @c(Update-insts!) modifies the instruction list, which initially contains only
    the text of the instructions, to include the corresponding execution
    procedures:

    ..src > scheme
      (define (update-insts! insts labels machine)
        (let ((pc (get-register machine 'pc))
              (flag (get-register machine 'flag))
              (stack (machine 'stack))
              (ops (machine 'operations)))
          (for-each
           (lambda (inst)
             (set-instruction-execution-proc!
              inst
              (make-execution-procedure
               (instruction-text inst)
               labels
               machine
               pc
               flag
               stack
               ops)))
           insts)))
    < src..

    The machine instruction data structure simply pairs the instruction text with
    the corresponding execution procedure. The execution procedure is not yet
    available when @c(extract-labels) constructs the instruction, and is inserted
    later by @c(update-insts!).

    ..src > scheme
      (define (make-instruction text)
        (cons text '()))
      (define (instruction-text inst) (car inst))
      (define (instruction-execution-proc inst)
        (cdr inst))
      (define (set-instruction-execution-proc!
               inst
               proc)
        (set-cdr! inst proc))
    < src..

    The instruction text is not used by our simulator, but it is handy to keep
    around for debugging (see @l(#Exercise 5.16)).

    Elements of the label table are pairs:

    ..src > scheme
      (define (make-label-entry label-name insts)
        (cons label-name insts))
    < src..

    Entries will be looked up in the table with

    ..src > scheme
      (define (lookup-label labels label-name)
        (let ((val (assoc label-name labels)))
          (if val
              (cdr val)
              (error "Undefined label: ASSEMBLE"
                     label-name))))
    < src..

    :: @t(Exercise 5.8) :: The following register-machine code is ambiguous,
       because the label @c(here) is defined more than once:

       ..src > scheme
         start
           (goto (label here))
         here
           (assign a (const 3))
           (goto (label there))
         here
           (assign a (const 4))
           (goto (label there))
         there
       < src..

       With the simulator as written, what will the contents of register @c(a) be
       when control reaches @c(there)?  Modify the @c(extract-labels) procedure so
       that the assembler will signal an error if the same label name is used to
       indicate two different locations.

*** 5.2.3 <> Generating Execution Procedures for Instructions

    The assembler calls @c(make-execution-procedure) to generate the execution
    procedure for an instruction. Like the @c(analyze) procedure in the evaluator
    of @l(#4.1.7), this dispatches on the type of instruction to generate the
    appropriate execution procedure.

    ..src > scheme
      (define (make-execution-procedure
               inst labels machine pc flag stack ops)
        (cond ((eq? (car inst) 'assign)
               (make-assign
                inst machine labels ops pc))
              ((eq? (car inst) 'test)
               (make-test
                inst machine labels ops flag pc))
              ((eq? (car inst) 'branch)
               (make-branch
                inst machine labels flag pc))
              ((eq? (car inst) 'goto)
               (make-goto inst machine labels pc))
              ((eq? (car inst) 'save)
               (make-save inst machine stack pc))
              ((eq? (car inst) 'restore)
               (make-restore inst machine stack pc))
              ((eq? (car inst) 'perform)
               (make-perform
                inst machine labels ops pc))
              (else (error "Unknown instruction
                            type: ASSEMBLE"
                           inst))))
    < src..

    For each type of instruction in the register-machine language, there is a
    generator that builds an appropriate execution procedure. The details of these
    procedures determine both the syntax and meaning of the individual
    instructions in the register-machine language. We use data abstraction to
    isolate the detailed syntax of register-machine expressions from the general
    execution mechanism, as we did for evaluators in @l(#4.1.2), by using syntax
    procedures to extract and classify the parts of an instruction.

**** @c(Assign) instructions

     The @c(make-assign) procedure handles @c(assign) instructions:

     ..src > scheme
       (define (make-assign
                inst machine labels operations pc)
         (let ((target
                (get-register
                 machine
                 (assign-reg-name inst)))
               (value-exp (assign-value-exp inst)))
           (let ((value-proc
                  (if (operation-exp? value-exp)
                      (make-operation-exp
                       value-exp
                       machine
                       labels
                       operations)
                      (make-primitive-exp
                       (car value-exp)
                       machine
                       labels))))
             (lambda ()   ; execution procedure
                          ; for assign
               (set-contents! target (value-proc))
               (advance-pc pc)))))
     < src..

     @c(Make-assign) extracts the target register name (the second element of the
     instruction) and the value expression (the rest of the list that forms the
     instruction) from the @c(assign) instruction using the selectors

     ..src > scheme
       (define (assign-reg-name assign-instruction)
         (cadr assign-instruction))
       (define (assign-value-exp assign-instruction)
         (cddr assign-instruction))
     < src..

     The register name is looked up with @c(get-register) to produce the target
     register object. The value expression is passed to @c(make-operation-exp) if
     the value is the result of an operation, and to @c(make-primitive-exp)
     otherwise. These procedures (shown below) parse the value expression and
     produce an execution procedure for the value. This is a procedure of no
     arguments, called @c(value-proc), which will be evaluated during the
     simulation to produce the actual value to be assigned to the register. Notice
     that the work of looking up the register name and parsing the value expression
     is performed just once, at assembly time, not every time the instruction is
     simulated. This saving of work is the reason we use execution procedures, and
     corresponds directly to the saving in work we obtained by separating program
     analysis from execution in the evaluator of @l(#4.1.7).

     The result returned by @c(make-assign) is the execution procedure for the
     @c(assign) instruction. When this procedure is called (by the machine model's
     @c(execute) procedure), it sets the contents of the target register to the
     result obtained by executing @c(value-proc). Then it advances the @c(pc) to
     the next instruction by running the procedure

     ..src > scheme
       (define (advance-pc pc)
         (set-contents! pc (cdr (get-contents pc))))
     < src..

     @c(Advance-pc) is the normal termination for all instructions except
     @c(branch) and @c(goto).

**** @c(Test), @c(branch), and @c(goto) instructions

     @c(Make-test) handles @c(test) instructions in a similar way. It extracts the
     expression that specifies the condition to be tested and generates an
     execution procedure for it. At simulation time, the procedure for the
     condition is called, the result is assigned to the @c(flag) register, and the
     @c(pc) is advanced:

     ..src > scheme
       (define
         (make-test
          inst machine labels operations flag pc)
         (let ((condition (test-condition inst)))
           (if (operation-exp? condition)
               (let ((condition-proc
                      (make-operation-exp
                       condition
                       machine
                       labels
                       operations)))
                 (lambda ()
                   (set-contents!
                    flag (condition-proc))
                   (advance-pc pc)))
               (error "Bad TEST instruction:
                       ASSEMBLE" inst))))

       (define (test-condition test-instruction)
         (cdr test-instruction))
     < src..

     The execution procedure for a @c(branch) instruction checks the contents of
     the @c(flag) register and either sets the contents of the @c(pc) to the branch
     destination (if the branch is taken) or else just advances the @c(pc) (if the
     branch is not taken). Notice that the indicated destination in a @c(branch)
     instruction must be a label, and the @c(make-branch) procedure enforces
     this. Notice also that the label is looked up at assembly time, not each time
     the @c(branch) instruction is simulated.

     ..src > scheme
       (define
         (make-branch
          inst machine labels flag pc)
         (let ((dest (branch-dest inst)))
           (if (label-exp? dest)
               (let ((insts
                      (lookup-label
                       labels
                       (label-exp-label dest))))
                 (lambda ()
                   (if (get-contents flag)
                       (set-contents! pc insts)
                       (advance-pc pc))))
               (error "Bad BRANCH instruction:
                       ASSEMBLE"
                      inst))))

       (define (branch-dest branch-instruction)
         (cadr branch-instruction))
     < src..

     A @c(goto) instruction is similar to a branch, except that the destination may
     be specified either as a label or as a register, and there is no condition to
     check––the @c(pc) is always set to the new destination.

     ..src > scheme
       (define (make-goto inst machine labels pc)
         (let ((dest (goto-dest inst)))
           (cond ((label-exp? dest)
                  (let ((insts
                         (lookup-label
                          labels
                          (label-exp-label dest))))
                    (lambda ()
                      (set-contents! pc insts))))
                 ((register-exp? dest)
                  (let ((reg
                         (get-register
                          machine
                          (register-exp-reg dest))))
                    (lambda ()
                      (set-contents!
                       pc
                       (get-contents reg)))))
                 (else (error "Bad GOTO instruction:
                               ASSEMBLE"
                              inst)))))

       (define (goto-dest goto-instruction)
         (cadr goto-instruction))
     < src..

**** Other instructions

     The stack instructions @c(save) and @c(restore) simply use the stack with the
     designated register and advance the @c(pc):

     ..src > scheme
       (define (make-save inst machine stack pc)
         (let ((reg (get-register
                     machine
                     (stack-inst-reg-name inst))))
           (lambda ()
             (push stack (get-contents reg))
             (advance-pc pc))))

       (define (make-restore inst machine stack pc)
         (let ((reg (get-register
                     machine
                     (stack-inst-reg-name inst))))
           (lambda ()
             (set-contents! reg (pop stack))
             (advance-pc pc))))

       (define (stack-inst-reg-name
                stack-instruction)
         (cadr stack-instruction))
     < src..

     The final instruction type, handled by @c(make-perform), generates an
     execution procedure for the action to be performed. At simulation time, the
     action procedure is executed and the @c(pc) advanced.

     ..src > scheme
       (define (make-perform
                inst machine labels operations pc)
         (let ((action (perform-action inst)))
           (if (operation-exp? action)
               (let ((action-proc
                      (make-operation-exp
                       action
                       machine
                       labels
                       operations)))
                 (lambda ()
                   (action-proc)
                   (advance-pc pc)))
               (error "Bad PERFORM instruction:
                       ASSEMBLE"
                      inst))))

       (define (perform-action inst) (cdr inst))
     < src..

**** Execution procedures for subexpressions

     The value of a @c(reg), @c(label), or @c(const) expression may be needed for
     assignment to a register (@c(make-assign)) or for input to an operation
     (@c(make-operation-exp), below). The following procedure generates execution
     procedures to produce values for these expressions during the simulation:

     ..src > scheme
       (define (make-primitive-exp exp machine labels)
         (cond ((constant-exp? exp)
                (let ((c (constant-exp-value exp)))
                  (lambda () c)))
               ((label-exp? exp)
                (let ((insts
                       (lookup-label
                        labels
                        (label-exp-label exp))))
                  (lambda () insts)))
               ((register-exp? exp)
                (let ((r (get-register
                          machine
                          (register-exp-reg exp))))
                  (lambda () (get-contents r))))
               (else (error "Unknown expression type:
                             ASSEMBLE"
                            exp))))
     < src..

     The syntax of @c(reg), @c(label), and @c(const) expressions is determined by

     ..src > scheme
       (define (register-exp? exp)
         (tagged-list? exp 'reg))
       (define (register-exp-reg exp)
         (cadr exp))
       (define (constant-exp? exp)
         (tagged-list? exp 'const))
       (define (constant-exp-value exp)
         (cadr exp))
       (define (label-exp? exp)
         (tagged-list? exp 'label))
       (define (label-exp-label exp)
         (cadr exp))
     < src..

     @c(Assign), @c(perform), and @c(test) instructions may include the application
     of a machine operation (specified by an @c(op) expression) to some operands
     (specified by @c(reg) and @c(const) expressions). The following procedure
     produces an execution procedure for an @"(operation expression)––a list
     containing the operation and operand expressions from the instruction:

     ..src > scheme
       (define (make-operation-exp
                exp machine labels operations)
         (let ((op (lookup-prim
                    (operation-exp-op exp)
                    operations))
               (aprocs
                (map (lambda (e)
                       (make-primitive-exp
                        e machine labels))
                     (operation-exp-operands exp))))
           (lambda () (apply op (map (lambda (p) (p))
                                     aprocs)))))
     < src..

     The syntax of operation expressions is determined by

     ..src > scheme
       (define (operation-exp? exp)
         (and (pair? exp)
              (tagged-list? (car exp) 'op)))
       (define (operation-exp-op operation-exp)
         (cadr (car operation-exp)))
       (define (operation-exp-operands operation-exp)
         (cdr operation-exp))
     < src..

     Observe that the treatment of operation expressions is very much like the
     treatment of procedure applications by the @c(analyze-application) procedure
     in the evaluator of @l(#4.1.7) in that we generate an execution procedure for
     each operand. At simulation time, we call the operand procedures and apply the
     Scheme procedure that simulates the operation to the resulting values. The
     simulation procedure is found by looking up the operation name in the
     operation table for the machine:

     ..src > scheme
       (define (lookup-prim symbol operations)
         (let ((val (assoc symbol operations)))
           (if val
               (cadr val)
               (error "Unknown operation: ASSEMBLE"
                      symbol))))
     < src..

     :: @t(Exercise 5.9) :: The treatment of machine operations above permits them
        to operate on labels as well as on constants and the contents of
        registers. Modify the expression-processing procedures to enforce the
        condition that operations can be used only with registers and constants.

     :: @t(Exercise 5.10) :: Design a new syntax for register-machine instructions
        and modify the simulator to use your new syntax.  Can you implement your
        new syntax without changing any part of the simulator except the syntax
        procedures in this section?

     :: @t(Exercise 5.11) :: When we introduced @c(save) and @c(restore) in
        @l(#5.1.4), we didn't specify what would happen if you tried to restore a
        register that was not the last one saved, as in the sequence

        ..src > scheme
          (save y)
          (save x)
          (restore y)
        < src..

        There are several reasonable possibilities for the meaning of @c(restore):

        1. @c[(restore y)] puts into @c(y) the last value saved on the stack,
           regardless of what register that value came from. This is the way our
           simulator behaves. Show how to take advantage of this behavior to
           eliminate one instruction from the Fibonacci machine of @l(#5.1.4)
           (@l(#Figure 5.12)).

        2. @c[(restore y)] puts into @c(y) the last value saved on the stack, but
           only if that value was saved from @c(y); otherwise, it signals an error.
           Modify the simulator to behave this way. You will have to change
           @c(save) to put the register name on the stack along with the value.

        3. @c[(restore y)] puts into @c(y) the last value saved from @c(y)
           regardless of what other registers were saved after @c(y) and not
           restored.  Modify the simulator to behave this way. You will have to
           associate a separate stack with each register. You should make the
           @c(initialize-stack) operation initialize all the register stacks.

     :: @t(Exercise 5.12) :: The simulator can be used to help determine the data
        paths required for implementing a machine with a given controller. Extend
        the assembler to store the following information in the machine model:

        - a list of all instructions, with duplicates removed, sorted by
          instruction type (@c(assign), @c(goto), and so on);

        - a list (without duplicates) of the registers used to hold entry points
          (these are the registers referenced by @c(goto) instructions);

        - a list (without duplicates) of the registers that are @c(save)d or
          @c(restore)d;

        - for each register, a list (without duplicates) of the sources from which
          it is assigned (for example, the sources for register @c(val) in the
          factorial machine of @l(#Figure 5.11) are @c[(const 1)] and @c[((op *)
          (reg n) (reg val))]).


        Extend the message-passing interface to the machine to provide access to
        this new information. To test your analyzer, define the Fibonacci machine
        from @l(#Figure 5.12) and examine the lists you constructed.

     :: @t(Exercise 5.13) :: Modify the simulator so that it uses the controller
        sequence to determine what registers the machine has rather than requiring
        a list of registers as an argument to @c(make-machine).  Instead of
        pre-allocating the registers in @c(make-machine), you can allocate them one
        at a time when they are first seen during assembly of the instructions.

*** 5.2.4 <> Monitoring Machine Performance

    Simulation is useful not only for verifying the correctness of a proposed
    machine design but also for measuring the machine's performance. For example,
    we can install in our simulation program a @"(meter) that measures the number
    of stack operations used in a computation. To do this, we modify our simulated
    stack to keep track of the number of times registers are saved on the stack
    and the maximum depth reached by the stack, and add a message to the stack's
    interface that prints the statistics, as shown below. We also add an operation
    to the basic machine model to print the stack statistics, by initializing
    @c(the-ops) in @c(make-new-machine) to

    ..src > scheme
      (list (list 'initialize-stack
                  (lambda ()
                    (stack 'initialize)))
            (list 'print-stack-statistics
                  (lambda ()
                    (stack 'print-statistics))))
    < src..

    Here is the new version of @c(make-stack):

    ..src > scheme
      (define (make-stack)
        (let ((s '())
              (number-pushes 0)
              (max-depth 0)
              (current-depth 0))
          (define (push x)
            (set! s (cons x s))
            (set! number-pushes (+ 1 number-pushes))
            (set! current-depth (+ 1 current-depth))
            (set! max-depth
                  (max current-depth max-depth)))
          (define (pop)
            (if (null? s)
                (error "Empty stack: POP")
                (let ((top (car s)))
                  (set! s (cdr s))
                  (set! current-depth
                        (- current-depth 1))
                  top)))
          (define (initialize)
            (set! s '())
            (set! number-pushes 0)
            (set! max-depth 0)
            (set! current-depth 0)
            'done)

          (define (print-statistics)
            (newline)
            (display (list 'total-pushes
                           '=
                           number-pushes
                           'maximum-depth
                           '=
                           max-depth)))
          (define (dispatch message)
            (cond ((eq? message 'push) push)
                  ((eq? message 'pop) (pop))
                  ((eq? message 'initialize)
                   (initialize))
                  ((eq? message 'print-statistics)
                   (print-statistics))
                  (else
                   (error "Unknown request: STACK"
                          message))))
          dispatch))
    < src..

    @l(#Exercise 5.15) through @l(#Exercise 5.19) describe other useful monitoring
    and debugging features that can be added to the register-machine simulator.

    :: @t(Exercise 5.14) :: Measure the number of pushes and the maximum stack
       depth required to compute @m(n!) for various small values of @m(n) using
       the factorial machine shown in @l(#Figure 5.11). From your data determine
       formulas in terms of @m(n) for the total number of push operations and the
       maximum stack depth used in computing @m(n!) for any @m(n > 1). Note that
       each of these is a linear function of @m(n) and is thus determined by two
       constants. In order to get the statistics printed, you will have to augment
       the factorial machine with instructions to initialize the stack and print
       the statistics. You may want to also modify the machine so that it
       repeatedly reads a value for @m(n), computes the factorial, and prints the
       result (as we did for the @A(GCD) machine in @l(#Figure 5.4)), so that you
       will not have to repeatedly invoke @c(get-register-contents),
       @c(set-register-contents!), and @c(start).

    :: @t(Exercise 5.15) :: Add @e(instruction counting) to the register machine
       simulation. That is, have the machine model keep track of the number of
       instructions executed. Extend the machine model's interface to accept a new
       message that prints the value of the instruction count and resets the count
       to zero.

    :: @t(Exercise 5.16) :: Augment the simulator to provide for @e(instruction
       tracing). That is, before each instruction is executed, the simulator
       should print the text of the instruction. Make the machine model accept
       @c(trace-on) and @c(trace-off) messages to turn tracing on and off.

    :: @t(Exercise 5.17) :: Extend the instruction tracing of @l(#Exercise 5.16)
       so that before printing an instruction, the simulator prints any labels
       that immediately precede that instruction in the controller sequence. Be
       careful to do this in a way that does not interfere with instruction
       counting (@l(#Exercise 5.15)). You will have to make the simulator retain
       the necessary label information.

    :: @t(Exercise 5.18) :: Modify the @c(make-register) procedure of @l(#5.2.1)
       so that registers can be traced. Registers should accept messages that turn
       tracing on and off. When a register is traced, assigning a value to the
       register should print the name of the register, the old contents of the
       register, and the new contents being assigned. Extend the interface to the
       machine model to permit you to turn tracing on and off for designated
       machine registers.

    :: @t(Exercise 5.19) :: Alyssa P. Hacker wants a @e(breakpoint) feature in the
       simulator to help her debug her machine designs. You have been hired to
       install this feature for her. She wants to be able to specify a place in
       the controller sequence where the simulator will stop and allow her to
       examine the state of the machine. You are to implement a procedure

       ..src > scheme
         (set-breakpoint ⟨machine⟩ ⟨label⟩ ⟨n⟩)
       < src..

       that sets a breakpoint just before the @m(nᵗʰ) instruction after the given
       label. For example,

       ..src > scheme
         (set-breakpoint gcd-machine 'test-b 4)
       < src..

       installs a breakpoint in @c(gcd-machine) just before the assignment to
       register @c(a). When the simulator reaches the breakpoint it should print
       the label and the offset of the breakpoint and stop executing instructions.
       Alyssa can then use @c(get-register-contents) and
       @c(set-register-contents!) to manipulate the state of the simulated
       machine.  She should then be able to continue execution by saying

       ..src > scheme
         (proceed-machine ⟨machine⟩)
       < src..

       She should also be able to remove a specific breakpoint by means of

       ..src > scheme
         (cancel-breakpoint ⟨machine⟩ ⟨label⟩ ⟨n⟩)
       < src..

       or to remove all breakpoints by means of

       ..src > scheme
         (cancel-all-breakpoints ⟨machine⟩)
       < src..

** 5.3 <> Storage Allocation and Garbage Collection

   In section @l(#5.4), we will show how to implement a Scheme evaluator as a
   register machine. In order to simplify the discussion, we will assume that our
   register machines can be equipped with a @e(list-structured memory), in which
   the basic operations for manipulating list-structured data are primitive.
   Postulating the existence of such a memory is a useful abstraction when one is
   focusing on the mechanisms of control in a Scheme interpreter, but this does
   not reflect a realistic view of the actual primitive data operations of
   contemporary computers. To obtain a more complete picture of how a Lisp system
   operates, we must investigate how list structure can be represented in a way
   that is compatible with conventional computer memories.

   There are two considerations in implementing list structure. The first is
   purely an issue of representation: how to represent the @"(box-and-pointer)
   structure of Lisp pairs, using only the storage and addressing capabilities of
   typical computer memories. The second issue concerns the management of memory
   as a computation proceeds. The operation of a Lisp system depends crucially on
   the ability to continually create new data objects. These include objects that
   are explicitly created by the Lisp procedures being interpreted as well as
   structures created by the interpreter itself, such as environments and
   argument lists. Although the constant creation of new data objects would pose
   no problem on a computer with an infinite amount of rapidly addressable
   memory, computer memories are available only in finite sizes (more's the
   pity). Lisp systems thus provide an @e(automatic storage allocation) facility
   to support the illusion of an infinite memory. When a data object is no longer
   needed, the memory allocated to it is automatically recycled and used to
   construct new data objects. There are various techniques for providing such
   automatic storage allocation. The method we shall discuss in this section is
   called @e(garbage collection).

*** 5.3.1 <> Memory as Vectors

    A conventional computer memory can be thought of as an array of cubbyholes,
    each of which can contain a piece of information. Each cubbyhole has a unique
    name, called its @e(address) or @e(location). Typical memory systems provide
    two primitive operations: one that fetches the data stored in a specified
    location and one that assigns new data to a specified location.  Memory
    addresses can be incremented to support sequential access to some set of the
    cubbyholes. More generally, many important data operations require that memory
    addresses be treated as data, which can be stored in memory locations and
    manipulated in machine registers. The representation of list structure is one
    application of such @e(address arithmetic).

    To model computer memory, we use a new kind of data structure called a
    @e(vector). Abstractly, a vector is a compound data object whose individual
    elements can be accessed by means of an integer index in an amount of time
    that is independent of the index.@n(290) In order to describe memory
    operations, we use two primitive Scheme procedures for manipulating vectors:

    - @c[(vector-ref ⟨vector⟩ ⟨n⟩)] returns the @m(nᵗʰ) element of the vector.

    - @c[(vector-set! ⟨vector⟩ ⟨n⟩ ⟨value⟩)] sets the @m(nᵗʰ) element of the
      vector to the designated value.


    For example, if @c(v) is a vector, then @c[(vector-ref v 5)] gets the fifth
    entry in the vector @c(v) and @c[(vector-set! v 5 7)] changes the value of the
    fifth entry of the vector @c(v) to 7.@n(291) For computer memory, this access
    can be implemented through the use of address arithmetic to combine a @e(base
    address) that specifies the beginning location of a vector in memory with an
    @e(index) that specifies the offset of a particular element of the vector.

**** Representing Lisp data

     We can use vectors to implement the basic pair structures required for a
     list-structured memory. Let us imagine that computer memory is divided into
     two vectors: @c(the-cars) and @c(the-cdrs). We will represent list structure
     as follows: A pointer to a pair is an index into the two vectors.  The @c(car)
     of the pair is the entry in @c(the-cars) with the designated index, and the
     @c(cdr) of the pair is the entry in @c(the-cdrs) with the designated index. We
     also need a representation for objects other than pairs (such as numbers and
     symbols) and a way to distinguish one kind of data from another. There are
     many methods of accomplishing this, but they all reduce to using @e(typed
     pointers), that is, to extending the notion of @"(pointer) to include
     information on data type.@n(292) The data type enables the system to
     distinguish a pointer to a pair (which consists of the @"(pair) data type and
     an index into the memory vectors) from pointers to other kinds of data (which
     consist of some other data type and whatever is being used to represent data
     of that type). Two data objects are considered to be the same (@c(eq?)) if
     their pointers are identical.@n(293) @l(#Figure 5.14) illustrates the use of
     this method to represent the list @c[((1 2) 3 4)], whose box-and-pointer
     diagram is also shown. We use letter prefixes to denote the data-type
     information. Thus, a pointer to the pair with index 5 is denoted @c(p5), the
     empty list is denoted by the pointer @c(e0), and a pointer to the number 4 is
     denoted @c(n4). In the box-and-pointer diagram, we have indicated at the lower
     left of each pair the vector index that specifies where the @c(car) and
     @c(cdr) of the pair are stored. The blank locations in @c(the-cars) and
     @c(the-cdrs) may contain parts of other list structures (not of interest
     here).

     ..figure > @t(Figure 5.14) Box-and-pointer and memory-vector representations
       of the list @c[((1 2) 3 4)].

       ..art >
                        ╭───┬───╮               ╭───┬───╮    ╭───┬───╮
         ((1 2) 3 4) ──▶│ ◆ │ ◆ ┼──────────────▶│ ◆ │ ◆ ┼───▶│ ◆ │ ╱ │
                        ╰─┼─┴───╯               ╰─┼─┴───╯    ╰─┼─┴───╯
                       1  │                    2  │         4  │
                          ▼                       ▼            ▼
                        ╭───┬───╮    ╭───┬───╮  ╭───╮        ╭───╮
                        │ ◆ │ ◆ ┼───▶│ ◆ │ ╱ │  │ 3 │        │ 4 │
                        ╰─┼─┴───╯    ╰─┼─┴───╯  ╰───╯        ╰───╯
                       5  │         7  │
                          ▼            ▼
                        ╭───╮        ╭───╮
                        │ 1 │        │ 2 │
                        ╰───╯        ╰───╯

            Index   0    1    2    3    4    5    6    7    8    ⋯
                  ╭────┬────┬────┬────┬────┬────┬────┬────┬────┬────
         the-cars │    │ p5 │ n3 │    │ n4 │ n1 │    │ n2 │    │ ⋯
                  ├────┼────┼────┼────┼────┼────┼────┼────┼────┼────
         the-cdrs │    │ p2 │ p4 │    │ e0 │ p7 │    │ e0 │    │ ⋯
                  ╰────┴────┴────┴────┴────┴────┴────┴────┴────┴────
       < art..

@    ..img > img/chap5/Fig5.14b.std.svg

     A pointer to a number, such as @c(n4), might consist of a type indicating
     numeric data together with the actual representation of the number 4.@n(294)
     To deal with numbers that are too large to be represented in the fixed amount
     of space allocated for a single pointer, we could use a distinct @e(bignum)
     data type, for which the pointer designates a list in which the parts of the
     number are stored.@n(295)

     A symbol might be represented as a typed pointer that designates a sequence of
     the characters that form the symbol's printed representation. This sequence is
     constructed by the Lisp reader when the character string is initially
     encountered in input. Since we want two instances of a symbol to be recognized
     as the @"(same) symbol by @c(eq?) and we want @c(eq?) to be a simple test for
     equality of pointers, we must ensure that if the reader sees the same
     character string twice, it will use the same pointer (to the same sequence of
     characters) to represent both occurrences. To accomplish this, the reader
     maintains a table, traditionally called the @e(obarray), of all the symbols it
     has ever encountered. When the reader encounters a character string and is
     about to construct a symbol, it checks the obarray to see if it has ever
     before seen the same character string. If it has not, it uses the characters
     to construct a new symbol (a typed pointer to a new character sequence) and
     enters this pointer in the obarray. If the reader has seen the string before,
     it returns the symbol pointer stored in the obarray. This process of replacing
     character strings by unique pointers is called @e(interning) symbols.

**** Implementing the primitive list operations

     Given the above representation scheme, we can replace each @"(primitive) list
     operation of a register machine with one or more primitive vector operations.
     We will use two registers, @c(the-cars) and @c(the-cdrs), to identify the
     memory vectors, and will assume that @c(vector-ref) and @c(vector-set!)  are
     available as primitive operations. We also assume that numeric operations on
     pointers (such as incrementing a pointer, using a pair pointer to index a
     vector, or adding two numbers) use only the index portion of the typed
     pointer.

     For example, we can make a register machine support the instructions

     ..src > scheme
       (assign ⟨reg₁⟩ (op car) (reg ⟨reg₂⟩))
       (assign ⟨reg₁⟩ (op cdr) (reg ⟨reg₂⟩))
     < src..

     if we implement these, respectively, as

     ..src > scheme
       (assign ⟨reg₁⟩
               (op vector-ref)
               (reg the-cars)
               (reg ⟨reg₂⟩))
       (assign ⟨reg₁⟩
               (op vector-ref)
               (reg the-cdrs)
               (reg ⟨reg₂⟩))
     < src..

     The instructions

     ..src > scheme
       (perform (op set-car!) (reg ⟨reg₁⟩) (reg ⟨reg₂⟩))
       (perform (op set-cdr!) (reg ⟨reg₁⟩) (reg ⟨reg₂⟩))
     < src..

     are implemented as

     ..src > scheme
       (perform (op vector-set!)
                (reg the-cars)
                (reg ⟨reg₁⟩)
                (reg ⟨reg₂⟩))
       (perform (op vector-set!)
                (reg the-cdrs)
                (reg ⟨reg₁⟩)
                (reg ⟨reg₂⟩))
     < src..

     @c(Cons) is performed by allocating an unused index and storing the arguments
     to @c(cons) in @c(the-cars) and @c(the-cdrs) at that indexed vector
     position. We presume that there is a special register, @c(free), that always
     holds a pair pointer containing the next available index, and that we can
     increment the index part of that pointer to find the next free
     location.@n(296) For example, the instruction

     ..src > scheme
       (assign ⟨reg₁⟩
               (op cons)
               (reg ⟨reg₂⟩)
               (reg ⟨reg₃⟩))
     < src..

     is implemented as the following sequence of vector operations:@n(297)

     ..src > scheme
       (perform (op vector-set!)
                (reg the-cars)
                (reg free)
                (reg ⟨reg₂⟩))
       (perform (op vector-set!)
                (reg the-cdrs)
                (reg free)
                (reg ⟨reg₃⟩))
       (assign ⟨reg₁⟩ (reg free))
       (assign free (op +) (reg free) (const 1))
     < src..

     The @c(eq?) operation

     ..src > scheme
       (op eq?) (reg ⟨reg₁⟩) (reg ⟨reg₂⟩)
     < src..

     simply tests the equality of all fields in the registers, and predicates such
     as @c(pair?), @c(null?), @c(symbol?), and @c(number?) need only check the type
     field.

**** Implementing stacks

     Although our register machines use stacks, we need do nothing special here,
     since stacks can be modeled in terms of lists. The stack can be a list of the
     saved values, pointed to by a special register @c(the-stack). Thus, @c[(save
     ⟨reg⟩)] can be implemented as

     ..src > scheme
       (assign the-stack
               (op cons)
               (reg ⟨reg⟩)
               (reg the-stack))
     < src..

     Similarly, @c[(restore ⟨reg⟩)] can be implemented as

     ..src > scheme
       (assign ⟨reg⟩ (op car) (reg the-stack))
       (assign the-stack (op cdr) (reg the-stack))
     < src..

     and @c[(perform (op initialize-stack))] can be implemented as

     ..src > scheme
       (assign the-stack (const ()))
     < src..

     These operations can be further expanded in terms of the vector operations
     given above. In conventional computer architectures, however, it is usually
     advantageous to allocate the stack as a separate vector. Then pushing and
     popping the stack can be accomplished by incrementing or decrementing an index
     into that vector.

     :: @t(Exercise 5.20) :: Draw the box-and-pointer representation and the
        memory-vector representation (as in @l(#Figure 5.14)) of the list structure
        produced by

        ..src > scheme
          (define x (cons 1 2))
          (define y (list x x))
        < src..

        with the @c(free) pointer initially @c(p1). What is the final value of
        @c(free)?  What pointers represent the values of @c(x) and @c(y)?

     :: @t(Exercise 5.21) :: Implement register machines for the following
        procedures. Assume that the list-structure memory operations are available
        as machine primitives.

        1. Recursive @c(count-leaves):

           ..src > scheme
             (define (count-leaves tree)
               (cond ((null? tree) 0)
                     ((not (pair? tree)) 1)
                     (else
                      (+ (count-leaves (car tree))
                         (count-leaves (cdr tree))))))
           < src..

        2. Recursive @c(count-leaves) with explicit counter:

           ..src > scheme
             (define (count-leaves tree)
               (define (count-iter tree n)
                 (cond ((null? tree) n)
                       ((not (pair? tree)) (+ n 1))
                       (else
                        (count-iter
                         (cdr tree)
                         (count-iter (car tree)
                                     n)))))
               (count-iter tree 0))
           < src..

     :: @t(Exercise 5.22) :: @l(#Exercise 3.12) of @l(#3.3.1) presented an
        @c(append) procedure that appends two lists to form a new list and an
        @c(append!) procedure that splices two lists together.  Design a register
        machine to implement each of these procedures. Assume that the
        list-structure memory operations are available as primitive operations.

*** 5.3.2 <> Maintaining the Illusion of Infinite Memory

    The representation method outlined in @l(#5.3.1) solves the problem of
    implementing list structure, provided that we have an infinite amount of
    memory. With a real computer we will eventually run out of free space in which
    to construct new pairs.@n(298) However, most of the pairs generated in a
    typical computation are used only to hold intermediate results. After these
    results are accessed, the pairs are no longer needed––they are
    @e(garbage). For instance, the computation

    ..src > scheme
      (accumulate
       +
       0
       (filter odd? (enumerate-interval 0 n)))
    < src..

    constructs two lists: the enumeration and the result of filtering the
    enumeration. When the accumulation is complete, these lists are no longer
    needed, and the allocated memory can be reclaimed. If we can arrange to
    collect all the garbage periodically, and if this turns out to recycle memory
    at about the same rate at which we construct new pairs, we will have preserved
    the illusion that there is an infinite amount of memory.

    In order to recycle pairs, we must have a way to determine which allocated
    pairs are not needed (in the sense that their contents can no longer influence
    the future of the computation). The method we shall examine for accomplishing
    this is known as @e(garbage collection). Garbage collection is based on the
    observation that, at any moment in a Lisp interpretation, the only objects
    that can affect the future of the computation are those that can be reached by
    some succession of @c(car) and @c(cdr) operations starting from the pointers
    that are currently in the machine registers.@n(299) Any memory cell that is
    not so accessible may be recycled.

    There are many ways to perform garbage collection. The method we shall examine
    here is called @e(stop-and-copy). The basic idea is to divide memory into two
    halves: @"(working memory) and @"(free memory.)  When @c(cons) constructs
    pairs, it allocates these in working memory. When working memory is full, we
    perform garbage collection by locating all the useful pairs in working memory
    and copying these into consecutive locations in free memory. (The useful pairs
    are located by tracing all the @c(car) and @c(cdr) pointers, starting with the
    machine registers.)  Since we do not copy the garbage, there will presumably
    be additional free memory that we can use to allocate new pairs. In addition,
    nothing in the working memory is needed, since all the useful pairs in it have
    been copied. Thus, if we interchange the roles of working memory and free
    memory, we can continue processing; new pairs will be allocated in the new
    working memory (which was the old free memory). When this is full, we can copy
    the useful pairs into the new free memory (which was the old working
    memory).@n(300)

**** Implementation of a stop-and-copy garbage collector

     We now use our register-machine language to describe the stop-and-copy
     algorithm in more detail. We will assume that there is a register called
     @c(root) that contains a pointer to a structure that eventually points at all
     accessible data. This can be arranged by storing the contents of all the
     machine registers in a pre-allocated list pointed at by @c(root) just before
     starting garbage collection.@n(301) We also assume that, in addition to the
     current working memory, there is free memory available into which we can copy
     the useful data. The current working memory consists of vectors whose base
     addresses are in registers called @c(the-cars) and @c(the-cdrs), and the free
     memory is in registers called @c(new-cars) and @c(new-cdrs).

     Garbage collection is triggered when we exhaust the free cells in the current
     working memory, that is, when a @c(cons) operation attempts to increment the
     @c(free) pointer beyond the end of the memory vector. When the
     garbage-collection process is complete, the @c(root) pointer will point into
     the new memory, all objects accessible from the @c(root) will have been moved
     to the new memory, and the @c(free) pointer will indicate the next place in
     the new memory where a new pair can be allocated. In addition, the roles of
     working memory and new memory will have been interchanged––new pairs will be
     constructed in the new memory, beginning at the place indicated by @c(free),
     and the (previous) working memory will be available as the new memory for the
     next garbage collection. @l(#Figure 5.15) shows the arrangement of memory just
     before and just after garbage collection.

     ..figure > @t(Figure 5.15) Reconfiguration of memory by the garbage-collection
       process.

       ..art >
                      Just before garbage collection

                  ╭────────────────────────────────────╮
         the-cars │                                    │ working
                  │ mixture of useful data and garbage │ memory
         the-cdrs │                                    │
                  ╰────────────────────────────────────╯
                                                     ▲
                                                     │ free

                  ╭────────────────────────────────────╮
         new-cars │                                    │ free
                  │            free memory             │ memory
         new-cdrs │                                    │
                  ╰────────────────────────────────────╯

                      Just after garbage collection

                  ╭────────────────────────────────────╮
         new-cars │                                    │ new
                  │          discarded memory          │ free
         new-cdrs │                                    │ memory
                  ╰────────────────────────────────────╯

                  ╭──────────────────┬─────────────────╮
         the-cars │                  │                 │ new
                  │   useful data    │    free area    │ working
         the-cdrs │                  │                 │ memory
                  ╰──────────────────┴─────────────────╯
                                       ▲
                                       | free
       < art..

@    ..img > img/chap5/Fig5.15c.std.svg

     The state of the garbage-collection process is controlled by maintaining two
     pointers: @c(free) and @c(scan). These are initialized to point to the
     beginning of the new memory. The algorithm begins by relocating the pair
     pointed at by @c(root) to the beginning of the new memory. The pair is copied,
     the @c(root) pointer is adjusted to point to the new location, and the
     @c(free) pointer is incremented. In addition, the old location of the pair is
     marked to show that its contents have been moved. This marking is done as
     follows: In the @c(car) position, we place a special tag that signals that
     this is an already-moved object. (Such an object is traditionally called a
     @e(broken heart).)@n(302) In the @c(cdr) position we place a @e(forwarding
     address) that points at the location to which the object has been moved.

     After relocating the root, the garbage collector enters its basic cycle. At
     each step in the algorithm, the @c(scan) pointer (initially pointing at the
     relocated root) points at a pair that has been moved to the new memory but
     whose @c(car) and @c(cdr) pointers still refer to objects in the old
     memory. These objects are each relocated, and the @c(scan) pointer is
     incremented. To relocate an object (for example, the object indicated by the
     @c(car) pointer of the pair we are scanning) we check to see if the object has
     already been moved (as indicated by the presence of a broken-heart tag in the
     @c(car) position of the object). If the object has not already been moved, we
     copy it to the place indicated by @c(free), update @c(free), set up a broken
     heart at the object's old location, and update the pointer to the object (in
     this example, the @c(car) pointer of the pair we are scanning) to point to the
     new location. If the object has already been moved, its forwarding address
     (found in the @c(cdr) position of the broken heart) is substituted for the
     pointer in the pair being scanned. Eventually, all accessible objects will
     have been moved and scanned, at which point the @c(scan) pointer will overtake
     the @c(free) pointer and the process will terminate.

     We can specify the stop-and-copy algorithm as a sequence of instructions for a
     register machine. The basic step of relocating an object is accomplished by a
     subroutine called @c(relocate-old-result-in-new). This subroutine gets its
     argument, a pointer to the object to be relocated, from a register named
     @c(old). It relocates the designated object (incrementing @c(free) in the
     process), puts a pointer to the relocated object into a register called
     @c(new), and returns by branching to the entry point stored in the register
     @c(relocate-continue). To begin garbage collection, we invoke this subroutine
     to relocate the @c(root) pointer, after initializing @c(free) and
     @c(scan). When the relocation of @c(root) has been accomplished, we install
     the new pointer as the new @c(root) and enter the main loop of the garbage
     collector.

     ..src > scheme
       begin-garbage-collection
         (assign free (const 0))
         (assign scan (const 0))
         (assign old (reg root))
         (assign relocate-continue
                 (label reassign-root))
         (goto (label relocate-old-result-in-new))
       reassign-root
         (assign root (reg new))
         (goto (label gc-loop))
     < src..

     In the main loop of the garbage collector we must determine whether there are
     any more objects to be scanned. We do this by testing whether the @c(scan)
     pointer is coincident with the @c(free) pointer. If the pointers are equal,
     then all accessible objects have been relocated, and we branch to @c(gc-flip),
     which cleans things up so that we can continue the interrupted computation. If
     there are still pairs to be scanned, we call the relocate subroutine to
     relocate the @c(car) of the next pair (by placing the @c(car) pointer in
     @c(old)). The @c(relocate-continue) register is set up so that the subroutine
     will return to update the @c(car) pointer.

     ..src > scheme
       gc-loop
         (test (op =) (reg scan) (reg free))
         (branch (label gc-flip))
         (assign old
                 (op vector-ref)
                 (reg new-cars)
                 (reg scan))
         (assign relocate-continue
                 (label update-car))
         (goto (label relocate-old-result-in-new))
     < src..

     At @c(update-car), we modify the @c(car) pointer of the pair being scanned,
     then proceed to relocate the @c(cdr) of the pair. We return to @c(update-cdr)
     when that relocation has been accomplished. After relocating and updating the
     @c(cdr), we are finished scanning that pair, so we continue with the main
     loop.

     ..src > scheme
       update-car
         (perform (op vector-set!)
                  (reg new-cars)
                  (reg scan)
                  (reg new))
         (assign  old
                  (op vector-ref)
                  (reg new-cdrs)
                  (reg scan))
         (assign  relocate-continue
                  (label update-cdr))
         (goto (label relocate-old-result-in-new))
       update-cdr
         (perform (op vector-set!)
                  (reg new-cdrs)
                  (reg scan)
                  (reg new))
         (assign  scan (op +) (reg scan) (const 1))
         (goto (label gc-loop))
     < src..

     The subroutine @c(relocate-old-result-in-new) relocates objects as follows: If
     the object to be relocated (pointed at by @c(old)) is not a pair, then we
     return the same pointer to the object unchanged (in @c(new)). (For example, we
     may be scanning a pair whose @c(car) is the number 4. If we represent the
     @c(car) by @c(n4), as described in @l(#5.3.1), then we want the @"(relocated)
     @c(car) pointer to still be @c(n4).)  Otherwise, we must perform the
     relocation. If the @c(car) position of the pair to be relocated contains a
     broken-heart tag, then the pair has in fact already been moved, so we retrieve
     the forwarding address (from the @c(cdr) position of the broken heart) and
     return this in @c(new). If the pointer in @c(old) points at a yet-unmoved
     pair, then we move the pair to the first free cell in new memory (pointed at
     by @c(free)) and set up the broken heart by storing a broken-heart tag and
     forwarding address at the old location.  @c(Relocate-old-result-in-new) uses a
     register @c(oldcr) to hold the @c(car) or the @c(cdr) of the object pointed at
     by @c(old).@n(303)

     ..src > scheme
       relocate-old-result-in-new
         (test (op pointer-to-pair?) (reg old))
         (branch (label pair))
         (assign new (reg old))
         (goto (reg relocate-continue))
       pair
         (assign  oldcr
                  (op vector-ref)
                  (reg the-cars)
                  (reg old))
         (test (op broken-heart?) (reg oldcr))
         (branch  (label already-moved))
         (assign  new (reg free)) ; new location for pair
         ;; Update free pointer.
         (assign free (op +) (reg free) (const 1))
         ;; Copy the car and cdr to new memory.
         (perform (op vector-set!)
                  (reg new-cars)
                  (reg new)
                  (reg oldcr))
         (assign  oldcr
                  (op vector-ref)
                  (reg the-cdrs)
                  (reg old))
         (perform (op vector-set!)
                  (reg new-cdrs)
                  (reg new)
                  (reg oldcr))
         ;; Construct the broken heart.
         (perform (op vector-set!)
                  (reg the-cars)
                  (reg old)
                  (const broken-heart))
         (perform (op vector-set!)
                  (reg the-cdrs)
                  (reg old)
                  (reg new))
         (goto (reg relocate-continue))
       already-moved
         (assign  new
                  (op vector-ref)
                  (reg the-cdrs)
                  (reg old))
         (goto (reg relocate-continue))
     < src..

     At the very end of the garbage-collection process, we interchange the role of
     old and new memories by interchanging pointers: interchanging @c(the-cars)
     with @c(new-cars), and @c(the-cdrs) with @c(new-cdrs). We will then be ready
     to perform another garbage collection the next time memory runs out.

     ..src > scheme
       gc-flip
         (assign temp (reg the-cdrs))
         (assign the-cdrs (reg new-cdrs))
         (assign new-cdrs (reg temp))
         (assign temp (reg the-cars))
         (assign the-cars (reg new-cars))
         (assign new-cars (reg temp))
     < src..

** 5.4 <> The Explicit-Control Evaluator

   In @l(#5.1) we saw how to transform simple Scheme programs into descriptions
   of register machines. We will now perform this transformation on a more
   complex program, the metacircular evaluator of @l(#4.1.1)--@l(#4.1.4), which
   shows how the behavior of a Scheme interpreter can be described in terms of
   the procedures @c(eval) and @c(apply). The @e(explicit-control evaluator) that
   we develop in this section shows how the underlying procedure-calling and
   argument-passing mechanisms used in the evaluation process can be described in
   terms of operations on registers and stacks. In addition, the explicit-control
   evaluator can serve as an implementation of a Scheme interpreter, written in a
   language that is very similar to the native machine language of conventional
   computers. The evaluator can be executed by the register-machine simulator of
   @l(#5.2). Alternatively, it can be used as a starting point for building a
   machine-language implementation of a Scheme evaluator, or even a
   special-purpose machine for evaluating Scheme expressions. @l(#Figure 5.16)
   shows such a hardware implementation: a silicon chip that acts as an evaluator
   for Scheme. The chip designers started with the data-path and controller
   specifications for a register machine similar to the evaluator described in
   this section and used design automation programs to construct the
   integrated-circuit layout.@n(304)

   ..figure > @t(Figure 5.16) A silicon-chip implementation of an evaluator for
     Scheme.

     ..img > img/chap5/chip.std.svg

*** Registers and operations

    In designing the explicit-control evaluator, we must specify the operations to
    be used in our register machine. We described the metacircular evaluator in
    terms of abstract syntax, using procedures such as @c(quoted?) and
    @c(make-procedure). In implementing the register machine, we could expand
    these procedures into sequences of elementary list-structure memory
    operations, and implement these operations on our register machine. However,
    this would make our evaluator very long, obscuring the basic structure with
    details. To clarify the presentation, we will include as primitive operations
    of the register machine the syntax procedures given in @l(#4.1.2) and the
    procedures for representing environments and other run-time data given in
    sections @l(#4.1.3) and @l(#4.1.4). In order to completely specify an
    evaluator that could be programmed in a low-level machine language or
    implemented in hardware, we would replace these operations by more elementary
    operations, using the list-structure implementation we described in @l(#5.3).

    Our Scheme evaluator register machine includes a stack and seven registers:
    @c(exp), @c(env), @c(val), @c(continue), @c(proc), @c(argl), and
    @c(unev). @c(Exp) is used to hold the expression to be evaluated, and @c(env)
    contains the environment in which the evaluation is to be performed. At the
    end of an evaluation, @c(val) contains the value obtained by evaluating the
    expression in the designated environment. The @c(continue) register is used to
    implement recursion, as explained in @l(#5.1.4). (The evaluator needs to call
    itself recursively, since evaluating an expression requires evaluating its
    subexpressions.)  The registers @c(proc), @c(argl), and @c(unev) are used in
    evaluating combinations.

    We will not provide a data-path diagram to show how the registers and
    operations of the evaluator are connected, nor will we give the complete list
    of machine operations. These are implicit in the evaluator's controller, which
    will be presented in detail.

*** 5.4.1 <> The Core of the Explicit-Control Evaluator

    The central element in the evaluator is the sequence of instructions beginning
    at @c(eval-dispatch). This corresponds to the @c(eval) procedure of the
    metacircular evaluator described in @l(#4.1.1). When the controller starts at
    @c(eval-dispatch), it evaluates the expression specified by @c(exp) in the
    environment specified by @c(env). When evaluation is complete, the controller
    will go to the entry point stored in @c(continue), and the @c(val) register
    will hold the value of the expression. As with the metacircular @c(eval), the
    structure of @c(eval-dispatch) is a case analysis on the syntactic type of the
    expression to be evaluated.@n(305)

    ..src > scheme
      eval-dispatch
        (test (op self-evaluating?) (reg exp))
        (branch (label ev-self-eval))
        (test (op variable?) (reg exp))
        (branch (label ev-variable))
        (test (op quoted?) (reg exp))
        (branch (label ev-quoted))
        (test (op assignment?) (reg exp))
        (branch (label ev-assignment))
        (test (op definition?) (reg exp))
        (branch (label ev-definition))
        (test (op if?) (reg exp))
        (branch (label ev-if))
        (test (op lambda?) (reg exp))
        (branch (label ev-lambda))
        (test (op begin?) (reg exp))
        (branch (label ev-begin))
        (test (op application?) (reg exp))
        (branch (label ev-application))
        (goto (label unknown-expression-type))
    < src..

**** Evaluating simple expressions

     Numbers and strings (which are self-evaluating), variables, quotations, and
     @c(lambda) expressions have no subexpressions to be evaluated. For these, the
     evaluator simply places the correct value in the @c(val) register and
     continues execution at the entry point specified by @c(continue).  Evaluation
     of simple expressions is performed by the following controller code:

     ..src > scheme
       ev-self-eval
         (assign val (reg exp))
         (goto (reg continue))
       ev-variable
         (assign val
                 (op lookup-variable-value)
                 (reg exp)
                 (reg env))
         (goto (reg continue))
       ev-quoted
         (assign val
                 (op text-of-quotation)
                 (reg exp))
         (goto (reg continue))
       ev-lambda
         (assign unev
                 (op lambda-parameters)
                 (reg exp))
         (assign exp
                 (op lambda-body)
                 (reg exp))
         (assign val
                 (op make-procedure)
                 (reg unev)
                 (reg exp)
                 (reg env))
         (goto (reg continue))
     < src..

     Observe how @c(ev-lambda) uses the @c(unev) and @c(exp) registers to hold the
     parameters and body of the lambda expression so that they can be passed to the
     @c(make-procedure) operation, along with the environment in @c(env).

**** Evaluating procedure applications

     A procedure application is specified by a combination containing an operator
     and operands. The operator is a subexpression whose value is a procedure, and
     the operands are subexpressions whose values are the arguments to which the
     procedure should be applied. The metacircular @c(eval) handles applications by
     calling itself recursively to evaluate each element of the combination, and
     then passing the results to @c(apply), which performs the actual procedure
     application. The explicit-control evaluator does the same thing; these
     recursive calls are implemented by @c(goto) instructions, together with use of
     the stack to save registers that will be restored after the recursive call
     returns. Before each call we will be careful to identify which registers must
     be saved (because their values will be needed later).@n(306)

     We begin the evaluation of an application by evaluating the operator to
     produce a procedure, which will later be applied to the evaluated operands. To
     evaluate the operator, we move it to the @c(exp) register and go to
     @c(eval-dispatch). The environment in the @c(env) register is already the
     correct one in which to evaluate the operator. However, we save @c(env)
     because we will need it later to evaluate the operands. We also extract the
     operands into @c(unev) and save this on the stack. We set up @c(continue) so
     that @c(eval-dispatch) will resume at @c(ev-appl-did-operator) after the
     operator has been evaluated. First, however, we save the old value of
     @c(continue), which tells the controller where to continue after the
     application.

     ..src > scheme
       ev-application
         (save continue)
         (save env)
         (assign unev (op operands) (reg exp))
         (save unev)
         (assign exp (op operator) (reg exp))
         (assign
          continue (label ev-appl-did-operator))
         (goto (label eval-dispatch))
     < src..

     Upon returning from evaluating the operator subexpression, we proceed to
     evaluate the operands of the combination and to accumulate the resulting
     arguments in a list, held in @c(argl). First we restore the unevaluated
     operands and the environment. We initialize @c(argl) to an empty list.  Then
     we assign to the @c(proc) register the procedure that was produced by
     evaluating the operator. If there are no operands, we go directly to
     @c(apply-dispatch). Otherwise we save @c(proc) on the stack and start the
     argument-evaluation loop:@n(307)

     ..src > scheme
       ev-appl-did-operator
         (restore unev)             ; the operands
         (restore env)
         (assign argl (op empty-arglist))
         (assign proc (reg val))    ; the operator
         (test (op no-operands?) (reg unev))
         (branch (label apply-dispatch))
         (save proc)
     < src..

     Each cycle of the argument-evaluation loop evaluates an operand from the list
     in @c(unev) and accumulates the result into @c(argl). To evaluate an operand,
     we place it in the @c(exp) register and go to @c(eval-dispatch), after setting
     @c(continue) so that execution will resume with the argument-accumulation
     phase. But first we save the arguments accumulated so far (held in @c(argl)),
     the environment (held in @c(env)), and the remaining operands to be evaluated
     (held in @c(unev)). A special case is made for the evaluation of the last
     operand, which is handled at @c(ev-appl-last-arg).

     ..src > scheme
       ev-appl-operand-loop
         (save argl)
         (assign exp
                 (op first-operand)
                 (reg unev))
         (test (op last-operand?) (reg unev))
         (branch (label ev-appl-last-arg))
         (save env)
         (save unev)
         (assign continue
                 (label ev-appl-accumulate-arg))
         (goto (label eval-dispatch))
     < src..

     When an operand has been evaluated, the value is accumulated into the list
     held in @c(argl). The operand is then removed from the list of unevaluated
     operands in @c(unev), and the argument-evaluation continues.

     ..src > scheme
       ev-appl-accumulate-arg
         (restore unev)
         (restore env)
         (restore argl)
         (assign argl
                 (op adjoin-arg)
                 (reg val)
                 (reg argl))
         (assign unev
                 (op rest-operands)
                 (reg unev))
         (goto (label ev-appl-operand-loop))
     < src..

     Evaluation of the last argument is handled differently. There is no need to
     save the environment or the list of unevaluated operands before going to
     @c(eval-dispatch), since they will not be required after the last operand is
     evaluated. Thus, we return from the evaluation to a special entry point
     @c(ev-appl-accum-last-arg), which restores the argument list, accumulates the
     new argument, restores the saved procedure, and goes off to perform the
     application.@n(308)

     ..src > scheme
       ev-appl-last-arg
         (assign continue
                 (label ev-appl-accum-last-arg))
         (goto (label eval-dispatch))
       ev-appl-accum-last-arg
         (restore argl)
         (assign argl
                 (op adjoin-arg)
                 (reg val)
                 (reg argl))
         (restore proc)
         (goto (label apply-dispatch))
     < src..

     The details of the argument-evaluation loop determine the order in which the
     interpreter evaluates the operands of a combination (e.g., left to right or
     right to left––see @l(#Exercise 3.8)). This order is not determined by the
     metacircular evaluator, which inherits its control structure from the
     underlying Scheme in which it is implemented.@n(309) Because the
     @c(first-operand) selector (used in @c(ev-appl-operand-loop) to extract
     successive operands from @c(unev)) is implemented as @c(car) and the
     @c(rest-operands) selector is implemented as @c(cdr), the explicit-control
     evaluator will evaluate the operands of a combination in left-to-right order.

**** Procedure application

     The entry point @c(apply-dispatch) corresponds to the @c(apply) procedure of
     the metacircular evaluator. By the time we get to @c(apply-dispatch), the
     @c(proc) register contains the procedure to apply and @c(argl) contains the
     list of evaluated arguments to which it must be applied. The saved value of
     @c(continue) (originally passed to @c(eval-dispatch) and saved at
     @c(ev-application)), which tells where to return with the result of the
     procedure application, is on the stack. When the application is complete, the
     controller transfers to the entry point specified by the saved @c(continue),
     with the result of the application in @c(val). As with the metacircular
     @c(apply), there are two cases to consider. Either the procedure to be applied
     is a primitive or it is a compound procedure.

     ..src > scheme
       apply-dispatch
         (test (op primitive-procedure?) (reg proc))
         (branch (label primitive-apply))
         (test (op compound-procedure?) (reg proc))
         (branch (label compound-apply))
         (goto (label unknown-procedure-type))
     < src..

     We assume that each primitive is implemented so as to obtain its arguments
     from @c(argl) and place its result in @c(val). To specify how the machine
     handles primitives, we would have to provide a sequence of controller
     instructions to implement each primitive and arrange for @c(primitive-apply)
     to dispatch to the instructions for the primitive identified by the contents
     of @c(proc). Since we are interested in the structure of the evaluation
     process rather than the details of the primitives, we will instead just use an
     @c(apply-primitive-procedure) operation that applies the procedure in @c(proc)
     to the arguments in @c(argl). For the purpose of simulating the evaluator with
     the simulator of @l(#5.2) we use the procedure @c(apply-primitive-procedure),
     which calls on the underlying Scheme system to perform the application, just
     as we did for the metacircular evaluator in @l(#4.1.4). After computing the
     value of the primitive application, we restore @c(continue) and go to the
     designated entry point.

     ..src > scheme
       primitive-apply
         (assign val (op apply-primitive-procedure)
                     (reg proc)
                     (reg argl))
         (restore continue)
         (goto (reg continue))
     < src..

     To apply a compound procedure, we proceed just as with the metacircular
     evaluator. We construct a frame that binds the procedure's parameters to the
     arguments, use this frame to extend the environment carried by the procedure,
     and evaluate in this extended environment the sequence of expressions that
     forms the body of the procedure. @c(Ev-sequence), described below in
     @l(#5.4.2), handles the evaluation of the sequence.

     ..src > scheme
       compound-apply
         (assign unev
                 (op procedure-parameters)
                 (reg proc))
         (assign env
                 (op procedure-environment)
                 (reg proc))
         (assign env
                 (op extend-environment)
                 (reg unev)
                 (reg argl)
                 (reg env))
         (assign unev
                 (op procedure-body)
                 (reg proc))
         (goto (label ev-sequence))
     < src..

     @c(Compound-apply) is the only place in the interpreter where the @c(env)
     register is ever assigned a new value. Just as in the metacircular evaluator,
     the new environment is constructed from the environment carried by the
     procedure, together with the argument list and the corresponding list of
     variables to be bound.

*** 5.4.2 <> Sequence Evaluation and Tail Recursion

    The portion of the explicit-control evaluator at @c(ev-sequence) is analogous
    to the metacircular evaluator's @c(eval-sequence) procedure. It handles
    sequences of expressions in procedure bodies or in explicit @c(begin)
    expressions.

    Explicit @c(begin) expressions are evaluated by placing the sequence of
    expressions to be evaluated in @c(unev), saving @c(continue) on the stack, and
    jumping to @c(ev-sequence).

    ..src > scheme
      ev-begin
        (assign unev
                (op begin-actions)
                (reg exp))
        (save continue)
        (goto (label ev-sequence))
    < src..

    The implicit sequences in procedure bodies are handled by jumping to
    @c(ev-sequence) from @c(compound-apply), at which point @c(continue) is
    already on the stack, having been saved at @c(ev-application).

    The entries at @c(ev-sequence) and @c(ev-sequence-continue) form a loop that
    successively evaluates each expression in a sequence. The list of unevaluated
    expressions is kept in @c(unev). Before evaluating each expression, we check
    to see if there are additional expressions to be evaluated in the sequence. If
    so, we save the rest of the unevaluated expressions (held in @c(unev)) and the
    environment in which these must be evaluated (held in @c(env)) and call
    @c(eval-dispatch) to evaluate the expression. The two saved registers are
    restored upon the return from this evaluation, at @c(ev-sequence-continue).

    The final expression in the sequence is handled differently, at the entry
    point @c(ev-sequence-last-exp). Since there are no more expressions to be
    evaluated after this one, we need not save @c(unev) or @c(env) before going to
    @c(eval-dispatch). The value of the whole sequence is the value of the last
    expression, so after the evaluation of the last expression there is nothing
    left to do except continue at the entry point currently held on the stack
    (which was saved by @c(ev-application) or @c(ev-begin).)  Rather than setting
    up @c(continue) to arrange for @c(eval-dispatch) to return here and then
    restoring @c(continue) from the stack and continuing at that entry point, we
    restore @c(continue) from the stack before going to @c(eval-dispatch), so that
    @c(eval-dispatch) will continue at that entry point after evaluating the
    expression.

    ..src > scheme
      ev-sequence
        (assign exp (op first-exp) (reg unev))
        (test (op last-exp?) (reg unev))
        (branch (label ev-sequence-last-exp))
        (save unev)
        (save env)
        (assign continue
                (label ev-sequence-continue))
        (goto (label eval-dispatch))
      ev-sequence-continue
        (restore env)
        (restore unev)
        (assign unev
                (op rest-exps)
                (reg unev))
        (goto (label ev-sequence))
      ev-sequence-last-exp
        (restore continue)
        (goto (label eval-dispatch))
    < src..

**** Tail recursion

     In @l(#Chapter 1) we said that the process described by a procedure such as

     ..src > scheme
       (define (sqrt-iter guess x)
         (if (good-enough? guess x)
             guess
             (sqrt-iter (improve guess x) x)))
     < src..

     is an iterative process. Even though the procedure is syntactically recursive
     (defined in terms of itself), it is not logically necessary for an evaluator
     to save information in passing from one call to @c(sqrt-iter) to the
     next.@n(310) An evaluator that can execute a procedure such as @c(sqrt-iter)
     without requiring increasing storage as the procedure continues to call itself
     is called a @e(tail-recursive) evaluator. The metacircular implementation of
     the evaluator in @l(#Chapter 4) does not specify whether the evaluator is
     tail-recursive, because that evaluator inherits its mechanism for saving state
     from the underlying Scheme. With the explicit-control evaluator, however, we
     can trace through the evaluation process to see when procedure calls cause a
     net accumulation of information on the stack.

     Our evaluator is tail-recursive, because in order to evaluate the final
     expression of a sequence we transfer directly to @c(eval-dispatch) without
     saving any information on the stack. Hence, evaluating the final expression in
     a sequence––even if it is a procedure call (as in @c(sqrt-iter), where the
     @c(if) expression, which is the last expression in the procedure body, reduces
     to a call to @c(sqrt-iter))––will not cause any information to be accumulated
     on the stack.@n(311)

     If we did not think to take advantage of the fact that it was unnecessary to
     save information in this case, we might have implemented @c(eval-sequence) by
     treating all the expressions in a sequence in the same way––saving the
     registers, evaluating the expression, returning to restore the registers, and
     repeating this until all the expressions have been evaluated:@n(312)

     ..src > scheme
       ev-sequence
         (test (op no-more-exps?) (reg unev))
         (branch (label ev-sequence-end))
         (assign exp (op first-exp) (reg unev))
         (save unev)
         (save env)
         (assign continue
                 (label ev-sequence-continue))
         (goto (label eval-dispatch))
       ev-sequence-continue
         (restore env)
         (restore unev)
         (assign unev (op rest-exps) (reg unev))
         (goto (label ev-sequence))
       ev-sequence-end
         (restore continue)
         (goto (reg continue))
     < src..

     This may seem like a minor change to our previous code for evaluation of a
     sequence: The only difference is that we go through the save-restore cycle for
     the last expression in a sequence as well as for the others. The interpreter
     will still give the same value for any expression. But this change is fatal to
     the tail-recursive implementation, because we must now return after evaluating
     the final expression in a sequence in order to undo the (useless) register
     saves. These extra saves will accumulate during a nest of procedure calls.
     Consequently, processes such as @c(sqrt-iter) will require space proportional
     to the number of iterations rather than requiring constant space.  This
     difference can be significant. For example, with tail recursion, an infinite
     loop can be expressed using only the procedure-call mechanism:

     ..src > scheme
       (define (count n)
         (newline)
         (display n)
         (count (+ n 1)))
     < src..

     Without tail recursion, such a procedure would eventually run out of stack
     space, and expressing a true iteration would require some control mechanism
     other than procedure call.

*** 5.4.3 <> Conditionals, Assignments, and Definitions

    As with the metacircular evaluator, special forms are handled by selectively
    evaluating fragments of the expression. For an @c(if) expression, we must
    evaluate the predicate and decide, based on the value of predicate, whether to
    evaluate the consequent or the alternative.

    Before evaluating the predicate, we save the @c(if) expression itself so that
    we can later extract the consequent or alternative. We also save the
    environment, which we will need later in order to evaluate the consequent or
    the alternative, and we save @c(continue), which we will need later in order
    to return to the evaluation of the expression that is waiting for the value of
    the @c(if).

    ..src > scheme
      ev-if
        (save exp)   ; save expression for later
        (save env)
        (save continue)
        (assign continue (label ev-if-decide))
        (assign exp (op if-predicate) (reg exp))
        ; evaluate the predicate:
        (goto (label eval-dispatch))
    < src..

    When we return from evaluating the predicate, we test whether it was true or
    false and, depending on the result, place either the consequent or the
    alternative in @c(exp) before going to @c(eval-dispatch). Notice that
    restoring @c(env) and @c(continue) here sets up @c(eval-dispatch) to have the
    correct environment and to continue at the right place to receive the value of
    the @c(if) expression.

    ..src > scheme
      ev-if-decide
        (restore continue)
        (restore env)
        (restore exp)
        (test (op true?) (reg val))
        (branch (label ev-if-consequent))
      ev-if-alternative
        (assign exp (op if-alternative) (reg exp))
        (goto (label eval-dispatch))
      ev-if-consequent
        (assign exp (op if-consequent) (reg exp))
        (goto (label eval-dispatch))
    < src..

**** Assignments and definitions

     Assignments are handled by @c(ev-assignment), which is reached from
     @c(eval-dispatch) with the assignment expression in @c(exp). The code at
     @c(ev-assignment) first evaluates the value part of the expression and then
     installs the new value in the environment. @c(Set-variable-value!) is assumed
     to be available as a machine operation.

     ..src > scheme
       ev-assignment
         (assign unev
                 (op assignment-variable)
                 (reg exp))
         (save unev)   ; save variable for later
         (assign exp
                 (op assignment-value)
                 (reg exp))
         (save env)
         (save continue)
         (assign continue
                 (label ev-assignment-1))
         ; evaluate the assignment value:
         (goto (label eval-dispatch))
       ev-assignment-1
         (restore continue)
         (restore env)
         (restore unev)
         (perform (op set-variable-value!)
                  (reg unev)
                  (reg val)
                  (reg env))
         (assign val
                 (const ok))
         (goto (reg continue))
     < src..

     Definitions are handled in a similar way:

     ..src > scheme
       ev-definition
         (assign unev
                 (op definition-variable)
                 (reg exp))
         (save unev)   ; save variable for later
         (assign exp
                 (op definition-value)
                 (reg exp))
         (save env)
         (save continue)
         (assign continue (label ev-definition-1))
         ; evaluate the definition value:
         (goto (label eval-dispatch))
       ev-definition-1
         (restore continue)
         (restore env)
         (restore unev)
         (perform (op define-variable!)
                  (reg unev)
                  (reg val)
                  (reg env))
         (assign val (const ok))
         (goto (reg continue))
     < src..

     :: @t(Exercise 5.23) :: Extend the evaluator to handle derived expressions
        such as @c(cond), @c(let), and so on (@l(#4.1.2)). You may @"(cheat) and
        assume that the syntax transformers such as @c(cond->if) are available as
        machine operations.@n(313)

     :: @t(Exercise 5.24) :: Implement @c(cond) as a new basic special form without
        reducing it to @c(if). You will have to construct a loop that tests the
        predicates of successive @c(cond) clauses until you find one that is true,
        and then use @c(ev-sequence) to evaluate the actions of the clause.

     :: @t(Exercise 5.25) :: Modify the evaluator so that it uses normal-order
        evaluation, based on the lazy evaluator of @l(#4.2).

*** 5.4.4 <> Running the Evaluator

    With the implementation of the explicit-control evaluator we come to the end
    of a development, begun in @l(#Chapter 1), in which we have explored
    successively more precise models of the evaluation process. We started with
    the relatively informal substitution model, then extended this in
    @l(#Chapter 3) to the environment model, which enabled us to deal with state
    and change. In the metacircular evaluator of @l(#Chapter 4), we used Scheme
    itself as a language for making more explicit the environment structure
    constructed during evaluation of an expression. Now, with register machines,
    we have taken a close look at the evaluator's mechanisms for storage
    management, argument passing, and control. At each new level of description,
    we have had to raise issues and resolve ambiguities that were not apparent at
    the previous, less precise treatment of evaluation. To understand the behavior
    of the explicit-control evaluator, we can simulate it and monitor its
    performance.

    We will install a driver loop in our evaluator machine. This plays the role of
    the @c(driver-loop) procedure of @l(#4.1.4). The evaluator will repeatedly
    print a prompt, read an expression, evaluate the expression by going to
    @c(eval-dispatch), and print the result. The following instructions form the
    beginning of the explicit-control evaluator's controller sequence:@n(314)

    ..src > scheme
      read-eval-print-loop
        (perform (op initialize-stack))
        (perform (op prompt-for-input)
                 (const ";;; EC-Eval input:"))
        (assign exp (op read))
        (assign env (op get-global-environment))
        (assign continue (label print-result))
        (goto (label eval-dispatch))
      print-result
        (perform (op announce-output)
                 (const ";;; EC-Eval value:"))
        (perform (op user-print) (reg val))
        (goto (label read-eval-print-loop))
    < src..

    When we encounter an error in a procedure (such as the @"(unknown procedure
    type error) indicated at @c(apply-dispatch)), we print an error message and
    return to the driver loop.@n(315)

    ..src > scheme
      unknown-expression-type
        (assign
         val
         (const unknown-expression-type-error))
        (goto (label signal-error))
      unknown-procedure-type
        ; clean up stack (from apply-dispatch):
        (restore continue)
        (assign
         val
         (const unknown-procedure-type-error))
        (goto (label signal-error))
      signal-error
        (perform (op user-print) (reg val))
        (goto (label read-eval-print-loop))
    < src..

    For the purposes of the simulation, we initialize the stack each time through
    the driver loop, since it might not be empty after an error (such as an
    undefined variable) interrupts an evaluation.@n(316)

    If we combine all the code fragments presented in @l(#5.4.1)--@l(#5.4.4), we
    can create an evaluator machine model that we can run using the
    register-machine simulator of @l(#5.2).

    ..src > scheme
      (define eceval
        (make-machine
         '(exp env val proc argl continue unev)
         eceval-operations
         '(read-eval-print-loop
           ⟨entire machine controller
            as given above⟩)))
    < src..

    We must define Scheme procedures to simulate the operations used as primitives
    by the evaluator. These are the same procedures we used for the metacircular
    evaluator in @l(#4.1), together with the few additional ones defined in
    footnotes throughout @l(#5.4).

    ..src > scheme
      (define eceval-operations
        (list (list 'self-evaluating?
                    self-evaluating)
              ⟨@e(complete list of operations)
               @e(for eceval machine)⟩))
    < src..

    Finally, we can initialize the global environment and run the evaluator:

    ..srci > scheme
      > (define the-global-environment
      ^    (setup-environment))
      > (start eceval)

      ;;; EC-Eval input:
      > (define (append x y)
      ^   (if (null? x)
      ^       y
      ^       (cons (car x) (append (cdr x) y))))
      ;;; EC-Eval value:
      ok

      ;;; EC-Eval input:
      > (append '(a b c) '(d e f))
      ;;; EC-Eval value:
      (a b c d e f)
    < srci..

    Of course, evaluating expressions in this way will take much longer than if we
    had directly typed them into Scheme, because of the multiple levels of
    simulation involved. Our expressions are evaluated by the
    explicit-control-evaluator machine, which is being simulated by a Scheme
    program, which is itself being evaluated by the Scheme interpreter.

**** Monitoring the performance of the evaluator

     Simulation can be a powerful tool to guide the implementation of evaluators.
     Simulations make it easy not only to explore variations of the
     register-machine design but also to monitor the performance of the simulated
     evaluator. For example, one important factor in performance is how efficiently
     the evaluator uses the stack. We can observe the number of stack operations
     required to evaluate various expressions by defining the evaluator register
     machine with the version of the simulator that collects statistics on stack
     use (@l(#5.2.4)), and adding an instruction at the evaluator's
     @c(print-result) entry point to print the statistics:

     ..src > scheme
       print-result
         ; added instruction:
         (perform (op print-stack-statistics))
         (perform (op announce-output)
                  (const ";;; EC-Eval value:"))
         … ; same as before
     < src..

     Interactions with the evaluator now look like this:

     ..srci > scheme
       ;;; EC-Eval input:
       > (define (factorial n)
       ^   (if (= n 1) 1 (* (factorial (- n 1)) n)))
       (total-pushes = 3, maximum-depth = 3)

       ;;; EC-Eval value:
       ok

       ;;; EC-Eval input:
       > (factorial 5)
       (total-pushes = 144, maximum-depth = 28)

       ;;; EC-Eval value:
       120
     < srci..

     Note that the driver loop of the evaluator reinitializes the stack at the
     start of each interaction, so that the statistics printed will refer only to
     stack operations used to evaluate the previous expression.

     :: @t(Exercise 5.26) :: Use the monitored stack to explore the tail-recursive
        property of the evaluator (@l(#5.4.2)).  Start the evaluator and define the
        iterative @c(factorial) procedure from @l(#1.2.1):

        ..src > scheme
          (define (factorial n)
            (define (iter product counter)
              (if (> counter n)
                  product
                  (iter (* counter product)
                        (+ counter 1))))
            (iter 1 1))
        < src..

        Run the procedure with some small values of @m(n). Record the maximum stack
        depth and the number of pushes required to compute @m(n!) for each of these
        values.

        1. You will find that the maximum depth required to evaluate @m(n!) is
           independent of @m(n). What is that depth?

        2. Determine from your data a formula in terms of @m(n) for the total
           number of push operations used in evaluating @m(n!) for any @m(n ≥
           1). Note that the number of operations used is a linear function of
           @m(n) and is thus determined by two constants.

     :: @t(Exercise 5.27) :: For comparison with @l(#Exercise 5.26), explore the
        behavior of the following procedure for computing factorials recursively:

        ..src > scheme
          (define (factorial n)
            (if (= n 1)
                1
                (* (factorial (- n 1)) n)))
        < src..

        By running this procedure with the monitored stack, determine, as a
        function of @m(n), the maximum depth of the stack and the total number of
        pushes used in evaluating @m(n!) for @m(n ≥ 1). (Again, these functions
        will be linear.)  Summarize your experiments by filling in the following
        table with the appropriate expressions in terms of @m(n):

        ..example >
                         Maximum depth       Number of pushes

          Recursive
          factorial

          Iterative
          factorial
        < example..

        The maximum depth is a measure of the amount of space used by the evaluator
        in carrying out the computation, and the number of pushes correlates well
        with the time required.

     :: @t(Exercise 5.28) :: Modify the definition of the evaluator by changing
        @c(eval-sequence) as described in @l(#5.4.2) so that the evaluator is no
        longer tail-recursive. Rerun your experiments from @l(#Exercise 5.26) and
        @l(#Exercise 5.27) to demonstrate that both versions of the @c(factorial)
        procedure now require space that grows linearly with their input.

     :: @t(Exercise 5.29) :: Monitor the stack operations in the tree-recursive
        Fibonacci computation:

        ..src > scheme
          (define (fib n)
            (if (< n 2)
                n
                (+ (fib (- n 1)) (fib (- n 2)))))
        < src..

        1. Give a formula in terms of @m(n) for the maximum depth of the stack
           required to compute @m[Fib(n)] for @m(n ≥ 2). Hint: In @l(#1.2.2) we
           argued that the space used by this process grows linearly with @m(n).

        2. Give a formula for the total number of pushes used to compute @m[Fib(n)]
           for @m(n ≥ 2). You should find that the number of pushes (which
           correlates well with the time used) grows exponentially with
           @m(n). Hint: Let @m[S(n)] be the number of pushes used in computing
           @m[Fib(n)]. You should be able to argue that there is a formula that
           expresses @m[S(n)] in terms of @m[S(n - 1)], @m[S(n - 2)], and some
           fixed @"(overhead) constant @m(k) that is independent of @m(n). Give the
           formula, and say what @m(k) is. Then show that @m[S(n)] can be expressed
           as @m[a⋅Fib(n + 1) + b] and give the values of @m(a) and @m(b).

     :: @t(Exercise 5.30) :: Our evaluator currently catches and signals only two
        kinds of errors––unknown expression types and unknown procedure
        types. Other errors will take us out of the evaluator read-eval-print
        loop. When we run the evaluator using the register-machine simulator, these
        errors are caught by the underlying Scheme system. This is analogous to the
        computer crashing when a user program makes an error.@n(317) It is a large
        project to make a real error system work, but it is well worth the effort
        to understand what is involved here.

        1. Errors that occur in the evaluation process, such as an attempt to
           access an unbound variable, could be caught by changing the lookup
           operation to make it return a distinguished condition code, which cannot
           be a possible value of any user variable. The evaluator can test for
           this condition code and then do what is necessary to go to
           @c(signal-error). Find all of the places in the evaluator where such a
           change is necessary and fix them. This is lots of work.

        2. Much worse is the problem of handling errors that are signaled by
           applying primitive procedures, such as an attempt to divide by zero or
           an attempt to extract the @c(car) of a symbol. In a professionally
           written high-quality system, each primitive application is checked for
           safety as part of the primitive. For example, every call to @c(car)
           could first check that the argument is a pair. If the argument is not a
           pair, the application would return a distinguished condition code to the
           evaluator, which would then report the failure. We could arrange for
           this in our register-machine simulator by making each primitive
           procedure check for applicability and returning an appropriate
           distinguished condition code on failure. Then the @c(primitive-apply)
           code in the evaluator can check for the condition code and go to
           @c(signal-error) if necessary. Build this structure and make it
           work. This is a major project.

** 5.5 <> Compilation

   The explicit-control evaluator of @l(#5.4) is a register machine whose
   controller interprets Scheme programs. In this section we will see how to run
   Scheme programs on a register machine whose controller is not a Scheme
   interpreter.

   The explicit-control evaluator machine is universal––it can carry out any
   computational process that can be described in Scheme. The evaluator's
   controller orchestrates the use of its data paths to perform the desired
   computation. Thus, the evaluator's data paths are universal: They are
   sufficient to perform any computation we desire, given an appropriate
   controller.@n(318)

   Commercial general-purpose computers are register machines organized around a
   collection of registers and operations that constitute an efficient and
   convenient universal set of data paths. The controller for a general-purpose
   machine is an interpreter for a register-machine language like the one we have
   been using. This language is called the @e(native language) of the machine, or
   simply @e(machine language). Programs written in machine language are
   sequences of instructions that use the machine's data paths. For example, the
   explicit-control evaluator's instruction sequence can be thought of as a
   machine-language program for a general-purpose computer rather than as the
   controller for a specialized interpreter machine.

   There are two common strategies for bridging the gap between higher-level
   languages and register-machine languages. The explicit-control evaluator
   illustrates the strategy of interpretation. An interpreter written in the
   native language of a machine configures the machine to execute programs
   written in a language (called the @e(source language)) that may differ from
   the native language of the machine performing the evaluation. The primitive
   procedures of the source language are implemented as a library of subroutines
   written in the native language of the given machine. A program to be
   interpreted (called the @e(source program)) is represented as a data
   structure. The interpreter traverses this data structure, analyzing the source
   program. As it does so, it simulates the intended behavior of the source
   program by calling appropriate primitive subroutines from the library.

   In this section, we explore the alternative strategy of @e(compilation).  A
   compiler for a given source language and machine translates a source program
   into an equivalent program (called the @e(object program)) written in the
   machine's native language. The compiler that we implement in this section
   translates programs written in Scheme into sequences of instructions to be
   executed using the explicit-control evaluator machine's data paths.@n(319)

   Compared with interpretation, compilation can provide a great increase in the
   efficiency of program execution, as we will explain below in the overview of
   the compiler. On the other hand, an interpreter provides a more powerful
   environment for interactive program development and debugging, because the
   source program being executed is available at run time to be examined and
   modified. In addition, because the entire library of primitives is present,
   new programs can be constructed and added to the system during debugging.

   In view of the complementary advantages of compilation and interpretation,
   modern program-development environments pursue a mixed strategy. Lisp
   interpreters are generally organized so that interpreted procedures and
   compiled procedures can call each other. This enables a programmer to compile
   those parts of a program that are assumed to be debugged, thus gaining the
   efficiency advantage of compilation, while retaining the interpretive mode of
   execution for those parts of the program that are in the flux of interactive
   development and debugging. In @l(#5.5.7), after we have implemented the
   compiler, we will show how to interface it with our interpreter to produce an
   integrated interpreter-compiler development system.

*** An overview of the compiler

    Our compiler is much like our interpreter, both in its structure and in the
    function it performs. Accordingly, the mechanisms used by the compiler for
    analyzing expressions will be similar to those used by the interpreter.
    Moreover, to make it easy to interface compiled and interpreted code, we will
    design the compiler to generate code that obeys the same conventions of
    register usage as the interpreter: The environment will be kept in the @c(env)
    register, argument lists will be accumulated in @c(argl), a procedure to be
    applied will be in @c(proc), procedures will return their answers in @c(val),
    and the location to which a procedure should return will be kept in
    @c(continue). In general, the compiler translates a source program into an
    object program that performs essentially the same register operations as would
    the interpreter in evaluating the same source program.

    This description suggests a strategy for implementing a rudimentary compiler:
    We traverse the expression in the same way the interpreter does. When we
    encounter a register instruction that the interpreter would perform in
    evaluating the expression, we do not execute the instruction but instead
    accumulate it into a sequence. The resulting sequence of instructions will be
    the object code. Observe the efficiency advantage of compilation over
    interpretation. Each time the interpreter evaluates an expression––for
    example, @c[(f 84 96)]––it performs the work of classifying the expression
    (discovering that this is a procedure application) and testing for the end of
    the operand list (discovering that there are two operands). With a compiler,
    the expression is analyzed only once, when the instruction sequence is
    generated at compile time. The object code produced by the compiler contains
    only the instructions that evaluate the operator and the two operands,
    assemble the argument list, and apply the procedure (in @c(proc)) to the
    arguments (in @c(argl)).

    This is the same kind of optimization we implemented in the analyzing
    evaluator of @l(#4.1.7). But there are further opportunities to gain
    efficiency in compiled code. As the interpreter runs, it follows a process
    that must be applicable to any expression in the language. In contrast, a
    given segment of compiled code is meant to execute some particular
    expression. This can make a big difference, for example in the use of the
    stack to save registers. When the interpreter evaluates an expression, it must
    be prepared for any contingency. Before evaluating a subexpression, the
    interpreter saves all registers that will be needed later, because the
    subexpression might require an arbitrary evaluation. A compiler, on the other
    hand, can exploit the structure of the particular expression it is processing
    to generate code that avoids unnecessary stack operations.

    As a case in point, consider the combination @c[(f 84 96)]. Before the
    interpreter evaluates the operator of the combination, it prepares for this
    evaluation by saving the registers containing the operands and the
    environment, whose values will be needed later. The interpreter then evaluates
    the operator to obtain the result in @c(val), restores the saved registers,
    and finally moves the result from @c(val) to @c(proc). However, in the
    particular expression we are dealing with, the operator is the symbol @c(f),
    whose evaluation is accomplished by the machine operation
    @c(lookup-variable-value), which does not alter any registers. The compiler
    that we implement in this section will take advantage of this fact and
    generate code that evaluates the operator using the instruction

    ..src > scheme
      (assign proc
              (op lookup-variable-value)
              (const f)
              (reg env))
    < src..

    This code not only avoids the unnecessary saves and restores but also assigns
    the value of the lookup directly to @c(proc), whereas the interpreter would
    obtain the result in @c(val) and then move this to @c(proc).

    A compiler can also optimize access to the environment. Having analyzed the
    code, the compiler can in many cases know in which frame a particular variable
    will be located and access that frame directly, rather than performing the
    @c(lookup-variable-value) search. We will discuss how to implement such
    variable access in @l(#5.5.6). Until then, however, we will focus on the kind
    of register and stack optimizations described above. There are many other
    optimizations that can be performed by a compiler, such as coding primitive
    operations @"(in line) instead of using a general @c(apply) mechanism (see
    @l(#Exercise 5.38)); but we will not emphasize these here. Our main goal in
    this section is to illustrate the compilation process in a simplified (but
    still interesting) context.

*** 5.5.1 <> Structure of the Compiler

    In @l(#4.1.7) we modified our original metacircular interpreter to separate
    analysis from execution. We analyzed each expression to produce an execution
    procedure that took an environment as argument and performed the required
    operations. In our compiler, we will do essentially the same analysis. Instead
    of producing execution procedures, however, we will generate sequences of
    instructions to be run by our register machine.

    The procedure @c(compile) is the top-level dispatch in the compiler. It
    corresponds to the @c(eval) procedure of @l(#4.1.1), the @c(analyze) procedure
    of @l(#4.1.7), and the @c(eval-dispatch) entry point of the
    explicit-control-evaluator in @l(#5.4.1). The compiler, like the interpreters,
    uses the expression-syntax procedures defined in @l(#4.1.2).@n(320)
    @c(Compile) performs a case analysis on the syntactic type of the expression
    to be compiled. For each type of expression, it dispatches to a specialized
    @e(code generator):

    ..src > scheme
      (define (compile exp target linkage)
        (cond ((self-evaluating? exp)
               (compile-self-evaluating
                exp target linkage))
              ((quoted? exp)
               (compile-quoted exp target linkage))
              ((variable? exp)
               (compile-variable
                exp target linkage))
              ((assignment? exp)
               (compile-assignment
                exp target linkage))
              ((definition? exp)
               (compile-definition
                exp target linkage))
              ((if? exp)
               (compile-if exp target linkage))
              ((lambda? exp)
               (compile-lambda exp target linkage))
              ((begin? exp)
               (compile-sequence
                (begin-actions exp) target linkage))
              ((cond? exp)
               (compile
                (cond->if exp) target linkage))
              ((application? exp)
               (compile-application
                exp target linkage))
              (else
               (error "Unknown expression type:
                       COMPILE"
                      exp))))
    < src..

**** Targets and linkages

     @c(Compile) and the code generators that it calls take two arguments in
     addition to the expression to compile. There is a @e(target), which specifies
     the register in which the compiled code is to return the value of the
     expression. There is also a @e(linkage descriptor), which describes how the
     code resulting from the compilation of the expression should proceed when it
     has finished its execution. The linkage descriptor can require that the code
     do one of the following three things:

     - continue at the next instruction in sequence (this is specified by the
       linkage descriptor @c(next)),

     - return from the procedure being compiled (this is specified by the linkage
       descriptor @c(return)), or

     - jump to a named entry point (this is specified by using the designated label
       as the linkage descriptor).


     For example, compiling the expression @c(5) (which is self-evaluating) with a
     target of the @c(val) register and a linkage of @c(next) should produce the
     instruction

     ..src > scheme
       (assign val (const 5))
     < src..

     Compiling the same expression with a linkage of @c(return) should produce the
     instructions

     ..src > scheme
       (assign val (const 5))
       (goto (reg continue))
     < src..

     In the first case, execution will continue with the next instruction in the
     sequence. In the second case, we will return from a procedure call. In both
     cases, the value of the expression will be placed into the target @c(val)
     register.

**** Instruction sequences and stack usage

     Each code generator returns an @e(instruction sequence) containing the object
     code it has generated for the expression. Code generation for a compound
     expression is accomplished by combining the output from simpler code
     generators for component expressions, just as evaluation of a compound
     expression is accomplished by evaluating the component expressions.

     The simplest method for combining instruction sequences is a procedure called
     @c(append-instruction-sequences). It takes as arguments any number of
     instruction sequences that are to be executed sequentially; it appends them
     and returns the combined sequence. That is, if @m[⟨seq₁⟩] and @m[⟨seq₂⟩] are
     sequences of instructions, then evaluating

     ..src > scheme
       (append-instruction-sequences ⟨seq₁⟩ ⟨seq₂⟩)
     < src..

     produces the sequence

     ..src > scheme
       ⟨seq₁⟩
       ⟨seq₂⟩
     < src..

     Whenever registers might need to be saved, the compiler's code generators use
     @c(preserving), which is a more subtle method for combining instruction
     sequences. @c(Preserving) takes three arguments: a set of registers and two
     instruction sequences that are to be executed sequentially. It appends the
     sequences in such a way that the contents of each register in the set is
     preserved over the execution of the first sequence, if this is needed for the
     execution of the second sequence. That is, if the first sequence modifies the
     register and the second sequence actually needs the register's original
     contents, then @c(preserving) wraps a @c(save) and a @c(restore) of the
     register around the first sequence before appending the sequences.  Otherwise,
     @c(preserving) simply returns the appended instruction sequences.  Thus, for
     example, @c[(preserving (list ⟨reg₁⟩ ⟨reg₂⟩) ⟨seg₁⟩ ⟨seg₂⟩)] produces one of
     the following four sequences of instructions, depending on how @m[⟨seq₁⟩] and
     @m[⟨seq₂⟩] use @m[⟨reg₁⟩] and @m[⟨reg₂⟩]:

     ..example >
       <seq₁> | (save <reg₁>)    | (save <reg₂>)    | (save <reg₂>)
       <seq₂> | <seq₁>           | <seq₁>           | (save <reg₁>)
              | (restore <reg₁>) | (restore <reg₂>) | <seq₁>
              | <seq₂>           | <seq₂>           | (restore <reg₁>)
              |                  |                  | (restore <reg₂>)
              |                  |                  | <seq₂>
     < example..

     By using @c(preserving) to combine instruction sequences the compiler avoids
     unnecessary stack operations. This also isolates the details of whether or not
     to generate @c(save) and @c(restore) instructions within the @c(preserving)
     procedure, separating them from the concerns that arise in writing each of the
     individual code generators. In fact no @c(save) or @c(restore) instructions
     are explicitly produced by the code generators.

     In principle, we could represent an instruction sequence simply as a list of
     instructions. @c(Append-instruction-sequences) could then combine instruction
     sequences by performing an ordinary list @c(append). However, @c(preserving)
     would then be a complex operation, because it would have to analyze each
     instruction sequence to determine how the sequence uses its
     registers. @c(Preserving) would be inefficient as well as complex, because it
     would have to analyze each of its instruction sequence arguments, even though
     these sequences might themselves have been constructed by calls to
     @c(preserving), in which case their parts would have already been analyzed.
     To avoid such repetitious analysis we will associate with each instruction
     sequence some information about its register use. When we construct a basic
     instruction sequence we will provide this information explicitly, and the
     procedures that combine instruction sequences will derive register-use
     information for the combined sequence from the information associated with the
     component sequences.

     An instruction sequence will contain three pieces of information:

     - the set of registers that must be initialized before the instructions in the
       sequence are executed (these registers are said to be @e(needed) by the
       sequence),

     - the set of registers whose values are modified by the instructions in the
       sequence, and

     - the actual instructions (also called @e(statements)) in the sequence.


     We will represent an instruction sequence as a list of its three parts. The
     constructor for instruction sequences is thus

     ..src > scheme
       (define (make-instruction-sequence
                needs modifies statements)
         (list needs modifies statements))
     < src..

     For example, the two-instruction sequence that looks up the value of the
     variable @c(x) in the current environment, assigns the result to @c(val), and
     then returns, requires registers @c(env) and @c(continue) to have been
     initialized, and modifies register @c(val). This sequence would therefore be
     constructed as

     ..src > scheme
       (make-instruction-sequence
        '(env continue)
        '(val)
        '((assign val
                  (op lookup-variable-value)
                  (const x)
                  (reg env))
          (goto (reg continue))))
     < src..

     We sometimes need to construct an instruction sequence with no statements:

     ..src > scheme
       (define (empty-instruction-sequence)
         (make-instruction-sequence '() '() '()))
     < src..

     The procedures for combining instruction sequences are shown in @l(#5.5.4).

     :: @t(Exercise 5.31) :: In evaluating a procedure application, the
        explicit-control evaluator always saves and restores the @c(env) register
        around the evaluation of the operator, saves and restores @c(env) around
        the evaluation of each operand (except the final one), saves and restores
        @c(argl) around the evaluation of each operand, and saves and restores
        @c(proc) around the evaluation of the operand sequence. For each of the
        following combinations, say which of these @c(save) and @c(restore)
        operations are superfluous and thus could be eliminated by the compiler's
        @c(preserving) mechanism:

        ..src > scheme
          (f 'x 'y)
          ((f) 'x 'y)
          (f (g 'x) y)
          (f (g 'x) 'y)
        < src..

     :: @t(Exercise 5.32) :: Using the @c(preserving) mechanism, the compiler will
        avoid saving and restoring @c(env) around the evaluation of the operator of
        a combination in the case where the operator is a symbol. We could also
        build such optimizations into the evaluator. Indeed, the explicit-control
        evaluator of @l(#5.4) already performs a similar optimization, by treating
        combinations with no operands as a special case.

        1. Extend the explicit-control evaluator to recognize as a separate class
           of expressions combinations whose operator is a symbol, and to take
           advantage of this fact in evaluating such expressions.

        2. Alyssa P. Hacker suggests that by extending the evaluator to recognize
           more and more special cases we could incorporate all the compiler's
           optimizations, and that this would eliminate the advantage of
           compilation altogether. What do you think of this idea?

*** 5.5.2 <> Compiling Expressions

    In this section and the next we implement the code generators to which the
    @c(compile) procedure dispatches.

**** Compiling linkage code

     In general, the output of each code generator will end with
     instructions––generated by the procedure @c(compile-linkage)––that implement
     the required linkage. If the linkage is @c(return) then we must generate the
     instruction @c[(goto (reg continue))]. This needs the @c(continue) register
     and does not modify any registers. If the linkage is @c(next), then we needn't
     include any additional instructions. Otherwise, the linkage is a label, and we
     generate a @c(goto) to that label, an instruction that does not need or modify
     any registers.@n(321)

     ..src > scheme
       (define (compile-linkage linkage)
         (cond ((eq? linkage 'return)
                (make-instruction-sequence
                 '(continue)
                 '()
                 '((goto (reg continue)))))
               ((eq? linkage 'next)
                (empty-instruction-sequence))
               (else
                (make-instruction-sequence '() '()
                 `((goto (label ,linkage)))))))
     < src..

     The linkage code is appended to an instruction sequence by @c(preserving) the
     @c(continue) register, since a @c(return) linkage will require the
     @c(continue) register: If the given instruction sequence modifies @c(continue)
     and the linkage code needs it, @c(continue) will be saved and restored.

     ..src > scheme
       (define (end-with-linkage
                linkage instruction-sequence)
         (preserving '(continue)
          instruction-sequence
          (compile-linkage linkage)))
     < src..

**** Compiling simple expressions

     The code generators for self-evaluating expressions, quotations, and variables
     construct instruction sequences that assign the required value to the target
     register and then proceed as specified by the linkage descriptor.

     ..src > scheme
       (define (compile-self-evaluating
                exp target linkage)
         (end-with-linkage
          linkage (make-instruction-sequence
                   '()
                   (list target)
                   `((assign ,target (const ,exp))))))

       (define (compile-quoted exp target linkage)
         (end-with-linkage
          linkage
          (make-instruction-sequence
           '()
           (list target)
           `((assign
              ,target
              (const ,(text-of-quotation exp)))))))

       (define (compile-variable
                exp target linkage)
         (end-with-linkage
          linkage
          (make-instruction-sequence
           '(env)
           (list target)
           `((assign ,target
                     (op lookup-variable-value)
                     (const ,exp)
                     (reg env))))))
     < src..

     All these assignment instructions modify the target register, and the one that
     looks up a variable needs the @c(env) register.

     Assignments and definitions are handled much as they are in the interpreter.
     We recursively generate code that computes the value to be assigned to the
     variable, and append to it a two-instruction sequence that actually sets or
     defines the variable and assigns the value of the whole expression (the symbol
     @c(ok)) to the target register. The recursive compilation has target @c(val)
     and linkage @c(next) so that the code will put its result into @c(val) and
     continue with the code that is appended after it. The appending is done
     preserving @c(env), since the environment is needed for setting or defining
     the variable and the code for the variable value could be the compilation of a
     complex expression that might modify the registers in arbitrary ways.

     ..src > scheme
       (define (compile-assignment
                exp target linkage)
         (let ((var (assignment-variable exp))
               (get-value-code
                (compile (assignment-value exp)
                         'val
                         'next)))
           (end-with-linkage
            linkage
            (preserving
             '(env)
             get-value-code
             (make-instruction-sequence
              '(env val)
              (list target)
              `((perform (op set-variable-value!)
                         (const ,var)
                         (reg val)
                         (reg env))
                (assign ,target (const ok))))))))

       (define (compile-definition
                exp target linkage)
         (let ((var (definition-variable exp))
               (get-value-code
                (compile (definition-value exp)
                         'val
                         'next)))
           (end-with-linkage
            linkage
            (preserving
             '(env)
             get-value-code
             (make-instruction-sequence
              '(env val)
              (list target)
              `((perform (op define-variable!)
                         (const ,var)
                         (reg val)
                         (reg env))
                (assign ,target (const ok))))))))
     < src..

     The appended two-instruction sequence requires @c(env) and @c(val) and
     modifies the target. Note that although we preserve @c(env) for this sequence,
     we do not preserve @c(val), because the @c(get-value-code) is designed to
     explicitly place its result in @c(val) for use by this sequence.  (In fact, if
     we did preserve @c(val), we would have a bug, because this would cause the
     previous contents of @c(val) to be restored right after the @c(get-value-code)
     is run.)

**** Compiling conditional expressions

     The code for an @c(if) expression compiled with a given target and linkage has
     the form

     ..src > scheme
       ⟨compilation of predicate,
        target val, linkage next⟩
        (test (op false?) (reg val))
        (branch (label false-branch))
       true-branch
        ⟨compilation of consequent with given
         target and given linkage or after-if⟩
       false-branch
        ⟨compilation of alternative
         with given target and linkage⟩
       after-if
     < src..

     To generate this code, we compile the predicate, consequent, and alternative,
     and combine the resulting code with instructions to test the predicate result
     and with newly generated labels to mark the true and false branches and the
     end of the conditional.@n(322) In this arrangement of code, we must branch
     around the true branch if the test is false. The only slight complication is
     in how the linkage for the true branch should be handled. If the linkage for
     the conditional is @c(return) or a label, then the true and false branches
     will both use this same linkage.  If the linkage is @c(next), the true branch
     ends with a jump around the code for the false branch to the label at the end
     of the conditional.

     ..src > scheme
       (define (compile-if exp target linkage)
         (let ((t-branch (make-label 'true-branch))
               (f-branch (make-label 'false-branch))
               (after-if (make-label 'after-if)))
           (let ((consequent-linkage
                  (if (eq? linkage 'next)
                      after-if
                      linkage)))
             (let ((p-code
                    (compile (if-predicate exp)
                             'val
                             'next))
                   (c-code
                    (compile (if-consequent exp)
                             target
                             consequent-linkage))
                   (a-code
                    (compile (if-alternative exp)
                             target
                             linkage)))
               (preserving
                '(env continue)
                p-code
                (append-instruction-sequences
                 (make-instruction-sequence
                  '(val)
                  '()
                  `((test (op false?) (reg val))
                    (branch (label ,f-branch))))
                 (parallel-instruction-sequences
                  (append-instruction-sequences
                   t-branch c-code)
                  (append-instruction-sequences
                   f-branch a-code))
                 after-if))))))
     < src..

     @c(Env) is preserved around the predicate code because it could be needed by
     the true and false branches, and @c(continue) is preserved because it could be
     needed by the linkage code in those branches. The code for the true and false
     branches (which are not executed sequentially) is appended using a special
     combiner @c(parallel-instruction-sequences) described in @l(#5.5.4).

     Note that @c(cond) is a derived expression, so all that the compiler needs to
     do handle it is to apply the @c(cond->if) transformer (from @l(#4.1.2)) and
     compile the resulting @c(if) expression.

**** Compiling sequences

     The compilation of sequences (from procedure bodies or explicit @c(begin)
     expressions) parallels their evaluation. Each expression of the sequence is
     compiled––the last expression with the linkage specified for the sequence, and
     the other expressions with linkage @c(next) (to execute the rest of the
     sequence). The instruction sequences for the individual expressions are
     appended to form a single instruction sequence, such that @c(env) (needed for
     the rest of the sequence) and @c(continue) (possibly needed for the linkage at
     the end of the sequence) are preserved.

     ..src > scheme
       (define (compile-sequence seq target linkage)
         (if (last-exp? seq)
             (compile (first-exp seq) target linkage)
             (preserving '(env continue)
              (compile (first-exp seq) target 'next)
              (compile-sequence (rest-exps seq)
                                target
                                linkage))))
     < src..

**** Compiling @c(lambda) expressions

     @c(Lambda) expressions construct procedures. The object code for a @c(lambda)
     expression must have the form

     ..src > scheme
       ⟨construct procedure object
        and assign it to target register⟩
       ⟨linkage⟩
     < src..

     When we compile the @c(lambda) expression, we also generate the code for the
     procedure body. Although the body won't be executed at the time of procedure
     construction, it is convenient to insert it into the object code right after
     the code for the @c(lambda). If the linkage for the @c(lambda) expression is a
     label or @c(return), this is fine. But if the linkage is @c(next), we will
     need to skip around the code for the procedure body by using a linkage that
     jumps to a label that is inserted after the body. The object code thus has the
     form

     ..src > scheme
       ⟨construct procedure object
        and assign it to target register⟩
        ⟨code for given linkage⟩ or
         (goto (label after-lambda))
        ⟨compilation of procedure body⟩
       after-lambda
     < src..

     @c(Compile-lambda) generates the code for constructing the procedure object
     followed by the code for the procedure body. The procedure object will be
     constructed at run time by combining the current environment (the environment
     at the point of definition) with the entry point to the compiled procedure
     body (a newly generated label).@n(323)

     ..src > scheme
       (define (compile-lambda exp target linkage)
         (let ((proc-entry
                (make-label 'entry))
               (after-lambda
                (make-label 'after-lambda)))
           (let ((lambda-linkage
                  (if (eq? linkage 'next)
                      after-lambda
                      linkage)))
             (append-instruction-sequences
              (tack-on-instruction-sequence
               (end-with-linkage
                lambda-linkage
                (make-instruction-sequence
                 '(env)
                 (list target)
                 `((assign
                    ,target
                    (op make-compiled-procedure)
                    (label ,proc-entry)
                    (reg env)))))
               (compile-lambda-body exp proc-entry))
              after-lambda))))
     < src..

     @c(Compile-lambda) uses the special combiner @c(tack-on-instruction-sequence)
     rather than @c(append-instruction-sequences) (@l(#5.5.4)) to append the
     procedure body to the @c(lambda) expression code, because the body is not part
     of the sequence of instructions that will be executed when the combined
     sequence is entered; rather, it is in the sequence only because that was a
     convenient place to put it.

     @c(Compile-lambda-body) constructs the code for the body of the procedure.
     This code begins with a label for the entry point. Next come instructions that
     will cause the run-time evaluation environment to switch to the correct
     environment for evaluating the procedure body––namely, the definition
     environment of the procedure, extended to include the bindings of the formal
     parameters to the arguments with which the procedure is called. After this
     comes the code for the sequence of expressions that makes up the procedure
     body. The sequence is compiled with linkage @c(return) and target @c(val) so
     that it will end by returning from the procedure with the procedure result in
     @c(val).

     ..src > scheme
       (define (compile-lambda-body exp proc-entry)
         (let ((formals (lambda-parameters exp)))
           (append-instruction-sequences
            (make-instruction-sequence
             '(env proc argl)
             '(env)
             `(,proc-entry
               (assign env
                       (op compiled-procedure-env)
                       (reg proc))
               (assign env
                       (op extend-environment)
                       (const ,formals)
                       (reg argl)
                       (reg env))))
            (compile-sequence (lambda-body exp)
                              'val
                              'return))))
     < src..

*** 5.5.3 <> Compiling Combinations

    The essence of the compilation process is the compilation of procedure
    applications. The code for a combination compiled with a given target and
    linkage has the form

    ..src > scheme
      ⟨compilation of operator,
       target proc, linkage next⟩
      ⟨evaluate operands and construct
       argument list in argl⟩
      ⟨compilation of procedure call
       with given target and linkage⟩
    < src..

    The registers @c(env), @c(proc), and @c(argl) may have to be saved and
    restored during evaluation of the operator and operands. Note that this is the
    only place in the compiler where a target other than @c(val) is specified.

    The required code is generated by @c(compile-application). This recursively
    compiles the operator, to produce code that puts the procedure to be applied
    into @c(proc), and compiles the operands, to produce code that evaluates the
    individual operands of the application. The instruction sequences for the
    operands are combined (by @c(construct-arglist)) with code that constructs the
    list of arguments in @c(argl), and the resulting argument-list code is
    combined with the procedure code and the code that performs the procedure call
    (produced by @c(compile-procedure-call)). In appending the code sequences, the
    @c(env) register must be preserved around the evaluation of the operator
    (since evaluating the operator might modify @c(env), which will be needed to
    evaluate the operands), and the @c(proc) register must be preserved around the
    construction of the argument list (since evaluating the operands might modify
    @c(proc), which will be needed for the actual procedure application).
    @c(Continue) must also be preserved throughout, since it is needed for the
    linkage in the procedure call.

    ..src > scheme
      (define (compile-application
               exp target linkage)
        (let ((proc-code
               (compile (operator exp) 'proc 'next))
              (operand-codes
               (map (lambda (operand)
                      (compile operand 'val 'next))
                    (operands exp))))
          (preserving
           '(env continue)
           proc-code
           (preserving
            '(proc continue)
            (construct-arglist operand-codes)
            (compile-procedure-call
             target
             linkage)))))
    < src..

    The code to construct the argument list will evaluate each operand into
    @c(val) and then @c(cons) that value onto the argument list being accumulated
    in @c(argl). Since we @c(cons) the arguments onto @c(argl) in sequence, we
    must start with the last argument and end with the first, so that the
    arguments will appear in order from first to last in the resulting
    list. Rather than waste an instruction by initializing @c(argl) to the empty
    list to set up for this sequence of evaluations, we make the first code
    sequence construct the initial @c(argl). The general form of the argument-list
    construction is thus as follows:

    ..src > scheme
      ⟨compilation of last operand, targeted to val⟩
      (assign argl (op list) (reg val))
      ⟨compilation of next operand, targeted to val⟩
      (assign argl (op cons) (reg val) (reg argl))
      …
      ⟨compilation of first operand, targeted to val⟩
      (assign argl (op cons) (reg val) (reg argl))
    < src..

    @c(Argl) must be preserved around each operand evaluation except the first (so
    that arguments accumulated so far won't be lost), and @c(env) must be
    preserved around each operand evaluation except the last (for use by
    subsequent operand evaluations).

    Compiling this argument code is a bit tricky, because of the special treatment
    of the first operand to be evaluated and the need to preserve @c(argl) and
    @c(env) in different places. The @c(construct-arglist) procedure takes as
    arguments the code that evaluates the individual operands. If there are no
    operands at all, it simply emits the instruction

    ..src > scheme
      (assign argl (const ()))
    < src..

    Otherwise, @c(construct-arglist) creates code that initializes @c(argl) with
    the last argument, and appends code that evaluates the rest of the arguments
    and adjoins them to @c(argl) in succession. In order to process the arguments
    from last to first, we must reverse the list of operand code sequences from
    the order supplied by @c(compile-application).

    ..src > scheme
      (define (construct-arglist operand-codes)
        (let ((operand-codes
               (reverse operand-codes)))
          (if (null? operand-codes)
              (make-instruction-sequence
               '()
               '(argl)
               '((assign argl (const ()))))
              (let ((code-to-get-last-arg
                     (append-instruction-sequences
                      (car operand-codes)
                      (make-instruction-sequence
                       '(val)
                       '(argl)
                       '((assign argl
                                 (op list)
                                 (reg val)))))))
                (if (null? (cdr operand-codes))
                    code-to-get-last-arg
                    (preserving
                     '(env)
                     code-to-get-last-arg
                     (code-to-get-rest-args
                      (cdr operand-codes))))))))

      (define (code-to-get-rest-args operand-codes)
        (let ((code-for-next-arg
               (preserving
                '(argl)
                (car operand-codes)
                (make-instruction-sequence
                 '(val argl)
                 '(argl)
                 '((assign argl
                           (op cons)
                           (reg val)
                           (reg argl)))))))
          (if (null? (cdr operand-codes))
              code-for-next-arg
              (preserving
               '(env)
               code-for-next-arg
               (code-to-get-rest-args
                (cdr operand-codes))))))
    < src..

**** Applying procedures

     After evaluating the elements of a combination, the compiled code must apply
     the procedure in @c(proc) to the arguments in @c(argl). The code performs
     essentially the same dispatch as the @c(apply) procedure in the metacircular
     evaluator of @l(#4.1.1) or the @c(apply-dispatch) entry point in the
     explicit-control evaluator of @l(#5.4.1). It checks whether the procedure to
     be applied is a primitive procedure or a compiled procedure. For a primitive
     procedure, it uses @c(apply-primitive-procedure); we will see shortly how it
     handles compiled procedures. The procedure-application code has the following
     form:

     ..src > scheme
       (test (op primitive-procedure?) (reg proc))
        (branch (label primitive-branch))
       compiled-branch
        ⟨code to apply compiled procedure
         with given target and appropriate linkage⟩
       primitive-branch
        (assign ⟨target⟩
                (op apply-primitive-procedure)
                (reg proc)
                (reg argl))
        ⟨linkage⟩
       after-call
     < src..

     Observe that the compiled branch must skip around the primitive branch.
     Therefore, if the linkage for the original procedure call was @c(next), the
     compound branch must use a linkage that jumps to a label that is inserted
     after the primitive branch. (This is similar to the linkage used for the true
     branch in @c(compile-if).)

     ..src > scheme
       (define (compile-procedure-call
                target linkage)
         (let ((primitive-branch
                (make-label 'primitive-branch))
               (compiled-branch
                (make-label 'compiled-branch))
               (after-call
                (make-label 'after-call)))
           (let ((compiled-linkage
                  (if (eq? linkage 'next)
                      after-call
                      linkage)))
             (append-instruction-sequences
              (make-instruction-sequence
               '(proc)
               '()
               `((test
                  (op primitive-procedure?)
                  (reg proc))
                 (branch
                  (label ,primitive-branch))))
              (parallel-instruction-sequences
               (append-instruction-sequences
                compiled-branch
                (compile-proc-appl
                 target
                 compiled-linkage))
               (append-instruction-sequences
                primitive-branch
                (end-with-linkage
                 linkage
                 (make-instruction-sequence
                  '(proc argl)
                  (list target)
                  `((assign
                     ,target
                     (op apply-primitive-procedure)
                     (reg proc)
                     (reg argl)))))))
              after-call))))
     < src..

     The primitive and compound branches, like the true and false branches in
     @c(compile-if), are appended using @c(parallel-instruction-sequences) rather
     than the ordinary @c(append-instruction-sequences), because they will not be
     executed sequentially.

**** Applying compiled procedures

     The code that handles procedure application is the most subtle part of the
     compiler, even though the instruction sequences it generates are very short. A
     compiled procedure (as constructed by @c(compile-lambda)) has an entry point,
     which is a label that designates where the code for the procedure starts. The
     code at this entry point computes a result in @c(val) and returns by executing
     the instruction @c[(goto (reg continue))]. Thus, we might expect the code for
     a compiled-procedure application (to be generated by @c(compile-proc-appl))
     with a given target and linkage to look like this if the linkage is a label

     ..src > scheme
       (assign continue
               (label proc-return))
        (assign val
                (op compiled-procedure-entry)
                (reg proc))
        (goto (reg val))
       proc-return
        (assign ⟨target⟩
                (reg val))   ; included if target is not val
        (goto (label ⟨linkage⟩))   ; linkage code
     < src..

     or like this if the linkage is return.

     ..src > scheme
       (save continue)
        (assign continue
                (label proc-return))
        (assign val
                (op compiled-procedure-entry)
                (reg proc))
        (goto (reg val))
       proc-return
        (assign ⟨target⟩
                (reg val))   ; included if target is not val
        (restore continue)
        (goto (reg continue))   ; linkage code
     < src..

     This code sets up @c(continue) so that the procedure will return to a label
     @c(proc-return) and jumps to the procedure's entry point. The code at
     @c(proc-return) transfers the procedure's result from @c(val) to the target
     register (if necessary) and then jumps to the location specified by the
     linkage. (The linkage is always @c(return) or a label, because
     @c(compile-procedure-call) replaces a @c(next) linkage for the
     compound-procedure branch by an @c(after-call) label.)

     In fact, if the target is not @c(val), that is exactly the code our compiler
     will generate.@n(324) Usually, however, the target is @c(val) (the only time
     the compiler specifies a different register is when targeting the evaluation
     of an operator to @c(proc)), so the procedure result is put directly into the
     target register and there is no need to return to a special location that
     copies it. Instead, we simplify the code by setting up @c(continue) so that
     the procedure will @"(return) directly to the place specified by the caller's
     linkage:

     ..src > scheme
       ⟨set up continue for linkage⟩
       (assign val
               (op compiled-procedure-entry)
               (reg proc))
       (goto (reg val))
     < src..

     If the linkage is a label, we set up @c(continue) so that the procedure will
     return to that label. (That is, the @c[(goto (reg continue))] the procedure
     ends with becomes equivalent to the @c[(goto (label ⟨linkage⟩))] at
     @c(proc-return) above.)

     ..src > scheme
       (assign continue
               (label ⟨linkage⟩))
       (assign val
               (op compiled-procedure-entry)
               (reg proc))
       (goto (reg val))
     < src..

     If the linkage is @c(return), we don't need to set up @c(continue) at all: It
     already holds the desired location. (That is, the @c[(goto (reg continue))]
     the procedure ends with goes directly to the place where the @c[(goto (reg
     continue))] at @c(proc-return) would have gone.)

     ..src > scheme
       (assign val
               (op compiled-procedure-entry)
               (reg proc))
       (goto (reg val))
     < src..

     With this implementation of the @c(return) linkage, the compiler generates
     tail-recursive code. Calling a procedure as the final step in a procedure body
     does a direct transfer, without saving any information on the stack.

     Suppose instead that we had handled the case of a procedure call with a
     linkage of @c(return) and a target of @c(val) as shown above for a non-@c(val)
     target. This would destroy tail recursion. Our system would still give the
     same value for any expression. But each time we called a procedure, we would
     save @c(continue) and return after the call to undo the (useless) save.  These
     extra saves would accumulate during a nest of procedure calls.@n(325)

     @c(Compile-proc-appl) generates the above procedure-application code by
     considering four cases, depending on whether the target for the call is
     @c(val) and whether the linkage is @c(return). Observe that the instruction
     sequences are declared to modify all the registers, since executing the
     procedure body can change the registers in arbitrary ways.@n(326) Also note
     that the code sequence for the case with target @c(val) and linkage @c(return)
     is declared to need @c(continue): Even though @c(continue) is not explicitly
     used in the two-instruction sequence, we must be sure that @c(continue) will
     have the correct value when we enter the compiled procedure.

     ..src > scheme
       (define (compile-proc-appl target linkage)
         (cond ((and (eq? target 'val)
                     (not (eq? linkage 'return)))
                (make-instruction-sequence
                 '(proc)
                 all-regs
                 `((assign continue (label ,linkage))
                   (assign
                    val
                    (op compiled-procedure-entry)
                    (reg proc))
                   (goto (reg val)))))
               ((and (not (eq? target 'val))
                     (not (eq? linkage 'return)))
                (let ((proc-return
                       (make-label 'proc-return)))
                  (make-instruction-sequence
                   '(proc)
                   all-regs
                   `((assign continue
                             (label ,proc-return))
                     (assign
                      val
                      (op compiled-procedure-entry)
                      (reg proc))
                     (goto (reg val))
                     ,proc-return
                     (assign ,target (reg val))
                     (goto (label ,linkage))))))
               ((and (eq? target 'val)
                     (eq? linkage 'return))
                (make-instruction-sequence
                 '(proc continue)
                 all-regs
                 '((assign
                    val
                    (op compiled-procedure-entry)
                    (reg proc))
                   (goto (reg val)))))
               ((and (not (eq? target 'val))
                     (eq? linkage 'return))
                (error "return linkage,
                        target not val: COMPILE"
                       target))))
     < src..

*** 5.5.4 <> Combining Instruction Sequences

    This section describes the details on how instruction sequences are
    represented and combined. Recall from @l(#5.5.1) that an instruction sequence
    is represented as a list of the registers needed, the registers modified, and
    the actual instructions. We will also consider a label (symbol) to be a
    degenerate case of an instruction sequence, which doesn't need or modify any
    registers.  So to determine the registers needed and modified by instruction
    sequences we use the selectors

    ..src > scheme
      (define (registers-needed s)
        (if (symbol? s) '() (car s)))
      (define (registers-modified s)
        (if (symbol? s) '() (cadr s)))
      (define (statements s)
        (if (symbol? s) (list s) (caddr s)))
    < src..

    and to determine whether a given sequence needs or modifies a given register
    we use the predicates

    ..src > scheme
      (define (needs-register? seq reg)
        (memq reg (registers-needed seq)))
      (define (modifies-register? seq reg)
        (memq reg (registers-modified seq)))
    < src..

    In terms of these predicates and selectors, we can implement the various
    instruction sequence combiners used throughout the compiler.

    The basic combiner is @c(append-instruction-sequences). This takes as
    arguments an arbitrary number of instruction sequences that are to be executed
    sequentially and returns an instruction sequence whose statements are the
    statements of all the sequences appended together. The subtle point is to
    determine the registers that are needed and modified by the resulting
    sequence.  It modifies those registers that are modified by any of the
    sequences; it needs those registers that must be initialized before the first
    sequence can be run (the registers needed by the first sequence), together
    with those registers needed by any of the other sequences that are not
    initialized (modified) by sequences preceding it.

    The sequences are appended two at a time by @c(append-2-sequences). This takes
    two instruction sequences @c(seq1) and @c(seq2) and returns the instruction
    sequence whose statements are the statements of @c(seq1) followed by the
    statements of @c(seq2), whose modified registers are those registers that are
    modified by either @c(seq1) or @c(seq2), and whose needed registers are the
    registers needed by @c(seq1) together with those registers needed by @c(seq2)
    that are not modified by @c(seq1). (In terms of set operations, the new set of
    needed registers is the union of the set of registers needed by @c(seq1) with
    the set difference of the registers needed by @c(seq2) and the registers
    modified by @c(seq1).)  Thus, @c(append-instruction-sequences) is implemented
    as follows:

    ..src > scheme
      (define (append-instruction-sequences . seqs)
        (define (append-2-sequences seq1 seq2)
          (make-instruction-sequence
           (list-union
            (registers-needed seq1)
            (list-difference
             (registers-needed seq2)
             (registers-modified seq1)))
           (list-union
            (registers-modified seq1)
            (registers-modified seq2))
           (append (statements seq1)
                   (statements seq2))))
        (define (append-seq-list seqs)
          (if (null? seqs)
              (empty-instruction-sequence)
              (append-2-sequences
               (car seqs)
               (append-seq-list (cdr seqs)))))
        (append-seq-list seqs))
    < src..

    This procedure uses some simple operations for manipulating sets represented
    as lists, similar to the (unordered) set representation described in
    @l(#2.3.3):

    ..src > scheme
      (define (list-union s1 s2)
        (cond ((null? s1) s2)
              ((memq (car s1) s2)
               (list-union (cdr s1) s2))
              (else
               (cons (car s1)
                     (list-union (cdr s1) s2)))))

      (define (list-difference s1 s2)
        (cond ((null? s1) '())
              ((memq (car s1) s2)
               (list-difference (cdr s1) s2))
              (else
               (cons (car s1)
                     (list-difference (cdr s1)
                                      s2)))))
    < src..

    @c(Preserving), the second major instruction sequence combiner, takes a list
    of registers @c(regs) and two instruction sequences @c(seq1) and @c(seq2) that
    are to be executed sequentially. It returns an instruction sequence whose
    statements are the statements of @c(seq1) followed by the statements of
    @c(seq2), with appropriate @c(save) and @c(restore) instructions around
    @c(seq1) to protect the registers in @c(regs) that are modified by @c(seq1)
    but needed by @c(seq2). To accomplish this, @c(preserving) first creates a
    sequence that has the required @c(save)s followed by the statements of
    @c(seq1) followed by the required @c(restore)s. This sequence needs the
    registers being saved and restored in addition to the registers needed by
    @c(seq1), and modifies the registers modified by @c(seq1) except for the ones
    being saved and restored. This augmented sequence and @c(seq2) are then
    appended in the usual way. The following procedure implements this strategy
    recursively, walking down the list of registers to be preserved:@n(327)

    ..src > scheme
      (define (preserving regs seq1 seq2)
        (if (null? regs)
            (append-instruction-sequences seq1 seq2)
            (let ((first-reg (car regs)))
              (if (and
                   (needs-register? seq2 first-reg)
                   (modifies-register? seq1
                                       first-reg))
                  (preserving
                   (cdr regs)
                   (make-instruction-sequence
                    (list-union
                     (list first-reg)
                     (registers-needed seq1))
                    (list-difference
                     (registers-modified seq1)
                     (list first-reg))
                    (append `((save ,first-reg))
                            (statements seq1)
                            `((restore ,first-reg))))
                   seq2)
                  (preserving
                   (cdr regs)
                   seq1
                   seq2)))))
    < src..

    Another sequence combiner, @c(tack-on-instruction-sequence), is used by
    @c(compile-lambda) to append a procedure body to another sequence. Because the
    procedure body is not @"(in line) to be executed as part of the combined
    sequence, its register use has no impact on the register use of the sequence
    in which it is embedded. We thus ignore the procedure body's sets of needed
    and modified registers when we tack it onto the other sequence.

    ..src > scheme
      (define (tack-on-instruction-sequence
               seq body-seq)
        (make-instruction-sequence
         (registers-needed seq)
         (registers-modified seq)
         (append (statements seq)
                 (statements body-seq))))
    < src..

    @c(Compile-if) and @c(compile-procedure-call) use a special combiner called
    @c(parallel-instruction-sequences) to append the two alternative branches that
    follow a test. The two branches will never be executed sequentially; for any
    particular evaluation of the test, one branch or the other will be
    entered. Because of this, the registers needed by the second branch are still
    needed by the combined sequence, even if these are modified by the first
    branch.

    ..src > scheme
      (define (parallel-instruction-sequences
               seq1 seq2)
        (make-instruction-sequence
         (list-union (registers-needed seq1)
                     (registers-needed seq2))
         (list-union (registers-modified seq1)
                     (registers-modified seq2))
         (append (statements seq1)
                 (statements seq2))))
    < src..

*** 5.5.5 <> An Example of Compiled Code

    Now that we have seen all the elements of the compiler, let us examine an
    example of compiled code to see how things fit together. We will compile the
    definition of a recursive @c(factorial) procedure by calling @c(compile):

    ..src > scheme
      (compile
       '(define (factorial n)
          (if (= n 1)
              1
              (* (factorial (- n 1)) n)))
       'val
       'next)
    < src..

    We have specified that the value of the @c(define) expression should be placed
    in the @c(val) register. We don't care what the compiled code does after
    executing the @c(define), so our choice of @c(next) as the linkage descriptor
    is arbitrary.

    @c(Compile) determines that the expression is a definition, so it calls
    @c(compile-definition) to compile code to compute the value to be assigned
    (targeted to @c(val)), followed by code to install the definition, followed by
    code to put the value of the @c(define) (which is the symbol @c(ok)) into the
    target register, followed finally by the linkage code. @c(Env) is preserved
    around the computation of the value, because it is needed in order to install
    the definition. Because the linkage is @c(next), there is no linkage code in
    this case. The skeleton of the compiled code is thus

    ..src > scheme
      ⟨save env if modified by code to compute value⟩
        ⟨compilation of definition value,
         target val, linkage next⟩
        ⟨restore env if saved above⟩
        (perform (op define-variable!)
                 (const factorial)
                 (reg val)
                 (reg env))
        (assign val (const ok))
    < src..

    The expression that is to be compiled to produce the value for the variable
    @c(factorial) is a @c(lambda) expression whose value is the procedure that
    computes factorials. @c(Compile) handles this by calling @c(compile-lambda),
    which compiles the procedure body, labels it as a new entry point, and
    generates the instruction that will combine the procedure body at the new
    entry point with the run-time environment and assign the result to
    @c(val). The sequence then skips around the compiled procedure code, which is
    inserted at this point. The procedure code itself begins by extending the
    procedure's definition environment by a frame that binds the formal parameter
    @c(n) to the procedure argument. Then comes the actual procedure body.  Since
    this code for the value of the variable doesn't modify the @c(env) register,
    the optional @c(save) and @c(restore) shown above aren't generated. (The
    procedure code at @c(entry2) isn't executed at this point, so its use of
    @c(env) is irrelevant.)  Therefore, the skeleton for the compiled code becomes

    ..src > scheme
        (assign val (op make-compiled-procedure)
                    (label entry2)
                    (reg env))
        (goto (label after-lambda1))
      entry2
        (assign env (op compiled-procedure-env)
                    (reg proc))
        (assign env (op extend-environment)
                    (const (n))
                    (reg argl)
                    (reg env))
        ⟨compilation of procedure body⟩
      after-lambda1
        (perform (op define-variable!)
                 (const factorial)
                 (reg val) (reg env))
        (assign val (const ok))
    < src..

    A procedure body is always compiled (by @c(compile-lambda-body)) as a sequence
    with target @c(val) and linkage @c(return). The sequence in this case consists
    of a single @c(if) expression:

    ..src > scheme
      (if (= n 1)
          1
          (* (factorial (- n 1)) n))
    < src..

    @c(Compile-if) generates code that first computes the predicate (targeted to
    @c(val)), then checks the result and branches around the true branch if the
    predicate is false. @c(Env) and @c(continue) are preserved around the
    predicate code, since they may be needed for the rest of the @c(if)
    expression. Since the @c(if) expression is the final expression (and only
    expression) in the sequence making up the procedure body, its target is
    @c(val) and its linkage is @c(return), so the true and false branches are both
    compiled with target @c(val) and linkage @c(return). (That is, the value of
    the conditional, which is the value computed by either of its branches, is the
    value of the procedure.)

    ..src > scheme
      ⟨save continue, env if modified by
       predicate and needed by branches⟩
        ⟨compilation of predicate,
         target val, linkage next⟩
        ⟨restore continue, env if saved above⟩
        (test (op false?) (reg val))
        (branch (label false-branch4))
      true-branch5
        ⟨compilation of true branch,
         target val, linkage return⟩
      false-branch4
        ⟨compilation of false branch,
         target val, linkage return⟩
      after-if3
    < src..

    The predicate @c[(= n 1)] is a procedure call. This looks up the operator (the
    symbol @c(=)) and places this value in @c(proc). It then assembles the
    arguments @c(1) and the value of @c(n) into @c(argl). Then it tests whether
    @c(proc) contains a primitive or a compound procedure, and dispatches to a
    primitive branch or a compound branch accordingly. Both branches resume at the
    @c(after-call) label. The requirements to preserve registers around the
    evaluation of the operator and operands don't result in any saving of
    registers, because in this case those evaluations don't modify the registers
    in question.

    ..src > scheme
        (assign proc (op lookup-variable-value)
                     (const =)
                     (reg env))
        (assign val (const 1))
        (assign argl (op list) (reg val))
        (assign val (op lookup-variable-value)
                    (const n)
                    (reg env))
        (assign argl (op cons) (reg val) (reg argl))
        (test (op primitive-procedure?) (reg proc))
        (branch (label primitive-branch17))
      compiled-branch16
        (assign continue (label after-call15))
        (assign val (op compiled-procedure-entry)
                    (reg proc))
        (goto (reg val))
      primitive-branch17
        (assign val (op apply-primitive-procedure)
                    (reg proc)
                    (reg argl))
      after-call15
    < src..

    The true branch, which is the constant 1, compiles (with target @c(val) and
    linkage @c(return)) to

    ..src > scheme
      (assign val (const 1))
      (goto (reg continue))
    < src..

    The code for the false branch is another procedure call, where the procedure
    is the value of the symbol @c(*), and the arguments are @c(n) and the result
    of another procedure call (a call to @c(factorial)). Each of these calls sets
    up @c(proc) and @c(argl) and its own primitive and compound
    branches. @l(#Figure 5.17) shows the complete compilation of the definition of
    the @c(factorial) procedure. Notice that the possible @c(save) and @c(restore)
    of @c(continue) and @c(env) around the predicate, shown above, are in fact
    generated, because these registers are modified by the procedure call in the
    predicate and needed for the procedure call and the @c(return) linkage in the
    branches.

    ..figure > @t(Figure 5.17) Compilation of the definition of the @c(factorial)
      procedure.

      ..src > scheme
        ;; construct the procedure and skip over code
        ;; for the procedure body
          (assign val
                  (op make-compiled-procedure)
                  (label entry2)
                  (reg env))
          (goto (label after-lambda1))
        entry2     ; calls to factorial will enter here
          (assign env
                  (op compiled-procedure-env)
                  (reg proc))
          (assign env
                  (op extend-environment)
                  (const (n))
                  (reg argl)
                  (reg env))
        ;; begin actual procedure body
          (save continue)
          (save env)
        ;; compute (= n 1)
          (assign proc
                  (op lookup-variable-value)
                  (const =)
                  (reg env))
          (assign val (const 1))
          (assign argl (op list) (reg val))
          (assign val
                  (op lookup-variable-value)
                  (const n)
                  (reg env))
          (assign argl (op cons) (reg val) (reg argl))
          (test (op primitive-procedure?) (reg proc))
          (branch (label primitive-branch17))
        compiled-branch16
          (assign continue (label after-call15))
          (assign val
                  (op compiled-procedure-entry)
                  (reg proc))
          (goto (reg val))
        primitive-branch17
          (assign val
                  (op apply-primitive-procedure)
                  (reg proc)
                  (reg argl))
        after-call15   ; val now contains result of (= n 1)
          (restore env)
          (restore continue)
          (test (op false?) (reg val))
          (branch (label false-branch4))
        true-branch5  ; return 1
          (assign val (const 1))
          (goto (reg continue))

        false-branch4
        ;; compute and return (* (factorial (- n 1)) n)
          (assign proc
                  (op lookup-variable-value)
                  (const *)
                  (reg env))
          (save continue)
          (save proc)   ; save * procedure
          (assign val
                  (op lookup-variable-value)
                  (const n)
                  (reg env))
          (assign argl (op list) (reg val))
          (save argl)   ; save partial argument list for *
        ;; compute (factorial (- n 1)),
        ;; which is the other argument for *
          (assign proc
                  (op lookup-variable-value)
                  (const factorial)
                  (reg env))
          (save proc)  ; save factorial procedure
        ;; compute (- n 1), which is the argument for factorial
          (assign proc
                  (op lookup-variable-value)
                  (const -)
                  (reg env))
          (assign val (const 1))
          (assign argl (op list) (reg val))
          (assign val
                  (op lookup-variable-value)
                  (const n)
                  (reg env))
          (assign argl (op cons) (reg val) (reg argl))
          (test (op primitive-procedure?) (reg proc))
          (branch (label primitive-branch8))
        compiled-branch7
          (assign continue (label after-call6))
          (assign val
                  (op compiled-procedure-entry)
                  (reg proc))
          (goto (reg val))
        primitive-branch8
          (assign val
                  (op apply-primitive-procedure)
                  (reg proc)
                  (reg argl))

        after-call6   ; val now contains result of (- n 1)
          (assign argl (op list) (reg val))
          (restore proc) ; restore factorial
        ;; apply factorial
          (test (op primitive-procedure?) (reg proc))
          (branch (label primitive-branch11))
        compiled-branch10
          (assign continue (label after-call9))
          (assign val
                  (op compiled-procedure-entry)
                  (reg proc))
          (goto (reg val))
        primitive-branch11
          (assign val
                  (op apply-primitive-procedure)
                  (reg proc)
                  (reg argl))
        after-call9      ; val now contains result
                         ; of (factorial (- n 1))
          (restore argl) ; restore partial argument list for *
          (assign argl (op cons) (reg val) (reg argl))
          (restore proc) ; restore *
          (restore continue)
        ;; apply * and return its value
          (test (op primitive-procedure?) (reg proc))
          (branch (label primitive-branch14))
        compiled-branch13
        ;; note that a compound procedure here
        ;; is called tail-recursively
          (assign val
                  (op compiled-procedure-entry)
                  (reg proc))
          (goto (reg val))
        primitive-branch14
          (assign val
                  (op apply-primitive-procedure)
                  (reg proc)
                  (reg argl))
          (goto (reg continue))
        after-call12
        after-if3
        after-lambda1
        ;; assign the procedure to the variable factorial
          (perform (op define-variable!)
                   (const factorial)
                   (reg val)
                   (reg env))
          (assign val (const ok))
      < src..


    :: @t(Exercise 5.33) :: Consider the following definition of a factorial
       procedure, which is slightly different from the one given above:

       ..src > scheme
         (define (factorial-alt n)
           (if (= n 1)
               1
               (* n (factorial-alt (- n 1)))))
       < src..

       Compile this procedure and compare the resulting code with that produced
       for @c(factorial). Explain any differences you find. Does either program
       execute more efficiently than the other?

    :: @t(Exercise 5.34) :: Compile the iterative factorial procedure

       ..src > scheme
         (define (factorial n)
           (define (iter product counter)
             (if (> counter n)
                 product
                 (iter (* counter product)
                       (+ counter 1))))
           (iter 1 1))
       < src..

       Annotate the resulting code, showing the essential difference between the
       code for iterative and recursive versions of @c(factorial) that makes one
       process build up stack space and the other run in constant stack space.

    :: @t(Exercise 5.35) :: What expression was compiled to produce the code shown
       in @l(#Figure 5.18)?

    ..figure > @t(Figure 5.18) An example of compiler output. See @l(#Exercise 5.35).

      ..src > scheme
        (assign val (op make-compiled-procedure)
                    (label entry16)
                    (reg env))
          (goto (label after-lambda15))
        entry16
          (assign env (op compiled-procedure-env)
                      (reg proc))
          (assign env (op extend-environment)
                      (const (x))
                      (reg argl)
                      (reg env))
          (assign proc (op lookup-variable-value)
                       (const +)
                       (reg env))
          (save continue) (save proc) (save env)
          (assign proc (op lookup-variable-value)
                       (const g)
                       (reg env))
          (save proc)
          (assign proc (op lookup-variable-value)
                       (const +)
                       (reg env))
          (assign val (const 2))
          (assign argl (op list) (reg val))
          (assign val (op lookup-variable-value)
                      (const x)
                      (reg env))
          (assign argl (op cons)
                       (reg val)
                       (reg argl))
          (test (op primitive-procedure?)
                (reg proc))
          (branch (label primitive-branch19))
        compiled-branch18
          (assign continue (label after-call17))
          (assign val
                  (op compiled-procedure-entry)
                  (reg proc))
          (goto (reg val))
        primitive-branch19
          (assign val
                  (op apply-primitive-procedure)
                  (reg proc)
                  (reg argl))
        after-call17
          (assign argl (op list) (reg val))
          (restore proc)
          (test (op primitive-procedure?)
                (reg proc))
          (branch (label primitive-branch22))
        compiled-branch21
          (assign continue (label after-call20))
          (assign val
                  (op compiled-procedure-entry)
                  (reg proc))
          (goto (reg val))
        primitive-branch22
          (assign val
                  (op apply-primitive-procedure)
                  (reg proc)
                  (reg argl))
        after-call20
          (assign argl (op list) (reg val))
          (restore env)
          (assign val
                  (op lookup-variable-value)
                  (const x)
                  (reg env))
          (assign argl
                  (op cons)
                  (reg val)
                  (reg argl))
          (restore proc)
          (restore continue)
          (test (op primitive-procedure?)
                (reg proc))
          (branch (label primitive-branch25))
        compiled-branch24
          (assign val (op compiled-procedure-entry)
                      (reg proc))
          (goto (reg val))
        primitive-branch25
          (assign val
                  (op apply-primitive-procedure)
                  (reg proc)
                  (reg argl))
          (goto (reg continue))
        after-call23
        after-lambda15
          (perform (op define-variable!)
                   (const f)
                   (reg val)
                   (reg env))
          (assign val (const ok))
      < src..


    :: @t(Exercise 5.36) :: What order of evaluation does our compiler produce for
       operands of a combination?  Is it left-to-right, right-to-left, or some
       other order?  Where in the compiler is this order determined?  Modify the
       compiler so that it produces some other order of evaluation. (See the
       discussion of order of evaluation for the explicit-control evaluator in
       @l(#5.4.1).)  How does changing the order of operand evaluation affect the
       efficiency of the code that constructs the argument list?

    :: @t(Exercise 5.37) :: One way to understand the compiler's @c(preserving)
       mechanism for optimizing stack usage is to see what extra operations would
       be generated if we did not use this idea. Modify @c(preserving) so that it
       always generates the @c(save) and @c(restore) operations. Compile some
       simple expressions and identify the unnecessary stack operations that are
       generated. Compare the code to that generated with the @c(preserving)
       mechanism intact.

    :: @t(Exercise 5.38) :: Our compiler is clever about avoiding unnecessary
       stack operations, but it is not clever at all when it comes to compiling
       calls to the primitive procedures of the language in terms of the primitive
       operations supplied by the machine. For example, consider how much code is
       compiled to compute @c[(+ a 1)]: The code sets up an argument list in
       @c(argl), puts the primitive addition procedure (which it finds by looking
       up the symbol @c(+) in the environment) into @c(proc), and tests whether
       the procedure is primitive or compound. The compiler always generates code
       to perform the test, as well as code for primitive and compound branches
       (only one of which will be executed). We have not shown the part of the
       controller that implements primitives, but we presume that these
       instructions make use of primitive arithmetic operations in the machine's
       data paths.  Consider how much less code would be generated if the compiler
       could @e(open-code) primitives––that is, if it could generate code to
       directly use these primitive machine operations. The expression @c[(+ a 1)]
       might be compiled into something as simple as@n(328)

       ..src > scheme
         (assign val (op lookup-variable-value)
                     (const a)
                     (reg env))
         (assign val (op +)
                     (reg val)
                     (const 1))
       < src..

       In this exercise we will extend our compiler to support open coding of
       selected primitives. Special-purpose code will be generated for calls to
       these primitive procedures instead of the general procedure-application
       code. In order to support this, we will augment our machine with special
       argument registers @c(arg1) and @c(arg2). The primitive arithmetic
       operations of the machine will take their inputs from @c(arg1) and
       @c(arg2). The results may be put into @c(val), @c(arg1), or @c(arg2).

       The compiler must be able to recognize the application of an open-coded
       primitive in the source program. We will augment the dispatch in the
       @c(compile) procedure to recognize the names of these primitives in
       addition to the reserved words (the special forms) it currently
       recognizes.@n(329) For each special form our compiler has a code
       generator. In this exercise we will construct a family of code generators
       for the open-coded primitives.

       1. The open-coded primitives, unlike the special forms, all need their
          operands evaluated. Write a code generator @c(spread-arguments) for use
          by all the open-coding code generators. @c(Spread-arguments) should take
          an operand list and compile the given operands targeted to successive
          argument registers.  Note that an operand may contain a call to an
          open-coded primitive, so argument registers will have to be preserved
          during operand evaluation.

       2. For each of the primitive procedures @c(=), @c(*), @c(-), and @c(+),
          write a code generator that takes a combination with that operator,
          together with a target and a linkage descriptor, and produces code to
          spread the arguments into the registers and then perform the operation
          targeted to the given target with the given linkage. You need only
          handle expressions with two operands. Make @c(compile) dispatch to these
          code generators.

       3. Try your new compiler on the @c(factorial) example. Compare the
          resulting code with the result produced without open coding.

       4. Extend your code generators for @c(+) and @c(*) so that they can handle
          expressions with arbitrary numbers of operands. An expression with more
          than two operands will have to be compiled into a sequence of
          operations, each with only two inputs.

*** 5.5.6 <> Lexical Addressing

    One of the most common optimizations performed by compilers is the
    optimization of variable lookup. Our compiler, as we have implemented it so
    far, generates code that uses the @c(lookup-variable-value) operation of the
    evaluator machine. This searches for a variable by comparing it with each
    variable that is currently bound, working frame by frame outward through the
    run-time environment. This search can be expensive if the frames are deeply
    nested or if there are many variables. For example, consider the problem of
    looking up the value of @c(x) while evaluating the expression @c[(* x y z)] in
    an application of the procedure that is returned by

    ..src > scheme
      (let ((x 3) (y 4))
        (lambda (a b c d e)
          (let ((y (* a b x))
                (z (+ c d x)))
            (* x y z))))
    < src..

    Since a @c(let) expression is just syntactic sugar for a @c(lambda)
    combination, this expression is equivalent to

    ..src > scheme
      ((lambda (x y)
         (lambda (a b c d e)
           ((lambda (y z) (* x y z))
            (* a b x)
            (+ c d x))))
       3
       4)
    < src..

    Each time @c(lookup-variable-value) searches for @c(x), it must determine that
    the symbol @c(x) is not @c(eq?) to @c(y) or @c(z) (in the first frame), nor to
    @c(a), @c(b), @c(c), @c(d), or @c(e) (in the second frame). We will assume,
    for the moment, that our programs do not use @c(define)––that variables are
    bound only with @c(lambda). Because our language is lexically scoped, the
    run-time environment for any expression will have a structure that parallels
    the lexical structure of the program in which the expression appears.@n(330)
    Thus, the compiler can know, when it analyzes the above expression, that each
    time the procedure is applied the variable @c(x) in @c[(* x y z)] will be
    found two frames out from the current frame and will be the first variable in
    that frame.

    We can exploit this fact by inventing a new kind of variable-lookup operation,
    @c(lexical-address-lookup), that takes as arguments an environment and a
    @e(lexical address) that consists of two numbers: a @e(frame number), which
    specifies how many frames to pass over, and a @e(displacement number), which
    specifies how many variables to pass over in that frame.
    @c(Lexical-address-lookup) will produce the value of the variable stored at
    that lexical address relative to the current environment.  If we add the
    @c(lexical-address-lookup) operation to our machine, we can make the compiler
    generate code that references variables using this operation, rather than
    @c(lookup-variable-value). Similarly, our compiled code can use a new
    @c(lexical-address-set!)  operation instead of @c(set-variable-value!).

    In order to generate such code, the compiler must be able to determine the
    lexical address of a variable it is about to compile a reference to. The
    lexical address of a variable in a program depends on where one is in the
    code.  For example, in the following program, the address of @c(x) in
    expression @c[(e1)] is (2, 0)––two frames back and the first variable in the
    frame. At that point @c(y) is at address (0, 0) and @c(c) is at address (1,
    2). In expression @c[(e2)], @c(x) is at (1, 0), @c(y) is at (1, 1), and @c(c)
    is at (0, 2).

    ..src > scheme
      ((lambda (x y)
         (lambda (a b c d e)
           ((lambda (y z) ⟨e1⟩)
            ⟨e2⟩
            (+ c d x))))
       3
       4)
    < src..

    One way for the compiler to produce code that uses lexical addressing is to
    maintain a data structure called a @e(compile-time environment). This keeps
    track of which variables will be at which positions in which frames in the
    run-time environment when a particular variable-access operation is
    executed. The compile-time environment is a list of frames, each containing a
    list of variables. (There will of course be no values bound to the variables,
    since values are not computed at compile time.)  The compile-time environment
    becomes an additional argument to @c(compile) and is passed along to each code
    generator. The top-level call to @c(compile) uses an empty compile-time
    environment. When a @c(lambda) body is compiled, @c(compile-lambda-body)
    extends the compile-time environment by a frame containing the procedure's
    parameters, so that the sequence making up the body is compiled with that
    extended environment. At each point in the compilation, @c(compile-variable)
    and @c(compile-assignment) use the compile-time environment in order to
    generate the appropriate lexical addresses.

    @l(#Exercise 5.39) through @l(#Exercise 5.43) describe how to complete this
    sketch of the lexical-addressing strategy in order to incorporate lexical
    lookup into the compiler. @l(#Exercise 5.44) describes another use for the
    compile-time environment.

    :: @t(Exercise 5.39) :: Write a procedure @c(lexical-address-lookup) that
       implements the new lookup operation. It should take two arguments––a
       lexical address and a run-time environment––and return the value of the
       variable stored at the specified lexical address.
       @c(Lexical-address-lookup) should signal an error if the value of the
       variable is the symbol @c(*unassigned*).@n(331) Also write a procedure
       @c(lexical-address-set!) that implements the operation that changes the
       value of the variable at a specified lexical address.

    :: @t(Exercise 5.40) :: Modify the compiler to maintain the compile-time
       environment as described above. That is, add a compile-time-environment
       argument to @c(compile) and the various code generators, and extend it in
       @c(compile-lambda-body).

    :: @t(Exercise 5.41) :: Write a procedure @c(find-variable) that takes as
       arguments a variable and a compile-time environment and returns the lexical
       address of the variable with respect to that environment. For example, in
       the program fragment that is shown above, the compile-time environment
       during the compilation of expression @c[(e1)] is @c[((y z) (a b c d e) (x
       y))]. @c(Find-variable) should produce

       ..srci > scheme
         > (find-variable
         ^  'c '((y z) (a b c d e) (x y)))
         (1 2)
         > (find-variable
         ^  'x '((y z) (a b c d e) (x y)))
         (2 0)
         > (find-variable
         ^  'w '((y z) (a b c d e) (x y)))
         not-found
       < srci..

    :: @t(Exercise 5.42) :: Using @c(find-variable) from @l(#Exercise 5.41),
       rewrite @c(compile-variable) and @c(compile-assignment) to output
       lexical-address instructions. In cases where @c(find-variable) returns
       @c(not-found) (that is, where the variable is not in the compile-time
       environment), you should have the code generators use the evaluator
       operations, as before, to search for the binding.  (The only place a
       variable that is not found at compile time can be is in the global
       environment, which is part of the run-time environment but is not part of
       the compile-time environment.@n(332) Thus, if you wish, you may have the
       evaluator operations look directly in the global environment, which can be
       obtained with the operation @c[(op get-global-environment)], instead of
       having them search the whole run-time environment found in @c(env).)  Test
       the modified compiler on a few simple cases, such as the nested @c(lambda)
       combination at the beginning of this section.

    :: @t(Exercise 5.43) :: We argued in @l(#4.1.6) that internal definitions for
       block structure should not be considered @"(real) @c(define)s. Rather, a
       procedure body should be interpreted as if the internal variables being
       defined were installed as ordinary @c(lambda) variables initialized to
       their correct values using @c(set!).  @l(#4.1.6) and @l(#Exercise 4.16)
       showed how to modify the metacircular interpreter to accomplish this by
       scanning out internal definitions. Modify the compiler to perform the same
       transformation before it compiles a procedure body.

    :: @t(Exercise 5.44) :: In this section we have focused on the use of the
       compile-time environment to produce lexical addresses. But there are other
       uses for compile-time environments. For instance, in @l(#Exercise 5.38) we
       increased the efficiency of compiled code by open-coding primitive
       procedures. Our implementation treated the names of open-coded procedures
       as reserved words. If a program were to rebind such a name, the mechanism
       described in @l(#Exercise 5.38) would still open-code it as a primitive,
       ignoring the new binding. For example, consider the procedure

       ..src > scheme
         (lambda (+ * a b x y)
           (+ (* a x) (* b y)))
       < src..

       which computes a linear combination of @c(x) and @c(y). We might call it
       with arguments @c(+matrix), @c(*matrix), and four matrices, but the
       open-coding compiler would still open-code the @c(+) and the @c(*) in @c[(+
       (* a x) (* b y))] as primitive @c(+) and @c(*). Modify the open-coding
       compiler to consult the compile-time environment in order to compile the
       correct code for expressions involving the names of primitive
       procedures. (The code will work correctly as long as the program does not
       @c(define) or @c(set!) these names.)

*** 5.5.7 <> Interfacing Compiled Code to the Evaluator

    We have not yet explained how to load compiled code into the evaluator machine
    or how to run it. We will assume that the explicit-control-evaluator machine
    has been defined as in @l(#5.4.4), with the additional operations specified in
    @n(323<>Footnote 323). We will implement a procedure @c(compile-and-go) that
    compiles a Scheme expression, loads the resulting object code into the
    evaluator machine, and causes the machine to run the code in the evaluator
    global environment, print the result, and enter the evaluator's driver
    loop. We will also modify the evaluator so that interpreted expressions can
    call compiled procedures as well as interpreted ones. We can then put a
    compiled procedure into the machine and use the evaluator to call it:

    ..srci > scheme
      > (compile-and-go
      ^  '(define (factorial n)
      ^     (if (= n 1)
      ^         1
      ^         (* (factorial (- n 1)) n))))
      ;;; EC-Eval value:
      ok
      ;;; EC-Eval input:
      > (factorial 5)
      ;;; EC-Eval value:
      120
    < srci..

    To allow the evaluator to handle compiled procedures (for example, to evaluate
    the call to @c(factorial) above), we need to change the code at
    @c(apply-dispatch) (@l(#5.4.1)) so that it recognizes compiled procedures (as
    distinct from compound or primitive procedures) and transfers control directly
    to the entry point of the compiled code:@n(333)

    ..src > scheme
      apply-dispatch
        (test (op primitive-procedure?) (reg proc))
        (branch (label primitive-apply))
        (test (op compound-procedure?) (reg proc))
        (branch (label compound-apply))
        (test (op compiled-procedure?) (reg proc))
        (branch (label compiled-apply))
        (goto (label unknown-procedure-type))

      compiled-apply
        (restore continue)
        (assign val
                (op compiled-procedure-entry)
                (reg proc))
        (goto (reg val))
    < src..

    Note the restore of @c(continue) at @c(compiled-apply). Recall that the
    evaluator was arranged so that at @c(apply-dispatch), the continuation would
    be at the top of the stack. The compiled code entry point, on the other hand,
    expects the continuation to be in @c(continue), so @c(continue) must be
    restored before the compiled code is executed.

    To enable us to run some compiled code when we start the evaluator machine, we
    add a @c(branch) instruction at the beginning of the evaluator machine, which
    causes the machine to go to a new entry point if the @c(flag) register is
    set.@n(334)

    ..src > scheme
      ;; branches if @c(flag) is set:
      (branch (label external-entry))
      read-eval-print-loop
        (perform (op initialize-stack))
        …
    < src..

    @c(External-entry) assumes that the machine is started with @c(val) containing
    the location of an instruction sequence that puts a result into @c(val) and
    ends with @c[(goto (reg continue))]. Starting at this entry point jumps to the
    location designated by @c(val), but first assigns @c(continue) so that
    execution will return to @c(print-result), which prints the value in @c(val)
    and then goes to the beginning of the evaluator's read-eval-print loop.@n(335)

    ..src > scheme
      external-entry
        (perform (op initialize-stack))
        (assign env (op get-global-environment))
        (assign continue (label print-result))
        (goto (reg val))
    < src..

    Now we can use the following procedure to compile a procedure definition,
    execute the compiled code, and run the read-eval-print loop so we can try the
    procedure. Because we want the compiled code to return to the location in
    @c(continue) with its result in @c(val), we compile the expression with a
    target of @c(val) and a linkage of @c(return). In order to transform the
    object code produced by the compiler into executable instructions for the
    evaluator register machine, we use the procedure @c(assemble) from the
    register-machine simulator (@l(#5.2.2)). We then initialize the @c(val)
    register to point to the list of instructions, set the @c(flag) so that the
    evaluator will go to @c(external-entry), and start the evaluator.

    ..src > scheme
      (define (compile-and-go expression)
        (let ((instructions
               (assemble
                (statements
                 (compile
                  expression 'val 'return))
                eceval)))
          (set! the-global-environment
                (setup-environment))
          (set-register-contents!
           eceval 'val instructions)
          (set-register-contents!
           eceval 'flag true)
          (start eceval)))
    < src..

    If we have set up stack monitoring, as at the end of @l(#5.4.4), we can
    examine the stack usage of compiled code:

    ..srci > scheme
      > (compile-and-go
      ^  '(define (factorial n)
      ^     (if (= n 1)
      ^         1
      ^         (* (factorial (- n 1)) n))))
      (total-pushes = 0, maximum-depth = 0)
      ;;; EC-Eval value:
      ok
      ;;; EC-Eval input:
      > (factorial 5)
      (total-pushes = 31, maximum-depth = 14)
      ;;; EC-Eval value:
      120
    < srci..

    Compare this example with the evaluation of @c[(factorial 5)] using the
    interpreted version of the same procedure, shown at the end of
    @l(#5.4.4). The interpreted version required 144 pushes and a maximum stack
    depth of 28. This illustrates the optimization that results from our
    compilation strategy.

**** Interpretation and compilation

     With the programs in this section, we can now experiment with the alternative
     execution strategies of interpretation and compilation.@n(336) An interpreter
     raises the machine to the level of the user program; a compiler lowers the
     user program to the level of the machine language. We can regard the Scheme
     language (or any programming language) as a coherent family of abstractions
     erected on the machine language.  Interpreters are good for interactive
     program development and debugging because the steps of program execution are
     organized in terms of these abstractions, and are therefore more intelligible
     to the programmer. Compiled code can execute faster, because the steps of
     program execution are organized in terms of the machine language, and the
     compiler is free to make optimizations that cut across the higher-level
     abstractions.@n(337)

     The alternatives of interpretation and compilation also lead to different
     strategies for porting languages to new computers. Suppose that we wish to
     implement Lisp for a new machine. One strategy is to begin with the
     explicit-control evaluator of @l(#5.4) and translate its instructions to
     instructions for the new machine. A different strategy is to begin with the
     compiler and change the code generators so that they generate code for the new
     machine. The second strategy allows us to run any Lisp program on the new
     machine by first compiling it with the compiler running on our original Lisp
     system, and linking it with a compiled version of the run-time library.@n(338)
     Better yet, we can compile the compiler itself, and run this on the new
     machine to compile other Lisp programs.@n(339) Or we can compile one of the
     interpreters of @l(#4.1) to produce an interpreter that runs on the new
     machine.

     :: @t(Exercise 5.45) :: By comparing the stack operations used by compiled
        code to the stack operations used by the evaluator for the same
        computation, we can determine the extent to which the compiler optimizes
        use of the stack, both in speed (reducing the total number of stack
        operations) and in space (reducing the maximum stack depth). Comparing this
        optimized stack use to the performance of a special-purpose machine for the
        same computation gives some indication of the quality of the compiler.

        1. @l(#Exercise 5.27) asked you to determine, as a function of @m(n), the
           number of pushes and the maximum stack depth needed by the evaluator to
           compute @m(n!)  using the recursive factorial procedure given
           above. @l(#Exercise 5.14) asked you to do the same measurements for the
           special-purpose factorial machine shown in @l(#Figure 5.11). Now perform
           the same analysis using the compiled @c(factorial) procedure.

           Take the ratio of the number of pushes in the compiled version to the
           number of pushes in the interpreted version, and do the same for the
           maximum stack depth.  Since the number of operations and the stack depth
           used to compute @m(n!)  are linear in @m(n), these ratios should
           approach constants as @m(n) becomes large.  What are these constants?
           Similarly, find the ratios of the stack usage in the special-purpose
           machine to the usage in the interpreted version.

           Compare the ratios for special-purpose versus interpreted code to the
           ratios for compiled versus interpreted code. You should find that the
           special-purpose machine does much better than the compiled code, since
           the hand-tailored controller code should be much better than what is
           produced by our rudimentary general-purpose compiler.

        2. Can you suggest improvements to the compiler that would help it generate
           code that would come closer in performance to the hand-tailored version?

     :: @t(Exercise 5.46) :: Carry out an analysis like the one in @l(#Exercise
        5.45) to determine the effectiveness of compiling the tree-recursive
        Fibonacci procedure

        ..src > scheme
          (define (fib n)
            (if (< n 2)
                n
                (+ (fib (- n 1)) (fib (- n 2)))))
        < src..

        compared to the effectiveness of using the special-purpose Fibonacci
        machine of @l(#Figure 5.12). (For measurement of the interpreted
        performance, see @l(#Exercise 5.29).)  For Fibonacci, the time resource
        used is not linear in @m(n); hence the ratios of stack operations will not
        approach a limiting value that is independent of @m(n).

     :: @t(Exercise 5.47) :: This section described how to modify the
        explicit-control evaluator so that interpreted code can call compiled
        procedures. Show how to modify the compiler so that compiled procedures can
        call not only primitive procedures and compiled procedures, but interpreted
        procedures as well. This requires modifying @c(compile-procedure-call) to
        handle the case of compound (interpreted) procedures. Be sure to handle all
        the same @c(target) and @c(linkage) combinations as in
        @c(compile-proc-appl). To do the actual procedure application, the code
        needs to jump to the evaluator's @c(compound-apply) entry point. This label
        cannot be directly referenced in object code (since the assembler requires
        that all labels referenced by the code it is assembling be defined there),
        so we will add a register called @c(compapp) to the evaluator machine to
        hold this entry point, and add an instruction to initialize it:

        ..src > scheme
            (assign compapp (label compound-apply))
            ;; branches if @c(flag) is set:
            (branch (label external-entry))
          read-eval-print-loop …
        < src..

        To test your code, start by defining a procedure @c(f) that calls a
        procedure @c(g). Use @c(compile-and-go) to compile the definition of @c(f)
        and start the evaluator. Now, typing at the evaluator, define @c(g) and try
        to call @c(f).

     :: @t(Exercise 5.48) :: The @c(compile-and-go) interface implemented in this
        section is awkward, since the compiler can be called only once (when the
        evaluator machine is started). Augment the compiler-interpreter interface
        by providing a @c(compile-and-run) primitive that can be called from within
        the explicit-control evaluator as follows:

        ..srci > scheme
          ;;; EC-Eval input:
          > (compile-and-run
          ^  '(define (factorial n)
          ^     (if (= n 1)
          ^         1
          ^         (* (factorial (- n 1)) n))))
          ;;; EC-Eval value:
          ok
          ;;; EC-Eval input:
          > (factorial 5)
          ;;; EC-Eval value:
          120
        < srci..

     :: @t(Exercise 5.49) :: As an alternative to using the explicit-control
        evaluator's read-eval-print loop, design a register machine that performs a
        read-compile-execute-print loop. That is, the machine should run a loop
        that reads an expression, compiles it, assembles and executes the resulting
        code, and prints the result. This is easy to run in our simulated setup,
        since we can arrange to call the procedures @c(compile) and @c(assemble) as
        @"(register-machine operations.)

     :: @t(Exercise 5.50) :: Use the compiler to compile the metacircular evaluator
        of @l(#4.1) and run this program using the register-machine simulator. (To
        compile more than one definition at a time, you can package the definitions
        in a @c(begin).)  The resulting interpreter will run very slowly because of
        the multiple levels of interpretation, but getting all the details to work
        is an instructive exercise.

     :: @t(Exercise 5.51) :: Develop a rudimentary implementation of Scheme in C
        (or some other low-level language of your choice) by translating the
        explicit-control evaluator of @l(#5.4) into C. In order to run this code
        you will need to also provide appropriate storage-allocation routines and
        other run-time support.

     :: @t(Exercise 5.52) :: As a counterpoint to @l(#Exercise 5.51), modify the
        compiler so that it compiles Scheme procedures into sequences of C
        instructions. Compile the metacircular evaluator of @l(#4.1) to produce a
        Scheme interpreter written in C.

* References

  @t(Abelson et al. 1992) Abelson, Harold, Andrew Berlin, Jacob Katzenelson,
  William McAllister, Guillermo Rozas, Gerald Jay Sussman, and Jack
  Wisdom. 1992. The Supercomputer Toolkit: A general framework for
  special-purpose computing.  @q(International Journal of High-Speed
  Electronics) 3(3): 337-361. @l(http://www.hpl.hp.com/techreports/94/HPL-94-30.html<>–›)

  @t(Allen 1978) Allen, John. 1978. @q(Anatomy of Lisp). New York: McGraw-Hill.

  @t(ANSI 1994) @A(ANSI) @A(X)3.226-1994. @q(American National Standard for
  Information Systems––Programming Language––Common Lisp).

  @t(Appel 1987) Appel, Andrew W. 1987. Garbage collection can be faster than
  stack allocation. @q(Information Processing Letters) 25(4): 275-279.
  @l(https://www.cs.princeton.edu/~appel/papers/45.ps<>–›)

  @t(Backus 1978) Backus, John. 1978. Can programming be liberated from the von
  Neumann style?  @q(Communications of the @A(ACM)) 21(8): 613-641.
  @l(http://worrydream.com/refs/Backus-CanProgrammingBeLiberated.pdf<>–›)

  @t[Baker (1978)] Baker, Henry G., Jr. 1978. List processing in real time on a
  serial computer.  @q(Communications of the @A(ACM)) 21(4): 280-293.
  @l(http://dspace.mit.edu/handle/1721.1/41976<>–›)

  @t(Batali et al. 1982) Batali, John, Neil Mayle, Howard Shrobe, Gerald Jay
  Sussman, and Daniel Weise.
  1982. The Scheme-81 architecture––System and chip. In @q(Proceedings of
  the @A(MIT) Conference on Advanced Research in @A(VLSI)), edited by Paul
  Penfield, Jr. Dedham, @A(MA): Artech House.

  @t[Borning (1977)] Borning, Alan. 1977. ThingLab––An object-oriented system
  for building simulations using constraints. In @q(Proceedings of the 5th
  International Joint Conference on Artificial Intelligence).
  @l(http://ijcai.org/Past%20Proceedings/IJCAI-77-VOL1/PDF/085.pdf<>–›)

  @t[Borodin and Munro (1975)] Borodin, Alan, and Ian Munro. 1975. @q(The
  Computational Complexity of Algebraic and Numeric Problems). New York:
  American Elsevier.

  @t(Chaitin 1975) Chaitin, Gregory J. 1975. Randomness and mathematical proof.
  @q(Scientific American) 232(5): 47-52.
  @l(https://www.cs.auckland.ac.nz/~chaitin/sciamer.html<>–›)

  @t[Church (1941)] Church, Alonzo. 1941. @q(The Calculi of
  Lambda-Conversion). Princeton, N.J.: Princeton University Press.

  @t[Clark (1978)] Clark, Keith L. 1978. Negation as failure. In @q(Logic and
  Data Bases).  New York: Plenum Press, pp. 293-322.
  @l(http://www.doc.ic.ac.uk/~klc/neg.html<>–›)

  @t[Clinger (1982)] Clinger, William. 1982. Nondeterministic call by need is
  neither lazy nor by name. In @q(Proceedings of the @A(ACM) Symposium on Lisp
  and Functional Programming), pp. 226-234.

  @t(Clinger and Rees 1991) Clinger, William, and Jonathan Rees. 1991. Macros
  that work. In @q(Proceedings of the 1991 @A(ACM) Conference on Principles of
  Programming Languages), pp. 155-162.
  @l(http://mumble.net/~jar/pubs/macros_that_work.ps<>–›)

  @t(Colmerauer et al. 1973) Colmerauer A., H. Kanoui, R. Pasero, and
  P. Roussel. 1973. Un système de communication homme-machine en
  français. Technical report, Groupe Intelligence Artificielle, Université d'Aix
  Marseille, Luminy.
  @l(http://alain.colmerauer.free.fr/alcol/ArchivesPublications/HommeMachineFr/HoMa.pdf<>–›)

  @t(Cormen et al. 1990) Cormen, Thomas, Charles Leiserson, and Ronald
  Rivest. 1990. @q(Introduction to Algorithms). Cambridge, @A(MA): @A(MIT)
  Press.

  @t(Darlington et al. 1982) Darlington, John, Peter Henderson, and David
  Turner. 1982. @q(Functional Programming and Its Applications). New York:
  Cambridge University Press.

  @t(Dijkstra 1968a) Dijkstra, Edsger W. 1968a. The structure of the @"(@A(THE))
  multiprogramming system. @q(Communications of the @A(ACM)) 11(5): 341-346.
  @l(http://www.cs.utexas.edu/users/EWD/ewd01xx/EWD196.PDF<>–›)

  @t(1968b) Dijkstra, Edsger W. 1968b. Cooperating sequential processes. In
  @q(Programming Languages), edited by F. Genuys. New York: Academic Press,
  pp. 43-112.  @l(http://www.cs.utexas.edu/users/EWD/ewd01xx/EWD123.PDF<>–›)

  @t(Dinesman 1968) Dinesman, Howard P. 1968. @q(Superior Mathematical
  Puzzles). New York: Simon and Schuster.

  @t(deKleer et al. 1977) deKleer, Johan, Jon Doyle, Guy Steele, and Gerald
  J. Sussman. 1977.  @A(AMORD): Explicit control of reasoning. In @q(Proceedings
  of the @A(ACM) Symposium on Artificial Intelligence and Programming
  Languages), pp. 116-125.  @l(http://dspace.mit.edu/handle/1721.1/5750<>–›)

  @t[Doyle (1979)] Doyle, Jon. 1979. A truth maintenance system. @q(Artificial
  Intelligence) 12: 231-272.  @l(http://dspace.mit.edu/handle/1721.1/5733<>–›)

  @t(Feigenbaum and Shrobe 1993) Feigenbaum, Edward, and Howard
  Shrobe. 1993. The Japanese National Fifth Generation Project: Introduction,
  survey, and evaluation. In @q(Future Generation Computer Systems), vol. 9,
  pp. 105-117.  @l(https://saltworks.stanford.edu/assets/kv359wz9060.pdf<>–›)

  @t[Feeley (1986)] Feeley, Marc. 1986. Deux approches à l'implantation du
  language Scheme. Masters thesis, Université de Montréal.
  @l(http://www.iro.umontreal.ca/~feeley/papers/FeeleyMSc.pdf<>–›)

  @t(Feeley and Lapalme 1987) Feeley, Marc and Guy Lapalme. 1987. Using closures
  for code generation.  @q(Journal of Computer Languages) 12(1): 47-66.
  @l(http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.90.6978<>–›)

  Feller, William. 1957. @q(An Introduction to Probability Theory and Its
  Applications), volume 1. New York: John Wiley & Sons.

  @t[Fenichel and Yochelson (1969)] Fenichel, R., and J. Yochelson. 1969. A Lisp
  garbage collector for virtual memory computer systems. @q(Communications of
  the @A(ACM)) 12(11): 611-612.
  @l(https://www.cs.purdue.edu/homes/hosking/690M/p611-fenichel.pdf<>–›)

  @t[Floyd (1967)] Floyd, Robert. 1967. Nondeterministic
  algorithms. @q(@A(JACM)), 14(4): 636-644.
  @l(http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.332.36<>–›)

  @t(Forbus and deKleer 1993) Forbus, Kenneth D., and Johan
  deKleer. 1993. @q(Building Problem Solvers). Cambridge, @A(MA): @A(MIT) Press.

  @t[Friedman and Wise (1976)] Friedman, Daniel P., and David
  S. Wise. 1976. @A(CONS) should not evaluate its arguments. In @q(Automata,
  Languages, and Programming: Third International Colloquium), edited by
  S. Michaelson and R. Milner, pp. 257-284.
  @l(https://www.cs.indiana.edu/cgi-bin/techreports/TRNNN.cgi?trnum=TR44<>–›)

  @t(Friedman et al. 1992) Friedman, Daniel P., Mitchell Wand, and Christopher
  T. Haynes. 1992.  @q(Essentials of Programming Languages). Cambridge, @A(MA):
  @A(MIT) Press/McGraw-Hill.

  @t(Gabriel 1988) Gabriel, Richard P. 1988. The Why of @e(Y). @q(Lisp Pointers)
  2(2): 15-25.  @l(http://www.dreamsongs.com/Files/WhyOfY.pdf<>–›)

  Goldberg, Adele, and David Robson. 1983. @q(Smalltalk-80: The Language and Its
  Implementation). Reading, @A(MA): Addison-Wesley.
  @l(http://stephane.ducasse.free.fr/FreeBooks/BlueBook/Bluebook.pdf<>–›)

  @t(Gordon et al. 1979) Gordon, Michael, Robin Milner, and Christopher
  Wadsworth. 1979.  @q(Edinburgh @A(LCF)). Lecture Notes in Computer Science,
  volume 78. New York: Springer-Verlag.

  @t(Gray and Reuter 1993) Gray, Jim, and Andreas Reuter. 1993. @q(Transaction
  Processing: Concepts and Models). San Mateo, @A(CA): Morgan-Kaufman.

  @t(Green 1969) Green, Cordell. 1969. Application of theorem proving to problem
  solving. In @q(Proceedings of the International Joint Conference on Artificial
  Intelligence), pp. 219-240.
  @l(http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.81.9820<>–›)

  @t[Green and Raphael (1968)] Green, Cordell, and Bertram Raphael. 1968. The
  use of theorem-proving techniques in question-answering systems. In
  @q(Proceedings of the @A(ACM) National Conference), pp. 169-181.
  @l(http://www.kestrel.edu/home/people/green/publications/green-raphael.pdf<>–›)

  @t(Griss 1981) Griss, Martin L. 1981. Portable Standard Lisp, a brief
  overview. Utah Symbolic Computation Group Operating Note 58, University of
  Utah.

  @t(Guttag 1977) Guttag, John V. 1977. Abstract data types and the development
  of data structures. @q(Communications of the @A(ACM)) 20(6): 396-404.
  @l(http://www.unc.edu/~stotts/comp723/guttagADT77.pdf<>–›)

  @t(Hamming 1980) Hamming, Richard W. 1980. @q(Coding and Information
  Theory). Englewood Cliffs, N.J.: Prentice-Hall.

  @t(Hanson 1990) Hanson, Christopher P. 1990. Efficient stack allocation for
  tail-recursive languages. In @q(Proceedings of @A(ACM) Conference on Lisp and
  Functional Programming), pp. 106-118.
  @l(https://groups.csail.mit.edu/mac/ftpdir/users/cph/links.ps.gz<>–›)

  @t(Hanson 1991) Hanson, Christopher P. 1991. A syntactic closures macro
  facility. @q(Lisp Pointers), 4(3).
  @l(http://groups.csail.mit.edu/mac/ftpdir/scheme-reports/synclo.ps<>–›)

  @t(Hardy 1921) Hardy, Godfrey H. 1921. Srinivasa Ramanujan. @q(Proceedings of
  the London Mathematical Society) @A(XIX)(2).

  @t(Hardy and Wright 1960) Hardy, Godfrey H., and E. M. Wright. 1960. @q(An
  Introduction to the Theory of Numbers). 4th edition. New York: Oxford
  University Press.
  @l(https://archive.org/details/AnIntroductionToTheTheoryOfNumbers-4thEd-G.h.HardyE.m.Wright<>–›)

  @t[Havender (1968)] Havender, J. 1968. Avoiding deadlocks in multi-tasking
  systems. @q(IBM Systems Journal) 7(2): 74-84.

  @t(Hearn 1969) Hearn, Anthony C. 1969. Standard Lisp. Technical report
  @A(AIM)-90, Artificial Intelligence Project, Stanford University.
  @l(http://www.softwarepreservation.org/projects/LISP/stanford/Hearn-StandardLisp-AIM-90.pdf<>–›)

  @t(Henderson 1980) Henderson, Peter. 1980. @q(Functional Programming:
  Application and Implementation). Englewood Cliffs, N.J.: Prentice-Hall.

  @t(Henderson 1982) Henderson. Peter. 1982. Functional Geometry. In
  @q(Conference Record of the 1982 @A(ACM) Symposium on Lisp and Functional
  Programming), pp. 179-187.
  @l(http://pmh-systems.co.uk/phAcademic/papers/funcgeo.pdf<>–›),
  @l(http://eprints.soton.ac.uk/257577/1/funcgeo2.pdf<>2002 version –›)

  @t[Hewitt (1969)] Hewitt, Carl E. 1969. @A(PLANNER): A language for proving
  theorems in robots. In @q(Proceedings of the International Joint Conference on
  Artificial Intelligence), pp. 295-301.
  @l(http://dspace.mit.edu/handle/1721.1/6171<>–›)

  @t[Hewitt (1977)] Hewitt, Carl E. 1977. Viewing control structures as patterns
  of passing messages. @q(Journal of Artificial Intelligence) 8(3): 323-364.
  @l(http://dspace.mit.edu/handle/1721.1/6272<>–›)

  @t[Hoare (1972)] Hoare, C. A. R. 1972. Proof of correctness of data
  representations.  @q(Acta Informatica) 1(1).

  @t(Hodges 1983) Hodges, Andrew. 1983. @q(Alan Turing: The Enigma). New York:
  Simon and Schuster.

  @t(Hofstadter 1979) Hofstadter, Douglas R. 1979. @q(G@@"odel, Escher, Bach: An
  Eternal Golden Braid). New York: Basic Books.

  @t(Hughes 1990) Hughes, R. J. M. 1990. Why functional programming matters. In
  @q(Research Topics in Functional Programming), edited by David
  Turner. Reading, @A(MA): Addison-Wesley, pp. 17-42.
  @l(http://www.cs.kent.ac.uk/people/staff/dat/miranda/whyfp90.pdf<>–›)

  @t(IEEE 1990) @A(IEEE) Std 1178-1990. 1990. @q(@A(IEEE) Standard for the
  Scheme Programming Language).

  @t(Ingerman et al. 1960) Ingerman, Peter, Edgar Irons, Kirk Sattley, and
  Wallace Feurzeig; assisted by M. Lind, Herbert Kanner, and Robert
  Floyd. 1960. @A(THUNKS): A way of compiling procedure statements, with some
  comments on procedure declarations.  Unpublished manuscript. (Also, private
  communication from Wallace Feurzeig.)

  @t(Kaldewaij 1990) Kaldewaij, Anne. 1990. @q(Programming: The Derivation of
  Algorithms). New York: Prentice-Hall.

  @t[Knuth (1973)] Knuth, Donald E. 1973. @q(Fundamental Algorithms). Volume 1
  of @q(The Art of Computer Programming). 2nd edition. Reading, @A(MA):
  Addison-Wesley.

  @t(Knuth 1981) Knuth, Donald E. 1981. @q(Seminumerical Algorithms). Volume 2
  of @q(The Art of Computer Programming). 2nd edition. Reading, @A(MA):
  Addison-Wesley.

  @t(Kohlbecker 1986) Kohlbecker, Eugene Edmund, Jr. 1986. Syntactic extensions
  in the programming language Lisp. Ph.D. thesis, Indiana University.
  @l(http://www.ccs.neu.edu/scheme/pubs/dissertation-kohlbecker.pdf<>–›)

  @t(Konopasek and Jayaraman 1984) Konopasek, Milos, and Sundaresan
  Jayaraman. 1984. @q(The TK!Solver Book: A Guide to Problem-Solving in Science,
  Engineering, Business, and Education). Berkeley, @A(CA): Osborne/McGraw-Hill.

  @t[Kowalski (1973; 1979)] Kowalski, Robert. 1973. Predicate logic as a
  programming language. Technical report 70, Department of Computational Logic,
  School of Artificial Intelligence, University of Edinburgh.
  @l(http://www.doc.ic.ac.uk/~rak/papers/IFIP%2074.pdf<>–›)

  Kowalski, Robert. 1979. @q(Logic for Problem Solving). New York:
  North-Holland.
  @l(http://www.doc.ic.ac.uk/%7Erak/papers/LogicForProblemSolving.pdf<>–›)

  @t[Lamport (1978)] Lamport, Leslie. 1978. Time, clocks, and the ordering of
  events in a distributed system. @q(Communications of the @A(ACM)) 21(7):
  558-565.
  @l(http://research.microsoft.com/en-us/um/people/lamport/pubs/time-clocks.pdf<>–›)

  @t(Lampson et al. 1981) Lampson, Butler, J. J. Horning, R. London,
  J. G. Mitchell, and G. K. Popek.
  1981. Report on the programming language Euclid. Technical report, Computer
  Systems Research Group, University of Toronto.
  @l(http://www.bitsavers.org/pdf/xerox/parc/techReports/CSL-81-12_Report_On_The_Programming_Language_Euclid.pdf<>–›)

  @t[Landin (1965)] Landin, Peter. 1965. A correspondence between Algol 60 and
  Church's lambda notation: Part I. @q(Communications of the @A(ACM)) 8(2):
  89-101.

  @t(Lieberman and Hewitt 1983) Lieberman, Henry, and Carl E. Hewitt. 1983. A
  real-time garbage collector based on the lifetimes of
  objects. @q(Communications of the @A(ACM)) 26(6): 419-429.
  @l(http://dspace.mit.edu/handle/1721.1/6335<>–›)

  @t[Liskov and Zilles (1975)] Liskov, Barbara H., and Stephen
  N. Zilles. 1975. Specification techniques for data abstractions. @q(@A(IEEE)
  Transactions on Software Engineering) 1(1): 7-19.
  @l(http://csg.csail.mit.edu/CSGArchives/memos/Memo-117.pdf<>–›)

  @t[McAllester (1978; 1980)] McAllester, David Allen. 1978. A three-valued
  truth-maintenance system. Memo 473, @A(MIT) Artificial Intelligence
  Laboratory.  @l(http://dspace.mit.edu/handle/1721.1/6296<>–›)

  McAllester, David Allen. 1980. An outlook on truth maintenance. Memo 551,
  @A(MIT) Artificial Intelligence Laboratory.
  @l(http://dspace.mit.edu/handle/1721.1/6327<>–›)

  @t(McCarthy 1960) McCarthy, John. 1960. Recursive functions of symbolic
  expressions and their computation by machine. @q(Communications of the
  @A(ACM)) 3(4): 184-195.
  @l(http://www-formal.stanford.edu/jmc/recursive.pdf<>–›)

  @t(McCarthy 1963) McCarthy, John. 1963. A basis for a mathematical theory of
  computation. In @q(Computer Programming and Formal Systems), edited by
  P. Braffort and D. Hirschberg. North-Holland.
  @l(http://www-formal.stanford.edu/jmc/basis.html<>–›)

  @t(McCarthy 1978) McCarthy, John. 1978. The history of Lisp. In @q(Proceedings
  of the @A(ACM) @A(SIGPLAN) Conference on the History of Programming
  Languages).  @l(http://www-formal.stanford.edu/jmc/history/lisp/lisp.html<>–›)

  @t(McCarthy et al. 1965) McCarthy, John, P. W. Abrahams, D. J. Edwards,
  T. P. Hart, and M. I. Levin.
  1965. @q(Lisp 1.5 Programmer's Manual). 2nd edition. Cambridge, @A(MA):
  @A(MIT) Press.
  @l(http://www.softwarepreservation.org/projects/LISP/book/LISP%201.5%20Programmers%20Manual.pdf/view<>–›)

  @t[McDermott and Sussman (1972)] McDermott, Drew, and Gerald Jay
  Sussman. 1972. Conniver reference manual.  Memo 259, @A(MIT) Artificial
  Intelligence Laboratory.  @l(http://dspace.mit.edu/handle/1721.1/6203<>–›)

  @t(Miller 1976) Miller, Gary L. 1976. Riemann's Hypothesis and tests for
  primality.  @q(Journal of Computer and System Sciences) 13(3): 300-317.
  @l(http://www.cs.cmu.edu/~glmiller/Publications/b2hd-Mi76.html<>–›)

  @t(Miller and Rozas 1994) Miller, James S., and Guillermo
  J. Rozas. 1994. Garbage collection is fast, but a stack is faster. Memo 1462,
  @A(MIT) Artificial Intelligence Laboratory.
  @l(http://dspace.mit.edu/handle/1721.1/6622<>–›)

  @t(Moon 1978) Moon, David. 1978. MacLisp reference manual,
  Version 0. Technical report, @A(MIT) Laboratory for Computer Science.
  @l(http://www.softwarepreservation.org/projects/LISP/MIT/Moon-MACLISP_Reference_Manual-Apr_08_1974.pdf/view<>–›)

  @t(Moon and Weinreb 1981) Moon, David, and Daniel Weinreb. 1981. Lisp machine
  manual. Technical report, @A(MIT) Artificial Intelligence Laboratory.
  @l(http://www.unlambda.com/lmman/index.html<>–›)

  @t(Morris et al. 1980) Morris, J. H., Eric Schmidt, and Philip
  Wadler. 1980. Experience with an applicative string processing language. In
  @q(Proceedings of the 7th Annual @A(ACM) @A(SIGACT)/@A(SIGPLAN) Symposium on
  the Principles of Programming Languages).

  @t(Phillips 1934) Phillips, Hubert. 1934. @q(The Sphinx Problem Book). London:
  Faber and Faber.

  @t(Pitman 1983) Pitman, Kent. 1983. The revised MacLisp Manual (Saturday
  evening edition).  Technical report 295, @A(MIT) Laboratory for Computer
  Science.  @l(http://maclisp.info/pitmanual<>–›)

  @t(Rabin 1980) Rabin, Michael O. 1980. Probabilistic algorithm for testing
  primality.  @q(Journal of Number Theory) 12: 128-138.

  @t(Raymond 1993) Raymond, Eric. 1993. @q(The New Hacker's Dictionary). 2nd
  edition.  Cambridge, @A(MA): @A(MIT) Press.
  @l(http://www.catb.org/jargon/<>–›)

  Raynal, Michel. 1986. @q(Algorithms for Mutual Exclusion). Cambridge, @A(MA):
  @A(MIT) Press.

  @t(Rees and Adams 1982) Rees, Jonathan A., and Norman I. Adams IV. 1982. T: A
  dialect of Lisp or, lambda: The ultimate software tool. In @q(Conference
  Record of the 1982 @A(ACM) Symposium on Lisp and Functional Programming),
  pp. 114-122.  @l(http://people.csail.mit.edu/riastradh/t/adams82t.pdf<>–›)

  Rees, Jonathan, and William Clinger (eds). 1991. The revised⁴ report on the
  algorithmic language Scheme. @q(Lisp Pointers), 4(3).
  @l(http://people.csail.mit.edu/jaffer/r4rs.pdf<>–›)

  @t[Rivest et al. (1977)] Rivest, Ronald, Adi Shamir, and Leonard
  Adleman. 1977. A method for obtaining digital signatures and public-key
  cryptosystems. Technical memo @A(LCS)/@A(TM82), @A(MIT) Laboratory for
  Computer Science.  @l(http://people.csail.mit.edu/rivest/Rsapaper.pdf<>–›)

  @t(Robinson 1965) Robinson, J. A. 1965. A machine-oriented logic based on the
  resolution principle. @q(Journal of the @A(ACM)) 12(1): 23.

  @t(Robinson 1983) Robinson, J. A. 1983. Logic programming––Past, present, and
  future.  @q(New Generation Computing) 1: 107-124.

  @t(Spafford 1989) Spafford, Eugene H. 1989. The Internet Worm: Crisis and
  aftermath.  @q(Communications of the @A(ACM)) 32(6): 678-688.
  @l(http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.123.8503&rep=rep1&type=pdf<>–›)

  @t(Steele 1977) Steele, Guy Lewis, Jr. 1977. Debunking the @"(expensive
  procedure call) myth.  In @q(Proceedings of the National Conference of the
  @A(ACM)), pp. 153-62.  @l(http://dspace.mit.edu/handle/1721.1/5753<>–›)

  @t(Steele 1982) Steele, Guy Lewis, Jr. 1982. An overview of Common Lisp. In
  @q(Proceedings of the @A(ACM) Symposium on Lisp and Functional Programming),
  pp. 98-107.

  @t(Steele 1990) Steele, Guy Lewis, Jr. 1990. @q(Common Lisp: The
  Language). 2nd edition.  Digital Press.
  @l(http://www.cs.cmu.edu/Groups/AI/html/cltl/cltl2.html<>–›)

  @t(Steele and Sussman 1975) Steele, Guy Lewis, Jr., and Gerald Jay
  Sussman. 1975. Scheme: An interpreter for the extended lambda calculus. Memo
  349, @A(MIT) Artificial Intelligence Laboratory.
  @l(http://dspace.mit.edu/handle/1721.1/5794<>–›)

  @t(Steele et al. 1983) Steele, Guy Lewis, Jr., Donald R. Woods, Raphael
  A. Finkel, Mark R. Crispin, Richard M. Stallman, and Geoffrey
  S. Goodfellow. 1983. @q(The Hacker's Dictionary). New York: Harper & Row.
  @l(http://www.dourish.com/goodies/jargon.html<>–›)

  @t(Stoy 1977) Stoy, Joseph E. 1977. @q(Denotational Semantics). Cambridge,
  @A(MA): @A(MIT) Press.

  @t(Sussman and Stallman 1975) Sussman, Gerald Jay, and Richard
  M. Stallman. 1975. Heuristic techniques in computer-aided circuit
  analysis. @q(@A(IEEE) Transactions on Circuits and Systems) @A(CAS)-22(11):
  857-865.  @l(http://dspace.mit.edu/handle/1721.1/5803<>–›)

  @t(Sussman and Steele 1980) Sussman, Gerald Jay, and Guy Lewis Steele
  Jr. 1980. Constraints––A language for expressing almost-hierachical
  descriptions. @q(AI Journal) 14: 1-39.
  @l(http://dspace.mit.edu/handle/1721.1/6312<>–›)

  @t(Sussman and Wisdom 1992) Sussman, Gerald Jay, and Jack
  Wisdom. 1992. Chaotic evolution of the solar system. @q(Science) 257: 256-262.
  @l(http://groups.csail.mit.edu/mac/users/wisdom/ss-chaos.pdf<>–›)

  @t[Sussman et al. (1971)] Sussman, Gerald Jay, Terry Winograd, and Eugene
  Charniak. 1971. Microplanner reference manual. Memo 203@A(A), @A(MIT)
  Artificial Intelligence Laboratory.
  @l(http://dspace.mit.edu/handle/1721.1/6184<>–›)

  @t[Sutherland (1963)] Sutherland, Ivan E. 1963. @A(SKETCHPAD): A man-machine
  graphical communication system. Technical report 296, @A(MIT) Lincoln
  Laboratory.  @l(https://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-574.pdf<>–›)

  @t(Teitelman 1974) Teitelman, Warren. 1974. Interlisp reference
  manual. Technical report, Xerox Palo Alto Research Center.
  @l(http://www.softwarepreservation.org/projects/LISP/interlisp/Interlisp-Oct_1974.pdf/view<>–›)

  @t(Thatcher et al. 1978) Thatcher, James W., Eric G. Wagner, and Jesse
  B. Wright. 1978. Data type specification: Parameterization and the power of
  specification techniques. In @q(Conference Record of the Tenth Annual @A(ACM)
  Symposium on Theory of Computing), pp. 119-132.

  @t(Turner 1981) Turner, David. 1981. The future of applicative languages. In
  @q(Proceedings of the 3rd European Conference on Informatics), Lecture Notes
  in Computer Science, volume 123. New York: Springer-Verlag, pp. 334-348.

  @t(Wand 1980) Wand, Mitchell. 1980. Continuation-based program transformation
  strategies.  @q(Journal of the @A(ACM)) 27(1): 164-180.
  @l(http://www.diku.dk/OLD/undervisning/2005e/224/papers/Wand80.pdf<>–›)

  @t[Waters (1979)] Waters, Richard C. 1979. A method for analyzing loop
  programs.  @q(@A(IEEE) Transactions on Software Engineering) 5(3): 237-247.

  Winograd, Terry. 1971. Procedures as a representation for data in a computer
  program for understanding natural language. Technical report @A(AI TR)-17,
  @A(MIT) Artificial Intelligence Laboratory.
  @l(http://dspace.mit.edu/handle/1721.1/7095<>–›)

  @t(Winston 1992) Winston, Patrick. 1992. @q(Artificial Intelligence). 3rd
  edition. Reading, @A(MA): Addison-Wesley.

  @t(Zabih et al. 1987) Zabih, Ramin, David McAllester, and David
  Chapman. 1987. Non-deterministic Lisp with dependency-directed
  backtracking. @q(@A(AAAI)-87), pp. 59-64.
  @l(http://www.aaai.org/Papers/AAAI/1987/AAAI87-011.pdf<>–›)

  @t[Zippel (1979)] Zippel, Richard. 1979. Probabilistic algorithms for sparse
  polynomials.  Ph.D. dissertation, Department of Electrical Engineering and
  Computer Science, @A(MIT).

  @t(Zippel 1993) Zippel, Richard. 1993. @q(Effective Polynomial
  Computation). Boston, @A(MA): Kluwer Academic Publishers.

* Colophon

  On the cover page is Agostino Ramelli's bookwheel mechanism from 1588. It
  could be seen as an early hypertext navigation aid. This image of the
  engraving is hosted by J. E. Johnson of
  @l(http://newgottland.com/2012/02/09/before-the-ereader-there-was-the-wheelreader/ramelli_bookwheel_1032px/<>New Gottland).

  The typefaces are Linux Libertine for body text and Linux Biolinum for
  headings, both by Philipp H. Poll. Typewriter face is Inconsolata created by
  Raph Levien and supplemented by Dimosthenis Kaponis and Takashi Tanigawa in
  the form of Inconsolata LGC.

  Graphic design and typography are done by Andres Raba. Texinfo source is
  converted to @A(HTML) using a customized version of @c(texi2any) utility in
  Texinfo 5.1 package. Diagrams are drawn with Inkscape and mathematics is
  typeset with the help of MathJax and MathML.

* Notes

  :: @N(1) :: The @q(Lisp 1 Programmer's Manual) appeared in 1960 and the
     @q(Lisp 1.5 Programmer's Manual) (@l(#McCarthy et al. 1965)) was published
     in 1962. The early history of Lisp is described in @l(#McCarthy 1978).

  :: @N(2) :: The two dialects in which most major Lisp programs of the 1970s
     were written are MacLisp (@l(#Moon 1978); @l(#Pitman 1983)), developed at
     the @A(MIT) Project @A(MAC), and Interlisp (@l(#Teitelman 1974)), developed
     at Bolt Beranek and Newman Inc. and the Xerox Palo Alto Research Center.
     Portable Standard Lisp (@l(#Hearn 1969); @l(#Griss 1981)) was a Lisp
     dialect designed to be easily portable between different machines. MacLisp
     spawned a number of subdialects, such as Franz Lisp, which was developed at
     the University of California at Berkeley, and Zetalisp (@l(#Moon and
     Weinreb 1981)), which was based on a special-purpose processor designed at
     the @A(MIT) Artificial Intelligence Laboratory to run Lisp very
     efficiently. The Lisp dialect used in this book, called Scheme (@l(#Steele
     and Sussman 1975)), was invented in 1975 by Guy Lewis Steele Jr. and Gerald
     Jay Sussman of the @A(MIT) Artificial Intelligence Laboratory and later
     reimplemented for instructional use at @A(MIT). Scheme became an @A(IEEE)
     standard in 1990 (@l(#IEEE 1990)). The Common Lisp dialect (@l(#Steele
     1982), @l(#Steele 1990)) was developed by the Lisp community to combine
     features from the earlier Lisp dialects to make an industrial standard for
     Lisp. Common Lisp became an @A(ANSI) standard in 1994 (@l(#ANSI 1994)).

  :: @N(3) :: One such special application was a breakthrough computation of
     scientific importance––an integration of the motion of the Solar System
     that extended previous results by nearly two orders of magnitude, and
     demonstrated that the dynamics of the Solar System is chaotic. This
     computation was made possible by new integration algorithms, a
     special-purpose compiler, and a special-purpose computer all implemented
     with the aid of software tools written in Lisp (@l(#Abelson et al. 1992);
     @l(#Sussman and Wisdom 1992)).

  :: @N(4) :: The characterization of numbers as @"(simple data) is a barefaced
     bluff. In fact, the treatment of numbers is one of the trickiest and most
     confusing aspects of any programming language. Some typical issues involved
     are these: Some computer systems distinguish @e(integers), such as 2, from
     @e(real numbers), such as 2.71. Is the real number 2.00 different from the
     integer 2?  Are the arithmetic operations used for integers the same as the
     operations used for real numbers?  Does 6 divided by 2 produce 3, or 3.0?
     How large a number can we represent?  How many decimal places of accuracy
     can we represent?  Is the range of integers the same as the range of real
     numbers?  Above and beyond these questions, of course, lies a collection of
     issues concerning roundoff and truncation errors––the entire science of
     numerical analysis. Since our focus in this book is on large-scale program
     design rather than on numerical techniques, we are going to ignore these
     problems. The numerical examples in this chapter will exhibit the usual
     roundoff behavior that one observes when using arithmetic operations that
     preserve a limited number of decimal places of accuracy in noninteger
     operations.

  :: @N(5) :: Throughout this book, when we wish to emphasize the distinction
     between the input typed by the user and the response printed by the
     interpreter, we will show the latter in evenly highlighted characters.

  :: @N(6) :: Lisp systems typically provide features to aid the user in
     formatting expressions. Two especially useful features are one that
     automatically indents to the proper pretty-print position whenever a new
     line is started and one that highlights the matching left parenthesis
     whenever a right parenthesis is typed.

  :: @N(7) :: Lisp obeys the convention that every expression has a value. This
     convention, together with the old reputation of Lisp as an inefficient
     language, is the source of the quip by Alan Perlis (paraphrasing Oscar
     Wilde) that @"(Lisp programmers know the value of everything but the cost
     of nothing.)

  :: @N(8) :: In this book, we do not show the interpreter's response to
     evaluating definitions, since this is highly implementation-dependent.

  :: @N(9) :: @l(#Chapter 3) will show that this notion of environment is
     crucial, both for understanding how the interpreter works and for
     implementing interpreters.

  :: @N(10) :: It may seem strange that the evaluation rule says, as part of the
     first step, that we should evaluate the leftmost element of a combination,
     since at this point that can only be an operator such as @c(+) or @c(*)
     representing a built-in primitive procedure such as addition or
     multiplication. We will see later that it is useful to be able to work with
     combinations whose operators are themselves compound expressions.

  :: @N(11) :: Special syntactic forms that are simply convenient alternative
     surface structures for things that can be written in more uniform ways are
     sometimes called @e(syntactic sugar), to use a phrase coined by Peter
     Landin. In comparison with users of other languages, Lisp programmers, as a
     rule, are less concerned with matters of syntax. (By contrast, examine any
     Pascal manual and notice how much of it is devoted to descriptions of
     syntax.)  This disdain for syntax is due partly to the flexibility of Lisp,
     which makes it easy to change surface syntax, and partly to the observation
     that many @"(convenient) syntactic constructs, which make the language less
     uniform, end up causing more trouble than they are worth when programs
     become large and complex. In the words of Alan Perlis, @"(Syntactic sugar
     causes cancer of the semicolon.)

  :: @N(12) :: Observe that there are two different operations being combined
     here: we are creating the procedure, and we are giving it the name
     @c(square). It is possible, indeed important, to be able to separate these
     two notions––to create procedures without naming them, and to give names to
     procedures that have already been created. We will see how to do this in
     @l(#1.3.2).

  :: @N(13) :: Throughout this book, we will describe the general syntax of
     expressions by using italic symbols delimited by angle brackets––e.g.,
     @c[(name)]––to denote the @"(slots) in the expression to be filled in when
     such an expression is actually used.

  :: @N(14) :: More generally, the body of the procedure can be a sequence of
     expressions. In this case, the interpreter evaluates each expression in the
     sequence in turn and returns the value of the final expression as the value
     of the procedure application.

  :: @N(15) :: Despite the simplicity of the substitution idea, it turns out to
     be surprisingly complicated to give a rigorous mathematical definition of
     the substitution process. The problem arises from the possibility of
     confusion between the names used for the formal parameters of a procedure
     and the (possibly identical) names used in the expressions to which the
     procedure may be applied. Indeed, there is a long history of erroneous
     definitions of @e(substitution) in the literature of logic and programming
     semantics.  See @l(#Stoy 1977) for a careful discussion of substitution.

  :: @N(16) :: In @l(#Chapter 3) we will introduce @e(stream processing), which
     is a way of handling apparently @"(infinite) data structures by
     incorporating a limited form of normal-order evaluation. In @l(#4.2) we
     will modify the Scheme interpreter to produce a normal-order variant of
     Scheme.

  :: @N(17) :: @"(Interpreted as either true or false) means this: In Scheme,
     there are two distinguished values that are denoted by the constants @c(#t)
     and @c(#f). When the interpreter checks a predicate's value, it interprets
     @c(#f) as false. Any other value is treated as true.  (Thus, providing
     @c(#t) is logically unnecessary, but it is convenient.)  In this book we
     will use names @c(true) and @c(false), which are associated with the values
     @c(#t) and @c(#f) respectively.

  :: @N(18) :: @c(Abs) also uses the @"(minus) operator @c(-), which, when used
     with a single operand, as in @c[(- x)], indicates negation.}

  :: @N(19) :: A minor difference between @c(if) and @c(cond) is that the
     @c[(e)] part of each @c(cond) clause may be a sequence of expressions. If
     the corresponding @c[(p)] is found to be true, the expressions @c[(e)] are
     evaluated in sequence and the value of the final expression in the sequence
     is returned as the value of the @c(cond). In an @c(if) expression, however,
     the @c[(consequent)] and @c[(alternative)] must be single expressions.

  :: @N(20) :: Declarative and imperative descriptions are intimately related,
     as indeed are mathematics and computer science. For instance, to say that
     the answer produced by a program is @"(correct) is to make a declarative
     statement about the program.  There is a large amount of research aimed at
     establishing techniques for proving that programs are correct, and much of
     the technical difficulty of this subject has to do with negotiating the
     transition between imperative statements (from which programs are
     constructed) and declarative statements (which can be used to deduce
     things).  In a related vein, an important current area in
     programming-language design is the exploration of so-called very high-level
     languages, in which one actually programs in terms of declarative
     statements.  The idea is to make interpreters sophisticated enough so that,
     given @"(what is) knowledge specified by the programmer, they can generate
     @"(how to) knowledge automatically. This cannot be done in general, but
     there are important areas where progress has been made. We shall revisit
     this idea in @l(#Chapter 4).

  :: @N(21) :: This square-root algorithm is actually a special case of Newton's
     method, which is a general technique for finding roots of equations. The
     square-root algorithm itself was developed by Heron of Alexandria in the
     first century A.D. We will see how to express the general Newton's method
     as a Lisp procedure in @l(#1.3.4).

  :: @N(22) :: We will usually give predicates names ending with question marks,
     to help us remember that they are predicates.  This is just a stylistic
     convention. As far as the interpreter is concerned, the question mark is
     just an ordinary character.

  :: @N(23) :: Observe that we express our initial guess as 1.0 rather
     than 1. This would not make any difference in many Lisp
     implementations. @A(MIT) Scheme, however, distinguishes between exact
     integers and decimal values, and dividing two integers produces a rational
     number rather than a decimal. For example, dividing 10 by 6 yields 5/3,
     while dividing 10.0 by 6.0 yields 1.6666666666666667. (We will learn how to
     implement arithmetic on rational numbers in @l(#2.1.1).)  If we start with
     an initial guess of 1 in our square-root program, and @m(x) is an exact
     integer, all subsequent values produced in the square-root computation will
     be rational numbers rather than decimals. Mixed operations on rational
     numbers and decimals always yield decimals, so starting with an initial
     guess of 1.0 forces all subsequent values to be decimals.

  :: @N(24) :: Readers who are worried about the efficiency issues involved in
     using procedure calls to implement iteration should note the remarks on
     @"(tail recursion) in @l(#1.2.1).

  :: @N(25) :: It is not even clear which of these procedures is a more
     efficient implementation. This depends upon the hardware available. There
     are machines for which the @"(obvious) implementation is the less efficient
     one. Consider a machine that has extensive tables of logarithms and
     antilogarithms stored in a very efficient manner.

  :: @N(26) :: The concept of consistent renaming is actually subtle and
     difficult to define formally. Famous logicians have made embarrassing
     errors here.

  :: @N(27) :: Lexical scoping dictates that free variables in a procedure are
     taken to refer to bindings made by enclosing procedure definitions; that
     is, they are looked up in the environment in which the procedure was
     defined. We will see how this works in detail in chapter 3 when we study
     environments and the detailed behavior of the interpreter.@t(Footnote 28)

  :: @N(28) :: Embedded definitions must come first in a procedure body. The
     management is not responsible for the consequences of running programs that
     intertwine definition and use.

  :: @N(29) :: In a real program we would probably use the block structure
     introduced in the last section to hide the definition of @c(fact-iter):

     ..src > scheme
       (define (factorial n)
         (define (iter product counter)
           (if (> counter n)
               product
               (iter (* counter product)
                     (+ counter 1))))
         (iter 1 1))
     < src..

     We avoided doing this here so as to minimize the number of things to think
     about at once.

  :: @N(30) :: When we discuss the implementation of procedures on register
     machines in @l(#Chapter 5), we will see that any iterative process can be
     realized @"(in hardware) as a machine that has a fixed set of registers and
     no auxiliary memory. In contrast, realizing a recursive process requires a
     machine that uses an auxiliary data structure known as a @e(stack).

  :: @N(31) :: Tail recursion has long been known as a compiler optimization
     trick. A coherent semantic basis for tail recursion was provided by Carl
     @l[#Hewitt (1977)], who explained it in terms of the @"(message-passing)
     model of computation that we shall discuss in @l(#Chapter 3). Inspired by
     this, Gerald Jay Sussman and Guy Lewis Steele Jr. (see @l(#Steele and
     Sussman 1975)) constructed a tail-recursive interpreter for Scheme. Steele
     later showed how tail recursion is a consequence of the natural way to
     compile procedure calls (@l(#Steele 1977)). The @A(IEEE) standard for
     Scheme requires that Scheme implementations be tail-recursive.

  :: @N(32) :: An example of this was hinted at in @l(#1.1.3). The interpreter
     itself evaluates expressions using a tree-recursive process.

  :: @N(33) :: For example, work through in detail how the reduction rule
     applies to the problem of making change for 10 cents using pennies and
     nickels.

  :: @N(34) :: One approach to coping with redundant computations is to arrange
     matters so that we automatically construct a table of values as they are
     computed. Each time we are asked to apply the procedure to some argument,
     we first look to see if the value is already stored in the table, in which
     case we avoid performing the redundant computation.  This strategy, known
     as @e(tabulation) or @e(memoization), can be implemented in a
     straightforward way. Tabulation can sometimes be used to transform
     processes that require an exponential number of steps (such as
     @c(count-change)) into processes whose space and time requirements grow
     linearly with the input. See @l(#Exercise 3.27).

  :: @N(35) :: The elements of Pascal's triangle are called the @e(binomial
     coefficients), because the @m(nᵗʰ) row consists of the coefficients of the
     terms in the expansion of @m[(x + y)ⁿ]. This pattern for computing the
     coefficients appeared in Blaise Pascal's 1653 seminal work on probability
     theory, @q(Traité du triangle arithmétique). According to @l[#Knuth
     (1973)], the same pattern appears in the @q(Szu-yuen Yü-chien) (@"(The
     Precious Mirror of the Four Elements)), published by the Chinese
     mathematician Chu Shih-chieh in 1303, in the works of the twelfth-century
     Persian poet and mathematician Omar Khayyam, and in the works of the
     twelfth-century Hindu mathematician Bháscara Áchárya.

  :: @N(36) :: These statements mask a great deal of oversimplification.  For
     instance, if we count process steps as @"(machine operations) we are making
     the assumption that the number of machine operations needed to perform,
     say, a multiplication is independent of the size of the numbers to be
     multiplied, which is false if the numbers are sufficiently large. Similar
     remarks hold for the estimates of space. Like the design and description of
     a process, the analysis of a process can be carried out at various levels
     of abstraction.}

  :: @N(37) :: More precisely, the number of multiplications required is equal
     to 1 less than the log base 2 of @m(n) plus the number of ones in the
     binary representation of @m(n). This total is always less than twice the
     log base 2 of @m(n). The arbitrary constants @m(k₁) and @m(k₂) in the
     definition of order notation imply that, for a logarithmic process, the
     base to which logarithms are taken does not matter, so all such processes
     are described as @m[Θ(log n)].

  :: @N(38) :: You may wonder why anyone would care about raising numbers to the
     1000th power. See @l(#1.2.6).

  :: @N(39) :: This iterative algorithm is ancient. It appears in the
     @q(Chandah-sutra) by Áchárya Pingala, written before 200 @A(B.C.) See
     @l(#Knuth 1981), section 4.6.3, for a full discussion and analysis of this
     and other methods of exponentiation.

  :: @N(40) :: This algorithm, which is sometimes known as the @"(Russian
     peasant method) of multiplication, is ancient. Examples of its use are
     found in the Rhind Papyrus, one of the two oldest mathematical documents in
     existence, written about 1700 @A(B.C.)  (and copied from an even older
     document) by an Egyptian scribe named A'h-mose.

  :: @N(41) :: This exercise was suggested to us by Joe Stoy, based on an
     example in @l(#Kaldewaij 1990).

  :: @N(42) :: Euclid's Algorithm is so called because it appears in Euclid's
     @q(Elements) (Book 7, ca. 300 @A(B.C.)).  According to @l(#Knuth (1973)),
     it can be considered the oldest known nontrivial algorithm. The ancient
     Egyptian method of multiplication (@l(#Exercise 1.18)) is surely older,
     but, as Knuth explains, Euclid's algorithm is the oldest known to have been
     presented as a general algorithm, rather than as a set of illustrative
     examples.

  :: @N(43) :: This theorem was proved in 1845 by Gabriel Lamé, a French
     mathematician and engineer known chiefly for his contributions to
     mathematical physics. To prove the theorem, we consider pairs @m[(aₙ, bₙ)],
     where @m(aₙ ≥ bₙ), for which Euclid's Algorithm terminates in @m(k)
     steps. The proof is based on the claim that, if @m[(aₖ₊₁, bₖ₊₁) → (aₙ, bₙ)
     → (aₖ₋₁, bₖ₋₁)] are three successive pairs in the reduction process, then
     we must have @m(bₖ₊₁ ≥ bₙ + bₖ₋₁). To verify the claim, consider that a
     reduction step is defined by applying the transformation @m(aₖ₋₁ = bₙ),
     @m(bₖ₋₁ =) remainder of @m(aₙ) divided by @m(bₙ). The second equation means
     that @m(aₙ = qbₙ + bₖ₋₁) for some positive integer @m(q). And since @m(q)
     must be at least 1 we have @m(aₙ = qbₙ + bₖ₋₁ ≥ bₙ + bₖ₋₁). But in the
     previous reduction step we have @m(bₖ₊₁ = aₙ). Therefore, @m(bₖ₊₁ = aₙ ≥
     bₙ + bₖ₋₁). This verifies the claim. Now we can prove the theorem by
     induction on @m(k), the number of steps that the algorithm requires to
     terminate. The result is true for @m(k = 1), since this merely requires
     that @m(b) be at least as large as @m[Fib(1) = 1]. Now, assume that the
     result is true for all integers less than or equal to @m(k) and establish
     the result for @m(k + 1). Let @m[(aₖ₊₁, bₖ₊₁) → (aₙ, bₙ) → (aₖ₋₁, bₖ₋₁)] be
     successive pairs in the reduction process. By our induction hypotheses, we
     have @m[bₖ₋₁ ≥ Fib(k - 1)] and @m[bₙ ≥ Fib(k)]. Thus, applying the claim we
     just proved together with the definition of the Fibonacci numbers gives
     @m[bₖ₊₁ ≥ bₙ + bₖ₋₁ ≥ Fib(k) + Fib(k-1) = Fib(k+1)], which completes the
     proof of Lamé's Theorem.

  :: @N(44) :: If @m(d) is a divisor of @m(n), then so is @m(n/d). But @m(d)
     and @m(n/d) cannot both be greater than @m(√n).

  :: @N(45) :: Pierre de Fermat (1601-1665) is considered to be the founder of
     modern number theory. He obtained many important number-theoretic results,
     but he usually announced just the results, without providing his
     proofs. Fermat's Little Theorem was stated in a letter he wrote
     in 1640. The first published proof was given by Euler in 1736 (and an
     earlier, identical proof was discovered in the unpublished manuscripts of
     Leibniz). The most famous of Fermat's results––known as Fermat's Last
     Theorem––was jotted down in 1637 in his copy of the book @q(Arithmetic) (by
     the third-century Greek mathematician Diophantus) with the remark @"(I have
     discovered a truly remarkable proof, but this margin is too small to
     contain it). Finding a proof of Fermat's Last Theorem became one of the
     most famous challenges in number theory. A complete solution was finally
     given in 1995 by Andrew Wiles of Princeton University.

  :: @N(46) :: The reduction steps in the cases where the exponent @m(e) is
     greater than 1 are based on the fact that, for any integers @m(x), @m(y),
     and @m(m), we can find the remainder of @m(x) times @m(y) modulo @m(m) by
     computing separately the remainders of @m(x) modulo @m(m) and @m(y) modulo
     @m(m), multiplying these, and then taking the remainder of the result
     modulo @m(m). For instance, in the case where @m(e) is even, we compute the
     remainder of @M(b^{e / 2}) modulo @m(m), square this, and take the
     remainder modulo @m(m). This technique is useful because it means we can
     perform our computation without ever having to deal with numbers much
     larger than @m(m).  (Compare @l(#Exercise 1.25).)

  :: @N(47) :: Numbers that fool the Fermat test are called @e(Carmichael
     numbers), and little is known about them other than that they are extremely
     rare. There are 255 Carmichael numbers below 100,000,000. The smallest few
     are 561, 1105, 1729, 2465, 2821, and 6601. In testing primality of very
     large numbers chosen at random, the chance of stumbling upon a value that
     fools the Fermat test is less than the chance that cosmic radiation will
     cause the computer to make an error in carrying out a @"(correct)
     algorithm. Considering an algorithm to be inadequate for the first reason
     but not for the second illustrates the difference between mathematics and
     engineering.

  :: @N(48) :: One of the most striking applications of probabilistic prime
     testing has been to the field of cryptography. Although it is now
     computationally infeasible to factor an arbitrary 200-digit number, the
     primality of such a number can be checked in a few seconds with the Fermat
     test. This fact forms the basis of a technique for constructing
     @"(unbreakable codes) suggested by @l(#Rivest et al. (1977)).  The
     resulting @e(RSA algorithm) has become a widely used technique for
     enhancing the security of electronic communications. Because of this and
     related developments, the study of prime numbers, once considered the
     epitome of a topic in @"(pure) mathematics to be studied only for its own
     sake, now turns out to have important practical applications to
     cryptography, electronic funds transfer, and information retrieval.

  :: @N(49) :: This series, usually written in the equivalent form @M({π\over4}
     = {1 - ⅓ + ⅕} - {⅐ + …}), is due to Leibniz. We'll see how to use this as
     the basis for some fancy numerical tricks in @l(#3.5.3).

  :: @N(50) :: Notice that we have used block structure (@l(#1.1.8)) to embed
     the definitions of @c(pi-next) and @c(pi-term) within @c(pi-sum), since
     these procedures are unlikely to be useful for any other purpose. We will
     see how to get rid of them altogether in @l(#1.3.2).

  :: @N(51) :: The intent of @l(#Exercise 1.31) through @l(#Exercise 1.33) is to
     demonstrate the expressive power that is attained by using an appropriate
     abstraction to consolidate many seemingly disparate operations. However,
     though accumulation and filtering are elegant ideas, our hands are somewhat
     tied in using them at this point since we do not yet have data structures
     to provide suitable means of combination for these abstractions. We will
     return to these ideas in @l(#2.2.3) when we show how to use @e(sequences)
     as interfaces for combining filters and accumulators to build even more
     powerful abstractions. We will see there how these methods really come into
     their own as a powerful and elegant approach to designing programs.

  :: @N(52) :: This formula was discovered by the seventeenth-century English
     mathematician John Wallis.

  :: @N(53) :: It would be clearer and less intimidating to people learning Lisp
     if a name more obvious than @c(lambda), such as @c(make-procedure), were
     used. But the convention is firmly entrenched. The notation is adopted from
     the λ-calculus, a mathematical formalism introduced by the mathematical
     logician Alonzo @l(#Church (1941)). Church developed the λ-calculus to
     provide a rigorous foundation for studying the notions of function and
     function application. The λ-calculus has become a basic tool for
     mathematical investigations of the semantics of programming languages.

  :: @N(54) :: Understanding internal definitions well enough to be sure a
     program means what we intend it to mean requires a more elaborate model of
     the evaluation process than we have presented in this chapter. The
     subtleties do not arise with internal definitions of procedures,
     however. We will return to this issue in @l(#4.1.6), after we learn more
     about evaluation.

  :: @N(55) :: We have used 0.001 as a representative @"(small) number to
     indicate a tolerance for the acceptable error in a calculation. The
     appropriate tolerance for a real calculation depends upon the problem to be
     solved and the limitations of the computer and the algorithm. This is often
     a very subtle consideration, requiring help from a numerical analyst or
     some other kind of magician.

  :: @N(56) :: This can be accomplished using @c(error), which takes as
     arguments a number of items that are printed as error messages.

  :: @N(57) :: Try this during a boring lecture: Set your calculator to radians
     mode and then repeatedly press the @c(cos) button until you obtain the
     fixed point.

  :: @N(58) :: @m(↦) (pronounced @"(maps to) is the mathematician's way of
     writing @c(lambda). @m(y ↦ x / y) means @c[(lambda (y) (/ x y))], that is,
     the function whose value at @m(y) is @m(x / y).

  :: @N(59) :: Observe that this is a combination whose operator is itself a
     combination. @l(#Exercise 1.4) already demonstrated the ability to form
     such combinations, but that was only a toy example. Here we begin to see
     the real need for such combinations––when applying a procedure that is
     obtained as the value returned by a higher-order procedure.

  :: @N(60) :: See @l(#Exercise 1.45) for a further generalization.

  :: @N(61) :: Elementary calculus books usually describe Newton's method in
     terms of the sequence of approximations @m[xₙ₊₁ = xₙ - g(xₙ) / Dg(xₙ)].
     Having language for talking about processes and using the idea of fixed
     points simplifies the description of the method.

  :: @N(62) :: Newton's method does not always converge to an answer, but it can
     be shown that in favorable cases each iteration doubles the
     number-of-digits accuracy of the approximation to the solution. In such
     cases, Newton's method will converge much more rapidly than the
     half-interval method.

  :: @N(63) :: For finding square roots, Newton's method converges rapidly to
     the correct solution from any starting point.

  :: @N(64) :: The notion of first-class status of programming-language elements
     is due to the British computer scientist Christopher Strachey (1916-1975).

  :: @N(65) :: We'll see examples of this after we introduce data structures in
     @l(#Chapter 2.)

  :: @N(66) :: The major implementation cost of first-class procedures is that
     allowing procedures to be returned as values requires reserving storage for
     a procedure's free variables even while the procedure is not executing. In
     the Scheme implementation we will study in @l(#4.1), these variables are
     stored in the procedure's environment.

  :: @N(67) :: The ability to directly manipulate procedures provides an
     analogous increase in the expressive power of a programming language. For
     example, in @l(#1.3.1) we introduced the @c(sum) procedure, which takes a
     procedure @c(term) as an argument and computes the sum of the values of
     @c(term) over some specified interval. In order to define @c(sum), it is
     crucial that we be able to speak of a procedure such as @c(term) as an
     entity in its own right, without regard for how @c(term) might be expressed
     with more primitive operations. Indeed, if we did not have the notion of
     @"(a procedure,) it is doubtful that we would ever even think of the
     possibility of defining an operation such as @c(sum). Moreover, insofar as
     performing the summation is concerned, the details of how @c(term) may be
     constructed from more primitive operations are irrelevant.

  :: @N(68) :: The name @c(cons) stands for @"(construct.) The names @c(car) and
     @c(cdr) derive from the original implementation of Lisp on the
     IBM 704. That machine had an addressing scheme that allowed one to
     reference the @"(address) and @"(decrement) parts of a memory
     location. @c(Car) stands for @"(Contents of Address part of Register) and
     @c(cdr) (pronounced @"(could-er) stands for @"(Contents of Decrement part
     of Register.)

  :: @N(69) :: Another way to define the selectors and constructor is

     ..src > scheme
       (define make-rat cons)
       (define numer car)
       (define denom cdr)
     < src..

     The first definition associates the name @c(make-rat) with the value of the
     expression @c(cons), which is the primitive procedure that constructs
     pairs. Thus @c(make-rat) and @c(cons) are names for the same primitive
     constructor.

     Defining selectors and constructors in this way is efficient: Instead of
     @c(make-rat) @e(calling) @c(cons), @c(make-rat) @e(is) @c(cons), so there
     is only one procedure called, not two, when @c(make-rat) is called. On the
     other hand, doing this defeats debugging aids that trace procedure calls or
     put breakpoints on procedure calls: You may want to watch @c(make-rat)
     being called, but you certainly don't want to watch every call to @c(cons).

     We have chosen not to use this style of definition in this book.

  :: @N(70) :: @c(Display) is the Scheme primitive for printing data.  The
     Scheme primitive @c(newline) starts a new line for printing. Neither of
     these procedures returns a useful value, so in the uses of @c(print-rat)
     below, we show only what @c(print-rat) prints, not what the interpreter
     prints as the value returned by @c(print-rat).

  :: @N(71) :: Surprisingly, this idea is very difficult to formulate
     rigorously. There are two approaches to giving such a formulation. One,
     pioneered by C. A. R. @l[#Hoare (1972)], is known as the method of
     @e(abstract models). It formalizes the @"(procedures plus conditions)
     specification as outlined in the rational-number example above. Note that
     the condition on the rational-number representation was stated in terms of
     facts about integers (equality and division). In general, abstract models
     define new kinds of data objects in terms of previously defined types of
     data objects. Assertions about data objects can therefore be checked by
     reducing them to assertions about previously defined data objects. Another
     approach, introduced by Zilles at @A(MIT), by Goguen, Thatcher, Wagner, and
     Wright at IBM (see @l(#Thatcher et al. 1978)), and by Guttag at Toronto
     (see @l(#Guttag 1977)), is called @e(algebraic specification). It regards
     the @"(procedures) as elements of an abstract algebraic system whose
     behavior is specified by axioms that correspond to our @"(conditions,) and
     uses the techniques of abstract algebra to check assertions about data
     objects. Both methods are surveyed in the paper by @l(#Liskov and Zilles
     (1975)).

  :: @N(72) :: The use of the word @"(closure) here comes from abstract algebra,
     where a set of elements is said to be closed under an operation if applying
     the operation to elements in the set produces an element that is again an
     element of the set. The Lisp community also (unfortunately) uses the word
     @"(closure) to describe a totally unrelated concept: A closure is an
     implementation technique for representing procedures with free
     variables. We do not use the word @"(closure) in this second sense in this
     book.

  :: @N(73) ::The notion that a means of combination should satisfy closure is a
     straightforward idea. Unfortunately, the data combiners provided in many
     popular programming languages do not satisfy closure, or make closure
     cumbersome to exploit. In Fortran or Basic, one typically combines data
     elements by assembling them into arrays––but one cannot form arrays whose
     elements are themselves arrays. Pascal and C admit structures whose
     elements are structures. However, this requires that the programmer
     manipulate pointers explicitly, and adhere to the restriction that each
     field of a structure can contain only elements of a prespecified
     form. Unlike Lisp with its pairs, these languages have no built-in
     general-purpose glue that makes it easy to manipulate compound data in a
     uniform way. This limitation lies behind Alan Perlis's comment in his
     foreword to this book: @"(In Pascal the plethora of declarable data
     structures induces a specialization within functions that inhibits and
     penalizes casual cooperation. It is better to have 100 functions operate on
     one data structure than to have 10 functions operate on 10 data
     structures.)

  :: @N(74) :: In this book, we use @e(list) to mean a chain of pairs terminated
     by the end-of-list marker. In contrast, the term @e(list structure) refers
     to any data structure made out of pairs, not just to lists.

  :: @N(75) :: Since nested applications of @c(car) and @c(cdr) are cumbersome
     to write, Lisp dialects provide abbreviations for them––for instance,

     ..src > scheme
       (cadr ⟨arg⟩) = (car (cdr ⟨arg⟩))
     < src..

     The names of all such procedures start with @c(c) and end with @c(r). Each
     @c(a) between them stands for a @c(car) operation and each @c(d) for a
     @c(cdr) operation, to be applied in the same order in which they appear in
     the name. The names @c(car) and @c(cdr) persist because simple combinations
     like @c(cadr) are pronounceable.

  :: @N(76) :: It's remarkable how much energy in the standardization of Lisp
     dialects has been dissipated in arguments that are literally over nothing:
     Should @c(nil) be an ordinary name?  Should the value of @c(nil) be a
     symbol?  Should it be a list?  Should it be a pair?  In Scheme, @c(nil) is
     an ordinary name, which we use in this section as a variable whose value is
     the end-of-list marker (just as @c(true) is an ordinary variable that has a
     true value). Other dialects of Lisp, including Common Lisp, treat @c(nil)
     as a special symbol. The authors of this book, who have endured too many
     language standardization brawls, would like to avoid the entire issue. Once
     we have introduced quotation in @l(#2.3), we will denote the empty list as
     @c['()] and dispense with the variable @c(nil) entirely.

  :: @N(77) :: To define @c(f) and @c(g) using @c(lambda) we would write

     ..src > scheme
       (define f (lambda (x y . z) ⟨body⟩))
       (define g (lambda w ⟨body⟩))
     < src..

  :: @N(78) :: @t(Footnote 78) Scheme standardly provides a @c(map) procedure
     that is more general than the one described here. This more general @c(map)
     takes a procedure of @m(n) arguments, together with @m(n) lists, and
     applies the procedure to all the first elements of the lists, all the
     second elements of the lists, and so on, returning a list of the
     results. For example:

     ..srci > scheme
       > (map +
       ^      (list 1 2 3)
       ^      (list 40 50 60)
       ^      (list 700 800 900))
       (741 852 963)
       > (map (lambda (x y) (+ x (* 2 y)))
       ^      (list 1 2 3)
       ^      (list 4 5 6))
       (9 12 15)
     < srci..

  :: @N(79) :: The order of the first two clauses in the @c(cond) matters, since
     the empty list satisfies @c(null?) and also is not a pair.

  :: @N(80) :: This is, in fact, precisely the @c(fringe) procedure from
     @l(#Exercise 2.28). Here we've renamed it to emphasize that it is part of a
     family of general sequence-manipulation procedures.

  :: @N(81) :: Richard @l[#Waters (1979)] developed a program that automatically
     analyzes traditional Fortran programs, viewing them in terms of maps,
     filters, and accumulations. He found that fully 90 percent of the code in
     the Fortran Scientific Subroutine Package fits neatly into this
     paradigm. One of the reasons for the success of Lisp as a programming
     language is that lists provide a standard medium for expressing ordered
     collections so that they can be manipulated using higher-order
     operations. The programming language APL owes much of its power and appeal
     to a similar choice. In APL all data are represented as arrays, and there
     is a universal and convenient set of generic operators for all sorts of
     array operations.

  :: @N(82) :: According to @l(#Knuth 1981), this rule was formulated by
     W. G. Horner early in the nineteenth century, but the method was actually
     used by Newton over a hundred years earlier. Horner's rule evaluates the
     polynomial using fewer additions and multiplications than does the
     straightforward method of first computing @m(aₙ xⁿ), then adding
     @m(aₙ₋₁xⁿ⁻¹), and so on. In fact, it is possible to prove that any
     algorithm for evaluating arbitrary polynomials must use at least as many
     additions and multiplications as does Horner's rule, and thus Horner's rule
     is an optimal algorithm for polynomial evaluation. This was proved (for the
     number of additions) by A. M. Ostrowski in a 1954 paper that essentially
     founded the modern study of optimal algorithms. The analogous statement for
     multiplications was proved by V. Y. Pan in 1966. The book by @l[#Borodin
     and Munro (1975)] provides an overview of these and other results about
     optimal algorithms.

  :: @N(83) :: This definition uses the extended version of @c(map) described in
     @n(78<>Footnote 78).

  :: @N(84) :: This approach to nested mappings was shown to us by David Turner,
     whose languages KRC and Miranda provide elegant formalisms for dealing with
     these constructs. The examples in this section (see also @l(#Exercise
     2.42)) are adapted from @l(#Turner 1981). In @l(#3.5.3), we'll see how this
     approach generalizes to infinite sequences.

  :: @N(85) :: We're representing a pair here as a list of two elements rather
     than as a Lisp pair. Thus, the @"(pair) @m[(i, j)] is represented as
     @c[(list i j)], not @c[(cons i j)].

  :: @N(86) :: The set @m(S - x) is the set of all elements of @m(S), excluding
     @m(x).

  :: @N(87) :: Semicolons in Scheme code are used to introduce @e(comments).
     Everything from the semicolon to the end of the line is ignored by the
     interpreter. In this book we don't use many comments; we try to make our
     programs self-documenting by using descriptive names.

  :: @N(88) :: The picture language is based on the language Peter Henderson
     created to construct images like M.C. Escher's @"(Square Limit) woodcut
     (see @l(#Henderson 1982)). The woodcut incorporates a repeated scaled
     pattern, similar to the arrangements drawn using the @c(square-limit)
     procedure in this section.

  :: @N(89) :: William Barton Rogers (1804-1882) was the founder and first
     president of @A(MIT). A geologist and talented teacher, he taught at
     William and Mary College and at the University of Virginia. In 1859 he
     moved to Boston, where he had more time for research, worked on a plan for
     establishing a @"(polytechnic institute,) and served as Massachusetts's
     first State Inspector of Gas Meters.

     When @A(MIT) was established in 1861, Rogers was elected its first
     president. Rogers espoused an ideal of @"(useful learning) that was
     different from the university education of the time, with its overemphasis
     on the classics, which, as he wrote, @"(stand in the way of the broader,
     higher and more practical instruction and discipline of the natural and
     social sciences.)  This education was likewise to be different from narrow
     trade-school education.  In Rogers's words:

     ..tab >
       The world-enforced distinction between the practical and the scientific
       worker is utterly futile, and the whole experience of modern times has
       demonstrated its utter worthlessness.

     Rogers served as president of @A(MIT) until 1870, when he resigned due to
     ill health. In 1878 the second president of @A(MIT), John Runkle, resigned
     under the pressure of a financial crisis brought on by the Panic of 1873
     and strain of fighting off attempts by Harvard to take over @A(MIT).
     Rogers returned to hold the office of president until 1881.

     Rogers collapsed and died while addressing @A(MIT)'s graduating class at
     the commencement exercises of 1882. Runkle quoted Rogers's last words
     in a memorial address delivered that same year:

     ..tab >
       @"(As I stand here today and see what the Institute is, … I call to mind
       the beginnings of science. I remember one hundred and fifty years ago
       Stephen Hales published a pamphlet on the subject of illuminating gas, in
       which he stated that his researches had demonstrated that 128 grains of
       bituminous coal--) @"(Bituminous coal,) these were his last words on
       earth. Here he bent forward, as if consulting some notes on the table
       before him, then slowly regaining an erect position, threw up his hands,
       and was translated from the scene of his earthly labors and triumphs to
       @"(the tomorrow of death,) where the mysteries of life are solved, and
       the disembodied spirit finds unending satisfaction in contemplating the
       new and still unfathomable mysteries of the infinite future.

     In the words of Francis A. Walker (@A(MIT)'s third president):

     ..tab >
       All his life he had borne himself most faithfully and heroically, and he
       died as so good a knight would surely have wished, in harness, at his
       post, and in the very part and act of public duty.

  :: @N(90) :: Equivalently, we could write

     ..src > scheme
       (define flipped-pairs
         (square-of-four
          identity flip-vert identity flip-vert))
     < src..

  :: @N(91) :: @c(Rotate180) rotates a painter by 180 degrees (see @l(#Exercise
     2.50)). Instead of @c(rotate180) we could say @c[(compose flip-vert
     flip-horiz)], using the @c(compose) procedure from @l(#Exercise 1.42).

  :: @N(92) :: @c(Frame-coord-map) uses the vector operations described in
     @l(#Exercise 2.46) below, which we assume have been implemented using some
     representation for vectors. Because of data abstraction, it doesn't matter
     what this vector representation is, so long as the vector operations behave
     correctly.

  :: @N(93) :: @c(Segments->painter) uses the representation for line segments
     described in @l(#Exercise 2.48) below. It also uses the @c(for-each)
     procedure described in @l(#Exercise 2.23).

  :: @N(94) :: For example, the @c(rogers) painter of @l(#Figure 2.11) was
     constructed from a gray-level image. For each point in a given frame, the
     @c(rogers) painter determines the point in the image that is mapped to it
     under the frame coordinate map, and shades it accordingly. By allowing
     different types of painters, we are capitalizing on the abstract data idea
     discussed in @l(#2.1.3), where we argued that a rational-number
     representation could be anything at all that satisfies an appropriate
     condition. Here we're using the fact that a painter can be implemented in
     any way at all, so long as it draws something in the designated frame.
     @l(#2.1.3) also showed how pairs could be implemented as procedures.
     Painters are our second example of a procedural representation for data.

  :: @N(95) :: @c(Rotate90) is a pure rotation only for square frames, because
     it also stretches and shrinks the image to fit into the rotated frame.

  :: @N(96) :: The diamond-shaped images in @l(#Figure 2.10) and @l(#Figure
     2.11) were created with @c(squash-inwards) applied to @c(wave) and
     @c(rogers).

  :: @N(97) :: Section @l(#3.3.4) describes one such language.

  :: @N(98) :: Allowing quotation in a language wreaks havoc with the ability to
     reason about the language in simple terms, because it destroys the notion
     that equals can be substituted for equals. For example, three is one plus
     two, but the word @"(three) is not the phrase @"(one plus two). Quotation
     is powerful because it gives us a way to build expressions that manipulate
     other expressions (as we will see when we write an interpreter in
     @l(#Chapter 4)). But allowing statements in a language that talk about
     other statements in that language makes it very difficult to maintain any
     coherent principle of what @"(equals can be substituted for equals) should
     mean. For example, if we know that the evening star is the morning star,
     then from the statement @"(the evening star is Venus) we can deduce @"(the
     morning star is Venus.)  However, given that @"(John knows that the evening
     star is Venus) we cannot infer that @"(John knows that the morning star is
     Venus.)

  :: @N(99) :: The single quote is different from the double quote we have been
     using to enclose character strings to be printed. Whereas the single quote
     can be used to denote lists or symbols, the double quote is used only with
     character strings.  In this book, the only use for character strings is as
     items to be printed.

  :: @N(100) :: Strictly, our use of the quotation mark violates the general
     rule that all compound expressions in our language should be delimited by
     parentheses and look like lists. We can recover this consistency by
     introducing a special form @c(quote), which serves the same purpose as the
     quotation mark. Thus, we would type @c[(quote a)] instead of @c('a), and we
     would type @c[(quote (a b c))] instead of @c['(a b c)].  This is precisely
     how the interpreter works. The quotation mark is just a single-character
     abbreviation for wrapping the next complete expression with @c(quote) to
     form @c[(quote ⟨expression⟩)]. This is important because it maintains
     the principle that any expression seen by the interpreter can be
     manipulated as a data object. For instance, we could construct the
     expression @c[(car '(a b c))], which is the same as @c[(car (quote (a b
     c)))], by evaluating @c[(list 'car (list 'quote '(a b c)))].

  :: @N(101) :: We can consider two symbols to be @"(the same) if they consist
     of the same characters in the same order. Such a definition skirts a deep
     issue that we are not yet ready to address: the meaning of @"(sameness) in
     a programming language. We will return to this in @l(#Chapter 3)
     (@l(#3.1.3)).

  :: @N(102) :: In practice, programmers use @c(equal?) to compare lists that
     contain numbers as well as symbols. Numbers are not considered to be
     symbols. The question of whether two numerically equal numbers (as tested
     by @c(=)) are also @c(eq?) is highly implementation-dependent. A better
     definition of @c(equal?) (such as the one that comes as a primitive in
     Scheme) would also stipulate that if @c(a) and @c(b) are both numbers, then
     @c(a) and @c(b) are @c(equal?) if they are numerically equal.

  :: @N(103) :: If we want to be more formal, we can specify @"(consistent with
     the interpretations given above) to mean that the operations satisfy a
     collection of rules such as these:

     - For any set @c(S) and any object @c(x), @c[(element-of-set? x (adjoin-set
       x S))] is true (informally: @"(Adjoining an object to a set produces a
       set that contains the object)).

     - For any sets @c(S) and @c(T) and any object @c(x), @c[(element-of-set? x
       (union-set S T))] is equal to @c[(or (element-of-set? x S)
       (element-of-set? x T))] (informally: @"(The elements of @c[(union S T)]
       are the elements that are in @c(S) or in @c(T)).

     - For any object @c(x), @c[(element-of-set? x '())] is false (informally:
       @"(No object is an element of the empty set).

  :: @N(104) :: Halving the size of the problem at each step is the
     distinguishing characteristic of logarithmic growth, as we saw with the
     fast-exponentiation algorithm of @l(#1.2.4) and the half-interval search
     method of @l(#1.3.3).

  :: @N(105) :: We are representing sets in terms of trees, and trees in terms
     of lists––in effect, a data abstraction built upon a data abstraction. We
     can regard the procedures @c(entry), @c(left-branch), @c(right-branch), and
     @c(make-tree) as a way of isolating the abstraction of a @"(binary tree)
     from the particular way we might wish to represent such a tree in terms of
     list structure.

  :: @N(106) :: Examples of such structures include @e(B-trees) and @e(red-black
     trees). There is a large literature on data structures devoted to this
     problem. See @l(#Cormen et al. 1990).

  :: @N(107) :: @l(#Exercise 2.63) through @l(#Exercise 2.65) are due to Paul
     Hilfinger.

  :: @N(108) :: See @l(#Hamming 1980) for a discussion of the mathematical
     properties of Huffman codes.

  :: @N(109) :: In actual computational systems, rectangular form is preferable
     to polar form most of the time because of roundoff errors in conversion
     between rectangular and polar form. This is why the complex-number example
     is unrealistic. Nevertheless, it provides a clear illustration of the
     design of a system using generic operations and a good introduction to the
     more substantial systems to be developed later in this chapter.

  :: @N(110) :: The arctangent function referred to here, computed by Scheme's
     @c(atan) procedure, is defined so as to take two arguments @m(y) and @m(x)
     and to return the angle whose tangent is @m(y / x).  The signs of the
     arguments determine the quadrant of the angle.

  :: @N(111) :: We use the list @c[(rectangular)] rather than the symbol
     @c(rectangular) to allow for the possibility of operations with multiple
     arguments, not all of the same type.

  :: @N(112) :: The type the constructors are installed under needn't be a list
     because a constructor is always used to make an object of one particular
     type.

  :: @N(113) :: @c(Apply-generic) uses the dotted-tail notation described in
     @l(#Exercise 2.20), because different generic operations may take different
     numbers of arguments. In @c(apply-generic), @c(op) has as its value the
     first argument to @c(apply-generic) and @c(args) has as its value a list of
     the remaining arguments.

     @c(Apply-generic) also uses the primitive procedure @c(apply), which takes
     two arguments, a procedure and a list. @c(Apply) applies the procedure,
     using the elements in the list as arguments. For example,

     ..src > scheme
       (apply + (list 1 2 3 4))
     < src..

     returns 10.

  :: @N(114) :: One limitation of this organization is it permits only generic
     procedures of one argument.

  :: @N(115) :: We also have to supply an almost identical procedure to handle
     the types @c[(scheme-number complex)].

  :: @N(116) :: See @l(#Exercise 2.82) for generalizations.

  :: @N(117) :: If we are clever, we can usually get by with fewer than @m(n²)
     coercion procedures. For instance, if we know how to convert from type 1 to
     type 2 and from type 2 to type 3, then we can use this knowledge to convert
     from type 1 to type 3. This can greatly decrease the number of coercion
     procedures we need to supply explicitly when we add a new type to the
     system. If we are willing to build the required amount of sophistication
     into our system, we can have it search the @"(graph) of relations among
     types and automatically generate those coercion procedures that can be
     inferred from the ones that are supplied explicitly.

  :: @N(118) :: This statement, which also appears in the first edition of this
     book, is just as true now as it was when we wrote it twelve years
     ago. Developing a useful, general framework for expressing the relations
     among different types of entities (what philosophers call @"(ontology))
     seems intractably difficult. The main difference between the confusion
     that existed ten years ago and the confusion that exists now is that now a
     variety of inadequate ontological theories have been embodied in a
     plethora of correspondingly inadequate programming languages. For
     example, much of the complexity of object-oriented programming
     languages––and the subtle and confusing differences among contemporary
     object-oriented languages––centers on the treatment of generic operations
     on interrelated types. Our own discussion of computational objects in
     @l(#Chapter 3) avoids these issues entirely. Readers familiar with
     object-oriented programming will notice that we have much to say in chapter
     3 about local state, but we do not even mention @"(classes) or
     @"(inheritance.)  In fact, we suspect that these problems cannot be
     adequately addressed in terms of computer-language design alone, without
     also drawing on work in knowledge representation and automated reasoning.

  :: @N(119) :: A real number can be projected to an integer using the @c(round)
     primitive, which returns the closest integer to its argument.

  :: @N(120) :: On the other hand, we will allow polynomials whose coefficients
     are themselves polynomials in other variables. This will give us
     essentially the same representational power as a full multivariate system,
     although it does lead to coercion problems, as discussed below.

  :: @N(121) :: For univariate polynomials, giving the value of a polynomial at
     a given set of points can be a particularly good representation. This makes
     polynomial arithmetic extremely simple. To obtain, for example, the sum of
     two polynomials represented in this way, we need only add the values of the
     polynomials at corresponding points. To transform back to a more familiar
     representation, we can use the Lagrange interpolation formula, which shows
     how to recover the coefficients of a polynomial of degree @m(n) given the
     values of the polynomial at @m(n + 1) points.

  :: @N(122) :: This operation is very much like the ordered @c(union-set)
     operation we developed in @l(#Exercise 2.62). In fact, if we think of the
     terms of the polynomial as a set ordered according to the power of the
     indeterminate, then the program that produces the term list for a sum is
     almost identical to @c(union-set).

  :: @N(123) :: To make this work completely smoothly, we should also add to our
     generic arithmetic system the ability to coerce a @"(number) to a
     polynomial by regarding it as a polynomial of degree zero whose coefficient
     is the number. This is necessary if we are going to perform operations such
     as

     ..example >
       [x² + (y + 1)x + 5] + [x² + 2x + 1]
     < example..

     which requires adding the coefficient @m(y + 1) to the coefficient 2.

  :: @N(124) :: In these polynomial examples, we assume that we have implemented
     the generic arithmetic system using the type mechanism suggested in
     @l(#Exercise 2.78). Thus, coefficients that are ordinary numbers will be
     represented as the numbers themselves rather than as pairs whose @c(car) is
     the symbol @c(scheme-number).

  :: @N(125) :: Although we are assuming that term lists are ordered, we have
     implemented @c(adjoin-term) to simply @c(cons) the new term onto the
     existing term list. We can get away with this so long as we guarantee that
     the procedures (such as @c(add-terms)) that use @c(adjoin-term) always call
     it with a higher-order term than appears in the list. If we did not want to
     make such a guarantee, we could have implemented @c(adjoin-term) to be
     similar to the @c(adjoin-set) constructor for the ordered-list
     representation of sets (@l(#Exercise 2.61)).

  :: @N(126) :: The fact that Euclid's Algorithm works for polynomials is
     formalized in algebra by saying that polynomials form a kind of algebraic
     domain called a @e(Euclidean ring). A Euclidean ring is a domain that
     admits addition, subtraction, and commutative multiplication, together with
     a way of assigning to each element @m(x) of the ring a positive integer
     @"(measure) @m[m(x)] with the properties that @m[m(xy) ≥ m(x)] for any
     nonzero @m(x) and @m(y) and that, given any @m(x) and @m(y), there exists a
     @m(q) such that @m(y = qx + r) and either @m(r = 0) or @m[m(r) < m(x)].
     From an abstract point of view, this is what is needed to prove that
     Euclid's Algorithm works. For the domain of integers, the measure @m(m) of
     an integer is the absolute value of the integer itself. For the domain of
     polynomials, the measure of a polynomial is its degree.

  :: @N(127) :: In an implementation like @A(MIT) Scheme, this produces a
     polynomial that is indeed a divisor of @m(Q₁) and @m(Q₂), but with rational
     coefficients. In many other Scheme systems, in which division of integers
     can produce limited-precision decimal numbers, we may fail to get a valid
     divisor.

  :: @N(128) :: One extremely efficient and elegant method for computing
     polynomial @A(GCD)s was discovered by Richard @l[#Zippel (1979)]. The
     method is a probabilistic algorithm, as is the fast test for primality that
     we discussed in @l(#Chapter 1). Zippel's book (@l(#Zippel 1993)) describes
     this method, together with other ways to compute polynomial @A(GCD)s.

  :: @N(129) :: Actually, this is not quite true. One exception was the
     random-number generator in @l(#1.2.6). Another exception involved the
     operation/type tables we introduced in @l(#2.4.3), where the values of two
     calls to @c(get) with the same arguments depended on intervening calls to
     @c(put). On the other hand, until we introduce assignment, we have no way
     to create such procedures ourselves.

  :: @N(130) :: The value of a @c(set!) expression is implementation-dependent.
     @c(Set!) should be used only for its effect, not for its value.

     The name @c(set!) reflects a naming convention used in Scheme: Operations
     that change the values of variables (or that change data structures, as we
     will see in @l(#3.3)) are given names that end with an exclamation point.
     This is similar to the convention of designating predicates by names that
     end with a question mark.

  :: @N(131) :: We have already used @c(begin) implicitly in our programs,
     because in Scheme the body of a procedure can be a sequence of
     expressions. Also, the @c[(consequent)] part of each clause in a @c(cond)
     expression can be a sequence of expressions rather than a single
     expression.

  :: @N(132) :: In programming-language jargon, the variable @c(balance) is said
     to be @e(encapsulated) within the @c(new-withdraw) procedure. Encapsulation
     reflects the general system-design principle known as the @e(hiding
     principle): One can make a system more modular and robust by protecting
     parts of the system from each other; that is, by providing information
     access only to those parts of the system that have a @"(need to know.)

  :: @N(133) :: In contrast with @c(new-withdraw) above, we do not have to use
     @c(let) to make @c(balance) a local variable, since formal parameters are
     already local.  This will be clearer after the discussion of the
     environment model of evaluation in @l(#3.2). (See also @l(#Exercise 3.10).)

  :: @N(134) :: One common way to implement @c(rand-update) is to use the rule
     that @m(x) is updated to @m(ax + b) modulo @m(m), where @m(a), @m(b), and
     @m(m) are appropriately chosen integers. Chapter 3 of @l(#Knuth 1981)
     includes an extensive discussion of techniques for generating sequences of
     random numbers and establishing their statistical properties. Notice that
     the @c(rand-update) procedure computes a mathematical function: Given the
     same input twice, it produces the same output. Therefore, the number
     sequence produced by @c(rand-update) certainly is not @"(random,) if by
     @"(random) we insist that each number in the sequence is unrelated to the
     preceding number. The relation between @"(real randomness) and so-called
     @e(pseudo-random) sequences, which are produced by well-determined
     computations and yet have suitable statistical properties, is a complex
     question involving difficult issues in mathematics and philosophy.
     Kolmogorov, Solomonoff, and Chaitin have made great progress in clarifying
     these issues; a discussion can be found in @l(#Chaitin 1975).

  :: @N(135) :: This theorem is due to E. Cesàro. See section 4.5.2 of
     @l(#Knuth 1981) for a discussion and a proof.

  :: @N(136) :: @A(MIT) Scheme provides such a procedure. If @c(random) is given
     an exact integer (as in @l(#1.2.6)) it returns an exact integer, but if it
     is given a decimal value (as in this exercise) it returns a decimal value.

  :: @N(137) :: We don't substitute for the occurrence of @c(balance) in the
     @c(set!) expression because the @c[(name)] in a @c(set!) is not
     evaluated. If we did substitute for it, we would get @c[(set! 25 (- 25
     amount))], which makes no sense.

  :: @N(138) :: The phenomenon of a single computational object being accessed
     by more than one name is known as @e(aliasing). The joint bank account
     situation illustrates a very simple example of an alias. In @l(#3.3) we
     will see much more complex examples, such as @"(distinct) compound data
     structures that share parts. Bugs can occur in our programs if we forget
     that a change to an object may also, as a @"(side effect,) change a
     @"(different) object because the two @"(different) objects are actually a
     single object appearing under different aliases. These so-called
     @e(side-effect bugs) are so difficult to locate and to analyze that some
     people have proposed that programming languages be designed in such a way
     as to not allow side effects or aliasing (@l(#Lampson et al. 1981);
     @l(#Morris et al. 1980)).

  :: @N(139) :: In view of this, it is ironic that introductory programming is
     most often taught in a highly imperative style. This may be a vestige of a
     belief, common throughout the 1960s and 1970s, that programs that call
     procedures must inherently be less efficient than programs that perform
     assignments. (@l(#Steele 1977) debunks this argument.)  Alternatively it
     may reflect a view that step-by-step assignment is easier for beginners to
     visualize than procedure call. Whatever the reason, it often saddles
     beginning programmers with @"(should I set this variable before or after
     that one) concerns that can complicate programming and obscure the
     important ideas.

  :: @N(140) :: Assignment introduces a subtlety into step 1 of the evaluation
     rule. As shown in @l(#Exercise 3.8), the presence of assignment allows us
     to write expressions that will produce different values depending on the
     order in which the subexpressions in a combination are evaluated. Thus, to
     be precise, we should specify an evaluation order in step 1 (e.g., left to
     right or right to left). However, this order should always be considered to
     be an implementation detail, and one should never write programs that
     depend on some particular order. For instance, a sophisticated compiler
     might optimize a program by varying the order in which subexpressions are
     evaluated.

  :: @N(141) :: If there is already a binding for the variable in the current
     frame, then the binding is changed. This is convenient because it allows
     redefinition of symbols; however, it also means that @c(define) can be used
     to change values, and this brings up the issues of assignment without
     explicitly using @c(set!). Because of this, some people prefer
     redefinitions of existing symbols to signal errors or warnings.

  :: @N(142) :: The environment model will not clarify our claim in @l(#1.2.1)
     that the interpreter can execute a procedure such as @c(fact-iter) in a
     constant amount of space using tail recursion. We will discuss tail
     recursion when we deal with the control structure of the interpreter in
     @l(#5.4).

  :: @N(143) :: Whether @c(W1) and @c(W2) share the same physical code stored in
     the computer, or whether they each keep a copy of the code, is a detail of
     the implementation. For the interpreter we implement in @l(#Chapter 4), the
     code is in fact shared.

  :: @N(144) :: @c(Set-car!) and @c(set-cdr!) return implementation-dependent
     values. Like @c(set!), they should be used only for their effect.

  :: @N(145) :: We see from this that mutation operations on lists can create
     @"(garbage) that is not part of any accessible structure. We will see in
     @l(#5.3.2) that Lisp memory-management systems include a @e(garbage
     collector), which identifies and recycles the memory space used by unneeded
     pairs.

  :: @N(146) :: @c(Get-new-pair) is one of the operations that must be
     implemented as part of the memory management required by a Lisp
     implementation. We will discuss this in @l(#5.3.1).

  :: @N(147) :: The two pairs are distinct because each call to @c(cons) returns
     a new pair. The symbols are shared; in Scheme there is a unique symbol with
     any given name. Since Scheme provides no way to mutate a symbol, this
     sharing is undetectable. Note also that the sharing is what enables us to
     compare symbols using @c(eq?), which simply checks equality of pointers.

  :: @N(148) :: The subtleties of dealing with sharing of mutable data objects
     reflect the underlying issues of @"(sameness) and @"(change) that were
     raised in @l(#3.1.3). We mentioned there that admitting change to our
     language requires that a compound object must have an @"(identity) that is
     something different from the pieces from which it is composed. In Lisp, we
     consider this @"(identity) to be the quality that is tested by @c(eq?),
     i.e., by equality of pointers. Since in most Lisp implementations a pointer
     is essentially a memory address, we are @"(solving the problem) of defining
     the identity of objects by stipulating that a data object @"(itself) is the
     information stored in some particular set of memory locations in the
     computer. This suffices for simple Lisp programs, but is hardly a general
     way to resolve the issue of @"(sameness) in computational models.}

  :: @N(149) :: On the other hand, from the viewpoint of implementation,
     assignment requires us to modify the environment, which is itself a mutable
     data structure. Thus, assignment and mutation are equipotent: Each can be
     implemented in terms of the other.

  :: @N(150) :: If the first item is the final item in the queue, the front
     pointer will be the empty list after the deletion, which will mark the
     queue as empty; we needn't worry about updating the rear pointer, which
     will still point to the deleted item, because @c(empty-queue?) looks only
     at the front pointer.

  :: @N(151) :: Be careful not to make the interpreter try to print a structure
     that contains cycles. (See @l(#Exercise 3.13).)

  :: @N(152) :: Because @c(assoc) uses @c(equal?), it can recognize keys that
     are symbols, numbers, or list structure.

  :: @N(153) :: Thus, the first backbone pair is the object that represents the
     table @"(itself); that is, a pointer to the table is a pointer to this
     pair. This same backbone pair always starts the table. If we did not
     arrange things in this way, @c(insert!)  would have to return a new value
     for the start of the table when it added a new record.

  :: @N(154) :: A full-adder is a basic circuit element used in adding two
     binary numbers. Here A and B are the bits at corresponding positions in the
     two numbers to be added, and @m(Cᵢₙ) is the carry bit from the addition one
     place to the right. The circuit generates SUM, which is the sum bit in the
     corresponding position, and @m(Cₒᵤₜ), which is the carry bit to be
     propagated to the left.

  :: @N(155) :: @t(Footnote 155) These procedures are simply syntactic sugar
     that allow us to use ordinary procedural syntax to access the local
     procedures of objects. It is striking that we can interchange the role of
     @"(procedures) and @"(data) in such a simple way. For example, if we write
     @c[(wire 'get-signal)] we think of @c(wire) as a procedure that is called
     with the message @c(get-signal) as input. Alternatively, writing
     @c[(get-signal wire)] encourages us to think of @c(wire) as a data object
     that is the input to a procedure @c(get-signal). The truth of the matter is
     that, in a language in which we can deal with procedures as objects, there
     is no fundamental difference between @"(procedures) and @"(data,) and we
     can choose our syntactic sugar to allow us to program in whatever style we
     choose.

  :: @N(156) :: The agenda is a headed list, like the tables in @l(#3.3.3), but
     since the list is headed by the time, we do not need an additional dummy
     header (such as the @c(*table*) symbol used with tables).

  :: @N(157) :: Observe that the @c(if) expression in this procedure has no
     @c[(alternative)] expression. Such a @"(one-armed @c(if) statement) is used
     to decide whether to do something, rather than to select between two
     expressions. An @c(if) expression returns an unspecified value if the
     predicate is false and there is no @c[(alternative)].

  :: @N(158) :: In this way, the current time will always be the time of the
     action most recently processed. Storing this time at the head of the agenda
     ensures that it will still be available even if the associated time segment
     has been deleted.

  :: @N(159) :: Constraint propagation first appeared in the incredibly
     forward-looking @A(SKETCHPAD) system of Ivan @l(#Sutherland (1963)). A
     beautiful constraint-propagation system based on the Smalltalk language was
     developed by Alan @l(#Borning (1977)) at Xerox Palo Alto Research
     Center. Sussman, Stallman, and Steele applied constraint propagation to
     electrical circuit analysis (@l(#Sussman and Stallman 1975); @l(#Sussman
     and Steele 1980)). TK!Solver (@l(#Konopasek and Jayaraman 1984)) is an
     extensive modeling environment based on constraints.

  :: @N(160) :: The @c(setter) might not be a constraint. In our temperature
     example, we used @c(user) as the @c(setter).

  :: @N(161) :: The expression-oriented format is convenient because it avoids
     the need to name the intermediate expressions in a computation. Our
     original formulation of the constraint language is cumbersome in the same
     way that many languages are cumbersome when dealing with operations on
     compound data. For example, if we wanted to compute the product @m[(a + b)
     ⋅ (c + d)], where the variables represent vectors, we could work in
     @"(imperative style,) using procedures that set the values of designated
     vector arguments but do not themselves return vectors as values:

     ..src > scheme
       (v-sum a b temp1)
       (v-sum c d temp2)
       (v-prod temp1 temp2 answer)
     < src..

     Alternatively, we could deal with expressions, using procedures that return
     vectors as values, and thus avoid explicitly mentioning @c(temp1) and
     @c(temp2):

     ..src > scheme
       (define answer
         (v-prod (v-sum a b) (v-sum c d)))
     < src..

     Since Lisp allows us to return compound objects as values of procedures, we
     can transform our imperative-style constraint language into an
     expression-oriented style as shown in this exercise. In languages that are
     impoverished in handling compound objects, such as Algol, Basic, and Pascal
     (unless one explicitly uses Pascal pointer variables), one is usually stuck
     with the imperative style when manipulating compound objects. Given the
     advantage of the expression-oriented format, one might ask if there is any
     reason to have implemented the system in imperative style, as we did in
     this section. One reason is that the non-expression-oriented constraint
     language provides a handle on constraint objects (e.g., the value of the
     @c(adder) procedure) as well as on connector objects. This is useful if we
     wish to extend the system with new operations that communicate with
     constraints directly rather than only indirectly via operations on
     connectors. Although it is easy to implement the expression-oriented style
     in terms of the imperative implementation, it is very difficult to do the
     converse.

  :: @N(162) :: Most real processors actually execute a few operations at a
     time, following a strategy called @e(pipelining). Although this technique
     greatly improves the effective utilization of the hardware, it is used only
     to speed up the execution of a sequential instruction stream, while
     retaining the behavior of the sequential program.

  :: @N(163) :: To quote some graffiti seen on a Cambridge building wall:
     @"(Time is a device that was invented to keep everything from happening at
     once.)

  :: @N(164) :: An even worse failure for this system could occur if the two
     @c(set!) operations attempt to change the balance simultaneously, in which
     case the actual data appearing in memory might end up being a random
     combination of the information being written by the two processes. Most
     computers have interlocks on the primitive memory-write operations, which
     protect against such simultaneous access. Even this seemingly simple kind
     of protection, however, raises implementation challenges in the design of
     multiprocessing computers, where elaborate @e(cache-coherence) protocols
     are required to ensure that the various processors will maintain a
     consistent view of memory contents, despite the fact that data may be
     replicated (@"(cached) among the different processors to increase the speed
     of memory access

  :: @N(165) :: The factorial program in @l(#3.1.3) illustrates this for a
     single sequential process.

  :: @N(166) :: The columns show the contents of Peter's wallet, the joint
     account (in Bank1), Paul's wallet, and Paul's private account (in Bank2),
     before and after each withdrawal (W) and deposit (D). Peter withdraws $10
     from Bank1; Paul deposits $5 in Bank2, then withdraws $25 from Bank1.

  :: @N(167) :: @t(Footnote 167) A more formal way to express this idea is to
     say that concurrent programs are inherently @e(nondeterministic). That is,
     they are described not by single-valued functions, but by functions whose
     results are sets of possible values. In @l(#4.3) we will study a language
     for expressing nondeterministic computations.

  :: @N(168) :: @c(Parallel-execute) is not part of standard Scheme, but it can
     be implemented in @A(MIT) Scheme. In our implementation, the new concurrent
     processes also run concurrently with the original Scheme process. Also, in
     our implementation, the value returned by @c(parallel-execute) is a special
     control object that can be used to halt the newly created processes.

  :: @N(169) :: We have simplified @c(exchange) by exploiting the fact that our
     @c(deposit) message accepts negative amounts. (This is a serious bug in our
     banking system!)

  :: @N(170) :: If the account balances start out as $10, $20, and $30, then
     after any number of concurrent exchanges, the balances should still be $10,
     $20, and $30 in some order.  Serializing the deposits to individual
     accounts is not sufficient to guarantee this. See @l(#Exercise 3.43).

  :: @N(171) :: @l(#Exercise 3.45) investigates why deposits and withdrawals are
     no longer automatically serialized by the account.

  :: @N(172) :: The term @"(mutex) is an abbreviation for @e(mutual
     exclusion). The general problem of arranging a mechanism that permits
     concurrent processes to safely share resources is called the mutual
     exclusion problem. Our mutex is a simple variant of the @e(semaphore)
     mechanism (see @l(#Exercise 3.47)), which was introduced in the @"(THE)
     Multiprogramming System developed at the Technological University of
     Eindhoven and named for the university's initials in Dutch (@l(#Dijkstra
     1968a)). The acquire and release operations were originally called P and V,
     from the Dutch words @e(passeren) (to pass) and @e(vrijgeven) (to release),
     in reference to the semaphores used on railroad systems. Dijkstra's classic
     exposition (@l(#1968b)) was one of the first to clearly present the issues
     of concurrency control, and showed how to use semaphores to handle a
     variety of concurrency problems.

  :: @N(173) :: {In most time-shared operating systems, processes that
     are blocked by a mutex do not waste time @"(busy-waiting) as above. Instead,
     the system schedules another process to run while the first is waiting, and the
     blocked process is awakened when the mutex becomes available.}

  :: @N(174) ::{In @A(MIT) Scheme for a single processor, which uses a
     time-slicing model, @c(test-and-set!) can be implemented as follows:

     ..src > scheme
       (define (test-and-set! cell)
         (without-interrupts
          (lambda ()
            (if (car cell)
                true
                (begin (set-car! cell true)
                       false)))))
     < src..

     @c(Without-interrupts) disables time-slicing interrupts while its procedure
     argument is being executed.}

  :: @N(175) :: There are many variants of such instructions––including
     test-and-set, test-and-clear, swap, compare-and-exchange, load-reserve, and
     store-conditional––whose design must be carefully matched to the machine's
     processor-memory interface. One issue that arises here is to determine what
     happens if two processes attempt to acquire the same resource at exactly
     the same time by using such an instruction. This requires some mechanism
     for making a decision about which process gets control. Such a mechanism is
     called an @e(arbiter). Arbiters usually boil down to some sort of hardware
     device. Unfortunately, it is possible to prove that one cannot physically
     construct a fair arbiter that works 100% of the time unless one allows the
     arbiter an arbitrarily long time to make its decision. The fundamental
     phenomenon here was originally observed by the fourteenth-century French
     philosopher Jean Buridan in his commentary on Aristotle's @i(De caelo).
     Buridan argued that a perfectly rational dog placed between two equally
     attractive sources of food will starve to death, because it is incapable of
     deciding which to go to first.

  :: @N(176) :: The general technique for avoiding deadlock by numbering the
     shared resources and acquiring them in order is due to @l(#Havender
     (1968)). Situations where deadlock cannot be avoided require
     @e(deadlock-recovery) methods, which entail having processes @"(back out)
     of the deadlocked state and try again. Deadlock-recovery mechanisms are
     widely used in database management systems, a topic that is treated in
     detail in @l(#Gray and Reuter 1993).

  :: @N(177) :: One such alternative to serialization is called @e(barrier
     synchronization). The programmer permits concurrent processes to execute as
     they please, but establishes certain synchronization points (@"(barriers)
     through which no process can proceed until all the processes have reached
     the barrier. Modern processors provide machine instructions that permit
     programmers to establish synchronization points at places where consistency
     is required. The @A(PowerPC), for example, includes for this purpose two
     instructions called @A(SYNC) and @A(EIEIO) (Enforced In-order Execution of
     Input/Output).

  :: @N(178) :: This may seem like a strange point of view, but there are
     systems that work this way. International charges to credit-card accounts,
     for example, are normally cleared on a per-country basis, and the charges
     made in different countries are periodically reconciled. Thus the account
     balance may be different in different countries.

  :: @N(179) :: For distributed systems, this perspective was pursued by
     @l[#Lamport (1978)], who showed how to use communication to establish
     @"(global clocks) that can be used to establish orderings on events in
     distributed systems.

  :: @N(180) :: Physicists sometimes adopt this view by introducing the @"(world
     lines) of particles as a device for reasoning about motion. We've also
     already mentioned (@l(#2.2.3)) that this is the natural way to think about
     signal-processing systems. We will explore applications of streams to
     signal processing in @l(#3.5.3).

  :: @N(181) :: Assume that we have a predicate @c(prime?) (e.g., as in
     @l(#1.2.6)) that tests for primality.

  :: @N(182) :: In the @A(MIT) implementation, @c(the-empty-stream) is the same
     as the empty list @c['()!], and @c(stream-null?) is the same as @c(null?).

  :: @N(183) :: This should bother you. The fact that we are defining such
     similar procedures for streams and lists indicates that we are missing some
     underlying abstraction.  Unfortunately, in order to exploit this
     abstraction, we will need to exert finer control over the process of
     evaluation than we can at present. We will discuss this point further at
     the end of @l(#3.5.4). In @l(#4.2), we'll develop a framework that unifies
     lists and streams.

  :: @N(184) :: Although @c(stream-car) and @c(stream-cdr) can be defined as
     procedures, @c(cons-stream) must be a special form. If @c(cons-stream) were
     a procedure, then, according to our model of evaluation, evaluating
     @c[(cons-stream ⟨a⟩ ⟨b⟩)] would automatically cause @c[(b)] to be
     evaluated, which is precisely what we do not want to happen. For the same
     reason, @c(delay) must be a special form, though @c(force) can be an
     ordinary procedure.

  :: @N(185) :: The numbers shown here do not really appear in the delayed
     expression. What actually appears is the original expression, in an
     environment in which the variables are bound to the appropriate numbers.
     For example, @c[(+ low 1)] with @c(low) bound to 10,000 actually appears
     where @c(10001) is shown.

  :: @N(186) :: There are many possible implementations of streams other than
     the one described in this section.  Delayed evaluation, which is the key to
     making streams practical, was inherent in Algol 60's @e(call-by-name)
     parameter-passing method. The use of this mechanism to implement streams
     was first described by @l(#Landin (1965)). Delayed evaluation for streams
     was introduced into Lisp by @l[#Friedman and Wise (1976)]. In their
     implementation, @c(cons) always delays evaluating its arguments, so that
     lists automatically behave as streams. The memoizing optimization is also
     known as @e(call-by-need). The Algol community would refer to our original
     delayed objects as @e(call-by-name thunks) and to the optimized versions as
     @e(call-by-need thunks).

  :: @N(187) :: Exercises such as @l(#Exercise 3.51) and @l(#Exercise 3.52) are
     valuable for testing our understanding of how @c(delay) works. On the other
     hand, intermixing delayed evaluation with printing––and, even worse, with
     assignment––is extremely confusing, and instructors of courses on computer
     languages have traditionally tormented their students with examination
     questions such as the ones in this section. Needless to say, writing
     programs that depend on such subtleties is odious programming style. Part
     of the power of stream processing is that it lets us ignore the order in
     which events actually happen in our programs. Unfortunately, this is
     precisely what we cannot afford to do in the presence of assignment, which
     forces us to be concerned with time and change.

  :: @N(188) :: Eratosthenes, a third-century @A(B.C.)  Alexandrian Greek
     philosopher, is famous for giving the first accurate estimate of the
     circumference of the Earth, which he computed by observing shadows cast at
     noon on the day of the summer solstice. Eratosthenes's sieve method,
     although ancient, has formed the basis for special-purpose hardware
     @"(sieves) that, until recently, were the most powerful tools in existence
     for locating large primes. Since the 70s, however, these methods have been
     superseded by outgrowths of the probabilistic techniques discussed in
     @l(#1.2.6).

  :: @N(189) :: We have named these figures after Peter Henderson, who was the
     first person to show us diagrams of this sort as a way of thinking about
     stream processing. Each solid line represents a stream of values being
     transmitted.  The dashed line from the @c(car) to the @c(cons) and the
     @c(filter) indicates that this is a single value rather than a stream.

  :: @N(190) :: This uses the generalized version of @c(stream-map) from
     @l(#Exercise 3.50).

  :: @N(191) :: This last point is very subtle and relies on the fact that
     @m(pₙ₊₁ ≤ pₙ²). (Here, @m(pₙ) denotes the @m(kᵗʰ) prime.)  Estimates such
     as these are very difficult to establish. The ancient proof by Euclid that
     there are an infinite number of primes shows that @m(pₙ₊₁ ≤ p₁ p₂ ⋯ pₙ +
     1), and no substantially better result was proved until 1851, when the
     Russian mathematician P. L. Chebyshev established that @m(pₙ₊₁ ≤ 2pₙ) for
     all @m(n).  This result, originally conjectured in 1845, is known as
     @e(Bertrand's hypothesis).  A proof can be found in section 22.3 of
     @l(#Hardy and Wright 1960).

  :: @N(192) :: This exercise shows how call-by-need is closely related to
     ordinary memoization as described in @l(#Exercise 3.27). In that exercise,
     we used assignment to explicitly construct a local table. Our call-by-need
     stream optimization effectively constructs such a table automatically,
     storing values in the previously forced parts of the stream.

  :: @N(193) :: We can't use @c(let) to bind the local variable @c(guesses),
     because the value of @c(guesses) depends on @c(guesses)
     itself. @l(#Exercise 3.63) addresses why we want a local variable here.

  :: @N(194) :: As in @l(#2.2.3), we represent a pair of integers as a list
     rather than a Lisp pair.

  :: @N(195) :: See @l(#Exercise 3.68) for some insight into why we chose this
     decomposition.

  :: @N(196) :: The precise statement of the required property on the order of
     combination is as follows: There should be a function @m(f) of two
     arguments such that the pair corresponding to element @m(i) of the first
     stream and element @m(j) of the second stream will appear as element number
     @m[f(i, j)] of the output stream. The trick of using @c(interleave) to
     accomplish this was shown to us by David Turner, who employed it in the
     language KRC (@l(#Turner 1981)).

  :: @N(197) :: We will require that the weighting function be such that the
     weight of a pair increases as we move out along a row or down along a
     column of the array of pairs.

  :: @N(198) :: To quote from G. H. Hardy's obituary of Ramanujan (@l(#Hardy
     1921)): @"(It was Mr. Littlewood (I believe) who remarked that `every
     positive integer was one of his friends.'  I remember once going to see him
     when he was lying ill at Putney. I had ridden in taxi-cab No. 1729, and
     remarked that the number seemed to me a rather dull one, and that I hoped
     it was not an unfavorable omen. `No,' he replied, `it is a very interesting
     number; it is the smallest number expressible as the sum of two cubes in
     two different ways.'  ) The trick of using weighted pairs to generate the
     Ramanujan numbers was shown to us by Charles Leiserson.

  :: @N(199) :: This procedure is not guaranteed to work in all Scheme
     implementations, although for any implementation there is a simple
     variation that will work. The problem has to do with subtle differences in
     the ways that Scheme implementations handle internal definitions. (See
     @l(#4.1.6).)

  :: @N(200) :: This is a small reflection, in Lisp, of the difficulties that
     conventional strongly typed languages such as Pascal have in coping with
     higher-order procedures. In such languages, the programmer must specify the
     data types of the arguments and the result of each procedure: number,
     logical value, sequence, and so on. Consequently, we could not express an
     abstraction such as @"(map a given procedure @c(proc) over all the elements
     in a sequence) by a single higher-order procedure such as @c(stream-map).
     Rather, we would need a different mapping procedure for each different
     combination of argument and result data types that might be specified for a
     @c(proc). Maintaining a practical notion of @"(data type) in the presence
     of higher-order procedures raises many difficult issues. One way of dealing
     with this problem is illustrated by the language ML (@l(#Gordon et
     al. 1979)), whose @"(polymorphic data types) include templates for
     higher-order transformations between data types. Moreover, data types for
     most procedures in ML are never explicitly declared by the
     programmer. Instead, ML includes a @e(type-inferencing) mechanism that uses
     information in the environment to deduce the data types for newly defined
     procedures.

  :: @N(201) :: Similarly in physics, when we observe a moving particle, we say
     that the position (state) of the particle is changing. However, from the
     perspective of the particle's world line in space-time there is no change
     involved.

  :: @N(202) :: John Backus, the inventor of Fortran, gave high visibility to
     functional programming when he was awarded the @A(ACM) Turing award
     in 1978. His acceptance speech (@l(#Backus 1978)) strongly advocated the
     functional approach. A good overview of functional programming is given in
     @l(#Henderson 1980) and in @l(#Darlington et al. 1982).

  :: @N(203) :: Observe that, for any two streams, there is in general more than
     one acceptable order of interleaving. Thus, technically, @"(merge) is a
     relation rather than a function––the answer is not a deterministic function
     of the inputs. We already mentioned (@n(167<>Footnote 167)) that
     nondeterminism is essential when dealing with concurrency. The merge
     relation illustrates the same essential nondeterminism, from the functional
     perspective. In @l(#4.3), we will look at nondeterminism from yet another
     point of view.

  :: @N(204) :: The object model approximates the world by dividing it into
     separate pieces. The functional model does not modularize along object
     boundaries. The object model is useful when the unshared state of the
     @"(objects) is much larger than the state that they share. An example of a
     place where the object viewpoint fails is quantum mechanics, where thinking
     of things as individual particles leads to paradoxes and confusions.
     Unifying the object view with the functional view may have little to do
     with programming, but rather with fundamental epistemological issues.

  :: @N(205) :: The same idea is pervasive throughout all of engineering. For
     example, electrical engineers use many different languages for describing
     circuits. Two of these are the language of electrical @e(networks) and the
     language of electrical @e(systems). The network language emphasizes the
     physical modeling of devices in terms of discrete electrical elements. The
     primitive objects of the network language are primitive electrical
     components such as resistors, capacitors, inductors, and transistors, which
     are characterized in terms of physical variables called voltage and
     current. When describing circuits in the network language, the engineer is
     concerned with the physical characteristics of a design. In contrast, the
     primitive objects of the system language are signal-processing modules such
     as filters and amplifiers. Only the functional behavior of the modules is
     relevant, and signals are manipulated without concern for their physical
     realization as voltages and currents. The system language is erected on the
     network language, in the sense that the elements of signal-processing
     systems are constructed from electrical networks. Here, however, the
     concerns are with the large-scale organization of electrical devices to
     solve a given application problem; the physical feasibility of the parts is
     assumed. This layered collection of languages is another example of the
     stratified design technique illustrated by the picture language of
     @l(#2.2.4).

  :: @N(206) :: The most important features that our evaluator leaves out are
     mechanisms for handling errors and supporting debugging. For a more
     extensive discussion of evaluators, see @l(#Friedman et al. 1992), which
     gives an exposition of programming languages that proceeds via a sequence
     of evaluators written in Scheme.

  :: @N(207) :: Even so, there will remain important aspects of the evaluation
     process that are not elucidated by our evaluator. The most important of
     these are the detailed mechanisms by which procedures call other procedures
     and return values to their callers. We will address these issues in
     @l(#Chapter 5), where we take a closer look at the evaluation process by
     implementing the evaluator as a simple register machine.

  :: @N(208) :: If we grant ourselves the ability to apply primitives, then what
     remains for us to implement in the evaluator?  The job of the evaluator is
     not to specify the primitives of the language, but rather to provide the
     connective tissue––the means of combination and the means of
     abstraction––that binds a collection of primitives to form a
     language. Specifically:

     - The evaluator enables us to deal with nested expressions. For example,
       although simply applying primitives would suffice for evaluating the
       expression @c[(+ 1 6)], it is not adequate for handling @c[(+ 1 (* 2
       3))]. As far as the primitive procedure @c(+) is concerned, its arguments
       must be numbers, and it would choke if we passed it the expression @c[(*
       2 3)] as an argument. One important role of the evaluator is to
       choreograph procedure composition so that @c[(* 2 3)] is reduced to 6
       before being passed as an argument to @c(+).

     - The evaluator allows us to use variables. For example, the primitive
       procedure for addition has no way to deal with expressions such as @c[(+
       x 1)]. We need an evaluator to keep track of variables and obtain their
       values before invoking the primitive procedures.

     - The evaluator allows us to define compound procedures. This involves
       keeping track of procedure definitions, knowing how to use these
       definitions in evaluating expressions, and providing a mechanism that
       enables procedures to accept arguments.

     - The evaluator provides the special forms, which must be evaluated
       differently from procedure calls.

  :: @N(209) :: We could have simplified the @c(application?)  clause in
     @c(eval) by using @c(map) (and stipulating that @c(operands) returns a
     list) rather than writing an explicit @c(list-of-values) procedure. We
     chose not to use @c(map) here to emphasize the fact that the evaluator can
     be implemented without any use of higher-order procedures (and thus could
     be written in a language that doesn't have higher-order procedures), even
     though the language that it supports will include higher-order procedures.

  :: @N(210) :: In this case, the language being implemented and the
     implementation language are the same. Contemplation of the meaning of
     @c(true?) here yields expansion of consciousness without the abuse of
     substance.

  :: @N(211) :: This implementation of @c(define) ignores a subtle issue in the
     handling of internal definitions, although it works correctly in most
     cases. We will see what the problem is and how to solve it in @l(#4.1.6).

  :: @N(212) :: As we said when we introduced @c(define) and @c(set!), these
     values are implementation-dependent in Scheme––that is, the implementor can
     choose what value to return.

  :: @N(213) :: As mentioned in @l(#2.3.1), the evaluator sees a quoted
     expression as a list beginning with @c(quote), even if the expression is
     typed with the quotation mark. For example, the expression @c('a) would be
     seen by the evaluator as @c[(quote a)]. See @l(#Exercise 2.55).

  :: @N(214) :: The value of an @c(if) expression when the predicate is false
     and there is no alternative is unspecified in Scheme; we have chosen here
     to make it false. We will support the use of the variables @c(true) and
     @c(false) in expressions to be evaluated by binding them in the global
     environment. See @l(#4.1.4).

  :: @N(215) :: These selectors for a list of expressions––and the corresponding
     ones for a list of operands––are not intended as a data abstraction. They
     are introduced as mnemonic names for the basic list operations in order to
     make it easier to understand the explicit-control evaluator in @l(#5.4).

  :: @N(216) :: The value of a @c(cond) expression when all the predicates are
     false and there is no @c(else) clause is unspecified in Scheme; we have
     chosen here to make it false.

  :: @N(217) :: Practical Lisp systems provide a mechanism that allows a user to
     add new derived expressions and specify their implementation as syntactic
     transformations without modifying the evaluator. Such a user-defined
     transformation is called a @e(macro). Although it is easy to add an
     elementary mechanism for defining macros, the resulting language has subtle
     name-conflict problems. There has been much research on mechanisms for
     macro definition that do not cause these difficulties. See, for example,
     @l(#Kohlbecker 1986), @l(#Clinger and Rees 1991), and @l(#Hanson 1991).

  :: @N(218) :: Frames are not really a data abstraction in the following code:
     @c(Set-variable-value!) and @c(define-variable!) use @c(set-car!)  to
     directly modify the values in a frame. The purpose of the frame procedures
     is to make the environment-manipulation procedures easy to read.

  :: @N(219) :: The drawback of this representation (as well as the variant in
     @l(#Exercise 4.11)) is that the evaluator may have to search through many
     frames in order to find the binding for a given variable. (Such an approach
     is referred to as @e(deep binding).)  One way to avoid this inefficiency is
     to make use of a strategy called @e(lexical addressing), which will be
     discussed in @l(#5.5.6).

  :: @N(220) :: Any procedure defined in the underlying Lisp can be used as a
     primitive for the metacircular evaluator. The name of a primitive installed
     in the evaluator need not be the same as the name of its implementation in
     the underlying Lisp; the names are the same here because the metacircular
     evaluator implements Scheme itself. Thus, for example, we could put
     @c[(list 'first car)] or @c[(list 'square (lambda (x) (* x x)))] in the
     list of @c(primitive-procedures).

  :: @N(221) :: @c(Apply-in-underlying-scheme) is the @c(apply) procedure we
     have used in earlier chapters. The metacircular evaluator's @c(apply)
     procedure (@l(#4.1.1)) models the working of this primitive. Having two
     different things called @c(apply) leads to a technical problem in running
     the metacircular evaluator, because defining the metacircular evaluator's
     @c(apply) will mask the definition of the primitive. One way around this is
     to rename the metacircular @c(apply) to avoid conflict with the name of the
     primitive procedure. We have assumed instead that we have saved a reference
     to the underlying @c(apply) by doing

     ..src > scheme
       (define apply-in-underlying-scheme apply)
     < src..

     before defining the metacircular @c(apply). This allows us to access the
     original version of @c(apply) under a different name.

  :: @N(222) :: The primitive procedure @c(read) waits for input from the user,
     and returns the next complete expression that is typed. For example, if the
     user types @c[(+ 23 x)], @c(read) returns a three-element list containing
     the symbol @c(+), the number 23, and the symbol @c(x). If the user types
     @c('x), @c(read) returns a two-element list containing the symbol @c(quote)
     and the symbol @c(x).

  :: @N(223) :: The fact that the machines are described in Lisp is
     inessential. If we give our evaluator a Lisp program that behaves as an
     evaluator for some other language, say C, the Lisp evaluator will emulate
     the C evaluator, which in turn can emulate any machine described as a C
     program.  Similarly, writing a Lisp evaluator in C produces a C program
     that can execute any Lisp program. The deep idea here is that any evaluator
     can emulate any other. Thus, the notion of @"(what can in principle be
     computed) (ignoring practicalities of time and memory required) is
     independent of the language or the computer, and instead reflects an
     underlying notion of @e(computability). This was first demonstrated in a
     clear way by Alan M. Turing (1912-1954), whose 1936 paper laid the
     foundations for theoretical computer science. In the paper, Turing
     presented a simple computational model––now known as a @e(Turing
     machine)––and argued that any @"(effective process) can be formulated as a
     program for such a machine. (This argument is known as the @e(Church-Turing
     thesis).)  Turing then implemented a universal machine, i.e., a Turing
     machine that behaves as an evaluator for Turing-machine programs. He used
     this framework to demonstrate that there are well-posed problems that
     cannot be computed by Turing machines (see @l(#Exercise 4.15)), and so by
     implication cannot be formulated as @"(effective processes.)  Turing went
     on to make fundamental contributions to practical computer science as
     well. For example, he invented the idea of structuring programs using
     general-purpose subroutines. See @l(#Hodges 1983) for a biography of
     Turing.

  :: @N(224) :: Some people find it counterintuitive that an evaluator, which is
     implemented by a relatively simple procedure, can emulate programs that are
     more complex than the evaluator itself. The existence of a universal
     evaluator machine is a deep and wonderful property of computation.
     @e(Recursion theory), a branch of mathematical logic, is concerned with
     logical limits of computation. Douglas Hofstadter's beautiful book
     @q(G@@"odel, Escher, Bach) explores some of these ideas (@l(#Hofstadter
     1979)).

  :: @N(225) :: Warning: This @c(eval) primitive is not identical to the
     @c(eval) procedure we implemented in @l(#4.1.1), because it uses @e(actual)
     Scheme environments rather than the sample environment structures we built
     in @l(#4.1.3). These actual environments cannot be manipulated by the user
     as ordinary lists; they must be accessed via @c(eval) or other special
     operations. Similarly, the @c(apply) primitive we saw earlier is not
     identical to the metacircular @c(apply), because it uses actual Scheme
     procedures rather than the procedure objects we constructed in @l(#4.1.3)
     and @l(#4.1.4).

  :: @N(226) :: The @A(MIT) implementation of Scheme includes @c(eval), as well
     as a symbol @c(user-initial-environment) that is bound to the initial
     environment in which the user's input expressions are evaluated.

  :: @N(227) :: Although we stipulated that @c(halts?)  is given a procedure
     object, notice that this reasoning still applies even if @c(halts?) can
     gain access to the procedure's text and its environment.  This is Turing's
     celebrated @e(Halting Theorem), which gave the first clear example of a
     @e(non-computable) problem, i.e., a well-posed task that cannot be carried
     out as a computational procedure.

  :: @N(228) :: Wanting programs to not depend on this evaluation mechanism is
     the reason for the @"(management is not responsible) remark in
     @n(28<>Footnote 28) of @l(#Chapter 1). By insisting that internal
     definitions come first and do not use each other while the definitions are
     being evaluated, the @A(IEEE) standard for Scheme leaves implementors some
     choice in the mechanism used to evaluate these definitions. The choice of
     one evaluation rule rather than another here may seem like a small issue,
     affecting only the interpretation of @"(badly formed) programs. However, we
     will see in @l(#5.5.6) that moving to a model of simultaneous scoping for
     internal definitions avoids some nasty difficulties that would otherwise
     arise in implementing a compiler.

  :: @N(229) :: The @A(IEEE) standard for Scheme allows for different
     implementation strategies by specifying that it is up to the programmer to
     obey this restriction, not up to the implementation to enforce it. Some
     Scheme implementations, including @A(MIT) Scheme, use the transformation
     shown above. Thus, some programs that don't obey this restriction will in
     fact run in such implementations.

  :: @N(230) :: The @A(MIT) implementors of Scheme support Alyssa on the
     following grounds: Eva is in principle correct––the definitions should be
     regarded as simultaneous. But it seems difficult to implement a general,
     efficient mechanism that does what Eva requires. In the absence of such a
     mechanism, it is better to generate an error in the difficult cases of
     simultaneous definitions (Alyssa's notion) than to produce an incorrect
     answer (as Ben would have it).

  :: @N(231) :: This example illustrates a programming trick for formulating
     recursive procedures without using @c(define). The most general trick of
     this sort is the @m(Y) @e(operator), which can be used to give a @"(pure
     λ-calculus) implementation of recursion. (See @l(#Stoy 1977) for details on
     the λ-calculus, and @l(#Gabriel 1988) for an exposition of the @m(Y)
     operator in Scheme.)

  :: @N(232) :: This technique is an integral part of the compilation process,
     which we shall discuss in @l(#Chapter 5). Jonathan Rees wrote a Scheme
     interpreter like this in about 1982 for the T project (@l(#Rees and Adams
     1982)). Marc @l(#Feeley (1986)) (see also @l(#Feeley and Lapalme 1987))
     independently invented this technique in his master's thesis.

  :: @N(233) :: There is, however, an important part of the variable search that
     @e(can) be done as part of the syntactic analysis. As we will show in
     @l(#5.5.6), one can determine the position in the environment structure
     where the value of the variable will be found, thus obviating the need to
     scan the environment for the entry that matches the variable.

  :: @N(234) :: See @l(#Exercise 4.23) for some insight into the processing of
     sequences.

  :: @N(235) :: Snarf: @"(To grab, especially a large document or file for the
     purpose of using it either with or without the owner's permission.)  Snarf
     down: @"(To snarf, sometimes with the connotation of absorbing, processing,
     or understanding.)  (These definitions were snarfed from @l(#Steele et
     al. 1983). See also @l(#Raymond 1993).)

  :: @N(236) :: The difference between the @"(lazy) terminology and the
     @"(normal-order) terminology is somewhat fuzzy. Generally, @"(lazy) refers
     to the mechanisms of particular evaluators, while @"(normal-order) refers
     to the semantics of languages, independent of any particular evaluation
     strategy. But this is not a hard-and-fast distinction, and the two
     terminologies are often used interchangeably.

  :: @N(237) :: The @"(strict) versus @"(non-strict) terminology means
     essentially the same thing as @"(applicative-order) versus
     @"(normal-order,) except that it refers to individual procedures and
     arguments rather than to the language as a whole. At a conference on
     programming languages you might hear someone say, @"(The normal-order
     language Hassle has certain strict primitives. Other procedures take their
     arguments by lazy evaluation.)

  :: @N(238) :: The word @e(thunk) was invented by an informal working group
     that was discussing the implementation of call-by-name in Algol 60. They
     observed that most of the analysis of (@"(thinking about)) the expression
     could be done at compile time; thus, at run time, the expression would
     already have been @"(thunk) about (@l(#Ingerman et al. 1960)).

  :: @N(239) :: This is analogous to the use of @c(force) on the delayed objects
     that were introduced in @l(#Chapter 3) to represent streams.  The critical
     difference between what we are doing here and what we did in @l(#Chapter 3)
     is that we are building delaying and forcing into the evaluator, and thus
     making this uniform and automatic throughout the language.

  :: @N(240) :: Lazy evaluation combined with memoization is sometimes referred
     to as @e(call-by-need) argument passing, in contrast to @e(call-by-name)
     argument passing.  (Call-by-name, introduced in Algol 60, is similar to
     non-memoized lazy evaluation.)  As language designers, we can build our
     evaluator to memoize, not to memoize, or leave this an option for
     programmers (@l(#Exercise 4.31)). As you might expect from @l(#Chapter 3),
     these choices raise issues that become both subtle and confusing in the
     presence of assignments. (See @l(#Exercise 4.27) and @l(#Exercise 4.29).)
     An excellent article by @l[#Clinger (1982)] attempts to clarify the
     multiple dimensions of confusion that arise here.

  :: @N(241) :: Notice that we also erase the @c(env) from the thunk once the
     expression's value has been computed. This makes no difference in the
     values returned by the interpreter. It does help save space, however,
     because removing the reference from the thunk to the @c(env) once it is no
     longer needed allows this structure to be @e(garbage-collected) and its
     space recycled, as we will discuss in @l(#5.3).

     Similarly, we could have allowed unneeded environments in the memoized
     delayed objects of @l(#3.5.1) to be garbage-collected, by having
     @c(memo-proc) do something like @c[(set! proc '())] to discard the
     procedure @c(proc) (which includes the environment in which the @c(delay)
     was evaluated) after storing its value.

  :: @N(242) :: This exercise demonstrates that the interaction between lazy
     evaluation and side effects can be very confusing. This is just what you
     might expect from the discussion in @l(#Chapter 3).

  :: @N(243) :: This is precisely the issue with the @c(unless) procedure, as in
     @l(#Exercise 4.26).

  :: @N(244) :: This is the procedural representation described in @l(#Exercise
     2.4). Essentially any procedural representation (e.g., a message-passing
     implementation) would do as well. Notice that we can install these
     definitions in the lazy evaluator simply by typing them at the driver
     loop. If we had originally included @c(cons), @c(car), and @c(cdr) as
     primitives in the global environment, they will be redefined. (Also see
     @l(#Exercise 4.33) and @l(#Exercise 4.34).)

  :: @N(245) :: This permits us to create delayed versions of more general kinds
     of list structures, not just sequences. @l(#Hughes 1990) discusses some
     applications of @"(lazy trees.)

  :: @N(246) :: We assume that we have previously defined a procedure @c(prime?)
     that tests whether numbers are prime. Even with @c(prime?) defined, the
     @c(prime-sum-pair) procedure may look suspiciously like the unhelpful
     @"(pseudo-Lisp) attempt to define the square-root function, which we
     described at the beginning of @l(#1.1.7). In fact, a square-root procedure
     along those lines can actually be formulated as a nondeterministic
     program. By incorporating a search mechanism into the evaluator, we are
     eroding the distinction between purely declarative descriptions and
     imperative specifications of how to compute answers. We'll go even farther
     in this direction in @l(#4.4).

  :: @N(247) :: The idea of @c(amb) for nondeterministic programming was first
     described in 1961 by John McCarthy (see @l(#McCarthy 1963)).

  :: @N(248) :: In actuality, the distinction between nondeterministically
     returning a single choice and returning all choices depends somewhat on our
     point of view. From the perspective of the code that uses the value, the
     nondeterministic choice returns a single value. From the perspective of the
     programmer designing the code, the nondeterministic choice potentially
     returns all possible values, and the computation branches so that each
     value is investigated separately.

  :: @N(249) :: One might object that this is a hopelessly inefficient
     mechanism. It might require millions of processors to solve some easily
     stated problem this way, and most of the time most of those processors
     would be idle. This objection should be taken in the context of
     history. Memory used to be considered just such an expensive commodity. In
     1964 a megabyte of @A(RAM) cost about $400,000. Now every personal computer
     has many megabytes of @A(RAM), and most of the time most of that @A(RAM) is
     unused. It is hard to underestimate the cost of mass-produced electronics.

  :: @N(250) :: @t(Footnote 250)Automagically: @"(Automatically, but in a way
     which, for some reason (typically because it is too complicated, or too
     ugly, or perhaps even too trivial), the speaker doesn't feel like
     explaining.)  (@l(#Steele et al. 1983), @l(#Raymond 1993))

  :: @N(251) :: The integration of automatic search strategies into programming
     languages has had a long and checkered history. The first suggestions that
     nondeterministic algorithms might be elegantly encoded in a programming
     language with search and automatic backtracking came from Robert @l(#Floyd
     (1967)). Carl @l[#Hewitt (1969)] invented a programming language called
     Planner that explicitly supported automatic chronological backtracking,
     providing for a built-in depth-first search strategy. @l(#Sussman et
     al. (1971)) implemented a subset of this language, called MicroPlanner,
     which was used to support work in problem solving and robot
     planning. Similar ideas, arising from logic and theorem proving, led to the
     genesis in Edinburgh and Marseille of the elegant language Prolog (which we
     will discuss in @l(#4.4)). After sufficient frustration with automatic
     search, @l(#McDermott and Sussman (1972)) developed a language called
     Conniver, which included mechanisms for placing the search strategy under
     programmer control. This proved unwieldy, however, and @l(#Sussman and
     Stallman 1975) found a more tractable approach while investigating methods
     of symbolic analysis for electrical circuits. They developed a
     non-chronological backtracking scheme that was based on tracing out the
     logical dependencies connecting facts, a technique that has come to be
     known as @e(dependency-directed backtracking). Although their method was
     complex, it produced reasonably efficient programs because it did little
     redundant search. @l[#Doyle (1979)] and @l[#McAllester (1978; 1980)]
     generalized and clarified the methods of Stallman and Sussman, developing a
     new paradigm for formulating search that is now called @e(truth
     maintenance). Modern problem-solving systems all use some form of
     truth-maintenance system as a substrate. See @l(#Forbus and deKleer 1993)
     for a discussion of elegant ways to build truth-maintenance systems and
     applications using truth maintenance.  @l(#Zabih et al. 1987) describes a
     nondeterministic extension to Scheme that is based on @c(amb); it is
     similar to the interpreter described in this section, but more
     sophisticated, because it uses dependency-directed backtracking rather than
     chronological backtracking. @l(#Winston 1992) gives an introduction to both
     kinds of backtracking.

  :: @N(252) :: Our program uses the following procedure to determine if the
     elements of a list are distinct:

     ..src > scheme
       (define (distinct? items)
         (cond ((null? items) true)
               ((null? (cdr items)) true)
               ((member (car items) (cdr items)) false)
               (else (distinct? (cdr items)))))
     < src..

     @c(Member) is like @c(memq) except that it uses @c(equal?) instead of
     @c(eq?) to test for equality.

  :: @N(253) :: This is taken from a booklet called @"(Problematical
     Recreations,) published in the 1960s by Litton Industries, where it is
     attributed to the @q(Kansas State Engineer).

  :: @N(254) :: Here we use the convention that the first element of each list
     designates the part of speech for the rest of the words in the list.

  :: @N(255) :: Notice that @c(parse-word) uses @c(set!) to modify the unparsed
     input list. For this to work, our @c(amb) evaluator must undo the effects
     of @c(set!) operations when it backtracks.

  :: @N(256) :: Observe that this definition is recursive––a verb may be
     followed by any number of prepositional phrases.

  :: @N(257) :: This kind of grammar can become arbitrarily complex, but it is
     only a toy as far as real language understanding is concerned. Real
     natural-language understanding by computer requires an elaborate mixture of
     syntactic analysis and interpretation of meaning. On the other hand, even
     toy parsers can be useful in supporting flexible command languages for
     programs such as information-retrieval systems. @l(#Winston 1992) discusses
     computational approaches to real language understanding and also the
     applications of simple grammars to command languages.

  :: @N(258) :: Although Alyssa's idea works just fine (and is surprisingly
     simple), the sentences that it generates are a bit boring––they don't
     sample the possible sentences of this language in a very interesting way.
     In fact, the grammar is highly recursive in many places, and Alyssa's
     technique @"(falls into) one of these recursions and gets stuck. See
     @l(#Exercise 4.50) for a way to deal with this.

  :: @N(259) :: We chose to implement the lazy evaluator in @l(#4.2) as a
     modification of the ordinary metacircular evaluator of @l(#4.1.1). In
     contrast, we will base the @c(amb) evaluator on the analyzing evaluator of
     @l(#4.1.7), because the execution procedures in that evaluator provide a
     convenient framework for implementing backtracking.

  :: @N(260) :: We assume that the evaluator supports @c(let) (see @l(#Exercise
     4.22)), which we have used in our nondeterministic programs.

  :: @N(261) :: We didn't worry about undoing definitions, since we can assume
     that internal definitions are scanned out (@l(#4.1.6)).

  :: @N(262) :: Logic programming has grown out of a long history of research in
     automatic theorem proving. Early theorem-proving programs could accomplish
     very little, because they exhaustively searched the space of possible
     proofs. The major breakthrough that made such a search plausible was the
     discovery in the early 1960s of the @e(unification algorithm) and the
     @e(resolution principle) (@l(#Robinson 1965)). Resolution was used, for
     example, by @l[#Green and Raphael (1968)] (see also @l(#Green 1969)) as the
     basis for a deductive question-answering system. During most of this
     period, researchers concentrated on algorithms that are guaranteed to find
     a proof if one exists. Such algorithms were difficult to control and to
     direct toward a proof. @l[#Hewitt (1969)] recognized the possibility of
     merging the control structure of a programming language with the operations
     of a logic-manipulation system, leading to the work in automatic search
     mentioned in @l(#4.3.1) (@n(250<>Footnote 250)). At the same time that this
     was being done, Colmerauer, in Marseille, was developing rule-based systems
     for manipulating natural language (see @l(#Colmerauer et al. 1973)). He
     invented a programming language called Prolog for representing those
     rules. @l[#Kowalski (1973; 1979)], in Edinburgh, recognized that execution
     of a Prolog program could be interpreted as proving theorems (using a proof
     technique called linear Horn-clause resolution). The merging of the last
     two strands led to the logic-programming movement. Thus, in assigning
     credit for the development of logic programming, the French can point to
     Prolog's genesis at the University of Marseille, while the British can
     highlight the work at the University of Edinburgh. According to people at
     @A(MIT), logic programming was developed by these groups in an attempt to
     figure out what Hewitt was talking about in his brilliant but impenetrable
     Ph.D. thesis. For a history of logic programming, see @l(#Robinson 1983).

  :: @N(263) :: To see the correspondence between the rules and the procedure,
     let @c(x) in the procedure (where @c(x) is nonempty) correspond to @c[(cons
     u v)] in the rule. Then @c(z) in the rule corresponds to the @c(append) of
     @c[(cdr x)] and @c(y).

  :: @N(264) :: This certainly does not relieve the user of the entire problem
     of how to compute the answer. There are many different mathematically
     equivalent sets of rules for formulating the @c(append) relation, only some
     of which can be turned into effective devices for computing in any
     direction.  In addition, sometimes @"(what is) information gives no clue
     @"(how to) compute an answer. For example, consider the problem of
     computing the @m(y) such that @m(y² = x).

  :: @N(265) :: Interest in logic programming peaked during the early 80s when
     the Japanese government began an ambitious project aimed at building
     superfast computers optimized to run logic programming languages. The speed
     of such computers was to be measured in LIPS (Logical Inferences Per
     Second) rather than the usual FLOPS (FLoating-point Operations Per
     Second). Although the project succeeded in developing hardware and software
     as originally planned, the international computer industry moved in a
     different direction.  See @l(#Feigenbaum and Shrobe 1993) for an overview
     evaluation of the Japanese project. The logic programming community has
     also moved on to consider relational programming based on techniques other
     than simple pattern matching, such as the ability to deal with numerical
     constraints such as the ones illustrated in the constraint-propagation
     system of @l(#3.3.5).

  :: @N(266) :: This uses the dotted-tail notation introduced in @l(#Exercise
     2.20).

  :: @N(267) :: Actually, this description of @c(not) is valid only for simple
     cases. The real behavior of @c(not) is more complex. We will examine
     @c(not)'s peculiarities in @l(#4.4.2) and @l(#4.4.3).

  :: @N(268) :: @c(Lisp-value) should be used only to perform an operation not
     provided in the query language. In particular, it should not be used to
     test equality (since that is what the matching in the query language is
     designed to do) or inequality (since that can be done with the @c(same)
     rule shown below).

  :: @N(269) :: Notice that we do not need @c(same) in order to make two things
     be the same: We just use the same pattern variable for each––in effect, we
     have one thing instead of two things in the first place. For example, see
     @c(?town) in the @c(lives-near) rule and @c(?middle-manager) in the
     @c(wheel) rule below. @c(Same) is useful when we want to force two things
     to be different, such as @c(?person-1) and @c(?person-2) in the
     @c(lives-near) rule. Although using the same pattern variable in two parts
     of a query forces the same value to appear in both places, using different
     pattern variables does not force different values to appear. (The values
     assigned to different pattern variables may be the same or different.)

  :: @N(270) :: We will also allow rules without bodies, as in @c(same), and we
     will interpret such a rule to mean that the rule conclusion is satisfied by
     any values of the variables.

  :: @N(271) :: Because matching is generally very expensive, we would like to
     avoid applying the full matcher to every element of the data base. This is
     usually arranged by breaking up the process into a fast, coarse match and
     the final match. The coarse match filters the data base to produce a small
     set of candidates for the final match. With care, we can arrange our data
     base so that some of the work of coarse matching can be done when the data
     base is constructed rather then when we want to select the candidates. This
     is called @e(indexing) the data base. There is a vast technology built
     around data-base-indexing schemes. Our implementation, described in
     @l(#4.4.4), contains a simple-minded form of such an optimization.

  :: @N(272) :: But this kind of exponential explosion is not common in @c(and)
     queries because the added conditions tend to reduce rather than expand the
     number of frames produced.

  :: @N(273) :: There is a large literature on data-base-management systems that
     is concerned with how to handle complex queries efficiently.

  :: @N(274) :: There is a subtle difference between this filter implementation
     of @c(not) and the usual meaning of @c(not) in mathematical logic. See
     @l(#4.4.3).

  :: @N(275) :: In one-sided pattern matching, all the equations that contain
     pattern variables are explicit and already solved for the unknown (the
     pattern variable).

  :: @N(276) :: Another way to think of unification is that it generates the
     most general pattern that is a specialization of the two input
     patterns. That is, the unification of @c[(?x a)] and @c[((b ?y) ?z)] is
     @c[((b ?y) a)], and the unification of @c[(?x a ?y)] and @c[(?y ?z a)],
     discussed above, is @c[(a a a)]. For our implementation, it is more
     convenient to think of the result of unification as a frame rather than a
     pattern.

  :: @N(277) :: Since unification is a generalization of matching, we could
     simplify the system by using the unifier to produce both streams. Treating
     the easy case with the simple matcher, however, illustrates how matching
     (as opposed to full-blown unification) can be useful in its own right.

  :: @N(278) :: The reason we use streams (rather than lists) of frames is that
     the recursive application of rules can generate infinite numbers of values
     that satisfy a query. The delayed evaluation embodied in streams is crucial
     here: The system will print responses one by one as they are generated,
     regardless of whether there are a finite or infinite number of responses.

  :: @N(279) :: That a particular method of inference is legitimate is not a
     trivial assertion. One must prove that if one starts with true premises,
     only true conclusions can be derived. The method of inference represented
     by rule applications is @e(modus ponens), the familiar method of inference
     that says that if @m(a) is true and @e(A implies B) is true, then we may
     conclude that @m(B) is true.

  :: @N(280) :: We must qualify this statement by agreeing that, in speaking of
     the @"(inference) accomplished by a logic program, we assume that the
     computation terminates.  Unfortunately, even this qualified statement is
     false for our implementation of the query language (and also false for
     programs in Prolog and most other current logic programming languages)
     because of our use of @c(not) and @c(lisp-value). As we will describe
     below, the @c(not) implemented in the query language is not always
     consistent with the @c(not) of mathematical logic, and @c(lisp-value)
     introduces additional complications. We could implement a language
     consistent with mathematical logic by simply removing @c(not) and
     @c(lisp-value) from the language and agreeing to write programs using only
     simple queries, @c(and), and @c(or). However, this would greatly restrict
     the expressive power of the language. One of the major concerns of research
     in logic programming is to find ways to achieve more consistency with
     mathematical logic without unduly sacrificing expressive power.

  :: @N(281) :: This is not a problem of the logic but one of the procedural
     interpretation of the logic provided by our interpreter. We could write an
     interpreter that would not fall into a loop here. For example, we could
     enumerate all the proofs derivable from our assertions and our rules in a
     breadth-first rather than a depth-first order. However, such a system makes
     it more difficult to take advantage of the order of deductions in our
     programs.  One attempt to build sophisticated control into such a program
     is described in @l(#deKleer et al. 1977). Another technique, which does not
     lead to such serious control problems, is to put in special knowledge, such
     as detectors for particular kinds of loops (@l(#Exercise 4.67)). However,
     there can be no general scheme for reliably preventing a system from going
     down infinite paths in performing deductions. Imagine a diabolical rule of
     the form @"(To show @m[P(x)] is true, show that @m[P(f(x))] is true,) for
     some suitably chosen function @m(f).

  :: @N(282) :: Consider the query @c[(not (baseball-fan (Bitdiddle Ben)))]. The
     system finds that @c[(baseball-fan (Bitdiddle Ben))] is not in the data
     base, so the empty frame does not satisfy the pattern and is not filtered
     out of the initial stream of frames. The result of the query is thus the
     empty frame, which is used to instantiate the input query to produce
     @c[(not (baseball-fan (Bitdiddle Ben)))].

  :: @N(283) :: A discussion and justification of this treatment of @c(not) can
     be found in the article by @l[#Clark (1978)].

  :: @N(284) :: In general, unifying @c(?y) with an expression involving @c(?y)
     would require our being able to find a fixed point of the equation @c[?y] =
     @c[(expression involving ?y)]. It is sometimes possible to syntactically
     form an expression that appears to be the solution. For example, @c(?y) =
     @c[(f ?y)] seems to have the fixed point @c[(f (f (f …  )))], which we can
     produce by beginning with the expression @c[(f ?y)] and repeatedly
     substituting @c[(f ?y)] for @c(?y). Unfortunately, not every such equation
     has a meaningful fixed point. The issues that arise here are similar to the
     issues of manipulating infinite series in mathematics. For example, we know
     that 2 is the solution to the equation @m(y = 1 + y / 2). Beginning with
     the expression @m(1 + y / 2) and repeatedly substituting @m(1 + y / 2) for
     @m(y) gives

     ..example >
       2 = y = 1 + y/2 = 1 + (1 + y/2)/2 = 1 + 1/2 + y/4 = ⋯
     < example..

     which leads to

     ..example >
       2 = 1 + 1/2 + 1/4 + 1/8 + ⋯
     < example..

     However, if we try the same manipulation beginning with the observation
     that @m(−1) is the solution to the equation @m(y = 1 + 2y), we obtain

    ..example >
      -1 = y = 1 + 2y = 1 + 2(1 + 2y) = 1 + 2 + 4y = ⋯
    < example..

     which leads to

     ..example >
       -1 = 1 + 2 + 4 + 8 + ⋯
     < example..

     Although the formal manipulations used in deriving these two equations are
     identical, the first result is a valid assertion about infinite series but
     the second is not. Similarly, for our unification results, reasoning with
     an arbitrary syntactically constructed expression may lead to errors.

  :: @N(285) :: Most Lisp systems give the user the ability to modify the
     ordinary @c(read) procedure to perform such transformations by defining
     @e(reader macro characters). Quoted expressions are already handled in this
     way: The reader automatically translates @c('expression) into @c[(quote
     expression)] before the evaluator sees it. We could arrange for
     @c(?expression) to be transformed into @c[(? expression)] in the same way;
     however, for the sake of clarity we have included the transformation
     procedure here explicitly.

     @c(Expand-question-mark) and @c(contract-question-mark) use several
     procedures with @c(string) in their names. These are Scheme primitives.

  :: @N(286) :: This assumption glosses over a great deal of complexity. Usually
     a large portion of the implementation of a Lisp system is dedicated to
     making reading and printing work.

  :: @N(287) :: One might argue that we don't need to save the old @c(n); after
     we decrement it and solve the subproblem, we could simply increment it to
     recover the old value. Although this strategy works for factorial, it
     cannot work in general, since the old value of a register cannot always be
     computed from the new one.

  :: @N(288) :: In @l(#5.3) we will see how to implement a stack in terms of
     more primitive operations.

  :: @N(289) :: Using the @c(receive) procedure here is a way to get
     @c(extract-labels) to effectively return two values––@c(labels) and
     @c(insts)––without explicitly making a compound data structure to hold
     them. An alternative implementation, which returns an explicit pair of
     values, is

     ..src > scheme
       (define (extract-labels text)
         (if (null? text)
             (cons '() '())
             (let ((result
                    (extract-labels (cdr text))))
               (let ((insts (car result))
                     (labels (cdr result)))
                 (let ((next-inst (car text)))
                   (if (symbol? next-inst)
                       (cons
                        insts
                        (cons
                         (make-label-entry
                          next-inst insts)
                         labels))
                       (cons
                        (cons
                         (make-instruction next-inst)
                         insts)
                        labels)))))))
     < src..

     which would be called by @c(assemble) as follows:

     ..src > scheme
       (define (assemble controller-text machine)
         (let ((result
                (extract-labels controller-text)))
           (let ((insts (car result))
                 (labels (cdr result)))
             (update-insts! insts labels machine)
             insts)))
     < src..

     You can consider our use of @c(receive) as demonstrating an elegant way to
     return multiple values, or simply an excuse to show off a programming
     trick.  An argument like @c(receive) that is the next procedure to be
     invoked is called a @"(continuation.)  Recall that we also used
     continuations to implement the backtracking control structure in the
     @c(amb) evaluator in @l(#4.3.3).

  :: @N(290) :: We could represent memory as lists of items. However, the access
     time would then not be independent of the index, since accessing the
     @m(nᵗʰ) element of a list requires @m(n - 1) @c(cdr) operations.

  :: @N(291) :: For completeness, we should specify a @c(make-vector) operation
     that constructs vectors. However, in the present application we will use
     vectors only to model fixed divisions of the computer memory.

  :: @N(292) :: This is precisely the same @"(tagged data) idea we introduced in
     @l(#Chapter 2) for dealing with generic operations. Here, however, the data
     types are included at the primitive machine level rather than constructed
     through the use of lists.

  :: @N(293) :: Type information may be encoded in a variety of ways, depending
     on the details of the machine on which the Lisp system is to be
     implemented. The execution efficiency of Lisp programs will be strongly
     dependent on how cleverly this choice is made, but it is difficult to
     formulate general design rules for good choices. The most straightforward
     way to implement typed pointers is to allocate a fixed set of bits in each
     pointer to be a @e(type field) that encodes the data type.  Important
     questions to be addressed in designing such a representation include the
     following: How many type bits are required?  How large must the vector
     indices be?  How efficiently can the primitive machine instructions be used
     to manipulate the type fields of pointers?  Machines that include special
     hardware for the efficient handling of type fields are said to have
     @e(tagged architectures).

  :: @N(294) :: This decision on the representation of numbers determines
     whether @c(eq?), which tests equality of pointers, can be used to test for
     equality of numbers. If the pointer contains the number itself, then equal
     numbers will have the same pointer. But if the pointer contains the index
     of a location where the number is stored, equal numbers will be guaranteed
     to have equal pointers only if we are careful never to store the same
     number in more than one location.

  :: @N(295) :: This is just like writing a number as a sequence of digits,
     except that each @"(digit) is a number between 0 and the largest number
     that can be stored in a single pointer.

  :: @N(296) :: There are other ways of finding free storage. For example, we
     could link together all the unused pairs into a @e(free list). Our free
     locations are consecutive (and hence can be accessed by incrementing a
     pointer) because we are using a compacting garbage collector, as we will
     see in @l(#5.3.2).

  :: @N(297) :: This is essentially the implementation of @c(cons) in terms of
     @c(set-car!) and @c(set-cdr!), as described in @l(#3.3.1). The operation
     @c(get-new-pair) used in that implementation is realized here by the
     @c(free) pointer.

  :: @N(298) :: This may not be true eventually, because memories may get large
     enough so that it would be impossible to run out of free memory in the
     lifetime of the computer. For example, there are about @m(3⋅10¹³)
     microseconds in a year, so if we were to @c(cons) once per microsecond we
     would need about @m(10¹⁵) cells of memory to build a machine that could
     operate for 30 years without running out of memory. That much memory seems
     absurdly large by today's standards, but it is not physically impossible.
     On the other hand, processors are getting faster and a future computer may
     have large numbers of processors operating in parallel on a single memory,
     so it may be possible to use up memory much faster than we have postulated.

  :: @N(299) :: We assume here that the stack is represented as a list as
     described in @l(#5.3.1), so that items on the stack are accessible via the
     pointer in the stack register.

  :: @N(300) :: This idea was invented and first implemented by Minsky, as part
     of the implementation of Lisp for the PDP-1 at the @A(MIT) Research
     Laboratory of Electronics. It was further developed by @l[#Fenichel and
     Yochelson (1969)] for use in the Lisp implementation for the Multics
     time-sharing system. Later, @l[#Baker (1978)] developed a @"(real-time)
     version of the method, which does not require the computation to stop
     during garbage collection. Baker's idea was extended by Hewitt, Lieberman,
     and Moon (see @l(#Lieberman and Hewitt 1983)) to take advantage of the fact
     that some structure is more volatile and other structure is more permanent.

     An alternative commonly used garbage-collection technique is the
     @e(mark-sweep) method. This consists of tracing all the structure
     accessible from the machine registers and marking each pair we reach. We
     then scan all of memory, and any location that is unmarked is @"(swept up)
     as garbage and made available for reuse. A full discussion of the
     mark-sweep method can be found in @l(#Allen 1978).

     The Minsky-Fenichel-Yochelson algorithm is the dominant algorithm in use
     for large-memory systems because it examines only the useful part of
     memory. This is in contrast to mark-sweep, in which the sweep phase must
     check all of memory. A second advantage of stop-and-copy is that it is a
     @e(compacting) garbage collector. That is, at the end of the
     garbage-collection phase the useful data will have been moved to
     consecutive memory locations, with all garbage pairs compressed out. This
     can be an extremely important performance consideration in machines with
     virtual memory, in which accesses to widely separated memory addresses may
     require extra paging operations.

  :: @N(301) :: This list of registers does not include the registers used by
     the storage-allocation system––@c(root), @c(the-cars), @c(the-cdrs), and
     the other registers that will be introduced in this section.

  :: @N(302) :: The term @e(broken heart) was coined by David Cressey, who wrote
     a garbage collector for MDL, a dialect of Lisp developed at @A(MIT) during
     the early 1970s.

  :: @N(303) :: The garbage collector uses the low-level predicate
     @c(pointer-to-pair?) instead of the list-structure @c(pair?)  operation
     because in a real system there might be various things that are treated as
     pairs for garbage-collection purposes. For example, in a Scheme system that
     conforms to the @A(IEEE) standard a procedure object may be implemented as
     a special kind of @"(pair) that doesn't satisfy the @c(pair?) predicate.
     For simulation purposes, @c(pointer-to-pair?) can be implemented as
     @c(pair?).

  :: @N(304) :: See @l(#Batali et al. 1982) for more information on the chip and
     the method by which it was designed.

  :: @N(305) :: In our controller, the dispatch is written as a sequence of
     @c(test) and @c(branch) instructions. Alternatively, it could have been
     written in a data-directed style (and in a real system it probably would
     have been) to avoid the need to perform sequential tests and to facilitate
     the definition of new expression types. A machine designed to run Lisp
     would probably include a @c(dispatch-on-type) instruction that would
     efficiently execute such data-directed dispatches.

  :: @N(306) :: This is an important but subtle point in translating algorithms
     from a procedural language, such as Lisp, to a register-machine
     language. As an alternative to saving only what is needed, we could save
     all the registers (except @c(val)) before each recursive call. This is
     called a @e(framed-stack) discipline.  This would work but might save more
     registers than necessary; this could be an important consideration in a
     system where stack operations are expensive.  Saving registers whose
     contents will not be needed later may also hold onto useless data that
     could otherwise be garbage-collected, freeing space to be reused.

  :: @N(307) :: We add to the evaluator data-structure procedures in @l(#4.1.3)
     the following two procedures for manipulating argument lists:

     ..src > scheme
       (define (empty-arglist) '())
       (define (adjoin-arg arg arglist)
         (append arglist (list arg)))
     < src..

     We also use an additional syntax procedure to test for the last operand in
     a combination:

     ..src > scheme
       (define (last-operand? ops) (null? (cdr ops)))
     < src..

  :: @N(308) :: The optimization of treating the last operand specially is known
     as @e(evlis tail recursion) (see @l(#Wand 1980)). We could be somewhat more
     efficient in the argument evaluation loop if we made evaluation of the
     first operand a special case too. This would permit us to postpone
     initializing @c(argl) until after evaluating the first operand, so as to
     avoid saving @c(argl) in this case. The compiler in @l(#5.5) performs this
     optimization. (Compare the @c(construct-arglist) procedure of @l(#5.5.3).)

  :: @N(309) :: The order of operand evaluation in the metacircular evaluator is
     determined by the order of evaluation of the arguments to @c(cons) in the
     procedure @c(list-of-values) of @l(#4.1.1) (see @l(#Exercise 4.1)).

  :: @N(310) :: We saw in @l(#5.1) how to implement such a process with a
     register machine that had no stack; the state of the process was stored in
     a fixed set of registers.

  :: @N(311) :: This implementation of tail recursion in @c(ev-sequence) is one
     variety of a well-known optimization technique used by many compilers. In
     compiling a procedure that ends with a procedure call, one can replace the
     call by a jump to the called procedure's entry point.  Building this
     strategy into the interpreter, as we have done in this section, provides
     the optimization uniformly throughout the language.

  :: @N(312) :: We can define @c(no-more-exps?) as follows:

     ..src > scheme
       (define (no-more-exps? seq) (null? seq))
     < src..

  :: @N(313) :: This isn't really cheating. In an actual implementation built
     from scratch, we would use our explicit-control evaluator to interpret a
     Scheme program that performs source-level transformations like @c(cond->if)
     in a syntax phase that runs before execution.

  :: @N(314) :: We assume here that @c(read) and the various printing operations
     are available as primitive machine operations, which is useful for our
     simulation, but completely unrealistic in practice. These are actually
     extremely complex operations. In practice, they would be implemented using
     low-level input-output operations such as transferring single characters to
     and from a device.

     To support the @c(get-global-environment) operation we define

     ..src > scheme
       (define the-global-environment
         (setup-environment))

       (define (get-global-environment)
         the-global-environment)
     < src..

  :: @N(315) :: There are other errors that we would like the interpreter to
     handle, but these are not so simple. See @l(#Exercise 5.30).

  :: @N(316) :: We could perform the stack initialization only after errors, but
     doing it in the driver loop will be convenient for monitoring the
     evaluator's performance, as described below.

  :: @N(317) :: Regrettably, this is the normal state of affairs in conventional
     compiler-based language systems such as C. In @A(UNIX)(tm) the system
     @"(dumps core,) and in @A(DOS)/Windows(tm) it becomes catatonic. The
     Macintosh(tm) displays a picture of an exploding bomb and offers you the
     opportunity to reboot the computer––if you're lucky.

  :: @N(318) :: This is a theoretical statement. We are not claiming that the
     evaluator's data paths are a particularly convenient or efficient set of
     data paths for a general-purpose computer. For example, they are not very
     good for implementing high-performance floating-point calculations or
     calculations that intensively manipulate bit vectors.

  :: @N(319) :: Actually, the machine that runs compiled code can be simpler
     than the interpreter machine, because we won't use the @c(exp) and @c(unev)
     registers. The interpreter used these to hold pieces of unevaluated
     expressions. With the compiler, however, these expressions get built into
     the compiled code that the register machine will run. For the same reason,
     we don't need the machine operations that deal with expression syntax.  But
     compiled code will use a few additional machine operations (to represent
     compiled procedure objects) that didn't appear in the explicit-control
     evaluator machine.

  :: @N(320) :: Notice, however, that our compiler is a Scheme program, and the
     syntax procedures that it uses to manipulate expressions are the actual
     Scheme procedures used with the metacircular evaluator. For the
     explicit-control evaluator, in contrast, we assumed that equivalent syntax
     operations were available as operations for the register machine. (Of
     course, when we simulated the register machine in Scheme, we used the
     actual Scheme procedures in our register machine simulation.)

  :: @N(321) :: This procedure uses a feature of Lisp called @e(backquote) (or
     @e(quasiquote)) that is handy for constructing lists. Preceding a list with
     a backquote symbol is much like quoting it, except that anything in the
     list that is flagged with a comma is evaluated.

     For example, if the value of @c(linkage) is the symbol @c(branch25), then
     the expression

     ..src > scheme
       `((goto (label ,linkage)))
     < src..

     evaluates to the list

     ..src > scheme
       ((goto (label branch25)))
     < src..

     Similarly, if the value of @c(x) is the list @c[(a b c)], then

     ..src > scheme
       `(1 2 ,(car x))
     < src..

     evaluates to the list

     ..src > scheme
       (1 2 a)
     < src..


  :: @N(322) :: We can't just use the labels @c(true-branch), @c(false-branch),
     and @c(after-if) as shown above, because there might be more than one
     @c(if) in the program. The compiler uses the procedure @c(make-label) to
     generate labels. @c(Make-label) takes a symbol as argument and returns a
     new symbol that begins with the given symbol. For example, successive calls
     to @c[(make-label 'a)] would return @c(a1), @c(a2), and so
     on. @c(Make-label) can be implemented similarly to the generation of unique
     variable names in the query language, as follows:

     ..src > scheme
       (define label-counter 0)

       (define (new-label-number)
         (set! label-counter (+ 1 label-counter))
         label-counter)

       (define (make-label name)
         (string->symbol
          (string-append
           (symbol->string name)
           (number->string (new-label-number)))))
     < src..

  :: @N(323) :: @t(Footnote 323) We need machine operations to implement a data
     structure for representing compiled procedures, analogous to the structure
     for compound procedures described in @l(#4.1.3):

     ..src > scheme
       (define (make-compiled-procedure entry env)
         (list 'compiled-procedure entry env))
       (define (compiled-procedure? proc)
         (tagged-list? proc 'compiled-procedure))
       (define (compiled-procedure-entry c-proc)
         (cadr c-proc))
       (define (compiled-procedure-env c-proc)
         (caddr c-proc))
     < src..

  :: @N(324) :: Actually, we signal an error when the target is not @c(val) and
     the linkage is @c(return), since the only place we request @c(return)
     linkages is in compiling procedures, and our convention is that procedures
     return their values in @c(val).

  :: @N(325) :: Making a compiler generate tail-recursive code might seem like a
     straightforward idea. But most compilers for common languages, including C
     and Pascal, do not do this, and therefore these languages cannot represent
     iterative processes in terms of procedure call alone. The difficulty with
     tail recursion in these languages is that their implementations use the
     stack to store procedure arguments and local variables as well as return
     addresses. The Scheme implementations described in this book store
     arguments and variables in memory to be garbage-collected. The reason for
     using the stack for variables and arguments is that it avoids the need for
     garbage collection in languages that would not otherwise require it, and is
     generally believed to be more efficient. Sophisticated Lisp compilers can,
     in fact, use the stack for arguments without destroying tail
     recursion. (See @l(#Hanson 1990) for a description.)  There is also some
     debate about whether stack allocation is actually more efficient than
     garbage collection in the first place, but the details seem to hinge on
     fine points of computer architecture. (See @l(#Appel 1987) and @l(#Miller
     and Rozas 1994) for opposing views on this issue.)

  :: @N(326) :: The variable @c(all-regs) is bound to the list of names of all
     the registers:

     ..src > scheme
       (define all-regs '(env proc val argl continue))
     < src..

  :: @N(327) :: Note that @c(preserving) calls @c(append) with three
     arguments. Though the definition of @c(append) shown in this book accepts
     only two arguments, Scheme standardly provides an @c(append) procedure that
     takes an arbitrary number of arguments.

  :: @N(328) :: We have used the same symbol @c(+) here to denote both the
     source-language procedure and the machine operation. In general there will
     not be a one-to-one correspondence between primitives of the source
     language and primitives of the machine.

  :: @N(329) :: Making the primitives into reserved words is in general a bad
     idea, since a user cannot then rebind these names to different procedures.
     Moreover, if we add reserved words to a compiler that is in use, existing
     programs that define procedures with these names will stop working. See
     @l(#Exercise 5.44) for ideas on how to avoid this problem.

  :: @N(330) :: This is not true if we allow internal definitions, unless we
     scan them out. See @l(#Exercise 5.43).

  :: @N(331) :: This is the modification to variable lookup required if we
     implement the scanning method to eliminate internal definitions
     (@l(#Exercise 5.43)). We will need to eliminate these definitions in order
     for lexical addressing to work.

  :: @N(332) :: Lexical addresses cannot be used to access variables in the
     global environment, because these names can be defined and redefined
     interactively at any time. With internal definitions scanned out, as in
     @l(#Exercise 5.43), the only definitions the compiler sees are those at top
     level, which act on the global environment. Compilation of a definition
     does not cause the defined name to be entered in the compile-time
     environment.

  :: @N(333) :: Of course, compiled procedures as well as interpreted procedures
     are compound (nonprimitive). For compatibility with the terminology used in
     the explicit-control evaluator, in this section we will use @"(compound) to
     mean interpreted (as opposed to compiled).

  :: @N(334) :: Now that the evaluator machine starts with a @c(branch), we must
     always initialize the @c(flag) register before starting the evaluator
     machine. To start the machine at its ordinary read-eval-print loop, we
     could use

     ..src > scheme
       (define (start-eceval)
         (set! the-global-environment
               (setup-environment))
         (set-register-contents! eceval 'flag false)
         (start eceval))
     < src..

  :: @N(335) :: Since a compiled procedure is an object that the system may try
     to print, we also modify the system print operation @c(user-print) (from
     @l(#4.1.4)) so that it will not attempt to print the components of a
     compiled procedure:

     ..src > scheme
       (define (user-print object)
         (cond ((compound-procedure? object)
                (display
                 (list 'compound-procedure
                       (procedure-parameters object)
                       (procedure-body object)
                       '<procedure-env>)))
               ((compiled-procedure? object)
                (display '<compiled-procedure>))
               (else (display object))))
     < src..


  :: @N(336) :: We can do even better by extending the compiler to allow
     compiled code to call interpreted procedures. See @l(#Exercise 5.47).

  :: @N(337) :: Independent of the strategy of execution, we incur significant
     overhead if we insist that errors encountered in execution of a user
     program be detected and signaled, rather than being allowed to kill the
     system or produce wrong answers. For example, an out-of-bounds array
     reference can be detected by checking the validity of the reference before
     performing it. The overhead of checking, however, can be many times the
     cost of the array reference itself, and a programmer should weigh speed
     against safety in determining whether such a check is desirable. A good
     compiler should be able to produce code with such checks, should avoid
     redundant checks, and should allow programmers to control the extent and
     type of error checking in the compiled code.

     Compilers for popular languages, such as C and C++, put hardly any
     error-checking operations into running code, so as to make things run as
     fast as possible. As a result, it falls to programmers to explicitly
     provide error checking. Unfortunately, people often neglect to do this,
     even in critical applications where speed is not a constraint. Their
     programs lead fast and dangerous lives. For example, the notorious @"(Worm)
     that paralyzed the Internet in 1988 exploited the @A(UNIX)ᵀᴹ operating
     system's failure to check whether the input buffer has overflowed in the
     finger daemon. (See @l(#Spafford 1989).)

  :: @N(338) :: Of course, with either the interpretation or the compilation
     strategy we must also implement for the new machine storage allocation,
     input and output, and all the various operations that we took as
     @"(primitive) in our discussion of the evaluator and compiler. One strategy
     for minimizing work here is to write as many of these operations as
     possible in Lisp and then compile them for the new machine. Ultimately,
     everything reduces to a small kernel (such as garbage collection and the
     mechanism for applying actual machine primitives) that is hand-coded for
     the new machine.

  :: @N(339) :: This strategy leads to amusing tests of correctness of the
     compiler, such as checking whether the compilation of a program on the new
     machine, using the compiled compiler, is identical with the compilation of
     the program on the original Lisp system. Tracking down the source of
     differences is fun but often frustrating, because the results are extremely
     sensitive to minuscule details.
